// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STAGE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STAGE_TYPE: i32 = 10;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STAGE_TYPE: [enum__Torappu_StageType; 11] = [
    enum__Torappu_StageType::MAIN,
    enum__Torappu_StageType::DAILY,
    enum__Torappu_StageType::TRAINING,
    enum__Torappu_StageType::ACTIVITY,
    enum__Torappu_StageType::GUIDE,
    enum__Torappu_StageType::SUB,
    enum__Torappu_StageType::CAMPAIGN,
    enum__Torappu_StageType::SPECIAL_STORY,
    enum__Torappu_StageType::HANDBOOK_BATTLE,
    enum__Torappu_StageType::CLIMB_TOWER,
    enum__Torappu_StageType::ENUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StageType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StageType {
    pub const MAIN: Self = Self(0);
    pub const DAILY: Self = Self(1);
    pub const TRAINING: Self = Self(2);
    pub const ACTIVITY: Self = Self(3);
    pub const GUIDE: Self = Self(4);
    pub const SUB: Self = Self(5);
    pub const CAMPAIGN: Self = Self(6);
    pub const SPECIAL_STORY: Self = Self(7);
    pub const HANDBOOK_BATTLE: Self = Self(8);
    pub const CLIMB_TOWER: Self = Self(9);
    pub const ENUM: Self = Self(10);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 10;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::MAIN,
        Self::DAILY,
        Self::TRAINING,
        Self::ACTIVITY,
        Self::GUIDE,
        Self::SUB,
        Self::CAMPAIGN,
        Self::SPECIAL_STORY,
        Self::HANDBOOK_BATTLE,
        Self::CLIMB_TOWER,
        Self::ENUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MAIN => Some("MAIN"),
            Self::DAILY => Some("DAILY"),
            Self::TRAINING => Some("TRAINING"),
            Self::ACTIVITY => Some("ACTIVITY"),
            Self::GUIDE => Some("GUIDE"),
            Self::SUB => Some("SUB"),
            Self::CAMPAIGN => Some("CAMPAIGN"),
            Self::SPECIAL_STORY => Some("SPECIAL_STORY"),
            Self::HANDBOOK_BATTLE => Some("HANDBOOK_BATTLE"),
            Self::CLIMB_TOWER => Some("CLIMB_TOWER"),
            Self::ENUM => Some("ENUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StageType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StageType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StageType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StageType {
    type Output = enum__Torappu_StageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StageType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StageType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StageType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: i32 = 15;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: [enum__Torappu_LevelData_Difficulty; 6] = [
    enum__Torappu_LevelData_Difficulty::NONE,
    enum__Torappu_LevelData_Difficulty::NORMAL,
    enum__Torappu_LevelData_Difficulty::FOUR_STAR,
    enum__Torappu_LevelData_Difficulty::EASY,
    enum__Torappu_LevelData_Difficulty::SIX_STAR,
    enum__Torappu_LevelData_Difficulty::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_LevelData_Difficulty(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_LevelData_Difficulty {
    pub const NONE: Self = Self(0);
    pub const NORMAL: Self = Self(1);
    pub const FOUR_STAR: Self = Self(2);
    pub const EASY: Self = Self(4);
    pub const SIX_STAR: Self = Self(8);
    pub const ALL: Self = Self(15);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 15;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::NORMAL,
        Self::FOUR_STAR,
        Self::EASY,
        Self::SIX_STAR,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NORMAL => Some("NORMAL"),
            Self::FOUR_STAR => Some("FOUR_STAR"),
            Self::EASY => Some("EASY"),
            Self::SIX_STAR => Some("SIX_STAR"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_LevelData_Difficulty {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_LevelData_Difficulty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_LevelData_Difficulty",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_LevelData_Difficulty {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_LevelData_Difficulty {
    type Output = enum__Torappu_LevelData_Difficulty;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_LevelData_Difficulty {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_LevelData_Difficulty {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_LevelData_Difficulty {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STAGE_DATA_PERFORMANCE_STAGE_FLAG: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STAGE_DATA_PERFORMANCE_STAGE_FLAG: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STAGE_DATA_PERFORMANCE_STAGE_FLAG:
    [enum__Torappu_StageData_PerformanceStageFlag; 2] = [
    enum__Torappu_StageData_PerformanceStageFlag::NORMAL_STAGE,
    enum__Torappu_StageData_PerformanceStageFlag::PERFORMANCE_STAGE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StageData_PerformanceStageFlag(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StageData_PerformanceStageFlag {
    pub const NORMAL_STAGE: Self = Self(0);
    pub const PERFORMANCE_STAGE: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NORMAL_STAGE, Self::PERFORMANCE_STAGE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL_STAGE => Some("NORMAL_STAGE"),
            Self::PERFORMANCE_STAGE => Some("PERFORMANCE_STAGE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StageData_PerformanceStageFlag {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StageData_PerformanceStageFlag {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StageData_PerformanceStageFlag",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StageData_PerformanceStageFlag {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StageData_PerformanceStageFlag {
    type Output = enum__Torappu_StageData_PerformanceStageFlag;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StageData_PerformanceStageFlag {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StageData_PerformanceStageFlag {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StageData_PerformanceStageFlag {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STAGE_DIFF_GROUP: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STAGE_DIFF_GROUP: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STAGE_DIFF_GROUP: [enum__Torappu_StageDiffGroup; 5] = [
    enum__Torappu_StageDiffGroup::NONE,
    enum__Torappu_StageDiffGroup::EASY,
    enum__Torappu_StageDiffGroup::NORMAL,
    enum__Torappu_StageDiffGroup::TOUGH,
    enum__Torappu_StageDiffGroup::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StageDiffGroup(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StageDiffGroup {
    pub const NONE: Self = Self(0);
    pub const EASY: Self = Self(1);
    pub const NORMAL: Self = Self(2);
    pub const TOUGH: Self = Self(4);
    pub const ALL: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::EASY, Self::NORMAL, Self::TOUGH, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::EASY => Some("EASY"),
            Self::NORMAL => Some("NORMAL"),
            Self::TOUGH => Some("TOUGH"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StageDiffGroup {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StageDiffGroup {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StageDiffGroup",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StageDiffGroup {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StageDiffGroup {
    type Output = enum__Torappu_StageDiffGroup;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StageDiffGroup {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StageDiffGroup {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StageDiffGroup {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PLAYER_BATTLE_RANK: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PLAYER_BATTLE_RANK: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PLAYER_BATTLE_RANK: [enum__Torappu_PlayerBattleRank; 4] = [
    enum__Torappu_PlayerBattleRank::ERR_ZERO,
    enum__Torappu_PlayerBattleRank::FAIL,
    enum__Torappu_PlayerBattleRank::PASS,
    enum__Torappu_PlayerBattleRank::COMPLETE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_PlayerBattleRank(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_PlayerBattleRank {
    pub const ERR_ZERO: Self = Self(0);
    pub const FAIL: Self = Self(1);
    pub const PASS: Self = Self(2);
    pub const COMPLETE: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::ERR_ZERO, Self::FAIL, Self::PASS, Self::COMPLETE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ERR_ZERO => Some("ERR_ZERO"),
            Self::FAIL => Some("FAIL"),
            Self::PASS => Some("PASS"),
            Self::COMPLETE => Some("COMPLETE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_PlayerBattleRank {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_PlayerBattleRank {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_PlayerBattleRank",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_PlayerBattleRank {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_PlayerBattleRank {
    type Output = enum__Torappu_PlayerBattleRank;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_PlayerBattleRank {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_PlayerBattleRank {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_PlayerBattleRank {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_APPEARANCE_STYLE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_APPEARANCE_STYLE: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_APPEARANCE_STYLE: [enum__Torappu_AppearanceStyle; 7] = [
    enum__Torappu_AppearanceStyle::MAIN_NORMAL,
    enum__Torappu_AppearanceStyle::MAIN_PREDEFINED,
    enum__Torappu_AppearanceStyle::SUB,
    enum__Torappu_AppearanceStyle::TRAINING,
    enum__Torappu_AppearanceStyle::HIGH_DIFFICULTY,
    enum__Torappu_AppearanceStyle::MIST_OPS,
    enum__Torappu_AppearanceStyle::SPECIAL_STORY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_AppearanceStyle(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_AppearanceStyle {
    pub const MAIN_NORMAL: Self = Self(0);
    pub const MAIN_PREDEFINED: Self = Self(1);
    pub const SUB: Self = Self(2);
    pub const TRAINING: Self = Self(3);
    pub const HIGH_DIFFICULTY: Self = Self(4);
    pub const MIST_OPS: Self = Self(5);
    pub const SPECIAL_STORY: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::MAIN_NORMAL,
        Self::MAIN_PREDEFINED,
        Self::SUB,
        Self::TRAINING,
        Self::HIGH_DIFFICULTY,
        Self::MIST_OPS,
        Self::SPECIAL_STORY,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MAIN_NORMAL => Some("MAIN_NORMAL"),
            Self::MAIN_PREDEFINED => Some("MAIN_PREDEFINED"),
            Self::SUB => Some("SUB"),
            Self::TRAINING => Some("TRAINING"),
            Self::HIGH_DIFFICULTY => Some("HIGH_DIFFICULTY"),
            Self::MIST_OPS => Some("MIST_OPS"),
            Self::SPECIAL_STORY => Some("SPECIAL_STORY"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_AppearanceStyle {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_AppearanceStyle {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_AppearanceStyle",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_AppearanceStyle {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_AppearanceStyle {
    type Output = enum__Torappu_AppearanceStyle;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_AppearanceStyle {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_AppearanceStyle {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_AppearanceStyle {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_TYPE: i32 = 90;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_TYPE: [enum__Torappu_ItemType; 91] = [
    enum__Torappu_ItemType::NONE,
    enum__Torappu_ItemType::CHAR,
    enum__Torappu_ItemType::CARD_EXP,
    enum__Torappu_ItemType::MATERIAL,
    enum__Torappu_ItemType::GOLD,
    enum__Torappu_ItemType::EXP_PLAYER,
    enum__Torappu_ItemType::TKT_TRY,
    enum__Torappu_ItemType::TKT_RECRUIT,
    enum__Torappu_ItemType::TKT_INST_FIN,
    enum__Torappu_ItemType::TKT_GACHA,
    enum__Torappu_ItemType::ACTIVITY_COIN,
    enum__Torappu_ItemType::DIAMOND,
    enum__Torappu_ItemType::DIAMOND_SHD,
    enum__Torappu_ItemType::HGG_SHD,
    enum__Torappu_ItemType::LGG_SHD,
    enum__Torappu_ItemType::FURN,
    enum__Torappu_ItemType::AP_GAMEPLAY,
    enum__Torappu_ItemType::AP_BASE,
    enum__Torappu_ItemType::SOCIAL_PT,
    enum__Torappu_ItemType::CHAR_SKIN,
    enum__Torappu_ItemType::TKT_GACHA_10,
    enum__Torappu_ItemType::TKT_GACHA_PRSV,
    enum__Torappu_ItemType::AP_ITEM,
    enum__Torappu_ItemType::AP_SUPPLY,
    enum__Torappu_ItemType::RENAMING_CARD,
    enum__Torappu_ItemType::RENAMING_CARD_2,
    enum__Torappu_ItemType::ET_STAGE,
    enum__Torappu_ItemType::ACTIVITY_ITEM,
    enum__Torappu_ItemType::VOUCHER_PICK,
    enum__Torappu_ItemType::VOUCHER_CGACHA,
    enum__Torappu_ItemType::VOUCHER_MGACHA,
    enum__Torappu_ItemType::CRS_SHOP_COIN,
    enum__Torappu_ItemType::CRS_RUNE_COIN,
    enum__Torappu_ItemType::LMTGS_COIN,
    enum__Torappu_ItemType::EPGS_COIN,
    enum__Torappu_ItemType::LIMITED_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_FREE_GACHA,
    enum__Torappu_ItemType::REP_COIN,
    enum__Torappu_ItemType::ROGUELIKE,
    enum__Torappu_ItemType::LINKAGE_TKT_GACHA_10,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_4,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_5,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_6,
    enum__Torappu_ItemType::VOUCHER_SKIN,
    enum__Torappu_ItemType::RETRO_COIN,
    enum__Torappu_ItemType::PLAYER_AVATAR,
    enum__Torappu_ItemType::UNI_COLLECTION,
    enum__Torappu_ItemType::VOUCHER_FULL_POTENTIAL,
    enum__Torappu_ItemType::RL_COIN,
    enum__Torappu_ItemType::RETURN_CREDIT,
    enum__Torappu_ItemType::MEDAL,
    enum__Torappu_ItemType::CHARM,
    enum__Torappu_ItemType::HOME_BACKGROUND,
    enum__Torappu_ItemType::EXTERMINATION_AGENT,
    enum__Torappu_ItemType::OPTIONAL_VOUCHER_PICK,
    enum__Torappu_ItemType::ACT_CART_COMPONENT,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_4,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_4,
    enum__Torappu_ItemType::ACTIVITY_POTENTIAL,
    enum__Torappu_ItemType::ITEM_PACK,
    enum__Torappu_ItemType::SANDBOX,
    enum__Torappu_ItemType::FAVOR_ADD_ITEM,
    enum__Torappu_ItemType::CLASSIC_SHD,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_BUFF,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_5,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_6,
    enum__Torappu_ItemType::RETURN_PROGRESS,
    enum__Torappu_ItemType::NEW_PROGRESS,
    enum__Torappu_ItemType::MCARD_VOUCHER,
    enum__Torappu_ItemType::MATERIAL_ISSUE_VOUCHER,
    enum__Torappu_ItemType::CRS_SHOP_COIN_V2,
    enum__Torappu_ItemType::HOME_THEME,
    enum__Torappu_ItemType::SANDBOX_PERM,
    enum__Torappu_ItemType::SANDBOX_TOKEN,
    enum__Torappu_ItemType::TEMPLATE_TRAP,
    enum__Torappu_ItemType::NAME_CARD_SKIN,
    enum__Torappu_ItemType::EMOTICON_SET,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA_10,
    enum__Torappu_ItemType::SO_CHAR_EXP,
    enum__Torappu_ItemType::GIFTPACKAGE_TKT,
    enum__Torappu_ItemType::VOUCHER_SKIN_V2,
    enum__Torappu_ItemType::RANDOM_VOUCHER_SKIN,
    enum__Torappu_ItemType::ACT1VHALFIDLE_ITEM,
    enum__Torappu_ItemType::PLOT_ITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemType {
    pub const NONE: Self = Self(0);
    pub const CHAR: Self = Self(1);
    pub const CARD_EXP: Self = Self(2);
    pub const MATERIAL: Self = Self(3);
    pub const GOLD: Self = Self(4);
    pub const EXP_PLAYER: Self = Self(5);
    pub const TKT_TRY: Self = Self(6);
    pub const TKT_RECRUIT: Self = Self(7);
    pub const TKT_INST_FIN: Self = Self(8);
    pub const TKT_GACHA: Self = Self(9);
    pub const ACTIVITY_COIN: Self = Self(10);
    pub const DIAMOND: Self = Self(11);
    pub const DIAMOND_SHD: Self = Self(12);
    pub const HGG_SHD: Self = Self(13);
    pub const LGG_SHD: Self = Self(14);
    pub const FURN: Self = Self(15);
    pub const AP_GAMEPLAY: Self = Self(16);
    pub const AP_BASE: Self = Self(17);
    pub const SOCIAL_PT: Self = Self(18);
    pub const CHAR_SKIN: Self = Self(19);
    pub const TKT_GACHA_10: Self = Self(20);
    pub const TKT_GACHA_PRSV: Self = Self(21);
    pub const AP_ITEM: Self = Self(22);
    pub const AP_SUPPLY: Self = Self(23);
    pub const RENAMING_CARD: Self = Self(24);
    pub const RENAMING_CARD_2: Self = Self(25);
    pub const ET_STAGE: Self = Self(26);
    pub const ACTIVITY_ITEM: Self = Self(27);
    pub const VOUCHER_PICK: Self = Self(28);
    pub const VOUCHER_CGACHA: Self = Self(29);
    pub const VOUCHER_MGACHA: Self = Self(30);
    pub const CRS_SHOP_COIN: Self = Self(31);
    pub const CRS_RUNE_COIN: Self = Self(32);
    pub const LMTGS_COIN: Self = Self(33);
    pub const EPGS_COIN: Self = Self(34);
    pub const LIMITED_TKT_GACHA_10: Self = Self(35);
    pub const LIMITED_FREE_GACHA: Self = Self(36);
    pub const REP_COIN: Self = Self(37);
    pub const ROGUELIKE: Self = Self(38);
    pub const LINKAGE_TKT_GACHA_10: Self = Self(39);
    pub const VOUCHER_ELITE_II_4: Self = Self(40);
    pub const VOUCHER_ELITE_II_5: Self = Self(41);
    pub const VOUCHER_ELITE_II_6: Self = Self(42);
    pub const VOUCHER_SKIN: Self = Self(43);
    pub const RETRO_COIN: Self = Self(44);
    pub const PLAYER_AVATAR: Self = Self(45);
    pub const UNI_COLLECTION: Self = Self(46);
    pub const VOUCHER_FULL_POTENTIAL: Self = Self(47);
    pub const RL_COIN: Self = Self(48);
    pub const RETURN_CREDIT: Self = Self(49);
    pub const MEDAL: Self = Self(50);
    pub const CHARM: Self = Self(51);
    pub const HOME_BACKGROUND: Self = Self(52);
    pub const EXTERMINATION_AGENT: Self = Self(53);
    pub const OPTIONAL_VOUCHER_PICK: Self = Self(54);
    pub const ACT_CART_COMPONENT: Self = Self(55);
    pub const VOUCHER_LEVELMAX_6: Self = Self(56);
    pub const VOUCHER_LEVELMAX_5: Self = Self(57);
    pub const VOUCHER_LEVELMAX_4: Self = Self(58);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_6: Self = Self(59);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_5: Self = Self(60);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_4: Self = Self(61);
    pub const ACTIVITY_POTENTIAL: Self = Self(62);
    pub const ITEM_PACK: Self = Self(63);
    pub const SANDBOX: Self = Self(64);
    pub const FAVOR_ADD_ITEM: Self = Self(65);
    pub const CLASSIC_SHD: Self = Self(66);
    pub const CLASSIC_TKT_GACHA: Self = Self(67);
    pub const CLASSIC_TKT_GACHA_10: Self = Self(68);
    pub const LIMITED_BUFF: Self = Self(69);
    pub const CLASSIC_FES_PICK_TIER_5: Self = Self(70);
    pub const CLASSIC_FES_PICK_TIER_6: Self = Self(71);
    pub const RETURN_PROGRESS: Self = Self(72);
    pub const NEW_PROGRESS: Self = Self(73);
    pub const MCARD_VOUCHER: Self = Self(74);
    pub const MATERIAL_ISSUE_VOUCHER: Self = Self(75);
    pub const CRS_SHOP_COIN_V2: Self = Self(76);
    pub const HOME_THEME: Self = Self(77);
    pub const SANDBOX_PERM: Self = Self(78);
    pub const SANDBOX_TOKEN: Self = Self(79);
    pub const TEMPLATE_TRAP: Self = Self(80);
    pub const NAME_CARD_SKIN: Self = Self(81);
    pub const EMOTICON_SET: Self = Self(82);
    pub const EXCLUSIVE_TKT_GACHA: Self = Self(83);
    pub const EXCLUSIVE_TKT_GACHA_10: Self = Self(84);
    pub const SO_CHAR_EXP: Self = Self(85);
    pub const GIFTPACKAGE_TKT: Self = Self(86);
    pub const VOUCHER_SKIN_V2: Self = Self(87);
    pub const RANDOM_VOUCHER_SKIN: Self = Self(88);
    pub const ACT1VHALFIDLE_ITEM: Self = Self(89);
    pub const PLOT_ITEM: Self = Self(90);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 90;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CHAR,
        Self::CARD_EXP,
        Self::MATERIAL,
        Self::GOLD,
        Self::EXP_PLAYER,
        Self::TKT_TRY,
        Self::TKT_RECRUIT,
        Self::TKT_INST_FIN,
        Self::TKT_GACHA,
        Self::ACTIVITY_COIN,
        Self::DIAMOND,
        Self::DIAMOND_SHD,
        Self::HGG_SHD,
        Self::LGG_SHD,
        Self::FURN,
        Self::AP_GAMEPLAY,
        Self::AP_BASE,
        Self::SOCIAL_PT,
        Self::CHAR_SKIN,
        Self::TKT_GACHA_10,
        Self::TKT_GACHA_PRSV,
        Self::AP_ITEM,
        Self::AP_SUPPLY,
        Self::RENAMING_CARD,
        Self::RENAMING_CARD_2,
        Self::ET_STAGE,
        Self::ACTIVITY_ITEM,
        Self::VOUCHER_PICK,
        Self::VOUCHER_CGACHA,
        Self::VOUCHER_MGACHA,
        Self::CRS_SHOP_COIN,
        Self::CRS_RUNE_COIN,
        Self::LMTGS_COIN,
        Self::EPGS_COIN,
        Self::LIMITED_TKT_GACHA_10,
        Self::LIMITED_FREE_GACHA,
        Self::REP_COIN,
        Self::ROGUELIKE,
        Self::LINKAGE_TKT_GACHA_10,
        Self::VOUCHER_ELITE_II_4,
        Self::VOUCHER_ELITE_II_5,
        Self::VOUCHER_ELITE_II_6,
        Self::VOUCHER_SKIN,
        Self::RETRO_COIN,
        Self::PLAYER_AVATAR,
        Self::UNI_COLLECTION,
        Self::VOUCHER_FULL_POTENTIAL,
        Self::RL_COIN,
        Self::RETURN_CREDIT,
        Self::MEDAL,
        Self::CHARM,
        Self::HOME_BACKGROUND,
        Self::EXTERMINATION_AGENT,
        Self::OPTIONAL_VOUCHER_PICK,
        Self::ACT_CART_COMPONENT,
        Self::VOUCHER_LEVELMAX_6,
        Self::VOUCHER_LEVELMAX_5,
        Self::VOUCHER_LEVELMAX_4,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_6,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_5,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_4,
        Self::ACTIVITY_POTENTIAL,
        Self::ITEM_PACK,
        Self::SANDBOX,
        Self::FAVOR_ADD_ITEM,
        Self::CLASSIC_SHD,
        Self::CLASSIC_TKT_GACHA,
        Self::CLASSIC_TKT_GACHA_10,
        Self::LIMITED_BUFF,
        Self::CLASSIC_FES_PICK_TIER_5,
        Self::CLASSIC_FES_PICK_TIER_6,
        Self::RETURN_PROGRESS,
        Self::NEW_PROGRESS,
        Self::MCARD_VOUCHER,
        Self::MATERIAL_ISSUE_VOUCHER,
        Self::CRS_SHOP_COIN_V2,
        Self::HOME_THEME,
        Self::SANDBOX_PERM,
        Self::SANDBOX_TOKEN,
        Self::TEMPLATE_TRAP,
        Self::NAME_CARD_SKIN,
        Self::EMOTICON_SET,
        Self::EXCLUSIVE_TKT_GACHA,
        Self::EXCLUSIVE_TKT_GACHA_10,
        Self::SO_CHAR_EXP,
        Self::GIFTPACKAGE_TKT,
        Self::VOUCHER_SKIN_V2,
        Self::RANDOM_VOUCHER_SKIN,
        Self::ACT1VHALFIDLE_ITEM,
        Self::PLOT_ITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CHAR => Some("CHAR"),
            Self::CARD_EXP => Some("CARD_EXP"),
            Self::MATERIAL => Some("MATERIAL"),
            Self::GOLD => Some("GOLD"),
            Self::EXP_PLAYER => Some("EXP_PLAYER"),
            Self::TKT_TRY => Some("TKT_TRY"),
            Self::TKT_RECRUIT => Some("TKT_RECRUIT"),
            Self::TKT_INST_FIN => Some("TKT_INST_FIN"),
            Self::TKT_GACHA => Some("TKT_GACHA"),
            Self::ACTIVITY_COIN => Some("ACTIVITY_COIN"),
            Self::DIAMOND => Some("DIAMOND"),
            Self::DIAMOND_SHD => Some("DIAMOND_SHD"),
            Self::HGG_SHD => Some("HGG_SHD"),
            Self::LGG_SHD => Some("LGG_SHD"),
            Self::FURN => Some("FURN"),
            Self::AP_GAMEPLAY => Some("AP_GAMEPLAY"),
            Self::AP_BASE => Some("AP_BASE"),
            Self::SOCIAL_PT => Some("SOCIAL_PT"),
            Self::CHAR_SKIN => Some("CHAR_SKIN"),
            Self::TKT_GACHA_10 => Some("TKT_GACHA_10"),
            Self::TKT_GACHA_PRSV => Some("TKT_GACHA_PRSV"),
            Self::AP_ITEM => Some("AP_ITEM"),
            Self::AP_SUPPLY => Some("AP_SUPPLY"),
            Self::RENAMING_CARD => Some("RENAMING_CARD"),
            Self::RENAMING_CARD_2 => Some("RENAMING_CARD_2"),
            Self::ET_STAGE => Some("ET_STAGE"),
            Self::ACTIVITY_ITEM => Some("ACTIVITY_ITEM"),
            Self::VOUCHER_PICK => Some("VOUCHER_PICK"),
            Self::VOUCHER_CGACHA => Some("VOUCHER_CGACHA"),
            Self::VOUCHER_MGACHA => Some("VOUCHER_MGACHA"),
            Self::CRS_SHOP_COIN => Some("CRS_SHOP_COIN"),
            Self::CRS_RUNE_COIN => Some("CRS_RUNE_COIN"),
            Self::LMTGS_COIN => Some("LMTGS_COIN"),
            Self::EPGS_COIN => Some("EPGS_COIN"),
            Self::LIMITED_TKT_GACHA_10 => Some("LIMITED_TKT_GACHA_10"),
            Self::LIMITED_FREE_GACHA => Some("LIMITED_FREE_GACHA"),
            Self::REP_COIN => Some("REP_COIN"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::LINKAGE_TKT_GACHA_10 => Some("LINKAGE_TKT_GACHA_10"),
            Self::VOUCHER_ELITE_II_4 => Some("VOUCHER_ELITE_II_4"),
            Self::VOUCHER_ELITE_II_5 => Some("VOUCHER_ELITE_II_5"),
            Self::VOUCHER_ELITE_II_6 => Some("VOUCHER_ELITE_II_6"),
            Self::VOUCHER_SKIN => Some("VOUCHER_SKIN"),
            Self::RETRO_COIN => Some("RETRO_COIN"),
            Self::PLAYER_AVATAR => Some("PLAYER_AVATAR"),
            Self::UNI_COLLECTION => Some("UNI_COLLECTION"),
            Self::VOUCHER_FULL_POTENTIAL => Some("VOUCHER_FULL_POTENTIAL"),
            Self::RL_COIN => Some("RL_COIN"),
            Self::RETURN_CREDIT => Some("RETURN_CREDIT"),
            Self::MEDAL => Some("MEDAL"),
            Self::CHARM => Some("CHARM"),
            Self::HOME_BACKGROUND => Some("HOME_BACKGROUND"),
            Self::EXTERMINATION_AGENT => Some("EXTERMINATION_AGENT"),
            Self::OPTIONAL_VOUCHER_PICK => Some("OPTIONAL_VOUCHER_PICK"),
            Self::ACT_CART_COMPONENT => Some("ACT_CART_COMPONENT"),
            Self::VOUCHER_LEVELMAX_6 => Some("VOUCHER_LEVELMAX_6"),
            Self::VOUCHER_LEVELMAX_5 => Some("VOUCHER_LEVELMAX_5"),
            Self::VOUCHER_LEVELMAX_4 => Some("VOUCHER_LEVELMAX_4"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_6 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_6"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_5 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_5"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_4 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_4"),
            Self::ACTIVITY_POTENTIAL => Some("ACTIVITY_POTENTIAL"),
            Self::ITEM_PACK => Some("ITEM_PACK"),
            Self::SANDBOX => Some("SANDBOX"),
            Self::FAVOR_ADD_ITEM => Some("FAVOR_ADD_ITEM"),
            Self::CLASSIC_SHD => Some("CLASSIC_SHD"),
            Self::CLASSIC_TKT_GACHA => Some("CLASSIC_TKT_GACHA"),
            Self::CLASSIC_TKT_GACHA_10 => Some("CLASSIC_TKT_GACHA_10"),
            Self::LIMITED_BUFF => Some("LIMITED_BUFF"),
            Self::CLASSIC_FES_PICK_TIER_5 => Some("CLASSIC_FES_PICK_TIER_5"),
            Self::CLASSIC_FES_PICK_TIER_6 => Some("CLASSIC_FES_PICK_TIER_6"),
            Self::RETURN_PROGRESS => Some("RETURN_PROGRESS"),
            Self::NEW_PROGRESS => Some("NEW_PROGRESS"),
            Self::MCARD_VOUCHER => Some("MCARD_VOUCHER"),
            Self::MATERIAL_ISSUE_VOUCHER => Some("MATERIAL_ISSUE_VOUCHER"),
            Self::CRS_SHOP_COIN_V2 => Some("CRS_SHOP_COIN_V2"),
            Self::HOME_THEME => Some("HOME_THEME"),
            Self::SANDBOX_PERM => Some("SANDBOX_PERM"),
            Self::SANDBOX_TOKEN => Some("SANDBOX_TOKEN"),
            Self::TEMPLATE_TRAP => Some("TEMPLATE_TRAP"),
            Self::NAME_CARD_SKIN => Some("NAME_CARD_SKIN"),
            Self::EMOTICON_SET => Some("EMOTICON_SET"),
            Self::EXCLUSIVE_TKT_GACHA => Some("EXCLUSIVE_TKT_GACHA"),
            Self::EXCLUSIVE_TKT_GACHA_10 => Some("EXCLUSIVE_TKT_GACHA_10"),
            Self::SO_CHAR_EXP => Some("SO_CHAR_EXP"),
            Self::GIFTPACKAGE_TKT => Some("GIFTPACKAGE_TKT"),
            Self::VOUCHER_SKIN_V2 => Some("VOUCHER_SKIN_V2"),
            Self::RANDOM_VOUCHER_SKIN => Some("RANDOM_VOUCHER_SKIN"),
            Self::ACT1VHALFIDLE_ITEM => Some("ACT1VHALFIDLE_ITEM"),
            Self::PLOT_ITEM => Some("PLOT_ITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemType {
    type Output = enum__Torappu_ItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STAGE_DROP_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STAGE_DROP_TYPE: i32 = 12;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STAGE_DROP_TYPE: [enum__Torappu_StageDropType; 13] = [
    enum__Torappu_StageDropType::NONE,
    enum__Torappu_StageDropType::ONCE,
    enum__Torappu_StageDropType::NORMAL,
    enum__Torappu_StageDropType::SPECIAL,
    enum__Torappu_StageDropType::ADDITIONAL,
    enum__Torappu_StageDropType::APRETURN,
    enum__Torappu_StageDropType::DIAMOND_MATERIAL,
    enum__Torappu_StageDropType::FUNITURE_DROP,
    enum__Torappu_StageDropType::COMPLETE,
    enum__Torappu_StageDropType::CHARM_DROP,
    enum__Torappu_StageDropType::OVERRIDE_DROP,
    enum__Torappu_StageDropType::ITEM_RETURN,
    enum__Torappu_StageDropType::CONDITION_DROP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StageDropType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StageDropType {
    pub const NONE: Self = Self(0);
    pub const ONCE: Self = Self(1);
    pub const NORMAL: Self = Self(2);
    pub const SPECIAL: Self = Self(3);
    pub const ADDITIONAL: Self = Self(4);
    pub const APRETURN: Self = Self(5);
    pub const DIAMOND_MATERIAL: Self = Self(6);
    pub const FUNITURE_DROP: Self = Self(7);
    pub const COMPLETE: Self = Self(8);
    pub const CHARM_DROP: Self = Self(9);
    pub const OVERRIDE_DROP: Self = Self(10);
    pub const ITEM_RETURN: Self = Self(11);
    pub const CONDITION_DROP: Self = Self(12);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 12;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ONCE,
        Self::NORMAL,
        Self::SPECIAL,
        Self::ADDITIONAL,
        Self::APRETURN,
        Self::DIAMOND_MATERIAL,
        Self::FUNITURE_DROP,
        Self::COMPLETE,
        Self::CHARM_DROP,
        Self::OVERRIDE_DROP,
        Self::ITEM_RETURN,
        Self::CONDITION_DROP,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ONCE => Some("ONCE"),
            Self::NORMAL => Some("NORMAL"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::ADDITIONAL => Some("ADDITIONAL"),
            Self::APRETURN => Some("APRETURN"),
            Self::DIAMOND_MATERIAL => Some("DIAMOND_MATERIAL"),
            Self::FUNITURE_DROP => Some("FUNITURE_DROP"),
            Self::COMPLETE => Some("COMPLETE"),
            Self::CHARM_DROP => Some("CHARM_DROP"),
            Self::OVERRIDE_DROP => Some("OVERRIDE_DROP"),
            Self::ITEM_RETURN => Some("ITEM_RETURN"),
            Self::CONDITION_DROP => Some("CONDITION_DROP"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StageDropType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StageDropType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StageDropType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StageDropType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StageDropType {
    type Output = enum__Torappu_StageDropType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StageDropType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StageDropType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StageDropType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_OCC_PER: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_OCC_PER: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_OCC_PER: [enum__Torappu_OccPer; 7] = [
    enum__Torappu_OccPer::ALWAYS,
    enum__Torappu_OccPer::ALMOST,
    enum__Torappu_OccPer::USUAL,
    enum__Torappu_OccPer::OFTEN,
    enum__Torappu_OccPer::SOMETIMES,
    enum__Torappu_OccPer::NEVER,
    enum__Torappu_OccPer::DEFINITELY_BUFF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_OccPer(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_OccPer {
    pub const ALWAYS: Self = Self(0);
    pub const ALMOST: Self = Self(1);
    pub const USUAL: Self = Self(2);
    pub const OFTEN: Self = Self(3);
    pub const SOMETIMES: Self = Self(4);
    pub const NEVER: Self = Self(5);
    pub const DEFINITELY_BUFF: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::ALWAYS,
        Self::ALMOST,
        Self::USUAL,
        Self::OFTEN,
        Self::SOMETIMES,
        Self::NEVER,
        Self::DEFINITELY_BUFF,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ALWAYS => Some("ALWAYS"),
            Self::ALMOST => Some("ALMOST"),
            Self::USUAL => Some("USUAL"),
            Self::OFTEN => Some("OFTEN"),
            Self::SOMETIMES => Some("SOMETIMES"),
            Self::NEVER => Some("NEVER"),
            Self::DEFINITELY_BUFF => Some("DEFINITELY_BUFF"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_OccPer {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_OccPer {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_OccPer",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_OccPer {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_OccPer {
    type Output = enum__Torappu_OccPer;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_OccPer {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_OccPer {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_OccPer {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STAGE_DATA_SPECIAL_STAGE_UNLOCK_PROGRESS_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STAGE_DATA_SPECIAL_STAGE_UNLOCK_PROGRESS_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STAGE_DATA_SPECIAL_STAGE_UNLOCK_PROGRESS_TYPE:
    [enum__Torappu_StageData_SpecialStageUnlockProgressType; 2] = [
    enum__Torappu_StageData_SpecialStageUnlockProgressType::ONCE,
    enum__Torappu_StageData_SpecialStageUnlockProgressType::PROGRESS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StageData_SpecialStageUnlockProgressType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StageData_SpecialStageUnlockProgressType {
    pub const ONCE: Self = Self(0);
    pub const PROGRESS: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::ONCE, Self::PROGRESS];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ONCE => Some("ONCE"),
            Self::PROGRESS => Some("PROGRESS"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StageData_SpecialStageUnlockProgressType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StageData_SpecialStageUnlockProgressType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StageData_SpecialStageUnlockProgressType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StageData_SpecialStageUnlockProgressType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StageData_SpecialStageUnlockProgressType {
    type Output = enum__Torappu_StageData_SpecialStageUnlockProgressType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StageData_SpecialStageUnlockProgressType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StageData_SpecialStageUnlockProgressType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StageData_SpecialStageUnlockProgressType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_FOG_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_FOG_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_FOG_TYPE: [enum__Torappu_FogType; 2] =
    [enum__Torappu_FogType::ZONE, enum__Torappu_FogType::STAGE];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_FogType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_FogType {
    pub const ZONE: Self = Self(0);
    pub const STAGE: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::ZONE, Self::STAGE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ZONE => Some("ZONE"),
            Self::STAGE => Some("STAGE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_FogType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_FogType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_FogType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_FogType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_FogType {
    type Output = enum__Torappu_FogType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_FogType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_FogType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_FogType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STAGE_BUTTON_IN_FOG_RENDER_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STAGE_BUTTON_IN_FOG_RENDER_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STAGE_BUTTON_IN_FOG_RENDER_TYPE:
    [enum__Torappu_StageButtonInFogRenderType; 2] = [
    enum__Torappu_StageButtonInFogRenderType::HIDE,
    enum__Torappu_StageButtonInFogRenderType::SHOW_WITH_FOG_SIX_STAR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StageButtonInFogRenderType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StageButtonInFogRenderType {
    pub const HIDE: Self = Self(0);
    pub const SHOW_WITH_FOG_SIX_STAR: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::HIDE, Self::SHOW_WITH_FOG_SIX_STAR];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::HIDE => Some("HIDE"),
            Self::SHOW_WITH_FOG_SIX_STAR => Some("SHOW_WITH_FOG_SIX_STAR"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StageButtonInFogRenderType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StageButtonInFogRenderType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StageButtonInFogRenderType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StageButtonInFogRenderType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StageButtonInFogRenderType {
    type Output = enum__Torappu_StageButtonInFogRenderType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StageButtonInFogRenderType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StageButtonInFogRenderType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StageButtonInFogRenderType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_EVOLVE_PHASE: [enum__Torappu_EvolvePhase; 5] = [
    enum__Torappu_EvolvePhase::PHASE_0,
    enum__Torappu_EvolvePhase::PHASE_1,
    enum__Torappu_EvolvePhase::PHASE_2,
    enum__Torappu_EvolvePhase::PHASE_3,
    enum__Torappu_EvolvePhase::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EvolvePhase(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EvolvePhase {
    pub const PHASE_0: Self = Self(0);
    pub const PHASE_1: Self = Self(1);
    pub const PHASE_2: Self = Self(2);
    pub const PHASE_3: Self = Self(3);
    pub const E_NUM: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::PHASE_0,
        Self::PHASE_1,
        Self::PHASE_2,
        Self::PHASE_3,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::PHASE_0 => Some("PHASE_0"),
            Self::PHASE_1 => Some("PHASE_1"),
            Self::PHASE_2 => Some("PHASE_2"),
            Self::PHASE_3 => Some("PHASE_3"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EvolvePhase {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_EvolvePhase {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_EvolvePhase",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EvolvePhase {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EvolvePhase {
    type Output = enum__Torappu_EvolvePhase;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EvolvePhase {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EvolvePhase {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EvolvePhase {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_OVERRIDE_GAME_MODE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_OVERRIDE_GAME_MODE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_OVERRIDE_GAME_MODE: [enum__Torappu_OverrideGameMode; 2] = [
    enum__Torappu_OverrideGameMode::NONE,
    enum__Torappu_OverrideGameMode::ACT27SIDE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_OverrideGameMode(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_OverrideGameMode {
    pub const NONE: Self = Self(0);
    pub const ACT27SIDE: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::ACT27SIDE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ACT27SIDE => Some("ACT27SIDE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_OverrideGameMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_OverrideGameMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_OverrideGameMode",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_OverrideGameMode {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_OverrideGameMode {
    type Output = enum__Torappu_OverrideGameMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_OverrideGameMode {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_OverrideGameMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_OverrideGameMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STORYLINE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STORYLINE_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STORYLINE_TYPE: [enum__Torappu_StorylineType; 2] = [
    enum__Torappu_StorylineType::CONTINUE,
    enum__Torappu_StorylineType::DISCRETE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StorylineType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StorylineType {
    pub const CONTINUE: Self = Self(0);
    pub const DISCRETE: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::CONTINUE, Self::DISCRETE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::CONTINUE => Some("CONTINUE"),
            Self::DISCRETE => Some("DISCRETE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StorylineType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StorylineType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StorylineType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StorylineType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StorylineType {
    type Output = enum__Torappu_StorylineType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StorylineType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StorylineType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StorylineType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STORYLINE_LOCATION_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STORYLINE_LOCATION_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STORYLINE_LOCATION_TYPE: [enum__Torappu_StorylineLocationType;
    4] = [
    enum__Torappu_StorylineLocationType::STORY_SET,
    enum__Torappu_StorylineLocationType::BEFORE,
    enum__Torappu_StorylineLocationType::AFTER,
    enum__Torappu_StorylineLocationType::MAINLINE_SPLIT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StorylineLocationType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StorylineLocationType {
    pub const STORY_SET: Self = Self(0);
    pub const BEFORE: Self = Self(1);
    pub const AFTER: Self = Self(2);
    pub const MAINLINE_SPLIT: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::STORY_SET,
        Self::BEFORE,
        Self::AFTER,
        Self::MAINLINE_SPLIT,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::STORY_SET => Some("STORY_SET"),
            Self::BEFORE => Some("BEFORE"),
            Self::AFTER => Some("AFTER"),
            Self::MAINLINE_SPLIT => Some("MAINLINE_SPLIT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StorylineLocationType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StorylineLocationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StorylineLocationType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StorylineLocationType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StorylineLocationType {
    type Output = enum__Torappu_StorylineLocationType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StorylineLocationType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StorylineLocationType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StorylineLocationType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STORYLINE_STORY_SET_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STORYLINE_STORY_SET_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STORYLINE_STORY_SET_TYPE:
    [enum__Torappu_StorylineStorySetType; 3] = [
    enum__Torappu_StorylineStorySetType::MAINLINE,
    enum__Torappu_StorylineStorySetType::SS,
    enum__Torappu_StorylineStorySetType::COLLECT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StorylineStorySetType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StorylineStorySetType {
    pub const MAINLINE: Self = Self(0);
    pub const SS: Self = Self(1);
    pub const COLLECT: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::MAINLINE, Self::SS, Self::COLLECT];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MAINLINE => Some("MAINLINE"),
            Self::SS => Some("SS"),
            Self::COLLECT => Some("COLLECT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StorylineStorySetType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StorylineStorySetType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StorylineStorySetType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StorylineStorySetType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StorylineStorySetType {
    type Output = enum__Torappu_StorylineStorySetType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StorylineStorySetType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StorylineStorySetType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StorylineStorySetType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SIX_STAR_MILESTONE_REWARD_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SIX_STAR_MILESTONE_REWARD_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SIX_STAR_MILESTONE_REWARD_TYPE:
    [enum__Torappu_SixStarMilestoneRewardType; 2] = [
    enum__Torappu_SixStarMilestoneRewardType::UNLOCK_STAGE,
    enum__Torappu_SixStarMilestoneRewardType::REWARD,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SixStarMilestoneRewardType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SixStarMilestoneRewardType {
    pub const UNLOCK_STAGE: Self = Self(0);
    pub const REWARD: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::UNLOCK_STAGE, Self::REWARD];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::UNLOCK_STAGE => Some("UNLOCK_STAGE"),
            Self::REWARD => Some("REWARD"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SixStarMilestoneRewardType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SixStarMilestoneRewardType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SixStarMilestoneRewardType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SixStarMilestoneRewardType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SixStarMilestoneRewardType {
    type Output = enum__Torappu_SixStarMilestoneRewardType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SixStarMilestoneRewardType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SixStarMilestoneRewardType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SixStarMilestoneRewardType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SIX_STAR_STAGE_COMPATIBLE_DROP_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SIX_STAR_STAGE_COMPATIBLE_DROP_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SIX_STAR_STAGE_COMPATIBLE_DROP_TYPE:
    [enum__Torappu_SixStarStageCompatibleDropType; 1] =
    [enum__Torappu_SixStarStageCompatibleDropType::COMPLETE_ONLY];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SixStarStageCompatibleDropType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SixStarStageCompatibleDropType {
    pub const COMPLETE_ONLY: Self = Self(0);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 0;
    pub const ENUM_VALUES: &'static [Self] = &[Self::COMPLETE_ONLY];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::COMPLETE_ONLY => Some("COMPLETE_ONLY"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SixStarStageCompatibleDropType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SixStarStageCompatibleDropType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SixStarStageCompatibleDropType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SixStarStageCompatibleDropType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SixStarStageCompatibleDropType {
    type Output = enum__Torappu_SixStarStageCompatibleDropType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SixStarStageCompatibleDropType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SixStarStageCompatibleDropType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SixStarStageCompatibleDropType {}
pub enum clz_Torappu_StageData_ConditionDescOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_ConditionDesc<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_ConditionDesc<'a> {
    type Inner = clz_Torappu_StageData_ConditionDesc<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_ConditionDesc<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_COMPLETESTATE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_ConditionDesc { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_ConditionDescArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_ConditionDesc<'bldr>> {
        let mut builder = clz_Torappu_StageData_ConditionDescBuilder::new(_fbb);
        builder.add_completeState(args.completeState);
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_ConditionDescT {
        let stageId = self.stageId().map(|x| x.to_string());
        let completeState = self.completeState();
        clz_Torappu_StageData_ConditionDescT {
            stageId,
            completeState,
        }
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_ConditionDesc::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn completeState(&self) -> enum__Torappu_PlayerBattleRank {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_PlayerBattleRank>(
                    clz_Torappu_StageData_ConditionDesc::VT_COMPLETESTATE,
                    Some(enum__Torappu_PlayerBattleRank::ERR_ZERO),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_ConditionDesc<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<enum__Torappu_PlayerBattleRank>(
                "completeState",
                Self::VT_COMPLETESTATE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_ConditionDescArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub completeState: enum__Torappu_PlayerBattleRank,
}
impl<'a> Default for clz_Torappu_StageData_ConditionDescArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_ConditionDescArgs {
            stageId: None,
            completeState: enum__Torappu_PlayerBattleRank::ERR_ZERO,
        }
    }
}

impl Serialize for clz_Torappu_StageData_ConditionDesc<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_ConditionDesc", 2)?;
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        s.serialize_field("completeState", &self.completeState())?;
        s.end()
    }
}

pub struct clz_Torappu_StageData_ConditionDescBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_ConditionDescBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_ConditionDesc::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_completeState(&mut self, completeState: enum__Torappu_PlayerBattleRank) {
        self.fbb_.push_slot::<enum__Torappu_PlayerBattleRank>(
            clz_Torappu_StageData_ConditionDesc::VT_COMPLETESTATE,
            completeState,
            enum__Torappu_PlayerBattleRank::ERR_ZERO,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_ConditionDescBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_ConditionDescBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_ConditionDesc<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_ConditionDesc<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_ConditionDesc");
        ds.field("stageId", &self.stageId());
        ds.field("completeState", &self.completeState());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_ConditionDescT {
    pub stageId: Option<String>,
    pub completeState: enum__Torappu_PlayerBattleRank,
}
impl Default for clz_Torappu_StageData_ConditionDescT {
    fn default() -> Self {
        Self {
            stageId: None,
            completeState: enum__Torappu_PlayerBattleRank::ERR_ZERO,
        }
    }
}
impl clz_Torappu_StageData_ConditionDescT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_ConditionDesc<'b>> {
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let completeState = self.completeState;
        clz_Torappu_StageData_ConditionDesc::create(
            _fbb,
            &clz_Torappu_StageData_ConditionDescArgs {
                stageId,
                completeState,
            },
        )
    }
}
pub enum clz_Torappu_ItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemBundle<'a> {
    type Inner = clz_Torappu_ItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'bldr>> {
        let mut builder = clz_Torappu_ItemBundleBuilder::new(_fbb);
        builder.add_type_(args.type_);
        builder.add_count(args.count);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemBundleT {
        let id = self.id().map(|x| x.to_string());
        let count = self.count();
        let type_ = self.type_();
        clz_Torappu_ItemBundleT { id, count, type_ }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemBundle::VT_ID, None)
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl<'a> Default for clz_Torappu_ItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemBundleArgs {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_ItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemBundle", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("count", &self.count())?;
        s.serialize_field("type_", &self.type_())?;
        s.end()
    }
}

pub struct clz_Torappu_ItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemBundle");
        ds.field("id", &self.id());
        ds.field("count", &self.count());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemBundleT {
    pub id: Option<String>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl Default for clz_Torappu_ItemBundleT {
    fn default() -> Self {
        Self {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}
impl clz_Torappu_ItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        let type_ = self.type_;
        clz_Torappu_ItemBundle::create(_fbb, &clz_Torappu_ItemBundleArgs { id, count, type_ })
    }
}
pub enum clz_Torappu_WeightItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_WeightItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_WeightItemBundle<'a> {
    type Inner = clz_Torappu_WeightItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_WeightItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_DROPTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_COUNT: flatbuffers::VOffsetT = 10;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_WeightItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_WeightItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_WeightItemBundle<'bldr>> {
        let mut builder = clz_Torappu_WeightItemBundleBuilder::new(_fbb);
        builder.add_weight(args.weight);
        builder.add_count(args.count);
        builder.add_dropType(args.dropType);
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_WeightItemBundleT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        let dropType = self.dropType();
        let count = self.count();
        let weight = self.weight();
        clz_Torappu_WeightItemBundleT {
            id,
            type_,
            dropType,
            count,
            weight,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_WeightItemBundle::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_WeightItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn dropType(&self) -> enum__Torappu_StageDropType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDropType>(
                    clz_Torappu_WeightItemBundle::VT_DROPTYPE,
                    Some(enum__Torappu_StageDropType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_WeightItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn weight(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_WeightItemBundle::VT_WEIGHT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_WeightItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<enum__Torappu_StageDropType>("dropType", Self::VT_DROPTYPE, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<i32>("weight", Self::VT_WEIGHT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_WeightItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_ItemType,
    pub dropType: enum__Torappu_StageDropType,
    pub count: i32,
    pub weight: i32,
}
impl<'a> Default for clz_Torappu_WeightItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_WeightItemBundleArgs {
            id: None,
            type_: enum__Torappu_ItemType::NONE,
            dropType: enum__Torappu_StageDropType::NONE,
            count: 0,
            weight: 0,
        }
    }
}

impl Serialize for clz_Torappu_WeightItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_WeightItemBundle", 5)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("dropType", &self.dropType())?;
        s.serialize_field("count", &self.count())?;
        s.serialize_field("weight", &self.weight())?;
        s.end()
    }
}

pub struct clz_Torappu_WeightItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_WeightItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_WeightItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_WeightItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_dropType(&mut self, dropType: enum__Torappu_StageDropType) {
        self.fbb_.push_slot::<enum__Torappu_StageDropType>(
            clz_Torappu_WeightItemBundle::VT_DROPTYPE,
            dropType,
            enum__Torappu_StageDropType::NONE,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_WeightItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_weight(&mut self, weight: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_WeightItemBundle::VT_WEIGHT, weight, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_WeightItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_WeightItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_WeightItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_WeightItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_WeightItemBundle");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("dropType", &self.dropType());
        ds.field("count", &self.count());
        ds.field("weight", &self.weight());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_WeightItemBundleT {
    pub id: Option<String>,
    pub type_: enum__Torappu_ItemType,
    pub dropType: enum__Torappu_StageDropType,
    pub count: i32,
    pub weight: i32,
}
impl Default for clz_Torappu_WeightItemBundleT {
    fn default() -> Self {
        Self {
            id: None,
            type_: enum__Torappu_ItemType::NONE,
            dropType: enum__Torappu_StageDropType::NONE,
            count: 0,
            weight: 0,
        }
    }
}
impl clz_Torappu_WeightItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_WeightItemBundle<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let dropType = self.dropType;
        let count = self.count;
        let weight = self.weight;
        clz_Torappu_WeightItemBundle::create(
            _fbb,
            &clz_Torappu_WeightItemBundleArgs {
                id,
                type_,
                dropType,
                count,
                weight,
            },
        )
    }
}
pub enum list_clz_Torappu_WeightItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct list_clz_Torappu_WeightItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for list_clz_Torappu_WeightItemBundle<'a> {
    type Inner = list_clz_Torappu_WeightItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> list_clz_Torappu_WeightItemBundle<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        list_clz_Torappu_WeightItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args list_clz_Torappu_WeightItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<list_clz_Torappu_WeightItemBundle<'bldr>> {
        let mut builder = list_clz_Torappu_WeightItemBundleBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> list_clz_Torappu_WeightItemBundleT {
        let values = self
            .values()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        list_clz_Torappu_WeightItemBundleT { values }
    }

    #[inline]
    pub fn values(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle>>,
            >>(list_clz_Torappu_WeightItemBundle::VT_VALUES, None)
        }
    }
}

impl flatbuffers::Verifiable for list_clz_Torappu_WeightItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle>>,
            >>("values", Self::VT_VALUES, false)?
            .finish();
        Ok(())
    }
}
pub struct list_clz_Torappu_WeightItemBundleArgs<'a> {
    pub values: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for list_clz_Torappu_WeightItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        list_clz_Torappu_WeightItemBundleArgs { values: None }
    }
}

impl Serialize for list_clz_Torappu_WeightItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("list_clz_Torappu_WeightItemBundle", 1)?;
        if let Some(f) = self.values() {
            s.serialize_field("values", &f)?;
        } else {
            s.skip_field("values")?;
        }
        s.end()
    }
}

pub struct list_clz_Torappu_WeightItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    list_clz_Torappu_WeightItemBundleBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_values(
        &mut self,
        values: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            list_clz_Torappu_WeightItemBundle::VT_VALUES,
            values,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> list_clz_Torappu_WeightItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        list_clz_Torappu_WeightItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<list_clz_Torappu_WeightItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for list_clz_Torappu_WeightItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("list_clz_Torappu_WeightItemBundle");
        ds.field("values", &self.values());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct list_clz_Torappu_WeightItemBundleT {
    pub values: Option<Vec<clz_Torappu_WeightItemBundleT>>,
}
impl Default for list_clz_Torappu_WeightItemBundleT {
    fn default() -> Self {
        Self { values: None }
    }
}
impl list_clz_Torappu_WeightItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<list_clz_Torappu_WeightItemBundle<'b>> {
        let values = self.values.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        list_clz_Torappu_WeightItemBundle::create(
            _fbb,
            &list_clz_Torappu_WeightItemBundleArgs { values },
        )
    }
}
pub enum clz_Torappu_StageData_DisplayRewardsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_DisplayRewards<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_DisplayRewards<'a> {
    type Inner = clz_Torappu_StageData_DisplayRewards<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_DisplayRewards<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_DROPTYPE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_DisplayRewards { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_DisplayRewardsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayRewards<'bldr>> {
        let mut builder = clz_Torappu_StageData_DisplayRewardsBuilder::new(_fbb);
        builder.add_dropType(args.dropType);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_DisplayRewardsT {
        let type_ = self.type_();
        let id = self.id().map(|x| x.to_string());
        let dropType = self.dropType();
        clz_Torappu_StageData_DisplayRewardsT {
            type_,
            id,
            dropType,
        }
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_StageData_DisplayRewards::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_DisplayRewards::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn dropType(&self) -> enum__Torappu_StageDropType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDropType>(
                    clz_Torappu_StageData_DisplayRewards::VT_DROPTYPE,
                    Some(enum__Torappu_StageDropType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_DisplayRewards<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_StageDropType>("dropType", Self::VT_DROPTYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_DisplayRewardsArgs<'a> {
    pub type_: enum__Torappu_ItemType,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dropType: enum__Torappu_StageDropType,
}
impl<'a> Default for clz_Torappu_StageData_DisplayRewardsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_DisplayRewardsArgs {
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_StageData_DisplayRewards<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_DisplayRewards", 3)?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("dropType", &self.dropType())?;
        s.end()
    }
}

pub struct clz_Torappu_StageData_DisplayRewardsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_DisplayRewardsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_StageData_DisplayRewards::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_DisplayRewards::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_dropType(&mut self, dropType: enum__Torappu_StageDropType) {
        self.fbb_.push_slot::<enum__Torappu_StageDropType>(
            clz_Torappu_StageData_DisplayRewards::VT_DROPTYPE,
            dropType,
            enum__Torappu_StageDropType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_DisplayRewardsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_DisplayRewardsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayRewards<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_DisplayRewards<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_DisplayRewards");
        ds.field("type_", &self.type_());
        ds.field("id", &self.id());
        ds.field("dropType", &self.dropType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_DisplayRewardsT {
    pub type_: enum__Torappu_ItemType,
    pub id: Option<String>,
    pub dropType: enum__Torappu_StageDropType,
}
impl Default for clz_Torappu_StageData_DisplayRewardsT {
    fn default() -> Self {
        Self {
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}
impl clz_Torappu_StageData_DisplayRewardsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayRewards<'b>> {
        let type_ = self.type_;
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let dropType = self.dropType;
        clz_Torappu_StageData_DisplayRewards::create(
            _fbb,
            &clz_Torappu_StageData_DisplayRewardsArgs {
                type_,
                id,
                dropType,
            },
        )
    }
}
pub enum clz_Torappu_StageData_DisplayDetailRewardsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_DisplayDetailRewards<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_DisplayDetailRewards<'a> {
    type Inner = clz_Torappu_StageData_DisplayDetailRewards<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_DisplayDetailRewards<'a> {
    pub const VT_OCCPERCENT: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_ID: flatbuffers::VOffsetT = 8;
    pub const VT_DROPTYPE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_DisplayDetailRewards { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_DisplayDetailRewardsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayDetailRewards<'bldr>> {
        let mut builder = clz_Torappu_StageData_DisplayDetailRewardsBuilder::new(_fbb);
        builder.add_dropType(args.dropType);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_type_(args.type_);
        builder.add_occPercent(args.occPercent);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_DisplayDetailRewardsT {
        let occPercent = self.occPercent();
        let type_ = self.type_();
        let id = self.id().map(|x| x.to_string());
        let dropType = self.dropType();
        clz_Torappu_StageData_DisplayDetailRewardsT {
            occPercent,
            type_,
            id,
            dropType,
        }
    }

    #[inline]
    pub fn occPercent(&self) -> enum__Torappu_OccPer {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_OccPer>(
                    clz_Torappu_StageData_DisplayDetailRewards::VT_OCCPERCENT,
                    Some(enum__Torappu_OccPer::ALWAYS),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_StageData_DisplayDetailRewards::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_DisplayDetailRewards::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn dropType(&self) -> enum__Torappu_StageDropType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDropType>(
                    clz_Torappu_StageData_DisplayDetailRewards::VT_DROPTYPE,
                    Some(enum__Torappu_StageDropType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_DisplayDetailRewards<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_OccPer>("occPercent", Self::VT_OCCPERCENT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_StageDropType>("dropType", Self::VT_DROPTYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_DisplayDetailRewardsArgs<'a> {
    pub occPercent: enum__Torappu_OccPer,
    pub type_: enum__Torappu_ItemType,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dropType: enum__Torappu_StageDropType,
}
impl<'a> Default for clz_Torappu_StageData_DisplayDetailRewardsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_DisplayDetailRewardsArgs {
            occPercent: enum__Torappu_OccPer::ALWAYS,
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_StageData_DisplayDetailRewards<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_DisplayDetailRewards", 4)?;
        s.serialize_field("occPercent", &self.occPercent())?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("dropType", &self.dropType())?;
        s.end()
    }
}

pub struct clz_Torappu_StageData_DisplayDetailRewardsBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_DisplayDetailRewardsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_occPercent(&mut self, occPercent: enum__Torappu_OccPer) {
        self.fbb_.push_slot::<enum__Torappu_OccPer>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_OCCPERCENT,
            occPercent,
            enum__Torappu_OccPer::ALWAYS,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_dropType(&mut self, dropType: enum__Torappu_StageDropType) {
        self.fbb_.push_slot::<enum__Torappu_StageDropType>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_DROPTYPE,
            dropType,
            enum__Torappu_StageDropType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_DisplayDetailRewardsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_DisplayDetailRewardsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayDetailRewards<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_DisplayDetailRewards<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_DisplayDetailRewards");
        ds.field("occPercent", &self.occPercent());
        ds.field("type_", &self.type_());
        ds.field("id", &self.id());
        ds.field("dropType", &self.dropType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_DisplayDetailRewardsT {
    pub occPercent: enum__Torappu_OccPer,
    pub type_: enum__Torappu_ItemType,
    pub id: Option<String>,
    pub dropType: enum__Torappu_StageDropType,
}
impl Default for clz_Torappu_StageData_DisplayDetailRewardsT {
    fn default() -> Self {
        Self {
            occPercent: enum__Torappu_OccPer::ALWAYS,
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}
impl clz_Torappu_StageData_DisplayDetailRewardsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayDetailRewards<'b>> {
        let occPercent = self.occPercent;
        let type_ = self.type_;
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let dropType = self.dropType;
        clz_Torappu_StageData_DisplayDetailRewards::create(
            _fbb,
            &clz_Torappu_StageData_DisplayDetailRewardsArgs {
                occPercent,
                type_,
                id,
                dropType,
            },
        )
    }
}
pub enum clz_Torappu_StageData_StageDropInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_StageDropInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_StageDropInfo<'a> {
    type Inner = clz_Torappu_StageData_StageDropInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_StageDropInfo<'a> {
    pub const VT_FIRSTPASSREWARDS: flatbuffers::VOffsetT = 4;
    pub const VT_FIRSTCOMPLETEREWARDS: flatbuffers::VOffsetT = 6;
    pub const VT_PASSREWARDS: flatbuffers::VOffsetT = 8;
    pub const VT_COMPLETEREWARDS: flatbuffers::VOffsetT = 10;
    pub const VT_DISPLAYREWARDS: flatbuffers::VOffsetT = 12;
    pub const VT_DISPLAYDETAILREWARDS: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_StageDropInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_StageDropInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo<'bldr>> {
        let mut builder = clz_Torappu_StageData_StageDropInfoBuilder::new(_fbb);
        if let Some(x) = args.displayDetailRewards {
            builder.add_displayDetailRewards(x);
        }
        if let Some(x) = args.displayRewards {
            builder.add_displayRewards(x);
        }
        if let Some(x) = args.completeRewards {
            builder.add_completeRewards(x);
        }
        if let Some(x) = args.passRewards {
            builder.add_passRewards(x);
        }
        if let Some(x) = args.firstCompleteRewards {
            builder.add_firstCompleteRewards(x);
        }
        if let Some(x) = args.firstPassRewards {
            builder.add_firstPassRewards(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_StageDropInfoT {
        let firstPassRewards = self
            .firstPassRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let firstCompleteRewards = self
            .firstCompleteRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let passRewards = self
            .passRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let completeRewards = self
            .completeRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let displayRewards = self
            .displayRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let displayDetailRewards = self
            .displayDetailRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_StageData_StageDropInfoT {
            firstPassRewards,
            firstCompleteRewards,
            passRewards,
            completeRewards,
            displayRewards,
            displayDetailRewards,
        }
    }

    #[inline]
    pub fn firstPassRewards(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(
                clz_Torappu_StageData_StageDropInfo::VT_FIRSTPASSREWARDS,
                None,
            )
        }
    }
    #[inline]
    pub fn firstCompleteRewards(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(
                clz_Torappu_StageData_StageDropInfo::VT_FIRSTCOMPLETEREWARDS,
                None,
            )
        }
    }
    #[inline]
    pub fn passRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle>,
                >,
            >>(clz_Torappu_StageData_StageDropInfo::VT_PASSREWARDS, None)
        }
    }
    #[inline]
    pub fn completeRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle>,
                >,
            >>(
                clz_Torappu_StageData_StageDropInfo::VT_COMPLETEREWARDS,
                None,
            )
        }
    }
    #[inline]
    pub fn displayRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards>,
                >,
            >>(clz_Torappu_StageData_StageDropInfo::VT_DISPLAYREWARDS, None)
        }
    }
    #[inline]
    pub fn displayDetailRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards>,
                >,
            >>(
                clz_Torappu_StageData_StageDropInfo::VT_DISPLAYDETAILREWARDS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_StageDropInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("firstPassRewards", Self::VT_FIRSTPASSREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("firstCompleteRewards", Self::VT_FIRSTCOMPLETEREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle>,
                >,
            >>("passRewards", Self::VT_PASSREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle>,
                >,
            >>("completeRewards", Self::VT_COMPLETEREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards>,
                >,
            >>("displayRewards", Self::VT_DISPLAYREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards>,
                >,
            >>("displayDetailRewards", Self::VT_DISPLAYDETAILREWARDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_StageDropInfoArgs<'a> {
    pub firstPassRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
    pub firstCompleteRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
    pub passRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'a>>,
            >,
        >,
    >,
    pub completeRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'a>>,
            >,
        >,
    >,
    pub displayRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards<'a>>,
            >,
        >,
    >,
    pub displayDetailRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_StageData_StageDropInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_StageDropInfoArgs {
            firstPassRewards: None,
            firstCompleteRewards: None,
            passRewards: None,
            completeRewards: None,
            displayRewards: None,
            displayDetailRewards: None,
        }
    }
}

impl Serialize for clz_Torappu_StageData_StageDropInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_StageDropInfo", 6)?;
        if let Some(f) = self.firstPassRewards() {
            s.serialize_field("firstPassRewards", &f)?;
        } else {
            s.skip_field("firstPassRewards")?;
        }
        if let Some(f) = self.firstCompleteRewards() {
            s.serialize_field("firstCompleteRewards", &f)?;
        } else {
            s.skip_field("firstCompleteRewards")?;
        }
        if let Some(f) = self.passRewards() {
            s.serialize_field("passRewards", &f)?;
        } else {
            s.skip_field("passRewards")?;
        }
        if let Some(f) = self.completeRewards() {
            s.serialize_field("completeRewards", &f)?;
        } else {
            s.skip_field("completeRewards")?;
        }
        if let Some(f) = self.displayRewards() {
            s.serialize_field("displayRewards", &f)?;
        } else {
            s.skip_field("displayRewards")?;
        }
        if let Some(f) = self.displayDetailRewards() {
            s.serialize_field("displayDetailRewards", &f)?;
        } else {
            s.skip_field("displayDetailRewards")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StageData_StageDropInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_StageDropInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_firstPassRewards(
        &mut self,
        firstPassRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_StageDropInfo::VT_FIRSTPASSREWARDS,
            firstPassRewards,
        );
    }
    #[inline]
    pub fn add_firstCompleteRewards(
        &mut self,
        firstCompleteRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_StageDropInfo::VT_FIRSTCOMPLETEREWARDS,
            firstCompleteRewards,
        );
    }
    #[inline]
    pub fn add_passRewards(
        &mut self,
        passRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_StageDropInfo::VT_PASSREWARDS,
            passRewards,
        );
    }
    #[inline]
    pub fn add_completeRewards(
        &mut self,
        completeRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_StageDropInfo::VT_COMPLETEREWARDS,
            completeRewards,
        );
    }
    #[inline]
    pub fn add_displayRewards(
        &mut self,
        displayRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_StageDropInfo::VT_DISPLAYREWARDS,
            displayRewards,
        );
    }
    #[inline]
    pub fn add_displayDetailRewards(
        &mut self,
        displayDetailRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_StageDropInfo::VT_DISPLAYDETAILREWARDS,
            displayDetailRewards,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_StageDropInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_StageDropInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_StageDropInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_StageDropInfo");
        ds.field("firstPassRewards", &self.firstPassRewards());
        ds.field("firstCompleteRewards", &self.firstCompleteRewards());
        ds.field("passRewards", &self.passRewards());
        ds.field("completeRewards", &self.completeRewards());
        ds.field("displayRewards", &self.displayRewards());
        ds.field("displayDetailRewards", &self.displayDetailRewards());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_StageDropInfoT {
    pub firstPassRewards: Option<Vec<clz_Torappu_ItemBundleT>>,
    pub firstCompleteRewards: Option<Vec<clz_Torappu_ItemBundleT>>,
    pub passRewards: Option<Vec<list_clz_Torappu_WeightItemBundleT>>,
    pub completeRewards: Option<Vec<list_clz_Torappu_WeightItemBundleT>>,
    pub displayRewards: Option<Vec<clz_Torappu_StageData_DisplayRewardsT>>,
    pub displayDetailRewards: Option<Vec<clz_Torappu_StageData_DisplayDetailRewardsT>>,
}
impl Default for clz_Torappu_StageData_StageDropInfoT {
    fn default() -> Self {
        Self {
            firstPassRewards: None,
            firstCompleteRewards: None,
            passRewards: None,
            completeRewards: None,
            displayRewards: None,
            displayDetailRewards: None,
        }
    }
}
impl clz_Torappu_StageData_StageDropInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo<'b>> {
        let firstPassRewards = self.firstPassRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let firstCompleteRewards = self.firstCompleteRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let passRewards = self.passRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let completeRewards = self.completeRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let displayRewards = self.displayRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let displayDetailRewards = self.displayDetailRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_StageData_StageDropInfo::create(
            _fbb,
            &clz_Torappu_StageData_StageDropInfoArgs {
                firstPassRewards,
                firstCompleteRewards,
                passRewards,
                completeRewards,
                displayRewards,
                displayDetailRewards,
            },
        )
    }
}
pub enum clz_Torappu_StageData_ExtraConditionDescOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_ExtraConditionDesc<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_ExtraConditionDesc<'a> {
    type Inner = clz_Torappu_StageData_ExtraConditionDesc<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_ExtraConditionDesc<'a> {
    pub const VT_INDEX: flatbuffers::VOffsetT = 4;
    pub const VT_TEMPLATE: flatbuffers::VOffsetT = 6;
    pub const VT_UNLOCKPARAM: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_ExtraConditionDesc { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_ExtraConditionDescArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_ExtraConditionDesc<'bldr>> {
        let mut builder = clz_Torappu_StageData_ExtraConditionDescBuilder::new(_fbb);
        if let Some(x) = args.unlockParam {
            builder.add_unlockParam(x);
        }
        if let Some(x) = args.template {
            builder.add_template(x);
        }
        builder.add_index(args.index);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_ExtraConditionDescT {
        let index = self.index();
        let template = self.template().map(|x| x.to_string());
        let unlockParam = self
            .unlockParam()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_StageData_ExtraConditionDescT {
            index,
            template,
            unlockParam,
        }
    }

    #[inline]
    pub fn index(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData_ExtraConditionDesc::VT_INDEX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn template(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_ExtraConditionDesc::VT_TEMPLATE,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockParam(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_StageData_ExtraConditionDesc::VT_UNLOCKPARAM,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_ExtraConditionDesc<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("index", Self::VT_INDEX, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "template",
                Self::VT_TEMPLATE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("unlockParam", Self::VT_UNLOCKPARAM, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_ExtraConditionDescArgs<'a> {
    pub index: i32,
    pub template: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockParam: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_StageData_ExtraConditionDescArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_ExtraConditionDescArgs {
            index: 0,
            template: None,
            unlockParam: None,
        }
    }
}

impl Serialize for clz_Torappu_StageData_ExtraConditionDesc<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_ExtraConditionDesc", 3)?;
        s.serialize_field("index", &self.index())?;
        if let Some(f) = self.template() {
            s.serialize_field("template", &f)?;
        } else {
            s.skip_field("template")?;
        }
        if let Some(f) = self.unlockParam() {
            s.serialize_field("unlockParam", &f)?;
        } else {
            s.skip_field("unlockParam")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StageData_ExtraConditionDescBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_ExtraConditionDescBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_index(&mut self, index: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData_ExtraConditionDesc::VT_INDEX, index, 0);
    }
    #[inline]
    pub fn add_template(&mut self, template: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_ExtraConditionDesc::VT_TEMPLATE,
            template,
        );
    }
    #[inline]
    pub fn add_unlockParam(
        &mut self,
        unlockParam: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_ExtraConditionDesc::VT_UNLOCKPARAM,
            unlockParam,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_ExtraConditionDescBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_ExtraConditionDescBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_ExtraConditionDesc<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_ExtraConditionDesc<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_ExtraConditionDesc");
        ds.field("index", &self.index());
        ds.field("template", &self.template());
        ds.field("unlockParam", &self.unlockParam());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_ExtraConditionDescT {
    pub index: i32,
    pub template: Option<String>,
    pub unlockParam: Option<Vec<String>>,
}
impl Default for clz_Torappu_StageData_ExtraConditionDescT {
    fn default() -> Self {
        Self {
            index: 0,
            template: None,
            unlockParam: None,
        }
    }
}
impl clz_Torappu_StageData_ExtraConditionDescT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_ExtraConditionDesc<'b>> {
        let index = self.index;
        let template = self.template.as_ref().map(|x| _fbb.create_string(x));
        let unlockParam = self.unlockParam.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_StageData_ExtraConditionDesc::create(
            _fbb,
            &clz_Torappu_StageData_ExtraConditionDescArgs {
                index,
                template,
                unlockParam,
            },
        )
    }
}
pub enum dict__int__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__int__string<'a> {
    type Inner = dict__int__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__int__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__string<'bldr>> {
        let mut builder = dict__int__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__int__stringT {
        let key = self.key();
        let value = self.value().map(|x| x.to_string());
        dict__int__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(dict__int__string::VT_KEY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__int__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__int__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__int__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__int__stringArgs<'a> {
    pub key: i32,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__int__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__stringArgs {
            key: 0,
            value: None,
        }
    }
}

impl Serialize for dict__int__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__int__string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__int__stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__int__stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_
            .push_slot::<i32>(dict__int__string::VT_KEY, key, 0);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__int__string::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__int__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__int__stringT {
    pub key: i32,
    pub value: Option<String>,
}
impl Default for dict__int__stringT {
    fn default() -> Self {
        Self {
            key: 0,
            value: None,
        }
    }
}
impl dict__int__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__int__string<'b>> {
        let key = self.key;
        let value = self.value.as_ref().map(|x| _fbb.create_string(x));
        dict__int__string::create(_fbb, &dict__int__stringArgs { key, value })
    }
}
pub enum clz_Torappu_StageData_SpecialProgressInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_SpecialProgressInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_SpecialProgressInfo<'a> {
    type Inner = clz_Torappu_StageData_SpecialProgressInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_SpecialProgressInfo<'a> {
    pub const VT_PROGRESSTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_DESCLIST: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_SpecialProgressInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_SpecialProgressInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialProgressInfo<'bldr>> {
        let mut builder = clz_Torappu_StageData_SpecialProgressInfoBuilder::new(_fbb);
        if let Some(x) = args.descList {
            builder.add_descList(x);
        }
        builder.add_progressType(args.progressType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_SpecialProgressInfoT {
        let progressType = self.progressType();
        let descList = self
            .descList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_StageData_SpecialProgressInfoT {
            progressType,
            descList,
        }
    }

    #[inline]
    pub fn progressType(&self) -> enum__Torappu_StageData_SpecialStageUnlockProgressType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageData_SpecialStageUnlockProgressType>(
                    clz_Torappu_StageData_SpecialProgressInfo::VT_PROGRESSTYPE,
                    Some(enum__Torappu_StageData_SpecialStageUnlockProgressType::ONCE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn descList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__int__string<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__int__string>>,
            >>(clz_Torappu_StageData_SpecialProgressInfo::VT_DESCLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_SpecialProgressInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_StageData_SpecialStageUnlockProgressType>(
                "progressType",
                Self::VT_PROGRESSTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__int__string>>,
            >>("descList", Self::VT_DESCLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_SpecialProgressInfoArgs<'a> {
    pub progressType: enum__Torappu_StageData_SpecialStageUnlockProgressType,
    pub descList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__int__string<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_StageData_SpecialProgressInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_SpecialProgressInfoArgs {
            progressType: enum__Torappu_StageData_SpecialStageUnlockProgressType::ONCE,
            descList: None,
        }
    }
}

impl Serialize for clz_Torappu_StageData_SpecialProgressInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_SpecialProgressInfo", 2)?;
        s.serialize_field("progressType", &self.progressType())?;
        if let Some(f) = self.descList() {
            s.serialize_field("descList", &f)?;
        } else {
            s.skip_field("descList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StageData_SpecialProgressInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_SpecialProgressInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_progressType(
        &mut self,
        progressType: enum__Torappu_StageData_SpecialStageUnlockProgressType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_StageData_SpecialStageUnlockProgressType>(
                clz_Torappu_StageData_SpecialProgressInfo::VT_PROGRESSTYPE,
                progressType,
                enum__Torappu_StageData_SpecialStageUnlockProgressType::ONCE,
            );
    }
    #[inline]
    pub fn add_descList(
        &mut self,
        descList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__int__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_SpecialProgressInfo::VT_DESCLIST,
            descList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_SpecialProgressInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_SpecialProgressInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialProgressInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_SpecialProgressInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_SpecialProgressInfo");
        ds.field("progressType", &self.progressType());
        ds.field("descList", &self.descList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_SpecialProgressInfoT {
    pub progressType: enum__Torappu_StageData_SpecialStageUnlockProgressType,
    pub descList: Option<Vec<dict__int__stringT>>,
}
impl Default for clz_Torappu_StageData_SpecialProgressInfoT {
    fn default() -> Self {
        Self {
            progressType: enum__Torappu_StageData_SpecialStageUnlockProgressType::ONCE,
            descList: None,
        }
    }
}
impl clz_Torappu_StageData_SpecialProgressInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialProgressInfo<'b>> {
        let progressType = self.progressType;
        let descList = self.descList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_StageData_SpecialProgressInfo::create(
            _fbb,
            &clz_Torappu_StageData_SpecialProgressInfoArgs {
                progressType,
                descList,
            },
        )
    }
}
pub enum clz_Torappu_StageData_SpecialStoryInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_SpecialStoryInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_SpecialStoryInfo<'a> {
    type Inner = clz_Torappu_StageData_SpecialStoryInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_SpecialStoryInfo<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_REWARDS: flatbuffers::VOffsetT = 6;
    pub const VT_PROGRESSINFO: flatbuffers::VOffsetT = 8;
    pub const VT_IMAGEID: flatbuffers::VOffsetT = 10;
    pub const VT_KEYITEMID: flatbuffers::VOffsetT = 12;
    pub const VT_UNLOCKDESC: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_SpecialStoryInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_SpecialStoryInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialStoryInfo<'bldr>> {
        let mut builder = clz_Torappu_StageData_SpecialStoryInfoBuilder::new(_fbb);
        if let Some(x) = args.unlockDesc {
            builder.add_unlockDesc(x);
        }
        if let Some(x) = args.keyItemId {
            builder.add_keyItemId(x);
        }
        if let Some(x) = args.imageId {
            builder.add_imageId(x);
        }
        if let Some(x) = args.progressInfo {
            builder.add_progressInfo(x);
        }
        if let Some(x) = args.rewards {
            builder.add_rewards(x);
        }
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_SpecialStoryInfoT {
        let stageId = self.stageId().map(|x| x.to_string());
        let rewards = self
            .rewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let progressInfo = self.progressInfo().map(|x| Box::new(x.unpack()));
        let imageId = self.imageId().map(|x| x.to_string());
        let keyItemId = self.keyItemId().map(|x| x.to_string());
        let unlockDesc = self.unlockDesc().map(|x| x.to_string());
        clz_Torappu_StageData_SpecialStoryInfoT {
            stageId,
            rewards,
            progressInfo,
            imageId,
            keyItemId,
            unlockDesc,
        }
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_SpecialStoryInfo::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn rewards(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_StageData_SpecialStoryInfo::VT_REWARDS, None)
        }
    }
    #[inline]
    pub fn progressInfo(&self) -> Option<clz_Torappu_StageData_SpecialProgressInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData_SpecialProgressInfo>>(
                    clz_Torappu_StageData_SpecialStoryInfo::VT_PROGRESSINFO,
                    None,
                )
        }
    }
    #[inline]
    pub fn imageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_SpecialStoryInfo::VT_IMAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn keyItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_SpecialStoryInfo::VT_KEYITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_SpecialStoryInfo::VT_UNLOCKDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_SpecialStoryInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("rewards", Self::VT_REWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData_SpecialProgressInfo>>(
                "progressInfo",
                Self::VT_PROGRESSINFO,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("imageId", Self::VT_IMAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "keyItemId",
                Self::VT_KEYITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockDesc",
                Self::VT_UNLOCKDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_SpecialStoryInfoArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
    pub progressInfo: Option<flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialProgressInfo<'a>>>,
    pub imageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub keyItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_StageData_SpecialStoryInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_SpecialStoryInfoArgs {
            stageId: None,
            rewards: None,
            progressInfo: None,
            imageId: None,
            keyItemId: None,
            unlockDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_StageData_SpecialStoryInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_SpecialStoryInfo", 6)?;
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        if let Some(f) = self.rewards() {
            s.serialize_field("rewards", &f)?;
        } else {
            s.skip_field("rewards")?;
        }
        if let Some(f) = self.progressInfo() {
            s.serialize_field("progressInfo", &f)?;
        } else {
            s.skip_field("progressInfo")?;
        }
        if let Some(f) = self.imageId() {
            s.serialize_field("imageId", &f)?;
        } else {
            s.skip_field("imageId")?;
        }
        if let Some(f) = self.keyItemId() {
            s.serialize_field("keyItemId", &f)?;
        } else {
            s.skip_field("keyItemId")?;
        }
        if let Some(f) = self.unlockDesc() {
            s.serialize_field("unlockDesc", &f)?;
        } else {
            s.skip_field("unlockDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StageData_SpecialStoryInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_SpecialStoryInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_SpecialStoryInfo::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_rewards(
        &mut self,
        rewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_SpecialStoryInfo::VT_REWARDS,
            rewards,
        );
    }
    #[inline]
    pub fn add_progressInfo(
        &mut self,
        progressInfo: flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialProgressInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialProgressInfo>>(
                clz_Torappu_StageData_SpecialStoryInfo::VT_PROGRESSINFO,
                progressInfo,
            );
    }
    #[inline]
    pub fn add_imageId(&mut self, imageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_SpecialStoryInfo::VT_IMAGEID,
            imageId,
        );
    }
    #[inline]
    pub fn add_keyItemId(&mut self, keyItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_SpecialStoryInfo::VT_KEYITEMID,
            keyItemId,
        );
    }
    #[inline]
    pub fn add_unlockDesc(&mut self, unlockDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_SpecialStoryInfo::VT_UNLOCKDESC,
            unlockDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_SpecialStoryInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_SpecialStoryInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialStoryInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_SpecialStoryInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_SpecialStoryInfo");
        ds.field("stageId", &self.stageId());
        ds.field("rewards", &self.rewards());
        ds.field("progressInfo", &self.progressInfo());
        ds.field("imageId", &self.imageId());
        ds.field("keyItemId", &self.keyItemId());
        ds.field("unlockDesc", &self.unlockDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_SpecialStoryInfoT {
    pub stageId: Option<String>,
    pub rewards: Option<Vec<clz_Torappu_ItemBundleT>>,
    pub progressInfo: Option<Box<clz_Torappu_StageData_SpecialProgressInfoT>>,
    pub imageId: Option<String>,
    pub keyItemId: Option<String>,
    pub unlockDesc: Option<String>,
}
impl Default for clz_Torappu_StageData_SpecialStoryInfoT {
    fn default() -> Self {
        Self {
            stageId: None,
            rewards: None,
            progressInfo: None,
            imageId: None,
            keyItemId: None,
            unlockDesc: None,
        }
    }
}
impl clz_Torappu_StageData_SpecialStoryInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialStoryInfo<'b>> {
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let rewards = self.rewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let progressInfo = self.progressInfo.as_ref().map(|x| x.pack(_fbb));
        let imageId = self.imageId.as_ref().map(|x| _fbb.create_string(x));
        let keyItemId = self.keyItemId.as_ref().map(|x| _fbb.create_string(x));
        let unlockDesc = self.unlockDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_StageData_SpecialStoryInfo::create(
            _fbb,
            &clz_Torappu_StageData_SpecialStoryInfoArgs {
                stageId,
                rewards,
                progressInfo,
                imageId,
                keyItemId,
                unlockDesc,
            },
        )
    }
}
pub enum clz_Torappu_StageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData<'a> {
    type Inner = clz_Torappu_StageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData<'a> {
    pub const VT_STAGETYPE: flatbuffers::VOffsetT = 4;
    pub const VT_DIFFICULTY: flatbuffers::VOffsetT = 6;
    pub const VT_PERFORMANCESTAGEFLAG: flatbuffers::VOffsetT = 8;
    pub const VT_DIFFGROUP: flatbuffers::VOffsetT = 10;
    pub const VT_UNLOCKCONDITION: flatbuffers::VOffsetT = 12;
    pub const VT_STAGEID: flatbuffers::VOffsetT = 14;
    pub const VT_LEVELID: flatbuffers::VOffsetT = 16;
    pub const VT_ZONEID: flatbuffers::VOffsetT = 18;
    pub const VT_CODE: flatbuffers::VOffsetT = 20;
    pub const VT_NAME: flatbuffers::VOffsetT = 22;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 24;
    pub const VT_HARDSTAGEDID: flatbuffers::VOffsetT = 26;
    pub const VT_SIXSTARSTAGEID: flatbuffers::VOffsetT = 28;
    pub const VT_DANGERLEVEL: flatbuffers::VOffsetT = 30;
    pub const VT_DANGERPOINT: flatbuffers::VOffsetT = 32;
    pub const VT_LOADINGPICID: flatbuffers::VOffsetT = 34;
    pub const VT_CANPRACTICE: flatbuffers::VOffsetT = 36;
    pub const VT_CANBATTLEREPLAY: flatbuffers::VOffsetT = 38;
    pub const VT_APCOST: flatbuffers::VOffsetT = 40;
    pub const VT_APFAILRETURN: flatbuffers::VOffsetT = 42;
    pub const VT_MAXSLOT: flatbuffers::VOffsetT = 44;
    pub const VT_ETITEMID: flatbuffers::VOffsetT = 46;
    pub const VT_ETCOST: flatbuffers::VOffsetT = 48;
    pub const VT_ETFAILRETURN: flatbuffers::VOffsetT = 50;
    pub const VT_ETBUTTONSTYLE: flatbuffers::VOffsetT = 52;
    pub const VT_APPROTECTTIMES: flatbuffers::VOffsetT = 54;
    pub const VT_DIAMONDONCEDROP: flatbuffers::VOffsetT = 56;
    pub const VT_PRACTICETICKETCOST: flatbuffers::VOffsetT = 58;
    pub const VT_DAILYSTAGEDIFFICULTY: flatbuffers::VOffsetT = 60;
    pub const VT_EXPGAIN: flatbuffers::VOffsetT = 62;
    pub const VT_GOLDGAIN: flatbuffers::VOffsetT = 64;
    pub const VT_LOSEEXPGAIN: flatbuffers::VOffsetT = 66;
    pub const VT_LOSEGOLDGAIN: flatbuffers::VOffsetT = 68;
    pub const VT_PASSFAVOR: flatbuffers::VOffsetT = 70;
    pub const VT_COMPLETEFAVOR: flatbuffers::VOffsetT = 72;
    pub const VT_SLPROGRESS: flatbuffers::VOffsetT = 74;
    pub const VT_DISPLAYMAINITEM: flatbuffers::VOffsetT = 76;
    pub const VT_HILIGHTMARK: flatbuffers::VOffsetT = 78;
    pub const VT_BOSSMARK: flatbuffers::VOffsetT = 80;
    pub const VT_ISPREDEFINED: flatbuffers::VOffsetT = 82;
    pub const VT_ISHARDPREDEFINED: flatbuffers::VOffsetT = 84;
    pub const VT_ISSKILLSELECTABLEPREDEFINED: flatbuffers::VOffsetT = 86;
    pub const VT_ISSTORYONLY: flatbuffers::VOffsetT = 88;
    pub const VT_APPEARANCESTYLE: flatbuffers::VOffsetT = 90;
    pub const VT_STAGEDROPINFO: flatbuffers::VOffsetT = 92;
    pub const VT_CANUSECHARM: flatbuffers::VOffsetT = 94;
    pub const VT_CANUSETECH: flatbuffers::VOffsetT = 96;
    pub const VT_CANUSETRAPTOOL: flatbuffers::VOffsetT = 98;
    pub const VT_CANUSEBATTLEPERFORMANCE: flatbuffers::VOffsetT = 100;
    pub const VT_CANUSEFIREWORK: flatbuffers::VOffsetT = 102;
    pub const VT_CANMULTIPLEBATTLE: flatbuffers::VOffsetT = 104;
    pub const VT_STARTBUTTONOVERRIDEID: flatbuffers::VOffsetT = 106;
    pub const VT_ISSTAGEPATCH: flatbuffers::VOffsetT = 108;
    pub const VT_MAINSTAGEID: flatbuffers::VOffsetT = 110;
    pub const VT_EXTRACONDITION: flatbuffers::VOffsetT = 112;
    pub const VT_EXTRAINFO: flatbuffers::VOffsetT = 114;
    pub const VT_SIXSTARBASEDESC: flatbuffers::VOffsetT = 116;
    pub const VT_SIXSTARDISPLAYREWARDLIST: flatbuffers::VOffsetT = 118;
    pub const VT_ADVANCEDRUNEIDLIST1: flatbuffers::VOffsetT = 120;
    pub const VT_ADVANCEDRUNEIDLIST2: flatbuffers::VOffsetT = 122;
    pub const VT_USESPECIALSIZEMAPPREVIEW: flatbuffers::VOffsetT = 124;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData<'bldr>> {
        let mut builder = clz_Torappu_StageDataBuilder::new(_fbb);
        if let Some(x) = args.advancedRuneIdList2 {
            builder.add_advancedRuneIdList2(x);
        }
        if let Some(x) = args.advancedRuneIdList1 {
            builder.add_advancedRuneIdList1(x);
        }
        if let Some(x) = args.sixStarDisplayRewardList {
            builder.add_sixStarDisplayRewardList(x);
        }
        if let Some(x) = args.sixStarBaseDesc {
            builder.add_sixStarBaseDesc(x);
        }
        if let Some(x) = args.extraInfo {
            builder.add_extraInfo(x);
        }
        if let Some(x) = args.extraCondition {
            builder.add_extraCondition(x);
        }
        if let Some(x) = args.mainStageId {
            builder.add_mainStageId(x);
        }
        if let Some(x) = args.startButtonOverrideId {
            builder.add_startButtonOverrideId(x);
        }
        if let Some(x) = args.stageDropInfo {
            builder.add_stageDropInfo(x);
        }
        builder.add_appearanceStyle(args.appearanceStyle);
        if let Some(x) = args.displayMainItem {
            builder.add_displayMainItem(x);
        }
        builder.add_slProgress(args.slProgress);
        builder.add_completeFavor(args.completeFavor);
        builder.add_passFavor(args.passFavor);
        builder.add_loseGoldGain(args.loseGoldGain);
        builder.add_loseExpGain(args.loseExpGain);
        builder.add_goldGain(args.goldGain);
        builder.add_expGain(args.expGain);
        builder.add_dailyStageDifficulty(args.dailyStageDifficulty);
        builder.add_practiceTicketCost(args.practiceTicketCost);
        builder.add_diamondOnceDrop(args.diamondOnceDrop);
        builder.add_apProtectTimes(args.apProtectTimes);
        if let Some(x) = args.etButtonStyle {
            builder.add_etButtonStyle(x);
        }
        builder.add_etFailReturn(args.etFailReturn);
        builder.add_etCost(args.etCost);
        if let Some(x) = args.etItemId {
            builder.add_etItemId(x);
        }
        builder.add_maxSlot(args.maxSlot);
        builder.add_apFailReturn(args.apFailReturn);
        builder.add_apCost(args.apCost);
        if let Some(x) = args.loadingPicId {
            builder.add_loadingPicId(x);
        }
        builder.add_dangerPoint(args.dangerPoint);
        if let Some(x) = args.dangerLevel {
            builder.add_dangerLevel(x);
        }
        if let Some(x) = args.sixStarStageId {
            builder.add_sixStarStageId(x);
        }
        if let Some(x) = args.hardStagedId {
            builder.add_hardStagedId(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.code {
            builder.add_code(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        if let Some(x) = args.levelId {
            builder.add_levelId(x);
        }
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        if let Some(x) = args.unlockCondition {
            builder.add_unlockCondition(x);
        }
        builder.add_diffGroup(args.diffGroup);
        builder.add_performanceStageFlag(args.performanceStageFlag);
        builder.add_difficulty(args.difficulty);
        builder.add_stageType(args.stageType);
        builder.add_useSpecialSizeMapPreview(args.useSpecialSizeMapPreview);
        builder.add_isStagePatch(args.isStagePatch);
        builder.add_canMultipleBattle(args.canMultipleBattle);
        builder.add_canUseFirework(args.canUseFirework);
        builder.add_canUseBattlePerformance(args.canUseBattlePerformance);
        builder.add_canUseTrapTool(args.canUseTrapTool);
        builder.add_canUseTech(args.canUseTech);
        builder.add_canUseCharm(args.canUseCharm);
        builder.add_isStoryOnly(args.isStoryOnly);
        builder.add_isSkillSelectablePredefined(args.isSkillSelectablePredefined);
        builder.add_isHardPredefined(args.isHardPredefined);
        builder.add_isPredefined(args.isPredefined);
        builder.add_bossMark(args.bossMark);
        builder.add_hilightMark(args.hilightMark);
        builder.add_canBattleReplay(args.canBattleReplay);
        builder.add_canPractice(args.canPractice);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageDataT {
        let stageType = self.stageType();
        let difficulty = self.difficulty();
        let performanceStageFlag = self.performanceStageFlag();
        let diffGroup = self.diffGroup();
        let unlockCondition = self
            .unlockCondition()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let stageId = self.stageId().map(|x| x.to_string());
        let levelId = self.levelId().map(|x| x.to_string());
        let zoneId = self.zoneId().map(|x| x.to_string());
        let code = self.code().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let hardStagedId = self.hardStagedId().map(|x| x.to_string());
        let sixStarStageId = self.sixStarStageId().map(|x| x.to_string());
        let dangerLevel = self.dangerLevel().map(|x| x.to_string());
        let dangerPoint = self.dangerPoint();
        let loadingPicId = self.loadingPicId().map(|x| x.to_string());
        let canPractice = self.canPractice();
        let canBattleReplay = self.canBattleReplay();
        let apCost = self.apCost();
        let apFailReturn = self.apFailReturn();
        let maxSlot = self.maxSlot();
        let etItemId = self.etItemId().map(|x| x.to_string());
        let etCost = self.etCost();
        let etFailReturn = self.etFailReturn();
        let etButtonStyle = self.etButtonStyle().map(|x| x.to_string());
        let apProtectTimes = self.apProtectTimes();
        let diamondOnceDrop = self.diamondOnceDrop();
        let practiceTicketCost = self.practiceTicketCost();
        let dailyStageDifficulty = self.dailyStageDifficulty();
        let expGain = self.expGain();
        let goldGain = self.goldGain();
        let loseExpGain = self.loseExpGain();
        let loseGoldGain = self.loseGoldGain();
        let passFavor = self.passFavor();
        let completeFavor = self.completeFavor();
        let slProgress = self.slProgress();
        let displayMainItem = self.displayMainItem().map(|x| x.to_string());
        let hilightMark = self.hilightMark();
        let bossMark = self.bossMark();
        let isPredefined = self.isPredefined();
        let isHardPredefined = self.isHardPredefined();
        let isSkillSelectablePredefined = self.isSkillSelectablePredefined();
        let isStoryOnly = self.isStoryOnly();
        let appearanceStyle = self.appearanceStyle();
        let stageDropInfo = self.stageDropInfo().map(|x| Box::new(x.unpack()));
        let canUseCharm = self.canUseCharm();
        let canUseTech = self.canUseTech();
        let canUseTrapTool = self.canUseTrapTool();
        let canUseBattlePerformance = self.canUseBattlePerformance();
        let canUseFirework = self.canUseFirework();
        let canMultipleBattle = self.canMultipleBattle();
        let startButtonOverrideId = self.startButtonOverrideId().map(|x| x.to_string());
        let isStagePatch = self.isStagePatch();
        let mainStageId = self.mainStageId().map(|x| x.to_string());
        let extraCondition = self
            .extraCondition()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let extraInfo = self
            .extraInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let sixStarBaseDesc = self.sixStarBaseDesc().map(|x| x.to_string());
        let sixStarDisplayRewardList = self
            .sixStarDisplayRewardList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let advancedRuneIdList1 = self
            .advancedRuneIdList1()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let advancedRuneIdList2 = self
            .advancedRuneIdList2()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let useSpecialSizeMapPreview = self.useSpecialSizeMapPreview();
        clz_Torappu_StageDataT {
            stageType,
            difficulty,
            performanceStageFlag,
            diffGroup,
            unlockCondition,
            stageId,
            levelId,
            zoneId,
            code,
            name,
            description,
            hardStagedId,
            sixStarStageId,
            dangerLevel,
            dangerPoint,
            loadingPicId,
            canPractice,
            canBattleReplay,
            apCost,
            apFailReturn,
            maxSlot,
            etItemId,
            etCost,
            etFailReturn,
            etButtonStyle,
            apProtectTimes,
            diamondOnceDrop,
            practiceTicketCost,
            dailyStageDifficulty,
            expGain,
            goldGain,
            loseExpGain,
            loseGoldGain,
            passFavor,
            completeFavor,
            slProgress,
            displayMainItem,
            hilightMark,
            bossMark,
            isPredefined,
            isHardPredefined,
            isSkillSelectablePredefined,
            isStoryOnly,
            appearanceStyle,
            stageDropInfo,
            canUseCharm,
            canUseTech,
            canUseTrapTool,
            canUseBattlePerformance,
            canUseFirework,
            canMultipleBattle,
            startButtonOverrideId,
            isStagePatch,
            mainStageId,
            extraCondition,
            extraInfo,
            sixStarBaseDesc,
            sixStarDisplayRewardList,
            advancedRuneIdList1,
            advancedRuneIdList2,
            useSpecialSizeMapPreview,
        }
    }

    #[inline]
    pub fn stageType(&self) -> enum__Torappu_StageType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageType>(
                    clz_Torappu_StageData::VT_STAGETYPE,
                    Some(enum__Torappu_StageType::MAIN),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn difficulty(&self) -> enum__Torappu_LevelData_Difficulty {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_LevelData_Difficulty>(
                    clz_Torappu_StageData::VT_DIFFICULTY,
                    Some(enum__Torappu_LevelData_Difficulty::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn performanceStageFlag(&self) -> enum__Torappu_StageData_PerformanceStageFlag {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageData_PerformanceStageFlag>(
                    clz_Torappu_StageData::VT_PERFORMANCESTAGEFLAG,
                    Some(enum__Torappu_StageData_PerformanceStageFlag::NORMAL_STAGE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn diffGroup(&self) -> enum__Torappu_StageDiffGroup {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDiffGroup>(
                    clz_Torappu_StageData::VT_DIFFGROUP,
                    Some(enum__Torappu_StageDiffGroup::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockCondition(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ConditionDesc<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ConditionDesc>,
                >,
            >>(clz_Torappu_StageData::VT_UNLOCKCONDITION, None)
        }
    }
    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_StageData::VT_STAGEID, None)
        }
    }
    #[inline]
    pub fn levelId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_StageData::VT_LEVELID, None)
        }
    }
    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_StageData::VT_ZONEID, None)
        }
    }
    #[inline]
    pub fn code(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_StageData::VT_CODE, None)
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_StageData::VT_NAME, None)
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn hardStagedId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_HARDSTAGEDID,
                None,
            )
        }
    }
    #[inline]
    pub fn sixStarStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_SIXSTARSTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn dangerLevel(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_DANGERLEVEL,
                None,
            )
        }
    }
    #[inline]
    pub fn dangerPoint(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_StageData::VT_DANGERPOINT, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn loadingPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_LOADINGPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn canPractice(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_CANPRACTICE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn canBattleReplay(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_CANBATTLEREPLAY, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn apCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_APCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn apFailReturn(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_APFAILRETURN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn maxSlot(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_MAXSLOT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn etItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_StageData::VT_ETITEMID, None)
        }
    }
    #[inline]
    pub fn etCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_ETCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn etFailReturn(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_ETFAILRETURN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn etButtonStyle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_ETBUTTONSTYLE,
                None,
            )
        }
    }
    #[inline]
    pub fn apProtectTimes(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_APPROTECTTIMES, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn diamondOnceDrop(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_DIAMONDONCEDROP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn practiceTicketCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_PRACTICETICKETCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn dailyStageDifficulty(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_DAILYSTAGEDIFFICULTY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn expGain(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_EXPGAIN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn goldGain(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_GOLDGAIN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn loseExpGain(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_LOSEEXPGAIN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn loseGoldGain(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_LOSEGOLDGAIN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn passFavor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_PASSFAVOR, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn completeFavor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_COMPLETEFAVOR, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn slProgress(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_SLPROGRESS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn displayMainItem(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_DISPLAYMAINITEM,
                None,
            )
        }
    }
    #[inline]
    pub fn hilightMark(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_HILIGHTMARK, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn bossMark(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_BOSSMARK, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isPredefined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_ISPREDEFINED, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isHardPredefined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_ISHARDPREDEFINED, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isSkillSelectablePredefined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_StageData::VT_ISSKILLSELECTABLEPREDEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isStoryOnly(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_ISSTORYONLY, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn appearanceStyle(&self) -> enum__Torappu_AppearanceStyle {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_AppearanceStyle>(
                    clz_Torappu_StageData::VT_APPEARANCESTYLE,
                    Some(enum__Torappu_AppearanceStyle::MAIN_NORMAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn stageDropInfo(&self) -> Option<clz_Torappu_StageData_StageDropInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData_StageDropInfo>>(
                    clz_Torappu_StageData::VT_STAGEDROPINFO,
                    None,
                )
        }
    }
    #[inline]
    pub fn canUseCharm(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_CANUSECHARM, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn canUseTech(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_CANUSETECH, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn canUseTrapTool(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_CANUSETRAPTOOL, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn canUseBattlePerformance(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_StageData::VT_CANUSEBATTLEPERFORMANCE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn canUseFirework(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_CANUSEFIREWORK, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn canMultipleBattle(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_CANMULTIPLEBATTLE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn startButtonOverrideId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_STARTBUTTONOVERRIDEID,
                None,
            )
        }
    }
    #[inline]
    pub fn isStagePatch(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_ISSTAGEPATCH, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn mainStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_MAINSTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn extraCondition(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ExtraConditionDesc<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ExtraConditionDesc>,
                >,
            >>(clz_Torappu_StageData::VT_EXTRACONDITION, None)
        }
    }
    #[inline]
    pub fn extraInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_SpecialStoryInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_SpecialStoryInfo>,
                >,
            >>(clz_Torappu_StageData::VT_EXTRAINFO, None)
        }
    }
    #[inline]
    pub fn sixStarBaseDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_SIXSTARBASEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn sixStarDisplayRewardList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_StageData::VT_SIXSTARDISPLAYREWARDLIST, None)
        }
    }
    #[inline]
    pub fn advancedRuneIdList1(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_StageData::VT_ADVANCEDRUNEIDLIST1, None)
        }
    }
    #[inline]
    pub fn advancedRuneIdList2(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_StageData::VT_ADVANCEDRUNEIDLIST2, None)
        }
    }
    #[inline]
    pub fn useSpecialSizeMapPreview(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_StageData::VT_USESPECIALSIZEMAPPREVIEW,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_StageType>("stageType", Self::VT_STAGETYPE, false)?
            .visit_field::<enum__Torappu_LevelData_Difficulty>(
                "difficulty",
                Self::VT_DIFFICULTY,
                false,
            )?
            .visit_field::<enum__Torappu_StageData_PerformanceStageFlag>(
                "performanceStageFlag",
                Self::VT_PERFORMANCESTAGEFLAG,
                false,
            )?
            .visit_field::<enum__Torappu_StageDiffGroup>("diffGroup", Self::VT_DIFFGROUP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ConditionDesc>,
                >,
            >>("unlockCondition", Self::VT_UNLOCKCONDITION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("levelId", Self::VT_LEVELID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("code", Self::VT_CODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "hardStagedId",
                Self::VT_HARDSTAGEDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "sixStarStageId",
                Self::VT_SIXSTARSTAGEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dangerLevel",
                Self::VT_DANGERLEVEL,
                false,
            )?
            .visit_field::<f32>("dangerPoint", Self::VT_DANGERPOINT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "loadingPicId",
                Self::VT_LOADINGPICID,
                false,
            )?
            .visit_field::<bool>("canPractice", Self::VT_CANPRACTICE, false)?
            .visit_field::<bool>("canBattleReplay", Self::VT_CANBATTLEREPLAY, false)?
            .visit_field::<i32>("apCost", Self::VT_APCOST, false)?
            .visit_field::<i32>("apFailReturn", Self::VT_APFAILRETURN, false)?
            .visit_field::<i32>("maxSlot", Self::VT_MAXSLOT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "etItemId",
                Self::VT_ETITEMID,
                false,
            )?
            .visit_field::<i32>("etCost", Self::VT_ETCOST, false)?
            .visit_field::<i32>("etFailReturn", Self::VT_ETFAILRETURN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "etButtonStyle",
                Self::VT_ETBUTTONSTYLE,
                false,
            )?
            .visit_field::<i32>("apProtectTimes", Self::VT_APPROTECTTIMES, false)?
            .visit_field::<i32>("diamondOnceDrop", Self::VT_DIAMONDONCEDROP, false)?
            .visit_field::<i32>("practiceTicketCost", Self::VT_PRACTICETICKETCOST, false)?
            .visit_field::<i32>("dailyStageDifficulty", Self::VT_DAILYSTAGEDIFFICULTY, false)?
            .visit_field::<i32>("expGain", Self::VT_EXPGAIN, false)?
            .visit_field::<i32>("goldGain", Self::VT_GOLDGAIN, false)?
            .visit_field::<i32>("loseExpGain", Self::VT_LOSEEXPGAIN, false)?
            .visit_field::<i32>("loseGoldGain", Self::VT_LOSEGOLDGAIN, false)?
            .visit_field::<i32>("passFavor", Self::VT_PASSFAVOR, false)?
            .visit_field::<i32>("completeFavor", Self::VT_COMPLETEFAVOR, false)?
            .visit_field::<i32>("slProgress", Self::VT_SLPROGRESS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "displayMainItem",
                Self::VT_DISPLAYMAINITEM,
                false,
            )?
            .visit_field::<bool>("hilightMark", Self::VT_HILIGHTMARK, false)?
            .visit_field::<bool>("bossMark", Self::VT_BOSSMARK, false)?
            .visit_field::<bool>("isPredefined", Self::VT_ISPREDEFINED, false)?
            .visit_field::<bool>("isHardPredefined", Self::VT_ISHARDPREDEFINED, false)?
            .visit_field::<bool>(
                "isSkillSelectablePredefined",
                Self::VT_ISSKILLSELECTABLEPREDEFINED,
                false,
            )?
            .visit_field::<bool>("isStoryOnly", Self::VT_ISSTORYONLY, false)?
            .visit_field::<enum__Torappu_AppearanceStyle>(
                "appearanceStyle",
                Self::VT_APPEARANCESTYLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData_StageDropInfo>>(
                "stageDropInfo",
                Self::VT_STAGEDROPINFO,
                false,
            )?
            .visit_field::<bool>("canUseCharm", Self::VT_CANUSECHARM, false)?
            .visit_field::<bool>("canUseTech", Self::VT_CANUSETECH, false)?
            .visit_field::<bool>("canUseTrapTool", Self::VT_CANUSETRAPTOOL, false)?
            .visit_field::<bool>(
                "canUseBattlePerformance",
                Self::VT_CANUSEBATTLEPERFORMANCE,
                false,
            )?
            .visit_field::<bool>("canUseFirework", Self::VT_CANUSEFIREWORK, false)?
            .visit_field::<bool>("canMultipleBattle", Self::VT_CANMULTIPLEBATTLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "startButtonOverrideId",
                Self::VT_STARTBUTTONOVERRIDEID,
                false,
            )?
            .visit_field::<bool>("isStagePatch", Self::VT_ISSTAGEPATCH, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mainStageId",
                Self::VT_MAINSTAGEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ExtraConditionDesc>,
                >,
            >>("extraCondition", Self::VT_EXTRACONDITION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_SpecialStoryInfo>,
                >,
            >>("extraInfo", Self::VT_EXTRAINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "sixStarBaseDesc",
                Self::VT_SIXSTARBASEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(
                "sixStarDisplayRewardList",
                Self::VT_SIXSTARDISPLAYREWARDLIST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("advancedRuneIdList1", Self::VT_ADVANCEDRUNEIDLIST1, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("advancedRuneIdList2", Self::VT_ADVANCEDRUNEIDLIST2, false)?
            .visit_field::<bool>(
                "useSpecialSizeMapPreview",
                Self::VT_USESPECIALSIZEMAPPREVIEW,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageDataArgs<'a> {
    pub stageType: enum__Torappu_StageType,
    pub difficulty: enum__Torappu_LevelData_Difficulty,
    pub performanceStageFlag: enum__Torappu_StageData_PerformanceStageFlag,
    pub diffGroup: enum__Torappu_StageDiffGroup,
    pub unlockCondition: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ConditionDesc<'a>>,
            >,
        >,
    >,
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub levelId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub code: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hardStagedId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sixStarStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dangerLevel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dangerPoint: f32,
    pub loadingPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub canPractice: bool,
    pub canBattleReplay: bool,
    pub apCost: i32,
    pub apFailReturn: i32,
    pub maxSlot: i32,
    pub etItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub etCost: i32,
    pub etFailReturn: i32,
    pub etButtonStyle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub apProtectTimes: i32,
    pub diamondOnceDrop: i32,
    pub practiceTicketCost: i32,
    pub dailyStageDifficulty: i32,
    pub expGain: i32,
    pub goldGain: i32,
    pub loseExpGain: i32,
    pub loseGoldGain: i32,
    pub passFavor: i32,
    pub completeFavor: i32,
    pub slProgress: i32,
    pub displayMainItem: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hilightMark: bool,
    pub bossMark: bool,
    pub isPredefined: bool,
    pub isHardPredefined: bool,
    pub isSkillSelectablePredefined: bool,
    pub isStoryOnly: bool,
    pub appearanceStyle: enum__Torappu_AppearanceStyle,
    pub stageDropInfo: Option<flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo<'a>>>,
    pub canUseCharm: bool,
    pub canUseTech: bool,
    pub canUseTrapTool: bool,
    pub canUseBattlePerformance: bool,
    pub canUseFirework: bool,
    pub canMultipleBattle: bool,
    pub startButtonOverrideId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isStagePatch: bool,
    pub mainStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub extraCondition: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ExtraConditionDesc<'a>>,
            >,
        >,
    >,
    pub extraInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_SpecialStoryInfo<'a>>,
            >,
        >,
    >,
    pub sixStarBaseDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sixStarDisplayRewardList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
    pub advancedRuneIdList1: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub advancedRuneIdList2: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub useSpecialSizeMapPreview: bool,
}
impl<'a> Default for clz_Torappu_StageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageDataArgs {
            stageType: enum__Torappu_StageType::MAIN,
            difficulty: enum__Torappu_LevelData_Difficulty::NONE,
            performanceStageFlag: enum__Torappu_StageData_PerformanceStageFlag::NORMAL_STAGE,
            diffGroup: enum__Torappu_StageDiffGroup::NONE,
            unlockCondition: None,
            stageId: None,
            levelId: None,
            zoneId: None,
            code: None,
            name: None,
            description: None,
            hardStagedId: None,
            sixStarStageId: None,
            dangerLevel: None,
            dangerPoint: 0.0,
            loadingPicId: None,
            canPractice: false,
            canBattleReplay: false,
            apCost: 0,
            apFailReturn: 0,
            maxSlot: 0,
            etItemId: None,
            etCost: 0,
            etFailReturn: 0,
            etButtonStyle: None,
            apProtectTimes: 0,
            diamondOnceDrop: 0,
            practiceTicketCost: 0,
            dailyStageDifficulty: 0,
            expGain: 0,
            goldGain: 0,
            loseExpGain: 0,
            loseGoldGain: 0,
            passFavor: 0,
            completeFavor: 0,
            slProgress: 0,
            displayMainItem: None,
            hilightMark: false,
            bossMark: false,
            isPredefined: false,
            isHardPredefined: false,
            isSkillSelectablePredefined: false,
            isStoryOnly: false,
            appearanceStyle: enum__Torappu_AppearanceStyle::MAIN_NORMAL,
            stageDropInfo: None,
            canUseCharm: false,
            canUseTech: false,
            canUseTrapTool: false,
            canUseBattlePerformance: false,
            canUseFirework: false,
            canMultipleBattle: false,
            startButtonOverrideId: None,
            isStagePatch: false,
            mainStageId: None,
            extraCondition: None,
            extraInfo: None,
            sixStarBaseDesc: None,
            sixStarDisplayRewardList: None,
            advancedRuneIdList1: None,
            advancedRuneIdList2: None,
            useSpecialSizeMapPreview: false,
        }
    }
}

impl Serialize for clz_Torappu_StageData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData", 61)?;
        s.serialize_field("stageType", &self.stageType())?;
        s.serialize_field("difficulty", &self.difficulty())?;
        s.serialize_field("performanceStageFlag", &self.performanceStageFlag())?;
        s.serialize_field("diffGroup", &self.diffGroup())?;
        if let Some(f) = self.unlockCondition() {
            s.serialize_field("unlockCondition", &f)?;
        } else {
            s.skip_field("unlockCondition")?;
        }
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        if let Some(f) = self.levelId() {
            s.serialize_field("levelId", &f)?;
        } else {
            s.skip_field("levelId")?;
        }
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.code() {
            s.serialize_field("code", &f)?;
        } else {
            s.skip_field("code")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.hardStagedId() {
            s.serialize_field("hardStagedId", &f)?;
        } else {
            s.skip_field("hardStagedId")?;
        }
        if let Some(f) = self.sixStarStageId() {
            s.serialize_field("sixStarStageId", &f)?;
        } else {
            s.skip_field("sixStarStageId")?;
        }
        if let Some(f) = self.dangerLevel() {
            s.serialize_field("dangerLevel", &f)?;
        } else {
            s.skip_field("dangerLevel")?;
        }
        s.serialize_field("dangerPoint", &self.dangerPoint())?;
        if let Some(f) = self.loadingPicId() {
            s.serialize_field("loadingPicId", &f)?;
        } else {
            s.skip_field("loadingPicId")?;
        }
        s.serialize_field("canPractice", &self.canPractice())?;
        s.serialize_field("canBattleReplay", &self.canBattleReplay())?;
        s.serialize_field("apCost", &self.apCost())?;
        s.serialize_field("apFailReturn", &self.apFailReturn())?;
        s.serialize_field("maxSlot", &self.maxSlot())?;
        if let Some(f) = self.etItemId() {
            s.serialize_field("etItemId", &f)?;
        } else {
            s.skip_field("etItemId")?;
        }
        s.serialize_field("etCost", &self.etCost())?;
        s.serialize_field("etFailReturn", &self.etFailReturn())?;
        if let Some(f) = self.etButtonStyle() {
            s.serialize_field("etButtonStyle", &f)?;
        } else {
            s.skip_field("etButtonStyle")?;
        }
        s.serialize_field("apProtectTimes", &self.apProtectTimes())?;
        s.serialize_field("diamondOnceDrop", &self.diamondOnceDrop())?;
        s.serialize_field("practiceTicketCost", &self.practiceTicketCost())?;
        s.serialize_field("dailyStageDifficulty", &self.dailyStageDifficulty())?;
        s.serialize_field("expGain", &self.expGain())?;
        s.serialize_field("goldGain", &self.goldGain())?;
        s.serialize_field("loseExpGain", &self.loseExpGain())?;
        s.serialize_field("loseGoldGain", &self.loseGoldGain())?;
        s.serialize_field("passFavor", &self.passFavor())?;
        s.serialize_field("completeFavor", &self.completeFavor())?;
        s.serialize_field("slProgress", &self.slProgress())?;
        if let Some(f) = self.displayMainItem() {
            s.serialize_field("displayMainItem", &f)?;
        } else {
            s.skip_field("displayMainItem")?;
        }
        s.serialize_field("hilightMark", &self.hilightMark())?;
        s.serialize_field("bossMark", &self.bossMark())?;
        s.serialize_field("isPredefined", &self.isPredefined())?;
        s.serialize_field("isHardPredefined", &self.isHardPredefined())?;
        s.serialize_field(
            "isSkillSelectablePredefined",
            &self.isSkillSelectablePredefined(),
        )?;
        s.serialize_field("isStoryOnly", &self.isStoryOnly())?;
        s.serialize_field("appearanceStyle", &self.appearanceStyle())?;
        if let Some(f) = self.stageDropInfo() {
            s.serialize_field("stageDropInfo", &f)?;
        } else {
            s.skip_field("stageDropInfo")?;
        }
        s.serialize_field("canUseCharm", &self.canUseCharm())?;
        s.serialize_field("canUseTech", &self.canUseTech())?;
        s.serialize_field("canUseTrapTool", &self.canUseTrapTool())?;
        s.serialize_field("canUseBattlePerformance", &self.canUseBattlePerformance())?;
        s.serialize_field("canUseFirework", &self.canUseFirework())?;
        s.serialize_field("canMultipleBattle", &self.canMultipleBattle())?;
        if let Some(f) = self.startButtonOverrideId() {
            s.serialize_field("startButtonOverrideId", &f)?;
        } else {
            s.skip_field("startButtonOverrideId")?;
        }
        s.serialize_field("isStagePatch", &self.isStagePatch())?;
        if let Some(f) = self.mainStageId() {
            s.serialize_field("mainStageId", &f)?;
        } else {
            s.skip_field("mainStageId")?;
        }
        if let Some(f) = self.extraCondition() {
            s.serialize_field("extraCondition", &f)?;
        } else {
            s.skip_field("extraCondition")?;
        }
        if let Some(f) = self.extraInfo() {
            s.serialize_field("extraInfo", &f)?;
        } else {
            s.skip_field("extraInfo")?;
        }
        if let Some(f) = self.sixStarBaseDesc() {
            s.serialize_field("sixStarBaseDesc", &f)?;
        } else {
            s.skip_field("sixStarBaseDesc")?;
        }
        if let Some(f) = self.sixStarDisplayRewardList() {
            s.serialize_field("sixStarDisplayRewardList", &f)?;
        } else {
            s.skip_field("sixStarDisplayRewardList")?;
        }
        if let Some(f) = self.advancedRuneIdList1() {
            s.serialize_field("advancedRuneIdList1", &f)?;
        } else {
            s.skip_field("advancedRuneIdList1")?;
        }
        if let Some(f) = self.advancedRuneIdList2() {
            s.serialize_field("advancedRuneIdList2", &f)?;
        } else {
            s.skip_field("advancedRuneIdList2")?;
        }
        s.serialize_field("useSpecialSizeMapPreview", &self.useSpecialSizeMapPreview())?;
        s.end()
    }
}

pub struct clz_Torappu_StageDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_StageDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_stageType(&mut self, stageType: enum__Torappu_StageType) {
        self.fbb_.push_slot::<enum__Torappu_StageType>(
            clz_Torappu_StageData::VT_STAGETYPE,
            stageType,
            enum__Torappu_StageType::MAIN,
        );
    }
    #[inline]
    pub fn add_difficulty(&mut self, difficulty: enum__Torappu_LevelData_Difficulty) {
        self.fbb_.push_slot::<enum__Torappu_LevelData_Difficulty>(
            clz_Torappu_StageData::VT_DIFFICULTY,
            difficulty,
            enum__Torappu_LevelData_Difficulty::NONE,
        );
    }
    #[inline]
    pub fn add_performanceStageFlag(
        &mut self,
        performanceStageFlag: enum__Torappu_StageData_PerformanceStageFlag,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_StageData_PerformanceStageFlag>(
                clz_Torappu_StageData::VT_PERFORMANCESTAGEFLAG,
                performanceStageFlag,
                enum__Torappu_StageData_PerformanceStageFlag::NORMAL_STAGE,
            );
    }
    #[inline]
    pub fn add_diffGroup(&mut self, diffGroup: enum__Torappu_StageDiffGroup) {
        self.fbb_.push_slot::<enum__Torappu_StageDiffGroup>(
            clz_Torappu_StageData::VT_DIFFGROUP,
            diffGroup,
            enum__Torappu_StageDiffGroup::NONE,
        );
    }
    #[inline]
    pub fn add_unlockCondition(
        &mut self,
        unlockCondition: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ConditionDesc<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_UNLOCKCONDITION,
            unlockCondition,
        );
    }
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_levelId(&mut self, levelId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_LEVELID,
            levelId,
        );
    }
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_code(&mut self, code: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_StageData::VT_CODE, code);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_StageData::VT_NAME, name);
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_hardStagedId(&mut self, hardStagedId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_HARDSTAGEDID,
            hardStagedId,
        );
    }
    #[inline]
    pub fn add_sixStarStageId(&mut self, sixStarStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_SIXSTARSTAGEID,
            sixStarStageId,
        );
    }
    #[inline]
    pub fn add_dangerLevel(&mut self, dangerLevel: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_DANGERLEVEL,
            dangerLevel,
        );
    }
    #[inline]
    pub fn add_dangerPoint(&mut self, dangerPoint: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_StageData::VT_DANGERPOINT, dangerPoint, 0.0);
    }
    #[inline]
    pub fn add_loadingPicId(&mut self, loadingPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_LOADINGPICID,
            loadingPicId,
        );
    }
    #[inline]
    pub fn add_canPractice(&mut self, canPractice: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_CANPRACTICE, canPractice, false);
    }
    #[inline]
    pub fn add_canBattleReplay(&mut self, canBattleReplay: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_CANBATTLEREPLAY,
            canBattleReplay,
            false,
        );
    }
    #[inline]
    pub fn add_apCost(&mut self, apCost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_APCOST, apCost, 0);
    }
    #[inline]
    pub fn add_apFailReturn(&mut self, apFailReturn: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_APFAILRETURN, apFailReturn, 0);
    }
    #[inline]
    pub fn add_maxSlot(&mut self, maxSlot: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_MAXSLOT, maxSlot, 0);
    }
    #[inline]
    pub fn add_etItemId(&mut self, etItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_ETITEMID,
            etItemId,
        );
    }
    #[inline]
    pub fn add_etCost(&mut self, etCost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_ETCOST, etCost, 0);
    }
    #[inline]
    pub fn add_etFailReturn(&mut self, etFailReturn: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_ETFAILRETURN, etFailReturn, 0);
    }
    #[inline]
    pub fn add_etButtonStyle(&mut self, etButtonStyle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_ETBUTTONSTYLE,
            etButtonStyle,
        );
    }
    #[inline]
    pub fn add_apProtectTimes(&mut self, apProtectTimes: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_APPROTECTTIMES, apProtectTimes, 0);
    }
    #[inline]
    pub fn add_diamondOnceDrop(&mut self, diamondOnceDrop: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_StageData::VT_DIAMONDONCEDROP,
            diamondOnceDrop,
            0,
        );
    }
    #[inline]
    pub fn add_practiceTicketCost(&mut self, practiceTicketCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_StageData::VT_PRACTICETICKETCOST,
            practiceTicketCost,
            0,
        );
    }
    #[inline]
    pub fn add_dailyStageDifficulty(&mut self, dailyStageDifficulty: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_StageData::VT_DAILYSTAGEDIFFICULTY,
            dailyStageDifficulty,
            0,
        );
    }
    #[inline]
    pub fn add_expGain(&mut self, expGain: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_EXPGAIN, expGain, 0);
    }
    #[inline]
    pub fn add_goldGain(&mut self, goldGain: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_GOLDGAIN, goldGain, 0);
    }
    #[inline]
    pub fn add_loseExpGain(&mut self, loseExpGain: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_LOSEEXPGAIN, loseExpGain, 0);
    }
    #[inline]
    pub fn add_loseGoldGain(&mut self, loseGoldGain: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_LOSEGOLDGAIN, loseGoldGain, 0);
    }
    #[inline]
    pub fn add_passFavor(&mut self, passFavor: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_PASSFAVOR, passFavor, 0);
    }
    #[inline]
    pub fn add_completeFavor(&mut self, completeFavor: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_COMPLETEFAVOR, completeFavor, 0);
    }
    #[inline]
    pub fn add_slProgress(&mut self, slProgress: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_SLPROGRESS, slProgress, 0);
    }
    #[inline]
    pub fn add_displayMainItem(&mut self, displayMainItem: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_DISPLAYMAINITEM,
            displayMainItem,
        );
    }
    #[inline]
    pub fn add_hilightMark(&mut self, hilightMark: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_HILIGHTMARK, hilightMark, false);
    }
    #[inline]
    pub fn add_bossMark(&mut self, bossMark: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_BOSSMARK, bossMark, false);
    }
    #[inline]
    pub fn add_isPredefined(&mut self, isPredefined: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_ISPREDEFINED, isPredefined, false);
    }
    #[inline]
    pub fn add_isHardPredefined(&mut self, isHardPredefined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_ISHARDPREDEFINED,
            isHardPredefined,
            false,
        );
    }
    #[inline]
    pub fn add_isSkillSelectablePredefined(&mut self, isSkillSelectablePredefined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_ISSKILLSELECTABLEPREDEFINED,
            isSkillSelectablePredefined,
            false,
        );
    }
    #[inline]
    pub fn add_isStoryOnly(&mut self, isStoryOnly: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_ISSTORYONLY, isStoryOnly, false);
    }
    #[inline]
    pub fn add_appearanceStyle(&mut self, appearanceStyle: enum__Torappu_AppearanceStyle) {
        self.fbb_.push_slot::<enum__Torappu_AppearanceStyle>(
            clz_Torappu_StageData::VT_APPEARANCESTYLE,
            appearanceStyle,
            enum__Torappu_AppearanceStyle::MAIN_NORMAL,
        );
    }
    #[inline]
    pub fn add_stageDropInfo(
        &mut self,
        stageDropInfo: flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo>>(
                clz_Torappu_StageData::VT_STAGEDROPINFO,
                stageDropInfo,
            );
    }
    #[inline]
    pub fn add_canUseCharm(&mut self, canUseCharm: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_CANUSECHARM, canUseCharm, false);
    }
    #[inline]
    pub fn add_canUseTech(&mut self, canUseTech: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_CANUSETECH, canUseTech, false);
    }
    #[inline]
    pub fn add_canUseTrapTool(&mut self, canUseTrapTool: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_CANUSETRAPTOOL,
            canUseTrapTool,
            false,
        );
    }
    #[inline]
    pub fn add_canUseBattlePerformance(&mut self, canUseBattlePerformance: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_CANUSEBATTLEPERFORMANCE,
            canUseBattlePerformance,
            false,
        );
    }
    #[inline]
    pub fn add_canUseFirework(&mut self, canUseFirework: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_CANUSEFIREWORK,
            canUseFirework,
            false,
        );
    }
    #[inline]
    pub fn add_canMultipleBattle(&mut self, canMultipleBattle: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_CANMULTIPLEBATTLE,
            canMultipleBattle,
            false,
        );
    }
    #[inline]
    pub fn add_startButtonOverrideId(
        &mut self,
        startButtonOverrideId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_STARTBUTTONOVERRIDEID,
            startButtonOverrideId,
        );
    }
    #[inline]
    pub fn add_isStagePatch(&mut self, isStagePatch: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_ISSTAGEPATCH, isStagePatch, false);
    }
    #[inline]
    pub fn add_mainStageId(&mut self, mainStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_MAINSTAGEID,
            mainStageId,
        );
    }
    #[inline]
    pub fn add_extraCondition(
        &mut self,
        extraCondition: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ExtraConditionDesc<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_EXTRACONDITION,
            extraCondition,
        );
    }
    #[inline]
    pub fn add_extraInfo(
        &mut self,
        extraInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_SpecialStoryInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_EXTRAINFO,
            extraInfo,
        );
    }
    #[inline]
    pub fn add_sixStarBaseDesc(&mut self, sixStarBaseDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_SIXSTARBASEDESC,
            sixStarBaseDesc,
        );
    }
    #[inline]
    pub fn add_sixStarDisplayRewardList(
        &mut self,
        sixStarDisplayRewardList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_SIXSTARDISPLAYREWARDLIST,
            sixStarDisplayRewardList,
        );
    }
    #[inline]
    pub fn add_advancedRuneIdList1(
        &mut self,
        advancedRuneIdList1: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_ADVANCEDRUNEIDLIST1,
            advancedRuneIdList1,
        );
    }
    #[inline]
    pub fn add_advancedRuneIdList2(
        &mut self,
        advancedRuneIdList2: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_ADVANCEDRUNEIDLIST2,
            advancedRuneIdList2,
        );
    }
    #[inline]
    pub fn add_useSpecialSizeMapPreview(&mut self, useSpecialSizeMapPreview: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_USESPECIALSIZEMAPPREVIEW,
            useSpecialSizeMapPreview,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData");
        ds.field("stageType", &self.stageType());
        ds.field("difficulty", &self.difficulty());
        ds.field("performanceStageFlag", &self.performanceStageFlag());
        ds.field("diffGroup", &self.diffGroup());
        ds.field("unlockCondition", &self.unlockCondition());
        ds.field("stageId", &self.stageId());
        ds.field("levelId", &self.levelId());
        ds.field("zoneId", &self.zoneId());
        ds.field("code", &self.code());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("hardStagedId", &self.hardStagedId());
        ds.field("sixStarStageId", &self.sixStarStageId());
        ds.field("dangerLevel", &self.dangerLevel());
        ds.field("dangerPoint", &self.dangerPoint());
        ds.field("loadingPicId", &self.loadingPicId());
        ds.field("canPractice", &self.canPractice());
        ds.field("canBattleReplay", &self.canBattleReplay());
        ds.field("apCost", &self.apCost());
        ds.field("apFailReturn", &self.apFailReturn());
        ds.field("maxSlot", &self.maxSlot());
        ds.field("etItemId", &self.etItemId());
        ds.field("etCost", &self.etCost());
        ds.field("etFailReturn", &self.etFailReturn());
        ds.field("etButtonStyle", &self.etButtonStyle());
        ds.field("apProtectTimes", &self.apProtectTimes());
        ds.field("diamondOnceDrop", &self.diamondOnceDrop());
        ds.field("practiceTicketCost", &self.practiceTicketCost());
        ds.field("dailyStageDifficulty", &self.dailyStageDifficulty());
        ds.field("expGain", &self.expGain());
        ds.field("goldGain", &self.goldGain());
        ds.field("loseExpGain", &self.loseExpGain());
        ds.field("loseGoldGain", &self.loseGoldGain());
        ds.field("passFavor", &self.passFavor());
        ds.field("completeFavor", &self.completeFavor());
        ds.field("slProgress", &self.slProgress());
        ds.field("displayMainItem", &self.displayMainItem());
        ds.field("hilightMark", &self.hilightMark());
        ds.field("bossMark", &self.bossMark());
        ds.field("isPredefined", &self.isPredefined());
        ds.field("isHardPredefined", &self.isHardPredefined());
        ds.field(
            "isSkillSelectablePredefined",
            &self.isSkillSelectablePredefined(),
        );
        ds.field("isStoryOnly", &self.isStoryOnly());
        ds.field("appearanceStyle", &self.appearanceStyle());
        ds.field("stageDropInfo", &self.stageDropInfo());
        ds.field("canUseCharm", &self.canUseCharm());
        ds.field("canUseTech", &self.canUseTech());
        ds.field("canUseTrapTool", &self.canUseTrapTool());
        ds.field("canUseBattlePerformance", &self.canUseBattlePerformance());
        ds.field("canUseFirework", &self.canUseFirework());
        ds.field("canMultipleBattle", &self.canMultipleBattle());
        ds.field("startButtonOverrideId", &self.startButtonOverrideId());
        ds.field("isStagePatch", &self.isStagePatch());
        ds.field("mainStageId", &self.mainStageId());
        ds.field("extraCondition", &self.extraCondition());
        ds.field("extraInfo", &self.extraInfo());
        ds.field("sixStarBaseDesc", &self.sixStarBaseDesc());
        ds.field("sixStarDisplayRewardList", &self.sixStarDisplayRewardList());
        ds.field("advancedRuneIdList1", &self.advancedRuneIdList1());
        ds.field("advancedRuneIdList2", &self.advancedRuneIdList2());
        ds.field("useSpecialSizeMapPreview", &self.useSpecialSizeMapPreview());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageDataT {
    pub stageType: enum__Torappu_StageType,
    pub difficulty: enum__Torappu_LevelData_Difficulty,
    pub performanceStageFlag: enum__Torappu_StageData_PerformanceStageFlag,
    pub diffGroup: enum__Torappu_StageDiffGroup,
    pub unlockCondition: Option<Vec<clz_Torappu_StageData_ConditionDescT>>,
    pub stageId: Option<String>,
    pub levelId: Option<String>,
    pub zoneId: Option<String>,
    pub code: Option<String>,
    pub name: Option<String>,
    pub description: Option<String>,
    pub hardStagedId: Option<String>,
    pub sixStarStageId: Option<String>,
    pub dangerLevel: Option<String>,
    pub dangerPoint: f32,
    pub loadingPicId: Option<String>,
    pub canPractice: bool,
    pub canBattleReplay: bool,
    pub apCost: i32,
    pub apFailReturn: i32,
    pub maxSlot: i32,
    pub etItemId: Option<String>,
    pub etCost: i32,
    pub etFailReturn: i32,
    pub etButtonStyle: Option<String>,
    pub apProtectTimes: i32,
    pub diamondOnceDrop: i32,
    pub practiceTicketCost: i32,
    pub dailyStageDifficulty: i32,
    pub expGain: i32,
    pub goldGain: i32,
    pub loseExpGain: i32,
    pub loseGoldGain: i32,
    pub passFavor: i32,
    pub completeFavor: i32,
    pub slProgress: i32,
    pub displayMainItem: Option<String>,
    pub hilightMark: bool,
    pub bossMark: bool,
    pub isPredefined: bool,
    pub isHardPredefined: bool,
    pub isSkillSelectablePredefined: bool,
    pub isStoryOnly: bool,
    pub appearanceStyle: enum__Torappu_AppearanceStyle,
    pub stageDropInfo: Option<Box<clz_Torappu_StageData_StageDropInfoT>>,
    pub canUseCharm: bool,
    pub canUseTech: bool,
    pub canUseTrapTool: bool,
    pub canUseBattlePerformance: bool,
    pub canUseFirework: bool,
    pub canMultipleBattle: bool,
    pub startButtonOverrideId: Option<String>,
    pub isStagePatch: bool,
    pub mainStageId: Option<String>,
    pub extraCondition: Option<Vec<clz_Torappu_StageData_ExtraConditionDescT>>,
    pub extraInfo: Option<Vec<clz_Torappu_StageData_SpecialStoryInfoT>>,
    pub sixStarBaseDesc: Option<String>,
    pub sixStarDisplayRewardList: Option<Vec<clz_Torappu_ItemBundleT>>,
    pub advancedRuneIdList1: Option<Vec<String>>,
    pub advancedRuneIdList2: Option<Vec<String>>,
    pub useSpecialSizeMapPreview: bool,
}
impl Default for clz_Torappu_StageDataT {
    fn default() -> Self {
        Self {
            stageType: enum__Torappu_StageType::MAIN,
            difficulty: enum__Torappu_LevelData_Difficulty::NONE,
            performanceStageFlag: enum__Torappu_StageData_PerformanceStageFlag::NORMAL_STAGE,
            diffGroup: enum__Torappu_StageDiffGroup::NONE,
            unlockCondition: None,
            stageId: None,
            levelId: None,
            zoneId: None,
            code: None,
            name: None,
            description: None,
            hardStagedId: None,
            sixStarStageId: None,
            dangerLevel: None,
            dangerPoint: 0.0,
            loadingPicId: None,
            canPractice: false,
            canBattleReplay: false,
            apCost: 0,
            apFailReturn: 0,
            maxSlot: 0,
            etItemId: None,
            etCost: 0,
            etFailReturn: 0,
            etButtonStyle: None,
            apProtectTimes: 0,
            diamondOnceDrop: 0,
            practiceTicketCost: 0,
            dailyStageDifficulty: 0,
            expGain: 0,
            goldGain: 0,
            loseExpGain: 0,
            loseGoldGain: 0,
            passFavor: 0,
            completeFavor: 0,
            slProgress: 0,
            displayMainItem: None,
            hilightMark: false,
            bossMark: false,
            isPredefined: false,
            isHardPredefined: false,
            isSkillSelectablePredefined: false,
            isStoryOnly: false,
            appearanceStyle: enum__Torappu_AppearanceStyle::MAIN_NORMAL,
            stageDropInfo: None,
            canUseCharm: false,
            canUseTech: false,
            canUseTrapTool: false,
            canUseBattlePerformance: false,
            canUseFirework: false,
            canMultipleBattle: false,
            startButtonOverrideId: None,
            isStagePatch: false,
            mainStageId: None,
            extraCondition: None,
            extraInfo: None,
            sixStarBaseDesc: None,
            sixStarDisplayRewardList: None,
            advancedRuneIdList1: None,
            advancedRuneIdList2: None,
            useSpecialSizeMapPreview: false,
        }
    }
}
impl clz_Torappu_StageDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData<'b>> {
        let stageType = self.stageType;
        let difficulty = self.difficulty;
        let performanceStageFlag = self.performanceStageFlag;
        let diffGroup = self.diffGroup;
        let unlockCondition = self.unlockCondition.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let levelId = self.levelId.as_ref().map(|x| _fbb.create_string(x));
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let code = self.code.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let hardStagedId = self.hardStagedId.as_ref().map(|x| _fbb.create_string(x));
        let sixStarStageId = self.sixStarStageId.as_ref().map(|x| _fbb.create_string(x));
        let dangerLevel = self.dangerLevel.as_ref().map(|x| _fbb.create_string(x));
        let dangerPoint = self.dangerPoint;
        let loadingPicId = self.loadingPicId.as_ref().map(|x| _fbb.create_string(x));
        let canPractice = self.canPractice;
        let canBattleReplay = self.canBattleReplay;
        let apCost = self.apCost;
        let apFailReturn = self.apFailReturn;
        let maxSlot = self.maxSlot;
        let etItemId = self.etItemId.as_ref().map(|x| _fbb.create_string(x));
        let etCost = self.etCost;
        let etFailReturn = self.etFailReturn;
        let etButtonStyle = self.etButtonStyle.as_ref().map(|x| _fbb.create_string(x));
        let apProtectTimes = self.apProtectTimes;
        let diamondOnceDrop = self.diamondOnceDrop;
        let practiceTicketCost = self.practiceTicketCost;
        let dailyStageDifficulty = self.dailyStageDifficulty;
        let expGain = self.expGain;
        let goldGain = self.goldGain;
        let loseExpGain = self.loseExpGain;
        let loseGoldGain = self.loseGoldGain;
        let passFavor = self.passFavor;
        let completeFavor = self.completeFavor;
        let slProgress = self.slProgress;
        let displayMainItem = self.displayMainItem.as_ref().map(|x| _fbb.create_string(x));
        let hilightMark = self.hilightMark;
        let bossMark = self.bossMark;
        let isPredefined = self.isPredefined;
        let isHardPredefined = self.isHardPredefined;
        let isSkillSelectablePredefined = self.isSkillSelectablePredefined;
        let isStoryOnly = self.isStoryOnly;
        let appearanceStyle = self.appearanceStyle;
        let stageDropInfo = self.stageDropInfo.as_ref().map(|x| x.pack(_fbb));
        let canUseCharm = self.canUseCharm;
        let canUseTech = self.canUseTech;
        let canUseTrapTool = self.canUseTrapTool;
        let canUseBattlePerformance = self.canUseBattlePerformance;
        let canUseFirework = self.canUseFirework;
        let canMultipleBattle = self.canMultipleBattle;
        let startButtonOverrideId = self
            .startButtonOverrideId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let isStagePatch = self.isStagePatch;
        let mainStageId = self.mainStageId.as_ref().map(|x| _fbb.create_string(x));
        let extraCondition = self.extraCondition.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let extraInfo = self.extraInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let sixStarBaseDesc = self.sixStarBaseDesc.as_ref().map(|x| _fbb.create_string(x));
        let sixStarDisplayRewardList = self.sixStarDisplayRewardList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let advancedRuneIdList1 = self.advancedRuneIdList1.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let advancedRuneIdList2 = self.advancedRuneIdList2.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let useSpecialSizeMapPreview = self.useSpecialSizeMapPreview;
        clz_Torappu_StageData::create(
            _fbb,
            &clz_Torappu_StageDataArgs {
                stageType,
                difficulty,
                performanceStageFlag,
                diffGroup,
                unlockCondition,
                stageId,
                levelId,
                zoneId,
                code,
                name,
                description,
                hardStagedId,
                sixStarStageId,
                dangerLevel,
                dangerPoint,
                loadingPicId,
                canPractice,
                canBattleReplay,
                apCost,
                apFailReturn,
                maxSlot,
                etItemId,
                etCost,
                etFailReturn,
                etButtonStyle,
                apProtectTimes,
                diamondOnceDrop,
                practiceTicketCost,
                dailyStageDifficulty,
                expGain,
                goldGain,
                loseExpGain,
                loseGoldGain,
                passFavor,
                completeFavor,
                slProgress,
                displayMainItem,
                hilightMark,
                bossMark,
                isPredefined,
                isHardPredefined,
                isSkillSelectablePredefined,
                isStoryOnly,
                appearanceStyle,
                stageDropInfo,
                canUseCharm,
                canUseTech,
                canUseTrapTool,
                canUseBattlePerformance,
                canUseFirework,
                canMultipleBattle,
                startButtonOverrideId,
                isStagePatch,
                mainStageId,
                extraCondition,
                extraInfo,
                sixStarBaseDesc,
                sixStarDisplayRewardList,
                advancedRuneIdList1,
                advancedRuneIdList2,
                useSpecialSizeMapPreview,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_StageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_StageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_StageData<'a> {
    type Inner = dict__string__clz_Torappu_StageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_StageData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_StageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_StageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_StageDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_StageDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_StageDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_StageData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_StageData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_StageData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData>>(
                    dict__string__clz_Torappu_StageData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_StageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_StageDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_StageData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_StageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_StageDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_StageData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_StageData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_StageDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_StageDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_StageData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_StageData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StageData>>(
                dict__string__clz_Torappu_StageData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_StageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_StageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_StageData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_StageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_StageData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_StageDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_StageDataT>>,
}
impl Default for dict__string__clz_Torappu_StageDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_StageDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_StageData::create(
            _fbb,
            &dict__string__clz_Torappu_StageDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RuneStageGroupData_RuneStageInstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneStageGroupData_RuneStageInst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneStageGroupData_RuneStageInst<'a> {
    type Inner = clz_Torappu_RuneStageGroupData_RuneStageInst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RuneStageGroupData_RuneStageInst<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_ACTIVEPACKEDRUNEIDS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneStageGroupData_RuneStageInst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneStageGroupData_RuneStageInstArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneStageGroupData_RuneStageInst<'bldr>> {
        let mut builder = clz_Torappu_RuneStageGroupData_RuneStageInstBuilder::new(_fbb);
        if let Some(x) = args.activePackedRuneIds {
            builder.add_activePackedRuneIds(x);
        }
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RuneStageGroupData_RuneStageInstT {
        let stageId = self.stageId().map(|x| x.to_string());
        let activePackedRuneIds = self
            .activePackedRuneIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_RuneStageGroupData_RuneStageInstT {
            stageId,
            activePackedRuneIds,
        }
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneStageGroupData_RuneStageInst::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn activePackedRuneIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RuneStageGroupData_RuneStageInst::VT_ACTIVEPACKEDRUNEIDS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneStageGroupData_RuneStageInst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("activePackedRuneIds", Self::VT_ACTIVEPACKEDRUNEIDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneStageGroupData_RuneStageInstArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub activePackedRuneIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_RuneStageGroupData_RuneStageInstArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneStageGroupData_RuneStageInstArgs {
            stageId: None,
            activePackedRuneIds: None,
        }
    }
}

impl Serialize for clz_Torappu_RuneStageGroupData_RuneStageInst<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RuneStageGroupData_RuneStageInst", 2)?;
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        if let Some(f) = self.activePackedRuneIds() {
            s.serialize_field("activePackedRuneIds", &f)?;
        } else {
            s.skip_field("activePackedRuneIds")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RuneStageGroupData_RuneStageInstBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RuneStageGroupData_RuneStageInstBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneStageGroupData_RuneStageInst::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_activePackedRuneIds(
        &mut self,
        activePackedRuneIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneStageGroupData_RuneStageInst::VT_ACTIVEPACKEDRUNEIDS,
            activePackedRuneIds,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneStageGroupData_RuneStageInstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneStageGroupData_RuneStageInstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneStageGroupData_RuneStageInst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneStageGroupData_RuneStageInst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneStageGroupData_RuneStageInst");
        ds.field("stageId", &self.stageId());
        ds.field("activePackedRuneIds", &self.activePackedRuneIds());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RuneStageGroupData_RuneStageInstT {
    pub stageId: Option<String>,
    pub activePackedRuneIds: Option<Vec<String>>,
}
impl Default for clz_Torappu_RuneStageGroupData_RuneStageInstT {
    fn default() -> Self {
        Self {
            stageId: None,
            activePackedRuneIds: None,
        }
    }
}
impl clz_Torappu_RuneStageGroupData_RuneStageInstT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneStageGroupData_RuneStageInst<'b>> {
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let activePackedRuneIds = self.activePackedRuneIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RuneStageGroupData_RuneStageInst::create(
            _fbb,
            &clz_Torappu_RuneStageGroupData_RuneStageInstArgs {
                stageId,
                activePackedRuneIds,
            },
        )
    }
}
pub enum clz_Torappu_RuneStageGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneStageGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneStageGroupData<'a> {
    type Inner = clz_Torappu_RuneStageGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RuneStageGroupData<'a> {
    pub const VT_GROUPID: flatbuffers::VOffsetT = 4;
    pub const VT_ACTIVERUNESTAGES: flatbuffers::VOffsetT = 6;
    pub const VT_STARTTS: flatbuffers::VOffsetT = 8;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneStageGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneStageGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneStageGroupData<'bldr>> {
        let mut builder = clz_Torappu_RuneStageGroupDataBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        if let Some(x) = args.activeRuneStages {
            builder.add_activeRuneStages(x);
        }
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RuneStageGroupDataT {
        let groupId = self.groupId().map(|x| x.to_string());
        let activeRuneStages = self
            .activeRuneStages()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let startTs = self.startTs();
        let endTs = self.endTs();
        clz_Torappu_RuneStageGroupDataT {
            groupId,
            activeRuneStages,
            startTs,
            endTs,
        }
    }

    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneStageGroupData::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn activeRuneStages(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RuneStageGroupData_RuneStageInst<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RuneStageGroupData_RuneStageInst>,
                >,
            >>(clz_Torappu_RuneStageGroupData::VT_ACTIVERUNESTAGES, None)
        }
    }
    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_RuneStageGroupData::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_RuneStageGroupData::VT_ENDTS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneStageGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RuneStageGroupData_RuneStageInst>,
                >,
            >>("activeRuneStages", Self::VT_ACTIVERUNESTAGES, false)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneStageGroupDataArgs<'a> {
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub activeRuneStages: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RuneStageGroupData_RuneStageInst<'a>>,
            >,
        >,
    >,
    pub startTs: i64,
    pub endTs: i64,
}
impl<'a> Default for clz_Torappu_RuneStageGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneStageGroupDataArgs {
            groupId: None,
            activeRuneStages: None,
            startTs: 0,
            endTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_RuneStageGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RuneStageGroupData", 4)?;
        if let Some(f) = self.groupId() {
            s.serialize_field("groupId", &f)?;
        } else {
            s.skip_field("groupId")?;
        }
        if let Some(f) = self.activeRuneStages() {
            s.serialize_field("activeRuneStages", &f)?;
        } else {
            s.skip_field("activeRuneStages")?;
        }
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        s.end()
    }
}

pub struct clz_Torappu_RuneStageGroupDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RuneStageGroupDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneStageGroupData::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_activeRuneStages(
        &mut self,
        activeRuneStages: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RuneStageGroupData_RuneStageInst<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneStageGroupData::VT_ACTIVERUNESTAGES,
            activeRuneStages,
        );
    }
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_RuneStageGroupData::VT_STARTTS, startTs, 0);
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_RuneStageGroupData::VT_ENDTS, endTs, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneStageGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneStageGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneStageGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneStageGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneStageGroupData");
        ds.field("groupId", &self.groupId());
        ds.field("activeRuneStages", &self.activeRuneStages());
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RuneStageGroupDataT {
    pub groupId: Option<String>,
    pub activeRuneStages: Option<Vec<clz_Torappu_RuneStageGroupData_RuneStageInstT>>,
    pub startTs: i64,
    pub endTs: i64,
}
impl Default for clz_Torappu_RuneStageGroupDataT {
    fn default() -> Self {
        Self {
            groupId: None,
            activeRuneStages: None,
            startTs: 0,
            endTs: 0,
        }
    }
}
impl clz_Torappu_RuneStageGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneStageGroupData<'b>> {
        let groupId = self.groupId.as_ref().map(|x| _fbb.create_string(x));
        let activeRuneStages = self.activeRuneStages.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let startTs = self.startTs;
        let endTs = self.endTs;
        clz_Torappu_RuneStageGroupData::create(
            _fbb,
            &clz_Torappu_RuneStageGroupDataArgs {
                groupId,
                activeRuneStages,
                startTs,
                endTs,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RuneStageGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RuneStageGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RuneStageGroupData<'a> {
    type Inner = dict__string__clz_Torappu_RuneStageGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RuneStageGroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RuneStageGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RuneStageGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RuneStageGroupData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RuneStageGroupDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RuneStageGroupDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RuneStageGroupDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RuneStageGroupData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_RuneStageGroupData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RuneStageGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneStageGroupData>>(
                    dict__string__clz_Torappu_RuneStageGroupData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RuneStageGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneStageGroupData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RuneStageGroupDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RuneStageGroupData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RuneStageGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RuneStageGroupDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RuneStageGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RuneStageGroupData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RuneStageGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RuneStageGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RuneStageGroupData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_RuneStageGroupData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RuneStageGroupData>>(
                dict__string__clz_Torappu_RuneStageGroupData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RuneStageGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RuneStageGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RuneStageGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RuneStageGroupData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RuneStageGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RuneStageGroupData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RuneStageGroupDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RuneStageGroupDataT>>,
}
impl Default for dict__string__clz_Torappu_RuneStageGroupDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RuneStageGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RuneStageGroupData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RuneStageGroupData::create(
            _fbb,
            &dict__string__clz_Torappu_RuneStageGroupDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_MapThemeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MapThemeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MapThemeData<'a> {
    type Inner = clz_Torappu_MapThemeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MapThemeData<'a> {
    pub const VT_THEMEID: flatbuffers::VOffsetT = 4;
    pub const VT_UNITCOLOR: flatbuffers::VOffsetT = 6;
    pub const VT_BUILDABLECOLOR: flatbuffers::VOffsetT = 8;
    pub const VT_THEMETYPE: flatbuffers::VOffsetT = 10;
    pub const VT_TRAPTINTCOLOR: flatbuffers::VOffsetT = 12;
    pub const VT_EMISSIONCOLOR: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MapThemeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MapThemeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MapThemeData<'bldr>> {
        let mut builder = clz_Torappu_MapThemeDataBuilder::new(_fbb);
        if let Some(x) = args.emissionColor {
            builder.add_emissionColor(x);
        }
        if let Some(x) = args.trapTintColor {
            builder.add_trapTintColor(x);
        }
        if let Some(x) = args.themeType {
            builder.add_themeType(x);
        }
        if let Some(x) = args.buildableColor {
            builder.add_buildableColor(x);
        }
        if let Some(x) = args.unitColor {
            builder.add_unitColor(x);
        }
        if let Some(x) = args.themeId {
            builder.add_themeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MapThemeDataT {
        let themeId = self.themeId().map(|x| x.to_string());
        let unitColor = self.unitColor().map(|x| x.to_string());
        let buildableColor = self.buildableColor().map(|x| x.to_string());
        let themeType = self.themeType().map(|x| x.to_string());
        let trapTintColor = self.trapTintColor().map(|x| x.to_string());
        let emissionColor = self.emissionColor().map(|x| x.to_string());
        clz_Torappu_MapThemeDataT {
            themeId,
            unitColor,
            buildableColor,
            themeType,
            trapTintColor,
            emissionColor,
        }
    }

    #[inline]
    pub fn themeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MapThemeData::VT_THEMEID,
                None,
            )
        }
    }
    #[inline]
    pub fn unitColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MapThemeData::VT_UNITCOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn buildableColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MapThemeData::VT_BUILDABLECOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn themeType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MapThemeData::VT_THEMETYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn trapTintColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MapThemeData::VT_TRAPTINTCOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn emissionColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MapThemeData::VT_EMISSIONCOLOR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MapThemeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("themeId", Self::VT_THEMEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unitColor",
                Self::VT_UNITCOLOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buildableColor",
                Self::VT_BUILDABLECOLOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "themeType",
                Self::VT_THEMETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "trapTintColor",
                Self::VT_TRAPTINTCOLOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "emissionColor",
                Self::VT_EMISSIONCOLOR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MapThemeDataArgs<'a> {
    pub themeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unitColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buildableColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub themeType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapTintColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub emissionColor: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_MapThemeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MapThemeDataArgs {
            themeId: None,
            unitColor: None,
            buildableColor: None,
            themeType: None,
            trapTintColor: None,
            emissionColor: None,
        }
    }
}

impl Serialize for clz_Torappu_MapThemeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MapThemeData", 6)?;
        if let Some(f) = self.themeId() {
            s.serialize_field("themeId", &f)?;
        } else {
            s.skip_field("themeId")?;
        }
        if let Some(f) = self.unitColor() {
            s.serialize_field("unitColor", &f)?;
        } else {
            s.skip_field("unitColor")?;
        }
        if let Some(f) = self.buildableColor() {
            s.serialize_field("buildableColor", &f)?;
        } else {
            s.skip_field("buildableColor")?;
        }
        if let Some(f) = self.themeType() {
            s.serialize_field("themeType", &f)?;
        } else {
            s.skip_field("themeType")?;
        }
        if let Some(f) = self.trapTintColor() {
            s.serialize_field("trapTintColor", &f)?;
        } else {
            s.skip_field("trapTintColor")?;
        }
        if let Some(f) = self.emissionColor() {
            s.serialize_field("emissionColor", &f)?;
        } else {
            s.skip_field("emissionColor")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_MapThemeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_MapThemeDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_themeId(&mut self, themeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MapThemeData::VT_THEMEID,
            themeId,
        );
    }
    #[inline]
    pub fn add_unitColor(&mut self, unitColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MapThemeData::VT_UNITCOLOR,
            unitColor,
        );
    }
    #[inline]
    pub fn add_buildableColor(&mut self, buildableColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MapThemeData::VT_BUILDABLECOLOR,
            buildableColor,
        );
    }
    #[inline]
    pub fn add_themeType(&mut self, themeType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MapThemeData::VT_THEMETYPE,
            themeType,
        );
    }
    #[inline]
    pub fn add_trapTintColor(&mut self, trapTintColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MapThemeData::VT_TRAPTINTCOLOR,
            trapTintColor,
        );
    }
    #[inline]
    pub fn add_emissionColor(&mut self, emissionColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MapThemeData::VT_EMISSIONCOLOR,
            emissionColor,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MapThemeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MapThemeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MapThemeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MapThemeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MapThemeData");
        ds.field("themeId", &self.themeId());
        ds.field("unitColor", &self.unitColor());
        ds.field("buildableColor", &self.buildableColor());
        ds.field("themeType", &self.themeType());
        ds.field("trapTintColor", &self.trapTintColor());
        ds.field("emissionColor", &self.emissionColor());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MapThemeDataT {
    pub themeId: Option<String>,
    pub unitColor: Option<String>,
    pub buildableColor: Option<String>,
    pub themeType: Option<String>,
    pub trapTintColor: Option<String>,
    pub emissionColor: Option<String>,
}
impl Default for clz_Torappu_MapThemeDataT {
    fn default() -> Self {
        Self {
            themeId: None,
            unitColor: None,
            buildableColor: None,
            themeType: None,
            trapTintColor: None,
            emissionColor: None,
        }
    }
}
impl clz_Torappu_MapThemeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MapThemeData<'b>> {
        let themeId = self.themeId.as_ref().map(|x| _fbb.create_string(x));
        let unitColor = self.unitColor.as_ref().map(|x| _fbb.create_string(x));
        let buildableColor = self.buildableColor.as_ref().map(|x| _fbb.create_string(x));
        let themeType = self.themeType.as_ref().map(|x| _fbb.create_string(x));
        let trapTintColor = self.trapTintColor.as_ref().map(|x| _fbb.create_string(x));
        let emissionColor = self.emissionColor.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_MapThemeData::create(
            _fbb,
            &clz_Torappu_MapThemeDataArgs {
                themeId,
                unitColor,
                buildableColor,
                themeType,
                trapTintColor,
                emissionColor,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_MapThemeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_MapThemeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_MapThemeData<'a> {
    type Inner = dict__string__clz_Torappu_MapThemeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_MapThemeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_MapThemeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_MapThemeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MapThemeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_MapThemeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_MapThemeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_MapThemeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_MapThemeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_MapThemeData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_MapThemeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_MapThemeData>>(
                    dict__string__clz_Torappu_MapThemeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_MapThemeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_MapThemeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_MapThemeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_MapThemeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_MapThemeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_MapThemeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_MapThemeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_MapThemeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_MapThemeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_MapThemeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_MapThemeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_MapThemeData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_MapThemeData>>(
                dict__string__clz_Torappu_MapThemeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_MapThemeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_MapThemeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MapThemeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_MapThemeData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_MapThemeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_MapThemeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_MapThemeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_MapThemeDataT>>,
}
impl Default for dict__string__clz_Torappu_MapThemeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_MapThemeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MapThemeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_MapThemeData::create(
            _fbb,
            &dict__string__clz_Torappu_MapThemeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_TileAppendInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TileAppendInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TileAppendInfo<'a> {
    type Inner = clz_Torappu_TileAppendInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_TileAppendInfo<'a> {
    pub const VT_TILEKEY: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
    pub const VT_ISFUNCTIONAL: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TileAppendInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TileAppendInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TileAppendInfo<'bldr>> {
        let mut builder = clz_Torappu_TileAppendInfoBuilder::new(_fbb);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.tileKey {
            builder.add_tileKey(x);
        }
        builder.add_isFunctional(args.isFunctional);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_TileAppendInfoT {
        let tileKey = self.tileKey().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let isFunctional = self.isFunctional();
        clz_Torappu_TileAppendInfoT {
            tileKey,
            name,
            description,
            isFunctional,
        }
    }

    #[inline]
    pub fn tileKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TileAppendInfo::VT_TILEKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TileAppendInfo::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TileAppendInfo::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn isFunctional(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_TileAppendInfo::VT_ISFUNCTIONAL, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TileAppendInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tileKey", Self::VT_TILEKEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<bool>("isFunctional", Self::VT_ISFUNCTIONAL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TileAppendInfoArgs<'a> {
    pub tileKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isFunctional: bool,
}
impl<'a> Default for clz_Torappu_TileAppendInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TileAppendInfoArgs {
            tileKey: None,
            name: None,
            description: None,
            isFunctional: false,
        }
    }
}

impl Serialize for clz_Torappu_TileAppendInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_TileAppendInfo", 4)?;
        if let Some(f) = self.tileKey() {
            s.serialize_field("tileKey", &f)?;
        } else {
            s.skip_field("tileKey")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        s.serialize_field("isFunctional", &self.isFunctional())?;
        s.end()
    }
}

pub struct clz_Torappu_TileAppendInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TileAppendInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_tileKey(&mut self, tileKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TileAppendInfo::VT_TILEKEY,
            tileKey,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TileAppendInfo::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TileAppendInfo::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_isFunctional(&mut self, isFunctional: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_TileAppendInfo::VT_ISFUNCTIONAL,
            isFunctional,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TileAppendInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TileAppendInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TileAppendInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TileAppendInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TileAppendInfo");
        ds.field("tileKey", &self.tileKey());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("isFunctional", &self.isFunctional());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_TileAppendInfoT {
    pub tileKey: Option<String>,
    pub name: Option<String>,
    pub description: Option<String>,
    pub isFunctional: bool,
}
impl Default for clz_Torappu_TileAppendInfoT {
    fn default() -> Self {
        Self {
            tileKey: None,
            name: None,
            description: None,
            isFunctional: false,
        }
    }
}
impl clz_Torappu_TileAppendInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TileAppendInfo<'b>> {
        let tileKey = self.tileKey.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let isFunctional = self.isFunctional;
        clz_Torappu_TileAppendInfo::create(
            _fbb,
            &clz_Torappu_TileAppendInfoArgs {
                tileKey,
                name,
                description,
                isFunctional,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_TileAppendInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_TileAppendInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_TileAppendInfo<'a> {
    type Inner = dict__string__clz_Torappu_TileAppendInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_TileAppendInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_TileAppendInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_TileAppendInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_TileAppendInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_TileAppendInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_TileAppendInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_TileAppendInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_TileAppendInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_TileAppendInfo) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_TileAppendInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_TileAppendInfo>>(
                    dict__string__clz_Torappu_TileAppendInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_TileAppendInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_TileAppendInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_TileAppendInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_TileAppendInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_TileAppendInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_TileAppendInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_TileAppendInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_TileAppendInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_TileAppendInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_TileAppendInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_TileAppendInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_TileAppendInfo<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_TileAppendInfo>>(
                dict__string__clz_Torappu_TileAppendInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_TileAppendInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_TileAppendInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_TileAppendInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_TileAppendInfo::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_TileAppendInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_TileAppendInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_TileAppendInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_TileAppendInfoT>>,
}
impl Default for dict__string__clz_Torappu_TileAppendInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_TileAppendInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_TileAppendInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_TileAppendInfo::create(
            _fbb,
            &dict__string__clz_Torappu_TileAppendInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_WeeklyForceOpenTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_WeeklyForceOpenTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_WeeklyForceOpenTable<'a> {
    type Inner = clz_Torappu_WeeklyForceOpenTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_WeeklyForceOpenTable<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 6;
    pub const VT_ENDTIME: flatbuffers::VOffsetT = 8;
    pub const VT_FORCEOPENLIST: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_WeeklyForceOpenTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_WeeklyForceOpenTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_WeeklyForceOpenTable<'bldr>> {
        let mut builder = clz_Torappu_WeeklyForceOpenTableBuilder::new(_fbb);
        builder.add_endTime(args.endTime);
        builder.add_startTime(args.startTime);
        if let Some(x) = args.forceOpenList {
            builder.add_forceOpenList(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_WeeklyForceOpenTableT {
        let id = self.id().map(|x| x.to_string());
        let startTime = self.startTime();
        let endTime = self.endTime();
        let forceOpenList = self
            .forceOpenList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_WeeklyForceOpenTableT {
            id,
            startTime,
            endTime,
            forceOpenList,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_WeeklyForceOpenTable::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_WeeklyForceOpenTable::VT_STARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_WeeklyForceOpenTable::VT_ENDTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn forceOpenList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_WeeklyForceOpenTable::VT_FORCEOPENLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_WeeklyForceOpenTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<i64>("endTime", Self::VT_ENDTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("forceOpenList", Self::VT_FORCEOPENLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_WeeklyForceOpenTableArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTime: i64,
    pub endTime: i64,
    pub forceOpenList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_WeeklyForceOpenTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_WeeklyForceOpenTableArgs {
            id: None,
            startTime: 0,
            endTime: 0,
            forceOpenList: None,
        }
    }
}

impl Serialize for clz_Torappu_WeeklyForceOpenTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_WeeklyForceOpenTable", 4)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("startTime", &self.startTime())?;
        s.serialize_field("endTime", &self.endTime())?;
        if let Some(f) = self.forceOpenList() {
            s.serialize_field("forceOpenList", &f)?;
        } else {
            s.skip_field("forceOpenList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_WeeklyForceOpenTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_WeeklyForceOpenTableBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_WeeklyForceOpenTable::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_WeeklyForceOpenTable::VT_STARTTIME, startTime, 0);
    }
    #[inline]
    pub fn add_endTime(&mut self, endTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_WeeklyForceOpenTable::VT_ENDTIME, endTime, 0);
    }
    #[inline]
    pub fn add_forceOpenList(
        &mut self,
        forceOpenList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_WeeklyForceOpenTable::VT_FORCEOPENLIST,
            forceOpenList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_WeeklyForceOpenTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_WeeklyForceOpenTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_WeeklyForceOpenTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_WeeklyForceOpenTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_WeeklyForceOpenTable");
        ds.field("id", &self.id());
        ds.field("startTime", &self.startTime());
        ds.field("endTime", &self.endTime());
        ds.field("forceOpenList", &self.forceOpenList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_WeeklyForceOpenTableT {
    pub id: Option<String>,
    pub startTime: i64,
    pub endTime: i64,
    pub forceOpenList: Option<Vec<String>>,
}
impl Default for clz_Torappu_WeeklyForceOpenTableT {
    fn default() -> Self {
        Self {
            id: None,
            startTime: 0,
            endTime: 0,
            forceOpenList: None,
        }
    }
}
impl clz_Torappu_WeeklyForceOpenTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_WeeklyForceOpenTable<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let startTime = self.startTime;
        let endTime = self.endTime;
        let forceOpenList = self.forceOpenList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_WeeklyForceOpenTable::create(
            _fbb,
            &clz_Torappu_WeeklyForceOpenTableArgs {
                id,
                startTime,
                endTime,
                forceOpenList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_WeeklyForceOpenTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_WeeklyForceOpenTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_WeeklyForceOpenTable<'a> {
    type Inner = dict__string__clz_Torappu_WeeklyForceOpenTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_WeeklyForceOpenTable<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_WeeklyForceOpenTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_WeeklyForceOpenTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_WeeklyForceOpenTable<'bldr>> {
        let mut builder = dict__string__clz_Torappu_WeeklyForceOpenTableBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_WeeklyForceOpenTableT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_WeeklyForceOpenTableT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_WeeklyForceOpenTable::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_WeeklyForceOpenTable,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_WeeklyForceOpenTable<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_WeeklyForceOpenTable>>(
                    dict__string__clz_Torappu_WeeklyForceOpenTable::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_WeeklyForceOpenTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_WeeklyForceOpenTable>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_WeeklyForceOpenTableArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_WeeklyForceOpenTable<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_WeeklyForceOpenTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_WeeklyForceOpenTableArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_WeeklyForceOpenTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_WeeklyForceOpenTable", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_WeeklyForceOpenTableBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_WeeklyForceOpenTableBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_WeeklyForceOpenTable::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_WeeklyForceOpenTable<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_WeeklyForceOpenTable>>(
                dict__string__clz_Torappu_WeeklyForceOpenTable::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_WeeklyForceOpenTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_WeeklyForceOpenTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_WeeklyForceOpenTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_WeeklyForceOpenTable::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_WeeklyForceOpenTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_WeeklyForceOpenTable");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_WeeklyForceOpenTableT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_WeeklyForceOpenTableT>>,
}
impl Default for dict__string__clz_Torappu_WeeklyForceOpenTableT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_WeeklyForceOpenTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_WeeklyForceOpenTable<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_WeeklyForceOpenTable::create(
            _fbb,
            &dict__string__clz_Torappu_WeeklyForceOpenTableArgs { key, value },
        )
    }
}
pub enum dict__string__longOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__long<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__long<'a> {
    type Inner = dict__string__long<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__long<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__long { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__longArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__long<'bldr>> {
        let mut builder = dict__string__longBuilder::new(_fbb);
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__longT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value();
        dict__string__longT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__long::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__long) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(dict__string__long::VT_VALUE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for dict__string__long<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<i64>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__longArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: i64,
}
impl<'a> Default for dict__string__longArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__longArgs {
            key: None, // required field
            value: 0,
        }
    }
}

impl Serialize for dict__string__long<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__long", 2)?;
        s.serialize_field("key", &self.key())?;
        s.serialize_field("value", &self.value())?;
        s.end()
    }
}

pub struct dict__string__longBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__longBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__long::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: i64) {
        self.fbb_
            .push_slot::<i64>(dict__string__long::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__longBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__longBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__long<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__long::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__long<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__long");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__longT {
    pub key: String,
    pub value: i64,
}
impl Default for dict__string__longT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: 0,
        }
    }
}
impl dict__string__longT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__long<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value;
        dict__string__long::create(_fbb, &dict__string__longArgs { key, value })
    }
}
pub enum clz_Torappu_TimelyDropTimeInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TimelyDropTimeInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TimelyDropTimeInfo<'a> {
    type Inner = clz_Torappu_TimelyDropTimeInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_TimelyDropTimeInfo<'a> {
    pub const VT_STARTTS: flatbuffers::VOffsetT = 4;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 6;
    pub const VT_STAGEPIC: flatbuffers::VOffsetT = 8;
    pub const VT_DROPPICID: flatbuffers::VOffsetT = 10;
    pub const VT_STAGEUNLOCK: flatbuffers::VOffsetT = 12;
    pub const VT_ENTRANCEDOWNPICID: flatbuffers::VOffsetT = 14;
    pub const VT_ENTRANCEUPPICID: flatbuffers::VOffsetT = 16;
    pub const VT_TIMELYGROUPID: flatbuffers::VOffsetT = 18;
    pub const VT_WEEKLYPICID: flatbuffers::VOffsetT = 20;
    pub const VT_ISREPLACE: flatbuffers::VOffsetT = 22;
    pub const VT_APSUPPLYOUTOFDATEDICT: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TimelyDropTimeInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TimelyDropTimeInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TimelyDropTimeInfo<'bldr>> {
        let mut builder = clz_Torappu_TimelyDropTimeInfoBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        if let Some(x) = args.apSupplyOutOfDateDict {
            builder.add_apSupplyOutOfDateDict(x);
        }
        if let Some(x) = args.weeklyPicId {
            builder.add_weeklyPicId(x);
        }
        if let Some(x) = args.timelyGroupId {
            builder.add_timelyGroupId(x);
        }
        if let Some(x) = args.entranceUpPicId {
            builder.add_entranceUpPicId(x);
        }
        if let Some(x) = args.entranceDownPicId {
            builder.add_entranceDownPicId(x);
        }
        if let Some(x) = args.stageUnlock {
            builder.add_stageUnlock(x);
        }
        if let Some(x) = args.dropPicId {
            builder.add_dropPicId(x);
        }
        if let Some(x) = args.stagePic {
            builder.add_stagePic(x);
        }
        builder.add_isReplace(args.isReplace);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_TimelyDropTimeInfoT {
        let startTs = self.startTs();
        let endTs = self.endTs();
        let stagePic = self.stagePic().map(|x| x.to_string());
        let dropPicId = self.dropPicId().map(|x| x.to_string());
        let stageUnlock = self.stageUnlock().map(|x| x.to_string());
        let entranceDownPicId = self.entranceDownPicId().map(|x| x.to_string());
        let entranceUpPicId = self.entranceUpPicId().map(|x| x.to_string());
        let timelyGroupId = self.timelyGroupId().map(|x| x.to_string());
        let weeklyPicId = self.weeklyPicId().map(|x| x.to_string());
        let isReplace = self.isReplace();
        let apSupplyOutOfDateDict = self
            .apSupplyOutOfDateDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_TimelyDropTimeInfoT {
            startTs,
            endTs,
            stagePic,
            dropPicId,
            stageUnlock,
            entranceDownPicId,
            entranceUpPicId,
            timelyGroupId,
            weeklyPicId,
            isReplace,
            apSupplyOutOfDateDict,
        }
    }

    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_TimelyDropTimeInfo::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_TimelyDropTimeInfo::VT_ENDTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn stagePic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TimelyDropTimeInfo::VT_STAGEPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn dropPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TimelyDropTimeInfo::VT_DROPPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn stageUnlock(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TimelyDropTimeInfo::VT_STAGEUNLOCK,
                None,
            )
        }
    }
    #[inline]
    pub fn entranceDownPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TimelyDropTimeInfo::VT_ENTRANCEDOWNPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn entranceUpPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TimelyDropTimeInfo::VT_ENTRANCEUPPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn timelyGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TimelyDropTimeInfo::VT_TIMELYGROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn weeklyPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_TimelyDropTimeInfo::VT_WEEKLYPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn isReplace(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_TimelyDropTimeInfo::VT_ISREPLACE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn apSupplyOutOfDateDict(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__long<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__long>>,
            >>(
                clz_Torappu_TimelyDropTimeInfo::VT_APSUPPLYOUTOFDATEDICT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TimelyDropTimeInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "stagePic",
                Self::VT_STAGEPIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dropPicId",
                Self::VT_DROPPICID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "stageUnlock",
                Self::VT_STAGEUNLOCK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "entranceDownPicId",
                Self::VT_ENTRANCEDOWNPICID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "entranceUpPicId",
                Self::VT_ENTRANCEUPPICID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "timelyGroupId",
                Self::VT_TIMELYGROUPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weeklyPicId",
                Self::VT_WEEKLYPICID,
                false,
            )?
            .visit_field::<bool>("isReplace", Self::VT_ISREPLACE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__long>>,
            >>(
                "apSupplyOutOfDateDict",
                Self::VT_APSUPPLYOUTOFDATEDICT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TimelyDropTimeInfoArgs<'a> {
    pub startTs: i64,
    pub endTs: i64,
    pub stagePic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dropPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stageUnlock: Option<flatbuffers::WIPOffset<&'a str>>,
    pub entranceDownPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub entranceUpPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timelyGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weeklyPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isReplace: bool,
    pub apSupplyOutOfDateDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__long<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_TimelyDropTimeInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TimelyDropTimeInfoArgs {
            startTs: 0,
            endTs: 0,
            stagePic: None,
            dropPicId: None,
            stageUnlock: None,
            entranceDownPicId: None,
            entranceUpPicId: None,
            timelyGroupId: None,
            weeklyPicId: None,
            isReplace: false,
            apSupplyOutOfDateDict: None,
        }
    }
}

impl Serialize for clz_Torappu_TimelyDropTimeInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_TimelyDropTimeInfo", 11)?;
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        if let Some(f) = self.stagePic() {
            s.serialize_field("stagePic", &f)?;
        } else {
            s.skip_field("stagePic")?;
        }
        if let Some(f) = self.dropPicId() {
            s.serialize_field("dropPicId", &f)?;
        } else {
            s.skip_field("dropPicId")?;
        }
        if let Some(f) = self.stageUnlock() {
            s.serialize_field("stageUnlock", &f)?;
        } else {
            s.skip_field("stageUnlock")?;
        }
        if let Some(f) = self.entranceDownPicId() {
            s.serialize_field("entranceDownPicId", &f)?;
        } else {
            s.skip_field("entranceDownPicId")?;
        }
        if let Some(f) = self.entranceUpPicId() {
            s.serialize_field("entranceUpPicId", &f)?;
        } else {
            s.skip_field("entranceUpPicId")?;
        }
        if let Some(f) = self.timelyGroupId() {
            s.serialize_field("timelyGroupId", &f)?;
        } else {
            s.skip_field("timelyGroupId")?;
        }
        if let Some(f) = self.weeklyPicId() {
            s.serialize_field("weeklyPicId", &f)?;
        } else {
            s.skip_field("weeklyPicId")?;
        }
        s.serialize_field("isReplace", &self.isReplace())?;
        if let Some(f) = self.apSupplyOutOfDateDict() {
            s.serialize_field("apSupplyOutOfDateDict", &f)?;
        } else {
            s.skip_field("apSupplyOutOfDateDict")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_TimelyDropTimeInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TimelyDropTimeInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_TimelyDropTimeInfo::VT_STARTTS, startTs, 0);
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_TimelyDropTimeInfo::VT_ENDTS, endTs, 0);
    }
    #[inline]
    pub fn add_stagePic(&mut self, stagePic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TimelyDropTimeInfo::VT_STAGEPIC,
            stagePic,
        );
    }
    #[inline]
    pub fn add_dropPicId(&mut self, dropPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TimelyDropTimeInfo::VT_DROPPICID,
            dropPicId,
        );
    }
    #[inline]
    pub fn add_stageUnlock(&mut self, stageUnlock: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TimelyDropTimeInfo::VT_STAGEUNLOCK,
            stageUnlock,
        );
    }
    #[inline]
    pub fn add_entranceDownPicId(&mut self, entranceDownPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TimelyDropTimeInfo::VT_ENTRANCEDOWNPICID,
            entranceDownPicId,
        );
    }
    #[inline]
    pub fn add_entranceUpPicId(&mut self, entranceUpPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TimelyDropTimeInfo::VT_ENTRANCEUPPICID,
            entranceUpPicId,
        );
    }
    #[inline]
    pub fn add_timelyGroupId(&mut self, timelyGroupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TimelyDropTimeInfo::VT_TIMELYGROUPID,
            timelyGroupId,
        );
    }
    #[inline]
    pub fn add_weeklyPicId(&mut self, weeklyPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TimelyDropTimeInfo::VT_WEEKLYPICID,
            weeklyPicId,
        );
    }
    #[inline]
    pub fn add_isReplace(&mut self, isReplace: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_TimelyDropTimeInfo::VT_ISREPLACE,
            isReplace,
            false,
        );
    }
    #[inline]
    pub fn add_apSupplyOutOfDateDict(
        &mut self,
        apSupplyOutOfDateDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__long<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TimelyDropTimeInfo::VT_APSUPPLYOUTOFDATEDICT,
            apSupplyOutOfDateDict,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TimelyDropTimeInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TimelyDropTimeInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TimelyDropTimeInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TimelyDropTimeInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TimelyDropTimeInfo");
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.field("stagePic", &self.stagePic());
        ds.field("dropPicId", &self.dropPicId());
        ds.field("stageUnlock", &self.stageUnlock());
        ds.field("entranceDownPicId", &self.entranceDownPicId());
        ds.field("entranceUpPicId", &self.entranceUpPicId());
        ds.field("timelyGroupId", &self.timelyGroupId());
        ds.field("weeklyPicId", &self.weeklyPicId());
        ds.field("isReplace", &self.isReplace());
        ds.field("apSupplyOutOfDateDict", &self.apSupplyOutOfDateDict());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_TimelyDropTimeInfoT {
    pub startTs: i64,
    pub endTs: i64,
    pub stagePic: Option<String>,
    pub dropPicId: Option<String>,
    pub stageUnlock: Option<String>,
    pub entranceDownPicId: Option<String>,
    pub entranceUpPicId: Option<String>,
    pub timelyGroupId: Option<String>,
    pub weeklyPicId: Option<String>,
    pub isReplace: bool,
    pub apSupplyOutOfDateDict: Option<Vec<dict__string__longT>>,
}
impl Default for clz_Torappu_TimelyDropTimeInfoT {
    fn default() -> Self {
        Self {
            startTs: 0,
            endTs: 0,
            stagePic: None,
            dropPicId: None,
            stageUnlock: None,
            entranceDownPicId: None,
            entranceUpPicId: None,
            timelyGroupId: None,
            weeklyPicId: None,
            isReplace: false,
            apSupplyOutOfDateDict: None,
        }
    }
}
impl clz_Torappu_TimelyDropTimeInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TimelyDropTimeInfo<'b>> {
        let startTs = self.startTs;
        let endTs = self.endTs;
        let stagePic = self.stagePic.as_ref().map(|x| _fbb.create_string(x));
        let dropPicId = self.dropPicId.as_ref().map(|x| _fbb.create_string(x));
        let stageUnlock = self.stageUnlock.as_ref().map(|x| _fbb.create_string(x));
        let entranceDownPicId = self
            .entranceDownPicId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let entranceUpPicId = self.entranceUpPicId.as_ref().map(|x| _fbb.create_string(x));
        let timelyGroupId = self.timelyGroupId.as_ref().map(|x| _fbb.create_string(x));
        let weeklyPicId = self.weeklyPicId.as_ref().map(|x| _fbb.create_string(x));
        let isReplace = self.isReplace;
        let apSupplyOutOfDateDict = self.apSupplyOutOfDateDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_TimelyDropTimeInfo::create(
            _fbb,
            &clz_Torappu_TimelyDropTimeInfoArgs {
                startTs,
                endTs,
                stagePic,
                dropPicId,
                stageUnlock,
                entranceDownPicId,
                entranceUpPicId,
                timelyGroupId,
                weeklyPicId,
                isReplace,
                apSupplyOutOfDateDict,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_TimelyDropTimeInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_TimelyDropTimeInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_TimelyDropTimeInfo<'a> {
    type Inner = dict__string__clz_Torappu_TimelyDropTimeInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_TimelyDropTimeInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_TimelyDropTimeInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_TimelyDropTimeInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_TimelyDropTimeInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_TimelyDropTimeInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_TimelyDropTimeInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_TimelyDropTimeInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_TimelyDropTimeInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_TimelyDropTimeInfo) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_TimelyDropTimeInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_TimelyDropTimeInfo>>(
                    dict__string__clz_Torappu_TimelyDropTimeInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_TimelyDropTimeInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_TimelyDropTimeInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_TimelyDropTimeInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_TimelyDropTimeInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_TimelyDropTimeInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_TimelyDropTimeInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_TimelyDropTimeInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_TimelyDropTimeInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_TimelyDropTimeInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_TimelyDropTimeInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_TimelyDropTimeInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_TimelyDropTimeInfo<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_TimelyDropTimeInfo>>(
                dict__string__clz_Torappu_TimelyDropTimeInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_TimelyDropTimeInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_TimelyDropTimeInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_TimelyDropTimeInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_TimelyDropTimeInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_TimelyDropTimeInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_TimelyDropTimeInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_TimelyDropTimeInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_TimelyDropTimeInfoT>>,
}
impl Default for dict__string__clz_Torappu_TimelyDropTimeInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_TimelyDropTimeInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_TimelyDropTimeInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_TimelyDropTimeInfo::create(
            _fbb,
            &dict__string__clz_Torappu_TimelyDropTimeInfoArgs { key, value },
        )
    }
}
pub enum dict__string__clz_Torappu_StageData_StageDropInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_StageData_StageDropInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_StageData_StageDropInfo<'a> {
    type Inner = dict__string__clz_Torappu_StageData_StageDropInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_StageData_StageDropInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_StageData_StageDropInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_StageData_StageDropInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageData_StageDropInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_StageData_StageDropInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_StageData_StageDropInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_StageData_StageDropInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_StageData_StageDropInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_StageData_StageDropInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_StageData_StageDropInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData_StageDropInfo>>(
                    dict__string__clz_Torappu_StageData_StageDropInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_StageData_StageDropInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData_StageDropInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_StageData_StageDropInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_StageData_StageDropInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_StageData_StageDropInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_StageData_StageDropInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_StageData_StageDropInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_StageData_StageDropInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_StageData_StageDropInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_StageData_StageDropInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo>>(
                dict__string__clz_Torappu_StageData_StageDropInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_StageData_StageDropInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_StageData_StageDropInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageData_StageDropInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_StageData_StageDropInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_StageData_StageDropInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_StageData_StageDropInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_StageData_StageDropInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_StageData_StageDropInfoT>>,
}
impl Default for dict__string__clz_Torappu_StageData_StageDropInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_StageData_StageDropInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageData_StageDropInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_StageData_StageDropInfo::create(
            _fbb,
            &dict__string__clz_Torappu_StageData_StageDropInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_OverrideDropInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_OverrideDropInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_OverrideDropInfo<'a> {
    type Inner = clz_Torappu_OverrideDropInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_OverrideDropInfo<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_STARTTS: flatbuffers::VOffsetT = 6;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 8;
    pub const VT_ZONERANGE: flatbuffers::VOffsetT = 10;
    pub const VT_TIMES: flatbuffers::VOffsetT = 12;
    pub const VT_NAME: flatbuffers::VOffsetT = 14;
    pub const VT_EGNAME: flatbuffers::VOffsetT = 16;
    pub const VT_DESC1: flatbuffers::VOffsetT = 18;
    pub const VT_DESC2: flatbuffers::VOffsetT = 20;
    pub const VT_DESC3: flatbuffers::VOffsetT = 22;
    pub const VT_DROPTAG: flatbuffers::VOffsetT = 24;
    pub const VT_DROPTYPEDESC: flatbuffers::VOffsetT = 26;
    pub const VT_DROPINFO: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_OverrideDropInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_OverrideDropInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_OverrideDropInfo<'bldr>> {
        let mut builder = clz_Torappu_OverrideDropInfoBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        if let Some(x) = args.dropInfo {
            builder.add_dropInfo(x);
        }
        if let Some(x) = args.dropTypeDesc {
            builder.add_dropTypeDesc(x);
        }
        if let Some(x) = args.dropTag {
            builder.add_dropTag(x);
        }
        if let Some(x) = args.desc3 {
            builder.add_desc3(x);
        }
        if let Some(x) = args.desc2 {
            builder.add_desc2(x);
        }
        if let Some(x) = args.desc1 {
            builder.add_desc1(x);
        }
        if let Some(x) = args.egName {
            builder.add_egName(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_times(args.times);
        if let Some(x) = args.zoneRange {
            builder.add_zoneRange(x);
        }
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_OverrideDropInfoT {
        let itemId = self.itemId().map(|x| x.to_string());
        let startTs = self.startTs();
        let endTs = self.endTs();
        let zoneRange = self.zoneRange().map(|x| x.to_string());
        let times = self.times();
        let name = self.name().map(|x| x.to_string());
        let egName = self.egName().map(|x| x.to_string());
        let desc1 = self.desc1().map(|x| x.to_string());
        let desc2 = self.desc2().map(|x| x.to_string());
        let desc3 = self.desc3().map(|x| x.to_string());
        let dropTag = self.dropTag().map(|x| x.to_string());
        let dropTypeDesc = self.dropTypeDesc().map(|x| x.to_string());
        let dropInfo = self
            .dropInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_OverrideDropInfoT {
            itemId,
            startTs,
            endTs,
            zoneRange,
            times,
            name,
            egName,
            desc1,
            desc2,
            desc3,
            dropTag,
            dropTypeDesc,
            dropInfo,
        }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_OverrideDropInfo::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_OverrideDropInfo::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_OverrideDropInfo::VT_ENDTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn zoneRange(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_OverrideDropInfo::VT_ZONERANGE,
                None,
            )
        }
    }
    #[inline]
    pub fn times(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_OverrideDropInfo::VT_TIMES, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_OverrideDropInfo::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn egName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_OverrideDropInfo::VT_EGNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc1(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_OverrideDropInfo::VT_DESC1,
                None,
            )
        }
    }
    #[inline]
    pub fn desc2(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_OverrideDropInfo::VT_DESC2,
                None,
            )
        }
    }
    #[inline]
    pub fn desc3(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_OverrideDropInfo::VT_DESC3,
                None,
            )
        }
    }
    #[inline]
    pub fn dropTag(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_OverrideDropInfo::VT_DROPTAG,
                None,
            )
        }
    }
    #[inline]
    pub fn dropTypeDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_OverrideDropInfo::VT_DROPTYPEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn dropInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData_StageDropInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData_StageDropInfo>,
                >,
            >>(clz_Torappu_OverrideDropInfo::VT_DROPINFO, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_OverrideDropInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneRange",
                Self::VT_ZONERANGE,
                false,
            )?
            .visit_field::<i32>("times", Self::VT_TIMES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("egName", Self::VT_EGNAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc1", Self::VT_DESC1, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc2", Self::VT_DESC2, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc3", Self::VT_DESC3, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dropTag", Self::VT_DROPTAG, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dropTypeDesc",
                Self::VT_DROPTYPEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData_StageDropInfo>,
                >,
            >>("dropInfo", Self::VT_DROPINFO, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_OverrideDropInfoArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTs: i64,
    pub endTs: i64,
    pub zoneRange: Option<flatbuffers::WIPOffset<&'a str>>,
    pub times: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub egName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc3: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dropTag: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dropTypeDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dropInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData_StageDropInfo<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_OverrideDropInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_OverrideDropInfoArgs {
            itemId: None,
            startTs: 0,
            endTs: 0,
            zoneRange: None,
            times: 0,
            name: None,
            egName: None,
            desc1: None,
            desc2: None,
            desc3: None,
            dropTag: None,
            dropTypeDesc: None,
            dropInfo: None,
        }
    }
}

impl Serialize for clz_Torappu_OverrideDropInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_OverrideDropInfo", 13)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        if let Some(f) = self.zoneRange() {
            s.serialize_field("zoneRange", &f)?;
        } else {
            s.skip_field("zoneRange")?;
        }
        s.serialize_field("times", &self.times())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.egName() {
            s.serialize_field("egName", &f)?;
        } else {
            s.skip_field("egName")?;
        }
        if let Some(f) = self.desc1() {
            s.serialize_field("desc1", &f)?;
        } else {
            s.skip_field("desc1")?;
        }
        if let Some(f) = self.desc2() {
            s.serialize_field("desc2", &f)?;
        } else {
            s.skip_field("desc2")?;
        }
        if let Some(f) = self.desc3() {
            s.serialize_field("desc3", &f)?;
        } else {
            s.skip_field("desc3")?;
        }
        if let Some(f) = self.dropTag() {
            s.serialize_field("dropTag", &f)?;
        } else {
            s.skip_field("dropTag")?;
        }
        if let Some(f) = self.dropTypeDesc() {
            s.serialize_field("dropTypeDesc", &f)?;
        } else {
            s.skip_field("dropTypeDesc")?;
        }
        if let Some(f) = self.dropInfo() {
            s.serialize_field("dropInfo", &f)?;
        } else {
            s.skip_field("dropInfo")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_OverrideDropInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_OverrideDropInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_OverrideDropInfo::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_OverrideDropInfo::VT_STARTTS, startTs, 0);
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_OverrideDropInfo::VT_ENDTS, endTs, 0);
    }
    #[inline]
    pub fn add_zoneRange(&mut self, zoneRange: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_OverrideDropInfo::VT_ZONERANGE,
            zoneRange,
        );
    }
    #[inline]
    pub fn add_times(&mut self, times: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_OverrideDropInfo::VT_TIMES, times, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_OverrideDropInfo::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_egName(&mut self, egName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_OverrideDropInfo::VT_EGNAME,
            egName,
        );
    }
    #[inline]
    pub fn add_desc1(&mut self, desc1: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_OverrideDropInfo::VT_DESC1,
            desc1,
        );
    }
    #[inline]
    pub fn add_desc2(&mut self, desc2: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_OverrideDropInfo::VT_DESC2,
            desc2,
        );
    }
    #[inline]
    pub fn add_desc3(&mut self, desc3: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_OverrideDropInfo::VT_DESC3,
            desc3,
        );
    }
    #[inline]
    pub fn add_dropTag(&mut self, dropTag: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_OverrideDropInfo::VT_DROPTAG,
            dropTag,
        );
    }
    #[inline]
    pub fn add_dropTypeDesc(&mut self, dropTypeDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_OverrideDropInfo::VT_DROPTYPEDESC,
            dropTypeDesc,
        );
    }
    #[inline]
    pub fn add_dropInfo(
        &mut self,
        dropInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData_StageDropInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_OverrideDropInfo::VT_DROPINFO,
            dropInfo,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_OverrideDropInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_OverrideDropInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_OverrideDropInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_OverrideDropInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_OverrideDropInfo");
        ds.field("itemId", &self.itemId());
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.field("zoneRange", &self.zoneRange());
        ds.field("times", &self.times());
        ds.field("name", &self.name());
        ds.field("egName", &self.egName());
        ds.field("desc1", &self.desc1());
        ds.field("desc2", &self.desc2());
        ds.field("desc3", &self.desc3());
        ds.field("dropTag", &self.dropTag());
        ds.field("dropTypeDesc", &self.dropTypeDesc());
        ds.field("dropInfo", &self.dropInfo());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_OverrideDropInfoT {
    pub itemId: Option<String>,
    pub startTs: i64,
    pub endTs: i64,
    pub zoneRange: Option<String>,
    pub times: i32,
    pub name: Option<String>,
    pub egName: Option<String>,
    pub desc1: Option<String>,
    pub desc2: Option<String>,
    pub desc3: Option<String>,
    pub dropTag: Option<String>,
    pub dropTypeDesc: Option<String>,
    pub dropInfo: Option<Vec<dict__string__clz_Torappu_StageData_StageDropInfoT>>,
}
impl Default for clz_Torappu_OverrideDropInfoT {
    fn default() -> Self {
        Self {
            itemId: None,
            startTs: 0,
            endTs: 0,
            zoneRange: None,
            times: 0,
            name: None,
            egName: None,
            desc1: None,
            desc2: None,
            desc3: None,
            dropTag: None,
            dropTypeDesc: None,
            dropInfo: None,
        }
    }
}
impl clz_Torappu_OverrideDropInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_OverrideDropInfo<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let startTs = self.startTs;
        let endTs = self.endTs;
        let zoneRange = self.zoneRange.as_ref().map(|x| _fbb.create_string(x));
        let times = self.times;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let egName = self.egName.as_ref().map(|x| _fbb.create_string(x));
        let desc1 = self.desc1.as_ref().map(|x| _fbb.create_string(x));
        let desc2 = self.desc2.as_ref().map(|x| _fbb.create_string(x));
        let desc3 = self.desc3.as_ref().map(|x| _fbb.create_string(x));
        let dropTag = self.dropTag.as_ref().map(|x| _fbb.create_string(x));
        let dropTypeDesc = self.dropTypeDesc.as_ref().map(|x| _fbb.create_string(x));
        let dropInfo = self.dropInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_OverrideDropInfo::create(
            _fbb,
            &clz_Torappu_OverrideDropInfoArgs {
                itemId,
                startTs,
                endTs,
                zoneRange,
                times,
                name,
                egName,
                desc1,
                desc2,
                desc3,
                dropTag,
                dropTypeDesc,
                dropInfo,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_OverrideDropInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_OverrideDropInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_OverrideDropInfo<'a> {
    type Inner = dict__string__clz_Torappu_OverrideDropInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_OverrideDropInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_OverrideDropInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_OverrideDropInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_OverrideDropInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_OverrideDropInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_OverrideDropInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_OverrideDropInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_OverrideDropInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_OverrideDropInfo) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_OverrideDropInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_OverrideDropInfo>>(
                    dict__string__clz_Torappu_OverrideDropInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_OverrideDropInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_OverrideDropInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_OverrideDropInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_OverrideDropInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_OverrideDropInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_OverrideDropInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_OverrideDropInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_OverrideDropInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_OverrideDropInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_OverrideDropInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_OverrideDropInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_OverrideDropInfo<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_OverrideDropInfo>>(
                dict__string__clz_Torappu_OverrideDropInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_OverrideDropInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_OverrideDropInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_OverrideDropInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_OverrideDropInfo::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_OverrideDropInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_OverrideDropInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_OverrideDropInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_OverrideDropInfoT>>,
}
impl Default for dict__string__clz_Torappu_OverrideDropInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_OverrideDropInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_OverrideDropInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_OverrideDropInfo::create(
            _fbb,
            &dict__string__clz_Torappu_OverrideDropInfoArgs { key, value },
        )
    }
}
pub enum dict__string__list_clz_Torappu_StageData_ConditionDescOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_clz_Torappu_StageData_ConditionDesc<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_clz_Torappu_StageData_ConditionDesc<'a> {
    type Inner = dict__string__list_clz_Torappu_StageData_ConditionDesc<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__list_clz_Torappu_StageData_ConditionDesc<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_clz_Torappu_StageData_ConditionDesc { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_clz_Torappu_StageData_ConditionDescArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_StageData_ConditionDesc<'bldr>> {
        let mut builder = dict__string__list_clz_Torappu_StageData_ConditionDescBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__list_clz_Torappu_StageData_ConditionDescT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__string__list_clz_Torappu_StageData_ConditionDescT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__list_clz_Torappu_StageData_ConditionDesc::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_clz_Torappu_StageData_ConditionDesc,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ConditionDesc<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ConditionDesc>,
                >,
            >>(
                dict__string__list_clz_Torappu_StageData_ConditionDesc::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_clz_Torappu_StageData_ConditionDesc<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ConditionDesc>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_clz_Torappu_StageData_ConditionDescArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ConditionDesc<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__string__list_clz_Torappu_StageData_ConditionDescArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_clz_Torappu_StageData_ConditionDescArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__list_clz_Torappu_StageData_ConditionDesc<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__list_clz_Torappu_StageData_ConditionDesc", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__list_clz_Torappu_StageData_ConditionDescBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_clz_Torappu_StageData_ConditionDescBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_StageData_ConditionDesc::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ConditionDesc<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_StageData_ConditionDesc::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_clz_Torappu_StageData_ConditionDescBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_clz_Torappu_StageData_ConditionDescBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_StageData_ConditionDesc<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__list_clz_Torappu_StageData_ConditionDesc::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_clz_Torappu_StageData_ConditionDesc<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_clz_Torappu_StageData_ConditionDesc");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_clz_Torappu_StageData_ConditionDescT {
    pub key: String,
    pub value: Option<Vec<clz_Torappu_StageData_ConditionDescT>>,
}
impl Default for dict__string__list_clz_Torappu_StageData_ConditionDescT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_clz_Torappu_StageData_ConditionDescT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_StageData_ConditionDesc<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_clz_Torappu_StageData_ConditionDesc::create(
            _fbb,
            &dict__string__list_clz_Torappu_StageData_ConditionDescArgs { key, value },
        )
    }
}
pub enum clz_Torappu_OverrideUnlockInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_OverrideUnlockInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_OverrideUnlockInfo<'a> {
    type Inner = clz_Torappu_OverrideUnlockInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_OverrideUnlockInfo<'a> {
    pub const VT_GROUPID: flatbuffers::VOffsetT = 4;
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 6;
    pub const VT_ENDTIME: flatbuffers::VOffsetT = 8;
    pub const VT_UNLOCKDICT: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_OverrideUnlockInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_OverrideUnlockInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_OverrideUnlockInfo<'bldr>> {
        let mut builder = clz_Torappu_OverrideUnlockInfoBuilder::new(_fbb);
        builder.add_endTime(args.endTime);
        builder.add_startTime(args.startTime);
        if let Some(x) = args.unlockDict {
            builder.add_unlockDict(x);
        }
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_OverrideUnlockInfoT {
        let groupId = self.groupId().map(|x| x.to_string());
        let startTime = self.startTime();
        let endTime = self.endTime();
        let unlockDict = self
            .unlockDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_OverrideUnlockInfoT {
            groupId,
            startTime,
            endTime,
            unlockDict,
        }
    }

    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_OverrideUnlockInfo::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_OverrideUnlockInfo::VT_STARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_OverrideUnlockInfo::VT_ENDTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__list_clz_Torappu_StageData_ConditionDesc<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_clz_Torappu_StageData_ConditionDesc,
                    >,
                >,
            >>(clz_Torappu_OverrideUnlockInfo::VT_UNLOCKDICT, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_OverrideUnlockInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<i64>("endTime", Self::VT_ENDTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_clz_Torappu_StageData_ConditionDesc,
                    >,
                >,
            >>("unlockDict", Self::VT_UNLOCKDICT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_OverrideUnlockInfoArgs<'a> {
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTime: i64,
    pub endTime: i64,
    pub unlockDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_StageData_ConditionDesc<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_OverrideUnlockInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_OverrideUnlockInfoArgs {
            groupId: None,
            startTime: 0,
            endTime: 0,
            unlockDict: None,
        }
    }
}

impl Serialize for clz_Torappu_OverrideUnlockInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_OverrideUnlockInfo", 4)?;
        if let Some(f) = self.groupId() {
            s.serialize_field("groupId", &f)?;
        } else {
            s.skip_field("groupId")?;
        }
        s.serialize_field("startTime", &self.startTime())?;
        s.serialize_field("endTime", &self.endTime())?;
        if let Some(f) = self.unlockDict() {
            s.serialize_field("unlockDict", &f)?;
        } else {
            s.skip_field("unlockDict")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_OverrideUnlockInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_OverrideUnlockInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_OverrideUnlockInfo::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_OverrideUnlockInfo::VT_STARTTIME, startTime, 0);
    }
    #[inline]
    pub fn add_endTime(&mut self, endTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_OverrideUnlockInfo::VT_ENDTIME, endTime, 0);
    }
    #[inline]
    pub fn add_unlockDict(
        &mut self,
        unlockDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_StageData_ConditionDesc<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_OverrideUnlockInfo::VT_UNLOCKDICT,
            unlockDict,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_OverrideUnlockInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_OverrideUnlockInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_OverrideUnlockInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_OverrideUnlockInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_OverrideUnlockInfo");
        ds.field("groupId", &self.groupId());
        ds.field("startTime", &self.startTime());
        ds.field("endTime", &self.endTime());
        ds.field("unlockDict", &self.unlockDict());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_OverrideUnlockInfoT {
    pub groupId: Option<String>,
    pub startTime: i64,
    pub endTime: i64,
    pub unlockDict: Option<Vec<dict__string__list_clz_Torappu_StageData_ConditionDescT>>,
}
impl Default for clz_Torappu_OverrideUnlockInfoT {
    fn default() -> Self {
        Self {
            groupId: None,
            startTime: 0,
            endTime: 0,
            unlockDict: None,
        }
    }
}
impl clz_Torappu_OverrideUnlockInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_OverrideUnlockInfo<'b>> {
        let groupId = self.groupId.as_ref().map(|x| _fbb.create_string(x));
        let startTime = self.startTime;
        let endTime = self.endTime;
        let unlockDict = self.unlockDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_OverrideUnlockInfo::create(
            _fbb,
            &clz_Torappu_OverrideUnlockInfoArgs {
                groupId,
                startTime,
                endTime,
                unlockDict,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_OverrideUnlockInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_OverrideUnlockInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_OverrideUnlockInfo<'a> {
    type Inner = dict__string__clz_Torappu_OverrideUnlockInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_OverrideUnlockInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_OverrideUnlockInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_OverrideUnlockInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_OverrideUnlockInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_OverrideUnlockInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_OverrideUnlockInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_OverrideUnlockInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_OverrideUnlockInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_OverrideUnlockInfo) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_OverrideUnlockInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_OverrideUnlockInfo>>(
                    dict__string__clz_Torappu_OverrideUnlockInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_OverrideUnlockInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_OverrideUnlockInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_OverrideUnlockInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_OverrideUnlockInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_OverrideUnlockInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_OverrideUnlockInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_OverrideUnlockInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_OverrideUnlockInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_OverrideUnlockInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_OverrideUnlockInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_OverrideUnlockInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_OverrideUnlockInfo<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_OverrideUnlockInfo>>(
                dict__string__clz_Torappu_OverrideUnlockInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_OverrideUnlockInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_OverrideUnlockInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_OverrideUnlockInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_OverrideUnlockInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_OverrideUnlockInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_OverrideUnlockInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_OverrideUnlockInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_OverrideUnlockInfoT>>,
}
impl Default for dict__string__clz_Torappu_OverrideUnlockInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_OverrideUnlockInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_OverrideUnlockInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_OverrideUnlockInfo::create(
            _fbb,
            &dict__string__clz_Torappu_OverrideUnlockInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_TimelyDropInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TimelyDropInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TimelyDropInfo<'a> {
    type Inner = clz_Torappu_TimelyDropInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_TimelyDropInfo<'a> {
    pub const VT_DROPINFO: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TimelyDropInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TimelyDropInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TimelyDropInfo<'bldr>> {
        let mut builder = clz_Torappu_TimelyDropInfoBuilder::new(_fbb);
        if let Some(x) = args.dropInfo {
            builder.add_dropInfo(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_TimelyDropInfoT {
        let dropInfo = self
            .dropInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_TimelyDropInfoT { dropInfo }
    }

    #[inline]
    pub fn dropInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData_StageDropInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData_StageDropInfo>,
                >,
            >>(clz_Torappu_TimelyDropInfo::VT_DROPINFO, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TimelyDropInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData_StageDropInfo>,
                >,
            >>("dropInfo", Self::VT_DROPINFO, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TimelyDropInfoArgs<'a> {
    pub dropInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData_StageDropInfo<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_TimelyDropInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TimelyDropInfoArgs { dropInfo: None }
    }
}

impl Serialize for clz_Torappu_TimelyDropInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_TimelyDropInfo", 1)?;
        if let Some(f) = self.dropInfo() {
            s.serialize_field("dropInfo", &f)?;
        } else {
            s.skip_field("dropInfo")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_TimelyDropInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TimelyDropInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_dropInfo(
        &mut self,
        dropInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData_StageDropInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TimelyDropInfo::VT_DROPINFO,
            dropInfo,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TimelyDropInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TimelyDropInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TimelyDropInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TimelyDropInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TimelyDropInfo");
        ds.field("dropInfo", &self.dropInfo());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_TimelyDropInfoT {
    pub dropInfo: Option<Vec<dict__string__clz_Torappu_StageData_StageDropInfoT>>,
}
impl Default for clz_Torappu_TimelyDropInfoT {
    fn default() -> Self {
        Self { dropInfo: None }
    }
}
impl clz_Torappu_TimelyDropInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TimelyDropInfo<'b>> {
        let dropInfo = self.dropInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_TimelyDropInfo::create(_fbb, &clz_Torappu_TimelyDropInfoArgs { dropInfo })
    }
}
pub enum dict__string__clz_Torappu_TimelyDropInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_TimelyDropInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_TimelyDropInfo<'a> {
    type Inner = dict__string__clz_Torappu_TimelyDropInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_TimelyDropInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_TimelyDropInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_TimelyDropInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_TimelyDropInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_TimelyDropInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_TimelyDropInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_TimelyDropInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_TimelyDropInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_TimelyDropInfo) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_TimelyDropInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_TimelyDropInfo>>(
                    dict__string__clz_Torappu_TimelyDropInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_TimelyDropInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_TimelyDropInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_TimelyDropInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_TimelyDropInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_TimelyDropInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_TimelyDropInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_TimelyDropInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_TimelyDropInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_TimelyDropInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_TimelyDropInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_TimelyDropInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_TimelyDropInfo<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_TimelyDropInfo>>(
                dict__string__clz_Torappu_TimelyDropInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_TimelyDropInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_TimelyDropInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_TimelyDropInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_TimelyDropInfo::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_TimelyDropInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_TimelyDropInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_TimelyDropInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_TimelyDropInfoT>>,
}
impl Default for dict__string__clz_Torappu_TimelyDropInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_TimelyDropInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_TimelyDropInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_TimelyDropInfo::create(
            _fbb,
            &dict__string__clz_Torappu_TimelyDropInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_StageValidInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageValidInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageValidInfo<'a> {
    type Inner = clz_Torappu_StageValidInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageValidInfo<'a> {
    pub const VT_STARTTS: flatbuffers::VOffsetT = 4;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageValidInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageValidInfoArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageValidInfo<'bldr>> {
        let mut builder = clz_Torappu_StageValidInfoBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageValidInfoT {
        let startTs = self.startTs();
        let endTs = self.endTs();
        clz_Torappu_StageValidInfoT { startTs, endTs }
    }

    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_StageValidInfo::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_StageValidInfo::VT_ENDTS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageValidInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageValidInfoArgs {
    pub startTs: i64,
    pub endTs: i64,
}
impl<'a> Default for clz_Torappu_StageValidInfoArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageValidInfoArgs {
            startTs: 0,
            endTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_StageValidInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageValidInfo", 2)?;
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        s.end()
    }
}

pub struct clz_Torappu_StageValidInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_StageValidInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_StageValidInfo::VT_STARTTS, startTs, 0);
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_StageValidInfo::VT_ENDTS, endTs, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageValidInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageValidInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageValidInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageValidInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageValidInfo");
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageValidInfoT {
    pub startTs: i64,
    pub endTs: i64,
}
impl Default for clz_Torappu_StageValidInfoT {
    fn default() -> Self {
        Self {
            startTs: 0,
            endTs: 0,
        }
    }
}
impl clz_Torappu_StageValidInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageValidInfo<'b>> {
        let startTs = self.startTs;
        let endTs = self.endTs;
        clz_Torappu_StageValidInfo::create(_fbb, &clz_Torappu_StageValidInfoArgs { startTs, endTs })
    }
}
pub enum dict__string__clz_Torappu_StageValidInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_StageValidInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_StageValidInfo<'a> {
    type Inner = dict__string__clz_Torappu_StageValidInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_StageValidInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_StageValidInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_StageValidInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageValidInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_StageValidInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_StageValidInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_StageValidInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_StageValidInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_StageValidInfo) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_StageValidInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StageValidInfo>>(
                    dict__string__clz_Torappu_StageValidInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_StageValidInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StageValidInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_StageValidInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_StageValidInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_StageValidInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_StageValidInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_StageValidInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_StageValidInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_StageValidInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_StageValidInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_StageValidInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_StageValidInfo<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StageValidInfo>>(
                dict__string__clz_Torappu_StageValidInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_StageValidInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_StageValidInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageValidInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_StageValidInfo::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_StageValidInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_StageValidInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_StageValidInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_StageValidInfoT>>,
}
impl Default for dict__string__clz_Torappu_StageValidInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_StageValidInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageValidInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_StageValidInfo::create(
            _fbb,
            &dict__string__clz_Torappu_StageValidInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_StageFogInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageFogInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageFogInfo<'a> {
    type Inner = clz_Torappu_StageFogInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageFogInfo<'a> {
    pub const VT_LOCKID: flatbuffers::VOffsetT = 4;
    pub const VT_FOGTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_STAGEBUTTONINFOGRENDERTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_STAGEID: flatbuffers::VOffsetT = 10;
    pub const VT_LOCKNAME: flatbuffers::VOffsetT = 12;
    pub const VT_LOCKDESC: flatbuffers::VOffsetT = 14;
    pub const VT_UNLOCKITEMID: flatbuffers::VOffsetT = 16;
    pub const VT_UNLOCKITEMTYPE: flatbuffers::VOffsetT = 18;
    pub const VT_UNLOCKITEMNUM: flatbuffers::VOffsetT = 20;
    pub const VT_PREPOSEDSTAGEID: flatbuffers::VOffsetT = 22;
    pub const VT_PREPOSEDLOCKID: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageFogInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageFogInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageFogInfo<'bldr>> {
        let mut builder = clz_Torappu_StageFogInfoBuilder::new(_fbb);
        if let Some(x) = args.preposedLockId {
            builder.add_preposedLockId(x);
        }
        if let Some(x) = args.preposedStageId {
            builder.add_preposedStageId(x);
        }
        builder.add_unlockItemNum(args.unlockItemNum);
        builder.add_unlockItemType(args.unlockItemType);
        if let Some(x) = args.unlockItemId {
            builder.add_unlockItemId(x);
        }
        if let Some(x) = args.lockDesc {
            builder.add_lockDesc(x);
        }
        if let Some(x) = args.lockName {
            builder.add_lockName(x);
        }
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.add_stageButtonInFogRenderType(args.stageButtonInFogRenderType);
        builder.add_fogType(args.fogType);
        if let Some(x) = args.lockId {
            builder.add_lockId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageFogInfoT {
        let lockId = self.lockId().map(|x| x.to_string());
        let fogType = self.fogType();
        let stageButtonInFogRenderType = self.stageButtonInFogRenderType();
        let stageId = self.stageId().map(|x| x.to_string());
        let lockName = self.lockName().map(|x| x.to_string());
        let lockDesc = self.lockDesc().map(|x| x.to_string());
        let unlockItemId = self.unlockItemId().map(|x| x.to_string());
        let unlockItemType = self.unlockItemType();
        let unlockItemNum = self.unlockItemNum();
        let preposedStageId = self.preposedStageId().map(|x| x.to_string());
        let preposedLockId = self.preposedLockId().map(|x| x.to_string());
        clz_Torappu_StageFogInfoT {
            lockId,
            fogType,
            stageButtonInFogRenderType,
            stageId,
            lockName,
            lockDesc,
            unlockItemId,
            unlockItemType,
            unlockItemNum,
            preposedStageId,
            preposedLockId,
        }
    }

    #[inline]
    pub fn lockId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageFogInfo::VT_LOCKID,
                None,
            )
        }
    }
    #[inline]
    pub fn fogType(&self) -> enum__Torappu_FogType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_FogType>(
                    clz_Torappu_StageFogInfo::VT_FOGTYPE,
                    Some(enum__Torappu_FogType::ZONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn stageButtonInFogRenderType(&self) -> enum__Torappu_StageButtonInFogRenderType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageButtonInFogRenderType>(
                    clz_Torappu_StageFogInfo::VT_STAGEBUTTONINFOGRENDERTYPE,
                    Some(enum__Torappu_StageButtonInFogRenderType::HIDE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageFogInfo::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn lockName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageFogInfo::VT_LOCKNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn lockDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageFogInfo::VT_LOCKDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageFogInfo::VT_UNLOCKITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockItemType(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_StageFogInfo::VT_UNLOCKITEMTYPE,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockItemNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageFogInfo::VT_UNLOCKITEMNUM, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn preposedStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageFogInfo::VT_PREPOSEDSTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn preposedLockId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageFogInfo::VT_PREPOSEDLOCKID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageFogInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lockId", Self::VT_LOCKID, false)?
            .visit_field::<enum__Torappu_FogType>("fogType", Self::VT_FOGTYPE, false)?
            .visit_field::<enum__Torappu_StageButtonInFogRenderType>(
                "stageButtonInFogRenderType",
                Self::VT_STAGEBUTTONINFOGRENDERTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "lockName",
                Self::VT_LOCKNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "lockDesc",
                Self::VT_LOCKDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockItemId",
                Self::VT_UNLOCKITEMID,
                false,
            )?
            .visit_field::<enum__Torappu_ItemType>(
                "unlockItemType",
                Self::VT_UNLOCKITEMTYPE,
                false,
            )?
            .visit_field::<i32>("unlockItemNum", Self::VT_UNLOCKITEMNUM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "preposedStageId",
                Self::VT_PREPOSEDSTAGEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "preposedLockId",
                Self::VT_PREPOSEDLOCKID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageFogInfoArgs<'a> {
    pub lockId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fogType: enum__Torappu_FogType,
    pub stageButtonInFogRenderType: enum__Torappu_StageButtonInFogRenderType,
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lockName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lockDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockItemType: enum__Torappu_ItemType,
    pub unlockItemNum: i32,
    pub preposedStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub preposedLockId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_StageFogInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageFogInfoArgs {
            lockId: None,
            fogType: enum__Torappu_FogType::ZONE,
            stageButtonInFogRenderType: enum__Torappu_StageButtonInFogRenderType::HIDE,
            stageId: None,
            lockName: None,
            lockDesc: None,
            unlockItemId: None,
            unlockItemType: enum__Torappu_ItemType::NONE,
            unlockItemNum: 0,
            preposedStageId: None,
            preposedLockId: None,
        }
    }
}

impl Serialize for clz_Torappu_StageFogInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageFogInfo", 11)?;
        if let Some(f) = self.lockId() {
            s.serialize_field("lockId", &f)?;
        } else {
            s.skip_field("lockId")?;
        }
        s.serialize_field("fogType", &self.fogType())?;
        s.serialize_field(
            "stageButtonInFogRenderType",
            &self.stageButtonInFogRenderType(),
        )?;
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        if let Some(f) = self.lockName() {
            s.serialize_field("lockName", &f)?;
        } else {
            s.skip_field("lockName")?;
        }
        if let Some(f) = self.lockDesc() {
            s.serialize_field("lockDesc", &f)?;
        } else {
            s.skip_field("lockDesc")?;
        }
        if let Some(f) = self.unlockItemId() {
            s.serialize_field("unlockItemId", &f)?;
        } else {
            s.skip_field("unlockItemId")?;
        }
        s.serialize_field("unlockItemType", &self.unlockItemType())?;
        s.serialize_field("unlockItemNum", &self.unlockItemNum())?;
        if let Some(f) = self.preposedStageId() {
            s.serialize_field("preposedStageId", &f)?;
        } else {
            s.skip_field("preposedStageId")?;
        }
        if let Some(f) = self.preposedLockId() {
            s.serialize_field("preposedLockId", &f)?;
        } else {
            s.skip_field("preposedLockId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StageFogInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_StageFogInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_lockId(&mut self, lockId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageFogInfo::VT_LOCKID,
            lockId,
        );
    }
    #[inline]
    pub fn add_fogType(&mut self, fogType: enum__Torappu_FogType) {
        self.fbb_.push_slot::<enum__Torappu_FogType>(
            clz_Torappu_StageFogInfo::VT_FOGTYPE,
            fogType,
            enum__Torappu_FogType::ZONE,
        );
    }
    #[inline]
    pub fn add_stageButtonInFogRenderType(
        &mut self,
        stageButtonInFogRenderType: enum__Torappu_StageButtonInFogRenderType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_StageButtonInFogRenderType>(
                clz_Torappu_StageFogInfo::VT_STAGEBUTTONINFOGRENDERTYPE,
                stageButtonInFogRenderType,
                enum__Torappu_StageButtonInFogRenderType::HIDE,
            );
    }
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageFogInfo::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_lockName(&mut self, lockName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageFogInfo::VT_LOCKNAME,
            lockName,
        );
    }
    #[inline]
    pub fn add_lockDesc(&mut self, lockDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageFogInfo::VT_LOCKDESC,
            lockDesc,
        );
    }
    #[inline]
    pub fn add_unlockItemId(&mut self, unlockItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageFogInfo::VT_UNLOCKITEMID,
            unlockItemId,
        );
    }
    #[inline]
    pub fn add_unlockItemType(&mut self, unlockItemType: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_StageFogInfo::VT_UNLOCKITEMTYPE,
            unlockItemType,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_unlockItemNum(&mut self, unlockItemNum: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageFogInfo::VT_UNLOCKITEMNUM, unlockItemNum, 0);
    }
    #[inline]
    pub fn add_preposedStageId(&mut self, preposedStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageFogInfo::VT_PREPOSEDSTAGEID,
            preposedStageId,
        );
    }
    #[inline]
    pub fn add_preposedLockId(&mut self, preposedLockId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageFogInfo::VT_PREPOSEDLOCKID,
            preposedLockId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageFogInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageFogInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageFogInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageFogInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageFogInfo");
        ds.field("lockId", &self.lockId());
        ds.field("fogType", &self.fogType());
        ds.field(
            "stageButtonInFogRenderType",
            &self.stageButtonInFogRenderType(),
        );
        ds.field("stageId", &self.stageId());
        ds.field("lockName", &self.lockName());
        ds.field("lockDesc", &self.lockDesc());
        ds.field("unlockItemId", &self.unlockItemId());
        ds.field("unlockItemType", &self.unlockItemType());
        ds.field("unlockItemNum", &self.unlockItemNum());
        ds.field("preposedStageId", &self.preposedStageId());
        ds.field("preposedLockId", &self.preposedLockId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageFogInfoT {
    pub lockId: Option<String>,
    pub fogType: enum__Torappu_FogType,
    pub stageButtonInFogRenderType: enum__Torappu_StageButtonInFogRenderType,
    pub stageId: Option<String>,
    pub lockName: Option<String>,
    pub lockDesc: Option<String>,
    pub unlockItemId: Option<String>,
    pub unlockItemType: enum__Torappu_ItemType,
    pub unlockItemNum: i32,
    pub preposedStageId: Option<String>,
    pub preposedLockId: Option<String>,
}
impl Default for clz_Torappu_StageFogInfoT {
    fn default() -> Self {
        Self {
            lockId: None,
            fogType: enum__Torappu_FogType::ZONE,
            stageButtonInFogRenderType: enum__Torappu_StageButtonInFogRenderType::HIDE,
            stageId: None,
            lockName: None,
            lockDesc: None,
            unlockItemId: None,
            unlockItemType: enum__Torappu_ItemType::NONE,
            unlockItemNum: 0,
            preposedStageId: None,
            preposedLockId: None,
        }
    }
}
impl clz_Torappu_StageFogInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageFogInfo<'b>> {
        let lockId = self.lockId.as_ref().map(|x| _fbb.create_string(x));
        let fogType = self.fogType;
        let stageButtonInFogRenderType = self.stageButtonInFogRenderType;
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let lockName = self.lockName.as_ref().map(|x| _fbb.create_string(x));
        let lockDesc = self.lockDesc.as_ref().map(|x| _fbb.create_string(x));
        let unlockItemId = self.unlockItemId.as_ref().map(|x| _fbb.create_string(x));
        let unlockItemType = self.unlockItemType;
        let unlockItemNum = self.unlockItemNum;
        let preposedStageId = self.preposedStageId.as_ref().map(|x| _fbb.create_string(x));
        let preposedLockId = self.preposedLockId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_StageFogInfo::create(
            _fbb,
            &clz_Torappu_StageFogInfoArgs {
                lockId,
                fogType,
                stageButtonInFogRenderType,
                stageId,
                lockName,
                lockDesc,
                unlockItemId,
                unlockItemType,
                unlockItemNum,
                preposedStageId,
                preposedLockId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_StageFogInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_StageFogInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_StageFogInfo<'a> {
    type Inner = dict__string__clz_Torappu_StageFogInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_StageFogInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_StageFogInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_StageFogInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageFogInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_StageFogInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_StageFogInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_StageFogInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_StageFogInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_StageFogInfo) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_StageFogInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StageFogInfo>>(
                    dict__string__clz_Torappu_StageFogInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_StageFogInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StageFogInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_StageFogInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_StageFogInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_StageFogInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_StageFogInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_StageFogInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_StageFogInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_StageFogInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_StageFogInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_StageFogInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_StageFogInfo<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StageFogInfo>>(
                dict__string__clz_Torappu_StageFogInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_StageFogInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_StageFogInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageFogInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_StageFogInfo::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_StageFogInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_StageFogInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_StageFogInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_StageFogInfoT>>,
}
impl Default for dict__string__clz_Torappu_StageFogInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_StageFogInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageFogInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_StageFogInfo::create(
            _fbb,
            &dict__string__clz_Torappu_StageFogInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_StageStartCond_RequireCharOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageStartCond_RequireChar<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageStartCond_RequireChar<'a> {
    type Inner = clz_Torappu_StageStartCond_RequireChar<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageStartCond_RequireChar<'a> {
    pub const VT_CHARID: flatbuffers::VOffsetT = 4;
    pub const VT_EVOLVEPHASE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageStartCond_RequireChar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageStartCond_RequireCharArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageStartCond_RequireChar<'bldr>> {
        let mut builder = clz_Torappu_StageStartCond_RequireCharBuilder::new(_fbb);
        builder.add_evolvePhase(args.evolvePhase);
        if let Some(x) = args.charId {
            builder.add_charId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageStartCond_RequireCharT {
        let charId = self.charId().map(|x| x.to_string());
        let evolvePhase = self.evolvePhase();
        clz_Torappu_StageStartCond_RequireCharT {
            charId,
            evolvePhase,
        }
    }

    #[inline]
    pub fn charId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageStartCond_RequireChar::VT_CHARID,
                None,
            )
        }
    }
    #[inline]
    pub fn evolvePhase(&self) -> enum__Torappu_EvolvePhase {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EvolvePhase>(
                    clz_Torappu_StageStartCond_RequireChar::VT_EVOLVEPHASE,
                    Some(enum__Torappu_EvolvePhase::PHASE_0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageStartCond_RequireChar<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charId", Self::VT_CHARID, false)?
            .visit_field::<enum__Torappu_EvolvePhase>("evolvePhase", Self::VT_EVOLVEPHASE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageStartCond_RequireCharArgs<'a> {
    pub charId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub evolvePhase: enum__Torappu_EvolvePhase,
}
impl<'a> Default for clz_Torappu_StageStartCond_RequireCharArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageStartCond_RequireCharArgs {
            charId: None,
            evolvePhase: enum__Torappu_EvolvePhase::PHASE_0,
        }
    }
}

impl Serialize for clz_Torappu_StageStartCond_RequireChar<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageStartCond_RequireChar", 2)?;
        if let Some(f) = self.charId() {
            s.serialize_field("charId", &f)?;
        } else {
            s.skip_field("charId")?;
        }
        s.serialize_field("evolvePhase", &self.evolvePhase())?;
        s.end()
    }
}

pub struct clz_Torappu_StageStartCond_RequireCharBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageStartCond_RequireCharBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_charId(&mut self, charId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageStartCond_RequireChar::VT_CHARID,
            charId,
        );
    }
    #[inline]
    pub fn add_evolvePhase(&mut self, evolvePhase: enum__Torappu_EvolvePhase) {
        self.fbb_.push_slot::<enum__Torappu_EvolvePhase>(
            clz_Torappu_StageStartCond_RequireChar::VT_EVOLVEPHASE,
            evolvePhase,
            enum__Torappu_EvolvePhase::PHASE_0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageStartCond_RequireCharBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageStartCond_RequireCharBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageStartCond_RequireChar<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageStartCond_RequireChar<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageStartCond_RequireChar");
        ds.field("charId", &self.charId());
        ds.field("evolvePhase", &self.evolvePhase());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageStartCond_RequireCharT {
    pub charId: Option<String>,
    pub evolvePhase: enum__Torappu_EvolvePhase,
}
impl Default for clz_Torappu_StageStartCond_RequireCharT {
    fn default() -> Self {
        Self {
            charId: None,
            evolvePhase: enum__Torappu_EvolvePhase::PHASE_0,
        }
    }
}
impl clz_Torappu_StageStartCond_RequireCharT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageStartCond_RequireChar<'b>> {
        let charId = self.charId.as_ref().map(|x| _fbb.create_string(x));
        let evolvePhase = self.evolvePhase;
        clz_Torappu_StageStartCond_RequireChar::create(
            _fbb,
            &clz_Torappu_StageStartCond_RequireCharArgs {
                charId,
                evolvePhase,
            },
        )
    }
}
pub enum clz_Torappu_StageStartCondOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageStartCond<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageStartCond<'a> {
    type Inner = clz_Torappu_StageStartCond<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageStartCond<'a> {
    pub const VT_REQUIRECHARS: flatbuffers::VOffsetT = 4;
    pub const VT_EXCLUDEASSISTS: flatbuffers::VOffsetT = 6;
    pub const VT_ISNOTPASS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageStartCond { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageStartCondArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageStartCond<'bldr>> {
        let mut builder = clz_Torappu_StageStartCondBuilder::new(_fbb);
        if let Some(x) = args.excludeAssists {
            builder.add_excludeAssists(x);
        }
        if let Some(x) = args.requireChars {
            builder.add_requireChars(x);
        }
        builder.add_isNotPass(args.isNotPass);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageStartCondT {
        let requireChars = self
            .requireChars()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let excludeAssists = self
            .excludeAssists()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let isNotPass = self.isNotPass();
        clz_Torappu_StageStartCondT {
            requireChars,
            excludeAssists,
            isNotPass,
        }
    }

    #[inline]
    pub fn requireChars(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageStartCond_RequireChar<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageStartCond_RequireChar>,
                >,
            >>(clz_Torappu_StageStartCond::VT_REQUIRECHARS, None)
        }
    }
    #[inline]
    pub fn excludeAssists(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_StageStartCond::VT_EXCLUDEASSISTS, None)
        }
    }
    #[inline]
    pub fn isNotPass(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageStartCond::VT_ISNOTPASS, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageStartCond<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageStartCond_RequireChar>,
                >,
            >>("requireChars", Self::VT_REQUIRECHARS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("excludeAssists", Self::VT_EXCLUDEASSISTS, false)?
            .visit_field::<bool>("isNotPass", Self::VT_ISNOTPASS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageStartCondArgs<'a> {
    pub requireChars: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageStartCond_RequireChar<'a>>,
            >,
        >,
    >,
    pub excludeAssists: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub isNotPass: bool,
}
impl<'a> Default for clz_Torappu_StageStartCondArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageStartCondArgs {
            requireChars: None,
            excludeAssists: None,
            isNotPass: false,
        }
    }
}

impl Serialize for clz_Torappu_StageStartCond<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageStartCond", 3)?;
        if let Some(f) = self.requireChars() {
            s.serialize_field("requireChars", &f)?;
        } else {
            s.skip_field("requireChars")?;
        }
        if let Some(f) = self.excludeAssists() {
            s.serialize_field("excludeAssists", &f)?;
        } else {
            s.skip_field("excludeAssists")?;
        }
        s.serialize_field("isNotPass", &self.isNotPass())?;
        s.end()
    }
}

pub struct clz_Torappu_StageStartCondBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_StageStartCondBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_requireChars(
        &mut self,
        requireChars: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageStartCond_RequireChar<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageStartCond::VT_REQUIRECHARS,
            requireChars,
        );
    }
    #[inline]
    pub fn add_excludeAssists(
        &mut self,
        excludeAssists: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageStartCond::VT_EXCLUDEASSISTS,
            excludeAssists,
        );
    }
    #[inline]
    pub fn add_isNotPass(&mut self, isNotPass: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageStartCond::VT_ISNOTPASS, isNotPass, false);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageStartCondBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageStartCondBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageStartCond<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageStartCond<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageStartCond");
        ds.field("requireChars", &self.requireChars());
        ds.field("excludeAssists", &self.excludeAssists());
        ds.field("isNotPass", &self.isNotPass());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageStartCondT {
    pub requireChars: Option<Vec<clz_Torappu_StageStartCond_RequireCharT>>,
    pub excludeAssists: Option<Vec<String>>,
    pub isNotPass: bool,
}
impl Default for clz_Torappu_StageStartCondT {
    fn default() -> Self {
        Self {
            requireChars: None,
            excludeAssists: None,
            isNotPass: false,
        }
    }
}
impl clz_Torappu_StageStartCondT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageStartCond<'b>> {
        let requireChars = self.requireChars.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let excludeAssists = self.excludeAssists.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let isNotPass = self.isNotPass;
        clz_Torappu_StageStartCond::create(
            _fbb,
            &clz_Torappu_StageStartCondArgs {
                requireChars,
                excludeAssists,
                isNotPass,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_StageStartCondOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_StageStartCond<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_StageStartCond<'a> {
    type Inner = dict__string__clz_Torappu_StageStartCond<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_StageStartCond<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_StageStartCond { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_StageStartCondArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageStartCond<'bldr>> {
        let mut builder = dict__string__clz_Torappu_StageStartCondBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_StageStartCondT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_StageStartCondT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_StageStartCond::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_StageStartCond) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_StageStartCond<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StageStartCond>>(
                    dict__string__clz_Torappu_StageStartCond::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_StageStartCond<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StageStartCond>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_StageStartCondArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_StageStartCond<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_StageStartCondArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_StageStartCondArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_StageStartCond<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_StageStartCond", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_StageStartCondBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_StageStartCondBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_StageStartCond::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_StageStartCond<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StageStartCond>>(
                dict__string__clz_Torappu_StageStartCond::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_StageStartCondBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_StageStartCondBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageStartCond<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_StageStartCond::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_StageStartCond<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_StageStartCond");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_StageStartCondT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_StageStartCondT>>,
}
impl Default for dict__string__clz_Torappu_StageStartCondT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_StageStartCondT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageStartCond<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_StageStartCond::create(
            _fbb,
            &dict__string__clz_Torappu_StageStartCondArgs { key, value },
        )
    }
}
pub enum clz_Torappu_StageDiffGroupTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageDiffGroupTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageDiffGroupTable<'a> {
    type Inner = clz_Torappu_StageDiffGroupTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageDiffGroupTable<'a> {
    pub const VT_NORMALID: flatbuffers::VOffsetT = 4;
    pub const VT_TOUGHID: flatbuffers::VOffsetT = 6;
    pub const VT_EASYID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageDiffGroupTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageDiffGroupTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageDiffGroupTable<'bldr>> {
        let mut builder = clz_Torappu_StageDiffGroupTableBuilder::new(_fbb);
        if let Some(x) = args.easyId {
            builder.add_easyId(x);
        }
        if let Some(x) = args.toughId {
            builder.add_toughId(x);
        }
        if let Some(x) = args.normalId {
            builder.add_normalId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageDiffGroupTableT {
        let normalId = self.normalId().map(|x| x.to_string());
        let toughId = self.toughId().map(|x| x.to_string());
        let easyId = self.easyId().map(|x| x.to_string());
        clz_Torappu_StageDiffGroupTableT {
            normalId,
            toughId,
            easyId,
        }
    }

    #[inline]
    pub fn normalId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageDiffGroupTable::VT_NORMALID,
                None,
            )
        }
    }
    #[inline]
    pub fn toughId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageDiffGroupTable::VT_TOUGHID,
                None,
            )
        }
    }
    #[inline]
    pub fn easyId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageDiffGroupTable::VT_EASYID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageDiffGroupTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "normalId",
                Self::VT_NORMALID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("toughId", Self::VT_TOUGHID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("easyId", Self::VT_EASYID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageDiffGroupTableArgs<'a> {
    pub normalId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub toughId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub easyId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_StageDiffGroupTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageDiffGroupTableArgs {
            normalId: None,
            toughId: None,
            easyId: None,
        }
    }
}

impl Serialize for clz_Torappu_StageDiffGroupTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageDiffGroupTable", 3)?;
        if let Some(f) = self.normalId() {
            s.serialize_field("normalId", &f)?;
        } else {
            s.skip_field("normalId")?;
        }
        if let Some(f) = self.toughId() {
            s.serialize_field("toughId", &f)?;
        } else {
            s.skip_field("toughId")?;
        }
        if let Some(f) = self.easyId() {
            s.serialize_field("easyId", &f)?;
        } else {
            s.skip_field("easyId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StageDiffGroupTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_StageDiffGroupTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_normalId(&mut self, normalId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageDiffGroupTable::VT_NORMALID,
            normalId,
        );
    }
    #[inline]
    pub fn add_toughId(&mut self, toughId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageDiffGroupTable::VT_TOUGHID,
            toughId,
        );
    }
    #[inline]
    pub fn add_easyId(&mut self, easyId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageDiffGroupTable::VT_EASYID,
            easyId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageDiffGroupTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageDiffGroupTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageDiffGroupTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageDiffGroupTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageDiffGroupTable");
        ds.field("normalId", &self.normalId());
        ds.field("toughId", &self.toughId());
        ds.field("easyId", &self.easyId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageDiffGroupTableT {
    pub normalId: Option<String>,
    pub toughId: Option<String>,
    pub easyId: Option<String>,
}
impl Default for clz_Torappu_StageDiffGroupTableT {
    fn default() -> Self {
        Self {
            normalId: None,
            toughId: None,
            easyId: None,
        }
    }
}
impl clz_Torappu_StageDiffGroupTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageDiffGroupTable<'b>> {
        let normalId = self.normalId.as_ref().map(|x| _fbb.create_string(x));
        let toughId = self.toughId.as_ref().map(|x| _fbb.create_string(x));
        let easyId = self.easyId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_StageDiffGroupTable::create(
            _fbb,
            &clz_Torappu_StageDiffGroupTableArgs {
                normalId,
                toughId,
                easyId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_StageDiffGroupTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_StageDiffGroupTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_StageDiffGroupTable<'a> {
    type Inner = dict__string__clz_Torappu_StageDiffGroupTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_StageDiffGroupTable<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_StageDiffGroupTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_StageDiffGroupTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageDiffGroupTable<'bldr>> {
        let mut builder = dict__string__clz_Torappu_StageDiffGroupTableBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_StageDiffGroupTableT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_StageDiffGroupTableT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_StageDiffGroupTable::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_StageDiffGroupTable) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_StageDiffGroupTable<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StageDiffGroupTable>>(
                    dict__string__clz_Torappu_StageDiffGroupTable::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_StageDiffGroupTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StageDiffGroupTable>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_StageDiffGroupTableArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_StageDiffGroupTable<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_StageDiffGroupTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_StageDiffGroupTableArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_StageDiffGroupTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_StageDiffGroupTable", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_StageDiffGroupTableBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_StageDiffGroupTableBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_StageDiffGroupTable::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_StageDiffGroupTable<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StageDiffGroupTable>>(
                dict__string__clz_Torappu_StageDiffGroupTable::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_StageDiffGroupTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_StageDiffGroupTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageDiffGroupTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_StageDiffGroupTable::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_StageDiffGroupTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_StageDiffGroupTable");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_StageDiffGroupTableT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_StageDiffGroupTableT>>,
}
impl Default for dict__string__clz_Torappu_StageDiffGroupTableT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_StageDiffGroupTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageDiffGroupTable<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_StageDiffGroupTable::create(
            _fbb,
            &dict__string__clz_Torappu_StageDiffGroupTableArgs { key, value },
        )
    }
}
pub enum clz_Torappu_StoryStageShowGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StoryStageShowGroup<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StoryStageShowGroup<'a> {
    type Inner = clz_Torappu_StoryStageShowGroup<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StoryStageShowGroup<'a> {
    pub const VT_DISPLAYRECORDID: flatbuffers::VOffsetT = 4;
    pub const VT_STAGEID: flatbuffers::VOffsetT = 6;
    pub const VT_ACCORDINGSTAGEID: flatbuffers::VOffsetT = 8;
    pub const VT_DIFFGROUP: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StoryStageShowGroup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StoryStageShowGroupArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StoryStageShowGroup<'bldr>> {
        let mut builder = clz_Torappu_StoryStageShowGroupBuilder::new(_fbb);
        builder.add_diffGroup(args.diffGroup);
        if let Some(x) = args.accordingStageId {
            builder.add_accordingStageId(x);
        }
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        if let Some(x) = args.displayRecordId {
            builder.add_displayRecordId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StoryStageShowGroupT {
        let displayRecordId = self.displayRecordId().map(|x| x.to_string());
        let stageId = self.stageId().map(|x| x.to_string());
        let accordingStageId = self.accordingStageId().map(|x| x.to_string());
        let diffGroup = self.diffGroup();
        clz_Torappu_StoryStageShowGroupT {
            displayRecordId,
            stageId,
            accordingStageId,
            diffGroup,
        }
    }

    #[inline]
    pub fn displayRecordId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StoryStageShowGroup::VT_DISPLAYRECORDID,
                None,
            )
        }
    }
    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StoryStageShowGroup::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn accordingStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StoryStageShowGroup::VT_ACCORDINGSTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn diffGroup(&self) -> enum__Torappu_StageDiffGroup {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDiffGroup>(
                    clz_Torappu_StoryStageShowGroup::VT_DIFFGROUP,
                    Some(enum__Torappu_StageDiffGroup::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StoryStageShowGroup<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "displayRecordId",
                Self::VT_DISPLAYRECORDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "accordingStageId",
                Self::VT_ACCORDINGSTAGEID,
                false,
            )?
            .visit_field::<enum__Torappu_StageDiffGroup>("diffGroup", Self::VT_DIFFGROUP, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StoryStageShowGroupArgs<'a> {
    pub displayRecordId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub accordingStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub diffGroup: enum__Torappu_StageDiffGroup,
}
impl<'a> Default for clz_Torappu_StoryStageShowGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StoryStageShowGroupArgs {
            displayRecordId: None,
            stageId: None,
            accordingStageId: None,
            diffGroup: enum__Torappu_StageDiffGroup::NONE,
        }
    }
}

impl Serialize for clz_Torappu_StoryStageShowGroup<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StoryStageShowGroup", 4)?;
        if let Some(f) = self.displayRecordId() {
            s.serialize_field("displayRecordId", &f)?;
        } else {
            s.skip_field("displayRecordId")?;
        }
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        if let Some(f) = self.accordingStageId() {
            s.serialize_field("accordingStageId", &f)?;
        } else {
            s.skip_field("accordingStageId")?;
        }
        s.serialize_field("diffGroup", &self.diffGroup())?;
        s.end()
    }
}

pub struct clz_Torappu_StoryStageShowGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_StoryStageShowGroupBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_displayRecordId(&mut self, displayRecordId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StoryStageShowGroup::VT_DISPLAYRECORDID,
            displayRecordId,
        );
    }
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StoryStageShowGroup::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_accordingStageId(&mut self, accordingStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StoryStageShowGroup::VT_ACCORDINGSTAGEID,
            accordingStageId,
        );
    }
    #[inline]
    pub fn add_diffGroup(&mut self, diffGroup: enum__Torappu_StageDiffGroup) {
        self.fbb_.push_slot::<enum__Torappu_StageDiffGroup>(
            clz_Torappu_StoryStageShowGroup::VT_DIFFGROUP,
            diffGroup,
            enum__Torappu_StageDiffGroup::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StoryStageShowGroupBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StoryStageShowGroupBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StoryStageShowGroup<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StoryStageShowGroup<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StoryStageShowGroup");
        ds.field("displayRecordId", &self.displayRecordId());
        ds.field("stageId", &self.stageId());
        ds.field("accordingStageId", &self.accordingStageId());
        ds.field("diffGroup", &self.diffGroup());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StoryStageShowGroupT {
    pub displayRecordId: Option<String>,
    pub stageId: Option<String>,
    pub accordingStageId: Option<String>,
    pub diffGroup: enum__Torappu_StageDiffGroup,
}
impl Default for clz_Torappu_StoryStageShowGroupT {
    fn default() -> Self {
        Self {
            displayRecordId: None,
            stageId: None,
            accordingStageId: None,
            diffGroup: enum__Torappu_StageDiffGroup::NONE,
        }
    }
}
impl clz_Torappu_StoryStageShowGroupT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StoryStageShowGroup<'b>> {
        let displayRecordId = self.displayRecordId.as_ref().map(|x| _fbb.create_string(x));
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let accordingStageId = self
            .accordingStageId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let diffGroup = self.diffGroup;
        clz_Torappu_StoryStageShowGroup::create(
            _fbb,
            &clz_Torappu_StoryStageShowGroupArgs {
                displayRecordId,
                stageId,
                accordingStageId,
                diffGroup,
            },
        )
    }
}
pub enum dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'a>
{
    type Inner = dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'bldr>,
    > {
        let mut builder =
            dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupT {
        let key = self.key();
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupT { key, value }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_StageDiffGroup {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDiffGroup>(
                    dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup::VT_KEY,
                    Some(enum__Torappu_StageDiffGroup::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_StageDiffGroup,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_StoryStageShowGroup<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StoryStageShowGroup>>(
                    dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_StageDiffGroup>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StoryStageShowGroup>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupArgs<'a> {
    pub key: enum__Torappu_StageDiffGroup,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_StoryStageShowGroup<'a>>>,
}
impl<'a> Default for dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupArgs {
            key: enum__Torappu_StageDiffGroup::NONE,
            value: None,
        }
    }
}

impl Serialize for dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_StageDiffGroup) {
        self.fbb_.push_slot::<enum__Torappu_StageDiffGroup>(
            dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup::VT_KEY,
            key,
            enum__Torappu_StageDiffGroup::NONE,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_StoryStageShowGroup<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StoryStageShowGroup>>(
                dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupT {
    pub key: enum__Torappu_StageDiffGroup,
    pub value: Option<Box<clz_Torappu_StoryStageShowGroupT>>,
}
impl Default for dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupT {
    fn default() -> Self {
        Self {
            key: enum__Torappu_StageDiffGroup::NONE,
            value: None,
        }
    }
}
impl dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'b>,
    > {
        let key = self.key;
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup::create(
            _fbb,
            &dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupArgs { key, value },
        )
    }
}
pub enum dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupOffset
{}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<
    'a,
> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'a>
{
    type Inner =
        dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a>
    dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'a>
{
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<
            'bldr,
        >,
    > {
        let mut builder = dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(
        &self,
    ) -> dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupT
    {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupT {
            key,
            value,
        }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup::VT_KEY, None).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup>>>>(dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup,
                    >,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupArgs<
    'a,
> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default
    for dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupArgs<
        'a,
    >
{
    #[inline]
    fn default() -> Self {
        dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize
    for dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'_>
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupBuilder<
        'a,
        'b,
        A,
    >
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup::VT_VALUE, value);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupBuilder<'a, 'b, A>{
        let start = _fbb.start_table();
        dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupBuilder {
      fbb_: _fbb,
      start_: start,
    }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup::VT_KEY,"key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupT {
    pub key: String,
    pub value: Option<Vec<dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupT>>,
}
impl Default
    for dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupT
{
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'b>,
    > {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup::create(_fbb, &dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupArgs{
      key,
      value,
    })
    }
}
pub enum clz_Torappu_SpecialBattleFinishStageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialBattleFinishStageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialBattleFinishStageData<'a> {
    type Inner = clz_Torappu_SpecialBattleFinishStageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialBattleFinishStageData<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_SKIPACCOMPLISHPERFORM: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialBattleFinishStageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialBattleFinishStageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialBattleFinishStageData<'bldr>> {
        let mut builder = clz_Torappu_SpecialBattleFinishStageDataBuilder::new(_fbb);
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.add_skipAccomplishPerform(args.skipAccomplishPerform);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialBattleFinishStageDataT {
        let stageId = self.stageId().map(|x| x.to_string());
        let skipAccomplishPerform = self.skipAccomplishPerform();
        clz_Torappu_SpecialBattleFinishStageDataT {
            stageId,
            skipAccomplishPerform,
        }
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialBattleFinishStageData::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn skipAccomplishPerform(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_SpecialBattleFinishStageData::VT_SKIPACCOMPLISHPERFORM,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialBattleFinishStageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<bool>(
                "skipAccomplishPerform",
                Self::VT_SKIPACCOMPLISHPERFORM,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialBattleFinishStageDataArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub skipAccomplishPerform: bool,
}
impl<'a> Default for clz_Torappu_SpecialBattleFinishStageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialBattleFinishStageDataArgs {
            stageId: None,
            skipAccomplishPerform: false,
        }
    }
}

impl Serialize for clz_Torappu_SpecialBattleFinishStageData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SpecialBattleFinishStageData", 2)?;
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        s.serialize_field("skipAccomplishPerform", &self.skipAccomplishPerform())?;
        s.end()
    }
}

pub struct clz_Torappu_SpecialBattleFinishStageDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialBattleFinishStageDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialBattleFinishStageData::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_skipAccomplishPerform(&mut self, skipAccomplishPerform: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SpecialBattleFinishStageData::VT_SKIPACCOMPLISHPERFORM,
            skipAccomplishPerform,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialBattleFinishStageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialBattleFinishStageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SpecialBattleFinishStageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialBattleFinishStageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialBattleFinishStageData");
        ds.field("stageId", &self.stageId());
        ds.field("skipAccomplishPerform", &self.skipAccomplishPerform());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialBattleFinishStageDataT {
    pub stageId: Option<String>,
    pub skipAccomplishPerform: bool,
}
impl Default for clz_Torappu_SpecialBattleFinishStageDataT {
    fn default() -> Self {
        Self {
            stageId: None,
            skipAccomplishPerform: false,
        }
    }
}
impl clz_Torappu_SpecialBattleFinishStageDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialBattleFinishStageData<'b>> {
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let skipAccomplishPerform = self.skipAccomplishPerform;
        clz_Torappu_SpecialBattleFinishStageData::create(
            _fbb,
            &clz_Torappu_SpecialBattleFinishStageDataArgs {
                stageId,
                skipAccomplishPerform,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialBattleFinishStageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialBattleFinishStageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SpecialBattleFinishStageData<'a> {
    type Inner = dict__string__clz_Torappu_SpecialBattleFinishStageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialBattleFinishStageData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialBattleFinishStageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialBattleFinishStageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialBattleFinishStageData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SpecialBattleFinishStageDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialBattleFinishStageDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialBattleFinishStageDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialBattleFinishStageData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialBattleFinishStageData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialBattleFinishStageData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialBattleFinishStageData>>(
                    dict__string__clz_Torappu_SpecialBattleFinishStageData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialBattleFinishStageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialBattleFinishStageData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialBattleFinishStageDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialBattleFinishStageData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialBattleFinishStageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialBattleFinishStageDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialBattleFinishStageData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SpecialBattleFinishStageData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialBattleFinishStageDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialBattleFinishStageDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialBattleFinishStageData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialBattleFinishStageData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialBattleFinishStageData>>(
                dict__string__clz_Torappu_SpecialBattleFinishStageData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialBattleFinishStageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialBattleFinishStageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialBattleFinishStageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialBattleFinishStageData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialBattleFinishStageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SpecialBattleFinishStageData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialBattleFinishStageDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialBattleFinishStageDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialBattleFinishStageDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialBattleFinishStageDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialBattleFinishStageData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialBattleFinishStageData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialBattleFinishStageDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RecordRewardServerDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RecordRewardServerData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RecordRewardServerData<'a> {
    type Inner = clz_Torappu_RecordRewardServerData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RecordRewardServerData<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_REWARDS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RecordRewardServerData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RecordRewardServerDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RecordRewardServerData<'bldr>> {
        let mut builder = clz_Torappu_RecordRewardServerDataBuilder::new(_fbb);
        if let Some(x) = args.rewards {
            builder.add_rewards(x);
        }
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RecordRewardServerDataT {
        let stageId = self.stageId().map(|x| x.to_string());
        let rewards = self
            .rewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RecordRewardServerDataT { stageId, rewards }
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RecordRewardServerData::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn rewards(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_RecordRewardServerData::VT_REWARDS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RecordRewardServerData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("rewards", Self::VT_REWARDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RecordRewardServerDataArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RecordRewardServerDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RecordRewardServerDataArgs {
            stageId: None,
            rewards: None,
        }
    }
}

impl Serialize for clz_Torappu_RecordRewardServerData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RecordRewardServerData", 2)?;
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        if let Some(f) = self.rewards() {
            s.serialize_field("rewards", &f)?;
        } else {
            s.skip_field("rewards")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RecordRewardServerDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RecordRewardServerDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RecordRewardServerData::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_rewards(
        &mut self,
        rewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RecordRewardServerData::VT_REWARDS,
            rewards,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RecordRewardServerDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RecordRewardServerDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RecordRewardServerData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RecordRewardServerData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RecordRewardServerData");
        ds.field("stageId", &self.stageId());
        ds.field("rewards", &self.rewards());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RecordRewardServerDataT {
    pub stageId: Option<String>,
    pub rewards: Option<Vec<clz_Torappu_ItemBundleT>>,
}
impl Default for clz_Torappu_RecordRewardServerDataT {
    fn default() -> Self {
        Self {
            stageId: None,
            rewards: None,
        }
    }
}
impl clz_Torappu_RecordRewardServerDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RecordRewardServerData<'b>> {
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let rewards = self.rewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RecordRewardServerData::create(
            _fbb,
            &clz_Torappu_RecordRewardServerDataArgs { stageId, rewards },
        )
    }
}
pub enum dict__string__clz_Torappu_RecordRewardServerDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RecordRewardServerData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RecordRewardServerData<'a> {
    type Inner = dict__string__clz_Torappu_RecordRewardServerData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RecordRewardServerData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RecordRewardServerData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RecordRewardServerDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RecordRewardServerData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RecordRewardServerDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RecordRewardServerDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RecordRewardServerDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RecordRewardServerData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RecordRewardServerData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RecordRewardServerData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RecordRewardServerData>>(
                    dict__string__clz_Torappu_RecordRewardServerData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RecordRewardServerData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RecordRewardServerData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RecordRewardServerDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RecordRewardServerData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RecordRewardServerDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RecordRewardServerDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RecordRewardServerData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RecordRewardServerData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RecordRewardServerDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RecordRewardServerDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RecordRewardServerData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RecordRewardServerData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RecordRewardServerData>>(
                dict__string__clz_Torappu_RecordRewardServerData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RecordRewardServerDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RecordRewardServerDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RecordRewardServerData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RecordRewardServerData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RecordRewardServerData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RecordRewardServerData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RecordRewardServerDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RecordRewardServerDataT>>,
}
impl Default for dict__string__clz_Torappu_RecordRewardServerDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RecordRewardServerDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RecordRewardServerData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RecordRewardServerData::create(
            _fbb,
            &dict__string__clz_Torappu_RecordRewardServerDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ApProtectZoneInfo_TimeRangeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ApProtectZoneInfo_TimeRange<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ApProtectZoneInfo_TimeRange<'a> {
    type Inner = clz_Torappu_ApProtectZoneInfo_TimeRange<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ApProtectZoneInfo_TimeRange<'a> {
    pub const VT_STARTTS: flatbuffers::VOffsetT = 4;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ApProtectZoneInfo_TimeRange { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ApProtectZoneInfo_TimeRangeArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ApProtectZoneInfo_TimeRange<'bldr>> {
        let mut builder = clz_Torappu_ApProtectZoneInfo_TimeRangeBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ApProtectZoneInfo_TimeRangeT {
        let startTs = self.startTs();
        let endTs = self.endTs();
        clz_Torappu_ApProtectZoneInfo_TimeRangeT { startTs, endTs }
    }

    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_ApProtectZoneInfo_TimeRange::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_ApProtectZoneInfo_TimeRange::VT_ENDTS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ApProtectZoneInfo_TimeRange<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ApProtectZoneInfo_TimeRangeArgs {
    pub startTs: i64,
    pub endTs: i64,
}
impl<'a> Default for clz_Torappu_ApProtectZoneInfo_TimeRangeArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ApProtectZoneInfo_TimeRangeArgs {
            startTs: 0,
            endTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_ApProtectZoneInfo_TimeRange<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ApProtectZoneInfo_TimeRange", 2)?;
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        s.end()
    }
}

pub struct clz_Torappu_ApProtectZoneInfo_TimeRangeBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ApProtectZoneInfo_TimeRangeBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_ApProtectZoneInfo_TimeRange::VT_STARTTS,
            startTs,
            0,
        );
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_ApProtectZoneInfo_TimeRange::VT_ENDTS, endTs, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ApProtectZoneInfo_TimeRangeBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ApProtectZoneInfo_TimeRangeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ApProtectZoneInfo_TimeRange<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ApProtectZoneInfo_TimeRange<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ApProtectZoneInfo_TimeRange");
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ApProtectZoneInfo_TimeRangeT {
    pub startTs: i64,
    pub endTs: i64,
}
impl Default for clz_Torappu_ApProtectZoneInfo_TimeRangeT {
    fn default() -> Self {
        Self {
            startTs: 0,
            endTs: 0,
        }
    }
}
impl clz_Torappu_ApProtectZoneInfo_TimeRangeT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ApProtectZoneInfo_TimeRange<'b>> {
        let startTs = self.startTs;
        let endTs = self.endTs;
        clz_Torappu_ApProtectZoneInfo_TimeRange::create(
            _fbb,
            &clz_Torappu_ApProtectZoneInfo_TimeRangeArgs { startTs, endTs },
        )
    }
}
pub enum clz_Torappu_ApProtectZoneInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ApProtectZoneInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ApProtectZoneInfo<'a> {
    type Inner = clz_Torappu_ApProtectZoneInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ApProtectZoneInfo<'a> {
    pub const VT_ZONEID: flatbuffers::VOffsetT = 4;
    pub const VT_TIMERANGES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ApProtectZoneInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ApProtectZoneInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ApProtectZoneInfo<'bldr>> {
        let mut builder = clz_Torappu_ApProtectZoneInfoBuilder::new(_fbb);
        if let Some(x) = args.timeRanges {
            builder.add_timeRanges(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ApProtectZoneInfoT {
        let zoneId = self.zoneId().map(|x| x.to_string());
        let timeRanges = self
            .timeRanges()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ApProtectZoneInfoT { zoneId, timeRanges }
    }

    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ApProtectZoneInfo::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn timeRanges(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_ApProtectZoneInfo_TimeRange<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ApProtectZoneInfo_TimeRange>,
                >,
            >>(clz_Torappu_ApProtectZoneInfo::VT_TIMERANGES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ApProtectZoneInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ApProtectZoneInfo_TimeRange>,
                >,
            >>("timeRanges", Self::VT_TIMERANGES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ApProtectZoneInfoArgs<'a> {
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timeRanges: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ApProtectZoneInfo_TimeRange<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ApProtectZoneInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ApProtectZoneInfoArgs {
            zoneId: None,
            timeRanges: None,
        }
    }
}

impl Serialize for clz_Torappu_ApProtectZoneInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ApProtectZoneInfo", 2)?;
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.timeRanges() {
            s.serialize_field("timeRanges", &f)?;
        } else {
            s.skip_field("timeRanges")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ApProtectZoneInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ApProtectZoneInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ApProtectZoneInfo::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_timeRanges(
        &mut self,
        timeRanges: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ApProtectZoneInfo_TimeRange<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ApProtectZoneInfo::VT_TIMERANGES,
            timeRanges,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ApProtectZoneInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ApProtectZoneInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ApProtectZoneInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ApProtectZoneInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ApProtectZoneInfo");
        ds.field("zoneId", &self.zoneId());
        ds.field("timeRanges", &self.timeRanges());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ApProtectZoneInfoT {
    pub zoneId: Option<String>,
    pub timeRanges: Option<Vec<clz_Torappu_ApProtectZoneInfo_TimeRangeT>>,
}
impl Default for clz_Torappu_ApProtectZoneInfoT {
    fn default() -> Self {
        Self {
            zoneId: None,
            timeRanges: None,
        }
    }
}
impl clz_Torappu_ApProtectZoneInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ApProtectZoneInfo<'b>> {
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let timeRanges = self.timeRanges.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ApProtectZoneInfo::create(
            _fbb,
            &clz_Torappu_ApProtectZoneInfoArgs { zoneId, timeRanges },
        )
    }
}
pub enum dict__string__clz_Torappu_ApProtectZoneInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ApProtectZoneInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ApProtectZoneInfo<'a> {
    type Inner = dict__string__clz_Torappu_ApProtectZoneInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ApProtectZoneInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ApProtectZoneInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ApProtectZoneInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ApProtectZoneInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ApProtectZoneInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ApProtectZoneInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ApProtectZoneInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ApProtectZoneInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_ApProtectZoneInfo) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ApProtectZoneInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ApProtectZoneInfo>>(
                    dict__string__clz_Torappu_ApProtectZoneInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ApProtectZoneInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ApProtectZoneInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ApProtectZoneInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ApProtectZoneInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ApProtectZoneInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ApProtectZoneInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ApProtectZoneInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ApProtectZoneInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ApProtectZoneInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ApProtectZoneInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ApProtectZoneInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_ApProtectZoneInfo<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ApProtectZoneInfo>>(
                dict__string__clz_Torappu_ApProtectZoneInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ApProtectZoneInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ApProtectZoneInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ApProtectZoneInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ApProtectZoneInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ApProtectZoneInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ApProtectZoneInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ApProtectZoneInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ApProtectZoneInfoT>>,
}
impl Default for dict__string__clz_Torappu_ApProtectZoneInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ApProtectZoneInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ApProtectZoneInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ApProtectZoneInfo::create(
            _fbb,
            &dict__string__clz_Torappu_ApProtectZoneInfoArgs { key, value },
        )
    }
}
pub enum dict__string__list_stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_string<'a> {
    type Inner = dict__string__list_string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__list_string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_string<'bldr>> {
        let mut builder = dict__string__list_stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__list_stringT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self
            .value()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        dict__string__list_stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__list_string::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__list_string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(dict__string__list_string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for dict__string__list_stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__list_string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__list_string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__list_stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__list_stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__list_string::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__list_string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__list_string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_stringT {
    pub key: String,
    pub value: Option<Vec<String>>,
}
impl Default for dict__string__list_stringT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__list_string<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_string::create(_fbb, &dict__string__list_stringArgs { key, value })
    }
}
pub enum clz_Torappu_ActCustomStageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActCustomStageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActCustomStageData<'a> {
    type Inner = clz_Torappu_ActCustomStageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActCustomStageData<'a> {
    pub const VT_OVERRIDEGAMEMODE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActCustomStageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActCustomStageDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActCustomStageData<'bldr>> {
        let mut builder = clz_Torappu_ActCustomStageDataBuilder::new(_fbb);
        builder.add_overrideGameMode(args.overrideGameMode);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActCustomStageDataT {
        let overrideGameMode = self.overrideGameMode();
        clz_Torappu_ActCustomStageDataT { overrideGameMode }
    }

    #[inline]
    pub fn overrideGameMode(&self) -> enum__Torappu_OverrideGameMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_OverrideGameMode>(
                    clz_Torappu_ActCustomStageData::VT_OVERRIDEGAMEMODE,
                    Some(enum__Torappu_OverrideGameMode::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActCustomStageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_OverrideGameMode>(
                "overrideGameMode",
                Self::VT_OVERRIDEGAMEMODE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActCustomStageDataArgs {
    pub overrideGameMode: enum__Torappu_OverrideGameMode,
}
impl<'a> Default for clz_Torappu_ActCustomStageDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActCustomStageDataArgs {
            overrideGameMode: enum__Torappu_OverrideGameMode::NONE,
        }
    }
}

impl Serialize for clz_Torappu_ActCustomStageData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActCustomStageData", 1)?;
        s.serialize_field("overrideGameMode", &self.overrideGameMode())?;
        s.end()
    }
}

pub struct clz_Torappu_ActCustomStageDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ActCustomStageDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_overrideGameMode(&mut self, overrideGameMode: enum__Torappu_OverrideGameMode) {
        self.fbb_.push_slot::<enum__Torappu_OverrideGameMode>(
            clz_Torappu_ActCustomStageData::VT_OVERRIDEGAMEMODE,
            overrideGameMode,
            enum__Torappu_OverrideGameMode::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActCustomStageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActCustomStageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActCustomStageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActCustomStageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActCustomStageData");
        ds.field("overrideGameMode", &self.overrideGameMode());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActCustomStageDataT {
    pub overrideGameMode: enum__Torappu_OverrideGameMode,
}
impl Default for clz_Torappu_ActCustomStageDataT {
    fn default() -> Self {
        Self {
            overrideGameMode: enum__Torappu_OverrideGameMode::NONE,
        }
    }
}
impl clz_Torappu_ActCustomStageDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActCustomStageData<'b>> {
        let overrideGameMode = self.overrideGameMode;
        clz_Torappu_ActCustomStageData::create(
            _fbb,
            &clz_Torappu_ActCustomStageDataArgs { overrideGameMode },
        )
    }
}
pub enum dict__string__clz_Torappu_ActCustomStageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActCustomStageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActCustomStageData<'a> {
    type Inner = dict__string__clz_Torappu_ActCustomStageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActCustomStageData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActCustomStageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActCustomStageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActCustomStageData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActCustomStageDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActCustomStageDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActCustomStageDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActCustomStageData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_ActCustomStageData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActCustomStageData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActCustomStageData>>(
                    dict__string__clz_Torappu_ActCustomStageData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActCustomStageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActCustomStageData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActCustomStageDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActCustomStageData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActCustomStageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActCustomStageDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActCustomStageData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ActCustomStageData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActCustomStageDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActCustomStageDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActCustomStageData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_ActCustomStageData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActCustomStageData>>(
                dict__string__clz_Torappu_ActCustomStageData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActCustomStageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActCustomStageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActCustomStageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActCustomStageData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActCustomStageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActCustomStageData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActCustomStageDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActCustomStageDataT>>,
}
impl Default for dict__string__clz_Torappu_ActCustomStageDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActCustomStageDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActCustomStageData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActCustomStageData::create(
            _fbb,
            &dict__string__clz_Torappu_ActCustomStageDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_StorylineMainlineSplitDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StorylineMainlineSplitData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StorylineMainlineSplitData<'a> {
    type Inner = clz_Torappu_StorylineMainlineSplitData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StorylineMainlineSplitData<'a> {
    pub const VT_ICONID: flatbuffers::VOffsetT = 4;
    pub const VT_SUBNAME: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StorylineMainlineSplitData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StorylineMainlineSplitDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineMainlineSplitData<'bldr>> {
        let mut builder = clz_Torappu_StorylineMainlineSplitDataBuilder::new(_fbb);
        if let Some(x) = args.subName {
            builder.add_subName(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StorylineMainlineSplitDataT {
        let iconId = self.iconId().map(|x| x.to_string());
        let subName = self.subName().map(|x| x.to_string());
        clz_Torappu_StorylineMainlineSplitDataT { iconId, subName }
    }

    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineMainlineSplitData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn subName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineMainlineSplitData::VT_SUBNAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StorylineMainlineSplitData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subName", Self::VT_SUBNAME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StorylineMainlineSplitDataArgs<'a> {
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subName: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_StorylineMainlineSplitDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StorylineMainlineSplitDataArgs {
            iconId: None,
            subName: None,
        }
    }
}

impl Serialize for clz_Torappu_StorylineMainlineSplitData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StorylineMainlineSplitData", 2)?;
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.subName() {
            s.serialize_field("subName", &f)?;
        } else {
            s.skip_field("subName")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StorylineMainlineSplitDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StorylineMainlineSplitDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineMainlineSplitData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_subName(&mut self, subName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineMainlineSplitData::VT_SUBNAME,
            subName,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StorylineMainlineSplitDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StorylineMainlineSplitDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StorylineMainlineSplitData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StorylineMainlineSplitData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StorylineMainlineSplitData");
        ds.field("iconId", &self.iconId());
        ds.field("subName", &self.subName());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StorylineMainlineSplitDataT {
    pub iconId: Option<String>,
    pub subName: Option<String>,
}
impl Default for clz_Torappu_StorylineMainlineSplitDataT {
    fn default() -> Self {
        Self {
            iconId: None,
            subName: None,
        }
    }
}
impl clz_Torappu_StorylineMainlineSplitDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineMainlineSplitData<'b>> {
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let subName = self.subName.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_StorylineMainlineSplitData::create(
            _fbb,
            &clz_Torappu_StorylineMainlineSplitDataArgs { iconId, subName },
        )
    }
}
pub enum clz_Torappu_StorylineLocationDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StorylineLocationData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StorylineLocationData<'a> {
    type Inner = clz_Torappu_StorylineLocationData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StorylineLocationData<'a> {
    pub const VT_LOCATIONID: flatbuffers::VOffsetT = 4;
    pub const VT_LOCATIONTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 10;
    pub const VT_PRESENTSTAGEID: flatbuffers::VOffsetT = 12;
    pub const VT_UNLOCKSTAGEID: flatbuffers::VOffsetT = 14;
    pub const VT_RELEVANTSTORYSETID: flatbuffers::VOffsetT = 16;
    pub const VT_MAINLINESPLITDATA: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StorylineLocationData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StorylineLocationDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineLocationData<'bldr>> {
        let mut builder = clz_Torappu_StorylineLocationDataBuilder::new(_fbb);
        builder.add_startTime(args.startTime);
        if let Some(x) = args.mainlineSplitData {
            builder.add_mainlineSplitData(x);
        }
        if let Some(x) = args.relevantStorySetId {
            builder.add_relevantStorySetId(x);
        }
        if let Some(x) = args.unlockStageId {
            builder.add_unlockStageId(x);
        }
        if let Some(x) = args.presentStageId {
            builder.add_presentStageId(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_locationType(args.locationType);
        if let Some(x) = args.locationId {
            builder.add_locationId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StorylineLocationDataT {
        let locationId = self.locationId().map(|x| x.to_string());
        let locationType = self.locationType();
        let sortId = self.sortId();
        let startTime = self.startTime();
        let presentStageId = self.presentStageId().map(|x| x.to_string());
        let unlockStageId = self.unlockStageId().map(|x| x.to_string());
        let relevantStorySetId = self.relevantStorySetId().map(|x| x.to_string());
        let mainlineSplitData = self.mainlineSplitData().map(|x| Box::new(x.unpack()));
        clz_Torappu_StorylineLocationDataT {
            locationId,
            locationType,
            sortId,
            startTime,
            presentStageId,
            unlockStageId,
            relevantStorySetId,
            mainlineSplitData,
        }
    }

    #[inline]
    pub fn locationId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineLocationData::VT_LOCATIONID,
                None,
            )
        }
    }
    #[inline]
    pub fn locationType(&self) -> enum__Torappu_StorylineLocationType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StorylineLocationType>(
                    clz_Torappu_StorylineLocationData::VT_LOCATIONTYPE,
                    Some(enum__Torappu_StorylineLocationType::STORY_SET),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StorylineLocationData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_StorylineLocationData::VT_STARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn presentStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineLocationData::VT_PRESENTSTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineLocationData::VT_UNLOCKSTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn relevantStorySetId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineLocationData::VT_RELEVANTSTORYSETID,
                None,
            )
        }
    }
    #[inline]
    pub fn mainlineSplitData(&self) -> Option<clz_Torappu_StorylineMainlineSplitData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineMainlineSplitData>>(
                    clz_Torappu_StorylineLocationData::VT_MAINLINESPLITDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StorylineLocationData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "locationId",
                Self::VT_LOCATIONID,
                false,
            )?
            .visit_field::<enum__Torappu_StorylineLocationType>(
                "locationType",
                Self::VT_LOCATIONTYPE,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "presentStageId",
                Self::VT_PRESENTSTAGEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockStageId",
                Self::VT_UNLOCKSTAGEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "relevantStorySetId",
                Self::VT_RELEVANTSTORYSETID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineMainlineSplitData>>(
                "mainlineSplitData",
                Self::VT_MAINLINESPLITDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StorylineLocationDataArgs<'a> {
    pub locationId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub locationType: enum__Torappu_StorylineLocationType,
    pub sortId: i32,
    pub startTime: i64,
    pub presentStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relevantStorySetId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mainlineSplitData:
        Option<flatbuffers::WIPOffset<clz_Torappu_StorylineMainlineSplitData<'a>>>,
}
impl<'a> Default for clz_Torappu_StorylineLocationDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StorylineLocationDataArgs {
            locationId: None,
            locationType: enum__Torappu_StorylineLocationType::STORY_SET,
            sortId: 0,
            startTime: 0,
            presentStageId: None,
            unlockStageId: None,
            relevantStorySetId: None,
            mainlineSplitData: None,
        }
    }
}

impl Serialize for clz_Torappu_StorylineLocationData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StorylineLocationData", 8)?;
        if let Some(f) = self.locationId() {
            s.serialize_field("locationId", &f)?;
        } else {
            s.skip_field("locationId")?;
        }
        s.serialize_field("locationType", &self.locationType())?;
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("startTime", &self.startTime())?;
        if let Some(f) = self.presentStageId() {
            s.serialize_field("presentStageId", &f)?;
        } else {
            s.skip_field("presentStageId")?;
        }
        if let Some(f) = self.unlockStageId() {
            s.serialize_field("unlockStageId", &f)?;
        } else {
            s.skip_field("unlockStageId")?;
        }
        if let Some(f) = self.relevantStorySetId() {
            s.serialize_field("relevantStorySetId", &f)?;
        } else {
            s.skip_field("relevantStorySetId")?;
        }
        if let Some(f) = self.mainlineSplitData() {
            s.serialize_field("mainlineSplitData", &f)?;
        } else {
            s.skip_field("mainlineSplitData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StorylineLocationDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StorylineLocationDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_locationId(&mut self, locationId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineLocationData::VT_LOCATIONID,
            locationId,
        );
    }
    #[inline]
    pub fn add_locationType(&mut self, locationType: enum__Torappu_StorylineLocationType) {
        self.fbb_.push_slot::<enum__Torappu_StorylineLocationType>(
            clz_Torappu_StorylineLocationData::VT_LOCATIONTYPE,
            locationType,
            enum__Torappu_StorylineLocationType::STORY_SET,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StorylineLocationData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_StorylineLocationData::VT_STARTTIME,
            startTime,
            0,
        );
    }
    #[inline]
    pub fn add_presentStageId(&mut self, presentStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineLocationData::VT_PRESENTSTAGEID,
            presentStageId,
        );
    }
    #[inline]
    pub fn add_unlockStageId(&mut self, unlockStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineLocationData::VT_UNLOCKSTAGEID,
            unlockStageId,
        );
    }
    #[inline]
    pub fn add_relevantStorySetId(&mut self, relevantStorySetId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineLocationData::VT_RELEVANTSTORYSETID,
            relevantStorySetId,
        );
    }
    #[inline]
    pub fn add_mainlineSplitData(
        &mut self,
        mainlineSplitData: flatbuffers::WIPOffset<clz_Torappu_StorylineMainlineSplitData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StorylineMainlineSplitData>>(
                clz_Torappu_StorylineLocationData::VT_MAINLINESPLITDATA,
                mainlineSplitData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StorylineLocationDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StorylineLocationDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StorylineLocationData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StorylineLocationData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StorylineLocationData");
        ds.field("locationId", &self.locationId());
        ds.field("locationType", &self.locationType());
        ds.field("sortId", &self.sortId());
        ds.field("startTime", &self.startTime());
        ds.field("presentStageId", &self.presentStageId());
        ds.field("unlockStageId", &self.unlockStageId());
        ds.field("relevantStorySetId", &self.relevantStorySetId());
        ds.field("mainlineSplitData", &self.mainlineSplitData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StorylineLocationDataT {
    pub locationId: Option<String>,
    pub locationType: enum__Torappu_StorylineLocationType,
    pub sortId: i32,
    pub startTime: i64,
    pub presentStageId: Option<String>,
    pub unlockStageId: Option<String>,
    pub relevantStorySetId: Option<String>,
    pub mainlineSplitData: Option<Box<clz_Torappu_StorylineMainlineSplitDataT>>,
}
impl Default for clz_Torappu_StorylineLocationDataT {
    fn default() -> Self {
        Self {
            locationId: None,
            locationType: enum__Torappu_StorylineLocationType::STORY_SET,
            sortId: 0,
            startTime: 0,
            presentStageId: None,
            unlockStageId: None,
            relevantStorySetId: None,
            mainlineSplitData: None,
        }
    }
}
impl clz_Torappu_StorylineLocationDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineLocationData<'b>> {
        let locationId = self.locationId.as_ref().map(|x| _fbb.create_string(x));
        let locationType = self.locationType;
        let sortId = self.sortId;
        let startTime = self.startTime;
        let presentStageId = self.presentStageId.as_ref().map(|x| _fbb.create_string(x));
        let unlockStageId = self.unlockStageId.as_ref().map(|x| _fbb.create_string(x));
        let relevantStorySetId = self
            .relevantStorySetId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let mainlineSplitData = self.mainlineSplitData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_StorylineLocationData::create(
            _fbb,
            &clz_Torappu_StorylineLocationDataArgs {
                locationId,
                locationType,
                sortId,
                startTime,
                presentStageId,
                unlockStageId,
                relevantStorySetId,
                mainlineSplitData,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_StorylineLocationDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_StorylineLocationData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_StorylineLocationData<'a> {
    type Inner = dict__string__clz_Torappu_StorylineLocationData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_StorylineLocationData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_StorylineLocationData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_StorylineLocationDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StorylineLocationData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_StorylineLocationDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_StorylineLocationDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_StorylineLocationDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_StorylineLocationData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_StorylineLocationData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_StorylineLocationData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineLocationData>>(
                    dict__string__clz_Torappu_StorylineLocationData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_StorylineLocationData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineLocationData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_StorylineLocationDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_StorylineLocationData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_StorylineLocationDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_StorylineLocationDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_StorylineLocationData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_StorylineLocationData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_StorylineLocationDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_StorylineLocationDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_StorylineLocationData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_StorylineLocationData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StorylineLocationData>>(
                dict__string__clz_Torappu_StorylineLocationData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_StorylineLocationDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_StorylineLocationDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StorylineLocationData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_StorylineLocationData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_StorylineLocationData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_StorylineLocationData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_StorylineLocationDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_StorylineLocationDataT>>,
}
impl Default for dict__string__clz_Torappu_StorylineLocationDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_StorylineLocationDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StorylineLocationData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_StorylineLocationData::create(
            _fbb,
            &dict__string__clz_Torappu_StorylineLocationDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_StorylineDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StorylineData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StorylineData<'a> {
    type Inner = clz_Torappu_StorylineData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StorylineData<'a> {
    pub const VT_STORYLINEID: flatbuffers::VOffsetT = 4;
    pub const VT_STORYLINETYPE: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;
    pub const VT_STORYLINENAME: flatbuffers::VOffsetT = 10;
    pub const VT_STORYLINEICONID: flatbuffers::VOffsetT = 12;
    pub const VT_STORYLINELOGOID: flatbuffers::VOffsetT = 14;
    pub const VT_BACKGROUNDID: flatbuffers::VOffsetT = 16;
    pub const VT_HASVIDEOTOPLAY: flatbuffers::VOffsetT = 18;
    pub const VT_STARTTS: flatbuffers::VOffsetT = 20;
    pub const VT_LOCATIONS: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StorylineData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StorylineDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineData<'bldr>> {
        let mut builder = clz_Torappu_StorylineDataBuilder::new(_fbb);
        builder.add_startTs(args.startTs);
        if let Some(x) = args.locations {
            builder.add_locations(x);
        }
        if let Some(x) = args.backgroundId {
            builder.add_backgroundId(x);
        }
        if let Some(x) = args.storylineLogoId {
            builder.add_storylineLogoId(x);
        }
        if let Some(x) = args.storylineIconId {
            builder.add_storylineIconId(x);
        }
        if let Some(x) = args.storylineName {
            builder.add_storylineName(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_storylineType(args.storylineType);
        if let Some(x) = args.storylineId {
            builder.add_storylineId(x);
        }
        builder.add_hasVideoToPlay(args.hasVideoToPlay);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StorylineDataT {
        let storylineId = self.storylineId().map(|x| x.to_string());
        let storylineType = self.storylineType();
        let sortId = self.sortId();
        let storylineName = self.storylineName().map(|x| x.to_string());
        let storylineIconId = self.storylineIconId().map(|x| x.to_string());
        let storylineLogoId = self.storylineLogoId().map(|x| x.to_string());
        let backgroundId = self.backgroundId().map(|x| x.to_string());
        let hasVideoToPlay = self.hasVideoToPlay();
        let startTs = self.startTs();
        let locations = self
            .locations()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_StorylineDataT {
            storylineId,
            storylineType,
            sortId,
            storylineName,
            storylineIconId,
            storylineLogoId,
            backgroundId,
            hasVideoToPlay,
            startTs,
            locations,
        }
    }

    #[inline]
    pub fn storylineId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineData::VT_STORYLINEID,
                None,
            )
        }
    }
    #[inline]
    pub fn storylineType(&self) -> enum__Torappu_StorylineType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StorylineType>(
                    clz_Torappu_StorylineData::VT_STORYLINETYPE,
                    Some(enum__Torappu_StorylineType::CONTINUE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StorylineData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn storylineName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineData::VT_STORYLINENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn storylineIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineData::VT_STORYLINEICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn storylineLogoId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineData::VT_STORYLINELOGOID,
                None,
            )
        }
    }
    #[inline]
    pub fn backgroundId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineData::VT_BACKGROUNDID,
                None,
            )
        }
    }
    #[inline]
    pub fn hasVideoToPlay(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StorylineData::VT_HASVIDEOTOPLAY, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_StorylineData::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn locations(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineLocationData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineLocationData>,
                >,
            >>(clz_Torappu_StorylineData::VT_LOCATIONS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StorylineData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "storylineId",
                Self::VT_STORYLINEID,
                false,
            )?
            .visit_field::<enum__Torappu_StorylineType>(
                "storylineType",
                Self::VT_STORYLINETYPE,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "storylineName",
                Self::VT_STORYLINENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "storylineIconId",
                Self::VT_STORYLINEICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "storylineLogoId",
                Self::VT_STORYLINELOGOID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "backgroundId",
                Self::VT_BACKGROUNDID,
                false,
            )?
            .visit_field::<bool>("hasVideoToPlay", Self::VT_HASVIDEOTOPLAY, false)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineLocationData>,
                >,
            >>("locations", Self::VT_LOCATIONS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StorylineDataArgs<'a> {
    pub storylineId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storylineType: enum__Torappu_StorylineType,
    pub sortId: i32,
    pub storylineName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storylineIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storylineLogoId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub backgroundId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hasVideoToPlay: bool,
    pub startTs: i64,
    pub locations: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineLocationData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_StorylineDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StorylineDataArgs {
            storylineId: None,
            storylineType: enum__Torappu_StorylineType::CONTINUE,
            sortId: 0,
            storylineName: None,
            storylineIconId: None,
            storylineLogoId: None,
            backgroundId: None,
            hasVideoToPlay: false,
            startTs: 0,
            locations: None,
        }
    }
}

impl Serialize for clz_Torappu_StorylineData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StorylineData", 10)?;
        if let Some(f) = self.storylineId() {
            s.serialize_field("storylineId", &f)?;
        } else {
            s.skip_field("storylineId")?;
        }
        s.serialize_field("storylineType", &self.storylineType())?;
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.storylineName() {
            s.serialize_field("storylineName", &f)?;
        } else {
            s.skip_field("storylineName")?;
        }
        if let Some(f) = self.storylineIconId() {
            s.serialize_field("storylineIconId", &f)?;
        } else {
            s.skip_field("storylineIconId")?;
        }
        if let Some(f) = self.storylineLogoId() {
            s.serialize_field("storylineLogoId", &f)?;
        } else {
            s.skip_field("storylineLogoId")?;
        }
        if let Some(f) = self.backgroundId() {
            s.serialize_field("backgroundId", &f)?;
        } else {
            s.skip_field("backgroundId")?;
        }
        s.serialize_field("hasVideoToPlay", &self.hasVideoToPlay())?;
        s.serialize_field("startTs", &self.startTs())?;
        if let Some(f) = self.locations() {
            s.serialize_field("locations", &f)?;
        } else {
            s.skip_field("locations")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StorylineDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_StorylineDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_storylineId(&mut self, storylineId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineData::VT_STORYLINEID,
            storylineId,
        );
    }
    #[inline]
    pub fn add_storylineType(&mut self, storylineType: enum__Torappu_StorylineType) {
        self.fbb_.push_slot::<enum__Torappu_StorylineType>(
            clz_Torappu_StorylineData::VT_STORYLINETYPE,
            storylineType,
            enum__Torappu_StorylineType::CONTINUE,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StorylineData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_storylineName(&mut self, storylineName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineData::VT_STORYLINENAME,
            storylineName,
        );
    }
    #[inline]
    pub fn add_storylineIconId(&mut self, storylineIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineData::VT_STORYLINEICONID,
            storylineIconId,
        );
    }
    #[inline]
    pub fn add_storylineLogoId(&mut self, storylineLogoId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineData::VT_STORYLINELOGOID,
            storylineLogoId,
        );
    }
    #[inline]
    pub fn add_backgroundId(&mut self, backgroundId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineData::VT_BACKGROUNDID,
            backgroundId,
        );
    }
    #[inline]
    pub fn add_hasVideoToPlay(&mut self, hasVideoToPlay: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StorylineData::VT_HASVIDEOTOPLAY,
            hasVideoToPlay,
            false,
        );
    }
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_StorylineData::VT_STARTTS, startTs, 0);
    }
    #[inline]
    pub fn add_locations(
        &mut self,
        locations: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineLocationData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineData::VT_LOCATIONS,
            locations,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StorylineDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StorylineDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StorylineData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StorylineData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StorylineData");
        ds.field("storylineId", &self.storylineId());
        ds.field("storylineType", &self.storylineType());
        ds.field("sortId", &self.sortId());
        ds.field("storylineName", &self.storylineName());
        ds.field("storylineIconId", &self.storylineIconId());
        ds.field("storylineLogoId", &self.storylineLogoId());
        ds.field("backgroundId", &self.backgroundId());
        ds.field("hasVideoToPlay", &self.hasVideoToPlay());
        ds.field("startTs", &self.startTs());
        ds.field("locations", &self.locations());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StorylineDataT {
    pub storylineId: Option<String>,
    pub storylineType: enum__Torappu_StorylineType,
    pub sortId: i32,
    pub storylineName: Option<String>,
    pub storylineIconId: Option<String>,
    pub storylineLogoId: Option<String>,
    pub backgroundId: Option<String>,
    pub hasVideoToPlay: bool,
    pub startTs: i64,
    pub locations: Option<Vec<dict__string__clz_Torappu_StorylineLocationDataT>>,
}
impl Default for clz_Torappu_StorylineDataT {
    fn default() -> Self {
        Self {
            storylineId: None,
            storylineType: enum__Torappu_StorylineType::CONTINUE,
            sortId: 0,
            storylineName: None,
            storylineIconId: None,
            storylineLogoId: None,
            backgroundId: None,
            hasVideoToPlay: false,
            startTs: 0,
            locations: None,
        }
    }
}
impl clz_Torappu_StorylineDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineData<'b>> {
        let storylineId = self.storylineId.as_ref().map(|x| _fbb.create_string(x));
        let storylineType = self.storylineType;
        let sortId = self.sortId;
        let storylineName = self.storylineName.as_ref().map(|x| _fbb.create_string(x));
        let storylineIconId = self.storylineIconId.as_ref().map(|x| _fbb.create_string(x));
        let storylineLogoId = self.storylineLogoId.as_ref().map(|x| _fbb.create_string(x));
        let backgroundId = self.backgroundId.as_ref().map(|x| _fbb.create_string(x));
        let hasVideoToPlay = self.hasVideoToPlay;
        let startTs = self.startTs;
        let locations = self.locations.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_StorylineData::create(
            _fbb,
            &clz_Torappu_StorylineDataArgs {
                storylineId,
                storylineType,
                sortId,
                storylineName,
                storylineIconId,
                storylineLogoId,
                backgroundId,
                hasVideoToPlay,
                startTs,
                locations,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_StorylineDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_StorylineData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_StorylineData<'a> {
    type Inner = dict__string__clz_Torappu_StorylineData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_StorylineData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_StorylineData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_StorylineDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StorylineData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_StorylineDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_StorylineDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_StorylineDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_StorylineData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_StorylineData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_StorylineData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineData>>(
                    dict__string__clz_Torappu_StorylineData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_StorylineData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_StorylineDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_StorylineData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_StorylineDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_StorylineDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_StorylineData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_StorylineData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_StorylineDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_StorylineDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_StorylineData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_StorylineData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StorylineData>>(
                dict__string__clz_Torappu_StorylineData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_StorylineDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_StorylineDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StorylineData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_StorylineData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_StorylineData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_StorylineData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_StorylineDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_StorylineDataT>>,
}
impl Default for dict__string__clz_Torappu_StorylineDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_StorylineDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StorylineData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_StorylineData::create(
            _fbb,
            &dict__string__clz_Torappu_StorylineDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_StorylineMainlineDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StorylineMainlineData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StorylineMainlineData<'a> {
    type Inner = clz_Torappu_StorylineMainlineData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StorylineMainlineData<'a> {
    pub const VT_ZONEID: flatbuffers::VOffsetT = 4;
    pub const VT_RETROID: flatbuffers::VOffsetT = 6;
    pub const VT_DECOIMAGEID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StorylineMainlineData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StorylineMainlineDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineMainlineData<'bldr>> {
        let mut builder = clz_Torappu_StorylineMainlineDataBuilder::new(_fbb);
        if let Some(x) = args.decoImageId {
            builder.add_decoImageId(x);
        }
        if let Some(x) = args.retroId {
            builder.add_retroId(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StorylineMainlineDataT {
        let zoneId = self.zoneId().map(|x| x.to_string());
        let retroId = self.retroId().map(|x| x.to_string());
        let decoImageId = self.decoImageId().map(|x| x.to_string());
        clz_Torappu_StorylineMainlineDataT {
            zoneId,
            retroId,
            decoImageId,
        }
    }

    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineMainlineData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn retroId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineMainlineData::VT_RETROID,
                None,
            )
        }
    }
    #[inline]
    pub fn decoImageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineMainlineData::VT_DECOIMAGEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StorylineMainlineData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("retroId", Self::VT_RETROID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "decoImageId",
                Self::VT_DECOIMAGEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StorylineMainlineDataArgs<'a> {
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub retroId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub decoImageId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_StorylineMainlineDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StorylineMainlineDataArgs {
            zoneId: None,
            retroId: None,
            decoImageId: None,
        }
    }
}

impl Serialize for clz_Torappu_StorylineMainlineData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StorylineMainlineData", 3)?;
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.retroId() {
            s.serialize_field("retroId", &f)?;
        } else {
            s.skip_field("retroId")?;
        }
        if let Some(f) = self.decoImageId() {
            s.serialize_field("decoImageId", &f)?;
        } else {
            s.skip_field("decoImageId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StorylineMainlineDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StorylineMainlineDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineMainlineData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_retroId(&mut self, retroId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineMainlineData::VT_RETROID,
            retroId,
        );
    }
    #[inline]
    pub fn add_decoImageId(&mut self, decoImageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineMainlineData::VT_DECOIMAGEID,
            decoImageId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StorylineMainlineDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StorylineMainlineDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StorylineMainlineData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StorylineMainlineData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StorylineMainlineData");
        ds.field("zoneId", &self.zoneId());
        ds.field("retroId", &self.retroId());
        ds.field("decoImageId", &self.decoImageId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StorylineMainlineDataT {
    pub zoneId: Option<String>,
    pub retroId: Option<String>,
    pub decoImageId: Option<String>,
}
impl Default for clz_Torappu_StorylineMainlineDataT {
    fn default() -> Self {
        Self {
            zoneId: None,
            retroId: None,
            decoImageId: None,
        }
    }
}
impl clz_Torappu_StorylineMainlineDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineMainlineData<'b>> {
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let retroId = self.retroId.as_ref().map(|x| _fbb.create_string(x));
        let decoImageId = self.decoImageId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_StorylineMainlineData::create(
            _fbb,
            &clz_Torappu_StorylineMainlineDataArgs {
                zoneId,
                retroId,
                decoImageId,
            },
        )
    }
}
pub enum clz_Torappu_StorylineSSDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StorylineSSData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StorylineSSData<'a> {
    type Inner = clz_Torappu_StorylineSSData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StorylineSSData<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_BACKGROUNDID: flatbuffers::VOffsetT = 8;
    pub const VT_TAGS: flatbuffers::VOffsetT = 10;
    pub const VT_REOPENACTIVITYID: flatbuffers::VOffsetT = 12;
    pub const VT_RETROACTIVITYID: flatbuffers::VOffsetT = 14;
    pub const VT_ISRECOMMENDED: flatbuffers::VOffsetT = 16;
    pub const VT_RECOMMENDHIDESTAGEID: flatbuffers::VOffsetT = 18;
    pub const VT_OVERRIDESTAGELIST: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StorylineSSData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StorylineSSDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineSSData<'bldr>> {
        let mut builder = clz_Torappu_StorylineSSDataBuilder::new(_fbb);
        if let Some(x) = args.overrideStageList {
            builder.add_overrideStageList(x);
        }
        if let Some(x) = args.recommendHideStageId {
            builder.add_recommendHideStageId(x);
        }
        if let Some(x) = args.retroActivityId {
            builder.add_retroActivityId(x);
        }
        if let Some(x) = args.reopenActivityId {
            builder.add_reopenActivityId(x);
        }
        if let Some(x) = args.tags {
            builder.add_tags(x);
        }
        if let Some(x) = args.backgroundId {
            builder.add_backgroundId(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_isRecommended(args.isRecommended);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StorylineSSDataT {
        let name = self.name().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let backgroundId = self.backgroundId().map(|x| x.to_string());
        let tags = self
            .tags()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let reopenActivityId = self.reopenActivityId().map(|x| x.to_string());
        let retroActivityId = self.retroActivityId().map(|x| x.to_string());
        let isRecommended = self.isRecommended();
        let recommendHideStageId = self.recommendHideStageId().map(|x| x.to_string());
        let overrideStageList = self
            .overrideStageList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_StorylineSSDataT {
            name,
            desc,
            backgroundId,
            tags,
            reopenActivityId,
            retroActivityId,
            isRecommended,
            recommendHideStageId,
            overrideStageList,
        }
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineSSData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineSSData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn backgroundId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineSSData::VT_BACKGROUNDID,
                None,
            )
        }
    }
    #[inline]
    pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_StorylineSSData::VT_TAGS, None)
        }
    }
    #[inline]
    pub fn reopenActivityId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineSSData::VT_REOPENACTIVITYID,
                None,
            )
        }
    }
    #[inline]
    pub fn retroActivityId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineSSData::VT_RETROACTIVITYID,
                None,
            )
        }
    }
    #[inline]
    pub fn isRecommended(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StorylineSSData::VT_ISRECOMMENDED, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn recommendHideStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineSSData::VT_RECOMMENDHIDESTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn overrideStageList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_StorylineSSData::VT_OVERRIDESTAGELIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StorylineSSData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "backgroundId",
                Self::VT_BACKGROUNDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("tags", Self::VT_TAGS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "reopenActivityId",
                Self::VT_REOPENACTIVITYID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "retroActivityId",
                Self::VT_RETROACTIVITYID,
                false,
            )?
            .visit_field::<bool>("isRecommended", Self::VT_ISRECOMMENDED, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "recommendHideStageId",
                Self::VT_RECOMMENDHIDESTAGEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("overrideStageList", Self::VT_OVERRIDESTAGELIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StorylineSSDataArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub backgroundId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tags: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub reopenActivityId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub retroActivityId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isRecommended: bool,
    pub recommendHideStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub overrideStageList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_StorylineSSDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StorylineSSDataArgs {
            name: None,
            desc: None,
            backgroundId: None,
            tags: None,
            reopenActivityId: None,
            retroActivityId: None,
            isRecommended: false,
            recommendHideStageId: None,
            overrideStageList: None,
        }
    }
}

impl Serialize for clz_Torappu_StorylineSSData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StorylineSSData", 9)?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.backgroundId() {
            s.serialize_field("backgroundId", &f)?;
        } else {
            s.skip_field("backgroundId")?;
        }
        if let Some(f) = self.tags() {
            s.serialize_field("tags", &f)?;
        } else {
            s.skip_field("tags")?;
        }
        if let Some(f) = self.reopenActivityId() {
            s.serialize_field("reopenActivityId", &f)?;
        } else {
            s.skip_field("reopenActivityId")?;
        }
        if let Some(f) = self.retroActivityId() {
            s.serialize_field("retroActivityId", &f)?;
        } else {
            s.skip_field("retroActivityId")?;
        }
        s.serialize_field("isRecommended", &self.isRecommended())?;
        if let Some(f) = self.recommendHideStageId() {
            s.serialize_field("recommendHideStageId", &f)?;
        } else {
            s.skip_field("recommendHideStageId")?;
        }
        if let Some(f) = self.overrideStageList() {
            s.serialize_field("overrideStageList", &f)?;
        } else {
            s.skip_field("overrideStageList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StorylineSSDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_StorylineSSDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineSSData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineSSData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_backgroundId(&mut self, backgroundId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineSSData::VT_BACKGROUNDID,
            backgroundId,
        );
    }
    #[inline]
    pub fn add_tags(
        &mut self,
        tags: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineSSData::VT_TAGS,
            tags,
        );
    }
    #[inline]
    pub fn add_reopenActivityId(&mut self, reopenActivityId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineSSData::VT_REOPENACTIVITYID,
            reopenActivityId,
        );
    }
    #[inline]
    pub fn add_retroActivityId(&mut self, retroActivityId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineSSData::VT_RETROACTIVITYID,
            retroActivityId,
        );
    }
    #[inline]
    pub fn add_isRecommended(&mut self, isRecommended: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StorylineSSData::VT_ISRECOMMENDED,
            isRecommended,
            false,
        );
    }
    #[inline]
    pub fn add_recommendHideStageId(
        &mut self,
        recommendHideStageId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineSSData::VT_RECOMMENDHIDESTAGEID,
            recommendHideStageId,
        );
    }
    #[inline]
    pub fn add_overrideStageList(
        &mut self,
        overrideStageList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineSSData::VT_OVERRIDESTAGELIST,
            overrideStageList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StorylineSSDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StorylineSSDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StorylineSSData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StorylineSSData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StorylineSSData");
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.field("backgroundId", &self.backgroundId());
        ds.field("tags", &self.tags());
        ds.field("reopenActivityId", &self.reopenActivityId());
        ds.field("retroActivityId", &self.retroActivityId());
        ds.field("isRecommended", &self.isRecommended());
        ds.field("recommendHideStageId", &self.recommendHideStageId());
        ds.field("overrideStageList", &self.overrideStageList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StorylineSSDataT {
    pub name: Option<String>,
    pub desc: Option<String>,
    pub backgroundId: Option<String>,
    pub tags: Option<Vec<String>>,
    pub reopenActivityId: Option<String>,
    pub retroActivityId: Option<String>,
    pub isRecommended: bool,
    pub recommendHideStageId: Option<String>,
    pub overrideStageList: Option<Vec<String>>,
}
impl Default for clz_Torappu_StorylineSSDataT {
    fn default() -> Self {
        Self {
            name: None,
            desc: None,
            backgroundId: None,
            tags: None,
            reopenActivityId: None,
            retroActivityId: None,
            isRecommended: false,
            recommendHideStageId: None,
            overrideStageList: None,
        }
    }
}
impl clz_Torappu_StorylineSSDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineSSData<'b>> {
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let backgroundId = self.backgroundId.as_ref().map(|x| _fbb.create_string(x));
        let tags = self.tags.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let reopenActivityId = self
            .reopenActivityId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let retroActivityId = self.retroActivityId.as_ref().map(|x| _fbb.create_string(x));
        let isRecommended = self.isRecommended;
        let recommendHideStageId = self
            .recommendHideStageId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let overrideStageList = self.overrideStageList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_StorylineSSData::create(
            _fbb,
            &clz_Torappu_StorylineSSDataArgs {
                name,
                desc,
                backgroundId,
                tags,
                reopenActivityId,
                retroActivityId,
                isRecommended,
                recommendHideStageId,
                overrideStageList,
            },
        )
    }
}
pub enum clz_Torappu_StorylineCollectDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StorylineCollectData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StorylineCollectData<'a> {
    type Inner = clz_Torappu_StorylineCollectData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StorylineCollectData<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;
    pub const VT_BACKGROUNDID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StorylineCollectData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StorylineCollectDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineCollectData<'bldr>> {
        let mut builder = clz_Torappu_StorylineCollectDataBuilder::new(_fbb);
        if let Some(x) = args.backgroundId {
            builder.add_backgroundId(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StorylineCollectDataT {
        let name = self.name().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let backgroundId = self.backgroundId().map(|x| x.to_string());
        clz_Torappu_StorylineCollectDataT {
            name,
            desc,
            backgroundId,
        }
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineCollectData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineCollectData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn backgroundId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineCollectData::VT_BACKGROUNDID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StorylineCollectData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "backgroundId",
                Self::VT_BACKGROUNDID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StorylineCollectDataArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub backgroundId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_StorylineCollectDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StorylineCollectDataArgs {
            name: None,
            desc: None,
            backgroundId: None,
        }
    }
}

impl Serialize for clz_Torappu_StorylineCollectData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StorylineCollectData", 3)?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.backgroundId() {
            s.serialize_field("backgroundId", &f)?;
        } else {
            s.skip_field("backgroundId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StorylineCollectDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StorylineCollectDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineCollectData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineCollectData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_backgroundId(&mut self, backgroundId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineCollectData::VT_BACKGROUNDID,
            backgroundId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StorylineCollectDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StorylineCollectDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StorylineCollectData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StorylineCollectData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StorylineCollectData");
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.field("backgroundId", &self.backgroundId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StorylineCollectDataT {
    pub name: Option<String>,
    pub desc: Option<String>,
    pub backgroundId: Option<String>,
}
impl Default for clz_Torappu_StorylineCollectDataT {
    fn default() -> Self {
        Self {
            name: None,
            desc: None,
            backgroundId: None,
        }
    }
}
impl clz_Torappu_StorylineCollectDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineCollectData<'b>> {
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let backgroundId = self.backgroundId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_StorylineCollectData::create(
            _fbb,
            &clz_Torappu_StorylineCollectDataArgs {
                name,
                desc,
                backgroundId,
            },
        )
    }
}
pub enum clz_Torappu_StorylineStorySetDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StorylineStorySetData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StorylineStorySetData<'a> {
    type Inner = clz_Torappu_StorylineStorySetData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StorylineStorySetData<'a> {
    pub const VT_STORYSETID: flatbuffers::VOffsetT = 4;
    pub const VT_STORYSETTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_SORTBYYEAR: flatbuffers::VOffsetT = 8;
    pub const VT_SORTWITHINYEAR: flatbuffers::VOffsetT = 10;
    pub const VT_KVIMAGEID: flatbuffers::VOffsetT = 12;
    pub const VT_TITLEIMAGEID: flatbuffers::VOffsetT = 14;
    pub const VT_HAVEVIDEOTOPLAY: flatbuffers::VOffsetT = 16;
    pub const VT_BACKGROUNDID: flatbuffers::VOffsetT = 18;
    pub const VT_GAMEMUSICID: flatbuffers::VOffsetT = 20;
    pub const VT_COREREWARDTYPE: flatbuffers::VOffsetT = 22;
    pub const VT_COREREWARDID: flatbuffers::VOffsetT = 24;
    pub const VT_RELEVANTACTIVITYID: flatbuffers::VOffsetT = 26;
    pub const VT_MAINLINEDATA: flatbuffers::VOffsetT = 28;
    pub const VT_SSDATA: flatbuffers::VOffsetT = 30;
    pub const VT_COLLECTDATA: flatbuffers::VOffsetT = 32;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StorylineStorySetData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StorylineStorySetDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineStorySetData<'bldr>> {
        let mut builder = clz_Torappu_StorylineStorySetDataBuilder::new(_fbb);
        if let Some(x) = args.collectData {
            builder.add_collectData(x);
        }
        if let Some(x) = args.ssData {
            builder.add_ssData(x);
        }
        if let Some(x) = args.mainlineData {
            builder.add_mainlineData(x);
        }
        if let Some(x) = args.relevantActivityId {
            builder.add_relevantActivityId(x);
        }
        if let Some(x) = args.coreRewardId {
            builder.add_coreRewardId(x);
        }
        builder.add_coreRewardType(args.coreRewardType);
        if let Some(x) = args.gameMusicId {
            builder.add_gameMusicId(x);
        }
        if let Some(x) = args.backgroundId {
            builder.add_backgroundId(x);
        }
        if let Some(x) = args.titleImageId {
            builder.add_titleImageId(x);
        }
        if let Some(x) = args.kvImageId {
            builder.add_kvImageId(x);
        }
        builder.add_sortWithinYear(args.sortWithinYear);
        builder.add_sortByYear(args.sortByYear);
        builder.add_storySetType(args.storySetType);
        if let Some(x) = args.storySetId {
            builder.add_storySetId(x);
        }
        builder.add_haveVideoToPlay(args.haveVideoToPlay);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StorylineStorySetDataT {
        let storySetId = self.storySetId().map(|x| x.to_string());
        let storySetType = self.storySetType();
        let sortByYear = self.sortByYear();
        let sortWithinYear = self.sortWithinYear();
        let kvImageId = self.kvImageId().map(|x| x.to_string());
        let titleImageId = self.titleImageId().map(|x| x.to_string());
        let haveVideoToPlay = self.haveVideoToPlay();
        let backgroundId = self.backgroundId().map(|x| x.to_string());
        let gameMusicId = self.gameMusicId().map(|x| x.to_string());
        let coreRewardType = self.coreRewardType();
        let coreRewardId = self.coreRewardId().map(|x| x.to_string());
        let relevantActivityId = self.relevantActivityId().map(|x| x.to_string());
        let mainlineData = self.mainlineData().map(|x| Box::new(x.unpack()));
        let ssData = self.ssData().map(|x| Box::new(x.unpack()));
        let collectData = self.collectData().map(|x| Box::new(x.unpack()));
        clz_Torappu_StorylineStorySetDataT {
            storySetId,
            storySetType,
            sortByYear,
            sortWithinYear,
            kvImageId,
            titleImageId,
            haveVideoToPlay,
            backgroundId,
            gameMusicId,
            coreRewardType,
            coreRewardId,
            relevantActivityId,
            mainlineData,
            ssData,
            collectData,
        }
    }

    #[inline]
    pub fn storySetId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineStorySetData::VT_STORYSETID,
                None,
            )
        }
    }
    #[inline]
    pub fn storySetType(&self) -> enum__Torappu_StorylineStorySetType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StorylineStorySetType>(
                    clz_Torappu_StorylineStorySetData::VT_STORYSETTYPE,
                    Some(enum__Torappu_StorylineStorySetType::MAINLINE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortByYear(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StorylineStorySetData::VT_SORTBYYEAR, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn sortWithinYear(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_StorylineStorySetData::VT_SORTWITHINYEAR,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn kvImageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineStorySetData::VT_KVIMAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn titleImageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineStorySetData::VT_TITLEIMAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn haveVideoToPlay(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_StorylineStorySetData::VT_HAVEVIDEOTOPLAY,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn backgroundId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineStorySetData::VT_BACKGROUNDID,
                None,
            )
        }
    }
    #[inline]
    pub fn gameMusicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineStorySetData::VT_GAMEMUSICID,
                None,
            )
        }
    }
    #[inline]
    pub fn coreRewardType(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_StorylineStorySetData::VT_COREREWARDTYPE,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn coreRewardId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineStorySetData::VT_COREREWARDID,
                None,
            )
        }
    }
    #[inline]
    pub fn relevantActivityId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineStorySetData::VT_RELEVANTACTIVITYID,
                None,
            )
        }
    }
    #[inline]
    pub fn mainlineData(&self) -> Option<clz_Torappu_StorylineMainlineData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineMainlineData>>(
                    clz_Torappu_StorylineStorySetData::VT_MAINLINEDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn ssData(&self) -> Option<clz_Torappu_StorylineSSData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineSSData>>(
                    clz_Torappu_StorylineStorySetData::VT_SSDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn collectData(&self) -> Option<clz_Torappu_StorylineCollectData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineCollectData>>(
                    clz_Torappu_StorylineStorySetData::VT_COLLECTDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StorylineStorySetData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "storySetId",
                Self::VT_STORYSETID,
                false,
            )?
            .visit_field::<enum__Torappu_StorylineStorySetType>(
                "storySetType",
                Self::VT_STORYSETTYPE,
                false,
            )?
            .visit_field::<i32>("sortByYear", Self::VT_SORTBYYEAR, false)?
            .visit_field::<i32>("sortWithinYear", Self::VT_SORTWITHINYEAR, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "kvImageId",
                Self::VT_KVIMAGEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "titleImageId",
                Self::VT_TITLEIMAGEID,
                false,
            )?
            .visit_field::<bool>("haveVideoToPlay", Self::VT_HAVEVIDEOTOPLAY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "backgroundId",
                Self::VT_BACKGROUNDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "gameMusicId",
                Self::VT_GAMEMUSICID,
                false,
            )?
            .visit_field::<enum__Torappu_ItemType>(
                "coreRewardType",
                Self::VT_COREREWARDTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "coreRewardId",
                Self::VT_COREREWARDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "relevantActivityId",
                Self::VT_RELEVANTACTIVITYID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineMainlineData>>(
                "mainlineData",
                Self::VT_MAINLINEDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineSSData>>(
                "ssData",
                Self::VT_SSDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineCollectData>>(
                "collectData",
                Self::VT_COLLECTDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StorylineStorySetDataArgs<'a> {
    pub storySetId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storySetType: enum__Torappu_StorylineStorySetType,
    pub sortByYear: i32,
    pub sortWithinYear: i32,
    pub kvImageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub titleImageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub haveVideoToPlay: bool,
    pub backgroundId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gameMusicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub coreRewardType: enum__Torappu_ItemType,
    pub coreRewardId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relevantActivityId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mainlineData: Option<flatbuffers::WIPOffset<clz_Torappu_StorylineMainlineData<'a>>>,
    pub ssData: Option<flatbuffers::WIPOffset<clz_Torappu_StorylineSSData<'a>>>,
    pub collectData: Option<flatbuffers::WIPOffset<clz_Torappu_StorylineCollectData<'a>>>,
}
impl<'a> Default for clz_Torappu_StorylineStorySetDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StorylineStorySetDataArgs {
            storySetId: None,
            storySetType: enum__Torappu_StorylineStorySetType::MAINLINE,
            sortByYear: 0,
            sortWithinYear: 0,
            kvImageId: None,
            titleImageId: None,
            haveVideoToPlay: false,
            backgroundId: None,
            gameMusicId: None,
            coreRewardType: enum__Torappu_ItemType::NONE,
            coreRewardId: None,
            relevantActivityId: None,
            mainlineData: None,
            ssData: None,
            collectData: None,
        }
    }
}

impl Serialize for clz_Torappu_StorylineStorySetData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StorylineStorySetData", 15)?;
        if let Some(f) = self.storySetId() {
            s.serialize_field("storySetId", &f)?;
        } else {
            s.skip_field("storySetId")?;
        }
        s.serialize_field("storySetType", &self.storySetType())?;
        s.serialize_field("sortByYear", &self.sortByYear())?;
        s.serialize_field("sortWithinYear", &self.sortWithinYear())?;
        if let Some(f) = self.kvImageId() {
            s.serialize_field("kvImageId", &f)?;
        } else {
            s.skip_field("kvImageId")?;
        }
        if let Some(f) = self.titleImageId() {
            s.serialize_field("titleImageId", &f)?;
        } else {
            s.skip_field("titleImageId")?;
        }
        s.serialize_field("haveVideoToPlay", &self.haveVideoToPlay())?;
        if let Some(f) = self.backgroundId() {
            s.serialize_field("backgroundId", &f)?;
        } else {
            s.skip_field("backgroundId")?;
        }
        if let Some(f) = self.gameMusicId() {
            s.serialize_field("gameMusicId", &f)?;
        } else {
            s.skip_field("gameMusicId")?;
        }
        s.serialize_field("coreRewardType", &self.coreRewardType())?;
        if let Some(f) = self.coreRewardId() {
            s.serialize_field("coreRewardId", &f)?;
        } else {
            s.skip_field("coreRewardId")?;
        }
        if let Some(f) = self.relevantActivityId() {
            s.serialize_field("relevantActivityId", &f)?;
        } else {
            s.skip_field("relevantActivityId")?;
        }
        if let Some(f) = self.mainlineData() {
            s.serialize_field("mainlineData", &f)?;
        } else {
            s.skip_field("mainlineData")?;
        }
        if let Some(f) = self.ssData() {
            s.serialize_field("ssData", &f)?;
        } else {
            s.skip_field("ssData")?;
        }
        if let Some(f) = self.collectData() {
            s.serialize_field("collectData", &f)?;
        } else {
            s.skip_field("collectData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StorylineStorySetDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StorylineStorySetDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_storySetId(&mut self, storySetId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineStorySetData::VT_STORYSETID,
            storySetId,
        );
    }
    #[inline]
    pub fn add_storySetType(&mut self, storySetType: enum__Torappu_StorylineStorySetType) {
        self.fbb_.push_slot::<enum__Torappu_StorylineStorySetType>(
            clz_Torappu_StorylineStorySetData::VT_STORYSETTYPE,
            storySetType,
            enum__Torappu_StorylineStorySetType::MAINLINE,
        );
    }
    #[inline]
    pub fn add_sortByYear(&mut self, sortByYear: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_StorylineStorySetData::VT_SORTBYYEAR,
            sortByYear,
            0,
        );
    }
    #[inline]
    pub fn add_sortWithinYear(&mut self, sortWithinYear: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_StorylineStorySetData::VT_SORTWITHINYEAR,
            sortWithinYear,
            0,
        );
    }
    #[inline]
    pub fn add_kvImageId(&mut self, kvImageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineStorySetData::VT_KVIMAGEID,
            kvImageId,
        );
    }
    #[inline]
    pub fn add_titleImageId(&mut self, titleImageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineStorySetData::VT_TITLEIMAGEID,
            titleImageId,
        );
    }
    #[inline]
    pub fn add_haveVideoToPlay(&mut self, haveVideoToPlay: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StorylineStorySetData::VT_HAVEVIDEOTOPLAY,
            haveVideoToPlay,
            false,
        );
    }
    #[inline]
    pub fn add_backgroundId(&mut self, backgroundId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineStorySetData::VT_BACKGROUNDID,
            backgroundId,
        );
    }
    #[inline]
    pub fn add_gameMusicId(&mut self, gameMusicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineStorySetData::VT_GAMEMUSICID,
            gameMusicId,
        );
    }
    #[inline]
    pub fn add_coreRewardType(&mut self, coreRewardType: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_StorylineStorySetData::VT_COREREWARDTYPE,
            coreRewardType,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_coreRewardId(&mut self, coreRewardId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineStorySetData::VT_COREREWARDID,
            coreRewardId,
        );
    }
    #[inline]
    pub fn add_relevantActivityId(&mut self, relevantActivityId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineStorySetData::VT_RELEVANTACTIVITYID,
            relevantActivityId,
        );
    }
    #[inline]
    pub fn add_mainlineData(
        &mut self,
        mainlineData: flatbuffers::WIPOffset<clz_Torappu_StorylineMainlineData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StorylineMainlineData>>(
                clz_Torappu_StorylineStorySetData::VT_MAINLINEDATA,
                mainlineData,
            );
    }
    #[inline]
    pub fn add_ssData(&mut self, ssData: flatbuffers::WIPOffset<clz_Torappu_StorylineSSData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StorylineSSData>>(
                clz_Torappu_StorylineStorySetData::VT_SSDATA,
                ssData,
            );
    }
    #[inline]
    pub fn add_collectData(
        &mut self,
        collectData: flatbuffers::WIPOffset<clz_Torappu_StorylineCollectData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StorylineCollectData>>(
                clz_Torappu_StorylineStorySetData::VT_COLLECTDATA,
                collectData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StorylineStorySetDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StorylineStorySetDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StorylineStorySetData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StorylineStorySetData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StorylineStorySetData");
        ds.field("storySetId", &self.storySetId());
        ds.field("storySetType", &self.storySetType());
        ds.field("sortByYear", &self.sortByYear());
        ds.field("sortWithinYear", &self.sortWithinYear());
        ds.field("kvImageId", &self.kvImageId());
        ds.field("titleImageId", &self.titleImageId());
        ds.field("haveVideoToPlay", &self.haveVideoToPlay());
        ds.field("backgroundId", &self.backgroundId());
        ds.field("gameMusicId", &self.gameMusicId());
        ds.field("coreRewardType", &self.coreRewardType());
        ds.field("coreRewardId", &self.coreRewardId());
        ds.field("relevantActivityId", &self.relevantActivityId());
        ds.field("mainlineData", &self.mainlineData());
        ds.field("ssData", &self.ssData());
        ds.field("collectData", &self.collectData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StorylineStorySetDataT {
    pub storySetId: Option<String>,
    pub storySetType: enum__Torappu_StorylineStorySetType,
    pub sortByYear: i32,
    pub sortWithinYear: i32,
    pub kvImageId: Option<String>,
    pub titleImageId: Option<String>,
    pub haveVideoToPlay: bool,
    pub backgroundId: Option<String>,
    pub gameMusicId: Option<String>,
    pub coreRewardType: enum__Torappu_ItemType,
    pub coreRewardId: Option<String>,
    pub relevantActivityId: Option<String>,
    pub mainlineData: Option<Box<clz_Torappu_StorylineMainlineDataT>>,
    pub ssData: Option<Box<clz_Torappu_StorylineSSDataT>>,
    pub collectData: Option<Box<clz_Torappu_StorylineCollectDataT>>,
}
impl Default for clz_Torappu_StorylineStorySetDataT {
    fn default() -> Self {
        Self {
            storySetId: None,
            storySetType: enum__Torappu_StorylineStorySetType::MAINLINE,
            sortByYear: 0,
            sortWithinYear: 0,
            kvImageId: None,
            titleImageId: None,
            haveVideoToPlay: false,
            backgroundId: None,
            gameMusicId: None,
            coreRewardType: enum__Torappu_ItemType::NONE,
            coreRewardId: None,
            relevantActivityId: None,
            mainlineData: None,
            ssData: None,
            collectData: None,
        }
    }
}
impl clz_Torappu_StorylineStorySetDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineStorySetData<'b>> {
        let storySetId = self.storySetId.as_ref().map(|x| _fbb.create_string(x));
        let storySetType = self.storySetType;
        let sortByYear = self.sortByYear;
        let sortWithinYear = self.sortWithinYear;
        let kvImageId = self.kvImageId.as_ref().map(|x| _fbb.create_string(x));
        let titleImageId = self.titleImageId.as_ref().map(|x| _fbb.create_string(x));
        let haveVideoToPlay = self.haveVideoToPlay;
        let backgroundId = self.backgroundId.as_ref().map(|x| _fbb.create_string(x));
        let gameMusicId = self.gameMusicId.as_ref().map(|x| _fbb.create_string(x));
        let coreRewardType = self.coreRewardType;
        let coreRewardId = self.coreRewardId.as_ref().map(|x| _fbb.create_string(x));
        let relevantActivityId = self
            .relevantActivityId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let mainlineData = self.mainlineData.as_ref().map(|x| x.pack(_fbb));
        let ssData = self.ssData.as_ref().map(|x| x.pack(_fbb));
        let collectData = self.collectData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_StorylineStorySetData::create(
            _fbb,
            &clz_Torappu_StorylineStorySetDataArgs {
                storySetId,
                storySetType,
                sortByYear,
                sortWithinYear,
                kvImageId,
                titleImageId,
                haveVideoToPlay,
                backgroundId,
                gameMusicId,
                coreRewardType,
                coreRewardId,
                relevantActivityId,
                mainlineData,
                ssData,
                collectData,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_StorylineStorySetDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_StorylineStorySetData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_StorylineStorySetData<'a> {
    type Inner = dict__string__clz_Torappu_StorylineStorySetData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_StorylineStorySetData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_StorylineStorySetData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_StorylineStorySetDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StorylineStorySetData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_StorylineStorySetDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_StorylineStorySetDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_StorylineStorySetDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_StorylineStorySetData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_StorylineStorySetData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_StorylineStorySetData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineStorySetData>>(
                    dict__string__clz_Torappu_StorylineStorySetData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_StorylineStorySetData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineStorySetData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_StorylineStorySetDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_StorylineStorySetData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_StorylineStorySetDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_StorylineStorySetDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_StorylineStorySetData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_StorylineStorySetData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_StorylineStorySetDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_StorylineStorySetDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_StorylineStorySetData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_StorylineStorySetData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StorylineStorySetData>>(
                dict__string__clz_Torappu_StorylineStorySetData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_StorylineStorySetDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_StorylineStorySetDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StorylineStorySetData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_StorylineStorySetData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_StorylineStorySetData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_StorylineStorySetData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_StorylineStorySetDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_StorylineStorySetDataT>>,
}
impl Default for dict__string__clz_Torappu_StorylineStorySetDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_StorylineStorySetDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StorylineStorySetData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_StorylineStorySetData::create(
            _fbb,
            &dict__string__clz_Torappu_StorylineStorySetDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_StorylineTagDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StorylineTagData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StorylineTagData<'a> {
    type Inner = clz_Torappu_StorylineTagData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StorylineTagData<'a> {
    pub const VT_TAGID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_TAGDESC: flatbuffers::VOffsetT = 8;
    pub const VT_TEXTCOLOR: flatbuffers::VOffsetT = 10;
    pub const VT_BKGCOLOR: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StorylineTagData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StorylineTagDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineTagData<'bldr>> {
        let mut builder = clz_Torappu_StorylineTagDataBuilder::new(_fbb);
        if let Some(x) = args.bkgColor {
            builder.add_bkgColor(x);
        }
        if let Some(x) = args.textColor {
            builder.add_textColor(x);
        }
        if let Some(x) = args.tagDesc {
            builder.add_tagDesc(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.tagId {
            builder.add_tagId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StorylineTagDataT {
        let tagId = self.tagId().map(|x| x.to_string());
        let sortId = self.sortId();
        let tagDesc = self.tagDesc().map(|x| x.to_string());
        let textColor = self.textColor().map(|x| x.to_string());
        let bkgColor = self.bkgColor().map(|x| x.to_string());
        clz_Torappu_StorylineTagDataT {
            tagId,
            sortId,
            tagDesc,
            textColor,
            bkgColor,
        }
    }

    #[inline]
    pub fn tagId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineTagData::VT_TAGID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StorylineTagData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn tagDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineTagData::VT_TAGDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn textColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineTagData::VT_TEXTCOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn bkgColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineTagData::VT_BKGCOLOR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StorylineTagData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tagId", Self::VT_TAGID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tagDesc", Self::VT_TAGDESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "textColor",
                Self::VT_TEXTCOLOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bkgColor",
                Self::VT_BKGCOLOR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StorylineTagDataArgs<'a> {
    pub tagId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub tagDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub textColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bkgColor: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_StorylineTagDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StorylineTagDataArgs {
            tagId: None,
            sortId: 0,
            tagDesc: None,
            textColor: None,
            bkgColor: None,
        }
    }
}

impl Serialize for clz_Torappu_StorylineTagData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StorylineTagData", 5)?;
        if let Some(f) = self.tagId() {
            s.serialize_field("tagId", &f)?;
        } else {
            s.skip_field("tagId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.tagDesc() {
            s.serialize_field("tagDesc", &f)?;
        } else {
            s.skip_field("tagDesc")?;
        }
        if let Some(f) = self.textColor() {
            s.serialize_field("textColor", &f)?;
        } else {
            s.skip_field("textColor")?;
        }
        if let Some(f) = self.bkgColor() {
            s.serialize_field("bkgColor", &f)?;
        } else {
            s.skip_field("bkgColor")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StorylineTagDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_StorylineTagDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_tagId(&mut self, tagId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineTagData::VT_TAGID,
            tagId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StorylineTagData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_tagDesc(&mut self, tagDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineTagData::VT_TAGDESC,
            tagDesc,
        );
    }
    #[inline]
    pub fn add_textColor(&mut self, textColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineTagData::VT_TEXTCOLOR,
            textColor,
        );
    }
    #[inline]
    pub fn add_bkgColor(&mut self, bkgColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineTagData::VT_BKGCOLOR,
            bkgColor,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StorylineTagDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StorylineTagDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StorylineTagData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StorylineTagData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StorylineTagData");
        ds.field("tagId", &self.tagId());
        ds.field("sortId", &self.sortId());
        ds.field("tagDesc", &self.tagDesc());
        ds.field("textColor", &self.textColor());
        ds.field("bkgColor", &self.bkgColor());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StorylineTagDataT {
    pub tagId: Option<String>,
    pub sortId: i32,
    pub tagDesc: Option<String>,
    pub textColor: Option<String>,
    pub bkgColor: Option<String>,
}
impl Default for clz_Torappu_StorylineTagDataT {
    fn default() -> Self {
        Self {
            tagId: None,
            sortId: 0,
            tagDesc: None,
            textColor: None,
            bkgColor: None,
        }
    }
}
impl clz_Torappu_StorylineTagDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineTagData<'b>> {
        let tagId = self.tagId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let tagDesc = self.tagDesc.as_ref().map(|x| _fbb.create_string(x));
        let textColor = self.textColor.as_ref().map(|x| _fbb.create_string(x));
        let bkgColor = self.bkgColor.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_StorylineTagData::create(
            _fbb,
            &clz_Torappu_StorylineTagDataArgs {
                tagId,
                sortId,
                tagDesc,
                textColor,
                bkgColor,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_StorylineTagDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_StorylineTagData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_StorylineTagData<'a> {
    type Inner = dict__string__clz_Torappu_StorylineTagData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_StorylineTagData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_StorylineTagData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_StorylineTagDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StorylineTagData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_StorylineTagDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_StorylineTagDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_StorylineTagDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_StorylineTagData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_StorylineTagData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_StorylineTagData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineTagData>>(
                    dict__string__clz_Torappu_StorylineTagData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_StorylineTagData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineTagData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_StorylineTagDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_StorylineTagData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_StorylineTagDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_StorylineTagDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_StorylineTagData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_StorylineTagData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_StorylineTagDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_StorylineTagDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_StorylineTagData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_StorylineTagData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StorylineTagData>>(
                dict__string__clz_Torappu_StorylineTagData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_StorylineTagDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_StorylineTagDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StorylineTagData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_StorylineTagData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_StorylineTagData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_StorylineTagData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_StorylineTagDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_StorylineTagDataT>>,
}
impl Default for dict__string__clz_Torappu_StorylineTagDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_StorylineTagDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StorylineTagData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_StorylineTagData::create(
            _fbb,
            &dict__string__clz_Torappu_StorylineTagDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_StorylineConstDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StorylineConstData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StorylineConstData<'a> {
    type Inner = clz_Torappu_StorylineConstData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StorylineConstData<'a> {
    pub const VT_RECOMMENDHIDEGUIDEGROUPID: flatbuffers::VOffsetT = 4;
    pub const VT_TUTORIALSELECTSTORYLINEID: flatbuffers::VOffsetT = 6;
    pub const VT_MAINLINESTORYLINEID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StorylineConstData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StorylineConstDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineConstData<'bldr>> {
        let mut builder = clz_Torappu_StorylineConstDataBuilder::new(_fbb);
        if let Some(x) = args.mainlineStorylineId {
            builder.add_mainlineStorylineId(x);
        }
        if let Some(x) = args.tutorialSelectStorylineId {
            builder.add_tutorialSelectStorylineId(x);
        }
        if let Some(x) = args.recommendHideGuideGroupId {
            builder.add_recommendHideGuideGroupId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StorylineConstDataT {
        let recommendHideGuideGroupId = self.recommendHideGuideGroupId().map(|x| x.to_string());
        let tutorialSelectStorylineId = self.tutorialSelectStorylineId().map(|x| x.to_string());
        let mainlineStorylineId = self.mainlineStorylineId().map(|x| x.to_string());
        clz_Torappu_StorylineConstDataT {
            recommendHideGuideGroupId,
            tutorialSelectStorylineId,
            mainlineStorylineId,
        }
    }

    #[inline]
    pub fn recommendHideGuideGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineConstData::VT_RECOMMENDHIDEGUIDEGROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn tutorialSelectStorylineId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineConstData::VT_TUTORIALSELECTSTORYLINEID,
                None,
            )
        }
    }
    #[inline]
    pub fn mainlineStorylineId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StorylineConstData::VT_MAINLINESTORYLINEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StorylineConstData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "recommendHideGuideGroupId",
                Self::VT_RECOMMENDHIDEGUIDEGROUPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tutorialSelectStorylineId",
                Self::VT_TUTORIALSELECTSTORYLINEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mainlineStorylineId",
                Self::VT_MAINLINESTORYLINEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StorylineConstDataArgs<'a> {
    pub recommendHideGuideGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tutorialSelectStorylineId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mainlineStorylineId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_StorylineConstDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StorylineConstDataArgs {
            recommendHideGuideGroupId: None,
            tutorialSelectStorylineId: None,
            mainlineStorylineId: None,
        }
    }
}

impl Serialize for clz_Torappu_StorylineConstData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StorylineConstData", 3)?;
        if let Some(f) = self.recommendHideGuideGroupId() {
            s.serialize_field("recommendHideGuideGroupId", &f)?;
        } else {
            s.skip_field("recommendHideGuideGroupId")?;
        }
        if let Some(f) = self.tutorialSelectStorylineId() {
            s.serialize_field("tutorialSelectStorylineId", &f)?;
        } else {
            s.skip_field("tutorialSelectStorylineId")?;
        }
        if let Some(f) = self.mainlineStorylineId() {
            s.serialize_field("mainlineStorylineId", &f)?;
        } else {
            s.skip_field("mainlineStorylineId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StorylineConstDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_StorylineConstDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_recommendHideGuideGroupId(
        &mut self,
        recommendHideGuideGroupId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineConstData::VT_RECOMMENDHIDEGUIDEGROUPID,
            recommendHideGuideGroupId,
        );
    }
    #[inline]
    pub fn add_tutorialSelectStorylineId(
        &mut self,
        tutorialSelectStorylineId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineConstData::VT_TUTORIALSELECTSTORYLINEID,
            tutorialSelectStorylineId,
        );
    }
    #[inline]
    pub fn add_mainlineStorylineId(
        &mut self,
        mainlineStorylineId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StorylineConstData::VT_MAINLINESTORYLINEID,
            mainlineStorylineId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StorylineConstDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StorylineConstDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StorylineConstData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StorylineConstData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StorylineConstData");
        ds.field(
            "recommendHideGuideGroupId",
            &self.recommendHideGuideGroupId(),
        );
        ds.field(
            "tutorialSelectStorylineId",
            &self.tutorialSelectStorylineId(),
        );
        ds.field("mainlineStorylineId", &self.mainlineStorylineId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StorylineConstDataT {
    pub recommendHideGuideGroupId: Option<String>,
    pub tutorialSelectStorylineId: Option<String>,
    pub mainlineStorylineId: Option<String>,
}
impl Default for clz_Torappu_StorylineConstDataT {
    fn default() -> Self {
        Self {
            recommendHideGuideGroupId: None,
            tutorialSelectStorylineId: None,
            mainlineStorylineId: None,
        }
    }
}
impl clz_Torappu_StorylineConstDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StorylineConstData<'b>> {
        let recommendHideGuideGroupId = self
            .recommendHideGuideGroupId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let tutorialSelectStorylineId = self
            .tutorialSelectStorylineId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let mainlineStorylineId = self
            .mainlineStorylineId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_StorylineConstData::create(
            _fbb,
            &clz_Torappu_StorylineConstDataArgs {
                recommendHideGuideGroupId,
                tutorialSelectStorylineId,
                mainlineStorylineId,
            },
        )
    }
}
pub enum clz_Torappu_SixStarRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SixStarRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SixStarRuneData<'a> {
    type Inner = clz_Torappu_SixStarRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SixStarRuneData<'a> {
    pub const VT_RUNEID: flatbuffers::VOffsetT = 4;
    pub const VT_RUNEDESC: flatbuffers::VOffsetT = 6;
    pub const VT_RUNEKEY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SixStarRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SixStarRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SixStarRuneData<'bldr>> {
        let mut builder = clz_Torappu_SixStarRuneDataBuilder::new(_fbb);
        if let Some(x) = args.runeKey {
            builder.add_runeKey(x);
        }
        if let Some(x) = args.runeDesc {
            builder.add_runeDesc(x);
        }
        if let Some(x) = args.runeId {
            builder.add_runeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SixStarRuneDataT {
        let runeId = self.runeId().map(|x| x.to_string());
        let runeDesc = self.runeDesc().map(|x| x.to_string());
        let runeKey = self.runeKey().map(|x| x.to_string());
        clz_Torappu_SixStarRuneDataT {
            runeId,
            runeDesc,
            runeKey,
        }
    }

    #[inline]
    pub fn runeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SixStarRuneData::VT_RUNEID,
                None,
            )
        }
    }
    #[inline]
    pub fn runeDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SixStarRuneData::VT_RUNEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn runeKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SixStarRuneData::VT_RUNEKEY,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SixStarRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("runeId", Self::VT_RUNEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "runeDesc",
                Self::VT_RUNEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("runeKey", Self::VT_RUNEKEY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SixStarRuneDataArgs<'a> {
    pub runeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub runeDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub runeKey: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SixStarRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SixStarRuneDataArgs {
            runeId: None,
            runeDesc: None,
            runeKey: None,
        }
    }
}

impl Serialize for clz_Torappu_SixStarRuneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SixStarRuneData", 3)?;
        if let Some(f) = self.runeId() {
            s.serialize_field("runeId", &f)?;
        } else {
            s.skip_field("runeId")?;
        }
        if let Some(f) = self.runeDesc() {
            s.serialize_field("runeDesc", &f)?;
        } else {
            s.skip_field("runeDesc")?;
        }
        if let Some(f) = self.runeKey() {
            s.serialize_field("runeKey", &f)?;
        } else {
            s.skip_field("runeKey")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SixStarRuneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_SixStarRuneDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_runeId(&mut self, runeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SixStarRuneData::VT_RUNEID,
            runeId,
        );
    }
    #[inline]
    pub fn add_runeDesc(&mut self, runeDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SixStarRuneData::VT_RUNEDESC,
            runeDesc,
        );
    }
    #[inline]
    pub fn add_runeKey(&mut self, runeKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SixStarRuneData::VT_RUNEKEY,
            runeKey,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SixStarRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SixStarRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SixStarRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SixStarRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SixStarRuneData");
        ds.field("runeId", &self.runeId());
        ds.field("runeDesc", &self.runeDesc());
        ds.field("runeKey", &self.runeKey());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SixStarRuneDataT {
    pub runeId: Option<String>,
    pub runeDesc: Option<String>,
    pub runeKey: Option<String>,
}
impl Default for clz_Torappu_SixStarRuneDataT {
    fn default() -> Self {
        Self {
            runeId: None,
            runeDesc: None,
            runeKey: None,
        }
    }
}
impl clz_Torappu_SixStarRuneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SixStarRuneData<'b>> {
        let runeId = self.runeId.as_ref().map(|x| _fbb.create_string(x));
        let runeDesc = self.runeDesc.as_ref().map(|x| _fbb.create_string(x));
        let runeKey = self.runeKey.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SixStarRuneData::create(
            _fbb,
            &clz_Torappu_SixStarRuneDataArgs {
                runeId,
                runeDesc,
                runeKey,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SixStarRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SixStarRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SixStarRuneData<'a> {
    type Inner = dict__string__clz_Torappu_SixStarRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SixStarRuneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SixStarRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SixStarRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SixStarRuneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SixStarRuneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SixStarRuneDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SixStarRuneDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SixStarRuneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_SixStarRuneData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SixStarRuneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SixStarRuneData>>(
                    dict__string__clz_Torappu_SixStarRuneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SixStarRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SixStarRuneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SixStarRuneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SixStarRuneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SixStarRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SixStarRuneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SixStarRuneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_SixStarRuneData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SixStarRuneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SixStarRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SixStarRuneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_SixStarRuneData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SixStarRuneData>>(
                dict__string__clz_Torappu_SixStarRuneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SixStarRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SixStarRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SixStarRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_SixStarRuneData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SixStarRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SixStarRuneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SixStarRuneDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SixStarRuneDataT>>,
}
impl Default for dict__string__clz_Torappu_SixStarRuneDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SixStarRuneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SixStarRuneData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SixStarRuneData::create(
            _fbb,
            &dict__string__clz_Torappu_SixStarRuneDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SixStarMilestoneItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SixStarMilestoneItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SixStarMilestoneItemData<'a> {
    type Inner = clz_Torappu_SixStarMilestoneItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SixStarMilestoneItemData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_NODEPOINT: flatbuffers::VOffsetT = 8;
    pub const VT_REWARDTYPE: flatbuffers::VOffsetT = 10;
    pub const VT_UNLOCKSTAGEFOG: flatbuffers::VOffsetT = 12;
    pub const VT_UNLOCKSTAGEID: flatbuffers::VOffsetT = 14;
    pub const VT_UNLOCKSTAGENAME: flatbuffers::VOffsetT = 16;
    pub const VT_REWARDLIST: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SixStarMilestoneItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SixStarMilestoneItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SixStarMilestoneItemData<'bldr>> {
        let mut builder = clz_Torappu_SixStarMilestoneItemDataBuilder::new(_fbb);
        if let Some(x) = args.rewardList {
            builder.add_rewardList(x);
        }
        if let Some(x) = args.unlockStageName {
            builder.add_unlockStageName(x);
        }
        if let Some(x) = args.unlockStageId {
            builder.add_unlockStageId(x);
        }
        if let Some(x) = args.unlockStageFog {
            builder.add_unlockStageFog(x);
        }
        builder.add_rewardType(args.rewardType);
        builder.add_nodePoint(args.nodePoint);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SixStarMilestoneItemDataT {
        let id = self.id().map(|x| x.to_string());
        let sortId = self.sortId();
        let nodePoint = self.nodePoint();
        let rewardType = self.rewardType();
        let unlockStageFog = self.unlockStageFog().map(|x| x.to_string());
        let unlockStageId = self.unlockStageId().map(|x| x.to_string());
        let unlockStageName = self.unlockStageName().map(|x| x.to_string());
        let rewardList = self
            .rewardList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SixStarMilestoneItemDataT {
            id,
            sortId,
            nodePoint,
            rewardType,
            unlockStageFog,
            unlockStageId,
            unlockStageName,
            rewardList,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SixStarMilestoneItemData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SixStarMilestoneItemData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn nodePoint(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SixStarMilestoneItemData::VT_NODEPOINT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn rewardType(&self) -> enum__Torappu_SixStarMilestoneRewardType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SixStarMilestoneRewardType>(
                    clz_Torappu_SixStarMilestoneItemData::VT_REWARDTYPE,
                    Some(enum__Torappu_SixStarMilestoneRewardType::UNLOCK_STAGE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockStageFog(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SixStarMilestoneItemData::VT_UNLOCKSTAGEFOG,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SixStarMilestoneItemData::VT_UNLOCKSTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockStageName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SixStarMilestoneItemData::VT_UNLOCKSTAGENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_SixStarMilestoneItemData::VT_REWARDLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SixStarMilestoneItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<i32>("nodePoint", Self::VT_NODEPOINT, false)?
            .visit_field::<enum__Torappu_SixStarMilestoneRewardType>(
                "rewardType",
                Self::VT_REWARDTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockStageFog",
                Self::VT_UNLOCKSTAGEFOG,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockStageId",
                Self::VT_UNLOCKSTAGEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockStageName",
                Self::VT_UNLOCKSTAGENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("rewardList", Self::VT_REWARDLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SixStarMilestoneItemDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub nodePoint: i32,
    pub rewardType: enum__Torappu_SixStarMilestoneRewardType,
    pub unlockStageFog: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockStageName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SixStarMilestoneItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SixStarMilestoneItemDataArgs {
            id: None,
            sortId: 0,
            nodePoint: 0,
            rewardType: enum__Torappu_SixStarMilestoneRewardType::UNLOCK_STAGE,
            unlockStageFog: None,
            unlockStageId: None,
            unlockStageName: None,
            rewardList: None,
        }
    }
}

impl Serialize for clz_Torappu_SixStarMilestoneItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SixStarMilestoneItemData", 8)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("nodePoint", &self.nodePoint())?;
        s.serialize_field("rewardType", &self.rewardType())?;
        if let Some(f) = self.unlockStageFog() {
            s.serialize_field("unlockStageFog", &f)?;
        } else {
            s.skip_field("unlockStageFog")?;
        }
        if let Some(f) = self.unlockStageId() {
            s.serialize_field("unlockStageId", &f)?;
        } else {
            s.skip_field("unlockStageId")?;
        }
        if let Some(f) = self.unlockStageName() {
            s.serialize_field("unlockStageName", &f)?;
        } else {
            s.skip_field("unlockStageName")?;
        }
        if let Some(f) = self.rewardList() {
            s.serialize_field("rewardList", &f)?;
        } else {
            s.skip_field("rewardList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SixStarMilestoneItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SixStarMilestoneItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SixStarMilestoneItemData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SixStarMilestoneItemData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_nodePoint(&mut self, nodePoint: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SixStarMilestoneItemData::VT_NODEPOINT,
            nodePoint,
            0,
        );
    }
    #[inline]
    pub fn add_rewardType(&mut self, rewardType: enum__Torappu_SixStarMilestoneRewardType) {
        self.fbb_
            .push_slot::<enum__Torappu_SixStarMilestoneRewardType>(
                clz_Torappu_SixStarMilestoneItemData::VT_REWARDTYPE,
                rewardType,
                enum__Torappu_SixStarMilestoneRewardType::UNLOCK_STAGE,
            );
    }
    #[inline]
    pub fn add_unlockStageFog(&mut self, unlockStageFog: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SixStarMilestoneItemData::VT_UNLOCKSTAGEFOG,
            unlockStageFog,
        );
    }
    #[inline]
    pub fn add_unlockStageId(&mut self, unlockStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SixStarMilestoneItemData::VT_UNLOCKSTAGEID,
            unlockStageId,
        );
    }
    #[inline]
    pub fn add_unlockStageName(&mut self, unlockStageName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SixStarMilestoneItemData::VT_UNLOCKSTAGENAME,
            unlockStageName,
        );
    }
    #[inline]
    pub fn add_rewardList(
        &mut self,
        rewardList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SixStarMilestoneItemData::VT_REWARDLIST,
            rewardList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SixStarMilestoneItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SixStarMilestoneItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SixStarMilestoneItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SixStarMilestoneItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SixStarMilestoneItemData");
        ds.field("id", &self.id());
        ds.field("sortId", &self.sortId());
        ds.field("nodePoint", &self.nodePoint());
        ds.field("rewardType", &self.rewardType());
        ds.field("unlockStageFog", &self.unlockStageFog());
        ds.field("unlockStageId", &self.unlockStageId());
        ds.field("unlockStageName", &self.unlockStageName());
        ds.field("rewardList", &self.rewardList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SixStarMilestoneItemDataT {
    pub id: Option<String>,
    pub sortId: i32,
    pub nodePoint: i32,
    pub rewardType: enum__Torappu_SixStarMilestoneRewardType,
    pub unlockStageFog: Option<String>,
    pub unlockStageId: Option<String>,
    pub unlockStageName: Option<String>,
    pub rewardList: Option<Vec<clz_Torappu_ItemBundleT>>,
}
impl Default for clz_Torappu_SixStarMilestoneItemDataT {
    fn default() -> Self {
        Self {
            id: None,
            sortId: 0,
            nodePoint: 0,
            rewardType: enum__Torappu_SixStarMilestoneRewardType::UNLOCK_STAGE,
            unlockStageFog: None,
            unlockStageId: None,
            unlockStageName: None,
            rewardList: None,
        }
    }
}
impl clz_Torappu_SixStarMilestoneItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SixStarMilestoneItemData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let nodePoint = self.nodePoint;
        let rewardType = self.rewardType;
        let unlockStageFog = self.unlockStageFog.as_ref().map(|x| _fbb.create_string(x));
        let unlockStageId = self.unlockStageId.as_ref().map(|x| _fbb.create_string(x));
        let unlockStageName = self.unlockStageName.as_ref().map(|x| _fbb.create_string(x));
        let rewardList = self.rewardList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SixStarMilestoneItemData::create(
            _fbb,
            &clz_Torappu_SixStarMilestoneItemDataArgs {
                id,
                sortId,
                nodePoint,
                rewardType,
                unlockStageFog,
                unlockStageId,
                unlockStageName,
                rewardList,
            },
        )
    }
}
pub enum clz_Torappu_SixStarMilestoneGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SixStarMilestoneGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SixStarMilestoneGroupData<'a> {
    type Inner = clz_Torappu_SixStarMilestoneGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SixStarMilestoneGroupData<'a> {
    pub const VT_GROUPID: flatbuffers::VOffsetT = 4;
    pub const VT_STAGEIDLIST: flatbuffers::VOffsetT = 6;
    pub const VT_MILESTONEDATALIST: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SixStarMilestoneGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SixStarMilestoneGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SixStarMilestoneGroupData<'bldr>> {
        let mut builder = clz_Torappu_SixStarMilestoneGroupDataBuilder::new(_fbb);
        if let Some(x) = args.milestoneDataList {
            builder.add_milestoneDataList(x);
        }
        if let Some(x) = args.stageIdList {
            builder.add_stageIdList(x);
        }
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SixStarMilestoneGroupDataT {
        let groupId = self.groupId().map(|x| x.to_string());
        let stageIdList = self
            .stageIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let milestoneDataList = self
            .milestoneDataList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SixStarMilestoneGroupDataT {
            groupId,
            stageIdList,
            milestoneDataList,
        }
    }

    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SixStarMilestoneGroupData::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn stageIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_SixStarMilestoneGroupData::VT_STAGEIDLIST, None)
        }
    }
    #[inline]
    pub fn milestoneDataList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SixStarMilestoneItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SixStarMilestoneItemData>,
                >,
            >>(
                clz_Torappu_SixStarMilestoneGroupData::VT_MILESTONEDATALIST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SixStarMilestoneGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("stageIdList", Self::VT_STAGEIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SixStarMilestoneItemData>,
                >,
            >>("milestoneDataList", Self::VT_MILESTONEDATALIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SixStarMilestoneGroupDataArgs<'a> {
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stageIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub milestoneDataList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SixStarMilestoneItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SixStarMilestoneGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SixStarMilestoneGroupDataArgs {
            groupId: None,
            stageIdList: None,
            milestoneDataList: None,
        }
    }
}

impl Serialize for clz_Torappu_SixStarMilestoneGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SixStarMilestoneGroupData", 3)?;
        if let Some(f) = self.groupId() {
            s.serialize_field("groupId", &f)?;
        } else {
            s.skip_field("groupId")?;
        }
        if let Some(f) = self.stageIdList() {
            s.serialize_field("stageIdList", &f)?;
        } else {
            s.skip_field("stageIdList")?;
        }
        if let Some(f) = self.milestoneDataList() {
            s.serialize_field("milestoneDataList", &f)?;
        } else {
            s.skip_field("milestoneDataList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SixStarMilestoneGroupDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SixStarMilestoneGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SixStarMilestoneGroupData::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_stageIdList(
        &mut self,
        stageIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SixStarMilestoneGroupData::VT_STAGEIDLIST,
            stageIdList,
        );
    }
    #[inline]
    pub fn add_milestoneDataList(
        &mut self,
        milestoneDataList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SixStarMilestoneItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SixStarMilestoneGroupData::VT_MILESTONEDATALIST,
            milestoneDataList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SixStarMilestoneGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SixStarMilestoneGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SixStarMilestoneGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SixStarMilestoneGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SixStarMilestoneGroupData");
        ds.field("groupId", &self.groupId());
        ds.field("stageIdList", &self.stageIdList());
        ds.field("milestoneDataList", &self.milestoneDataList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SixStarMilestoneGroupDataT {
    pub groupId: Option<String>,
    pub stageIdList: Option<Vec<String>>,
    pub milestoneDataList: Option<Vec<clz_Torappu_SixStarMilestoneItemDataT>>,
}
impl Default for clz_Torappu_SixStarMilestoneGroupDataT {
    fn default() -> Self {
        Self {
            groupId: None,
            stageIdList: None,
            milestoneDataList: None,
        }
    }
}
impl clz_Torappu_SixStarMilestoneGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SixStarMilestoneGroupData<'b>> {
        let groupId = self.groupId.as_ref().map(|x| _fbb.create_string(x));
        let stageIdList = self.stageIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let milestoneDataList = self.milestoneDataList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SixStarMilestoneGroupData::create(
            _fbb,
            &clz_Torappu_SixStarMilestoneGroupDataArgs {
                groupId,
                stageIdList,
                milestoneDataList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SixStarMilestoneGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SixStarMilestoneGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SixStarMilestoneGroupData<'a> {
    type Inner = dict__string__clz_Torappu_SixStarMilestoneGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SixStarMilestoneGroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SixStarMilestoneGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SixStarMilestoneGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SixStarMilestoneGroupData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SixStarMilestoneGroupDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SixStarMilestoneGroupDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SixStarMilestoneGroupDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SixStarMilestoneGroupData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SixStarMilestoneGroupData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SixStarMilestoneGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SixStarMilestoneGroupData>>(
                    dict__string__clz_Torappu_SixStarMilestoneGroupData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SixStarMilestoneGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SixStarMilestoneGroupData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SixStarMilestoneGroupDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SixStarMilestoneGroupData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SixStarMilestoneGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SixStarMilestoneGroupDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SixStarMilestoneGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SixStarMilestoneGroupData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SixStarMilestoneGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SixStarMilestoneGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SixStarMilestoneGroupData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SixStarMilestoneGroupData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SixStarMilestoneGroupData>>(
                dict__string__clz_Torappu_SixStarMilestoneGroupData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SixStarMilestoneGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SixStarMilestoneGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SixStarMilestoneGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SixStarMilestoneGroupData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SixStarMilestoneGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SixStarMilestoneGroupData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SixStarMilestoneGroupDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SixStarMilestoneGroupDataT>>,
}
impl Default for dict__string__clz_Torappu_SixStarMilestoneGroupDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SixStarMilestoneGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SixStarMilestoneGroupData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SixStarMilestoneGroupData::create(
            _fbb,
            &dict__string__clz_Torappu_SixStarMilestoneGroupDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SixStarLinkedStageCompatibleInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SixStarLinkedStageCompatibleInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SixStarLinkedStageCompatibleInfo<'a> {
    type Inner = clz_Torappu_SixStarLinkedStageCompatibleInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SixStarLinkedStageCompatibleInfo<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_APCOST: flatbuffers::VOffsetT = 6;
    pub const VT_APFAILRETURN: flatbuffers::VOffsetT = 8;
    pub const VT_DROPTYPE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SixStarLinkedStageCompatibleInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SixStarLinkedStageCompatibleInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SixStarLinkedStageCompatibleInfo<'bldr>> {
        let mut builder = clz_Torappu_SixStarLinkedStageCompatibleInfoBuilder::new(_fbb);
        builder.add_dropType(args.dropType);
        builder.add_apFailReturn(args.apFailReturn);
        builder.add_apCost(args.apCost);
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SixStarLinkedStageCompatibleInfoT {
        let stageId = self.stageId().map(|x| x.to_string());
        let apCost = self.apCost();
        let apFailReturn = self.apFailReturn();
        let dropType = self.dropType();
        clz_Torappu_SixStarLinkedStageCompatibleInfoT {
            stageId,
            apCost,
            apFailReturn,
            dropType,
        }
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SixStarLinkedStageCompatibleInfo::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn apCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SixStarLinkedStageCompatibleInfo::VT_APCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn apFailReturn(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SixStarLinkedStageCompatibleInfo::VT_APFAILRETURN,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn dropType(&self) -> enum__Torappu_SixStarStageCompatibleDropType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SixStarStageCompatibleDropType>(
                    clz_Torappu_SixStarLinkedStageCompatibleInfo::VT_DROPTYPE,
                    Some(enum__Torappu_SixStarStageCompatibleDropType::COMPLETE_ONLY),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SixStarLinkedStageCompatibleInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<i32>("apCost", Self::VT_APCOST, false)?
            .visit_field::<i32>("apFailReturn", Self::VT_APFAILRETURN, false)?
            .visit_field::<enum__Torappu_SixStarStageCompatibleDropType>(
                "dropType",
                Self::VT_DROPTYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SixStarLinkedStageCompatibleInfoArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub apCost: i32,
    pub apFailReturn: i32,
    pub dropType: enum__Torappu_SixStarStageCompatibleDropType,
}
impl<'a> Default for clz_Torappu_SixStarLinkedStageCompatibleInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SixStarLinkedStageCompatibleInfoArgs {
            stageId: None,
            apCost: 0,
            apFailReturn: 0,
            dropType: enum__Torappu_SixStarStageCompatibleDropType::COMPLETE_ONLY,
        }
    }
}

impl Serialize for clz_Torappu_SixStarLinkedStageCompatibleInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SixStarLinkedStageCompatibleInfo", 4)?;
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        s.serialize_field("apCost", &self.apCost())?;
        s.serialize_field("apFailReturn", &self.apFailReturn())?;
        s.serialize_field("dropType", &self.dropType())?;
        s.end()
    }
}

pub struct clz_Torappu_SixStarLinkedStageCompatibleInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SixStarLinkedStageCompatibleInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SixStarLinkedStageCompatibleInfo::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_apCost(&mut self, apCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SixStarLinkedStageCompatibleInfo::VT_APCOST,
            apCost,
            0,
        );
    }
    #[inline]
    pub fn add_apFailReturn(&mut self, apFailReturn: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SixStarLinkedStageCompatibleInfo::VT_APFAILRETURN,
            apFailReturn,
            0,
        );
    }
    #[inline]
    pub fn add_dropType(&mut self, dropType: enum__Torappu_SixStarStageCompatibleDropType) {
        self.fbb_
            .push_slot::<enum__Torappu_SixStarStageCompatibleDropType>(
                clz_Torappu_SixStarLinkedStageCompatibleInfo::VT_DROPTYPE,
                dropType,
                enum__Torappu_SixStarStageCompatibleDropType::COMPLETE_ONLY,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SixStarLinkedStageCompatibleInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SixStarLinkedStageCompatibleInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SixStarLinkedStageCompatibleInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SixStarLinkedStageCompatibleInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SixStarLinkedStageCompatibleInfo");
        ds.field("stageId", &self.stageId());
        ds.field("apCost", &self.apCost());
        ds.field("apFailReturn", &self.apFailReturn());
        ds.field("dropType", &self.dropType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SixStarLinkedStageCompatibleInfoT {
    pub stageId: Option<String>,
    pub apCost: i32,
    pub apFailReturn: i32,
    pub dropType: enum__Torappu_SixStarStageCompatibleDropType,
}
impl Default for clz_Torappu_SixStarLinkedStageCompatibleInfoT {
    fn default() -> Self {
        Self {
            stageId: None,
            apCost: 0,
            apFailReturn: 0,
            dropType: enum__Torappu_SixStarStageCompatibleDropType::COMPLETE_ONLY,
        }
    }
}
impl clz_Torappu_SixStarLinkedStageCompatibleInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SixStarLinkedStageCompatibleInfo<'b>> {
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let apCost = self.apCost;
        let apFailReturn = self.apFailReturn;
        let dropType = self.dropType;
        clz_Torappu_SixStarLinkedStageCompatibleInfo::create(
            _fbb,
            &clz_Torappu_SixStarLinkedStageCompatibleInfoArgs {
                stageId,
                apCost,
                apFailReturn,
                dropType,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo<'a>
{
    type Inner = dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SixStarLinkedStageCompatibleInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SixStarLinkedStageCompatibleInfo>>(
                    dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SixStarLinkedStageCompatibleInfo>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SixStarLinkedStageCompatibleInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SixStarLinkedStageCompatibleInfo<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SixStarLinkedStageCompatibleInfo>>(dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SixStarLinkedStageCompatibleInfoT>>,
}
impl Default for dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo::create(
            _fbb,
            &dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ConditionalDropInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ConditionalDropInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ConditionalDropInfo<'a> {
    type Inner = clz_Torappu_ConditionalDropInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ConditionalDropInfo<'a> {
    pub const VT_TEMPLATE: flatbuffers::VOffsetT = 4;
    pub const VT_PARAM: flatbuffers::VOffsetT = 6;
    pub const VT_COUNTLIMIT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ConditionalDropInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ConditionalDropInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ConditionalDropInfo<'bldr>> {
        let mut builder = clz_Torappu_ConditionalDropInfoBuilder::new(_fbb);
        builder.add_countLimit(args.countLimit);
        if let Some(x) = args.param {
            builder.add_param(x);
        }
        if let Some(x) = args.template {
            builder.add_template(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ConditionalDropInfoT {
        let template = self.template().map(|x| x.to_string());
        let param = self
            .param()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let countLimit = self.countLimit();
        clz_Torappu_ConditionalDropInfoT {
            template,
            param,
            countLimit,
        }
    }

    #[inline]
    pub fn template(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ConditionalDropInfo::VT_TEMPLATE,
                None,
            )
        }
    }
    #[inline]
    pub fn param(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_ConditionalDropInfo::VT_PARAM, None)
        }
    }
    #[inline]
    pub fn countLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ConditionalDropInfo::VT_COUNTLIMIT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ConditionalDropInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "template",
                Self::VT_TEMPLATE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("param", Self::VT_PARAM, false)?
            .visit_field::<i32>("countLimit", Self::VT_COUNTLIMIT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ConditionalDropInfoArgs<'a> {
    pub template: Option<flatbuffers::WIPOffset<&'a str>>,
    pub param: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub countLimit: i32,
}
impl<'a> Default for clz_Torappu_ConditionalDropInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ConditionalDropInfoArgs {
            template: None,
            param: None,
            countLimit: 0,
        }
    }
}

impl Serialize for clz_Torappu_ConditionalDropInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ConditionalDropInfo", 3)?;
        if let Some(f) = self.template() {
            s.serialize_field("template", &f)?;
        } else {
            s.skip_field("template")?;
        }
        if let Some(f) = self.param() {
            s.serialize_field("param", &f)?;
        } else {
            s.skip_field("param")?;
        }
        s.serialize_field("countLimit", &self.countLimit())?;
        s.end()
    }
}

pub struct clz_Torappu_ConditionalDropInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ConditionalDropInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_template(&mut self, template: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ConditionalDropInfo::VT_TEMPLATE,
            template,
        );
    }
    #[inline]
    pub fn add_param(
        &mut self,
        param: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ConditionalDropInfo::VT_PARAM,
            param,
        );
    }
    #[inline]
    pub fn add_countLimit(&mut self, countLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ConditionalDropInfo::VT_COUNTLIMIT,
            countLimit,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ConditionalDropInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ConditionalDropInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ConditionalDropInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ConditionalDropInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ConditionalDropInfo");
        ds.field("template", &self.template());
        ds.field("param", &self.param());
        ds.field("countLimit", &self.countLimit());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ConditionalDropInfoT {
    pub template: Option<String>,
    pub param: Option<Vec<String>>,
    pub countLimit: i32,
}
impl Default for clz_Torappu_ConditionalDropInfoT {
    fn default() -> Self {
        Self {
            template: None,
            param: None,
            countLimit: 0,
        }
    }
}
impl clz_Torappu_ConditionalDropInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ConditionalDropInfo<'b>> {
        let template = self.template.as_ref().map(|x| _fbb.create_string(x));
        let param = self.param.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let countLimit = self.countLimit;
        clz_Torappu_ConditionalDropInfo::create(
            _fbb,
            &clz_Torappu_ConditionalDropInfoArgs {
                template,
                param,
                countLimit,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ConditionalDropInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ConditionalDropInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ConditionalDropInfo<'a> {
    type Inner = dict__string__clz_Torappu_ConditionalDropInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ConditionalDropInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ConditionalDropInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ConditionalDropInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ConditionalDropInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ConditionalDropInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ConditionalDropInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ConditionalDropInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ConditionalDropInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_ConditionalDropInfo) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ConditionalDropInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ConditionalDropInfo>>(
                    dict__string__clz_Torappu_ConditionalDropInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ConditionalDropInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ConditionalDropInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ConditionalDropInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ConditionalDropInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ConditionalDropInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ConditionalDropInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ConditionalDropInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ConditionalDropInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ConditionalDropInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ConditionalDropInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ConditionalDropInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ConditionalDropInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ConditionalDropInfo>>(
                dict__string__clz_Torappu_ConditionalDropInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ConditionalDropInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ConditionalDropInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ConditionalDropInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ConditionalDropInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ConditionalDropInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ConditionalDropInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ConditionalDropInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ConditionalDropInfoT>>,
}
impl Default for dict__string__clz_Torappu_ConditionalDropInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ConditionalDropInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ConditionalDropInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ConditionalDropInfo::create(
            _fbb,
            &dict__string__clz_Torappu_ConditionalDropInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_StageTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageTable<'a> {
    type Inner = clz_Torappu_StageTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageTable<'a> {
    pub const VT_STAGES: flatbuffers::VOffsetT = 4;
    pub const VT_RUNESTAGEGROUPS: flatbuffers::VOffsetT = 6;
    pub const VT_MAPTHEMES: flatbuffers::VOffsetT = 8;
    pub const VT_TILEINFO: flatbuffers::VOffsetT = 10;
    pub const VT_FORCEOPENTABLE: flatbuffers::VOffsetT = 12;
    pub const VT_TIMELYSTAGEDROPINFO: flatbuffers::VOffsetT = 14;
    pub const VT_OVERRIDEDROPINFO: flatbuffers::VOffsetT = 16;
    pub const VT_OVERRIDEUNLOCKINFO: flatbuffers::VOffsetT = 18;
    pub const VT_TIMELYTABLE: flatbuffers::VOffsetT = 20;
    pub const VT_STAGEVALIDINFO: flatbuffers::VOffsetT = 22;
    pub const VT_STAGEFOGINFO: flatbuffers::VOffsetT = 24;
    pub const VT_STAGESTARTCONDS: flatbuffers::VOffsetT = 26;
    pub const VT_DIFFGROUPTABLE: flatbuffers::VOffsetT = 28;
    pub const VT_STORYSTAGESHOWGROUP: flatbuffers::VOffsetT = 30;
    pub const VT_SPECIALBATTLEFINISHSTAGEDATA: flatbuffers::VOffsetT = 32;
    pub const VT_RECORDREWARDDATA: flatbuffers::VOffsetT = 34;
    pub const VT_APPROTECTZONEINFO: flatbuffers::VOffsetT = 36;
    pub const VT_ANTISPOILERDICT: flatbuffers::VOffsetT = 38;
    pub const VT_ACTCUSTOMSTAGEDATAS: flatbuffers::VOffsetT = 40;
    pub const VT_SPNORMALSTAGEIDFOR4STARLIST: flatbuffers::VOffsetT = 42;
    pub const VT_STORYLINES: flatbuffers::VOffsetT = 44;
    pub const VT_STORYLINESTORYSETS: flatbuffers::VOffsetT = 46;
    pub const VT_STORYLINETAGS: flatbuffers::VOffsetT = 48;
    pub const VT_STORYLINECONST: flatbuffers::VOffsetT = 50;
    pub const VT_SIXSTARRUNEDATA: flatbuffers::VOffsetT = 52;
    pub const VT_SIXSTARMILESTONEINFO: flatbuffers::VOffsetT = 54;
    pub const VT_SIXSTARCOMPATIBLEINFO: flatbuffers::VOffsetT = 56;
    pub const VT_CONDITIONALDROPINFO: flatbuffers::VOffsetT = 58;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageTable<'bldr>> {
        let mut builder = clz_Torappu_StageTableBuilder::new(_fbb);
        if let Some(x) = args.conditionalDropInfo {
            builder.add_conditionalDropInfo(x);
        }
        if let Some(x) = args.sixStarCompatibleInfo {
            builder.add_sixStarCompatibleInfo(x);
        }
        if let Some(x) = args.sixStarMilestoneInfo {
            builder.add_sixStarMilestoneInfo(x);
        }
        if let Some(x) = args.sixStarRuneData {
            builder.add_sixStarRuneData(x);
        }
        if let Some(x) = args.storylineConst {
            builder.add_storylineConst(x);
        }
        if let Some(x) = args.storylineTags {
            builder.add_storylineTags(x);
        }
        if let Some(x) = args.storylineStorySets {
            builder.add_storylineStorySets(x);
        }
        if let Some(x) = args.storylines {
            builder.add_storylines(x);
        }
        if let Some(x) = args.spNormalStageIdFor4StarList {
            builder.add_spNormalStageIdFor4StarList(x);
        }
        if let Some(x) = args.actCustomStageDatas {
            builder.add_actCustomStageDatas(x);
        }
        if let Some(x) = args.antiSpoilerDict {
            builder.add_antiSpoilerDict(x);
        }
        if let Some(x) = args.apProtectZoneInfo {
            builder.add_apProtectZoneInfo(x);
        }
        if let Some(x) = args.recordRewardData {
            builder.add_recordRewardData(x);
        }
        if let Some(x) = args.specialBattleFinishStageData {
            builder.add_specialBattleFinishStageData(x);
        }
        if let Some(x) = args.storyStageShowGroup {
            builder.add_storyStageShowGroup(x);
        }
        if let Some(x) = args.diffGroupTable {
            builder.add_diffGroupTable(x);
        }
        if let Some(x) = args.stageStartConds {
            builder.add_stageStartConds(x);
        }
        if let Some(x) = args.stageFogInfo {
            builder.add_stageFogInfo(x);
        }
        if let Some(x) = args.stageValidInfo {
            builder.add_stageValidInfo(x);
        }
        if let Some(x) = args.timelyTable {
            builder.add_timelyTable(x);
        }
        if let Some(x) = args.overrideUnlockInfo {
            builder.add_overrideUnlockInfo(x);
        }
        if let Some(x) = args.overrideDropInfo {
            builder.add_overrideDropInfo(x);
        }
        if let Some(x) = args.timelyStageDropInfo {
            builder.add_timelyStageDropInfo(x);
        }
        if let Some(x) = args.forceOpenTable {
            builder.add_forceOpenTable(x);
        }
        if let Some(x) = args.tileInfo {
            builder.add_tileInfo(x);
        }
        if let Some(x) = args.mapThemes {
            builder.add_mapThemes(x);
        }
        if let Some(x) = args.runeStageGroups {
            builder.add_runeStageGroups(x);
        }
        if let Some(x) = args.stages {
            builder.add_stages(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageTableT {
        let stages = self
            .stages()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let runeStageGroups = self
            .runeStageGroups()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let mapThemes = self
            .mapThemes()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let tileInfo = self
            .tileInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let forceOpenTable = self
            .forceOpenTable()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let timelyStageDropInfo = self
            .timelyStageDropInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let overrideDropInfo = self
            .overrideDropInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let overrideUnlockInfo = self
            .overrideUnlockInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let timelyTable = self
            .timelyTable()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let stageValidInfo = self
            .stageValidInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let stageFogInfo = self
            .stageFogInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let stageStartConds = self
            .stageStartConds()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let diffGroupTable = self
            .diffGroupTable()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let storyStageShowGroup = self
            .storyStageShowGroup()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let specialBattleFinishStageData = self
            .specialBattleFinishStageData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let recordRewardData = self
            .recordRewardData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let apProtectZoneInfo = self
            .apProtectZoneInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let antiSpoilerDict = self
            .antiSpoilerDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let actCustomStageDatas = self
            .actCustomStageDatas()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let spNormalStageIdFor4StarList = self
            .spNormalStageIdFor4StarList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let storylines = self
            .storylines()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let storylineStorySets = self
            .storylineStorySets()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let storylineTags = self
            .storylineTags()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let storylineConst = self.storylineConst().map(|x| Box::new(x.unpack()));
        let sixStarRuneData = self
            .sixStarRuneData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let sixStarMilestoneInfo = self
            .sixStarMilestoneInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let sixStarCompatibleInfo = self
            .sixStarCompatibleInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let conditionalDropInfo = self
            .conditionalDropInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_StageTableT {
            stages,
            runeStageGroups,
            mapThemes,
            tileInfo,
            forceOpenTable,
            timelyStageDropInfo,
            overrideDropInfo,
            overrideUnlockInfo,
            timelyTable,
            stageValidInfo,
            stageFogInfo,
            stageStartConds,
            diffGroupTable,
            storyStageShowGroup,
            specialBattleFinishStageData,
            recordRewardData,
            apProtectZoneInfo,
            antiSpoilerDict,
            actCustomStageDatas,
            spNormalStageIdFor4StarList,
            storylines,
            storylineStorySets,
            storylineTags,
            storylineConst,
            sixStarRuneData,
            sixStarMilestoneInfo,
            sixStarCompatibleInfo,
            conditionalDropInfo,
        }
    }

    #[inline]
    pub fn stages(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData>,
                >,
            >>(clz_Torappu_StageTable::VT_STAGES, None)
        }
    }
    #[inline]
    pub fn runeStageGroups(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RuneStageGroupData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RuneStageGroupData>,
                >,
            >>(clz_Torappu_StageTable::VT_RUNESTAGEGROUPS, None)
        }
    }
    #[inline]
    pub fn mapThemes(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MapThemeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MapThemeData>,
                >,
            >>(clz_Torappu_StageTable::VT_MAPTHEMES, None)
        }
    }
    #[inline]
    pub fn tileInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TileAppendInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TileAppendInfo>,
                >,
            >>(clz_Torappu_StageTable::VT_TILEINFO, None)
        }
    }
    #[inline]
    pub fn forceOpenTable(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_WeeklyForceOpenTable<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_WeeklyForceOpenTable>,
                >,
            >>(clz_Torappu_StageTable::VT_FORCEOPENTABLE, None)
        }
    }
    #[inline]
    pub fn timelyStageDropInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TimelyDropTimeInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TimelyDropTimeInfo>,
                >,
            >>(clz_Torappu_StageTable::VT_TIMELYSTAGEDROPINFO, None)
        }
    }
    #[inline]
    pub fn overrideDropInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_OverrideDropInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_OverrideDropInfo>,
                >,
            >>(clz_Torappu_StageTable::VT_OVERRIDEDROPINFO, None)
        }
    }
    #[inline]
    pub fn overrideUnlockInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_OverrideUnlockInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_OverrideUnlockInfo>,
                >,
            >>(clz_Torappu_StageTable::VT_OVERRIDEUNLOCKINFO, None)
        }
    }
    #[inline]
    pub fn timelyTable(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TimelyDropInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TimelyDropInfo>,
                >,
            >>(clz_Torappu_StageTable::VT_TIMELYTABLE, None)
        }
    }
    #[inline]
    pub fn stageValidInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageValidInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageValidInfo>,
                >,
            >>(clz_Torappu_StageTable::VT_STAGEVALIDINFO, None)
        }
    }
    #[inline]
    pub fn stageFogInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageFogInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageFogInfo>,
                >,
            >>(clz_Torappu_StageTable::VT_STAGEFOGINFO, None)
        }
    }
    #[inline]
    pub fn stageStartConds(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageStartCond<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageStartCond>,
                >,
            >>(clz_Torappu_StageTable::VT_STAGESTARTCONDS, None)
        }
    }
    #[inline]
    pub fn diffGroupTable(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageDiffGroupTable<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageDiffGroupTable>,
                >,
            >>(clz_Torappu_StageTable::VT_DIFFGROUPTABLE, None)
        }
    }
    #[inline]
    pub fn storyStageShowGroup(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'a>>>>{
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup>>>>(clz_Torappu_StageTable::VT_STORYSTAGESHOWGROUP, None)
        }
    }
    #[inline]
    pub fn specialBattleFinishStageData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SpecialBattleFinishStageData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialBattleFinishStageData,
                    >,
                >,
            >>(
                clz_Torappu_StageTable::VT_SPECIALBATTLEFINISHSTAGEDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn recordRewardData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RecordRewardServerData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RecordRewardServerData>,
                >,
            >>(clz_Torappu_StageTable::VT_RECORDREWARDDATA, None)
        }
    }
    #[inline]
    pub fn apProtectZoneInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ApProtectZoneInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ApProtectZoneInfo>,
                >,
            >>(clz_Torappu_StageTable::VT_APPROTECTZONEINFO, None)
        }
    }
    #[inline]
    pub fn antiSpoilerDict(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string>>,
            >>(clz_Torappu_StageTable::VT_ANTISPOILERDICT, None)
        }
    }
    #[inline]
    pub fn actCustomStageDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActCustomStageData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActCustomStageData>,
                >,
            >>(clz_Torappu_StageTable::VT_ACTCUSTOMSTAGEDATAS, None)
        }
    }
    #[inline]
    pub fn spNormalStageIdFor4StarList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_StageTable::VT_SPNORMALSTAGEIDFOR4STARLIST, None)
        }
    }
    #[inline]
    pub fn storylines(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineData>,
                >,
            >>(clz_Torappu_StageTable::VT_STORYLINES, None)
        }
    }
    #[inline]
    pub fn storylineStorySets(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineStorySetData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineStorySetData>,
                >,
            >>(clz_Torappu_StageTable::VT_STORYLINESTORYSETS, None)
        }
    }
    #[inline]
    pub fn storylineTags(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineTagData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineTagData>,
                >,
            >>(clz_Torappu_StageTable::VT_STORYLINETAGS, None)
        }
    }
    #[inline]
    pub fn storylineConst(&self) -> Option<clz_Torappu_StorylineConstData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineConstData>>(
                    clz_Torappu_StageTable::VT_STORYLINECONST,
                    None,
                )
        }
    }
    #[inline]
    pub fn sixStarRuneData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SixStarRuneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SixStarRuneData>,
                >,
            >>(clz_Torappu_StageTable::VT_SIXSTARRUNEDATA, None)
        }
    }
    #[inline]
    pub fn sixStarMilestoneInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SixStarMilestoneGroupData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SixStarMilestoneGroupData,
                    >,
                >,
            >>(clz_Torappu_StageTable::VT_SIXSTARMILESTONEINFO, None)
        }
    }
    #[inline]
    pub fn sixStarCompatibleInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo,
                    >,
                >,
            >>(clz_Torappu_StageTable::VT_SIXSTARCOMPATIBLEINFO, None)
        }
    }
    #[inline]
    pub fn conditionalDropInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ConditionalDropInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ConditionalDropInfo>,
                >,
            >>(clz_Torappu_StageTable::VT_CONDITIONALDROPINFO, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData>>>>("stages", Self::VT_STAGES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RuneStageGroupData>>>>("runeStageGroups", Self::VT_RUNESTAGEGROUPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MapThemeData>>>>("mapThemes", Self::VT_MAPTHEMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TileAppendInfo>>>>("tileInfo", Self::VT_TILEINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_WeeklyForceOpenTable>>>>("forceOpenTable", Self::VT_FORCEOPENTABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TimelyDropTimeInfo>>>>("timelyStageDropInfo", Self::VT_TIMELYSTAGEDROPINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_OverrideDropInfo>>>>("overrideDropInfo", Self::VT_OVERRIDEDROPINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_OverrideUnlockInfo>>>>("overrideUnlockInfo", Self::VT_OVERRIDEUNLOCKINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TimelyDropInfo>>>>("timelyTable", Self::VT_TIMELYTABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageValidInfo>>>>("stageValidInfo", Self::VT_STAGEVALIDINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageFogInfo>>>>("stageFogInfo", Self::VT_STAGEFOGINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageStartCond>>>>("stageStartConds", Self::VT_STAGESTARTCONDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageDiffGroupTable>>>>("diffGroupTable", Self::VT_DIFFGROUPTABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup>>>>("storyStageShowGroup", Self::VT_STORYSTAGESHOWGROUP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SpecialBattleFinishStageData>>>>("specialBattleFinishStageData", Self::VT_SPECIALBATTLEFINISHSTAGEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RecordRewardServerData>>>>("recordRewardData", Self::VT_RECORDREWARDDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ApProtectZoneInfo>>>>("apProtectZoneInfo", Self::VT_APPROTECTZONEINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_string>>>>("antiSpoilerDict", Self::VT_ANTISPOILERDICT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActCustomStageData>>>>("actCustomStageDatas", Self::VT_ACTCUSTOMSTAGEDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("spNormalStageIdFor4StarList", Self::VT_SPNORMALSTAGEIDFOR4STARLIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineData>>>>("storylines", Self::VT_STORYLINES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineStorySetData>>>>("storylineStorySets", Self::VT_STORYLINESTORYSETS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineTagData>>>>("storylineTags", Self::VT_STORYLINETAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StorylineConstData>>("storylineConst", Self::VT_STORYLINECONST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SixStarRuneData>>>>("sixStarRuneData", Self::VT_SIXSTARRUNEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SixStarMilestoneGroupData>>>>("sixStarMilestoneInfo", Self::VT_SIXSTARMILESTONEINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo>>>>("sixStarCompatibleInfo", Self::VT_SIXSTARCOMPATIBLEINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ConditionalDropInfo>>>>("conditionalDropInfo", Self::VT_CONDITIONALDROPINFO, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageTableArgs<'a> {
    pub stages: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData<'a>>>>>,
    pub runeStageGroups: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RuneStageGroupData<'a>>>>>,
    pub mapThemes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MapThemeData<'a>>>>>,
    pub tileInfo: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TileAppendInfo<'a>>>>>,
    pub forceOpenTable: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_WeeklyForceOpenTable<'a>>>>>,
    pub timelyStageDropInfo: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TimelyDropTimeInfo<'a>>>>>,
    pub overrideDropInfo: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_OverrideDropInfo<'a>>>>>,
    pub overrideUnlockInfo: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_OverrideUnlockInfo<'a>>>>>,
    pub timelyTable: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TimelyDropInfo<'a>>>>>,
    pub stageValidInfo: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageValidInfo<'a>>>>>,
    pub stageFogInfo: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageFogInfo<'a>>>>>,
    pub stageStartConds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageStartCond<'a>>>>>,
    pub diffGroupTable: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageDiffGroupTable<'a>>>>>,
    pub storyStageShowGroup: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'a>>>>>,
    pub specialBattleFinishStageData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SpecialBattleFinishStageData<'a>>>>>,
    pub recordRewardData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RecordRewardServerData<'a>>>>>,
    pub apProtectZoneInfo: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ApProtectZoneInfo<'a>>>>>,
    pub antiSpoilerDict: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>>>,
    pub actCustomStageDatas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActCustomStageData<'a>>>>>,
    pub spNormalStageIdFor4StarList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub storylines: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineData<'a>>>>>,
    pub storylineStorySets: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineStorySetData<'a>>>>>,
    pub storylineTags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineTagData<'a>>>>>,
    pub storylineConst: Option<flatbuffers::WIPOffset<clz_Torappu_StorylineConstData<'a>>>,
    pub sixStarRuneData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SixStarRuneData<'a>>>>>,
    pub sixStarMilestoneInfo: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SixStarMilestoneGroupData<'a>>>>>,
    pub sixStarCompatibleInfo: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo<'a>>>>>,
    pub conditionalDropInfo: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ConditionalDropInfo<'a>>>>>,
}
impl<'a> Default for clz_Torappu_StageTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageTableArgs {
            stages: None,
            runeStageGroups: None,
            mapThemes: None,
            tileInfo: None,
            forceOpenTable: None,
            timelyStageDropInfo: None,
            overrideDropInfo: None,
            overrideUnlockInfo: None,
            timelyTable: None,
            stageValidInfo: None,
            stageFogInfo: None,
            stageStartConds: None,
            diffGroupTable: None,
            storyStageShowGroup: None,
            specialBattleFinishStageData: None,
            recordRewardData: None,
            apProtectZoneInfo: None,
            antiSpoilerDict: None,
            actCustomStageDatas: None,
            spNormalStageIdFor4StarList: None,
            storylines: None,
            storylineStorySets: None,
            storylineTags: None,
            storylineConst: None,
            sixStarRuneData: None,
            sixStarMilestoneInfo: None,
            sixStarCompatibleInfo: None,
            conditionalDropInfo: None,
        }
    }
}

impl Serialize for clz_Torappu_StageTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageTable", 28)?;
        if let Some(f) = self.stages() {
            s.serialize_field("stages", &f)?;
        } else {
            s.skip_field("stages")?;
        }
        if let Some(f) = self.runeStageGroups() {
            s.serialize_field("runeStageGroups", &f)?;
        } else {
            s.skip_field("runeStageGroups")?;
        }
        if let Some(f) = self.mapThemes() {
            s.serialize_field("mapThemes", &f)?;
        } else {
            s.skip_field("mapThemes")?;
        }
        if let Some(f) = self.tileInfo() {
            s.serialize_field("tileInfo", &f)?;
        } else {
            s.skip_field("tileInfo")?;
        }
        if let Some(f) = self.forceOpenTable() {
            s.serialize_field("forceOpenTable", &f)?;
        } else {
            s.skip_field("forceOpenTable")?;
        }
        if let Some(f) = self.timelyStageDropInfo() {
            s.serialize_field("timelyStageDropInfo", &f)?;
        } else {
            s.skip_field("timelyStageDropInfo")?;
        }
        if let Some(f) = self.overrideDropInfo() {
            s.serialize_field("overrideDropInfo", &f)?;
        } else {
            s.skip_field("overrideDropInfo")?;
        }
        if let Some(f) = self.overrideUnlockInfo() {
            s.serialize_field("overrideUnlockInfo", &f)?;
        } else {
            s.skip_field("overrideUnlockInfo")?;
        }
        if let Some(f) = self.timelyTable() {
            s.serialize_field("timelyTable", &f)?;
        } else {
            s.skip_field("timelyTable")?;
        }
        if let Some(f) = self.stageValidInfo() {
            s.serialize_field("stageValidInfo", &f)?;
        } else {
            s.skip_field("stageValidInfo")?;
        }
        if let Some(f) = self.stageFogInfo() {
            s.serialize_field("stageFogInfo", &f)?;
        } else {
            s.skip_field("stageFogInfo")?;
        }
        if let Some(f) = self.stageStartConds() {
            s.serialize_field("stageStartConds", &f)?;
        } else {
            s.skip_field("stageStartConds")?;
        }
        if let Some(f) = self.diffGroupTable() {
            s.serialize_field("diffGroupTable", &f)?;
        } else {
            s.skip_field("diffGroupTable")?;
        }
        if let Some(f) = self.storyStageShowGroup() {
            s.serialize_field("storyStageShowGroup", &f)?;
        } else {
            s.skip_field("storyStageShowGroup")?;
        }
        if let Some(f) = self.specialBattleFinishStageData() {
            s.serialize_field("specialBattleFinishStageData", &f)?;
        } else {
            s.skip_field("specialBattleFinishStageData")?;
        }
        if let Some(f) = self.recordRewardData() {
            s.serialize_field("recordRewardData", &f)?;
        } else {
            s.skip_field("recordRewardData")?;
        }
        if let Some(f) = self.apProtectZoneInfo() {
            s.serialize_field("apProtectZoneInfo", &f)?;
        } else {
            s.skip_field("apProtectZoneInfo")?;
        }
        if let Some(f) = self.antiSpoilerDict() {
            s.serialize_field("antiSpoilerDict", &f)?;
        } else {
            s.skip_field("antiSpoilerDict")?;
        }
        if let Some(f) = self.actCustomStageDatas() {
            s.serialize_field("actCustomStageDatas", &f)?;
        } else {
            s.skip_field("actCustomStageDatas")?;
        }
        if let Some(f) = self.spNormalStageIdFor4StarList() {
            s.serialize_field("spNormalStageIdFor4StarList", &f)?;
        } else {
            s.skip_field("spNormalStageIdFor4StarList")?;
        }
        if let Some(f) = self.storylines() {
            s.serialize_field("storylines", &f)?;
        } else {
            s.skip_field("storylines")?;
        }
        if let Some(f) = self.storylineStorySets() {
            s.serialize_field("storylineStorySets", &f)?;
        } else {
            s.skip_field("storylineStorySets")?;
        }
        if let Some(f) = self.storylineTags() {
            s.serialize_field("storylineTags", &f)?;
        } else {
            s.skip_field("storylineTags")?;
        }
        if let Some(f) = self.storylineConst() {
            s.serialize_field("storylineConst", &f)?;
        } else {
            s.skip_field("storylineConst")?;
        }
        if let Some(f) = self.sixStarRuneData() {
            s.serialize_field("sixStarRuneData", &f)?;
        } else {
            s.skip_field("sixStarRuneData")?;
        }
        if let Some(f) = self.sixStarMilestoneInfo() {
            s.serialize_field("sixStarMilestoneInfo", &f)?;
        } else {
            s.skip_field("sixStarMilestoneInfo")?;
        }
        if let Some(f) = self.sixStarCompatibleInfo() {
            s.serialize_field("sixStarCompatibleInfo", &f)?;
        } else {
            s.skip_field("sixStarCompatibleInfo")?;
        }
        if let Some(f) = self.conditionalDropInfo() {
            s.serialize_field("conditionalDropInfo", &f)?;
        } else {
            s.skip_field("conditionalDropInfo")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StageTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_StageTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_stages(
        &mut self,
        stages: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_STAGES,
            stages,
        );
    }
    #[inline]
    pub fn add_runeStageGroups(
        &mut self,
        runeStageGroups: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RuneStageGroupData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_RUNESTAGEGROUPS,
            runeStageGroups,
        );
    }
    #[inline]
    pub fn add_mapThemes(
        &mut self,
        mapThemes: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MapThemeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_MAPTHEMES,
            mapThemes,
        );
    }
    #[inline]
    pub fn add_tileInfo(
        &mut self,
        tileInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TileAppendInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_TILEINFO,
            tileInfo,
        );
    }
    #[inline]
    pub fn add_forceOpenTable(
        &mut self,
        forceOpenTable: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_WeeklyForceOpenTable<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_FORCEOPENTABLE,
            forceOpenTable,
        );
    }
    #[inline]
    pub fn add_timelyStageDropInfo(
        &mut self,
        timelyStageDropInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TimelyDropTimeInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_TIMELYSTAGEDROPINFO,
            timelyStageDropInfo,
        );
    }
    #[inline]
    pub fn add_overrideDropInfo(
        &mut self,
        overrideDropInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_OverrideDropInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_OVERRIDEDROPINFO,
            overrideDropInfo,
        );
    }
    #[inline]
    pub fn add_overrideUnlockInfo(
        &mut self,
        overrideUnlockInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_OverrideUnlockInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_OVERRIDEUNLOCKINFO,
            overrideUnlockInfo,
        );
    }
    #[inline]
    pub fn add_timelyTable(
        &mut self,
        timelyTable: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_TimelyDropInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_TIMELYTABLE,
            timelyTable,
        );
    }
    #[inline]
    pub fn add_stageValidInfo(
        &mut self,
        stageValidInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageValidInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_STAGEVALIDINFO,
            stageValidInfo,
        );
    }
    #[inline]
    pub fn add_stageFogInfo(
        &mut self,
        stageFogInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageFogInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_STAGEFOGINFO,
            stageFogInfo,
        );
    }
    #[inline]
    pub fn add_stageStartConds(
        &mut self,
        stageStartConds: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageStartCond<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_STAGESTARTCONDS,
            stageStartConds,
        );
    }
    #[inline]
    pub fn add_diffGroupTable(
        &mut self,
        diffGroupTable: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageDiffGroupTable<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_DIFFGROUPTABLE,
            diffGroupTable,
        );
    }
    #[inline]
    pub fn add_storyStageShowGroup(
        &mut self,
        storyStageShowGroup: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroup<'b >>>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_STORYSTAGESHOWGROUP,
            storyStageShowGroup,
        );
    }
    #[inline]
    pub fn add_specialBattleFinishStageData(
        &mut self,
        specialBattleFinishStageData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialBattleFinishStageData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_SPECIALBATTLEFINISHSTAGEDATA,
            specialBattleFinishStageData,
        );
    }
    #[inline]
    pub fn add_recordRewardData(
        &mut self,
        recordRewardData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RecordRewardServerData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_RECORDREWARDDATA,
            recordRewardData,
        );
    }
    #[inline]
    pub fn add_apProtectZoneInfo(
        &mut self,
        apProtectZoneInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ApProtectZoneInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_APPROTECTZONEINFO,
            apProtectZoneInfo,
        );
    }
    #[inline]
    pub fn add_antiSpoilerDict(
        &mut self,
        antiSpoilerDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__list_string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_ANTISPOILERDICT,
            antiSpoilerDict,
        );
    }
    #[inline]
    pub fn add_actCustomStageDatas(
        &mut self,
        actCustomStageDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActCustomStageData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_ACTCUSTOMSTAGEDATAS,
            actCustomStageDatas,
        );
    }
    #[inline]
    pub fn add_spNormalStageIdFor4StarList(
        &mut self,
        spNormalStageIdFor4StarList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_SPNORMALSTAGEIDFOR4STARLIST,
            spNormalStageIdFor4StarList,
        );
    }
    #[inline]
    pub fn add_storylines(
        &mut self,
        storylines: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_STORYLINES,
            storylines,
        );
    }
    #[inline]
    pub fn add_storylineStorySets(
        &mut self,
        storylineStorySets: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineStorySetData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_STORYLINESTORYSETS,
            storylineStorySets,
        );
    }
    #[inline]
    pub fn add_storylineTags(
        &mut self,
        storylineTags: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StorylineTagData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_STORYLINETAGS,
            storylineTags,
        );
    }
    #[inline]
    pub fn add_storylineConst(
        &mut self,
        storylineConst: flatbuffers::WIPOffset<clz_Torappu_StorylineConstData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StorylineConstData>>(
                clz_Torappu_StageTable::VT_STORYLINECONST,
                storylineConst,
            );
    }
    #[inline]
    pub fn add_sixStarRuneData(
        &mut self,
        sixStarRuneData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SixStarRuneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_SIXSTARRUNEDATA,
            sixStarRuneData,
        );
    }
    #[inline]
    pub fn add_sixStarMilestoneInfo(
        &mut self,
        sixStarMilestoneInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SixStarMilestoneGroupData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_SIXSTARMILESTONEINFO,
            sixStarMilestoneInfo,
        );
    }
    #[inline]
    pub fn add_sixStarCompatibleInfo(
        &mut self,
        sixStarCompatibleInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfo<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_SIXSTARCOMPATIBLEINFO,
            sixStarCompatibleInfo,
        );
    }
    #[inline]
    pub fn add_conditionalDropInfo(
        &mut self,
        conditionalDropInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ConditionalDropInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageTable::VT_CONDITIONALDROPINFO,
            conditionalDropInfo,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageTable");
        ds.field("stages", &self.stages());
        ds.field("runeStageGroups", &self.runeStageGroups());
        ds.field("mapThemes", &self.mapThemes());
        ds.field("tileInfo", &self.tileInfo());
        ds.field("forceOpenTable", &self.forceOpenTable());
        ds.field("timelyStageDropInfo", &self.timelyStageDropInfo());
        ds.field("overrideDropInfo", &self.overrideDropInfo());
        ds.field("overrideUnlockInfo", &self.overrideUnlockInfo());
        ds.field("timelyTable", &self.timelyTable());
        ds.field("stageValidInfo", &self.stageValidInfo());
        ds.field("stageFogInfo", &self.stageFogInfo());
        ds.field("stageStartConds", &self.stageStartConds());
        ds.field("diffGroupTable", &self.diffGroupTable());
        ds.field("storyStageShowGroup", &self.storyStageShowGroup());
        ds.field(
            "specialBattleFinishStageData",
            &self.specialBattleFinishStageData(),
        );
        ds.field("recordRewardData", &self.recordRewardData());
        ds.field("apProtectZoneInfo", &self.apProtectZoneInfo());
        ds.field("antiSpoilerDict", &self.antiSpoilerDict());
        ds.field("actCustomStageDatas", &self.actCustomStageDatas());
        ds.field(
            "spNormalStageIdFor4StarList",
            &self.spNormalStageIdFor4StarList(),
        );
        ds.field("storylines", &self.storylines());
        ds.field("storylineStorySets", &self.storylineStorySets());
        ds.field("storylineTags", &self.storylineTags());
        ds.field("storylineConst", &self.storylineConst());
        ds.field("sixStarRuneData", &self.sixStarRuneData());
        ds.field("sixStarMilestoneInfo", &self.sixStarMilestoneInfo());
        ds.field("sixStarCompatibleInfo", &self.sixStarCompatibleInfo());
        ds.field("conditionalDropInfo", &self.conditionalDropInfo());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageTableT {
    pub stages: Option<Vec<dict__string__clz_Torappu_StageDataT>>,
    pub runeStageGroups: Option<Vec<dict__string__clz_Torappu_RuneStageGroupDataT>>,
    pub mapThemes: Option<Vec<dict__string__clz_Torappu_MapThemeDataT>>,
    pub tileInfo: Option<Vec<dict__string__clz_Torappu_TileAppendInfoT>>,
    pub forceOpenTable: Option<Vec<dict__string__clz_Torappu_WeeklyForceOpenTableT>>,
    pub timelyStageDropInfo: Option<Vec<dict__string__clz_Torappu_TimelyDropTimeInfoT>>,
    pub overrideDropInfo: Option<Vec<dict__string__clz_Torappu_OverrideDropInfoT>>,
    pub overrideUnlockInfo: Option<Vec<dict__string__clz_Torappu_OverrideUnlockInfoT>>,
    pub timelyTable: Option<Vec<dict__string__clz_Torappu_TimelyDropInfoT>>,
    pub stageValidInfo: Option<Vec<dict__string__clz_Torappu_StageValidInfoT>>,
    pub stageFogInfo: Option<Vec<dict__string__clz_Torappu_StageFogInfoT>>,
    pub stageStartConds: Option<Vec<dict__string__clz_Torappu_StageStartCondT>>,
    pub diffGroupTable: Option<Vec<dict__string__clz_Torappu_StageDiffGroupTableT>>,
    pub storyStageShowGroup: Option<
        Vec<
            dict__string__list_dict__enum__Torappu_StageDiffGroup__clz_Torappu_StoryStageShowGroupT,
        >,
    >,
    pub specialBattleFinishStageData:
        Option<Vec<dict__string__clz_Torappu_SpecialBattleFinishStageDataT>>,
    pub recordRewardData: Option<Vec<dict__string__clz_Torappu_RecordRewardServerDataT>>,
    pub apProtectZoneInfo: Option<Vec<dict__string__clz_Torappu_ApProtectZoneInfoT>>,
    pub antiSpoilerDict: Option<Vec<dict__string__list_stringT>>,
    pub actCustomStageDatas: Option<Vec<dict__string__clz_Torappu_ActCustomStageDataT>>,
    pub spNormalStageIdFor4StarList: Option<Vec<String>>,
    pub storylines: Option<Vec<dict__string__clz_Torappu_StorylineDataT>>,
    pub storylineStorySets: Option<Vec<dict__string__clz_Torappu_StorylineStorySetDataT>>,
    pub storylineTags: Option<Vec<dict__string__clz_Torappu_StorylineTagDataT>>,
    pub storylineConst: Option<Box<clz_Torappu_StorylineConstDataT>>,
    pub sixStarRuneData: Option<Vec<dict__string__clz_Torappu_SixStarRuneDataT>>,
    pub sixStarMilestoneInfo: Option<Vec<dict__string__clz_Torappu_SixStarMilestoneGroupDataT>>,
    pub sixStarCompatibleInfo:
        Option<Vec<dict__string__clz_Torappu_SixStarLinkedStageCompatibleInfoT>>,
    pub conditionalDropInfo: Option<Vec<dict__string__clz_Torappu_ConditionalDropInfoT>>,
}
impl Default for clz_Torappu_StageTableT {
    fn default() -> Self {
        Self {
            stages: None,
            runeStageGroups: None,
            mapThemes: None,
            tileInfo: None,
            forceOpenTable: None,
            timelyStageDropInfo: None,
            overrideDropInfo: None,
            overrideUnlockInfo: None,
            timelyTable: None,
            stageValidInfo: None,
            stageFogInfo: None,
            stageStartConds: None,
            diffGroupTable: None,
            storyStageShowGroup: None,
            specialBattleFinishStageData: None,
            recordRewardData: None,
            apProtectZoneInfo: None,
            antiSpoilerDict: None,
            actCustomStageDatas: None,
            spNormalStageIdFor4StarList: None,
            storylines: None,
            storylineStorySets: None,
            storylineTags: None,
            storylineConst: None,
            sixStarRuneData: None,
            sixStarMilestoneInfo: None,
            sixStarCompatibleInfo: None,
            conditionalDropInfo: None,
        }
    }
}
impl clz_Torappu_StageTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageTable<'b>> {
        let stages = self.stages.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let runeStageGroups = self.runeStageGroups.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let mapThemes = self.mapThemes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let tileInfo = self.tileInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let forceOpenTable = self.forceOpenTable.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let timelyStageDropInfo = self.timelyStageDropInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let overrideDropInfo = self.overrideDropInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let overrideUnlockInfo = self.overrideUnlockInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let timelyTable = self.timelyTable.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let stageValidInfo = self.stageValidInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let stageFogInfo = self.stageFogInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let stageStartConds = self.stageStartConds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let diffGroupTable = self.diffGroupTable.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let storyStageShowGroup = self.storyStageShowGroup.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let specialBattleFinishStageData = self.specialBattleFinishStageData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let recordRewardData = self.recordRewardData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let apProtectZoneInfo = self.apProtectZoneInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let antiSpoilerDict = self.antiSpoilerDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let actCustomStageDatas = self.actCustomStageDatas.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let spNormalStageIdFor4StarList = self.spNormalStageIdFor4StarList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let storylines = self.storylines.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let storylineStorySets = self.storylineStorySets.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let storylineTags = self.storylineTags.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let storylineConst = self.storylineConst.as_ref().map(|x| x.pack(_fbb));
        let sixStarRuneData = self.sixStarRuneData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let sixStarMilestoneInfo = self.sixStarMilestoneInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let sixStarCompatibleInfo = self.sixStarCompatibleInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let conditionalDropInfo = self.conditionalDropInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_StageTable::create(
            _fbb,
            &clz_Torappu_StageTableArgs {
                stages,
                runeStageGroups,
                mapThemes,
                tileInfo,
                forceOpenTable,
                timelyStageDropInfo,
                overrideDropInfo,
                overrideUnlockInfo,
                timelyTable,
                stageValidInfo,
                stageFogInfo,
                stageStartConds,
                diffGroupTable,
                storyStageShowGroup,
                specialBattleFinishStageData,
                recordRewardData,
                apProtectZoneInfo,
                antiSpoilerDict,
                actCustomStageDatas,
                spNormalStageIdFor4StarList,
                storylines,
                storylineStorySets,
                storylineTags,
                storylineConst,
                sixStarRuneData,
                sixStarMilestoneInfo,
                sixStarCompatibleInfo,
                conditionalDropInfo,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_StageTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_stage_table_unchecked`.
pub fn root_as_clz_torappu_stage_table(
    buf: &[u8],
) -> Result<clz_Torappu_StageTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_StageTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_StageTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_stage_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_stage_table(
    buf: &[u8],
) -> Result<clz_Torappu_StageTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_StageTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_StageTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_stage_table_unchecked`.
pub fn root_as_clz_torappu_stage_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_StageTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_StageTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_StageTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_stage_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_stage_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_StageTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_StageTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_StageTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_StageTable`.
pub unsafe fn root_as_clz_torappu_stage_table_unchecked(buf: &[u8]) -> clz_Torappu_StageTable {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_StageTable>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_StageTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_StageTable`.
pub unsafe fn size_prefixed_root_as_clz_torappu_stage_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_StageTable {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_StageTable>(buf) }
}
#[inline]
pub fn finish_clz_torappu_stage_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_StageTable<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_stage_table_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_StageTable<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
