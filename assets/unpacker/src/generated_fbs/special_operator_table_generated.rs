// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SPECIAL_OPERATOR_TARGET_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SPECIAL_OPERATOR_TARGET_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SPECIAL_OPERATOR_TARGET_TYPE:
    [enum__Torappu_SpecialOperatorTargetType; 2] = [
    enum__Torappu_SpecialOperatorTargetType::NONE,
    enum__Torappu_SpecialOperatorTargetType::ROGUE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SpecialOperatorTargetType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SpecialOperatorTargetType {
    pub const NONE: Self = Self(0);
    pub const ROGUE: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::ROGUE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ROGUE => Some("ROGUE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SpecialOperatorTargetType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SpecialOperatorTargetType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SpecialOperatorTargetType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SpecialOperatorTargetType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SpecialOperatorTargetType {
    type Output = enum__Torappu_SpecialOperatorTargetType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SpecialOperatorTargetType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SpecialOperatorTargetType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SpecialOperatorTargetType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SPECIAL_OPERATOR_DETAIL_NODE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SPECIAL_OPERATOR_DETAIL_NODE_TYPE: i32 = 5;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SPECIAL_OPERATOR_DETAIL_NODE_TYPE:
    [enum__Torappu_SpecialOperatorDetailNodeType; 6] = [
    enum__Torappu_SpecialOperatorDetailNodeType::NONE,
    enum__Torappu_SpecialOperatorDetailNodeType::EVOLVE,
    enum__Torappu_SpecialOperatorDetailNodeType::SKILL,
    enum__Torappu_SpecialOperatorDetailNodeType::TALENT,
    enum__Torappu_SpecialOperatorDetailNodeType::MASTER,
    enum__Torappu_SpecialOperatorDetailNodeType::UNIEQUIP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SpecialOperatorDetailNodeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SpecialOperatorDetailNodeType {
    pub const NONE: Self = Self(0);
    pub const EVOLVE: Self = Self(1);
    pub const SKILL: Self = Self(2);
    pub const TALENT: Self = Self(3);
    pub const MASTER: Self = Self(4);
    pub const UNIEQUIP: Self = Self(5);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 5;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::EVOLVE,
        Self::SKILL,
        Self::TALENT,
        Self::MASTER,
        Self::UNIEQUIP,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::EVOLVE => Some("EVOLVE"),
            Self::SKILL => Some("SKILL"),
            Self::TALENT => Some("TALENT"),
            Self::MASTER => Some("MASTER"),
            Self::UNIEQUIP => Some("UNIEQUIP"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SpecialOperatorDetailNodeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SpecialOperatorDetailNodeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SpecialOperatorDetailNodeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SpecialOperatorDetailNodeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SpecialOperatorDetailNodeType {
    type Output = enum__Torappu_SpecialOperatorDetailNodeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SpecialOperatorDetailNodeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SpecialOperatorDetailNodeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SpecialOperatorDetailNodeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_EVOLVE_PHASE: [enum__Torappu_EvolvePhase; 5] = [
    enum__Torappu_EvolvePhase::PHASE_0,
    enum__Torappu_EvolvePhase::PHASE_1,
    enum__Torappu_EvolvePhase::PHASE_2,
    enum__Torappu_EvolvePhase::PHASE_3,
    enum__Torappu_EvolvePhase::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EvolvePhase(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EvolvePhase {
    pub const PHASE_0: Self = Self(0);
    pub const PHASE_1: Self = Self(1);
    pub const PHASE_2: Self = Self(2);
    pub const PHASE_3: Self = Self(3);
    pub const E_NUM: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::PHASE_0,
        Self::PHASE_1,
        Self::PHASE_2,
        Self::PHASE_3,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::PHASE_0 => Some("PHASE_0"),
            Self::PHASE_1 => Some("PHASE_1"),
            Self::PHASE_2 => Some("PHASE_2"),
            Self::PHASE_3 => Some("PHASE_3"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EvolvePhase {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_EvolvePhase {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_EvolvePhase",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EvolvePhase {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EvolvePhase {
    type Output = enum__Torappu_EvolvePhase;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EvolvePhase {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EvolvePhase {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EvolvePhase {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SPECIAL_OPERATOR_CONDITION_VIEW_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SPECIAL_OPERATOR_CONDITION_VIEW_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SPECIAL_OPERATOR_CONDITION_VIEW_TYPE:
    [enum__Torappu_SpecialOperatorConditionViewType; 2] = [
    enum__Torappu_SpecialOperatorConditionViewType::TASK,
    enum__Torappu_SpecialOperatorConditionViewType::EVOLVEPHASE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SpecialOperatorConditionViewType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SpecialOperatorConditionViewType {
    pub const TASK: Self = Self(0);
    pub const EVOLVEPHASE: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::TASK, Self::EVOLVEPHASE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::TASK => Some("TASK"),
            Self::EVOLVEPHASE => Some("EVOLVEPHASE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SpecialOperatorConditionViewType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SpecialOperatorConditionViewType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SpecialOperatorConditionViewType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SpecialOperatorConditionViewType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SpecialOperatorConditionViewType {
    type Output = enum__Torappu_SpecialOperatorConditionViewType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SpecialOperatorConditionViewType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SpecialOperatorConditionViewType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SpecialOperatorConditionViewType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_MISSION_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_MISSION_TYPE: i32 = 11;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_MISSION_TYPE: [enum__Torappu_MissionType; 12] = [
    enum__Torappu_MissionType::UNKNOWN,
    enum__Torappu_MissionType::MAIN,
    enum__Torappu_MissionType::DAILY,
    enum__Torappu_MissionType::WEEKLY,
    enum__Torappu_MissionType::GUIDE,
    enum__Torappu_MissionType::SUB,
    enum__Torappu_MissionType::ACTIVITY,
    enum__Torappu_MissionType::OPENSERVER,
    enum__Torappu_MissionType::TOWERSEASON,
    enum__Torappu_MissionType::RETRO,
    enum__Torappu_MissionType::SPECIAL_OPERATOR,
    enum__Torappu_MissionType::SPECIAL_OPERATOR_WEEKLY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_MissionType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_MissionType {
    pub const UNKNOWN: Self = Self(0);
    pub const MAIN: Self = Self(1);
    pub const DAILY: Self = Self(2);
    pub const WEEKLY: Self = Self(3);
    pub const GUIDE: Self = Self(4);
    pub const SUB: Self = Self(5);
    pub const ACTIVITY: Self = Self(6);
    pub const OPENSERVER: Self = Self(7);
    pub const TOWERSEASON: Self = Self(8);
    pub const RETRO: Self = Self(9);
    pub const SPECIAL_OPERATOR: Self = Self(10);
    pub const SPECIAL_OPERATOR_WEEKLY: Self = Self(11);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 11;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::UNKNOWN,
        Self::MAIN,
        Self::DAILY,
        Self::WEEKLY,
        Self::GUIDE,
        Self::SUB,
        Self::ACTIVITY,
        Self::OPENSERVER,
        Self::TOWERSEASON,
        Self::RETRO,
        Self::SPECIAL_OPERATOR,
        Self::SPECIAL_OPERATOR_WEEKLY,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::UNKNOWN => Some("UNKNOWN"),
            Self::MAIN => Some("MAIN"),
            Self::DAILY => Some("DAILY"),
            Self::WEEKLY => Some("WEEKLY"),
            Self::GUIDE => Some("GUIDE"),
            Self::SUB => Some("SUB"),
            Self::ACTIVITY => Some("ACTIVITY"),
            Self::OPENSERVER => Some("OPENSERVER"),
            Self::TOWERSEASON => Some("TOWERSEASON"),
            Self::RETRO => Some("RETRO"),
            Self::SPECIAL_OPERATOR => Some("SPECIAL_OPERATOR"),
            Self::SPECIAL_OPERATOR_WEEKLY => Some("SPECIAL_OPERATOR_WEEKLY"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_MissionType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_MissionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_MissionType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_MissionType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_MissionType {
    type Output = enum__Torappu_MissionType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_MissionType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_MissionType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_MissionType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_MISSION_ITEM_BG_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_MISSION_ITEM_BG_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_MISSION_ITEM_BG_TYPE: [enum__Torappu_MissionItemBgType; 3] = [
    enum__Torappu_MissionItemBgType::COMMON,
    enum__Torappu_MissionItemBgType::Equipment,
    enum__Torappu_MissionItemBgType::Char,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_MissionItemBgType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_MissionItemBgType {
    pub const COMMON: Self = Self(0);
    pub const Equipment: Self = Self(1);
    pub const Char: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::COMMON, Self::Equipment, Self::Char];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::COMMON => Some("COMMON"),
            Self::Equipment => Some("Equipment"),
            Self::Char => Some("Char"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_MissionItemBgType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_MissionItemBgType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_MissionItemBgType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_MissionItemBgType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_MissionItemBgType {
    type Output = enum__Torappu_MissionItemBgType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_MissionItemBgType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_MissionItemBgType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_MissionItemBgType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_TYPE: i32 = 90;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_TYPE: [enum__Torappu_ItemType; 91] = [
    enum__Torappu_ItemType::NONE,
    enum__Torappu_ItemType::CHAR,
    enum__Torappu_ItemType::CARD_EXP,
    enum__Torappu_ItemType::MATERIAL,
    enum__Torappu_ItemType::GOLD,
    enum__Torappu_ItemType::EXP_PLAYER,
    enum__Torappu_ItemType::TKT_TRY,
    enum__Torappu_ItemType::TKT_RECRUIT,
    enum__Torappu_ItemType::TKT_INST_FIN,
    enum__Torappu_ItemType::TKT_GACHA,
    enum__Torappu_ItemType::ACTIVITY_COIN,
    enum__Torappu_ItemType::DIAMOND,
    enum__Torappu_ItemType::DIAMOND_SHD,
    enum__Torappu_ItemType::HGG_SHD,
    enum__Torappu_ItemType::LGG_SHD,
    enum__Torappu_ItemType::FURN,
    enum__Torappu_ItemType::AP_GAMEPLAY,
    enum__Torappu_ItemType::AP_BASE,
    enum__Torappu_ItemType::SOCIAL_PT,
    enum__Torappu_ItemType::CHAR_SKIN,
    enum__Torappu_ItemType::TKT_GACHA_10,
    enum__Torappu_ItemType::TKT_GACHA_PRSV,
    enum__Torappu_ItemType::AP_ITEM,
    enum__Torappu_ItemType::AP_SUPPLY,
    enum__Torappu_ItemType::RENAMING_CARD,
    enum__Torappu_ItemType::RENAMING_CARD_2,
    enum__Torappu_ItemType::ET_STAGE,
    enum__Torappu_ItemType::ACTIVITY_ITEM,
    enum__Torappu_ItemType::VOUCHER_PICK,
    enum__Torappu_ItemType::VOUCHER_CGACHA,
    enum__Torappu_ItemType::VOUCHER_MGACHA,
    enum__Torappu_ItemType::CRS_SHOP_COIN,
    enum__Torappu_ItemType::CRS_RUNE_COIN,
    enum__Torappu_ItemType::LMTGS_COIN,
    enum__Torappu_ItemType::EPGS_COIN,
    enum__Torappu_ItemType::LIMITED_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_FREE_GACHA,
    enum__Torappu_ItemType::REP_COIN,
    enum__Torappu_ItemType::ROGUELIKE,
    enum__Torappu_ItemType::LINKAGE_TKT_GACHA_10,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_4,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_5,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_6,
    enum__Torappu_ItemType::VOUCHER_SKIN,
    enum__Torappu_ItemType::RETRO_COIN,
    enum__Torappu_ItemType::PLAYER_AVATAR,
    enum__Torappu_ItemType::UNI_COLLECTION,
    enum__Torappu_ItemType::VOUCHER_FULL_POTENTIAL,
    enum__Torappu_ItemType::RL_COIN,
    enum__Torappu_ItemType::RETURN_CREDIT,
    enum__Torappu_ItemType::MEDAL,
    enum__Torappu_ItemType::CHARM,
    enum__Torappu_ItemType::HOME_BACKGROUND,
    enum__Torappu_ItemType::EXTERMINATION_AGENT,
    enum__Torappu_ItemType::OPTIONAL_VOUCHER_PICK,
    enum__Torappu_ItemType::ACT_CART_COMPONENT,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_4,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_4,
    enum__Torappu_ItemType::ACTIVITY_POTENTIAL,
    enum__Torappu_ItemType::ITEM_PACK,
    enum__Torappu_ItemType::SANDBOX,
    enum__Torappu_ItemType::FAVOR_ADD_ITEM,
    enum__Torappu_ItemType::CLASSIC_SHD,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_BUFF,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_5,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_6,
    enum__Torappu_ItemType::RETURN_PROGRESS,
    enum__Torappu_ItemType::NEW_PROGRESS,
    enum__Torappu_ItemType::MCARD_VOUCHER,
    enum__Torappu_ItemType::MATERIAL_ISSUE_VOUCHER,
    enum__Torappu_ItemType::CRS_SHOP_COIN_V2,
    enum__Torappu_ItemType::HOME_THEME,
    enum__Torappu_ItemType::SANDBOX_PERM,
    enum__Torappu_ItemType::SANDBOX_TOKEN,
    enum__Torappu_ItemType::TEMPLATE_TRAP,
    enum__Torappu_ItemType::NAME_CARD_SKIN,
    enum__Torappu_ItemType::EMOTICON_SET,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA_10,
    enum__Torappu_ItemType::SO_CHAR_EXP,
    enum__Torappu_ItemType::GIFTPACKAGE_TKT,
    enum__Torappu_ItemType::VOUCHER_SKIN_V2,
    enum__Torappu_ItemType::RANDOM_VOUCHER_SKIN,
    enum__Torappu_ItemType::ACT1VHALFIDLE_ITEM,
    enum__Torappu_ItemType::PLOT_ITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemType {
    pub const NONE: Self = Self(0);
    pub const CHAR: Self = Self(1);
    pub const CARD_EXP: Self = Self(2);
    pub const MATERIAL: Self = Self(3);
    pub const GOLD: Self = Self(4);
    pub const EXP_PLAYER: Self = Self(5);
    pub const TKT_TRY: Self = Self(6);
    pub const TKT_RECRUIT: Self = Self(7);
    pub const TKT_INST_FIN: Self = Self(8);
    pub const TKT_GACHA: Self = Self(9);
    pub const ACTIVITY_COIN: Self = Self(10);
    pub const DIAMOND: Self = Self(11);
    pub const DIAMOND_SHD: Self = Self(12);
    pub const HGG_SHD: Self = Self(13);
    pub const LGG_SHD: Self = Self(14);
    pub const FURN: Self = Self(15);
    pub const AP_GAMEPLAY: Self = Self(16);
    pub const AP_BASE: Self = Self(17);
    pub const SOCIAL_PT: Self = Self(18);
    pub const CHAR_SKIN: Self = Self(19);
    pub const TKT_GACHA_10: Self = Self(20);
    pub const TKT_GACHA_PRSV: Self = Self(21);
    pub const AP_ITEM: Self = Self(22);
    pub const AP_SUPPLY: Self = Self(23);
    pub const RENAMING_CARD: Self = Self(24);
    pub const RENAMING_CARD_2: Self = Self(25);
    pub const ET_STAGE: Self = Self(26);
    pub const ACTIVITY_ITEM: Self = Self(27);
    pub const VOUCHER_PICK: Self = Self(28);
    pub const VOUCHER_CGACHA: Self = Self(29);
    pub const VOUCHER_MGACHA: Self = Self(30);
    pub const CRS_SHOP_COIN: Self = Self(31);
    pub const CRS_RUNE_COIN: Self = Self(32);
    pub const LMTGS_COIN: Self = Self(33);
    pub const EPGS_COIN: Self = Self(34);
    pub const LIMITED_TKT_GACHA_10: Self = Self(35);
    pub const LIMITED_FREE_GACHA: Self = Self(36);
    pub const REP_COIN: Self = Self(37);
    pub const ROGUELIKE: Self = Self(38);
    pub const LINKAGE_TKT_GACHA_10: Self = Self(39);
    pub const VOUCHER_ELITE_II_4: Self = Self(40);
    pub const VOUCHER_ELITE_II_5: Self = Self(41);
    pub const VOUCHER_ELITE_II_6: Self = Self(42);
    pub const VOUCHER_SKIN: Self = Self(43);
    pub const RETRO_COIN: Self = Self(44);
    pub const PLAYER_AVATAR: Self = Self(45);
    pub const UNI_COLLECTION: Self = Self(46);
    pub const VOUCHER_FULL_POTENTIAL: Self = Self(47);
    pub const RL_COIN: Self = Self(48);
    pub const RETURN_CREDIT: Self = Self(49);
    pub const MEDAL: Self = Self(50);
    pub const CHARM: Self = Self(51);
    pub const HOME_BACKGROUND: Self = Self(52);
    pub const EXTERMINATION_AGENT: Self = Self(53);
    pub const OPTIONAL_VOUCHER_PICK: Self = Self(54);
    pub const ACT_CART_COMPONENT: Self = Self(55);
    pub const VOUCHER_LEVELMAX_6: Self = Self(56);
    pub const VOUCHER_LEVELMAX_5: Self = Self(57);
    pub const VOUCHER_LEVELMAX_4: Self = Self(58);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_6: Self = Self(59);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_5: Self = Self(60);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_4: Self = Self(61);
    pub const ACTIVITY_POTENTIAL: Self = Self(62);
    pub const ITEM_PACK: Self = Self(63);
    pub const SANDBOX: Self = Self(64);
    pub const FAVOR_ADD_ITEM: Self = Self(65);
    pub const CLASSIC_SHD: Self = Self(66);
    pub const CLASSIC_TKT_GACHA: Self = Self(67);
    pub const CLASSIC_TKT_GACHA_10: Self = Self(68);
    pub const LIMITED_BUFF: Self = Self(69);
    pub const CLASSIC_FES_PICK_TIER_5: Self = Self(70);
    pub const CLASSIC_FES_PICK_TIER_6: Self = Self(71);
    pub const RETURN_PROGRESS: Self = Self(72);
    pub const NEW_PROGRESS: Self = Self(73);
    pub const MCARD_VOUCHER: Self = Self(74);
    pub const MATERIAL_ISSUE_VOUCHER: Self = Self(75);
    pub const CRS_SHOP_COIN_V2: Self = Self(76);
    pub const HOME_THEME: Self = Self(77);
    pub const SANDBOX_PERM: Self = Self(78);
    pub const SANDBOX_TOKEN: Self = Self(79);
    pub const TEMPLATE_TRAP: Self = Self(80);
    pub const NAME_CARD_SKIN: Self = Self(81);
    pub const EMOTICON_SET: Self = Self(82);
    pub const EXCLUSIVE_TKT_GACHA: Self = Self(83);
    pub const EXCLUSIVE_TKT_GACHA_10: Self = Self(84);
    pub const SO_CHAR_EXP: Self = Self(85);
    pub const GIFTPACKAGE_TKT: Self = Self(86);
    pub const VOUCHER_SKIN_V2: Self = Self(87);
    pub const RANDOM_VOUCHER_SKIN: Self = Self(88);
    pub const ACT1VHALFIDLE_ITEM: Self = Self(89);
    pub const PLOT_ITEM: Self = Self(90);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 90;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CHAR,
        Self::CARD_EXP,
        Self::MATERIAL,
        Self::GOLD,
        Self::EXP_PLAYER,
        Self::TKT_TRY,
        Self::TKT_RECRUIT,
        Self::TKT_INST_FIN,
        Self::TKT_GACHA,
        Self::ACTIVITY_COIN,
        Self::DIAMOND,
        Self::DIAMOND_SHD,
        Self::HGG_SHD,
        Self::LGG_SHD,
        Self::FURN,
        Self::AP_GAMEPLAY,
        Self::AP_BASE,
        Self::SOCIAL_PT,
        Self::CHAR_SKIN,
        Self::TKT_GACHA_10,
        Self::TKT_GACHA_PRSV,
        Self::AP_ITEM,
        Self::AP_SUPPLY,
        Self::RENAMING_CARD,
        Self::RENAMING_CARD_2,
        Self::ET_STAGE,
        Self::ACTIVITY_ITEM,
        Self::VOUCHER_PICK,
        Self::VOUCHER_CGACHA,
        Self::VOUCHER_MGACHA,
        Self::CRS_SHOP_COIN,
        Self::CRS_RUNE_COIN,
        Self::LMTGS_COIN,
        Self::EPGS_COIN,
        Self::LIMITED_TKT_GACHA_10,
        Self::LIMITED_FREE_GACHA,
        Self::REP_COIN,
        Self::ROGUELIKE,
        Self::LINKAGE_TKT_GACHA_10,
        Self::VOUCHER_ELITE_II_4,
        Self::VOUCHER_ELITE_II_5,
        Self::VOUCHER_ELITE_II_6,
        Self::VOUCHER_SKIN,
        Self::RETRO_COIN,
        Self::PLAYER_AVATAR,
        Self::UNI_COLLECTION,
        Self::VOUCHER_FULL_POTENTIAL,
        Self::RL_COIN,
        Self::RETURN_CREDIT,
        Self::MEDAL,
        Self::CHARM,
        Self::HOME_BACKGROUND,
        Self::EXTERMINATION_AGENT,
        Self::OPTIONAL_VOUCHER_PICK,
        Self::ACT_CART_COMPONENT,
        Self::VOUCHER_LEVELMAX_6,
        Self::VOUCHER_LEVELMAX_5,
        Self::VOUCHER_LEVELMAX_4,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_6,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_5,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_4,
        Self::ACTIVITY_POTENTIAL,
        Self::ITEM_PACK,
        Self::SANDBOX,
        Self::FAVOR_ADD_ITEM,
        Self::CLASSIC_SHD,
        Self::CLASSIC_TKT_GACHA,
        Self::CLASSIC_TKT_GACHA_10,
        Self::LIMITED_BUFF,
        Self::CLASSIC_FES_PICK_TIER_5,
        Self::CLASSIC_FES_PICK_TIER_6,
        Self::RETURN_PROGRESS,
        Self::NEW_PROGRESS,
        Self::MCARD_VOUCHER,
        Self::MATERIAL_ISSUE_VOUCHER,
        Self::CRS_SHOP_COIN_V2,
        Self::HOME_THEME,
        Self::SANDBOX_PERM,
        Self::SANDBOX_TOKEN,
        Self::TEMPLATE_TRAP,
        Self::NAME_CARD_SKIN,
        Self::EMOTICON_SET,
        Self::EXCLUSIVE_TKT_GACHA,
        Self::EXCLUSIVE_TKT_GACHA_10,
        Self::SO_CHAR_EXP,
        Self::GIFTPACKAGE_TKT,
        Self::VOUCHER_SKIN_V2,
        Self::RANDOM_VOUCHER_SKIN,
        Self::ACT1VHALFIDLE_ITEM,
        Self::PLOT_ITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CHAR => Some("CHAR"),
            Self::CARD_EXP => Some("CARD_EXP"),
            Self::MATERIAL => Some("MATERIAL"),
            Self::GOLD => Some("GOLD"),
            Self::EXP_PLAYER => Some("EXP_PLAYER"),
            Self::TKT_TRY => Some("TKT_TRY"),
            Self::TKT_RECRUIT => Some("TKT_RECRUIT"),
            Self::TKT_INST_FIN => Some("TKT_INST_FIN"),
            Self::TKT_GACHA => Some("TKT_GACHA"),
            Self::ACTIVITY_COIN => Some("ACTIVITY_COIN"),
            Self::DIAMOND => Some("DIAMOND"),
            Self::DIAMOND_SHD => Some("DIAMOND_SHD"),
            Self::HGG_SHD => Some("HGG_SHD"),
            Self::LGG_SHD => Some("LGG_SHD"),
            Self::FURN => Some("FURN"),
            Self::AP_GAMEPLAY => Some("AP_GAMEPLAY"),
            Self::AP_BASE => Some("AP_BASE"),
            Self::SOCIAL_PT => Some("SOCIAL_PT"),
            Self::CHAR_SKIN => Some("CHAR_SKIN"),
            Self::TKT_GACHA_10 => Some("TKT_GACHA_10"),
            Self::TKT_GACHA_PRSV => Some("TKT_GACHA_PRSV"),
            Self::AP_ITEM => Some("AP_ITEM"),
            Self::AP_SUPPLY => Some("AP_SUPPLY"),
            Self::RENAMING_CARD => Some("RENAMING_CARD"),
            Self::RENAMING_CARD_2 => Some("RENAMING_CARD_2"),
            Self::ET_STAGE => Some("ET_STAGE"),
            Self::ACTIVITY_ITEM => Some("ACTIVITY_ITEM"),
            Self::VOUCHER_PICK => Some("VOUCHER_PICK"),
            Self::VOUCHER_CGACHA => Some("VOUCHER_CGACHA"),
            Self::VOUCHER_MGACHA => Some("VOUCHER_MGACHA"),
            Self::CRS_SHOP_COIN => Some("CRS_SHOP_COIN"),
            Self::CRS_RUNE_COIN => Some("CRS_RUNE_COIN"),
            Self::LMTGS_COIN => Some("LMTGS_COIN"),
            Self::EPGS_COIN => Some("EPGS_COIN"),
            Self::LIMITED_TKT_GACHA_10 => Some("LIMITED_TKT_GACHA_10"),
            Self::LIMITED_FREE_GACHA => Some("LIMITED_FREE_GACHA"),
            Self::REP_COIN => Some("REP_COIN"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::LINKAGE_TKT_GACHA_10 => Some("LINKAGE_TKT_GACHA_10"),
            Self::VOUCHER_ELITE_II_4 => Some("VOUCHER_ELITE_II_4"),
            Self::VOUCHER_ELITE_II_5 => Some("VOUCHER_ELITE_II_5"),
            Self::VOUCHER_ELITE_II_6 => Some("VOUCHER_ELITE_II_6"),
            Self::VOUCHER_SKIN => Some("VOUCHER_SKIN"),
            Self::RETRO_COIN => Some("RETRO_COIN"),
            Self::PLAYER_AVATAR => Some("PLAYER_AVATAR"),
            Self::UNI_COLLECTION => Some("UNI_COLLECTION"),
            Self::VOUCHER_FULL_POTENTIAL => Some("VOUCHER_FULL_POTENTIAL"),
            Self::RL_COIN => Some("RL_COIN"),
            Self::RETURN_CREDIT => Some("RETURN_CREDIT"),
            Self::MEDAL => Some("MEDAL"),
            Self::CHARM => Some("CHARM"),
            Self::HOME_BACKGROUND => Some("HOME_BACKGROUND"),
            Self::EXTERMINATION_AGENT => Some("EXTERMINATION_AGENT"),
            Self::OPTIONAL_VOUCHER_PICK => Some("OPTIONAL_VOUCHER_PICK"),
            Self::ACT_CART_COMPONENT => Some("ACT_CART_COMPONENT"),
            Self::VOUCHER_LEVELMAX_6 => Some("VOUCHER_LEVELMAX_6"),
            Self::VOUCHER_LEVELMAX_5 => Some("VOUCHER_LEVELMAX_5"),
            Self::VOUCHER_LEVELMAX_4 => Some("VOUCHER_LEVELMAX_4"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_6 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_6"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_5 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_5"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_4 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_4"),
            Self::ACTIVITY_POTENTIAL => Some("ACTIVITY_POTENTIAL"),
            Self::ITEM_PACK => Some("ITEM_PACK"),
            Self::SANDBOX => Some("SANDBOX"),
            Self::FAVOR_ADD_ITEM => Some("FAVOR_ADD_ITEM"),
            Self::CLASSIC_SHD => Some("CLASSIC_SHD"),
            Self::CLASSIC_TKT_GACHA => Some("CLASSIC_TKT_GACHA"),
            Self::CLASSIC_TKT_GACHA_10 => Some("CLASSIC_TKT_GACHA_10"),
            Self::LIMITED_BUFF => Some("LIMITED_BUFF"),
            Self::CLASSIC_FES_PICK_TIER_5 => Some("CLASSIC_FES_PICK_TIER_5"),
            Self::CLASSIC_FES_PICK_TIER_6 => Some("CLASSIC_FES_PICK_TIER_6"),
            Self::RETURN_PROGRESS => Some("RETURN_PROGRESS"),
            Self::NEW_PROGRESS => Some("NEW_PROGRESS"),
            Self::MCARD_VOUCHER => Some("MCARD_VOUCHER"),
            Self::MATERIAL_ISSUE_VOUCHER => Some("MATERIAL_ISSUE_VOUCHER"),
            Self::CRS_SHOP_COIN_V2 => Some("CRS_SHOP_COIN_V2"),
            Self::HOME_THEME => Some("HOME_THEME"),
            Self::SANDBOX_PERM => Some("SANDBOX_PERM"),
            Self::SANDBOX_TOKEN => Some("SANDBOX_TOKEN"),
            Self::TEMPLATE_TRAP => Some("TEMPLATE_TRAP"),
            Self::NAME_CARD_SKIN => Some("NAME_CARD_SKIN"),
            Self::EMOTICON_SET => Some("EMOTICON_SET"),
            Self::EXCLUSIVE_TKT_GACHA => Some("EXCLUSIVE_TKT_GACHA"),
            Self::EXCLUSIVE_TKT_GACHA_10 => Some("EXCLUSIVE_TKT_GACHA_10"),
            Self::SO_CHAR_EXP => Some("SO_CHAR_EXP"),
            Self::GIFTPACKAGE_TKT => Some("GIFTPACKAGE_TKT"),
            Self::VOUCHER_SKIN_V2 => Some("VOUCHER_SKIN_V2"),
            Self::RANDOM_VOUCHER_SKIN => Some("RANDOM_VOUCHER_SKIN"),
            Self::ACT1VHALFIDLE_ITEM => Some("ACT1VHALFIDLE_ITEM"),
            Self::PLOT_ITEM => Some("PLOT_ITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemType {
    type Output = enum__Torappu_ItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemType {}
pub enum clz_Torappu_SpecialOperatorBasicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorBasicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorBasicData<'a> {
    type Inner = clz_Torappu_SpecialOperatorBasicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorBasicData<'a> {
    pub const VT_SOCHARID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_TARGETTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_TARGETID: flatbuffers::VOffsetT = 10;
    pub const VT_TARGETTOPICNAME: flatbuffers::VOffsetT = 12;
    pub const VT_BGID: flatbuffers::VOffsetT = 14;
    pub const VT_BGEFFECTID: flatbuffers::VOffsetT = 16;
    pub const VT_CHAREFFECTID: flatbuffers::VOffsetT = 18;
    pub const VT_TYPEICONID: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorBasicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorBasicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorBasicData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorBasicDataBuilder::new(_fbb);
        if let Some(x) = args.typeIconId {
            builder.add_typeIconId(x);
        }
        if let Some(x) = args.charEffectId {
            builder.add_charEffectId(x);
        }
        if let Some(x) = args.bgEffectId {
            builder.add_bgEffectId(x);
        }
        if let Some(x) = args.bgId {
            builder.add_bgId(x);
        }
        if let Some(x) = args.targetTopicName {
            builder.add_targetTopicName(x);
        }
        if let Some(x) = args.targetId {
            builder.add_targetId(x);
        }
        builder.add_targetType(args.targetType);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.soCharId {
            builder.add_soCharId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorBasicDataT {
        let soCharId = self.soCharId().map(|x| x.to_string());
        let sortId = self.sortId();
        let targetType = self.targetType();
        let targetId = self.targetId().map(|x| x.to_string());
        let targetTopicName = self.targetTopicName().map(|x| x.to_string());
        let bgId = self.bgId().map(|x| x.to_string());
        let bgEffectId = self.bgEffectId().map(|x| x.to_string());
        let charEffectId = self.charEffectId().map(|x| x.to_string());
        let typeIconId = self.typeIconId().map(|x| x.to_string());
        clz_Torappu_SpecialOperatorBasicDataT {
            soCharId,
            sortId,
            targetType,
            targetId,
            targetTopicName,
            bgId,
            bgEffectId,
            charEffectId,
            typeIconId,
        }
    }

    #[inline]
    pub fn soCharId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorBasicData::VT_SOCHARID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SpecialOperatorBasicData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn targetType(&self) -> enum__Torappu_SpecialOperatorTargetType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SpecialOperatorTargetType>(
                    clz_Torappu_SpecialOperatorBasicData::VT_TARGETTYPE,
                    Some(enum__Torappu_SpecialOperatorTargetType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn targetId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorBasicData::VT_TARGETID,
                None,
            )
        }
    }
    #[inline]
    pub fn targetTopicName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorBasicData::VT_TARGETTOPICNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn bgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorBasicData::VT_BGID,
                None,
            )
        }
    }
    #[inline]
    pub fn bgEffectId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorBasicData::VT_BGEFFECTID,
                None,
            )
        }
    }
    #[inline]
    pub fn charEffectId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorBasicData::VT_CHAREFFECTID,
                None,
            )
        }
    }
    #[inline]
    pub fn typeIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorBasicData::VT_TYPEICONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorBasicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "soCharId",
                Self::VT_SOCHARID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<enum__Torappu_SpecialOperatorTargetType>(
                "targetType",
                Self::VT_TARGETTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "targetId",
                Self::VT_TARGETID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "targetTopicName",
                Self::VT_TARGETTOPICNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bgId", Self::VT_BGID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bgEffectId",
                Self::VT_BGEFFECTID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "charEffectId",
                Self::VT_CHAREFFECTID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "typeIconId",
                Self::VT_TYPEICONID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorBasicDataArgs<'a> {
    pub soCharId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub targetType: enum__Torappu_SpecialOperatorTargetType,
    pub targetId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub targetTopicName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bgEffectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub charEffectId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub typeIconId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SpecialOperatorBasicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorBasicDataArgs {
            soCharId: None,
            sortId: 0,
            targetType: enum__Torappu_SpecialOperatorTargetType::NONE,
            targetId: None,
            targetTopicName: None,
            bgId: None,
            bgEffectId: None,
            charEffectId: None,
            typeIconId: None,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorBasicData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SpecialOperatorBasicData", 9)?;
        if let Some(f) = self.soCharId() {
            s.serialize_field("soCharId", &f)?;
        } else {
            s.skip_field("soCharId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("targetType", &self.targetType())?;
        if let Some(f) = self.targetId() {
            s.serialize_field("targetId", &f)?;
        } else {
            s.skip_field("targetId")?;
        }
        if let Some(f) = self.targetTopicName() {
            s.serialize_field("targetTopicName", &f)?;
        } else {
            s.skip_field("targetTopicName")?;
        }
        if let Some(f) = self.bgId() {
            s.serialize_field("bgId", &f)?;
        } else {
            s.skip_field("bgId")?;
        }
        if let Some(f) = self.bgEffectId() {
            s.serialize_field("bgEffectId", &f)?;
        } else {
            s.skip_field("bgEffectId")?;
        }
        if let Some(f) = self.charEffectId() {
            s.serialize_field("charEffectId", &f)?;
        } else {
            s.skip_field("charEffectId")?;
        }
        if let Some(f) = self.typeIconId() {
            s.serialize_field("typeIconId", &f)?;
        } else {
            s.skip_field("typeIconId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorBasicDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorBasicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_soCharId(&mut self, soCharId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorBasicData::VT_SOCHARID,
            soCharId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_SpecialOperatorBasicData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_targetType(&mut self, targetType: enum__Torappu_SpecialOperatorTargetType) {
        self.fbb_
            .push_slot::<enum__Torappu_SpecialOperatorTargetType>(
                clz_Torappu_SpecialOperatorBasicData::VT_TARGETTYPE,
                targetType,
                enum__Torappu_SpecialOperatorTargetType::NONE,
            );
    }
    #[inline]
    pub fn add_targetId(&mut self, targetId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorBasicData::VT_TARGETID,
            targetId,
        );
    }
    #[inline]
    pub fn add_targetTopicName(&mut self, targetTopicName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorBasicData::VT_TARGETTOPICNAME,
            targetTopicName,
        );
    }
    #[inline]
    pub fn add_bgId(&mut self, bgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorBasicData::VT_BGID,
            bgId,
        );
    }
    #[inline]
    pub fn add_bgEffectId(&mut self, bgEffectId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorBasicData::VT_BGEFFECTID,
            bgEffectId,
        );
    }
    #[inline]
    pub fn add_charEffectId(&mut self, charEffectId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorBasicData::VT_CHAREFFECTID,
            charEffectId,
        );
    }
    #[inline]
    pub fn add_typeIconId(&mut self, typeIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorBasicData::VT_TYPEICONID,
            typeIconId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorBasicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorBasicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorBasicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorBasicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorBasicData");
        ds.field("soCharId", &self.soCharId());
        ds.field("sortId", &self.sortId());
        ds.field("targetType", &self.targetType());
        ds.field("targetId", &self.targetId());
        ds.field("targetTopicName", &self.targetTopicName());
        ds.field("bgId", &self.bgId());
        ds.field("bgEffectId", &self.bgEffectId());
        ds.field("charEffectId", &self.charEffectId());
        ds.field("typeIconId", &self.typeIconId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorBasicDataT {
    pub soCharId: Option<String>,
    pub sortId: i32,
    pub targetType: enum__Torappu_SpecialOperatorTargetType,
    pub targetId: Option<String>,
    pub targetTopicName: Option<String>,
    pub bgId: Option<String>,
    pub bgEffectId: Option<String>,
    pub charEffectId: Option<String>,
    pub typeIconId: Option<String>,
}
impl Default for clz_Torappu_SpecialOperatorBasicDataT {
    fn default() -> Self {
        Self {
            soCharId: None,
            sortId: 0,
            targetType: enum__Torappu_SpecialOperatorTargetType::NONE,
            targetId: None,
            targetTopicName: None,
            bgId: None,
            bgEffectId: None,
            charEffectId: None,
            typeIconId: None,
        }
    }
}
impl clz_Torappu_SpecialOperatorBasicDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorBasicData<'b>> {
        let soCharId = self.soCharId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let targetType = self.targetType;
        let targetId = self.targetId.as_ref().map(|x| _fbb.create_string(x));
        let targetTopicName = self.targetTopicName.as_ref().map(|x| _fbb.create_string(x));
        let bgId = self.bgId.as_ref().map(|x| _fbb.create_string(x));
        let bgEffectId = self.bgEffectId.as_ref().map(|x| _fbb.create_string(x));
        let charEffectId = self.charEffectId.as_ref().map(|x| _fbb.create_string(x));
        let typeIconId = self.typeIconId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SpecialOperatorBasicData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorBasicDataArgs {
                soCharId,
                sortId,
                targetType,
                targetId,
                targetTopicName,
                bgId,
                bgEffectId,
                charEffectId,
                typeIconId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorBasicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorBasicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SpecialOperatorBasicData<'a> {
    type Inner = dict__string__clz_Torappu_SpecialOperatorBasicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorBasicData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorBasicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorBasicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorBasicData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SpecialOperatorBasicDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorBasicDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorBasicDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorBasicData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorBasicData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorBasicData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorBasicData>>(
                    dict__string__clz_Torappu_SpecialOperatorBasicData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialOperatorBasicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorBasicData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorBasicDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorBasicData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorBasicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorBasicDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorBasicData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_SpecialOperatorBasicData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorBasicDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorBasicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorBasicData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorBasicData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorBasicData>>(
                dict__string__clz_Torappu_SpecialOperatorBasicData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorBasicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorBasicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorBasicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorBasicData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorBasicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SpecialOperatorBasicData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorBasicDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorBasicDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorBasicDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorBasicDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorBasicData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorBasicData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorBasicDataArgs { key, value },
        )
    }
}
pub enum list_intOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct list_int<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for list_int<'a> {
    type Inner = list_int<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> list_int<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        list_int { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args list_intArgs<'args>,
    ) -> flatbuffers::WIPOffset<list_int<'bldr>> {
        let mut builder = list_intBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> list_intT {
        let values = self.values().map(|x| x.into_iter().collect());
        list_intT { values }
    }

    #[inline]
    pub fn values(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    list_int::VT_VALUES,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for list_int<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "values",
                Self::VT_VALUES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct list_intArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for list_intArgs<'a> {
    #[inline]
    fn default() -> Self {
        list_intArgs { values: None }
    }
}

impl Serialize for list_int<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("list_int", 1)?;
        if let Some(f) = self.values() {
            s.serialize_field("values", &f)?;
        } else {
            s.skip_field("values")?;
        }
        s.end()
    }
}

pub struct list_intBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> list_intBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(list_int::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> list_intBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        list_intBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<list_int<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for list_int<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("list_int");
        ds.field("values", &self.values());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct list_intT {
    pub values: Option<Vec<i32>>,
}
impl Default for list_intT {
    fn default() -> Self {
        Self { values: None }
    }
}
impl list_intT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<list_int<'b>> {
        let values = self.values.as_ref().map(|x| _fbb.create_vector(x));
        list_int::create(_fbb, &list_intArgs { values })
    }
}
pub enum clz_Torappu_SpecialOperatorDetailConstDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorDetailConstData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorDetailConstData<'a> {
    type Inner = clz_Torappu_SpecialOperatorDetailConstData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorDetailConstData<'a> {
    pub const VT_NEXTROUNDBUFFTOAST: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorDetailConstData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorDetailConstDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailConstData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorDetailConstDataBuilder::new(_fbb);
        if let Some(x) = args.nextRoundBuffToast {
            builder.add_nextRoundBuffToast(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorDetailConstDataT {
        let nextRoundBuffToast = self.nextRoundBuffToast().map(|x| x.to_string());
        clz_Torappu_SpecialOperatorDetailConstDataT { nextRoundBuffToast }
    }

    #[inline]
    pub fn nextRoundBuffToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorDetailConstData::VT_NEXTROUNDBUFFTOAST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorDetailConstData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nextRoundBuffToast",
                Self::VT_NEXTROUNDBUFFTOAST,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorDetailConstDataArgs<'a> {
    pub nextRoundBuffToast: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SpecialOperatorDetailConstDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorDetailConstDataArgs {
            nextRoundBuffToast: None,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorDetailConstData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SpecialOperatorDetailConstData", 1)?;
        if let Some(f) = self.nextRoundBuffToast() {
            s.serialize_field("nextRoundBuffToast", &f)?;
        } else {
            s.skip_field("nextRoundBuffToast")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorDetailConstDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorDetailConstDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nextRoundBuffToast(&mut self, nextRoundBuffToast: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailConstData::VT_NEXTROUNDBUFFTOAST,
            nextRoundBuffToast,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorDetailConstDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorDetailConstDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailConstData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorDetailConstData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorDetailConstData");
        ds.field("nextRoundBuffToast", &self.nextRoundBuffToast());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorDetailConstDataT {
    pub nextRoundBuffToast: Option<String>,
}
impl Default for clz_Torappu_SpecialOperatorDetailConstDataT {
    fn default() -> Self {
        Self {
            nextRoundBuffToast: None,
        }
    }
}
impl clz_Torappu_SpecialOperatorDetailConstDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailConstData<'b>> {
        let nextRoundBuffToast = self
            .nextRoundBuffToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_SpecialOperatorDetailConstData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorDetailConstDataArgs { nextRoundBuffToast },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorDetailTabDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorDetailTabData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorDetailTabData<'a> {
    type Inner = clz_Torappu_SpecialOperatorDetailTabData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorDetailTabData<'a> {
    pub const VT_SOTABID: flatbuffers::VOffsetT = 4;
    pub const VT_SOTABNAME: flatbuffers::VOffsetT = 6;
    pub const VT_SOTABSORTID: flatbuffers::VOffsetT = 8;
    pub const VT_NODETYPE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorDetailTabData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorDetailTabDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailTabData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorDetailTabDataBuilder::new(_fbb);
        builder.add_nodeType(args.nodeType);
        builder.add_soTabSortId(args.soTabSortId);
        if let Some(x) = args.soTabName {
            builder.add_soTabName(x);
        }
        if let Some(x) = args.soTabId {
            builder.add_soTabId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorDetailTabDataT {
        let soTabId = self.soTabId().map(|x| x.to_string());
        let soTabName = self.soTabName().map(|x| x.to_string());
        let soTabSortId = self.soTabSortId();
        let nodeType = self.nodeType();
        clz_Torappu_SpecialOperatorDetailTabDataT {
            soTabId,
            soTabName,
            soTabSortId,
            nodeType,
        }
    }

    #[inline]
    pub fn soTabId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorDetailTabData::VT_SOTABID,
                None,
            )
        }
    }
    #[inline]
    pub fn soTabName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorDetailTabData::VT_SOTABNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn soTabSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SpecialOperatorDetailTabData::VT_SOTABSORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn nodeType(&self) -> enum__Torappu_SpecialOperatorDetailNodeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SpecialOperatorDetailNodeType>(
                    clz_Torappu_SpecialOperatorDetailTabData::VT_NODETYPE,
                    Some(enum__Torappu_SpecialOperatorDetailNodeType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorDetailTabData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("soTabId", Self::VT_SOTABID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "soTabName",
                Self::VT_SOTABNAME,
                false,
            )?
            .visit_field::<i32>("soTabSortId", Self::VT_SOTABSORTID, false)?
            .visit_field::<enum__Torappu_SpecialOperatorDetailNodeType>(
                "nodeType",
                Self::VT_NODETYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorDetailTabDataArgs<'a> {
    pub soTabId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub soTabName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub soTabSortId: i32,
    pub nodeType: enum__Torappu_SpecialOperatorDetailNodeType,
}
impl<'a> Default for clz_Torappu_SpecialOperatorDetailTabDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorDetailTabDataArgs {
            soTabId: None,
            soTabName: None,
            soTabSortId: 0,
            nodeType: enum__Torappu_SpecialOperatorDetailNodeType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorDetailTabData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SpecialOperatorDetailTabData", 4)?;
        if let Some(f) = self.soTabId() {
            s.serialize_field("soTabId", &f)?;
        } else {
            s.skip_field("soTabId")?;
        }
        if let Some(f) = self.soTabName() {
            s.serialize_field("soTabName", &f)?;
        } else {
            s.skip_field("soTabName")?;
        }
        s.serialize_field("soTabSortId", &self.soTabSortId())?;
        s.serialize_field("nodeType", &self.nodeType())?;
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorDetailTabDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorDetailTabDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_soTabId(&mut self, soTabId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailTabData::VT_SOTABID,
            soTabId,
        );
    }
    #[inline]
    pub fn add_soTabName(&mut self, soTabName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailTabData::VT_SOTABNAME,
            soTabName,
        );
    }
    #[inline]
    pub fn add_soTabSortId(&mut self, soTabSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SpecialOperatorDetailTabData::VT_SOTABSORTID,
            soTabSortId,
            0,
        );
    }
    #[inline]
    pub fn add_nodeType(&mut self, nodeType: enum__Torappu_SpecialOperatorDetailNodeType) {
        self.fbb_
            .push_slot::<enum__Torappu_SpecialOperatorDetailNodeType>(
                clz_Torappu_SpecialOperatorDetailTabData::VT_NODETYPE,
                nodeType,
                enum__Torappu_SpecialOperatorDetailNodeType::NONE,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorDetailTabDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorDetailTabDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailTabData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorDetailTabData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorDetailTabData");
        ds.field("soTabId", &self.soTabId());
        ds.field("soTabName", &self.soTabName());
        ds.field("soTabSortId", &self.soTabSortId());
        ds.field("nodeType", &self.nodeType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorDetailTabDataT {
    pub soTabId: Option<String>,
    pub soTabName: Option<String>,
    pub soTabSortId: i32,
    pub nodeType: enum__Torappu_SpecialOperatorDetailNodeType,
}
impl Default for clz_Torappu_SpecialOperatorDetailTabDataT {
    fn default() -> Self {
        Self {
            soTabId: None,
            soTabName: None,
            soTabSortId: 0,
            nodeType: enum__Torappu_SpecialOperatorDetailNodeType::NONE,
        }
    }
}
impl clz_Torappu_SpecialOperatorDetailTabDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailTabData<'b>> {
        let soTabId = self.soTabId.as_ref().map(|x| _fbb.create_string(x));
        let soTabName = self.soTabName.as_ref().map(|x| _fbb.create_string(x));
        let soTabSortId = self.soTabSortId;
        let nodeType = self.nodeType;
        clz_Torappu_SpecialOperatorDetailTabData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorDetailTabDataArgs {
                soTabId,
                soTabName,
                soTabSortId,
                nodeType,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorDetailTabDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorDetailTabData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SpecialOperatorDetailTabData<'a> {
    type Inner = dict__string__clz_Torappu_SpecialOperatorDetailTabData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorDetailTabData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailTabData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorDetailTabDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailTabData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SpecialOperatorDetailTabDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorDetailTabDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorDetailTabDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorDetailTabData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorDetailTabData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorDetailTabData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailTabData>>(
                    dict__string__clz_Torappu_SpecialOperatorDetailTabData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialOperatorDetailTabData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailTabData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorDetailTabDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailTabData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorDetailTabDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailTabDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorDetailTabData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SpecialOperatorDetailTabData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorDetailTabDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorDetailTabDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorDetailTabData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailTabData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailTabData>>(
                dict__string__clz_Torappu_SpecialOperatorDetailTabData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorDetailTabDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorDetailTabDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailTabData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorDetailTabData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorDetailTabData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SpecialOperatorDetailTabData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorDetailTabDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorDetailTabDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorDetailTabDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorDetailTabDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailTabData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorDetailTabData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorDetailTabDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorDetailNodeUnlockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorDetailNodeUnlockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorDetailNodeUnlockData<'a> {
    type Inner = clz_Torappu_SpecialOperatorDetailNodeUnlockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorDetailNodeUnlockData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_NODETYPE: flatbuffers::VOffsetT = 6;
    pub const VT_ISINGAMEMECHANICS: flatbuffers::VOffsetT = 8;
    pub const VT_UNLOCKEVOLVEPHASE: flatbuffers::VOffsetT = 10;
    pub const VT_UNLOCKLEVEL: flatbuffers::VOffsetT = 12;
    pub const VT_UNLOCKTASKID: flatbuffers::VOffsetT = 14;
    pub const VT_FRONTNODEID: flatbuffers::VOffsetT = 16;
    pub const VT_IFAUTOUNLOCK: flatbuffers::VOffsetT = 18;
    pub const VT_CONDITIONVIEWTYPE: flatbuffers::VOffsetT = 20;
    pub const VT_TOPOORDER: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorDetailNodeUnlockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorDetailNodeUnlockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailNodeUnlockData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorDetailNodeUnlockDataBuilder::new(_fbb);
        builder.add_topoOrder(args.topoOrder);
        builder.add_conditionViewType(args.conditionViewType);
        if let Some(x) = args.frontNodeId {
            builder.add_frontNodeId(x);
        }
        if let Some(x) = args.unlockTaskId {
            builder.add_unlockTaskId(x);
        }
        builder.add_unlockLevel(args.unlockLevel);
        builder.add_unlockEvolvePhase(args.unlockEvolvePhase);
        builder.add_nodeType(args.nodeType);
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.add_ifAutoUnlock(args.ifAutoUnlock);
        builder.add_isInGameMechanics(args.isInGameMechanics);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorDetailNodeUnlockDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        let nodeType = self.nodeType();
        let isInGameMechanics = self.isInGameMechanics();
        let unlockEvolvePhase = self.unlockEvolvePhase();
        let unlockLevel = self.unlockLevel();
        let unlockTaskId = self.unlockTaskId().map(|x| x.to_string());
        let frontNodeId = self.frontNodeId().map(|x| x.to_string());
        let ifAutoUnlock = self.ifAutoUnlock();
        let conditionViewType = self.conditionViewType();
        let topoOrder = self.topoOrder();
        clz_Torappu_SpecialOperatorDetailNodeUnlockDataT {
            nodeId,
            nodeType,
            isInGameMechanics,
            unlockEvolvePhase,
            unlockLevel,
            unlockTaskId,
            frontNodeId,
            ifAutoUnlock,
            conditionViewType,
            topoOrder,
        }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeType(&self) -> enum__Torappu_SpecialOperatorDetailNodeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SpecialOperatorDetailNodeType>(
                    clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_NODETYPE,
                    Some(enum__Torappu_SpecialOperatorDetailNodeType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isInGameMechanics(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_ISINGAMEMECHANICS,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockEvolvePhase(&self) -> enum__Torappu_EvolvePhase {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EvolvePhase>(
                    clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_UNLOCKEVOLVEPHASE,
                    Some(enum__Torappu_EvolvePhase::PHASE_0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_UNLOCKLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockTaskId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_UNLOCKTASKID,
                None,
            )
        }
    }
    #[inline]
    pub fn frontNodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_FRONTNODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn ifAutoUnlock(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_IFAUTOUNLOCK,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn conditionViewType(&self) -> enum__Torappu_SpecialOperatorConditionViewType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SpecialOperatorConditionViewType>(
                    clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_CONDITIONVIEWTYPE,
                    Some(enum__Torappu_SpecialOperatorConditionViewType::TASK),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn topoOrder(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_TOPOORDER,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorDetailNodeUnlockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<enum__Torappu_SpecialOperatorDetailNodeType>(
                "nodeType",
                Self::VT_NODETYPE,
                false,
            )?
            .visit_field::<bool>("isInGameMechanics", Self::VT_ISINGAMEMECHANICS, false)?
            .visit_field::<enum__Torappu_EvolvePhase>(
                "unlockEvolvePhase",
                Self::VT_UNLOCKEVOLVEPHASE,
                false,
            )?
            .visit_field::<i32>("unlockLevel", Self::VT_UNLOCKLEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockTaskId",
                Self::VT_UNLOCKTASKID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "frontNodeId",
                Self::VT_FRONTNODEID,
                false,
            )?
            .visit_field::<bool>("ifAutoUnlock", Self::VT_IFAUTOUNLOCK, false)?
            .visit_field::<enum__Torappu_SpecialOperatorConditionViewType>(
                "conditionViewType",
                Self::VT_CONDITIONVIEWTYPE,
                false,
            )?
            .visit_field::<i32>("topoOrder", Self::VT_TOPOORDER, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorDetailNodeUnlockDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeType: enum__Torappu_SpecialOperatorDetailNodeType,
    pub isInGameMechanics: bool,
    pub unlockEvolvePhase: enum__Torappu_EvolvePhase,
    pub unlockLevel: i32,
    pub unlockTaskId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub frontNodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ifAutoUnlock: bool,
    pub conditionViewType: enum__Torappu_SpecialOperatorConditionViewType,
    pub topoOrder: i32,
}
impl<'a> Default for clz_Torappu_SpecialOperatorDetailNodeUnlockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorDetailNodeUnlockDataArgs {
            nodeId: None,
            nodeType: enum__Torappu_SpecialOperatorDetailNodeType::NONE,
            isInGameMechanics: false,
            unlockEvolvePhase: enum__Torappu_EvolvePhase::PHASE_0,
            unlockLevel: 0,
            unlockTaskId: None,
            frontNodeId: None,
            ifAutoUnlock: false,
            conditionViewType: enum__Torappu_SpecialOperatorConditionViewType::TASK,
            topoOrder: 0,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorDetailNodeUnlockData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SpecialOperatorDetailNodeUnlockData", 10)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        s.serialize_field("nodeType", &self.nodeType())?;
        s.serialize_field("isInGameMechanics", &self.isInGameMechanics())?;
        s.serialize_field("unlockEvolvePhase", &self.unlockEvolvePhase())?;
        s.serialize_field("unlockLevel", &self.unlockLevel())?;
        if let Some(f) = self.unlockTaskId() {
            s.serialize_field("unlockTaskId", &f)?;
        } else {
            s.skip_field("unlockTaskId")?;
        }
        if let Some(f) = self.frontNodeId() {
            s.serialize_field("frontNodeId", &f)?;
        } else {
            s.skip_field("frontNodeId")?;
        }
        s.serialize_field("ifAutoUnlock", &self.ifAutoUnlock())?;
        s.serialize_field("conditionViewType", &self.conditionViewType())?;
        s.serialize_field("topoOrder", &self.topoOrder())?;
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorDetailNodeUnlockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorDetailNodeUnlockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_nodeType(&mut self, nodeType: enum__Torappu_SpecialOperatorDetailNodeType) {
        self.fbb_
            .push_slot::<enum__Torappu_SpecialOperatorDetailNodeType>(
                clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_NODETYPE,
                nodeType,
                enum__Torappu_SpecialOperatorDetailNodeType::NONE,
            );
    }
    #[inline]
    pub fn add_isInGameMechanics(&mut self, isInGameMechanics: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_ISINGAMEMECHANICS,
            isInGameMechanics,
            false,
        );
    }
    #[inline]
    pub fn add_unlockEvolvePhase(&mut self, unlockEvolvePhase: enum__Torappu_EvolvePhase) {
        self.fbb_.push_slot::<enum__Torappu_EvolvePhase>(
            clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_UNLOCKEVOLVEPHASE,
            unlockEvolvePhase,
            enum__Torappu_EvolvePhase::PHASE_0,
        );
    }
    #[inline]
    pub fn add_unlockLevel(&mut self, unlockLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_UNLOCKLEVEL,
            unlockLevel,
            0,
        );
    }
    #[inline]
    pub fn add_unlockTaskId(&mut self, unlockTaskId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_UNLOCKTASKID,
            unlockTaskId,
        );
    }
    #[inline]
    pub fn add_frontNodeId(&mut self, frontNodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_FRONTNODEID,
            frontNodeId,
        );
    }
    #[inline]
    pub fn add_ifAutoUnlock(&mut self, ifAutoUnlock: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_IFAUTOUNLOCK,
            ifAutoUnlock,
            false,
        );
    }
    #[inline]
    pub fn add_conditionViewType(
        &mut self,
        conditionViewType: enum__Torappu_SpecialOperatorConditionViewType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_SpecialOperatorConditionViewType>(
                clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_CONDITIONVIEWTYPE,
                conditionViewType,
                enum__Torappu_SpecialOperatorConditionViewType::TASK,
            );
    }
    #[inline]
    pub fn add_topoOrder(&mut self, topoOrder: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_TOPOORDER,
            topoOrder,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorDetailNodeUnlockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorDetailNodeUnlockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailNodeUnlockData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorDetailNodeUnlockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorDetailNodeUnlockData");
        ds.field("nodeId", &self.nodeId());
        ds.field("nodeType", &self.nodeType());
        ds.field("isInGameMechanics", &self.isInGameMechanics());
        ds.field("unlockEvolvePhase", &self.unlockEvolvePhase());
        ds.field("unlockLevel", &self.unlockLevel());
        ds.field("unlockTaskId", &self.unlockTaskId());
        ds.field("frontNodeId", &self.frontNodeId());
        ds.field("ifAutoUnlock", &self.ifAutoUnlock());
        ds.field("conditionViewType", &self.conditionViewType());
        ds.field("topoOrder", &self.topoOrder());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorDetailNodeUnlockDataT {
    pub nodeId: Option<String>,
    pub nodeType: enum__Torappu_SpecialOperatorDetailNodeType,
    pub isInGameMechanics: bool,
    pub unlockEvolvePhase: enum__Torappu_EvolvePhase,
    pub unlockLevel: i32,
    pub unlockTaskId: Option<String>,
    pub frontNodeId: Option<String>,
    pub ifAutoUnlock: bool,
    pub conditionViewType: enum__Torappu_SpecialOperatorConditionViewType,
    pub topoOrder: i32,
}
impl Default for clz_Torappu_SpecialOperatorDetailNodeUnlockDataT {
    fn default() -> Self {
        Self {
            nodeId: None,
            nodeType: enum__Torappu_SpecialOperatorDetailNodeType::NONE,
            isInGameMechanics: false,
            unlockEvolvePhase: enum__Torappu_EvolvePhase::PHASE_0,
            unlockLevel: 0,
            unlockTaskId: None,
            frontNodeId: None,
            ifAutoUnlock: false,
            conditionViewType: enum__Torappu_SpecialOperatorConditionViewType::TASK,
            topoOrder: 0,
        }
    }
}
impl clz_Torappu_SpecialOperatorDetailNodeUnlockDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailNodeUnlockData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let nodeType = self.nodeType;
        let isInGameMechanics = self.isInGameMechanics;
        let unlockEvolvePhase = self.unlockEvolvePhase;
        let unlockLevel = self.unlockLevel;
        let unlockTaskId = self.unlockTaskId.as_ref().map(|x| _fbb.create_string(x));
        let frontNodeId = self.frontNodeId.as_ref().map(|x| _fbb.create_string(x));
        let ifAutoUnlock = self.ifAutoUnlock;
        let conditionViewType = self.conditionViewType;
        let topoOrder = self.topoOrder;
        clz_Torappu_SpecialOperatorDetailNodeUnlockData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorDetailNodeUnlockDataArgs {
                nodeId,
                nodeType,
                isInGameMechanics,
                unlockEvolvePhase,
                unlockLevel,
                unlockTaskId,
                frontNodeId,
                ifAutoUnlock,
                conditionViewType,
                topoOrder,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData<'a>
{
    type Inner = dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorDetailNodeUnlockData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailNodeUnlockData>>(dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailNodeUnlockData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailNodeUnlockData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailNodeUnlockData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailNodeUnlockData>>(dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorDetailNodeUnlockDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorDetailEvolveNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorDetailEvolveNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorDetailEvolveNodeData<'a> {
    type Inner = clz_Torappu_SpecialOperatorDetailEvolveNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorDetailEvolveNodeData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_TOEVOLVEPHASE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorDetailEvolveNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorDetailEvolveNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailEvolveNodeData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorDetailEvolveNodeDataBuilder::new(_fbb);
        builder.add_toEvolvePhase(args.toEvolvePhase);
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorDetailEvolveNodeDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        let toEvolvePhase = self.toEvolvePhase();
        clz_Torappu_SpecialOperatorDetailEvolveNodeDataT {
            nodeId,
            toEvolvePhase,
        }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorDetailEvolveNodeData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn toEvolvePhase(&self) -> enum__Torappu_EvolvePhase {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EvolvePhase>(
                    clz_Torappu_SpecialOperatorDetailEvolveNodeData::VT_TOEVOLVEPHASE,
                    Some(enum__Torappu_EvolvePhase::PHASE_0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorDetailEvolveNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<enum__Torappu_EvolvePhase>(
                "toEvolvePhase",
                Self::VT_TOEVOLVEPHASE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorDetailEvolveNodeDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub toEvolvePhase: enum__Torappu_EvolvePhase,
}
impl<'a> Default for clz_Torappu_SpecialOperatorDetailEvolveNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorDetailEvolveNodeDataArgs {
            nodeId: None,
            toEvolvePhase: enum__Torappu_EvolvePhase::PHASE_0,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorDetailEvolveNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SpecialOperatorDetailEvolveNodeData", 2)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        s.serialize_field("toEvolvePhase", &self.toEvolvePhase())?;
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorDetailEvolveNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorDetailEvolveNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailEvolveNodeData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_toEvolvePhase(&mut self, toEvolvePhase: enum__Torappu_EvolvePhase) {
        self.fbb_.push_slot::<enum__Torappu_EvolvePhase>(
            clz_Torappu_SpecialOperatorDetailEvolveNodeData::VT_TOEVOLVEPHASE,
            toEvolvePhase,
            enum__Torappu_EvolvePhase::PHASE_0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorDetailEvolveNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorDetailEvolveNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailEvolveNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorDetailEvolveNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorDetailEvolveNodeData");
        ds.field("nodeId", &self.nodeId());
        ds.field("toEvolvePhase", &self.toEvolvePhase());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorDetailEvolveNodeDataT {
    pub nodeId: Option<String>,
    pub toEvolvePhase: enum__Torappu_EvolvePhase,
}
impl Default for clz_Torappu_SpecialOperatorDetailEvolveNodeDataT {
    fn default() -> Self {
        Self {
            nodeId: None,
            toEvolvePhase: enum__Torappu_EvolvePhase::PHASE_0,
        }
    }
}
impl clz_Torappu_SpecialOperatorDetailEvolveNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailEvolveNodeData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let toEvolvePhase = self.toEvolvePhase;
        clz_Torappu_SpecialOperatorDetailEvolveNodeData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorDetailEvolveNodeDataArgs {
                nodeId,
                toEvolvePhase,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData<'a>
{
    type Inner = dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorDetailEvolveNodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailEvolveNodeData>>(dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailEvolveNodeData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailEvolveNodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailEvolveNodeData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailEvolveNodeData>>(dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorDetailEvolveNodeDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorDetailSkillNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorDetailSkillNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorDetailSkillNodeData<'a> {
    type Inner = clz_Torappu_SpecialOperatorDetailSkillNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorDetailSkillNodeData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_SKILLKEY: flatbuffers::VOffsetT = 6;
    pub const VT_SKILLLEVEL: flatbuffers::VOffsetT = 8;
    pub const VT_SKILLSPLEVEL: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorDetailSkillNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorDetailSkillNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailSkillNodeData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorDetailSkillNodeDataBuilder::new(_fbb);
        builder.add_skillSpLevel(args.skillSpLevel);
        builder.add_skillLevel(args.skillLevel);
        if let Some(x) = args.skillKey {
            builder.add_skillKey(x);
        }
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorDetailSkillNodeDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        let skillKey = self.skillKey().map(|x| x.to_string());
        let skillLevel = self.skillLevel();
        let skillSpLevel = self.skillSpLevel();
        clz_Torappu_SpecialOperatorDetailSkillNodeDataT {
            nodeId,
            skillKey,
            skillLevel,
            skillSpLevel,
        }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorDetailSkillNodeData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn skillKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorDetailSkillNodeData::VT_SKILLKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn skillLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SpecialOperatorDetailSkillNodeData::VT_SKILLLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn skillSpLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SpecialOperatorDetailSkillNodeData::VT_SKILLSPLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorDetailSkillNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "skillKey",
                Self::VT_SKILLKEY,
                false,
            )?
            .visit_field::<i32>("skillLevel", Self::VT_SKILLLEVEL, false)?
            .visit_field::<i32>("skillSpLevel", Self::VT_SKILLSPLEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorDetailSkillNodeDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub skillKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub skillLevel: i32,
    pub skillSpLevel: i32,
}
impl<'a> Default for clz_Torappu_SpecialOperatorDetailSkillNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorDetailSkillNodeDataArgs {
            nodeId: None,
            skillKey: None,
            skillLevel: 0,
            skillSpLevel: 0,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorDetailSkillNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SpecialOperatorDetailSkillNodeData", 4)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        if let Some(f) = self.skillKey() {
            s.serialize_field("skillKey", &f)?;
        } else {
            s.skip_field("skillKey")?;
        }
        s.serialize_field("skillLevel", &self.skillLevel())?;
        s.serialize_field("skillSpLevel", &self.skillSpLevel())?;
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorDetailSkillNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorDetailSkillNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailSkillNodeData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_skillKey(&mut self, skillKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailSkillNodeData::VT_SKILLKEY,
            skillKey,
        );
    }
    #[inline]
    pub fn add_skillLevel(&mut self, skillLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SpecialOperatorDetailSkillNodeData::VT_SKILLLEVEL,
            skillLevel,
            0,
        );
    }
    #[inline]
    pub fn add_skillSpLevel(&mut self, skillSpLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SpecialOperatorDetailSkillNodeData::VT_SKILLSPLEVEL,
            skillSpLevel,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorDetailSkillNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorDetailSkillNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailSkillNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorDetailSkillNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorDetailSkillNodeData");
        ds.field("nodeId", &self.nodeId());
        ds.field("skillKey", &self.skillKey());
        ds.field("skillLevel", &self.skillLevel());
        ds.field("skillSpLevel", &self.skillSpLevel());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorDetailSkillNodeDataT {
    pub nodeId: Option<String>,
    pub skillKey: Option<String>,
    pub skillLevel: i32,
    pub skillSpLevel: i32,
}
impl Default for clz_Torappu_SpecialOperatorDetailSkillNodeDataT {
    fn default() -> Self {
        Self {
            nodeId: None,
            skillKey: None,
            skillLevel: 0,
            skillSpLevel: 0,
        }
    }
}
impl clz_Torappu_SpecialOperatorDetailSkillNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailSkillNodeData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let skillKey = self.skillKey.as_ref().map(|x| _fbb.create_string(x));
        let skillLevel = self.skillLevel;
        let skillSpLevel = self.skillSpLevel;
        clz_Torappu_SpecialOperatorDetailSkillNodeData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorDetailSkillNodeDataArgs {
                nodeId,
                skillKey,
                skillLevel,
                skillSpLevel,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData<'a>
{
    type Inner = dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorDetailSkillNodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailSkillNodeData>>(dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailSkillNodeData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailSkillNodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailSkillNodeData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailSkillNodeData>>(dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorDetailSkillNodeDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorDetailTalentNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorDetailTalentNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorDetailTalentNodeData<'a> {
    type Inner = clz_Torappu_SpecialOperatorDetailTalentNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorDetailTalentNodeData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_TALENTINDEX: flatbuffers::VOffsetT = 6;
    pub const VT_UPDATECOUNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorDetailTalentNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorDetailTalentNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailTalentNodeData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorDetailTalentNodeDataBuilder::new(_fbb);
        builder.add_updateCount(args.updateCount);
        builder.add_talentIndex(args.talentIndex);
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorDetailTalentNodeDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        let talentIndex = self.talentIndex();
        let updateCount = self.updateCount();
        clz_Torappu_SpecialOperatorDetailTalentNodeDataT {
            nodeId,
            talentIndex,
            updateCount,
        }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorDetailTalentNodeData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn talentIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SpecialOperatorDetailTalentNodeData::VT_TALENTINDEX,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn updateCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SpecialOperatorDetailTalentNodeData::VT_UPDATECOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorDetailTalentNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<i32>("talentIndex", Self::VT_TALENTINDEX, false)?
            .visit_field::<i32>("updateCount", Self::VT_UPDATECOUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorDetailTalentNodeDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub talentIndex: i32,
    pub updateCount: i32,
}
impl<'a> Default for clz_Torappu_SpecialOperatorDetailTalentNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorDetailTalentNodeDataArgs {
            nodeId: None,
            talentIndex: 0,
            updateCount: 0,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorDetailTalentNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SpecialOperatorDetailTalentNodeData", 3)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        s.serialize_field("talentIndex", &self.talentIndex())?;
        s.serialize_field("updateCount", &self.updateCount())?;
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorDetailTalentNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorDetailTalentNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailTalentNodeData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_talentIndex(&mut self, talentIndex: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SpecialOperatorDetailTalentNodeData::VT_TALENTINDEX,
            talentIndex,
            0,
        );
    }
    #[inline]
    pub fn add_updateCount(&mut self, updateCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SpecialOperatorDetailTalentNodeData::VT_UPDATECOUNT,
            updateCount,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorDetailTalentNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorDetailTalentNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailTalentNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorDetailTalentNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorDetailTalentNodeData");
        ds.field("nodeId", &self.nodeId());
        ds.field("talentIndex", &self.talentIndex());
        ds.field("updateCount", &self.updateCount());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorDetailTalentNodeDataT {
    pub nodeId: Option<String>,
    pub talentIndex: i32,
    pub updateCount: i32,
}
impl Default for clz_Torappu_SpecialOperatorDetailTalentNodeDataT {
    fn default() -> Self {
        Self {
            nodeId: None,
            talentIndex: 0,
            updateCount: 0,
        }
    }
}
impl clz_Torappu_SpecialOperatorDetailTalentNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailTalentNodeData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let talentIndex = self.talentIndex;
        let updateCount = self.updateCount;
        clz_Torappu_SpecialOperatorDetailTalentNodeData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorDetailTalentNodeDataArgs {
                nodeId,
                talentIndex,
                updateCount,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData<'a>
{
    type Inner = dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorDetailTalentNodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailTalentNodeData>>(dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailTalentNodeData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailTalentNodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailTalentNodeData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailTalentNodeData>>(dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorDetailTalentNodeDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorDetailMasterNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorDetailMasterNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorDetailMasterNodeData<'a> {
    type Inner = clz_Torappu_SpecialOperatorDetailMasterNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorDetailMasterNodeData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_MASTERID: flatbuffers::VOffsetT = 6;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorDetailMasterNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorDetailMasterNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailMasterNodeData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorDetailMasterNodeDataBuilder::new(_fbb);
        builder.add_level(args.level);
        if let Some(x) = args.masterId {
            builder.add_masterId(x);
        }
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorDetailMasterNodeDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        let masterId = self.masterId().map(|x| x.to_string());
        let level = self.level();
        clz_Torappu_SpecialOperatorDetailMasterNodeDataT {
            nodeId,
            masterId,
            level,
        }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorDetailMasterNodeData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn masterId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorDetailMasterNodeData::VT_MASTERID,
                None,
            )
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SpecialOperatorDetailMasterNodeData::VT_LEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorDetailMasterNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "masterId",
                Self::VT_MASTERID,
                false,
            )?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorDetailMasterNodeDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub masterId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub level: i32,
}
impl<'a> Default for clz_Torappu_SpecialOperatorDetailMasterNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorDetailMasterNodeDataArgs {
            nodeId: None,
            masterId: None,
            level: 0,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorDetailMasterNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SpecialOperatorDetailMasterNodeData", 3)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        if let Some(f) = self.masterId() {
            s.serialize_field("masterId", &f)?;
        } else {
            s.skip_field("masterId")?;
        }
        s.serialize_field("level", &self.level())?;
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorDetailMasterNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorDetailMasterNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailMasterNodeData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_masterId(&mut self, masterId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailMasterNodeData::VT_MASTERID,
            masterId,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SpecialOperatorDetailMasterNodeData::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorDetailMasterNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorDetailMasterNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailMasterNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorDetailMasterNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorDetailMasterNodeData");
        ds.field("nodeId", &self.nodeId());
        ds.field("masterId", &self.masterId());
        ds.field("level", &self.level());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorDetailMasterNodeDataT {
    pub nodeId: Option<String>,
    pub masterId: Option<String>,
    pub level: i32,
}
impl Default for clz_Torappu_SpecialOperatorDetailMasterNodeDataT {
    fn default() -> Self {
        Self {
            nodeId: None,
            masterId: None,
            level: 0,
        }
    }
}
impl clz_Torappu_SpecialOperatorDetailMasterNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailMasterNodeData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let masterId = self.masterId.as_ref().map(|x| _fbb.create_string(x));
        let level = self.level;
        clz_Torappu_SpecialOperatorDetailMasterNodeData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorDetailMasterNodeDataArgs {
                nodeId,
                masterId,
                level,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData<'a>
{
    type Inner = dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorDetailMasterNodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailMasterNodeData>>(dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailMasterNodeData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailMasterNodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailMasterNodeData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailMasterNodeData>>(dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorDetailMasterNodeDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorDetailUniEquipNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'a> {
    type Inner = clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_UNIEQUIPID: flatbuffers::VOffsetT = 6;
    pub const VT_EQUIPLEVEL: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorDetailUniEquipNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorDetailUniEquipNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorDetailUniEquipNodeDataBuilder::new(_fbb);
        builder.add_equipLevel(args.equipLevel);
        if let Some(x) = args.uniEquipId {
            builder.add_uniEquipId(x);
        }
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorDetailUniEquipNodeDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        let uniEquipId = self.uniEquipId().map(|x| x.to_string());
        let equipLevel = self.equipLevel();
        clz_Torappu_SpecialOperatorDetailUniEquipNodeDataT {
            nodeId,
            uniEquipId,
            equipLevel,
        }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorDetailUniEquipNodeData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn uniEquipId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorDetailUniEquipNodeData::VT_UNIEQUIPID,
                None,
            )
        }
    }
    #[inline]
    pub fn equipLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_SpecialOperatorDetailUniEquipNodeData::VT_EQUIPLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "uniEquipId",
                Self::VT_UNIEQUIPID,
                false,
            )?
            .visit_field::<i32>("equipLevel", Self::VT_EQUIPLEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorDetailUniEquipNodeDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub uniEquipId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub equipLevel: i32,
}
impl<'a> Default for clz_Torappu_SpecialOperatorDetailUniEquipNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorDetailUniEquipNodeDataArgs {
            nodeId: None,
            uniEquipId: None,
            equipLevel: 0,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SpecialOperatorDetailUniEquipNodeData", 3)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        if let Some(f) = self.uniEquipId() {
            s.serialize_field("uniEquipId", &f)?;
        } else {
            s.skip_field("uniEquipId")?;
        }
        s.serialize_field("equipLevel", &self.equipLevel())?;
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorDetailUniEquipNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorDetailUniEquipNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailUniEquipNodeData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_uniEquipId(&mut self, uniEquipId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailUniEquipNodeData::VT_UNIEQUIPID,
            uniEquipId,
        );
    }
    #[inline]
    pub fn add_equipLevel(&mut self, equipLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SpecialOperatorDetailUniEquipNodeData::VT_EQUIPLEVEL,
            equipLevel,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorDetailUniEquipNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorDetailUniEquipNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorDetailUniEquipNodeData");
        ds.field("nodeId", &self.nodeId());
        ds.field("uniEquipId", &self.uniEquipId());
        ds.field("equipLevel", &self.equipLevel());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorDetailUniEquipNodeDataT {
    pub nodeId: Option<String>,
    pub uniEquipId: Option<String>,
    pub equipLevel: i32,
}
impl Default for clz_Torappu_SpecialOperatorDetailUniEquipNodeDataT {
    fn default() -> Self {
        Self {
            nodeId: None,
            uniEquipId: None,
            equipLevel: 0,
        }
    }
}
impl clz_Torappu_SpecialOperatorDetailUniEquipNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let uniEquipId = self.uniEquipId.as_ref().map(|x| _fbb.create_string(x));
        let equipLevel = self.equipLevel;
        clz_Torappu_SpecialOperatorDetailUniEquipNodeData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorDetailUniEquipNodeDataArgs {
                nodeId,
                uniEquipId,
                equipLevel,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'a>
{
    type Inner = dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailUniEquipNodeData>>(dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailUniEquipNodeData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailUniEquipNodeData>>(dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorDetailUniEquipNodeDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataArgs { key, value },
        )
    }
}
pub enum clz_UnityEngine_Vector2Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_UnityEngine_Vector2<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_UnityEngine_Vector2<'a> {
    type Inner = clz_UnityEngine_Vector2<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_UnityEngine_Vector2<'a> {
    pub const VT_X: flatbuffers::VOffsetT = 4;
    pub const VT_Y: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_UnityEngine_Vector2 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_UnityEngine_Vector2Args,
    ) -> flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'bldr>> {
        let mut builder = clz_UnityEngine_Vector2Builder::new(_fbb);
        builder.add_y(args.y);
        builder.add_x(args.x);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_UnityEngine_Vector2T {
        let x = self.x();
        let y = self.y();
        clz_UnityEngine_Vector2T { x, y }
    }

    #[inline]
    pub fn x(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_UnityEngine_Vector2::VT_X, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn y(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_UnityEngine_Vector2::VT_Y, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_UnityEngine_Vector2<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("x", Self::VT_X, false)?
            .visit_field::<f32>("y", Self::VT_Y, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_UnityEngine_Vector2Args {
    pub x: f32,
    pub y: f32,
}
impl<'a> Default for clz_UnityEngine_Vector2Args {
    #[inline]
    fn default() -> Self {
        clz_UnityEngine_Vector2Args { x: 0.0, y: 0.0 }
    }
}

impl Serialize for clz_UnityEngine_Vector2<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_UnityEngine_Vector2", 2)?;
        s.serialize_field("x", &self.x())?;
        s.serialize_field("y", &self.y())?;
        s.end()
    }
}

pub struct clz_UnityEngine_Vector2Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_UnityEngine_Vector2Builder<'a, 'b, A> {
    #[inline]
    pub fn add_x(&mut self, x: f32) {
        self.fbb_
            .push_slot::<f32>(clz_UnityEngine_Vector2::VT_X, x, 0.0);
    }
    #[inline]
    pub fn add_y(&mut self, y: f32) {
        self.fbb_
            .push_slot::<f32>(clz_UnityEngine_Vector2::VT_Y, y, 0.0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_UnityEngine_Vector2Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_UnityEngine_Vector2Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_UnityEngine_Vector2<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_UnityEngine_Vector2");
        ds.field("x", &self.x());
        ds.field("y", &self.y());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_UnityEngine_Vector2T {
    pub x: f32,
    pub y: f32,
}
impl Default for clz_UnityEngine_Vector2T {
    fn default() -> Self {
        Self { x: 0.0, y: 0.0 }
    }
}
impl clz_UnityEngine_Vector2T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'b>> {
        let x = self.x;
        let y = self.y;
        clz_UnityEngine_Vector2::create(_fbb, &clz_UnityEngine_Vector2Args { x, y })
    }
}
pub enum clz_Torappu_SpecialOperatorPointPosDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorPointPosData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorPointPosData<'a> {
    type Inner = clz_Torappu_SpecialOperatorPointPosData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorPointPosData<'a> {
    pub const VT_POS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorPointPosData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorPointPosDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorPointPosData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorPointPosDataBuilder::new(_fbb);
        if let Some(x) = args.pos {
            builder.add_pos(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorPointPosDataT {
        let pos = self.pos().map(|x| Box::new(x.unpack()));
        clz_Torappu_SpecialOperatorPointPosDataT { pos }
    }

    #[inline]
    pub fn pos(&self) -> Option<clz_UnityEngine_Vector2<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                    clz_Torappu_SpecialOperatorPointPosData::VT_POS,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorPointPosData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                "pos",
                Self::VT_POS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorPointPosDataArgs<'a> {
    pub pos: Option<flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>>>,
}
impl<'a> Default for clz_Torappu_SpecialOperatorPointPosDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorPointPosDataArgs { pos: None }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorPointPosData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SpecialOperatorPointPosData", 1)?;
        if let Some(f) = self.pos() {
            s.serialize_field("pos", &f)?;
        } else {
            s.skip_field("pos")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorPointPosDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorPointPosDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_pos(&mut self, pos: flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_UnityEngine_Vector2>>(
                clz_Torappu_SpecialOperatorPointPosData::VT_POS,
                pos,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorPointPosDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorPointPosDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorPointPosData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorPointPosData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorPointPosData");
        ds.field("pos", &self.pos());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorPointPosDataT {
    pub pos: Option<Box<clz_UnityEngine_Vector2T>>,
}
impl Default for clz_Torappu_SpecialOperatorPointPosDataT {
    fn default() -> Self {
        Self { pos: None }
    }
}
impl clz_Torappu_SpecialOperatorPointPosDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorPointPosData<'b>> {
        let pos = self.pos.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_SpecialOperatorPointPosData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorPointPosDataArgs { pos },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorPointPosDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorPointPosData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SpecialOperatorPointPosData<'a> {
    type Inner = dict__string__clz_Torappu_SpecialOperatorPointPosData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorPointPosData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorPointPosData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorPointPosDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorPointPosData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SpecialOperatorPointPosDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorPointPosDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorPointPosDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorPointPosData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorPointPosData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorPointPosData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorPointPosData>>(
                    dict__string__clz_Torappu_SpecialOperatorPointPosData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialOperatorPointPosData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorPointPosData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorPointPosDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorPointPosData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorPointPosDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorPointPosDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorPointPosData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SpecialOperatorPointPosData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorPointPosDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorPointPosDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorPointPosData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorPointPosData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorPointPosData>>(
                dict__string__clz_Torappu_SpecialOperatorPointPosData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorPointPosDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorPointPosDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorPointPosData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorPointPosData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorPointPosData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SpecialOperatorPointPosData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorPointPosDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorPointPosDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorPointPosDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorPointPosDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorPointPosData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorPointPosData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorPointPosDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorNodePointDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorNodePointData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorNodePointData<'a> {
    type Inner = clz_Torappu_SpecialOperatorNodePointData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorNodePointData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorNodePointData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorNodePointDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorNodePointData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorNodePointDataBuilder::new(_fbb);
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorNodePointDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        clz_Torappu_SpecialOperatorNodePointDataT { nodeId }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorNodePointData::VT_NODEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorNodePointData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorNodePointDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SpecialOperatorNodePointDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorNodePointDataArgs { nodeId: None }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorNodePointData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SpecialOperatorNodePointData", 1)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorNodePointDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorNodePointDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorNodePointData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorNodePointDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorNodePointDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorNodePointData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorNodePointData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorNodePointData");
        ds.field("nodeId", &self.nodeId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorNodePointDataT {
    pub nodeId: Option<String>,
}
impl Default for clz_Torappu_SpecialOperatorNodePointDataT {
    fn default() -> Self {
        Self { nodeId: None }
    }
}
impl clz_Torappu_SpecialOperatorNodePointDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorNodePointData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SpecialOperatorNodePointData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorNodePointDataArgs { nodeId },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorNodePointDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorNodePointData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SpecialOperatorNodePointData<'a> {
    type Inner = dict__string__clz_Torappu_SpecialOperatorNodePointData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorNodePointData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorNodePointData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorNodePointDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorNodePointData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SpecialOperatorNodePointDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorNodePointDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorNodePointDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorNodePointData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorNodePointData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorNodePointData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorNodePointData>>(
                    dict__string__clz_Torappu_SpecialOperatorNodePointData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialOperatorNodePointData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorNodePointData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorNodePointDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorNodePointData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorNodePointDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorNodePointDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorNodePointData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SpecialOperatorNodePointData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorNodePointDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorNodePointDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorNodePointData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorNodePointData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorNodePointData>>(
                dict__string__clz_Torappu_SpecialOperatorNodePointData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorNodePointDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorNodePointDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorNodePointData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorNodePointData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorNodePointData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SpecialOperatorNodePointData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorNodePointDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorNodePointDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorNodePointDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorNodePointDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorNodePointData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorNodePointData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorNodePointDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorElitePointDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorElitePointData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorElitePointData<'a> {
    type Inner = clz_Torappu_SpecialOperatorElitePointData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorElitePointData<'a> {
    pub const VT_EVOLVEPHASE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorElitePointData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorElitePointDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorElitePointData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorElitePointDataBuilder::new(_fbb);
        builder.add_evolvePhase(args.evolvePhase);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorElitePointDataT {
        let evolvePhase = self.evolvePhase();
        clz_Torappu_SpecialOperatorElitePointDataT { evolvePhase }
    }

    #[inline]
    pub fn evolvePhase(&self) -> enum__Torappu_EvolvePhase {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EvolvePhase>(
                    clz_Torappu_SpecialOperatorElitePointData::VT_EVOLVEPHASE,
                    Some(enum__Torappu_EvolvePhase::PHASE_0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorElitePointData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_EvolvePhase>("evolvePhase", Self::VT_EVOLVEPHASE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorElitePointDataArgs {
    pub evolvePhase: enum__Torappu_EvolvePhase,
}
impl<'a> Default for clz_Torappu_SpecialOperatorElitePointDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorElitePointDataArgs {
            evolvePhase: enum__Torappu_EvolvePhase::PHASE_0,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorElitePointData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SpecialOperatorElitePointData", 1)?;
        s.serialize_field("evolvePhase", &self.evolvePhase())?;
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorElitePointDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorElitePointDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_evolvePhase(&mut self, evolvePhase: enum__Torappu_EvolvePhase) {
        self.fbb_.push_slot::<enum__Torappu_EvolvePhase>(
            clz_Torappu_SpecialOperatorElitePointData::VT_EVOLVEPHASE,
            evolvePhase,
            enum__Torappu_EvolvePhase::PHASE_0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorElitePointDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorElitePointDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorElitePointData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorElitePointData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorElitePointData");
        ds.field("evolvePhase", &self.evolvePhase());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorElitePointDataT {
    pub evolvePhase: enum__Torappu_EvolvePhase,
}
impl Default for clz_Torappu_SpecialOperatorElitePointDataT {
    fn default() -> Self {
        Self {
            evolvePhase: enum__Torappu_EvolvePhase::PHASE_0,
        }
    }
}
impl clz_Torappu_SpecialOperatorElitePointDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorElitePointData<'b>> {
        let evolvePhase = self.evolvePhase;
        clz_Torappu_SpecialOperatorElitePointData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorElitePointDataArgs { evolvePhase },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorElitePointDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorElitePointData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SpecialOperatorElitePointData<'a> {
    type Inner = dict__string__clz_Torappu_SpecialOperatorElitePointData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorElitePointData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorElitePointData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorElitePointDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorElitePointData<'bldr>>
    {
        let mut builder = dict__string__clz_Torappu_SpecialOperatorElitePointDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorElitePointDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorElitePointDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorElitePointData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorElitePointData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorElitePointData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorElitePointData>>(
                    dict__string__clz_Torappu_SpecialOperatorElitePointData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialOperatorElitePointData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorElitePointData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorElitePointDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorElitePointData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorElitePointDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorElitePointDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorElitePointData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SpecialOperatorElitePointData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorElitePointDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorElitePointDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorElitePointData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorElitePointData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorElitePointData>>(
                dict__string__clz_Torappu_SpecialOperatorElitePointData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorElitePointDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorElitePointDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorElitePointData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorElitePointData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorElitePointData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SpecialOperatorElitePointData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorElitePointDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorElitePointDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorElitePointDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorElitePointDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorElitePointData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorElitePointData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorElitePointDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorLevelPointDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorLevelPointData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorLevelPointData<'a> {
    type Inner = clz_Torappu_SpecialOperatorLevelPointData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorLevelPointData<'a> {
    pub const VT_EVOLVEPHASE: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorLevelPointData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorLevelPointDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLevelPointData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorLevelPointDataBuilder::new(_fbb);
        builder.add_level(args.level);
        builder.add_evolvePhase(args.evolvePhase);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorLevelPointDataT {
        let evolvePhase = self.evolvePhase();
        let level = self.level();
        clz_Torappu_SpecialOperatorLevelPointDataT { evolvePhase, level }
    }

    #[inline]
    pub fn evolvePhase(&self) -> enum__Torappu_EvolvePhase {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EvolvePhase>(
                    clz_Torappu_SpecialOperatorLevelPointData::VT_EVOLVEPHASE,
                    Some(enum__Torappu_EvolvePhase::PHASE_0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_SpecialOperatorLevelPointData::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorLevelPointData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_EvolvePhase>("evolvePhase", Self::VT_EVOLVEPHASE, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorLevelPointDataArgs {
    pub evolvePhase: enum__Torappu_EvolvePhase,
    pub level: i32,
}
impl<'a> Default for clz_Torappu_SpecialOperatorLevelPointDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorLevelPointDataArgs {
            evolvePhase: enum__Torappu_EvolvePhase::PHASE_0,
            level: 0,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorLevelPointData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SpecialOperatorLevelPointData", 2)?;
        s.serialize_field("evolvePhase", &self.evolvePhase())?;
        s.serialize_field("level", &self.level())?;
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorLevelPointDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorLevelPointDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_evolvePhase(&mut self, evolvePhase: enum__Torappu_EvolvePhase) {
        self.fbb_.push_slot::<enum__Torappu_EvolvePhase>(
            clz_Torappu_SpecialOperatorLevelPointData::VT_EVOLVEPHASE,
            evolvePhase,
            enum__Torappu_EvolvePhase::PHASE_0,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_SpecialOperatorLevelPointData::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorLevelPointDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorLevelPointDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLevelPointData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorLevelPointData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorLevelPointData");
        ds.field("evolvePhase", &self.evolvePhase());
        ds.field("level", &self.level());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorLevelPointDataT {
    pub evolvePhase: enum__Torappu_EvolvePhase,
    pub level: i32,
}
impl Default for clz_Torappu_SpecialOperatorLevelPointDataT {
    fn default() -> Self {
        Self {
            evolvePhase: enum__Torappu_EvolvePhase::PHASE_0,
            level: 0,
        }
    }
}
impl clz_Torappu_SpecialOperatorLevelPointDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLevelPointData<'b>> {
        let evolvePhase = self.evolvePhase;
        let level = self.level;
        clz_Torappu_SpecialOperatorLevelPointData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorLevelPointDataArgs { evolvePhase, level },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorLevelPointDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorLevelPointData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SpecialOperatorLevelPointData<'a> {
    type Inner = dict__string__clz_Torappu_SpecialOperatorLevelPointData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorLevelPointData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorLevelPointData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorLevelPointDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorLevelPointData<'bldr>>
    {
        let mut builder = dict__string__clz_Torappu_SpecialOperatorLevelPointDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorLevelPointDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorLevelPointDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorLevelPointData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorLevelPointData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorLevelPointData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorLevelPointData>>(
                    dict__string__clz_Torappu_SpecialOperatorLevelPointData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialOperatorLevelPointData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorLevelPointData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorLevelPointDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLevelPointData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorLevelPointDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorLevelPointDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorLevelPointData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SpecialOperatorLevelPointData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorLevelPointDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorLevelPointDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorLevelPointData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLevelPointData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLevelPointData>>(
                dict__string__clz_Torappu_SpecialOperatorLevelPointData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorLevelPointDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorLevelPointDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorLevelPointData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorLevelPointData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorLevelPointData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SpecialOperatorLevelPointData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorLevelPointDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorLevelPointDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorLevelPointDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorLevelPointDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorLevelPointData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorLevelPointData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorLevelPointDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorLinePosDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorLinePosData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorLinePosData<'a> {
    type Inner = clz_Torappu_SpecialOperatorLinePosData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorLinePosData<'a> {
    pub const VT_STARTPOS: flatbuffers::VOffsetT = 4;
    pub const VT_ENDPOS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorLinePosData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorLinePosDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLinePosData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorLinePosDataBuilder::new(_fbb);
        if let Some(x) = args.endPos {
            builder.add_endPos(x);
        }
        if let Some(x) = args.startPos {
            builder.add_startPos(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorLinePosDataT {
        let startPos = self.startPos().map(|x| Box::new(x.unpack()));
        let endPos = self.endPos().map(|x| Box::new(x.unpack()));
        clz_Torappu_SpecialOperatorLinePosDataT { startPos, endPos }
    }

    #[inline]
    pub fn startPos(&self) -> Option<clz_UnityEngine_Vector2<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                    clz_Torappu_SpecialOperatorLinePosData::VT_STARTPOS,
                    None,
                )
        }
    }
    #[inline]
    pub fn endPos(&self) -> Option<clz_UnityEngine_Vector2<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                    clz_Torappu_SpecialOperatorLinePosData::VT_ENDPOS,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorLinePosData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                "startPos",
                Self::VT_STARTPOS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                "endPos",
                Self::VT_ENDPOS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorLinePosDataArgs<'a> {
    pub startPos: Option<flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>>>,
    pub endPos: Option<flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>>>,
}
impl<'a> Default for clz_Torappu_SpecialOperatorLinePosDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorLinePosDataArgs {
            startPos: None,
            endPos: None,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorLinePosData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SpecialOperatorLinePosData", 2)?;
        if let Some(f) = self.startPos() {
            s.serialize_field("startPos", &f)?;
        } else {
            s.skip_field("startPos")?;
        }
        if let Some(f) = self.endPos() {
            s.serialize_field("endPos", &f)?;
        } else {
            s.skip_field("endPos")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorLinePosDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorLinePosDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_startPos(&mut self, startPos: flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_UnityEngine_Vector2>>(
                clz_Torappu_SpecialOperatorLinePosData::VT_STARTPOS,
                startPos,
            );
    }
    #[inline]
    pub fn add_endPos(&mut self, endPos: flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_UnityEngine_Vector2>>(
                clz_Torappu_SpecialOperatorLinePosData::VT_ENDPOS,
                endPos,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorLinePosDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorLinePosDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLinePosData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorLinePosData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorLinePosData");
        ds.field("startPos", &self.startPos());
        ds.field("endPos", &self.endPos());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorLinePosDataT {
    pub startPos: Option<Box<clz_UnityEngine_Vector2T>>,
    pub endPos: Option<Box<clz_UnityEngine_Vector2T>>,
}
impl Default for clz_Torappu_SpecialOperatorLinePosDataT {
    fn default() -> Self {
        Self {
            startPos: None,
            endPos: None,
        }
    }
}
impl clz_Torappu_SpecialOperatorLinePosDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLinePosData<'b>> {
        let startPos = self.startPos.as_ref().map(|x| x.pack(_fbb));
        let endPos = self.endPos.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_SpecialOperatorLinePosData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorLinePosDataArgs { startPos, endPos },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorLinePosDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorLinePosData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SpecialOperatorLinePosData<'a> {
    type Inner = dict__string__clz_Torappu_SpecialOperatorLinePosData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorLinePosData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorLinePosData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorLinePosDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorLinePosData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SpecialOperatorLinePosDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorLinePosDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorLinePosDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorLinePosData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorLinePosData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorLinePosData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorLinePosData>>(
                    dict__string__clz_Torappu_SpecialOperatorLinePosData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialOperatorLinePosData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorLinePosData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorLinePosDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLinePosData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorLinePosDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorLinePosDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorLinePosData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SpecialOperatorLinePosData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorLinePosDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorLinePosDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorLinePosData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLinePosData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLinePosData>>(
                dict__string__clz_Torappu_SpecialOperatorLinePosData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorLinePosDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorLinePosDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorLinePosData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorLinePosData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorLinePosData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SpecialOperatorLinePosData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorLinePosDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorLinePosDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorLinePosDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorLinePosDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorLinePosData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorLinePosData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorLinePosDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorLineRelationDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorLineRelationData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorLineRelationData<'a> {
    type Inner = clz_Torappu_SpecialOperatorLineRelationData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorLineRelationData<'a> {
    pub const VT_STARTPOINTLIST: flatbuffers::VOffsetT = 4;
    pub const VT_ENDPOINTLIST: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorLineRelationData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorLineRelationDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLineRelationData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorLineRelationDataBuilder::new(_fbb);
        if let Some(x) = args.endPointList {
            builder.add_endPointList(x);
        }
        if let Some(x) = args.startPointList {
            builder.add_startPointList(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorLineRelationDataT {
        let startPointList = self
            .startPointList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let endPointList = self
            .endPointList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_SpecialOperatorLineRelationDataT {
            startPointList,
            endPointList,
        }
    }

    #[inline]
    pub fn startPointList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SpecialOperatorLineRelationData::VT_STARTPOINTLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn endPointList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_SpecialOperatorLineRelationData::VT_ENDPOINTLIST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorLineRelationData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("startPointList", Self::VT_STARTPOINTLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("endPointList", Self::VT_ENDPOINTLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorLineRelationDataArgs<'a> {
    pub startPointList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub endPointList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_SpecialOperatorLineRelationDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorLineRelationDataArgs {
            startPointList: None,
            endPointList: None,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorLineRelationData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_SpecialOperatorLineRelationData", 2)?;
        if let Some(f) = self.startPointList() {
            s.serialize_field("startPointList", &f)?;
        } else {
            s.skip_field("startPointList")?;
        }
        if let Some(f) = self.endPointList() {
            s.serialize_field("endPointList", &f)?;
        } else {
            s.skip_field("endPointList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorLineRelationDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorLineRelationDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_startPointList(
        &mut self,
        startPointList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorLineRelationData::VT_STARTPOINTLIST,
            startPointList,
        );
    }
    #[inline]
    pub fn add_endPointList(
        &mut self,
        endPointList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorLineRelationData::VT_ENDPOINTLIST,
            endPointList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorLineRelationDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorLineRelationDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLineRelationData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorLineRelationData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorLineRelationData");
        ds.field("startPointList", &self.startPointList());
        ds.field("endPointList", &self.endPointList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorLineRelationDataT {
    pub startPointList: Option<Vec<String>>,
    pub endPointList: Option<Vec<String>>,
}
impl Default for clz_Torappu_SpecialOperatorLineRelationDataT {
    fn default() -> Self {
        Self {
            startPointList: None,
            endPointList: None,
        }
    }
}
impl clz_Torappu_SpecialOperatorLineRelationDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLineRelationData<'b>> {
        let startPointList = self.startPointList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let endPointList = self.endPointList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SpecialOperatorLineRelationData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorLineRelationDataArgs {
                startPointList,
                endPointList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorLineRelationDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorLineRelationData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SpecialOperatorLineRelationData<'a> {
    type Inner = dict__string__clz_Torappu_SpecialOperatorLineRelationData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorLineRelationData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorLineRelationData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorLineRelationDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorLineRelationData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_SpecialOperatorLineRelationDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorLineRelationDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorLineRelationDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorLineRelationData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorLineRelationData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorLineRelationData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorLineRelationData>>(
                    dict__string__clz_Torappu_SpecialOperatorLineRelationData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialOperatorLineRelationData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorLineRelationData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorLineRelationDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLineRelationData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorLineRelationDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorLineRelationDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorLineRelationData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_SpecialOperatorLineRelationData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorLineRelationDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorLineRelationDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorLineRelationData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLineRelationData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorLineRelationData>>(dict__string__clz_Torappu_SpecialOperatorLineRelationData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorLineRelationDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorLineRelationDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorLineRelationData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorLineRelationData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorLineRelationData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SpecialOperatorLineRelationData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorLineRelationDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorLineRelationDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorLineRelationDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorLineRelationDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorLineRelationData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorLineRelationData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorLineRelationDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorDiagramDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorDiagramData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorDiagramData<'a> {
    type Inner = clz_Torappu_SpecialOperatorDiagramData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorDiagramData<'a> {
    pub const VT_WIDTH: flatbuffers::VOffsetT = 4;
    pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;
    pub const VT_POINTPOSDATAMAP: flatbuffers::VOffsetT = 8;
    pub const VT_NODEPOINTDATAMAP: flatbuffers::VOffsetT = 10;
    pub const VT_ELITEPOINTDATAMAP: flatbuffers::VOffsetT = 12;
    pub const VT_LEVELPOINTDATAMAP: flatbuffers::VOffsetT = 14;
    pub const VT_LINEPOSDATAMAP: flatbuffers::VOffsetT = 16;
    pub const VT_LINERELATIONDATAMAP: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorDiagramData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorDiagramDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDiagramData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorDiagramDataBuilder::new(_fbb);
        if let Some(x) = args.lineRelationDataMap {
            builder.add_lineRelationDataMap(x);
        }
        if let Some(x) = args.linePosDataMap {
            builder.add_linePosDataMap(x);
        }
        if let Some(x) = args.levelPointDataMap {
            builder.add_levelPointDataMap(x);
        }
        if let Some(x) = args.elitePointDataMap {
            builder.add_elitePointDataMap(x);
        }
        if let Some(x) = args.nodePointDataMap {
            builder.add_nodePointDataMap(x);
        }
        if let Some(x) = args.pointPosDataMap {
            builder.add_pointPosDataMap(x);
        }
        builder.add_height(args.height);
        builder.add_width(args.width);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorDiagramDataT {
        let width = self.width();
        let height = self.height();
        let pointPosDataMap = self
            .pointPosDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let nodePointDataMap = self
            .nodePointDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let elitePointDataMap = self
            .elitePointDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let levelPointDataMap = self
            .levelPointDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let linePosDataMap = self
            .linePosDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let lineRelationDataMap = self
            .lineRelationDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SpecialOperatorDiagramDataT {
            width,
            height,
            pointPosDataMap,
            nodePointDataMap,
            elitePointDataMap,
            levelPointDataMap,
            linePosDataMap,
            lineRelationDataMap,
        }
    }

    #[inline]
    pub fn width(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_SpecialOperatorDiagramData::VT_WIDTH, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn height(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_SpecialOperatorDiagramData::VT_HEIGHT, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn pointPosDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SpecialOperatorPointPosData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorPointPosData,
                    >,
                >,
            >>(
                clz_Torappu_SpecialOperatorDiagramData::VT_POINTPOSDATAMAP,
                None,
            )
        }
    }
    #[inline]
    pub fn nodePointDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SpecialOperatorNodePointData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorNodePointData,
                    >,
                >,
            >>(
                clz_Torappu_SpecialOperatorDiagramData::VT_NODEPOINTDATAMAP,
                None,
            )
        }
    }
    #[inline]
    pub fn elitePointDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SpecialOperatorElitePointData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorElitePointData,
                    >,
                >,
            >>(
                clz_Torappu_SpecialOperatorDiagramData::VT_ELITEPOINTDATAMAP,
                None,
            )
        }
    }
    #[inline]
    pub fn levelPointDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SpecialOperatorLevelPointData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorLevelPointData,
                    >,
                >,
            >>(
                clz_Torappu_SpecialOperatorDiagramData::VT_LEVELPOINTDATAMAP,
                None,
            )
        }
    }
    #[inline]
    pub fn linePosDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SpecialOperatorLinePosData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorLinePosData,
                    >,
                >,
            >>(
                clz_Torappu_SpecialOperatorDiagramData::VT_LINEPOSDATAMAP,
                None,
            )
        }
    }
    #[inline]
    pub fn lineRelationDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SpecialOperatorLineRelationData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorLineRelationData,
                    >,
                >,
            >>(
                clz_Torappu_SpecialOperatorDiagramData::VT_LINERELATIONDATAMAP,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorDiagramData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("width", Self::VT_WIDTH, false)?
            .visit_field::<f32>("height", Self::VT_HEIGHT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorPointPosData,
                    >,
                >,
            >>("pointPosDataMap", Self::VT_POINTPOSDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorNodePointData,
                    >,
                >,
            >>("nodePointDataMap", Self::VT_NODEPOINTDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorElitePointData,
                    >,
                >,
            >>("elitePointDataMap", Self::VT_ELITEPOINTDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorLevelPointData,
                    >,
                >,
            >>("levelPointDataMap", Self::VT_LEVELPOINTDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorLinePosData,
                    >,
                >,
            >>("linePosDataMap", Self::VT_LINEPOSDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorLineRelationData,
                    >,
                >,
            >>("lineRelationDataMap", Self::VT_LINERELATIONDATAMAP, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorDiagramDataArgs<'a> {
    pub width: f32,
    pub height: f32,
    pub pointPosDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorPointPosData<'a>,
                >,
            >,
        >,
    >,
    pub nodePointDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorNodePointData<'a>,
                >,
            >,
        >,
    >,
    pub elitePointDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorElitePointData<'a>,
                >,
            >,
        >,
    >,
    pub levelPointDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorLevelPointData<'a>,
                >,
            >,
        >,
    >,
    pub linePosDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorLinePosData<'a>,
                >,
            >,
        >,
    >,
    pub lineRelationDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorLineRelationData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SpecialOperatorDiagramDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorDiagramDataArgs {
            width: 0.0,
            height: 0.0,
            pointPosDataMap: None,
            nodePointDataMap: None,
            elitePointDataMap: None,
            levelPointDataMap: None,
            linePosDataMap: None,
            lineRelationDataMap: None,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorDiagramData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SpecialOperatorDiagramData", 8)?;
        s.serialize_field("width", &self.width())?;
        s.serialize_field("height", &self.height())?;
        if let Some(f) = self.pointPosDataMap() {
            s.serialize_field("pointPosDataMap", &f)?;
        } else {
            s.skip_field("pointPosDataMap")?;
        }
        if let Some(f) = self.nodePointDataMap() {
            s.serialize_field("nodePointDataMap", &f)?;
        } else {
            s.skip_field("nodePointDataMap")?;
        }
        if let Some(f) = self.elitePointDataMap() {
            s.serialize_field("elitePointDataMap", &f)?;
        } else {
            s.skip_field("elitePointDataMap")?;
        }
        if let Some(f) = self.levelPointDataMap() {
            s.serialize_field("levelPointDataMap", &f)?;
        } else {
            s.skip_field("levelPointDataMap")?;
        }
        if let Some(f) = self.linePosDataMap() {
            s.serialize_field("linePosDataMap", &f)?;
        } else {
            s.skip_field("linePosDataMap")?;
        }
        if let Some(f) = self.lineRelationDataMap() {
            s.serialize_field("lineRelationDataMap", &f)?;
        } else {
            s.skip_field("lineRelationDataMap")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorDiagramDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorDiagramDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_width(&mut self, width: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_SpecialOperatorDiagramData::VT_WIDTH, width, 0.0);
    }
    #[inline]
    pub fn add_height(&mut self, height: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_SpecialOperatorDiagramData::VT_HEIGHT,
            height,
            0.0,
        );
    }
    #[inline]
    pub fn add_pointPosDataMap(
        &mut self,
        pointPosDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorPointPosData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDiagramData::VT_POINTPOSDATAMAP,
            pointPosDataMap,
        );
    }
    #[inline]
    pub fn add_nodePointDataMap(
        &mut self,
        nodePointDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorNodePointData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDiagramData::VT_NODEPOINTDATAMAP,
            nodePointDataMap,
        );
    }
    #[inline]
    pub fn add_elitePointDataMap(
        &mut self,
        elitePointDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorElitePointData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDiagramData::VT_ELITEPOINTDATAMAP,
            elitePointDataMap,
        );
    }
    #[inline]
    pub fn add_levelPointDataMap(
        &mut self,
        levelPointDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorLevelPointData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDiagramData::VT_LEVELPOINTDATAMAP,
            levelPointDataMap,
        );
    }
    #[inline]
    pub fn add_linePosDataMap(
        &mut self,
        linePosDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorLinePosData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDiagramData::VT_LINEPOSDATAMAP,
            linePosDataMap,
        );
    }
    #[inline]
    pub fn add_lineRelationDataMap(
        &mut self,
        lineRelationDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorLineRelationData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDiagramData::VT_LINERELATIONDATAMAP,
            lineRelationDataMap,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorDiagramDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorDiagramDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDiagramData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorDiagramData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorDiagramData");
        ds.field("width", &self.width());
        ds.field("height", &self.height());
        ds.field("pointPosDataMap", &self.pointPosDataMap());
        ds.field("nodePointDataMap", &self.nodePointDataMap());
        ds.field("elitePointDataMap", &self.elitePointDataMap());
        ds.field("levelPointDataMap", &self.levelPointDataMap());
        ds.field("linePosDataMap", &self.linePosDataMap());
        ds.field("lineRelationDataMap", &self.lineRelationDataMap());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorDiagramDataT {
    pub width: f32,
    pub height: f32,
    pub pointPosDataMap: Option<Vec<dict__string__clz_Torappu_SpecialOperatorPointPosDataT>>,
    pub nodePointDataMap: Option<Vec<dict__string__clz_Torappu_SpecialOperatorNodePointDataT>>,
    pub elitePointDataMap: Option<Vec<dict__string__clz_Torappu_SpecialOperatorElitePointDataT>>,
    pub levelPointDataMap: Option<Vec<dict__string__clz_Torappu_SpecialOperatorLevelPointDataT>>,
    pub linePosDataMap: Option<Vec<dict__string__clz_Torappu_SpecialOperatorLinePosDataT>>,
    pub lineRelationDataMap:
        Option<Vec<dict__string__clz_Torappu_SpecialOperatorLineRelationDataT>>,
}
impl Default for clz_Torappu_SpecialOperatorDiagramDataT {
    fn default() -> Self {
        Self {
            width: 0.0,
            height: 0.0,
            pointPosDataMap: None,
            nodePointDataMap: None,
            elitePointDataMap: None,
            levelPointDataMap: None,
            linePosDataMap: None,
            lineRelationDataMap: None,
        }
    }
}
impl clz_Torappu_SpecialOperatorDiagramDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDiagramData<'b>> {
        let width = self.width;
        let height = self.height;
        let pointPosDataMap = self.pointPosDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let nodePointDataMap = self.nodePointDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let elitePointDataMap = self.elitePointDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let levelPointDataMap = self.levelPointDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let linePosDataMap = self.linePosDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let lineRelationDataMap = self.lineRelationDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SpecialOperatorDiagramData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorDiagramDataArgs {
                width,
                height,
                pointPosDataMap,
                nodePointDataMap,
                elitePointDataMap,
                levelPointDataMap,
                linePosDataMap,
                lineRelationDataMap,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorDiagramDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorDiagramData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SpecialOperatorDiagramData<'a> {
    type Inner = dict__string__clz_Torappu_SpecialOperatorDiagramData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorDiagramData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorDiagramData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorDiagramDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDiagramData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SpecialOperatorDiagramDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorDiagramDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorDiagramDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorDiagramData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorDiagramData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorDiagramData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDiagramData>>(
                    dict__string__clz_Torappu_SpecialOperatorDiagramData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialOperatorDiagramData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDiagramData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorDiagramDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDiagramData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorDiagramDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorDiagramDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorDiagramData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SpecialOperatorDiagramData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorDiagramDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorDiagramDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorDiagramData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDiagramData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDiagramData>>(
                dict__string__clz_Torappu_SpecialOperatorDiagramData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorDiagramDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorDiagramDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDiagramData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorDiagramData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorDiagramData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SpecialOperatorDiagramData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorDiagramDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorDiagramDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorDiagramDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorDiagramDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDiagramData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorDiagramData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorDiagramDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorDetailDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorDetailData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorDetailData<'a> {
    type Inner = clz_Torappu_SpecialOperatorDetailData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorDetailData<'a> {
    pub const VT_SPECIALOPERATOREXPMAP: flatbuffers::VOffsetT = 4;
    pub const VT_DETAILCONSTDATA: flatbuffers::VOffsetT = 6;
    pub const VT_TABDATA: flatbuffers::VOffsetT = 8;
    pub const VT_NODEUNLOCKDATA: flatbuffers::VOffsetT = 10;
    pub const VT_EVOLVENODEDATA: flatbuffers::VOffsetT = 12;
    pub const VT_SKILLNODEDATA: flatbuffers::VOffsetT = 14;
    pub const VT_TALENTNODEDATA: flatbuffers::VOffsetT = 16;
    pub const VT_MASTERNODEDATA: flatbuffers::VOffsetT = 18;
    pub const VT_UNIEQUIPNODEDATA: flatbuffers::VOffsetT = 20;
    pub const VT_NODEDIAGRAMMAP: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorDetailData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorDetailDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorDetailDataBuilder::new(_fbb);
        if let Some(x) = args.nodeDiagramMap {
            builder.add_nodeDiagramMap(x);
        }
        if let Some(x) = args.uniEquipNodeData {
            builder.add_uniEquipNodeData(x);
        }
        if let Some(x) = args.masterNodeData {
            builder.add_masterNodeData(x);
        }
        if let Some(x) = args.talentNodeData {
            builder.add_talentNodeData(x);
        }
        if let Some(x) = args.skillNodeData {
            builder.add_skillNodeData(x);
        }
        if let Some(x) = args.evolveNodeData {
            builder.add_evolveNodeData(x);
        }
        if let Some(x) = args.nodeUnlockData {
            builder.add_nodeUnlockData(x);
        }
        if let Some(x) = args.tabData {
            builder.add_tabData(x);
        }
        if let Some(x) = args.detailConstData {
            builder.add_detailConstData(x);
        }
        if let Some(x) = args.specialOperatorExpMap {
            builder.add_specialOperatorExpMap(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorDetailDataT {
        let specialOperatorExpMap = self
            .specialOperatorExpMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let detailConstData = self.detailConstData().map(|x| Box::new(x.unpack()));
        let tabData = self
            .tabData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let nodeUnlockData = self
            .nodeUnlockData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let evolveNodeData = self
            .evolveNodeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let skillNodeData = self
            .skillNodeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let talentNodeData = self
            .talentNodeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let masterNodeData = self
            .masterNodeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let uniEquipNodeData = self
            .uniEquipNodeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let nodeDiagramMap = self
            .nodeDiagramMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_SpecialOperatorDetailDataT {
            specialOperatorExpMap,
            detailConstData,
            tabData,
            nodeUnlockData,
            evolveNodeData,
            skillNodeData,
            talentNodeData,
            masterNodeData,
            uniEquipNodeData,
            nodeDiagramMap,
        }
    }

    #[inline]
    pub fn specialOperatorExpMap(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<list_int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<list_int>>,
            >>(
                clz_Torappu_SpecialOperatorDetailData::VT_SPECIALOPERATOREXPMAP,
                None,
            )
        }
    }
    #[inline]
    pub fn detailConstData(&self) -> Option<clz_Torappu_SpecialOperatorDetailConstData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailConstData>>(
                    clz_Torappu_SpecialOperatorDetailData::VT_DETAILCONSTDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn tabData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SpecialOperatorDetailTabData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorDetailTabData,
                    >,
                >,
            >>(clz_Torappu_SpecialOperatorDetailData::VT_TABDATA, None)
        }
    }
    #[inline]
    pub fn nodeUnlockData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData,
                    >,
                >,
            >>(
                clz_Torappu_SpecialOperatorDetailData::VT_NODEUNLOCKDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn evolveNodeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData,
                    >,
                >,
            >>(
                clz_Torappu_SpecialOperatorDetailData::VT_EVOLVENODEDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn skillNodeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData,
                    >,
                >,
            >>(
                clz_Torappu_SpecialOperatorDetailData::VT_SKILLNODEDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn talentNodeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData,
                    >,
                >,
            >>(
                clz_Torappu_SpecialOperatorDetailData::VT_TALENTNODEDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn masterNodeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData,
                    >,
                >,
            >>(
                clz_Torappu_SpecialOperatorDetailData::VT_MASTERNODEDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn uniEquipNodeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData,
                    >,
                >,
            >>(
                clz_Torappu_SpecialOperatorDetailData::VT_UNIEQUIPNODEDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeDiagramMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SpecialOperatorDiagramData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorDiagramData,
                    >,
                >,
            >>(
                clz_Torappu_SpecialOperatorDetailData::VT_NODEDIAGRAMMAP,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorDetailData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<list_int>>>>("specialOperatorExpMap", Self::VT_SPECIALOPERATOREXPMAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailConstData>>("detailConstData", Self::VT_DETAILCONSTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SpecialOperatorDetailTabData>>>>("tabData", Self::VT_TABDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData>>>>("nodeUnlockData", Self::VT_NODEUNLOCKDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData>>>>("evolveNodeData", Self::VT_EVOLVENODEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData>>>>("skillNodeData", Self::VT_SKILLNODEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData>>>>("talentNodeData", Self::VT_TALENTNODEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData>>>>("masterNodeData", Self::VT_MASTERNODEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData>>>>("uniEquipNodeData", Self::VT_UNIEQUIPNODEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SpecialOperatorDiagramData>>>>("nodeDiagramMap", Self::VT_NODEDIAGRAMMAP, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorDetailDataArgs<'a> {
    pub specialOperatorExpMap: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<list_int<'a>>>>,
    >,
    pub detailConstData:
        Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailConstData<'a>>>,
    pub tabData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailTabData<'a>,
                >,
            >,
        >,
    >,
    pub nodeUnlockData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData<'a>,
                >,
            >,
        >,
    >,
    pub evolveNodeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData<'a>,
                >,
            >,
        >,
    >,
    pub skillNodeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData<'a>,
                >,
            >,
        >,
    >,
    pub talentNodeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData<'a>,
                >,
            >,
        >,
    >,
    pub masterNodeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData<'a>,
                >,
            >,
        >,
    >,
    pub uniEquipNodeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'a>,
                >,
            >,
        >,
    >,
    pub nodeDiagramMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDiagramData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_SpecialOperatorDetailDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorDetailDataArgs {
            specialOperatorExpMap: None,
            detailConstData: None,
            tabData: None,
            nodeUnlockData: None,
            evolveNodeData: None,
            skillNodeData: None,
            talentNodeData: None,
            masterNodeData: None,
            uniEquipNodeData: None,
            nodeDiagramMap: None,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorDetailData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SpecialOperatorDetailData", 10)?;
        if let Some(f) = self.specialOperatorExpMap() {
            s.serialize_field("specialOperatorExpMap", &f)?;
        } else {
            s.skip_field("specialOperatorExpMap")?;
        }
        if let Some(f) = self.detailConstData() {
            s.serialize_field("detailConstData", &f)?;
        } else {
            s.skip_field("detailConstData")?;
        }
        if let Some(f) = self.tabData() {
            s.serialize_field("tabData", &f)?;
        } else {
            s.skip_field("tabData")?;
        }
        if let Some(f) = self.nodeUnlockData() {
            s.serialize_field("nodeUnlockData", &f)?;
        } else {
            s.skip_field("nodeUnlockData")?;
        }
        if let Some(f) = self.evolveNodeData() {
            s.serialize_field("evolveNodeData", &f)?;
        } else {
            s.skip_field("evolveNodeData")?;
        }
        if let Some(f) = self.skillNodeData() {
            s.serialize_field("skillNodeData", &f)?;
        } else {
            s.skip_field("skillNodeData")?;
        }
        if let Some(f) = self.talentNodeData() {
            s.serialize_field("talentNodeData", &f)?;
        } else {
            s.skip_field("talentNodeData")?;
        }
        if let Some(f) = self.masterNodeData() {
            s.serialize_field("masterNodeData", &f)?;
        } else {
            s.skip_field("masterNodeData")?;
        }
        if let Some(f) = self.uniEquipNodeData() {
            s.serialize_field("uniEquipNodeData", &f)?;
        } else {
            s.skip_field("uniEquipNodeData")?;
        }
        if let Some(f) = self.nodeDiagramMap() {
            s.serialize_field("nodeDiagramMap", &f)?;
        } else {
            s.skip_field("nodeDiagramMap")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorDetailDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorDetailDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_specialOperatorExpMap(
        &mut self,
        specialOperatorExpMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<list_int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailData::VT_SPECIALOPERATOREXPMAP,
            specialOperatorExpMap,
        );
    }
    #[inline]
    pub fn add_detailConstData(
        &mut self,
        detailConstData: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailConstData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailConstData>>(
                clz_Torappu_SpecialOperatorDetailData::VT_DETAILCONSTDATA,
                detailConstData,
            );
    }
    #[inline]
    pub fn add_tabData(
        &mut self,
        tabData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailTabData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailData::VT_TABDATA,
            tabData,
        );
    }
    #[inline]
    pub fn add_nodeUnlockData(
        &mut self,
        nodeUnlockData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailData::VT_NODEUNLOCKDATA,
            nodeUnlockData,
        );
    }
    #[inline]
    pub fn add_evolveNodeData(
        &mut self,
        evolveNodeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailData::VT_EVOLVENODEDATA,
            evolveNodeData,
        );
    }
    #[inline]
    pub fn add_skillNodeData(
        &mut self,
        skillNodeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailData::VT_SKILLNODEDATA,
            skillNodeData,
        );
    }
    #[inline]
    pub fn add_talentNodeData(
        &mut self,
        talentNodeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailData::VT_TALENTNODEDATA,
            talentNodeData,
        );
    }
    #[inline]
    pub fn add_masterNodeData(
        &mut self,
        masterNodeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailData::VT_MASTERNODEDATA,
            masterNodeData,
        );
    }
    #[inline]
    pub fn add_uniEquipNodeData(
        &mut self,
        uniEquipNodeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailData::VT_UNIEQUIPNODEDATA,
            uniEquipNodeData,
        );
    }
    #[inline]
    pub fn add_nodeDiagramMap(
        &mut self,
        nodeDiagramMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDiagramData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorDetailData::VT_NODEDIAGRAMMAP,
            nodeDiagramMap,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorDetailDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorDetailDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorDetailData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorDetailData");
        ds.field("specialOperatorExpMap", &self.specialOperatorExpMap());
        ds.field("detailConstData", &self.detailConstData());
        ds.field("tabData", &self.tabData());
        ds.field("nodeUnlockData", &self.nodeUnlockData());
        ds.field("evolveNodeData", &self.evolveNodeData());
        ds.field("skillNodeData", &self.skillNodeData());
        ds.field("talentNodeData", &self.talentNodeData());
        ds.field("masterNodeData", &self.masterNodeData());
        ds.field("uniEquipNodeData", &self.uniEquipNodeData());
        ds.field("nodeDiagramMap", &self.nodeDiagramMap());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorDetailDataT {
    pub specialOperatorExpMap: Option<Vec<list_intT>>,
    pub detailConstData: Option<Box<clz_Torappu_SpecialOperatorDetailConstDataT>>,
    pub tabData: Option<Vec<dict__string__clz_Torappu_SpecialOperatorDetailTabDataT>>,
    pub nodeUnlockData: Option<Vec<dict__string__clz_Torappu_SpecialOperatorDetailNodeUnlockDataT>>,
    pub evolveNodeData: Option<Vec<dict__string__clz_Torappu_SpecialOperatorDetailEvolveNodeDataT>>,
    pub skillNodeData: Option<Vec<dict__string__clz_Torappu_SpecialOperatorDetailSkillNodeDataT>>,
    pub talentNodeData: Option<Vec<dict__string__clz_Torappu_SpecialOperatorDetailTalentNodeDataT>>,
    pub masterNodeData: Option<Vec<dict__string__clz_Torappu_SpecialOperatorDetailMasterNodeDataT>>,
    pub uniEquipNodeData:
        Option<Vec<dict__string__clz_Torappu_SpecialOperatorDetailUniEquipNodeDataT>>,
    pub nodeDiagramMap: Option<Vec<dict__string__clz_Torappu_SpecialOperatorDiagramDataT>>,
}
impl Default for clz_Torappu_SpecialOperatorDetailDataT {
    fn default() -> Self {
        Self {
            specialOperatorExpMap: None,
            detailConstData: None,
            tabData: None,
            nodeUnlockData: None,
            evolveNodeData: None,
            skillNodeData: None,
            talentNodeData: None,
            masterNodeData: None,
            uniEquipNodeData: None,
            nodeDiagramMap: None,
        }
    }
}
impl clz_Torappu_SpecialOperatorDetailDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailData<'b>> {
        let specialOperatorExpMap = self.specialOperatorExpMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let detailConstData = self.detailConstData.as_ref().map(|x| x.pack(_fbb));
        let tabData = self.tabData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let nodeUnlockData = self.nodeUnlockData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let evolveNodeData = self.evolveNodeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let skillNodeData = self.skillNodeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let talentNodeData = self.talentNodeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let masterNodeData = self.masterNodeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let uniEquipNodeData = self.uniEquipNodeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let nodeDiagramMap = self.nodeDiagramMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_SpecialOperatorDetailData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorDetailDataArgs {
                specialOperatorExpMap,
                detailConstData,
                tabData,
                nodeUnlockData,
                evolveNodeData,
                skillNodeData,
                talentNodeData,
                masterNodeData,
                uniEquipNodeData,
                nodeDiagramMap,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_SpecialOperatorDetailDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_SpecialOperatorDetailData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_SpecialOperatorDetailData<'a> {
    type Inner = dict__string__clz_Torappu_SpecialOperatorDetailData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_SpecialOperatorDetailData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_SpecialOperatorDetailDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_SpecialOperatorDetailDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_SpecialOperatorDetailDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_SpecialOperatorDetailDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_SpecialOperatorDetailData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_SpecialOperatorDetailData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_SpecialOperatorDetailData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailData>>(
                    dict__string__clz_Torappu_SpecialOperatorDetailData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_SpecialOperatorDetailData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorDetailData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_SpecialOperatorDetailDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_SpecialOperatorDetailDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_SpecialOperatorDetailDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_SpecialOperatorDetailData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_SpecialOperatorDetailData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_SpecialOperatorDetailDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_SpecialOperatorDetailDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_SpecialOperatorDetailData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorDetailData>>(
                dict__string__clz_Torappu_SpecialOperatorDetailData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_SpecialOperatorDetailDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_SpecialOperatorDetailDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_SpecialOperatorDetailData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_SpecialOperatorDetailData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_SpecialOperatorDetailData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_SpecialOperatorDetailDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_SpecialOperatorDetailDataT>>,
}
impl Default for dict__string__clz_Torappu_SpecialOperatorDetailDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_SpecialOperatorDetailDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_SpecialOperatorDetailData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_SpecialOperatorDetailData::create(
            _fbb,
            &dict__string__clz_Torappu_SpecialOperatorDetailDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorModeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorModeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorModeData<'a> {
    type Inner = clz_Torappu_SpecialOperatorModeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorModeData<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_TYPENAME: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorModeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorModeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorModeData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorModeDataBuilder::new(_fbb);
        if let Some(x) = args.typeName {
            builder.add_typeName(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorModeDataT {
        let type_ = self.type_();
        let typeName = self.typeName().map(|x| x.to_string());
        clz_Torappu_SpecialOperatorModeDataT { type_, typeName }
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_SpecialOperatorTargetType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SpecialOperatorTargetType>(
                    clz_Torappu_SpecialOperatorModeData::VT_TYPE_,
                    Some(enum__Torappu_SpecialOperatorTargetType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn typeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorModeData::VT_TYPENAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorModeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SpecialOperatorTargetType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "typeName",
                Self::VT_TYPENAME,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorModeDataArgs<'a> {
    pub type_: enum__Torappu_SpecialOperatorTargetType,
    pub typeName: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SpecialOperatorModeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorModeDataArgs {
            type_: enum__Torappu_SpecialOperatorTargetType::NONE,
            typeName: None,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorModeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SpecialOperatorModeData", 2)?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.typeName() {
            s.serialize_field("typeName", &f)?;
        } else {
            s.skip_field("typeName")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorModeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorModeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_SpecialOperatorTargetType) {
        self.fbb_
            .push_slot::<enum__Torappu_SpecialOperatorTargetType>(
                clz_Torappu_SpecialOperatorModeData::VT_TYPE_,
                type_,
                enum__Torappu_SpecialOperatorTargetType::NONE,
            );
    }
    #[inline]
    pub fn add_typeName(&mut self, typeName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorModeData::VT_TYPENAME,
            typeName,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorModeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorModeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorModeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorModeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorModeData");
        ds.field("type_", &self.type_());
        ds.field("typeName", &self.typeName());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorModeDataT {
    pub type_: enum__Torappu_SpecialOperatorTargetType,
    pub typeName: Option<String>,
}
impl Default for clz_Torappu_SpecialOperatorModeDataT {
    fn default() -> Self {
        Self {
            type_: enum__Torappu_SpecialOperatorTargetType::NONE,
            typeName: None,
        }
    }
}
impl clz_Torappu_SpecialOperatorModeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorModeData<'b>> {
        let type_ = self.type_;
        let typeName = self.typeName.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_SpecialOperatorModeData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorModeDataArgs { type_, typeName },
        )
    }
}
pub enum clz_Torappu_MissionDisplayRewardsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MissionDisplayRewards<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MissionDisplayRewards<'a> {
    type Inner = clz_Torappu_MissionDisplayRewards<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MissionDisplayRewards<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_COUNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MissionDisplayRewards { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MissionDisplayRewardsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MissionDisplayRewards<'bldr>> {
        let mut builder = clz_Torappu_MissionDisplayRewardsBuilder::new(_fbb);
        builder.add_count(args.count);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MissionDisplayRewardsT {
        let type_ = self.type_();
        let id = self.id().map(|x| x.to_string());
        let count = self.count();
        clz_Torappu_MissionDisplayRewardsT { type_, id, count }
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_MissionDisplayRewards::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MissionDisplayRewards::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_MissionDisplayRewards::VT_COUNT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MissionDisplayRewards<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MissionDisplayRewardsArgs<'a> {
    pub type_: enum__Torappu_ItemType,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
}
impl<'a> Default for clz_Torappu_MissionDisplayRewardsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MissionDisplayRewardsArgs {
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            count: 0,
        }
    }
}

impl Serialize for clz_Torappu_MissionDisplayRewards<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MissionDisplayRewards", 3)?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("count", &self.count())?;
        s.end()
    }
}

pub struct clz_Torappu_MissionDisplayRewardsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_MissionDisplayRewardsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_MissionDisplayRewards::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionDisplayRewards::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_MissionDisplayRewards::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MissionDisplayRewardsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MissionDisplayRewardsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MissionDisplayRewards<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MissionDisplayRewards<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MissionDisplayRewards");
        ds.field("type_", &self.type_());
        ds.field("id", &self.id());
        ds.field("count", &self.count());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MissionDisplayRewardsT {
    pub type_: enum__Torappu_ItemType,
    pub id: Option<String>,
    pub count: i32,
}
impl Default for clz_Torappu_MissionDisplayRewardsT {
    fn default() -> Self {
        Self {
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            count: 0,
        }
    }
}
impl clz_Torappu_MissionDisplayRewardsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MissionDisplayRewards<'b>> {
        let type_ = self.type_;
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        clz_Torappu_MissionDisplayRewards::create(
            _fbb,
            &clz_Torappu_MissionDisplayRewardsArgs { type_, id, count },
        )
    }
}
pub enum clz_Torappu_MissionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MissionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MissionData<'a> {
    type Inner = clz_Torappu_MissionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MissionData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 10;
    pub const VT_ITEMBGTYPE: flatbuffers::VOffsetT = 12;
    pub const VT_PREMISSIONIDS: flatbuffers::VOffsetT = 14;
    pub const VT_TEMPLATE: flatbuffers::VOffsetT = 16;
    pub const VT_TEMPLATETYPE: flatbuffers::VOffsetT = 18;
    pub const VT_PARAM: flatbuffers::VOffsetT = 20;
    pub const VT_UNLOCKCONDITION: flatbuffers::VOffsetT = 22;
    pub const VT_UNLOCKPARAM: flatbuffers::VOffsetT = 24;
    pub const VT_MISSIONGROUP: flatbuffers::VOffsetT = 26;
    pub const VT_TOPAGE: flatbuffers::VOffsetT = 28;
    pub const VT_PERIODICALPOINT: flatbuffers::VOffsetT = 30;
    pub const VT_REWARDS: flatbuffers::VOffsetT = 32;
    pub const VT_BACKIMAGEPATH: flatbuffers::VOffsetT = 34;
    pub const VT_FOLDID: flatbuffers::VOffsetT = 36;
    pub const VT_HAVESUBMISSIONTOUNLOCK: flatbuffers::VOffsetT = 38;
    pub const VT_COUNTENDTS: flatbuffers::VOffsetT = 40;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MissionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MissionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MissionData<'bldr>> {
        let mut builder = clz_Torappu_MissionDataBuilder::new(_fbb);
        builder.add_countEndTs(args.countEndTs);
        if let Some(x) = args.foldId {
            builder.add_foldId(x);
        }
        if let Some(x) = args.backImagePath {
            builder.add_backImagePath(x);
        }
        if let Some(x) = args.rewards {
            builder.add_rewards(x);
        }
        builder.add_periodicalPoint(args.periodicalPoint);
        if let Some(x) = args.toPage {
            builder.add_toPage(x);
        }
        if let Some(x) = args.missionGroup {
            builder.add_missionGroup(x);
        }
        if let Some(x) = args.unlockParam {
            builder.add_unlockParam(x);
        }
        if let Some(x) = args.unlockCondition {
            builder.add_unlockCondition(x);
        }
        if let Some(x) = args.param {
            builder.add_param(x);
        }
        if let Some(x) = args.templateType {
            builder.add_templateType(x);
        }
        if let Some(x) = args.template {
            builder.add_template(x);
        }
        if let Some(x) = args.preMissionIds {
            builder.add_preMissionIds(x);
        }
        builder.add_itemBgType(args.itemBgType);
        builder.add_type_(args.type_);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_haveSubMissionToUnlock(args.haveSubMissionToUnlock);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MissionDataT {
        let id = self.id().map(|x| x.to_string());
        let sortId = self.sortId();
        let description = self.description().map(|x| x.to_string());
        let type_ = self.type_();
        let itemBgType = self.itemBgType();
        let preMissionIds = self
            .preMissionIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let template = self.template().map(|x| x.to_string());
        let templateType = self.templateType().map(|x| x.to_string());
        let param = self
            .param()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let unlockCondition = self.unlockCondition().map(|x| x.to_string());
        let unlockParam = self
            .unlockParam()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let missionGroup = self.missionGroup().map(|x| x.to_string());
        let toPage = self.toPage().map(|x| x.to_string());
        let periodicalPoint = self.periodicalPoint();
        let rewards = self
            .rewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let backImagePath = self.backImagePath().map(|x| x.to_string());
        let foldId = self.foldId().map(|x| x.to_string());
        let haveSubMissionToUnlock = self.haveSubMissionToUnlock();
        let countEndTs = self.countEndTs();
        clz_Torappu_MissionDataT {
            id,
            sortId,
            description,
            type_,
            itemBgType,
            preMissionIds,
            template,
            templateType,
            param,
            unlockCondition,
            unlockParam,
            missionGroup,
            toPage,
            periodicalPoint,
            rewards,
            backImagePath,
            foldId,
            haveSubMissionToUnlock,
            countEndTs,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_MissionData::VT_ID, None)
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_MissionData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MissionData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_MissionType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_MissionType>(
                    clz_Torappu_MissionData::VT_TYPE_,
                    Some(enum__Torappu_MissionType::UNKNOWN),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemBgType(&self) -> enum__Torappu_MissionItemBgType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_MissionItemBgType>(
                    clz_Torappu_MissionData::VT_ITEMBGTYPE,
                    Some(enum__Torappu_MissionItemBgType::COMMON),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn preMissionIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_MissionData::VT_PREMISSIONIDS, None)
        }
    }
    #[inline]
    pub fn template(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MissionData::VT_TEMPLATE,
                None,
            )
        }
    }
    #[inline]
    pub fn templateType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MissionData::VT_TEMPLATETYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn param(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_MissionData::VT_PARAM, None)
        }
    }
    #[inline]
    pub fn unlockCondition(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MissionData::VT_UNLOCKCONDITION,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockParam(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_MissionData::VT_UNLOCKPARAM, None)
        }
    }
    #[inline]
    pub fn missionGroup(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MissionData::VT_MISSIONGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn toPage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_MissionData::VT_TOPAGE, None)
        }
    }
    #[inline]
    pub fn periodicalPoint(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_MissionData::VT_PERIODICALPOINT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn rewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards>,
                >,
            >>(clz_Torappu_MissionData::VT_REWARDS, None)
        }
    }
    #[inline]
    pub fn backImagePath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MissionData::VT_BACKIMAGEPATH,
                None,
            )
        }
    }
    #[inline]
    pub fn foldId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_MissionData::VT_FOLDID, None)
        }
    }
    #[inline]
    pub fn haveSubMissionToUnlock(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_MissionData::VT_HAVESUBMISSIONTOUNLOCK,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn countEndTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_MissionData::VT_COUNTENDTS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MissionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<enum__Torappu_MissionType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<enum__Torappu_MissionItemBgType>(
                "itemBgType",
                Self::VT_ITEMBGTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("preMissionIds", Self::VT_PREMISSIONIDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "template",
                Self::VT_TEMPLATE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "templateType",
                Self::VT_TEMPLATETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("param", Self::VT_PARAM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockCondition",
                Self::VT_UNLOCKCONDITION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("unlockParam", Self::VT_UNLOCKPARAM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "missionGroup",
                Self::VT_MISSIONGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("toPage", Self::VT_TOPAGE, false)?
            .visit_field::<i32>("periodicalPoint", Self::VT_PERIODICALPOINT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards>,
                >,
            >>("rewards", Self::VT_REWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "backImagePath",
                Self::VT_BACKIMAGEPATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("foldId", Self::VT_FOLDID, false)?
            .visit_field::<bool>(
                "haveSubMissionToUnlock",
                Self::VT_HAVESUBMISSIONTOUNLOCK,
                false,
            )?
            .visit_field::<i64>("countEndTs", Self::VT_COUNTENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MissionDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_MissionType,
    pub itemBgType: enum__Torappu_MissionItemBgType,
    pub preMissionIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub template: Option<flatbuffers::WIPOffset<&'a str>>,
    pub templateType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub param: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub unlockCondition: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockParam: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub missionGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub toPage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub periodicalPoint: i32,
    pub rewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards<'a>>,
            >,
        >,
    >,
    pub backImagePath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub foldId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub haveSubMissionToUnlock: bool,
    pub countEndTs: i64,
}
impl<'a> Default for clz_Torappu_MissionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MissionDataArgs {
            id: None,
            sortId: 0,
            description: None,
            type_: enum__Torappu_MissionType::UNKNOWN,
            itemBgType: enum__Torappu_MissionItemBgType::COMMON,
            preMissionIds: None,
            template: None,
            templateType: None,
            param: None,
            unlockCondition: None,
            unlockParam: None,
            missionGroup: None,
            toPage: None,
            periodicalPoint: 0,
            rewards: None,
            backImagePath: None,
            foldId: None,
            haveSubMissionToUnlock: false,
            countEndTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_MissionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MissionData", 19)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("itemBgType", &self.itemBgType())?;
        if let Some(f) = self.preMissionIds() {
            s.serialize_field("preMissionIds", &f)?;
        } else {
            s.skip_field("preMissionIds")?;
        }
        if let Some(f) = self.template() {
            s.serialize_field("template", &f)?;
        } else {
            s.skip_field("template")?;
        }
        if let Some(f) = self.templateType() {
            s.serialize_field("templateType", &f)?;
        } else {
            s.skip_field("templateType")?;
        }
        if let Some(f) = self.param() {
            s.serialize_field("param", &f)?;
        } else {
            s.skip_field("param")?;
        }
        if let Some(f) = self.unlockCondition() {
            s.serialize_field("unlockCondition", &f)?;
        } else {
            s.skip_field("unlockCondition")?;
        }
        if let Some(f) = self.unlockParam() {
            s.serialize_field("unlockParam", &f)?;
        } else {
            s.skip_field("unlockParam")?;
        }
        if let Some(f) = self.missionGroup() {
            s.serialize_field("missionGroup", &f)?;
        } else {
            s.skip_field("missionGroup")?;
        }
        if let Some(f) = self.toPage() {
            s.serialize_field("toPage", &f)?;
        } else {
            s.skip_field("toPage")?;
        }
        s.serialize_field("periodicalPoint", &self.periodicalPoint())?;
        if let Some(f) = self.rewards() {
            s.serialize_field("rewards", &f)?;
        } else {
            s.skip_field("rewards")?;
        }
        if let Some(f) = self.backImagePath() {
            s.serialize_field("backImagePath", &f)?;
        } else {
            s.skip_field("backImagePath")?;
        }
        if let Some(f) = self.foldId() {
            s.serialize_field("foldId", &f)?;
        } else {
            s.skip_field("foldId")?;
        }
        s.serialize_field("haveSubMissionToUnlock", &self.haveSubMissionToUnlock())?;
        s.serialize_field("countEndTs", &self.countEndTs())?;
        s.end()
    }
}

pub struct clz_Torappu_MissionDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_MissionDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_MissionData::VT_ID, id);
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_MissionData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_MissionType) {
        self.fbb_.push_slot::<enum__Torappu_MissionType>(
            clz_Torappu_MissionData::VT_TYPE_,
            type_,
            enum__Torappu_MissionType::UNKNOWN,
        );
    }
    #[inline]
    pub fn add_itemBgType(&mut self, itemBgType: enum__Torappu_MissionItemBgType) {
        self.fbb_.push_slot::<enum__Torappu_MissionItemBgType>(
            clz_Torappu_MissionData::VT_ITEMBGTYPE,
            itemBgType,
            enum__Torappu_MissionItemBgType::COMMON,
        );
    }
    #[inline]
    pub fn add_preMissionIds(
        &mut self,
        preMissionIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionData::VT_PREMISSIONIDS,
            preMissionIds,
        );
    }
    #[inline]
    pub fn add_template(&mut self, template: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionData::VT_TEMPLATE,
            template,
        );
    }
    #[inline]
    pub fn add_templateType(&mut self, templateType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionData::VT_TEMPLATETYPE,
            templateType,
        );
    }
    #[inline]
    pub fn add_param(
        &mut self,
        param: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionData::VT_PARAM,
            param,
        );
    }
    #[inline]
    pub fn add_unlockCondition(&mut self, unlockCondition: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionData::VT_UNLOCKCONDITION,
            unlockCondition,
        );
    }
    #[inline]
    pub fn add_unlockParam(
        &mut self,
        unlockParam: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionData::VT_UNLOCKPARAM,
            unlockParam,
        );
    }
    #[inline]
    pub fn add_missionGroup(&mut self, missionGroup: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionData::VT_MISSIONGROUP,
            missionGroup,
        );
    }
    #[inline]
    pub fn add_toPage(&mut self, toPage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionData::VT_TOPAGE,
            toPage,
        );
    }
    #[inline]
    pub fn add_periodicalPoint(&mut self, periodicalPoint: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_MissionData::VT_PERIODICALPOINT,
            periodicalPoint,
            0,
        );
    }
    #[inline]
    pub fn add_rewards(
        &mut self,
        rewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionData::VT_REWARDS,
            rewards,
        );
    }
    #[inline]
    pub fn add_backImagePath(&mut self, backImagePath: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionData::VT_BACKIMAGEPATH,
            backImagePath,
        );
    }
    #[inline]
    pub fn add_foldId(&mut self, foldId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionData::VT_FOLDID,
            foldId,
        );
    }
    #[inline]
    pub fn add_haveSubMissionToUnlock(&mut self, haveSubMissionToUnlock: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_MissionData::VT_HAVESUBMISSIONTOUNLOCK,
            haveSubMissionToUnlock,
            false,
        );
    }
    #[inline]
    pub fn add_countEndTs(&mut self, countEndTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_MissionData::VT_COUNTENDTS, countEndTs, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MissionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MissionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MissionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MissionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MissionData");
        ds.field("id", &self.id());
        ds.field("sortId", &self.sortId());
        ds.field("description", &self.description());
        ds.field("type_", &self.type_());
        ds.field("itemBgType", &self.itemBgType());
        ds.field("preMissionIds", &self.preMissionIds());
        ds.field("template", &self.template());
        ds.field("templateType", &self.templateType());
        ds.field("param", &self.param());
        ds.field("unlockCondition", &self.unlockCondition());
        ds.field("unlockParam", &self.unlockParam());
        ds.field("missionGroup", &self.missionGroup());
        ds.field("toPage", &self.toPage());
        ds.field("periodicalPoint", &self.periodicalPoint());
        ds.field("rewards", &self.rewards());
        ds.field("backImagePath", &self.backImagePath());
        ds.field("foldId", &self.foldId());
        ds.field("haveSubMissionToUnlock", &self.haveSubMissionToUnlock());
        ds.field("countEndTs", &self.countEndTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MissionDataT {
    pub id: Option<String>,
    pub sortId: i32,
    pub description: Option<String>,
    pub type_: enum__Torappu_MissionType,
    pub itemBgType: enum__Torappu_MissionItemBgType,
    pub preMissionIds: Option<Vec<String>>,
    pub template: Option<String>,
    pub templateType: Option<String>,
    pub param: Option<Vec<String>>,
    pub unlockCondition: Option<String>,
    pub unlockParam: Option<Vec<String>>,
    pub missionGroup: Option<String>,
    pub toPage: Option<String>,
    pub periodicalPoint: i32,
    pub rewards: Option<Vec<clz_Torappu_MissionDisplayRewardsT>>,
    pub backImagePath: Option<String>,
    pub foldId: Option<String>,
    pub haveSubMissionToUnlock: bool,
    pub countEndTs: i64,
}
impl Default for clz_Torappu_MissionDataT {
    fn default() -> Self {
        Self {
            id: None,
            sortId: 0,
            description: None,
            type_: enum__Torappu_MissionType::UNKNOWN,
            itemBgType: enum__Torappu_MissionItemBgType::COMMON,
            preMissionIds: None,
            template: None,
            templateType: None,
            param: None,
            unlockCondition: None,
            unlockParam: None,
            missionGroup: None,
            toPage: None,
            periodicalPoint: 0,
            rewards: None,
            backImagePath: None,
            foldId: None,
            haveSubMissionToUnlock: false,
            countEndTs: 0,
        }
    }
}
impl clz_Torappu_MissionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MissionData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let itemBgType = self.itemBgType;
        let preMissionIds = self.preMissionIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let template = self.template.as_ref().map(|x| _fbb.create_string(x));
        let templateType = self.templateType.as_ref().map(|x| _fbb.create_string(x));
        let param = self.param.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let unlockCondition = self.unlockCondition.as_ref().map(|x| _fbb.create_string(x));
        let unlockParam = self.unlockParam.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let missionGroup = self.missionGroup.as_ref().map(|x| _fbb.create_string(x));
        let toPage = self.toPage.as_ref().map(|x| _fbb.create_string(x));
        let periodicalPoint = self.periodicalPoint;
        let rewards = self.rewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let backImagePath = self.backImagePath.as_ref().map(|x| _fbb.create_string(x));
        let foldId = self.foldId.as_ref().map(|x| _fbb.create_string(x));
        let haveSubMissionToUnlock = self.haveSubMissionToUnlock;
        let countEndTs = self.countEndTs;
        clz_Torappu_MissionData::create(
            _fbb,
            &clz_Torappu_MissionDataArgs {
                id,
                sortId,
                description,
                type_,
                itemBgType,
                preMissionIds,
                template,
                templateType,
                param,
                unlockCondition,
                unlockParam,
                missionGroup,
                toPage,
                periodicalPoint,
                rewards,
                backImagePath,
                foldId,
                haveSubMissionToUnlock,
                countEndTs,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_MissionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_MissionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_MissionData<'a> {
    type Inner = dict__string__clz_Torappu_MissionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_MissionData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_MissionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_MissionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MissionData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_MissionDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_MissionDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_MissionDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_MissionData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_MissionData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_MissionData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_MissionData>>(
                    dict__string__clz_Torappu_MissionData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_MissionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_MissionData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_MissionDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_MissionData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_MissionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_MissionDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_MissionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_MissionData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_MissionDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_MissionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_MissionData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_MissionData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_MissionData>>(
                dict__string__clz_Torappu_MissionData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_MissionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_MissionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MissionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_MissionData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_MissionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_MissionData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_MissionDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_MissionDataT>>,
}
impl Default for dict__string__clz_Torappu_MissionDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_MissionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MissionData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_MissionData::create(
            _fbb,
            &dict__string__clz_Torappu_MissionDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_MissionGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MissionGroup<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MissionGroup<'a> {
    type Inner = clz_Torappu_MissionGroup<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MissionGroup<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TITLE: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
    pub const VT_PREMISSIONGROUP: flatbuffers::VOffsetT = 10;
    pub const VT_PERIOD: flatbuffers::VOffsetT = 12;
    pub const VT_REWARDS: flatbuffers::VOffsetT = 14;
    pub const VT_MISSIONIDS: flatbuffers::VOffsetT = 16;
    pub const VT_STARTTS: flatbuffers::VOffsetT = 18;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MissionGroup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MissionGroupArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MissionGroup<'bldr>> {
        let mut builder = clz_Torappu_MissionGroupBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        if let Some(x) = args.missionIds {
            builder.add_missionIds(x);
        }
        if let Some(x) = args.rewards {
            builder.add_rewards(x);
        }
        if let Some(x) = args.period {
            builder.add_period(x);
        }
        if let Some(x) = args.preMissionGroup {
            builder.add_preMissionGroup(x);
        }
        builder.add_type_(args.type_);
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MissionGroupT {
        let id = self.id().map(|x| x.to_string());
        let title = self.title().map(|x| x.to_string());
        let type_ = self.type_();
        let preMissionGroup = self.preMissionGroup().map(|x| x.to_string());
        let period = self.period().map(|x| x.into_iter().collect());
        let rewards = self
            .rewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let missionIds = self
            .missionIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let startTs = self.startTs();
        let endTs = self.endTs();
        clz_Torappu_MissionGroupT {
            id,
            title,
            type_,
            preMissionGroup,
            period,
            rewards,
            missionIds,
            startTs,
            endTs,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_MissionGroup::VT_ID, None)
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_MissionGroup::VT_TITLE, None)
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_MissionType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_MissionType>(
                    clz_Torappu_MissionGroup::VT_TYPE_,
                    Some(enum__Torappu_MissionType::UNKNOWN),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn preMissionGroup(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_MissionGroup::VT_PREMISSIONGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn period(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_MissionGroup::VT_PERIOD,
                    None,
                )
        }
    }
    #[inline]
    pub fn rewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards>,
                >,
            >>(clz_Torappu_MissionGroup::VT_REWARDS, None)
        }
    }
    #[inline]
    pub fn missionIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_MissionGroup::VT_MISSIONIDS, None)
        }
    }
    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_MissionGroup::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_MissionGroup::VT_ENDTS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MissionGroup<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<enum__Torappu_MissionType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "preMissionGroup",
                Self::VT_PREMISSIONGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "period",
                Self::VT_PERIOD,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards>,
                >,
            >>("rewards", Self::VT_REWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("missionIds", Self::VT_MISSIONIDS, false)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MissionGroupArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_MissionType,
    pub preMissionGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub period: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub rewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards<'a>>,
            >,
        >,
    >,
    pub missionIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub startTs: i64,
    pub endTs: i64,
}
impl<'a> Default for clz_Torappu_MissionGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MissionGroupArgs {
            id: None,
            title: None,
            type_: enum__Torappu_MissionType::UNKNOWN,
            preMissionGroup: None,
            period: None,
            rewards: None,
            missionIds: None,
            startTs: 0,
            endTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_MissionGroup<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MissionGroup", 9)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.title() {
            s.serialize_field("title", &f)?;
        } else {
            s.skip_field("title")?;
        }
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.preMissionGroup() {
            s.serialize_field("preMissionGroup", &f)?;
        } else {
            s.skip_field("preMissionGroup")?;
        }
        if let Some(f) = self.period() {
            s.serialize_field("period", &f)?;
        } else {
            s.skip_field("period")?;
        }
        if let Some(f) = self.rewards() {
            s.serialize_field("rewards", &f)?;
        } else {
            s.skip_field("rewards")?;
        }
        if let Some(f) = self.missionIds() {
            s.serialize_field("missionIds", &f)?;
        } else {
            s.skip_field("missionIds")?;
        }
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        s.end()
    }
}

pub struct clz_Torappu_MissionGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_MissionGroupBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_MissionGroup::VT_ID, id);
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionGroup::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_MissionType) {
        self.fbb_.push_slot::<enum__Torappu_MissionType>(
            clz_Torappu_MissionGroup::VT_TYPE_,
            type_,
            enum__Torappu_MissionType::UNKNOWN,
        );
    }
    #[inline]
    pub fn add_preMissionGroup(&mut self, preMissionGroup: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionGroup::VT_PREMISSIONGROUP,
            preMissionGroup,
        );
    }
    #[inline]
    pub fn add_period(&mut self, period: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionGroup::VT_PERIOD,
            period,
        );
    }
    #[inline]
    pub fn add_rewards(
        &mut self,
        rewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_MissionDisplayRewards<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionGroup::VT_REWARDS,
            rewards,
        );
    }
    #[inline]
    pub fn add_missionIds(
        &mut self,
        missionIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MissionGroup::VT_MISSIONIDS,
            missionIds,
        );
    }
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_MissionGroup::VT_STARTTS, startTs, 0);
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_MissionGroup::VT_ENDTS, endTs, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MissionGroupBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MissionGroupBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MissionGroup<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MissionGroup<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MissionGroup");
        ds.field("id", &self.id());
        ds.field("title", &self.title());
        ds.field("type_", &self.type_());
        ds.field("preMissionGroup", &self.preMissionGroup());
        ds.field("period", &self.period());
        ds.field("rewards", &self.rewards());
        ds.field("missionIds", &self.missionIds());
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MissionGroupT {
    pub id: Option<String>,
    pub title: Option<String>,
    pub type_: enum__Torappu_MissionType,
    pub preMissionGroup: Option<String>,
    pub period: Option<Vec<i32>>,
    pub rewards: Option<Vec<clz_Torappu_MissionDisplayRewardsT>>,
    pub missionIds: Option<Vec<String>>,
    pub startTs: i64,
    pub endTs: i64,
}
impl Default for clz_Torappu_MissionGroupT {
    fn default() -> Self {
        Self {
            id: None,
            title: None,
            type_: enum__Torappu_MissionType::UNKNOWN,
            preMissionGroup: None,
            period: None,
            rewards: None,
            missionIds: None,
            startTs: 0,
            endTs: 0,
        }
    }
}
impl clz_Torappu_MissionGroupT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MissionGroup<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let title = self.title.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let preMissionGroup = self.preMissionGroup.as_ref().map(|x| _fbb.create_string(x));
        let period = self.period.as_ref().map(|x| _fbb.create_vector(x));
        let rewards = self.rewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let missionIds = self.missionIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let startTs = self.startTs;
        let endTs = self.endTs;
        clz_Torappu_MissionGroup::create(
            _fbb,
            &clz_Torappu_MissionGroupArgs {
                id,
                title,
                type_,
                preMissionGroup,
                period,
                rewards,
                missionIds,
                startTs,
                endTs,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_MissionGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_MissionGroup<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_MissionGroup<'a> {
    type Inner = dict__string__clz_Torappu_MissionGroup<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_MissionGroup<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_MissionGroup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_MissionGroupArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MissionGroup<'bldr>> {
        let mut builder = dict__string__clz_Torappu_MissionGroupBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_MissionGroupT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_MissionGroupT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_MissionGroup::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_MissionGroup) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_MissionGroup<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_MissionGroup>>(
                    dict__string__clz_Torappu_MissionGroup::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_MissionGroup<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_MissionGroup>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_MissionGroupArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_MissionGroup<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_MissionGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_MissionGroupArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_MissionGroup<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_MissionGroup", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_MissionGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_MissionGroupBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_MissionGroup::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_MissionGroup<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_MissionGroup>>(
                dict__string__clz_Torappu_MissionGroup::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_MissionGroupBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_MissionGroupBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MissionGroup<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_MissionGroup::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_MissionGroup<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_MissionGroup");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_MissionGroupT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_MissionGroupT>>,
}
impl Default for dict__string__clz_Torappu_MissionGroupT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_MissionGroupT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_MissionGroup<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_MissionGroup::create(
            _fbb,
            &dict__string__clz_Torappu_MissionGroupArgs { key, value },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorConstDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorConstData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorConstData<'a> {
    type Inner = clz_Torappu_SpecialOperatorConstData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorConstData<'a> {
    pub const VT_WEEKLYTASKBOARDUNLOCK: flatbuffers::VOffsetT = 4;
    pub const VT_TASKPINONTOAST: flatbuffers::VOffsetT = 6;
    pub const VT_NOFRONTNODETOAST: flatbuffers::VOffsetT = 8;
    pub const VT_NOFRONTTASKTOAST: flatbuffers::VOffsetT = 10;
    pub const VT_SKILLGOTOTOAST: flatbuffers::VOffsetT = 12;
    pub const VT_EVOLVETABEXPNOTICE: flatbuffers::VOffsetT = 14;
    pub const VT_PINNEDSPECIALOPERATOR: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorConstData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorConstDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorConstData<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorConstDataBuilder::new(_fbb);
        if let Some(x) = args.pinnedSpecialOperator {
            builder.add_pinnedSpecialOperator(x);
        }
        if let Some(x) = args.evolveTabExpNotice {
            builder.add_evolveTabExpNotice(x);
        }
        if let Some(x) = args.skillGotoToast {
            builder.add_skillGotoToast(x);
        }
        if let Some(x) = args.noFrontTaskToast {
            builder.add_noFrontTaskToast(x);
        }
        if let Some(x) = args.noFrontNodeToast {
            builder.add_noFrontNodeToast(x);
        }
        if let Some(x) = args.taskPinOnToast {
            builder.add_taskPinOnToast(x);
        }
        if let Some(x) = args.weeklyTaskBoardUnlock {
            builder.add_weeklyTaskBoardUnlock(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorConstDataT {
        let weeklyTaskBoardUnlock = self.weeklyTaskBoardUnlock().map(|x| x.to_string());
        let taskPinOnToast = self.taskPinOnToast().map(|x| x.to_string());
        let noFrontNodeToast = self.noFrontNodeToast().map(|x| x.to_string());
        let noFrontTaskToast = self.noFrontTaskToast().map(|x| x.to_string());
        let skillGotoToast = self.skillGotoToast().map(|x| x.to_string());
        let evolveTabExpNotice = self.evolveTabExpNotice().map(|x| x.to_string());
        let pinnedSpecialOperator = self.pinnedSpecialOperator().map(|x| x.to_string());
        clz_Torappu_SpecialOperatorConstDataT {
            weeklyTaskBoardUnlock,
            taskPinOnToast,
            noFrontNodeToast,
            noFrontTaskToast,
            skillGotoToast,
            evolveTabExpNotice,
            pinnedSpecialOperator,
        }
    }

    #[inline]
    pub fn weeklyTaskBoardUnlock(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorConstData::VT_WEEKLYTASKBOARDUNLOCK,
                None,
            )
        }
    }
    #[inline]
    pub fn taskPinOnToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorConstData::VT_TASKPINONTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn noFrontNodeToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorConstData::VT_NOFRONTNODETOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn noFrontTaskToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorConstData::VT_NOFRONTTASKTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn skillGotoToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorConstData::VT_SKILLGOTOTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn evolveTabExpNotice(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorConstData::VT_EVOLVETABEXPNOTICE,
                None,
            )
        }
    }
    #[inline]
    pub fn pinnedSpecialOperator(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_SpecialOperatorConstData::VT_PINNEDSPECIALOPERATOR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorConstData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weeklyTaskBoardUnlock",
                Self::VT_WEEKLYTASKBOARDUNLOCK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "taskPinOnToast",
                Self::VT_TASKPINONTOAST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noFrontNodeToast",
                Self::VT_NOFRONTNODETOAST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "noFrontTaskToast",
                Self::VT_NOFRONTTASKTOAST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "skillGotoToast",
                Self::VT_SKILLGOTOTOAST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "evolveTabExpNotice",
                Self::VT_EVOLVETABEXPNOTICE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "pinnedSpecialOperator",
                Self::VT_PINNEDSPECIALOPERATOR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorConstDataArgs<'a> {
    pub weeklyTaskBoardUnlock: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskPinOnToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noFrontNodeToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub noFrontTaskToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub skillGotoToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub evolveTabExpNotice: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pinnedSpecialOperator: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_SpecialOperatorConstDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorConstDataArgs {
            weeklyTaskBoardUnlock: None,
            taskPinOnToast: None,
            noFrontNodeToast: None,
            noFrontTaskToast: None,
            skillGotoToast: None,
            evolveTabExpNotice: None,
            pinnedSpecialOperator: None,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorConstData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SpecialOperatorConstData", 7)?;
        if let Some(f) = self.weeklyTaskBoardUnlock() {
            s.serialize_field("weeklyTaskBoardUnlock", &f)?;
        } else {
            s.skip_field("weeklyTaskBoardUnlock")?;
        }
        if let Some(f) = self.taskPinOnToast() {
            s.serialize_field("taskPinOnToast", &f)?;
        } else {
            s.skip_field("taskPinOnToast")?;
        }
        if let Some(f) = self.noFrontNodeToast() {
            s.serialize_field("noFrontNodeToast", &f)?;
        } else {
            s.skip_field("noFrontNodeToast")?;
        }
        if let Some(f) = self.noFrontTaskToast() {
            s.serialize_field("noFrontTaskToast", &f)?;
        } else {
            s.skip_field("noFrontTaskToast")?;
        }
        if let Some(f) = self.skillGotoToast() {
            s.serialize_field("skillGotoToast", &f)?;
        } else {
            s.skip_field("skillGotoToast")?;
        }
        if let Some(f) = self.evolveTabExpNotice() {
            s.serialize_field("evolveTabExpNotice", &f)?;
        } else {
            s.skip_field("evolveTabExpNotice")?;
        }
        if let Some(f) = self.pinnedSpecialOperator() {
            s.serialize_field("pinnedSpecialOperator", &f)?;
        } else {
            s.skip_field("pinnedSpecialOperator")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorConstDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorConstDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_weeklyTaskBoardUnlock(
        &mut self,
        weeklyTaskBoardUnlock: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorConstData::VT_WEEKLYTASKBOARDUNLOCK,
            weeklyTaskBoardUnlock,
        );
    }
    #[inline]
    pub fn add_taskPinOnToast(&mut self, taskPinOnToast: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorConstData::VT_TASKPINONTOAST,
            taskPinOnToast,
        );
    }
    #[inline]
    pub fn add_noFrontNodeToast(&mut self, noFrontNodeToast: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorConstData::VT_NOFRONTNODETOAST,
            noFrontNodeToast,
        );
    }
    #[inline]
    pub fn add_noFrontTaskToast(&mut self, noFrontTaskToast: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorConstData::VT_NOFRONTTASKTOAST,
            noFrontTaskToast,
        );
    }
    #[inline]
    pub fn add_skillGotoToast(&mut self, skillGotoToast: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorConstData::VT_SKILLGOTOTOAST,
            skillGotoToast,
        );
    }
    #[inline]
    pub fn add_evolveTabExpNotice(&mut self, evolveTabExpNotice: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorConstData::VT_EVOLVETABEXPNOTICE,
            evolveTabExpNotice,
        );
    }
    #[inline]
    pub fn add_pinnedSpecialOperator(
        &mut self,
        pinnedSpecialOperator: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorConstData::VT_PINNEDSPECIALOPERATOR,
            pinnedSpecialOperator,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorConstDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorConstDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorConstData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorConstData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorConstData");
        ds.field("weeklyTaskBoardUnlock", &self.weeklyTaskBoardUnlock());
        ds.field("taskPinOnToast", &self.taskPinOnToast());
        ds.field("noFrontNodeToast", &self.noFrontNodeToast());
        ds.field("noFrontTaskToast", &self.noFrontTaskToast());
        ds.field("skillGotoToast", &self.skillGotoToast());
        ds.field("evolveTabExpNotice", &self.evolveTabExpNotice());
        ds.field("pinnedSpecialOperator", &self.pinnedSpecialOperator());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorConstDataT {
    pub weeklyTaskBoardUnlock: Option<String>,
    pub taskPinOnToast: Option<String>,
    pub noFrontNodeToast: Option<String>,
    pub noFrontTaskToast: Option<String>,
    pub skillGotoToast: Option<String>,
    pub evolveTabExpNotice: Option<String>,
    pub pinnedSpecialOperator: Option<String>,
}
impl Default for clz_Torappu_SpecialOperatorConstDataT {
    fn default() -> Self {
        Self {
            weeklyTaskBoardUnlock: None,
            taskPinOnToast: None,
            noFrontNodeToast: None,
            noFrontTaskToast: None,
            skillGotoToast: None,
            evolveTabExpNotice: None,
            pinnedSpecialOperator: None,
        }
    }
}
impl clz_Torappu_SpecialOperatorConstDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorConstData<'b>> {
        let weeklyTaskBoardUnlock = self
            .weeklyTaskBoardUnlock
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let taskPinOnToast = self.taskPinOnToast.as_ref().map(|x| _fbb.create_string(x));
        let noFrontNodeToast = self
            .noFrontNodeToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let noFrontTaskToast = self
            .noFrontTaskToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let skillGotoToast = self.skillGotoToast.as_ref().map(|x| _fbb.create_string(x));
        let evolveTabExpNotice = self
            .evolveTabExpNotice
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let pinnedSpecialOperator = self
            .pinnedSpecialOperator
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_SpecialOperatorConstData::create(
            _fbb,
            &clz_Torappu_SpecialOperatorConstDataArgs {
                weeklyTaskBoardUnlock,
                taskPinOnToast,
                noFrontNodeToast,
                noFrontTaskToast,
                skillGotoToast,
                evolveTabExpNotice,
                pinnedSpecialOperator,
            },
        )
    }
}
pub enum clz_Torappu_SpecialOperatorTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_SpecialOperatorTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_SpecialOperatorTable<'a> {
    type Inner = clz_Torappu_SpecialOperatorTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_SpecialOperatorTable<'a> {
    pub const VT_OPERATORBASICDATA: flatbuffers::VOffsetT = 4;
    pub const VT_OPERATORDETAILDATA: flatbuffers::VOffsetT = 6;
    pub const VT_MODEDATA: flatbuffers::VOffsetT = 8;
    pub const VT_NODEUNLOCKMISSIONDATA: flatbuffers::VOffsetT = 10;
    pub const VT_NODEUNLOCKMISSIONGROUP: flatbuffers::VOffsetT = 12;
    pub const VT_CONSTDATA: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_SpecialOperatorTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_SpecialOperatorTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorTable<'bldr>> {
        let mut builder = clz_Torappu_SpecialOperatorTableBuilder::new(_fbb);
        if let Some(x) = args.constData {
            builder.add_constData(x);
        }
        if let Some(x) = args.nodeUnlockMissionGroup {
            builder.add_nodeUnlockMissionGroup(x);
        }
        if let Some(x) = args.nodeUnlockMissionData {
            builder.add_nodeUnlockMissionData(x);
        }
        if let Some(x) = args.modeData {
            builder.add_modeData(x);
        }
        if let Some(x) = args.operatorDetailData {
            builder.add_operatorDetailData(x);
        }
        if let Some(x) = args.operatorBasicData {
            builder.add_operatorBasicData(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_SpecialOperatorTableT {
        let operatorBasicData = self
            .operatorBasicData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let operatorDetailData = self
            .operatorDetailData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let modeData = self
            .modeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let nodeUnlockMissionData = self
            .nodeUnlockMissionData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let nodeUnlockMissionGroup = self
            .nodeUnlockMissionGroup()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let constData = self.constData().map(|x| Box::new(x.unpack()));
        clz_Torappu_SpecialOperatorTableT {
            operatorBasicData,
            operatorDetailData,
            modeData,
            nodeUnlockMissionData,
            nodeUnlockMissionGroup,
            constData,
        }
    }

    #[inline]
    pub fn operatorBasicData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SpecialOperatorBasicData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorBasicData,
                    >,
                >,
            >>(clz_Torappu_SpecialOperatorTable::VT_OPERATORBASICDATA, None)
        }
    }
    #[inline]
    pub fn operatorDetailData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_SpecialOperatorDetailData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorDetailData,
                    >,
                >,
            >>(
                clz_Torappu_SpecialOperatorTable::VT_OPERATORDETAILDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn modeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorModeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorModeData>,
                >,
            >>(clz_Torappu_SpecialOperatorTable::VT_MODEDATA, None)
        }
    }
    #[inline]
    pub fn nodeUnlockMissionData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MissionData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MissionData>,
                >,
            >>(
                clz_Torappu_SpecialOperatorTable::VT_NODEUNLOCKMISSIONDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeUnlockMissionGroup(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MissionGroup<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MissionGroup>,
                >,
            >>(
                clz_Torappu_SpecialOperatorTable::VT_NODEUNLOCKMISSIONGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn constData(&self) -> Option<clz_Torappu_SpecialOperatorConstData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorConstData>>(
                    clz_Torappu_SpecialOperatorTable::VT_CONSTDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_SpecialOperatorTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorBasicData,
                    >,
                >,
            >>("operatorBasicData", Self::VT_OPERATORBASICDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_SpecialOperatorDetailData,
                    >,
                >,
            >>("operatorDetailData", Self::VT_OPERATORDETAILDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorModeData>,
                >,
            >>("modeData", Self::VT_MODEDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MissionData>,
                >,
            >>(
                "nodeUnlockMissionData",
                Self::VT_NODEUNLOCKMISSIONDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MissionGroup>,
                >,
            >>(
                "nodeUnlockMissionGroup",
                Self::VT_NODEUNLOCKMISSIONGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorConstData>>(
                "constData",
                Self::VT_CONSTDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_SpecialOperatorTableArgs<'a> {
    pub operatorBasicData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorBasicData<'a>,
                >,
            >,
        >,
    >,
    pub operatorDetailData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailData<'a>,
                >,
            >,
        >,
    >,
    pub modeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorModeData<'a>>,
            >,
        >,
    >,
    pub nodeUnlockMissionData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MissionData<'a>>,
            >,
        >,
    >,
    pub nodeUnlockMissionGroup: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MissionGroup<'a>>,
            >,
        >,
    >,
    pub constData: Option<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorConstData<'a>>>,
}
impl<'a> Default for clz_Torappu_SpecialOperatorTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_SpecialOperatorTableArgs {
            operatorBasicData: None,
            operatorDetailData: None,
            modeData: None,
            nodeUnlockMissionData: None,
            nodeUnlockMissionGroup: None,
            constData: None,
        }
    }
}

impl Serialize for clz_Torappu_SpecialOperatorTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_SpecialOperatorTable", 6)?;
        if let Some(f) = self.operatorBasicData() {
            s.serialize_field("operatorBasicData", &f)?;
        } else {
            s.skip_field("operatorBasicData")?;
        }
        if let Some(f) = self.operatorDetailData() {
            s.serialize_field("operatorDetailData", &f)?;
        } else {
            s.skip_field("operatorDetailData")?;
        }
        if let Some(f) = self.modeData() {
            s.serialize_field("modeData", &f)?;
        } else {
            s.skip_field("modeData")?;
        }
        if let Some(f) = self.nodeUnlockMissionData() {
            s.serialize_field("nodeUnlockMissionData", &f)?;
        } else {
            s.skip_field("nodeUnlockMissionData")?;
        }
        if let Some(f) = self.nodeUnlockMissionGroup() {
            s.serialize_field("nodeUnlockMissionGroup", &f)?;
        } else {
            s.skip_field("nodeUnlockMissionGroup")?;
        }
        if let Some(f) = self.constData() {
            s.serialize_field("constData", &f)?;
        } else {
            s.skip_field("constData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_SpecialOperatorTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_SpecialOperatorTableBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_operatorBasicData(
        &mut self,
        operatorBasicData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorBasicData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorTable::VT_OPERATORBASICDATA,
            operatorBasicData,
        );
    }
    #[inline]
    pub fn add_operatorDetailData(
        &mut self,
        operatorDetailData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_SpecialOperatorDetailData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorTable::VT_OPERATORDETAILDATA,
            operatorDetailData,
        );
    }
    #[inline]
    pub fn add_modeData(
        &mut self,
        modeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_SpecialOperatorModeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorTable::VT_MODEDATA,
            modeData,
        );
    }
    #[inline]
    pub fn add_nodeUnlockMissionData(
        &mut self,
        nodeUnlockMissionData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MissionData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorTable::VT_NODEUNLOCKMISSIONDATA,
            nodeUnlockMissionData,
        );
    }
    #[inline]
    pub fn add_nodeUnlockMissionGroup(
        &mut self,
        nodeUnlockMissionGroup: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_MissionGroup<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_SpecialOperatorTable::VT_NODEUNLOCKMISSIONGROUP,
            nodeUnlockMissionGroup,
        );
    }
    #[inline]
    pub fn add_constData(
        &mut self,
        constData: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorConstData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorConstData>>(
                clz_Torappu_SpecialOperatorTable::VT_CONSTDATA,
                constData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_SpecialOperatorTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_SpecialOperatorTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_SpecialOperatorTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_SpecialOperatorTable");
        ds.field("operatorBasicData", &self.operatorBasicData());
        ds.field("operatorDetailData", &self.operatorDetailData());
        ds.field("modeData", &self.modeData());
        ds.field("nodeUnlockMissionData", &self.nodeUnlockMissionData());
        ds.field("nodeUnlockMissionGroup", &self.nodeUnlockMissionGroup());
        ds.field("constData", &self.constData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_SpecialOperatorTableT {
    pub operatorBasicData: Option<Vec<dict__string__clz_Torappu_SpecialOperatorBasicDataT>>,
    pub operatorDetailData: Option<Vec<dict__string__clz_Torappu_SpecialOperatorDetailDataT>>,
    pub modeData: Option<Vec<clz_Torappu_SpecialOperatorModeDataT>>,
    pub nodeUnlockMissionData: Option<Vec<dict__string__clz_Torappu_MissionDataT>>,
    pub nodeUnlockMissionGroup: Option<Vec<dict__string__clz_Torappu_MissionGroupT>>,
    pub constData: Option<Box<clz_Torappu_SpecialOperatorConstDataT>>,
}
impl Default for clz_Torappu_SpecialOperatorTableT {
    fn default() -> Self {
        Self {
            operatorBasicData: None,
            operatorDetailData: None,
            modeData: None,
            nodeUnlockMissionData: None,
            nodeUnlockMissionGroup: None,
            constData: None,
        }
    }
}
impl clz_Torappu_SpecialOperatorTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorTable<'b>> {
        let operatorBasicData = self.operatorBasicData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let operatorDetailData = self.operatorDetailData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let modeData = self.modeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let nodeUnlockMissionData = self.nodeUnlockMissionData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let nodeUnlockMissionGroup = self.nodeUnlockMissionGroup.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let constData = self.constData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_SpecialOperatorTable::create(
            _fbb,
            &clz_Torappu_SpecialOperatorTableArgs {
                operatorBasicData,
                operatorDetailData,
                modeData,
                nodeUnlockMissionData,
                nodeUnlockMissionGroup,
                constData,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_SpecialOperatorTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_special_operator_table_unchecked`.
pub fn root_as_clz_torappu_special_operator_table(
    buf: &[u8],
) -> Result<clz_Torappu_SpecialOperatorTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_SpecialOperatorTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_SpecialOperatorTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_special_operator_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_special_operator_table(
    buf: &[u8],
) -> Result<clz_Torappu_SpecialOperatorTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_SpecialOperatorTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_SpecialOperatorTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_special_operator_table_unchecked`.
pub fn root_as_clz_torappu_special_operator_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_SpecialOperatorTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_SpecialOperatorTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_SpecialOperatorTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_special_operator_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_special_operator_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_SpecialOperatorTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_SpecialOperatorTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_SpecialOperatorTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_SpecialOperatorTable`.
pub unsafe fn root_as_clz_torappu_special_operator_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_SpecialOperatorTable {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_SpecialOperatorTable>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_SpecialOperatorTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_SpecialOperatorTable`.
pub unsafe fn size_prefixed_root_as_clz_torappu_special_operator_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_SpecialOperatorTable {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_SpecialOperatorTable>(buf) }
}
#[inline]
pub fn finish_clz_torappu_special_operator_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorTable<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_special_operator_table_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_SpecialOperatorTable<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
