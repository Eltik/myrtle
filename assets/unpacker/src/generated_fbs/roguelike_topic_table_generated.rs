// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_MODULE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_MODULE_TYPE: i32 = 12;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_MODULE_TYPE: [enum__Torappu_RoguelikeModuleType; 13] = [
    enum__Torappu_RoguelikeModuleType::NONE,
    enum__Torappu_RoguelikeModuleType::SANCHECK,
    enum__Torappu_RoguelikeModuleType::DICE,
    enum__Torappu_RoguelikeModuleType::CHAOS,
    enum__Torappu_RoguelikeModuleType::TOTEMBUFF,
    enum__Torappu_RoguelikeModuleType::VISION,
    enum__Torappu_RoguelikeModuleType::FRAGMENT,
    enum__Torappu_RoguelikeModuleType::DISASTER,
    enum__Torappu_RoguelikeModuleType::NODE_UPGRADE,
    enum__Torappu_RoguelikeModuleType::COPPER,
    enum__Torappu_RoguelikeModuleType::WRATH,
    enum__Torappu_RoguelikeModuleType::CANDLE,
    enum__Torappu_RoguelikeModuleType::SKY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeModuleType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeModuleType {
    pub const NONE: Self = Self(0);
    pub const SANCHECK: Self = Self(1);
    pub const DICE: Self = Self(2);
    pub const CHAOS: Self = Self(3);
    pub const TOTEMBUFF: Self = Self(4);
    pub const VISION: Self = Self(5);
    pub const FRAGMENT: Self = Self(6);
    pub const DISASTER: Self = Self(7);
    pub const NODE_UPGRADE: Self = Self(8);
    pub const COPPER: Self = Self(9);
    pub const WRATH: Self = Self(10);
    pub const CANDLE: Self = Self(11);
    pub const SKY: Self = Self(12);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 12;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::SANCHECK,
        Self::DICE,
        Self::CHAOS,
        Self::TOTEMBUFF,
        Self::VISION,
        Self::FRAGMENT,
        Self::DISASTER,
        Self::NODE_UPGRADE,
        Self::COPPER,
        Self::WRATH,
        Self::CANDLE,
        Self::SKY,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SANCHECK => Some("SANCHECK"),
            Self::DICE => Some("DICE"),
            Self::CHAOS => Some("CHAOS"),
            Self::TOTEMBUFF => Some("TOTEMBUFF"),
            Self::VISION => Some("VISION"),
            Self::FRAGMENT => Some("FRAGMENT"),
            Self::DISASTER => Some("DISASTER"),
            Self::NODE_UPGRADE => Some("NODE_UPGRADE"),
            Self::COPPER => Some("COPPER"),
            Self::WRATH => Some("WRATH"),
            Self::CANDLE => Some("CANDLE"),
            Self::SKY => Some("SKY"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeModuleType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeModuleType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeModuleType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeModuleType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeModuleType {
    type Output = enum__Torappu_RoguelikeModuleType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeModuleType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeModuleType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeModuleType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_MONTH_CHAT_TRIG_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_MONTH_CHAT_TRIG_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_MONTH_CHAT_TRIG_TYPE:
    [enum__Torappu_RoguelikeMonthChatTrigType; 3] = [
    enum__Torappu_RoguelikeMonthChatTrigType::NONE,
    enum__Torappu_RoguelikeMonthChatTrigType::TRANSITING,
    enum__Torappu_RoguelikeMonthChatTrigType::DUNGEON,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeMonthChatTrigType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeMonthChatTrigType {
    pub const NONE: Self = Self(0);
    pub const TRANSITING: Self = Self(1);
    pub const DUNGEON: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::TRANSITING, Self::DUNGEON];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TRANSITING => Some("TRANSITING"),
            Self::DUNGEON => Some("DUNGEON"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeMonthChatTrigType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeMonthChatTrigType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeMonthChatTrigType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeMonthChatTrigType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeMonthChatTrigType {
    type Output = enum__Torappu_RoguelikeMonthChatTrigType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeMonthChatTrigType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeMonthChatTrigType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeMonthChatTrigType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_CHAR_STATE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_CHAR_STATE: i32 = 8;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_CHAR_STATE: [enum__Torappu_RoguelikeCharState; 9] = [
    enum__Torappu_RoguelikeCharState::NORMAL,
    enum__Torappu_RoguelikeCharState::UPGRADE,
    enum__Torappu_RoguelikeCharState::UPGRADE_BUFF,
    enum__Torappu_RoguelikeCharState::UPGRADE_BONUS,
    enum__Torappu_RoguelikeCharState::FREE,
    enum__Torappu_RoguelikeCharState::ASSIST,
    enum__Torappu_RoguelikeCharState::THIRD,
    enum__Torappu_RoguelikeCharState::MONTHLY,
    enum__Torappu_RoguelikeCharState::THIRD_LOW,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeCharState(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeCharState {
    pub const NORMAL: Self = Self(0);
    pub const UPGRADE: Self = Self(1);
    pub const UPGRADE_BUFF: Self = Self(2);
    pub const UPGRADE_BONUS: Self = Self(3);
    pub const FREE: Self = Self(4);
    pub const ASSIST: Self = Self(5);
    pub const THIRD: Self = Self(6);
    pub const MONTHLY: Self = Self(7);
    pub const THIRD_LOW: Self = Self(8);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 8;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NORMAL,
        Self::UPGRADE,
        Self::UPGRADE_BUFF,
        Self::UPGRADE_BONUS,
        Self::FREE,
        Self::ASSIST,
        Self::THIRD,
        Self::MONTHLY,
        Self::THIRD_LOW,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::UPGRADE => Some("UPGRADE"),
            Self::UPGRADE_BUFF => Some("UPGRADE_BUFF"),
            Self::UPGRADE_BONUS => Some("UPGRADE_BONUS"),
            Self::FREE => Some("FREE"),
            Self::ASSIST => Some("ASSIST"),
            Self::THIRD => Some("THIRD"),
            Self::MONTHLY => Some("MONTHLY"),
            Self::THIRD_LOW => Some("THIRD_LOW"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeCharState {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeCharState {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeCharState",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeCharState {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeCharState {
    type Output = enum__Torappu_RoguelikeCharState;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeCharState {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeCharState {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeCharState {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_ENROLL_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_ENROLL_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_ENROLL_TYPE: [enum__Torappu_RoguelikeEnrollType; 2] = [
    enum__Torappu_RoguelikeEnrollType::DLC,
    enum__Torappu_RoguelikeEnrollType::REVIEW,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeEnrollType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeEnrollType {
    pub const DLC: Self = Self(0);
    pub const REVIEW: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::DLC, Self::REVIEW];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::DLC => Some("DLC"),
            Self::REVIEW => Some("REVIEW"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeEnrollType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeEnrollType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeEnrollType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeEnrollType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeEnrollType {
    type Output = enum__Torappu_RoguelikeEnrollType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeEnrollType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeEnrollType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeEnrollType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_TYPE: i32 = 90;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_TYPE: [enum__Torappu_ItemType; 91] = [
    enum__Torappu_ItemType::NONE,
    enum__Torappu_ItemType::CHAR,
    enum__Torappu_ItemType::CARD_EXP,
    enum__Torappu_ItemType::MATERIAL,
    enum__Torappu_ItemType::GOLD,
    enum__Torappu_ItemType::EXP_PLAYER,
    enum__Torappu_ItemType::TKT_TRY,
    enum__Torappu_ItemType::TKT_RECRUIT,
    enum__Torappu_ItemType::TKT_INST_FIN,
    enum__Torappu_ItemType::TKT_GACHA,
    enum__Torappu_ItemType::ACTIVITY_COIN,
    enum__Torappu_ItemType::DIAMOND,
    enum__Torappu_ItemType::DIAMOND_SHD,
    enum__Torappu_ItemType::HGG_SHD,
    enum__Torappu_ItemType::LGG_SHD,
    enum__Torappu_ItemType::FURN,
    enum__Torappu_ItemType::AP_GAMEPLAY,
    enum__Torappu_ItemType::AP_BASE,
    enum__Torappu_ItemType::SOCIAL_PT,
    enum__Torappu_ItemType::CHAR_SKIN,
    enum__Torappu_ItemType::TKT_GACHA_10,
    enum__Torappu_ItemType::TKT_GACHA_PRSV,
    enum__Torappu_ItemType::AP_ITEM,
    enum__Torappu_ItemType::AP_SUPPLY,
    enum__Torappu_ItemType::RENAMING_CARD,
    enum__Torappu_ItemType::RENAMING_CARD_2,
    enum__Torappu_ItemType::ET_STAGE,
    enum__Torappu_ItemType::ACTIVITY_ITEM,
    enum__Torappu_ItemType::VOUCHER_PICK,
    enum__Torappu_ItemType::VOUCHER_CGACHA,
    enum__Torappu_ItemType::VOUCHER_MGACHA,
    enum__Torappu_ItemType::CRS_SHOP_COIN,
    enum__Torappu_ItemType::CRS_RUNE_COIN,
    enum__Torappu_ItemType::LMTGS_COIN,
    enum__Torappu_ItemType::EPGS_COIN,
    enum__Torappu_ItemType::LIMITED_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_FREE_GACHA,
    enum__Torappu_ItemType::REP_COIN,
    enum__Torappu_ItemType::ROGUELIKE,
    enum__Torappu_ItemType::LINKAGE_TKT_GACHA_10,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_4,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_5,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_6,
    enum__Torappu_ItemType::VOUCHER_SKIN,
    enum__Torappu_ItemType::RETRO_COIN,
    enum__Torappu_ItemType::PLAYER_AVATAR,
    enum__Torappu_ItemType::UNI_COLLECTION,
    enum__Torappu_ItemType::VOUCHER_FULL_POTENTIAL,
    enum__Torappu_ItemType::RL_COIN,
    enum__Torappu_ItemType::RETURN_CREDIT,
    enum__Torappu_ItemType::MEDAL,
    enum__Torappu_ItemType::CHARM,
    enum__Torappu_ItemType::HOME_BACKGROUND,
    enum__Torappu_ItemType::EXTERMINATION_AGENT,
    enum__Torappu_ItemType::OPTIONAL_VOUCHER_PICK,
    enum__Torappu_ItemType::ACT_CART_COMPONENT,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_4,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_4,
    enum__Torappu_ItemType::ACTIVITY_POTENTIAL,
    enum__Torappu_ItemType::ITEM_PACK,
    enum__Torappu_ItemType::SANDBOX,
    enum__Torappu_ItemType::FAVOR_ADD_ITEM,
    enum__Torappu_ItemType::CLASSIC_SHD,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_BUFF,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_5,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_6,
    enum__Torappu_ItemType::RETURN_PROGRESS,
    enum__Torappu_ItemType::NEW_PROGRESS,
    enum__Torappu_ItemType::MCARD_VOUCHER,
    enum__Torappu_ItemType::MATERIAL_ISSUE_VOUCHER,
    enum__Torappu_ItemType::CRS_SHOP_COIN_V2,
    enum__Torappu_ItemType::HOME_THEME,
    enum__Torappu_ItemType::SANDBOX_PERM,
    enum__Torappu_ItemType::SANDBOX_TOKEN,
    enum__Torappu_ItemType::TEMPLATE_TRAP,
    enum__Torappu_ItemType::NAME_CARD_SKIN,
    enum__Torappu_ItemType::EMOTICON_SET,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA_10,
    enum__Torappu_ItemType::SO_CHAR_EXP,
    enum__Torappu_ItemType::GIFTPACKAGE_TKT,
    enum__Torappu_ItemType::VOUCHER_SKIN_V2,
    enum__Torappu_ItemType::RANDOM_VOUCHER_SKIN,
    enum__Torappu_ItemType::ACT1VHALFIDLE_ITEM,
    enum__Torappu_ItemType::PLOT_ITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemType {
    pub const NONE: Self = Self(0);
    pub const CHAR: Self = Self(1);
    pub const CARD_EXP: Self = Self(2);
    pub const MATERIAL: Self = Self(3);
    pub const GOLD: Self = Self(4);
    pub const EXP_PLAYER: Self = Self(5);
    pub const TKT_TRY: Self = Self(6);
    pub const TKT_RECRUIT: Self = Self(7);
    pub const TKT_INST_FIN: Self = Self(8);
    pub const TKT_GACHA: Self = Self(9);
    pub const ACTIVITY_COIN: Self = Self(10);
    pub const DIAMOND: Self = Self(11);
    pub const DIAMOND_SHD: Self = Self(12);
    pub const HGG_SHD: Self = Self(13);
    pub const LGG_SHD: Self = Self(14);
    pub const FURN: Self = Self(15);
    pub const AP_GAMEPLAY: Self = Self(16);
    pub const AP_BASE: Self = Self(17);
    pub const SOCIAL_PT: Self = Self(18);
    pub const CHAR_SKIN: Self = Self(19);
    pub const TKT_GACHA_10: Self = Self(20);
    pub const TKT_GACHA_PRSV: Self = Self(21);
    pub const AP_ITEM: Self = Self(22);
    pub const AP_SUPPLY: Self = Self(23);
    pub const RENAMING_CARD: Self = Self(24);
    pub const RENAMING_CARD_2: Self = Self(25);
    pub const ET_STAGE: Self = Self(26);
    pub const ACTIVITY_ITEM: Self = Self(27);
    pub const VOUCHER_PICK: Self = Self(28);
    pub const VOUCHER_CGACHA: Self = Self(29);
    pub const VOUCHER_MGACHA: Self = Self(30);
    pub const CRS_SHOP_COIN: Self = Self(31);
    pub const CRS_RUNE_COIN: Self = Self(32);
    pub const LMTGS_COIN: Self = Self(33);
    pub const EPGS_COIN: Self = Self(34);
    pub const LIMITED_TKT_GACHA_10: Self = Self(35);
    pub const LIMITED_FREE_GACHA: Self = Self(36);
    pub const REP_COIN: Self = Self(37);
    pub const ROGUELIKE: Self = Self(38);
    pub const LINKAGE_TKT_GACHA_10: Self = Self(39);
    pub const VOUCHER_ELITE_II_4: Self = Self(40);
    pub const VOUCHER_ELITE_II_5: Self = Self(41);
    pub const VOUCHER_ELITE_II_6: Self = Self(42);
    pub const VOUCHER_SKIN: Self = Self(43);
    pub const RETRO_COIN: Self = Self(44);
    pub const PLAYER_AVATAR: Self = Self(45);
    pub const UNI_COLLECTION: Self = Self(46);
    pub const VOUCHER_FULL_POTENTIAL: Self = Self(47);
    pub const RL_COIN: Self = Self(48);
    pub const RETURN_CREDIT: Self = Self(49);
    pub const MEDAL: Self = Self(50);
    pub const CHARM: Self = Self(51);
    pub const HOME_BACKGROUND: Self = Self(52);
    pub const EXTERMINATION_AGENT: Self = Self(53);
    pub const OPTIONAL_VOUCHER_PICK: Self = Self(54);
    pub const ACT_CART_COMPONENT: Self = Self(55);
    pub const VOUCHER_LEVELMAX_6: Self = Self(56);
    pub const VOUCHER_LEVELMAX_5: Self = Self(57);
    pub const VOUCHER_LEVELMAX_4: Self = Self(58);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_6: Self = Self(59);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_5: Self = Self(60);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_4: Self = Self(61);
    pub const ACTIVITY_POTENTIAL: Self = Self(62);
    pub const ITEM_PACK: Self = Self(63);
    pub const SANDBOX: Self = Self(64);
    pub const FAVOR_ADD_ITEM: Self = Self(65);
    pub const CLASSIC_SHD: Self = Self(66);
    pub const CLASSIC_TKT_GACHA: Self = Self(67);
    pub const CLASSIC_TKT_GACHA_10: Self = Self(68);
    pub const LIMITED_BUFF: Self = Self(69);
    pub const CLASSIC_FES_PICK_TIER_5: Self = Self(70);
    pub const CLASSIC_FES_PICK_TIER_6: Self = Self(71);
    pub const RETURN_PROGRESS: Self = Self(72);
    pub const NEW_PROGRESS: Self = Self(73);
    pub const MCARD_VOUCHER: Self = Self(74);
    pub const MATERIAL_ISSUE_VOUCHER: Self = Self(75);
    pub const CRS_SHOP_COIN_V2: Self = Self(76);
    pub const HOME_THEME: Self = Self(77);
    pub const SANDBOX_PERM: Self = Self(78);
    pub const SANDBOX_TOKEN: Self = Self(79);
    pub const TEMPLATE_TRAP: Self = Self(80);
    pub const NAME_CARD_SKIN: Self = Self(81);
    pub const EMOTICON_SET: Self = Self(82);
    pub const EXCLUSIVE_TKT_GACHA: Self = Self(83);
    pub const EXCLUSIVE_TKT_GACHA_10: Self = Self(84);
    pub const SO_CHAR_EXP: Self = Self(85);
    pub const GIFTPACKAGE_TKT: Self = Self(86);
    pub const VOUCHER_SKIN_V2: Self = Self(87);
    pub const RANDOM_VOUCHER_SKIN: Self = Self(88);
    pub const ACT1VHALFIDLE_ITEM: Self = Self(89);
    pub const PLOT_ITEM: Self = Self(90);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 90;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CHAR,
        Self::CARD_EXP,
        Self::MATERIAL,
        Self::GOLD,
        Self::EXP_PLAYER,
        Self::TKT_TRY,
        Self::TKT_RECRUIT,
        Self::TKT_INST_FIN,
        Self::TKT_GACHA,
        Self::ACTIVITY_COIN,
        Self::DIAMOND,
        Self::DIAMOND_SHD,
        Self::HGG_SHD,
        Self::LGG_SHD,
        Self::FURN,
        Self::AP_GAMEPLAY,
        Self::AP_BASE,
        Self::SOCIAL_PT,
        Self::CHAR_SKIN,
        Self::TKT_GACHA_10,
        Self::TKT_GACHA_PRSV,
        Self::AP_ITEM,
        Self::AP_SUPPLY,
        Self::RENAMING_CARD,
        Self::RENAMING_CARD_2,
        Self::ET_STAGE,
        Self::ACTIVITY_ITEM,
        Self::VOUCHER_PICK,
        Self::VOUCHER_CGACHA,
        Self::VOUCHER_MGACHA,
        Self::CRS_SHOP_COIN,
        Self::CRS_RUNE_COIN,
        Self::LMTGS_COIN,
        Self::EPGS_COIN,
        Self::LIMITED_TKT_GACHA_10,
        Self::LIMITED_FREE_GACHA,
        Self::REP_COIN,
        Self::ROGUELIKE,
        Self::LINKAGE_TKT_GACHA_10,
        Self::VOUCHER_ELITE_II_4,
        Self::VOUCHER_ELITE_II_5,
        Self::VOUCHER_ELITE_II_6,
        Self::VOUCHER_SKIN,
        Self::RETRO_COIN,
        Self::PLAYER_AVATAR,
        Self::UNI_COLLECTION,
        Self::VOUCHER_FULL_POTENTIAL,
        Self::RL_COIN,
        Self::RETURN_CREDIT,
        Self::MEDAL,
        Self::CHARM,
        Self::HOME_BACKGROUND,
        Self::EXTERMINATION_AGENT,
        Self::OPTIONAL_VOUCHER_PICK,
        Self::ACT_CART_COMPONENT,
        Self::VOUCHER_LEVELMAX_6,
        Self::VOUCHER_LEVELMAX_5,
        Self::VOUCHER_LEVELMAX_4,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_6,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_5,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_4,
        Self::ACTIVITY_POTENTIAL,
        Self::ITEM_PACK,
        Self::SANDBOX,
        Self::FAVOR_ADD_ITEM,
        Self::CLASSIC_SHD,
        Self::CLASSIC_TKT_GACHA,
        Self::CLASSIC_TKT_GACHA_10,
        Self::LIMITED_BUFF,
        Self::CLASSIC_FES_PICK_TIER_5,
        Self::CLASSIC_FES_PICK_TIER_6,
        Self::RETURN_PROGRESS,
        Self::NEW_PROGRESS,
        Self::MCARD_VOUCHER,
        Self::MATERIAL_ISSUE_VOUCHER,
        Self::CRS_SHOP_COIN_V2,
        Self::HOME_THEME,
        Self::SANDBOX_PERM,
        Self::SANDBOX_TOKEN,
        Self::TEMPLATE_TRAP,
        Self::NAME_CARD_SKIN,
        Self::EMOTICON_SET,
        Self::EXCLUSIVE_TKT_GACHA,
        Self::EXCLUSIVE_TKT_GACHA_10,
        Self::SO_CHAR_EXP,
        Self::GIFTPACKAGE_TKT,
        Self::VOUCHER_SKIN_V2,
        Self::RANDOM_VOUCHER_SKIN,
        Self::ACT1VHALFIDLE_ITEM,
        Self::PLOT_ITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CHAR => Some("CHAR"),
            Self::CARD_EXP => Some("CARD_EXP"),
            Self::MATERIAL => Some("MATERIAL"),
            Self::GOLD => Some("GOLD"),
            Self::EXP_PLAYER => Some("EXP_PLAYER"),
            Self::TKT_TRY => Some("TKT_TRY"),
            Self::TKT_RECRUIT => Some("TKT_RECRUIT"),
            Self::TKT_INST_FIN => Some("TKT_INST_FIN"),
            Self::TKT_GACHA => Some("TKT_GACHA"),
            Self::ACTIVITY_COIN => Some("ACTIVITY_COIN"),
            Self::DIAMOND => Some("DIAMOND"),
            Self::DIAMOND_SHD => Some("DIAMOND_SHD"),
            Self::HGG_SHD => Some("HGG_SHD"),
            Self::LGG_SHD => Some("LGG_SHD"),
            Self::FURN => Some("FURN"),
            Self::AP_GAMEPLAY => Some("AP_GAMEPLAY"),
            Self::AP_BASE => Some("AP_BASE"),
            Self::SOCIAL_PT => Some("SOCIAL_PT"),
            Self::CHAR_SKIN => Some("CHAR_SKIN"),
            Self::TKT_GACHA_10 => Some("TKT_GACHA_10"),
            Self::TKT_GACHA_PRSV => Some("TKT_GACHA_PRSV"),
            Self::AP_ITEM => Some("AP_ITEM"),
            Self::AP_SUPPLY => Some("AP_SUPPLY"),
            Self::RENAMING_CARD => Some("RENAMING_CARD"),
            Self::RENAMING_CARD_2 => Some("RENAMING_CARD_2"),
            Self::ET_STAGE => Some("ET_STAGE"),
            Self::ACTIVITY_ITEM => Some("ACTIVITY_ITEM"),
            Self::VOUCHER_PICK => Some("VOUCHER_PICK"),
            Self::VOUCHER_CGACHA => Some("VOUCHER_CGACHA"),
            Self::VOUCHER_MGACHA => Some("VOUCHER_MGACHA"),
            Self::CRS_SHOP_COIN => Some("CRS_SHOP_COIN"),
            Self::CRS_RUNE_COIN => Some("CRS_RUNE_COIN"),
            Self::LMTGS_COIN => Some("LMTGS_COIN"),
            Self::EPGS_COIN => Some("EPGS_COIN"),
            Self::LIMITED_TKT_GACHA_10 => Some("LIMITED_TKT_GACHA_10"),
            Self::LIMITED_FREE_GACHA => Some("LIMITED_FREE_GACHA"),
            Self::REP_COIN => Some("REP_COIN"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::LINKAGE_TKT_GACHA_10 => Some("LINKAGE_TKT_GACHA_10"),
            Self::VOUCHER_ELITE_II_4 => Some("VOUCHER_ELITE_II_4"),
            Self::VOUCHER_ELITE_II_5 => Some("VOUCHER_ELITE_II_5"),
            Self::VOUCHER_ELITE_II_6 => Some("VOUCHER_ELITE_II_6"),
            Self::VOUCHER_SKIN => Some("VOUCHER_SKIN"),
            Self::RETRO_COIN => Some("RETRO_COIN"),
            Self::PLAYER_AVATAR => Some("PLAYER_AVATAR"),
            Self::UNI_COLLECTION => Some("UNI_COLLECTION"),
            Self::VOUCHER_FULL_POTENTIAL => Some("VOUCHER_FULL_POTENTIAL"),
            Self::RL_COIN => Some("RL_COIN"),
            Self::RETURN_CREDIT => Some("RETURN_CREDIT"),
            Self::MEDAL => Some("MEDAL"),
            Self::CHARM => Some("CHARM"),
            Self::HOME_BACKGROUND => Some("HOME_BACKGROUND"),
            Self::EXTERMINATION_AGENT => Some("EXTERMINATION_AGENT"),
            Self::OPTIONAL_VOUCHER_PICK => Some("OPTIONAL_VOUCHER_PICK"),
            Self::ACT_CART_COMPONENT => Some("ACT_CART_COMPONENT"),
            Self::VOUCHER_LEVELMAX_6 => Some("VOUCHER_LEVELMAX_6"),
            Self::VOUCHER_LEVELMAX_5 => Some("VOUCHER_LEVELMAX_5"),
            Self::VOUCHER_LEVELMAX_4 => Some("VOUCHER_LEVELMAX_4"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_6 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_6"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_5 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_5"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_4 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_4"),
            Self::ACTIVITY_POTENTIAL => Some("ACTIVITY_POTENTIAL"),
            Self::ITEM_PACK => Some("ITEM_PACK"),
            Self::SANDBOX => Some("SANDBOX"),
            Self::FAVOR_ADD_ITEM => Some("FAVOR_ADD_ITEM"),
            Self::CLASSIC_SHD => Some("CLASSIC_SHD"),
            Self::CLASSIC_TKT_GACHA => Some("CLASSIC_TKT_GACHA"),
            Self::CLASSIC_TKT_GACHA_10 => Some("CLASSIC_TKT_GACHA_10"),
            Self::LIMITED_BUFF => Some("LIMITED_BUFF"),
            Self::CLASSIC_FES_PICK_TIER_5 => Some("CLASSIC_FES_PICK_TIER_5"),
            Self::CLASSIC_FES_PICK_TIER_6 => Some("CLASSIC_FES_PICK_TIER_6"),
            Self::RETURN_PROGRESS => Some("RETURN_PROGRESS"),
            Self::NEW_PROGRESS => Some("NEW_PROGRESS"),
            Self::MCARD_VOUCHER => Some("MCARD_VOUCHER"),
            Self::MATERIAL_ISSUE_VOUCHER => Some("MATERIAL_ISSUE_VOUCHER"),
            Self::CRS_SHOP_COIN_V2 => Some("CRS_SHOP_COIN_V2"),
            Self::HOME_THEME => Some("HOME_THEME"),
            Self::SANDBOX_PERM => Some("SANDBOX_PERM"),
            Self::SANDBOX_TOKEN => Some("SANDBOX_TOKEN"),
            Self::TEMPLATE_TRAP => Some("TEMPLATE_TRAP"),
            Self::NAME_CARD_SKIN => Some("NAME_CARD_SKIN"),
            Self::EMOTICON_SET => Some("EMOTICON_SET"),
            Self::EXCLUSIVE_TKT_GACHA => Some("EXCLUSIVE_TKT_GACHA"),
            Self::EXCLUSIVE_TKT_GACHA_10 => Some("EXCLUSIVE_TKT_GACHA_10"),
            Self::SO_CHAR_EXP => Some("SO_CHAR_EXP"),
            Self::GIFTPACKAGE_TKT => Some("GIFTPACKAGE_TKT"),
            Self::VOUCHER_SKIN_V2 => Some("VOUCHER_SKIN_V2"),
            Self::RANDOM_VOUCHER_SKIN => Some("RANDOM_VOUCHER_SKIN"),
            Self::ACT1VHALFIDLE_ITEM => Some("ACT1VHALFIDLE_ITEM"),
            Self::PLOT_ITEM => Some("PLOT_ITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemType {
    type Output = enum__Torappu_ItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_GAME_MONTH_TASK_CLASS: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_GAME_MONTH_TASK_CLASS: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_GAME_MONTH_TASK_CLASS:
    [enum__Torappu_RoguelikeGameMonthTaskClass; 4] = [
    enum__Torappu_RoguelikeGameMonthTaskClass::NONE,
    enum__Torappu_RoguelikeGameMonthTaskClass::C,
    enum__Torappu_RoguelikeGameMonthTaskClass::B,
    enum__Torappu_RoguelikeGameMonthTaskClass::A,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeGameMonthTaskClass(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeGameMonthTaskClass {
    pub const NONE: Self = Self(0);
    pub const C: Self = Self(1);
    pub const B: Self = Self(2);
    pub const A: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::C, Self::B, Self::A];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::C => Some("C"),
            Self::B => Some("B"),
            Self::A => Some("A"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeGameMonthTaskClass {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeGameMonthTaskClass {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeGameMonthTaskClass",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeGameMonthTaskClass {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeGameMonthTaskClass {
    type Output = enum__Torappu_RoguelikeGameMonthTaskClass;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeGameMonthTaskClass {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeGameMonthTaskClass {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeGameMonthTaskClass {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_TOPIC_MODE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_TOPIC_MODE: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_TOPIC_MODE: [enum__Torappu_RoguelikeTopicMode; 7] = [
    enum__Torappu_RoguelikeTopicMode::NONE,
    enum__Torappu_RoguelikeTopicMode::EASY,
    enum__Torappu_RoguelikeTopicMode::NORMAL,
    enum__Torappu_RoguelikeTopicMode::HARD,
    enum__Torappu_RoguelikeTopicMode::NORML_END,
    enum__Torappu_RoguelikeTopicMode::MONTH_TEAM,
    enum__Torappu_RoguelikeTopicMode::CHALLENGE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeTopicMode(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeTopicMode {
    pub const NONE: Self = Self(0);
    pub const EASY: Self = Self(1);
    pub const NORMAL: Self = Self(2);
    pub const HARD: Self = Self(3);
    pub const NORML_END: Self = Self(4);
    pub const MONTH_TEAM: Self = Self(5);
    pub const CHALLENGE: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::EASY,
        Self::NORMAL,
        Self::HARD,
        Self::NORML_END,
        Self::MONTH_TEAM,
        Self::CHALLENGE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::EASY => Some("EASY"),
            Self::NORMAL => Some("NORMAL"),
            Self::HARD => Some("HARD"),
            Self::NORML_END => Some("NORML_END"),
            Self::MONTH_TEAM => Some("MONTH_TEAM"),
            Self::CHALLENGE => Some("CHALLENGE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeTopicMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeTopicMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeTopicMode",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeTopicMode {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeTopicMode {
    type Output = enum__Torappu_RoguelikeTopicMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeTopicMode {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeTopicMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeTopicMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_TOPIC_DIFFICULTY_WARNING_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_TOPIC_DIFFICULTY_WARNING_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_TOPIC_DIFFICULTY_WARNING_TYPE:
    [enum__Torappu_RoguelikeTopicDifficultyWarningType; 3] = [
    enum__Torappu_RoguelikeTopicDifficultyWarningType::NONE,
    enum__Torappu_RoguelikeTopicDifficultyWarningType::NORMAL,
    enum__Torappu_RoguelikeTopicDifficultyWarningType::HARD,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeTopicDifficultyWarningType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeTopicDifficultyWarningType {
    pub const NONE: Self = Self(0);
    pub const NORMAL: Self = Self(1);
    pub const HARD: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::NORMAL, Self::HARD];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NORMAL => Some("NORMAL"),
            Self::HARD => Some("HARD"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeTopicDifficultyWarningType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeTopicDifficultyWarningType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeTopicDifficultyWarningType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeTopicDifficultyWarningType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeTopicDifficultyWarningType {
    type Output = enum__Torappu_RoguelikeTopicDifficultyWarningType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeTopicDifficultyWarningType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeTopicDifficultyWarningType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeTopicDifficultyWarningType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_TOPIC_BANK_REWARD_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_TOPIC_BANK_REWARD_TYPE: i32 = 5;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_TOPIC_BANK_REWARD_TYPE:
    [enum__Torappu_RoguelikeTopicBankRewardType; 6] = [
    enum__Torappu_RoguelikeTopicBankRewardType::NONE,
    enum__Torappu_RoguelikeTopicBankRewardType::UNLOCK_ITEM,
    enum__Torappu_RoguelikeTopicBankRewardType::ADD_SHOP_POS,
    enum__Torappu_RoguelikeTopicBankRewardType::UNLOCK_WITHDRAW,
    enum__Torappu_RoguelikeTopicBankRewardType::UNLOCK_SHOP_BATTLE,
    enum__Torappu_RoguelikeTopicBankRewardType::UNLOCK_SHOP_REFRESH,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeTopicBankRewardType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeTopicBankRewardType {
    pub const NONE: Self = Self(0);
    pub const UNLOCK_ITEM: Self = Self(1);
    pub const ADD_SHOP_POS: Self = Self(2);
    pub const UNLOCK_WITHDRAW: Self = Self(3);
    pub const UNLOCK_SHOP_BATTLE: Self = Self(4);
    pub const UNLOCK_SHOP_REFRESH: Self = Self(5);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 5;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::UNLOCK_ITEM,
        Self::ADD_SHOP_POS,
        Self::UNLOCK_WITHDRAW,
        Self::UNLOCK_SHOP_BATTLE,
        Self::UNLOCK_SHOP_REFRESH,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::UNLOCK_ITEM => Some("UNLOCK_ITEM"),
            Self::ADD_SHOP_POS => Some("ADD_SHOP_POS"),
            Self::UNLOCK_WITHDRAW => Some("UNLOCK_WITHDRAW"),
            Self::UNLOCK_SHOP_BATTLE => Some("UNLOCK_SHOP_BATTLE"),
            Self::UNLOCK_SHOP_REFRESH => Some("UNLOCK_SHOP_REFRESH"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeTopicBankRewardType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeTopicBankRewardType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeTopicBankRewardType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeTopicBankRewardType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeTopicBankRewardType {
    type Output = enum__Torappu_RoguelikeTopicBankRewardType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeTopicBankRewardType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeTopicBankRewardType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeTopicBankRewardType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ACT_ARCHIVE_TOTEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ACT_ARCHIVE_TOTEM_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ACT_ARCHIVE_TOTEM_TYPE: [enum__Torappu_ActArchiveTotemType; 3] = [
    enum__Torappu_ActArchiveTotemType::LOCATION,
    enum__Torappu_ActArchiveTotemType::EFFECT,
    enum__Torappu_ActArchiveTotemType::AFFIX,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ActArchiveTotemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ActArchiveTotemType {
    pub const LOCATION: Self = Self(0);
    pub const EFFECT: Self = Self(1);
    pub const AFFIX: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::LOCATION, Self::EFFECT, Self::AFFIX];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::LOCATION => Some("LOCATION"),
            Self::EFFECT => Some("EFFECT"),
            Self::AFFIX => Some("AFFIX"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ActArchiveTotemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ActArchiveTotemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ActArchiveTotemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ActArchiveTotemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ActArchiveTotemType {
    type Output = enum__Torappu_ActArchiveTotemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ActArchiveTotemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ActArchiveTotemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ActArchiveTotemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ACT_ARCHIVE_COPPER_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ACT_ARCHIVE_COPPER_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ACT_ARCHIVE_COPPER_TYPE: [enum__Torappu_ActArchiveCopperType;
    4] = [
    enum__Torappu_ActArchiveCopperType::ERR_ZERO,
    enum__Torappu_ActArchiveCopperType::LUCK,
    enum__Torappu_ActArchiveCopperType::COPPER,
    enum__Torappu_ActArchiveCopperType::GILD,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ActArchiveCopperType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ActArchiveCopperType {
    pub const ERR_ZERO: Self = Self(0);
    pub const LUCK: Self = Self(1);
    pub const COPPER: Self = Self(2);
    pub const GILD: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::ERR_ZERO, Self::LUCK, Self::COPPER, Self::GILD];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ERR_ZERO => Some("ERR_ZERO"),
            Self::LUCK => Some("LUCK"),
            Self::COPPER => Some("COPPER"),
            Self::GILD => Some("GILD"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ActArchiveCopperType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ActArchiveCopperType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ActArchiveCopperType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ActArchiveCopperType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ActArchiveCopperType {
    type Output = enum__Torappu_ActArchiveCopperType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ActArchiveCopperType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ActArchiveCopperType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ActArchiveCopperType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_COPPER_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_COPPER_TYPE: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_COPPER_TYPE: [enum__Torappu_RoguelikeCopperType; 7] = [
    enum__Torappu_RoguelikeCopperType::NONE,
    enum__Torappu_RoguelikeCopperType::BLANK,
    enum__Torappu_RoguelikeCopperType::FIGHT,
    enum__Torappu_RoguelikeCopperType::RESOURCE,
    enum__Torappu_RoguelikeCopperType::UNSOUND,
    enum__Torappu_RoguelikeCopperType::TREASURE,
    enum__Torappu_RoguelikeCopperType::SPECIAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeCopperType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeCopperType {
    pub const NONE: Self = Self(0);
    pub const BLANK: Self = Self(1);
    pub const FIGHT: Self = Self(2);
    pub const RESOURCE: Self = Self(3);
    pub const UNSOUND: Self = Self(4);
    pub const TREASURE: Self = Self(5);
    pub const SPECIAL: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::BLANK,
        Self::FIGHT,
        Self::RESOURCE,
        Self::UNSOUND,
        Self::TREASURE,
        Self::SPECIAL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BLANK => Some("BLANK"),
            Self::FIGHT => Some("FIGHT"),
            Self::RESOURCE => Some("RESOURCE"),
            Self::UNSOUND => Some("UNSOUND"),
            Self::TREASURE => Some("TREASURE"),
            Self::SPECIAL => Some("SPECIAL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeCopperType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeCopperType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeCopperType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeCopperType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeCopperType {
    type Output = enum__Torappu_RoguelikeCopperType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeCopperType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeCopperType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeCopperType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_COPPER_LUCKY_LEVEL: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_COPPER_LUCKY_LEVEL: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_COPPER_LUCKY_LEVEL:
    [enum__Torappu_RoguelikeCopperLuckyLevel; 4] = [
    enum__Torappu_RoguelikeCopperLuckyLevel::NONE,
    enum__Torappu_RoguelikeCopperLuckyLevel::HIGH,
    enum__Torappu_RoguelikeCopperLuckyLevel::MID,
    enum__Torappu_RoguelikeCopperLuckyLevel::LOW,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeCopperLuckyLevel(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeCopperLuckyLevel {
    pub const NONE: Self = Self(0);
    pub const HIGH: Self = Self(1);
    pub const MID: Self = Self(2);
    pub const LOW: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::HIGH, Self::MID, Self::LOW];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::HIGH => Some("HIGH"),
            Self::MID => Some("MID"),
            Self::LOW => Some("LOW"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeCopperLuckyLevel {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeCopperLuckyLevel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeCopperLuckyLevel",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeCopperLuckyLevel {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeCopperLuckyLevel {
    type Output = enum__Torappu_RoguelikeCopperLuckyLevel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeCopperLuckyLevel {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeCopperLuckyLevel {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeCopperLuckyLevel {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ACT_ARCHIVE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ACT_ARCHIVE_TYPE: i32 = 27;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ACT_ARCHIVE_TYPE: [enum__Torappu_ActArchiveType; 28] = [
    enum__Torappu_ActArchiveType::NONE,
    enum__Torappu_ActArchiveType::TIMELINE,
    enum__Torappu_ActArchiveType::MUSIC,
    enum__Torappu_ActArchiveType::PIC,
    enum__Torappu_ActArchiveType::AVG,
    enum__Torappu_ActArchiveType::STORY,
    enum__Torappu_ActArchiveType::NEWS,
    enum__Torappu_ActArchiveType::BUFF,
    enum__Torappu_ActArchiveType::RELIC,
    enum__Torappu_ActArchiveType::CAPSULE,
    enum__Torappu_ActArchiveType::TRAP,
    enum__Torappu_ActArchiveType::CHAT,
    enum__Torappu_ActArchiveType::LANDMARK,
    enum__Torappu_ActArchiveType::LOG,
    enum__Torappu_ActArchiveType::ACTIVITY_ENTRY,
    enum__Torappu_ActArchiveType::DYNAMIC_MUSIC,
    enum__Torappu_ActArchiveType::DYNAMIC_PIC,
    enum__Torappu_ActArchiveType::ENDBOOK,
    enum__Torappu_ActArchiveType::DYNAMIC_STORY,
    enum__Torappu_ActArchiveType::TOTEM,
    enum__Torappu_ActArchiveType::CHAOS,
    enum__Torappu_ActArchiveType::CHALLENGE_BOOK,
    enum__Torappu_ActArchiveType::ACHIEVEMENT,
    enum__Torappu_ActArchiveType::QUEST,
    enum__Torappu_ActArchiveType::FRAGMENT,
    enum__Torappu_ActArchiveType::DISASTER,
    enum__Torappu_ActArchiveType::COPPER,
    enum__Torappu_ActArchiveType::WRATH,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ActArchiveType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ActArchiveType {
    pub const NONE: Self = Self(0);
    pub const TIMELINE: Self = Self(1);
    pub const MUSIC: Self = Self(2);
    pub const PIC: Self = Self(3);
    pub const AVG: Self = Self(4);
    pub const STORY: Self = Self(5);
    pub const NEWS: Self = Self(6);
    pub const BUFF: Self = Self(7);
    pub const RELIC: Self = Self(8);
    pub const CAPSULE: Self = Self(9);
    pub const TRAP: Self = Self(10);
    pub const CHAT: Self = Self(11);
    pub const LANDMARK: Self = Self(12);
    pub const LOG: Self = Self(13);
    pub const ACTIVITY_ENTRY: Self = Self(14);
    pub const DYNAMIC_MUSIC: Self = Self(15);
    pub const DYNAMIC_PIC: Self = Self(16);
    pub const ENDBOOK: Self = Self(17);
    pub const DYNAMIC_STORY: Self = Self(18);
    pub const TOTEM: Self = Self(19);
    pub const CHAOS: Self = Self(20);
    pub const CHALLENGE_BOOK: Self = Self(21);
    pub const ACHIEVEMENT: Self = Self(22);
    pub const QUEST: Self = Self(23);
    pub const FRAGMENT: Self = Self(24);
    pub const DISASTER: Self = Self(25);
    pub const COPPER: Self = Self(26);
    pub const WRATH: Self = Self(27);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 27;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::TIMELINE,
        Self::MUSIC,
        Self::PIC,
        Self::AVG,
        Self::STORY,
        Self::NEWS,
        Self::BUFF,
        Self::RELIC,
        Self::CAPSULE,
        Self::TRAP,
        Self::CHAT,
        Self::LANDMARK,
        Self::LOG,
        Self::ACTIVITY_ENTRY,
        Self::DYNAMIC_MUSIC,
        Self::DYNAMIC_PIC,
        Self::ENDBOOK,
        Self::DYNAMIC_STORY,
        Self::TOTEM,
        Self::CHAOS,
        Self::CHALLENGE_BOOK,
        Self::ACHIEVEMENT,
        Self::QUEST,
        Self::FRAGMENT,
        Self::DISASTER,
        Self::COPPER,
        Self::WRATH,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TIMELINE => Some("TIMELINE"),
            Self::MUSIC => Some("MUSIC"),
            Self::PIC => Some("PIC"),
            Self::AVG => Some("AVG"),
            Self::STORY => Some("STORY"),
            Self::NEWS => Some("NEWS"),
            Self::BUFF => Some("BUFF"),
            Self::RELIC => Some("RELIC"),
            Self::CAPSULE => Some("CAPSULE"),
            Self::TRAP => Some("TRAP"),
            Self::CHAT => Some("CHAT"),
            Self::LANDMARK => Some("LANDMARK"),
            Self::LOG => Some("LOG"),
            Self::ACTIVITY_ENTRY => Some("ACTIVITY_ENTRY"),
            Self::DYNAMIC_MUSIC => Some("DYNAMIC_MUSIC"),
            Self::DYNAMIC_PIC => Some("DYNAMIC_PIC"),
            Self::ENDBOOK => Some("ENDBOOK"),
            Self::DYNAMIC_STORY => Some("DYNAMIC_STORY"),
            Self::TOTEM => Some("TOTEM"),
            Self::CHAOS => Some("CHAOS"),
            Self::CHALLENGE_BOOK => Some("CHALLENGE_BOOK"),
            Self::ACHIEVEMENT => Some("ACHIEVEMENT"),
            Self::QUEST => Some("QUEST"),
            Self::FRAGMENT => Some("FRAGMENT"),
            Self::DISASTER => Some("DISASTER"),
            Self::COPPER => Some("COPPER"),
            Self::WRATH => Some("WRATH"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ActArchiveType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ActArchiveType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ActArchiveType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ActArchiveType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ActArchiveType {
    type Output = enum__Torappu_ActArchiveType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ActArchiveType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ActArchiveType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ActArchiveType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_EVOLVE_PHASE: [enum__Torappu_EvolvePhase; 5] = [
    enum__Torappu_EvolvePhase::PHASE_0,
    enum__Torappu_EvolvePhase::PHASE_1,
    enum__Torappu_EvolvePhase::PHASE_2,
    enum__Torappu_EvolvePhase::PHASE_3,
    enum__Torappu_EvolvePhase::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EvolvePhase(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EvolvePhase {
    pub const PHASE_0: Self = Self(0);
    pub const PHASE_1: Self = Self(1);
    pub const PHASE_2: Self = Self(2);
    pub const PHASE_3: Self = Self(3);
    pub const E_NUM: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::PHASE_0,
        Self::PHASE_1,
        Self::PHASE_2,
        Self::PHASE_3,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::PHASE_0 => Some("PHASE_0"),
            Self::PHASE_1 => Some("PHASE_1"),
            Self::PHASE_2 => Some("PHASE_2"),
            Self::PHASE_3 => Some("PHASE_3"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EvolvePhase {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_EvolvePhase {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_EvolvePhase",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EvolvePhase {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EvolvePhase {
    type Output = enum__Torappu_EvolvePhase;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EvolvePhase {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EvolvePhase {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EvolvePhase {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: i32 = 15;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: [enum__Torappu_LevelData_Difficulty; 6] = [
    enum__Torappu_LevelData_Difficulty::NONE,
    enum__Torappu_LevelData_Difficulty::NORMAL,
    enum__Torappu_LevelData_Difficulty::FOUR_STAR,
    enum__Torappu_LevelData_Difficulty::EASY,
    enum__Torappu_LevelData_Difficulty::SIX_STAR,
    enum__Torappu_LevelData_Difficulty::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_LevelData_Difficulty(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_LevelData_Difficulty {
    pub const NONE: Self = Self(0);
    pub const NORMAL: Self = Self(1);
    pub const FOUR_STAR: Self = Self(2);
    pub const EASY: Self = Self(4);
    pub const SIX_STAR: Self = Self(8);
    pub const ALL: Self = Self(15);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 15;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::NORMAL,
        Self::FOUR_STAR,
        Self::EASY,
        Self::SIX_STAR,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NORMAL => Some("NORMAL"),
            Self::FOUR_STAR => Some("FOUR_STAR"),
            Self::EASY => Some("EASY"),
            Self::SIX_STAR => Some("SIX_STAR"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_LevelData_Difficulty {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_LevelData_Difficulty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_LevelData_Difficulty",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_LevelData_Difficulty {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_LevelData_Difficulty {
    type Output = enum__Torappu_LevelData_Difficulty;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_LevelData_Difficulty {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_LevelData_Difficulty {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_LevelData_Difficulty {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 512;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PROFESSION_CATEGORY: [enum__Torappu_ProfessionCategory; 11] = [
    enum__Torappu_ProfessionCategory::NONE,
    enum__Torappu_ProfessionCategory::WARRIOR,
    enum__Torappu_ProfessionCategory::SNIPER,
    enum__Torappu_ProfessionCategory::TANK,
    enum__Torappu_ProfessionCategory::MEDIC,
    enum__Torappu_ProfessionCategory::SUPPORT,
    enum__Torappu_ProfessionCategory::CASTER,
    enum__Torappu_ProfessionCategory::SPECIAL,
    enum__Torappu_ProfessionCategory::TOKEN,
    enum__Torappu_ProfessionCategory::TRAP,
    enum__Torappu_ProfessionCategory::PIONEER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ProfessionCategory(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ProfessionCategory {
    pub const NONE: Self = Self(0);
    pub const WARRIOR: Self = Self(1);
    pub const SNIPER: Self = Self(2);
    pub const TANK: Self = Self(4);
    pub const MEDIC: Self = Self(8);
    pub const SUPPORT: Self = Self(16);
    pub const CASTER: Self = Self(32);
    pub const SPECIAL: Self = Self(64);
    pub const TOKEN: Self = Self(128);
    pub const TRAP: Self = Self(256);
    pub const PIONEER: Self = Self(512);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 512;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::WARRIOR,
        Self::SNIPER,
        Self::TANK,
        Self::MEDIC,
        Self::SUPPORT,
        Self::CASTER,
        Self::SPECIAL,
        Self::TOKEN,
        Self::TRAP,
        Self::PIONEER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::WARRIOR => Some("WARRIOR"),
            Self::SNIPER => Some("SNIPER"),
            Self::TANK => Some("TANK"),
            Self::MEDIC => Some("MEDIC"),
            Self::SUPPORT => Some("SUPPORT"),
            Self::CASTER => Some("CASTER"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::TOKEN => Some("TOKEN"),
            Self::TRAP => Some("TRAP"),
            Self::PIONEER => Some("PIONEER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ProfessionCategory {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ProfessionCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ProfessionCategory",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ProfessionCategory {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ProfessionCategory {
    type Output = enum__Torappu_ProfessionCategory;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ProfessionCategory {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ProfessionCategory {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ProfessionCategory {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_RARITY_RANK_MASK: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_RARITY_RANK_MASK: i32 = 63;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_RARITY_RANK_MASK: [enum__Torappu_RarityRankMask; 8] = [
    enum__Torappu_RarityRankMask::NONE,
    enum__Torappu_RarityRankMask::TIER_1,
    enum__Torappu_RarityRankMask::TIER_2,
    enum__Torappu_RarityRankMask::TIER_3,
    enum__Torappu_RarityRankMask::TIER_4,
    enum__Torappu_RarityRankMask::TIER_5,
    enum__Torappu_RarityRankMask::TIER_6,
    enum__Torappu_RarityRankMask::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RarityRankMask(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RarityRankMask {
    pub const NONE: Self = Self(0);
    pub const TIER_1: Self = Self(1);
    pub const TIER_2: Self = Self(2);
    pub const TIER_3: Self = Self(4);
    pub const TIER_4: Self = Self(8);
    pub const TIER_5: Self = Self(16);
    pub const TIER_6: Self = Self(32);
    pub const ALL: Self = Self(63);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 63;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::TIER_1,
        Self::TIER_2,
        Self::TIER_3,
        Self::TIER_4,
        Self::TIER_5,
        Self::TIER_6,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TIER_1 => Some("TIER_1"),
            Self::TIER_2 => Some("TIER_2"),
            Self::TIER_3 => Some("TIER_3"),
            Self::TIER_4 => Some("TIER_4"),
            Self::TIER_5 => Some("TIER_5"),
            Self::TIER_6 => Some("TIER_6"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RarityRankMask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RarityRankMask {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RarityRankMask",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RarityRankMask {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RarityRankMask {
    type Output = enum__Torappu_RarityRankMask;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RarityRankMask {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RarityRankMask {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RarityRankMask {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PROFESSION_ID: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PROFESSION_ID: i32 = 9;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PROFESSION_ID: [enum__Torappu_ProfessionID; 10] = [
    enum__Torappu_ProfessionID::WARRIOR,
    enum__Torappu_ProfessionID::SNIPER,
    enum__Torappu_ProfessionID::TANK,
    enum__Torappu_ProfessionID::MEDIC,
    enum__Torappu_ProfessionID::SUPPORT,
    enum__Torappu_ProfessionID::CASTER,
    enum__Torappu_ProfessionID::SPECIAL,
    enum__Torappu_ProfessionID::TOKEN,
    enum__Torappu_ProfessionID::TRAP,
    enum__Torappu_ProfessionID::PIONEER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ProfessionID(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ProfessionID {
    pub const WARRIOR: Self = Self(0);
    pub const SNIPER: Self = Self(1);
    pub const TANK: Self = Self(2);
    pub const MEDIC: Self = Self(3);
    pub const SUPPORT: Self = Self(4);
    pub const CASTER: Self = Self(5);
    pub const SPECIAL: Self = Self(6);
    pub const TOKEN: Self = Self(7);
    pub const TRAP: Self = Self(8);
    pub const PIONEER: Self = Self(9);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 9;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::WARRIOR,
        Self::SNIPER,
        Self::TANK,
        Self::MEDIC,
        Self::SUPPORT,
        Self::CASTER,
        Self::SPECIAL,
        Self::TOKEN,
        Self::TRAP,
        Self::PIONEER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::WARRIOR => Some("WARRIOR"),
            Self::SNIPER => Some("SNIPER"),
            Self::TANK => Some("TANK"),
            Self::MEDIC => Some("MEDIC"),
            Self::SUPPORT => Some("SUPPORT"),
            Self::CASTER => Some("CASTER"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::TOKEN => Some("TOKEN"),
            Self::TRAP => Some("TRAP"),
            Self::PIONEER => Some("PIONEER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ProfessionID {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ProfessionID {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ProfessionID",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ProfessionID {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ProfessionID {
    type Output = enum__Torappu_ProfessionID;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ProfessionID {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ProfessionID {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ProfessionID {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_RARITY_RANK: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_RARITY_RANK: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_RARITY_RANK: [enum__Torappu_RarityRank; 7] = [
    enum__Torappu_RarityRank::TIER_1,
    enum__Torappu_RarityRank::TIER_2,
    enum__Torappu_RarityRank::TIER_3,
    enum__Torappu_RarityRank::TIER_4,
    enum__Torappu_RarityRank::TIER_5,
    enum__Torappu_RarityRank::TIER_6,
    enum__Torappu_RarityRank::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RarityRank(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RarityRank {
    pub const TIER_1: Self = Self(0);
    pub const TIER_2: Self = Self(1);
    pub const TIER_3: Self = Self(2);
    pub const TIER_4: Self = Self(3);
    pub const TIER_5: Self = Self(4);
    pub const TIER_6: Self = Self(5);
    pub const E_NUM: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::TIER_1,
        Self::TIER_2,
        Self::TIER_3,
        Self::TIER_4,
        Self::TIER_5,
        Self::TIER_6,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::TIER_1 => Some("TIER_1"),
            Self::TIER_2 => Some("TIER_2"),
            Self::TIER_3 => Some("TIER_3"),
            Self::TIER_4 => Some("TIER_4"),
            Self::TIER_5 => Some("TIER_5"),
            Self::TIER_6 => Some("TIER_6"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RarityRank {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RarityRank {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RarityRank",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RarityRank {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RarityRank {
    type Output = enum__Torappu_RarityRank;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RarityRank {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RarityRank {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RarityRank {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_CUSTOM_TICKET_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_CUSTOM_TICKET_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_CUSTOM_TICKET_TYPE: [enum__Torappu_CustomTicketType; 3] = [
    enum__Torappu_CustomTicketType::NONE,
    enum__Torappu_CustomTicketType::PURIFY,
    enum__Torappu_CustomTicketType::GET_CANDLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_CustomTicketType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_CustomTicketType {
    pub const NONE: Self = Self(0);
    pub const PURIFY: Self = Self(1);
    pub const GET_CANDLE: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::PURIFY, Self::GET_CANDLE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::PURIFY => Some("PURIFY"),
            Self::GET_CANDLE => Some("GET_CANDLE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_CustomTicketType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_CustomTicketType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_CustomTicketType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_CustomTicketType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_CustomTicketType {
    type Output = enum__Torappu_CustomTicketType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_CustomTicketType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_CustomTicketType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_CustomTicketType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_GAME_RELIC_CHECK_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_GAME_RELIC_CHECK_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_GAME_RELIC_CHECK_TYPE:
    [enum__Torappu_RoguelikeGameRelicCheckType; 4] = [
    enum__Torappu_RoguelikeGameRelicCheckType::NONE,
    enum__Torappu_RoguelikeGameRelicCheckType::PROFESSION,
    enum__Torappu_RoguelikeGameRelicCheckType::SUB_PROFESSION,
    enum__Torappu_RoguelikeGameRelicCheckType::UPGRADE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeGameRelicCheckType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeGameRelicCheckType {
    pub const NONE: Self = Self(0);
    pub const PROFESSION: Self = Self(1);
    pub const SUB_PROFESSION: Self = Self(2);
    pub const UPGRADE: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::PROFESSION,
        Self::SUB_PROFESSION,
        Self::UPGRADE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::PROFESSION => Some("PROFESSION"),
            Self::SUB_PROFESSION => Some("SUB_PROFESSION"),
            Self::UPGRADE => Some("UPGRADE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeGameRelicCheckType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeGameRelicCheckType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeGameRelicCheckType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeGameRelicCheckType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeGameRelicCheckType {
    type Output = enum__Torappu_RoguelikeGameRelicCheckType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeGameRelicCheckType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeGameRelicCheckType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeGameRelicCheckType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_GAME_CHOICE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_GAME_CHOICE_TYPE: i32 = 16;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_GAME_CHOICE_TYPE:
    [enum__Torappu_RoguelikeGameChoiceType; 17] = [
    enum__Torappu_RoguelikeGameChoiceType::NONE,
    enum__Torappu_RoguelikeGameChoiceType::LEAVE,
    enum__Torappu_RoguelikeGameChoiceType::NEXT,
    enum__Torappu_RoguelikeGameChoiceType::NEXT_PROB,
    enum__Torappu_RoguelikeGameChoiceType::TRADE,
    enum__Torappu_RoguelikeGameChoiceType::TRADE_PROB,
    enum__Torappu_RoguelikeGameChoiceType::SACRIFICE,
    enum__Torappu_RoguelikeGameChoiceType::TELEPORT,
    enum__Torappu_RoguelikeGameChoiceType::EXPEDITION,
    enum__Torappu_RoguelikeGameChoiceType::WISH,
    enum__Torappu_RoguelikeGameChoiceType::TRADE_PROB_SHOW,
    enum__Torappu_RoguelikeGameChoiceType::SACRIFICE_TOTEM,
    enum__Torappu_RoguelikeGameChoiceType::WISH_ALL,
    enum__Torappu_RoguelikeGameChoiceType::KILL,
    enum__Torappu_RoguelikeGameChoiceType::USE_STASHED_TICKET,
    enum__Torappu_RoguelikeGameChoiceType::EXPEDITION_ALL,
    enum__Torappu_RoguelikeGameChoiceType::EXPEDITION_RETURN_ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeGameChoiceType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeGameChoiceType {
    pub const NONE: Self = Self(0);
    pub const LEAVE: Self = Self(1);
    pub const NEXT: Self = Self(2);
    pub const NEXT_PROB: Self = Self(3);
    pub const TRADE: Self = Self(4);
    pub const TRADE_PROB: Self = Self(5);
    pub const SACRIFICE: Self = Self(6);
    pub const TELEPORT: Self = Self(7);
    pub const EXPEDITION: Self = Self(8);
    pub const WISH: Self = Self(9);
    pub const TRADE_PROB_SHOW: Self = Self(10);
    pub const SACRIFICE_TOTEM: Self = Self(11);
    pub const WISH_ALL: Self = Self(12);
    pub const KILL: Self = Self(13);
    pub const USE_STASHED_TICKET: Self = Self(14);
    pub const EXPEDITION_ALL: Self = Self(15);
    pub const EXPEDITION_RETURN_ALL: Self = Self(16);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 16;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::LEAVE,
        Self::NEXT,
        Self::NEXT_PROB,
        Self::TRADE,
        Self::TRADE_PROB,
        Self::SACRIFICE,
        Self::TELEPORT,
        Self::EXPEDITION,
        Self::WISH,
        Self::TRADE_PROB_SHOW,
        Self::SACRIFICE_TOTEM,
        Self::WISH_ALL,
        Self::KILL,
        Self::USE_STASHED_TICKET,
        Self::EXPEDITION_ALL,
        Self::EXPEDITION_RETURN_ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::LEAVE => Some("LEAVE"),
            Self::NEXT => Some("NEXT"),
            Self::NEXT_PROB => Some("NEXT_PROB"),
            Self::TRADE => Some("TRADE"),
            Self::TRADE_PROB => Some("TRADE_PROB"),
            Self::SACRIFICE => Some("SACRIFICE"),
            Self::TELEPORT => Some("TELEPORT"),
            Self::EXPEDITION => Some("EXPEDITION"),
            Self::WISH => Some("WISH"),
            Self::TRADE_PROB_SHOW => Some("TRADE_PROB_SHOW"),
            Self::SACRIFICE_TOTEM => Some("SACRIFICE_TOTEM"),
            Self::WISH_ALL => Some("WISH_ALL"),
            Self::KILL => Some("KILL"),
            Self::USE_STASHED_TICKET => Some("USE_STASHED_TICKET"),
            Self::EXPEDITION_ALL => Some("EXPEDITION_ALL"),
            Self::EXPEDITION_RETURN_ALL => Some("EXPEDITION_RETURN_ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeGameChoiceType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeGameChoiceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeGameChoiceType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeGameChoiceType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeGameChoiceType {
    type Output = enum__Torappu_RoguelikeGameChoiceType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeGameChoiceType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeGameChoiceType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeGameChoiceType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_CHOICE_LEFT_DECO_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_CHOICE_LEFT_DECO_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_CHOICE_LEFT_DECO_TYPE:
    [enum__Torappu_RoguelikeChoiceLeftDecoType; 5] = [
    enum__Torappu_RoguelikeChoiceLeftDecoType::NONE,
    enum__Torappu_RoguelikeChoiceLeftDecoType::TASK,
    enum__Torappu_RoguelikeChoiceLeftDecoType::TASK_REWARD,
    enum__Torappu_RoguelikeChoiceLeftDecoType::DICE,
    enum__Torappu_RoguelikeChoiceLeftDecoType::VISION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeChoiceLeftDecoType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeChoiceLeftDecoType {
    pub const NONE: Self = Self(0);
    pub const TASK: Self = Self(1);
    pub const TASK_REWARD: Self = Self(2);
    pub const DICE: Self = Self(3);
    pub const VISION: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::TASK,
        Self::TASK_REWARD,
        Self::DICE,
        Self::VISION,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TASK => Some("TASK"),
            Self::TASK_REWARD => Some("TASK_REWARD"),
            Self::DICE => Some("DICE"),
            Self::VISION => Some("VISION"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeChoiceLeftDecoType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeChoiceLeftDecoType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeChoiceLeftDecoType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeChoiceLeftDecoType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeChoiceLeftDecoType {
    type Output = enum__Torappu_RoguelikeChoiceLeftDecoType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeChoiceLeftDecoType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeChoiceLeftDecoType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeChoiceLeftDecoType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_CHOICE_DISPLAY_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_CHOICE_DISPLAY_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_CHOICE_DISPLAY_TYPE:
    [enum__Torappu_RoguelikeChoiceDisplayType; 4] = [
    enum__Torappu_RoguelikeChoiceDisplayType::NONE,
    enum__Torappu_RoguelikeChoiceDisplayType::NORMAL,
    enum__Torappu_RoguelikeChoiceDisplayType::ITEM,
    enum__Torappu_RoguelikeChoiceDisplayType::TASK,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeChoiceDisplayType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeChoiceDisplayType {
    pub const NONE: Self = Self(0);
    pub const NORMAL: Self = Self(1);
    pub const ITEM: Self = Self(2);
    pub const TASK: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::NORMAL, Self::ITEM, Self::TASK];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NORMAL => Some("NORMAL"),
            Self::ITEM => Some("ITEM"),
            Self::TASK => Some("TASK"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeChoiceDisplayType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeChoiceDisplayType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeChoiceDisplayType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeChoiceDisplayType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeChoiceDisplayType {
    type Output = enum__Torappu_RoguelikeChoiceDisplayType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeChoiceDisplayType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeChoiceDisplayType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeChoiceDisplayType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_CHOICE_HINT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_CHOICE_HINT_TYPE: i32 = 15;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_CHOICE_HINT_TYPE:
    [enum__Torappu_RoguelikeChoiceHintType; 16] = [
    enum__Torappu_RoguelikeChoiceHintType::NONE,
    enum__Torappu_RoguelikeChoiceHintType::ITEM,
    enum__Torappu_RoguelikeChoiceHintType::CANDLED_CHAR,
    enum__Torappu_RoguelikeChoiceHintType::GUIDED_CHAR,
    enum__Torappu_RoguelikeChoiceHintType::SACRIFICE,
    enum__Torappu_RoguelikeChoiceHintType::SACRIFICE_TOTEM,
    enum__Torappu_RoguelikeChoiceHintType::EXPEDITION,
    enum__Torappu_RoguelikeChoiceHintType::CANDLE,
    enum__Torappu_RoguelikeChoiceHintType::GUIDED,
    enum__Torappu_RoguelikeChoiceHintType::HP,
    enum__Torappu_RoguelikeChoiceHintType::VISION,
    enum__Torappu_RoguelikeChoiceHintType::STASHED_RECRUIT,
    enum__Torappu_RoguelikeChoiceHintType::CHAOS,
    enum__Torappu_RoguelikeChoiceHintType::FRAGMENT,
    enum__Torappu_RoguelikeChoiceHintType::SP_ZONE_AP,
    enum__Torappu_RoguelikeChoiceHintType::COPPER_LUCK,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeChoiceHintType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeChoiceHintType {
    pub const NONE: Self = Self(0);
    pub const ITEM: Self = Self(1);
    pub const CANDLED_CHAR: Self = Self(2);
    pub const GUIDED_CHAR: Self = Self(3);
    pub const SACRIFICE: Self = Self(4);
    pub const SACRIFICE_TOTEM: Self = Self(5);
    pub const EXPEDITION: Self = Self(6);
    pub const CANDLE: Self = Self(7);
    pub const GUIDED: Self = Self(8);
    pub const HP: Self = Self(9);
    pub const VISION: Self = Self(10);
    pub const STASHED_RECRUIT: Self = Self(11);
    pub const CHAOS: Self = Self(12);
    pub const FRAGMENT: Self = Self(13);
    pub const SP_ZONE_AP: Self = Self(14);
    pub const COPPER_LUCK: Self = Self(15);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 15;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ITEM,
        Self::CANDLED_CHAR,
        Self::GUIDED_CHAR,
        Self::SACRIFICE,
        Self::SACRIFICE_TOTEM,
        Self::EXPEDITION,
        Self::CANDLE,
        Self::GUIDED,
        Self::HP,
        Self::VISION,
        Self::STASHED_RECRUIT,
        Self::CHAOS,
        Self::FRAGMENT,
        Self::SP_ZONE_AP,
        Self::COPPER_LUCK,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ITEM => Some("ITEM"),
            Self::CANDLED_CHAR => Some("CANDLED_CHAR"),
            Self::GUIDED_CHAR => Some("GUIDED_CHAR"),
            Self::SACRIFICE => Some("SACRIFICE"),
            Self::SACRIFICE_TOTEM => Some("SACRIFICE_TOTEM"),
            Self::EXPEDITION => Some("EXPEDITION"),
            Self::CANDLE => Some("CANDLE"),
            Self::GUIDED => Some("GUIDED"),
            Self::HP => Some("HP"),
            Self::VISION => Some("VISION"),
            Self::STASHED_RECRUIT => Some("STASHED_RECRUIT"),
            Self::CHAOS => Some("CHAOS"),
            Self::FRAGMENT => Some("FRAGMENT"),
            Self::SP_ZONE_AP => Some("SP_ZONE_AP"),
            Self::COPPER_LUCK => Some("COPPER_LUCK"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeChoiceHintType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeChoiceHintType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeChoiceHintType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeChoiceHintType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeChoiceHintType {
    type Output = enum__Torappu_RoguelikeChoiceHintType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeChoiceHintType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeChoiceHintType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeChoiceHintType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_EVENT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_EVENT_TYPE: i32 = 1965823;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_EVENT_TYPE: [enum__Torappu_RoguelikeEventType; 26] = [
    enum__Torappu_RoguelikeEventType::NONE,
    enum__Torappu_RoguelikeEventType::BATTLE_NORMAL,
    enum__Torappu_RoguelikeEventType::BATTLE_ELITE,
    enum__Torappu_RoguelikeEventType::BATTLE_BOSS,
    enum__Torappu_RoguelikeEventType::BATTLES,
    enum__Torappu_RoguelikeEventType::SHOP,
    enum__Torappu_RoguelikeEventType::REST,
    enum__Torappu_RoguelikeEventType::INCIDENT,
    enum__Torappu_RoguelikeEventType::TREASURE,
    enum__Torappu_RoguelikeEventType::ENTERTAINMENT,
    enum__Torappu_RoguelikeEventType::UNKNOWN,
    enum__Torappu_RoguelikeEventType::WISH,
    enum__Torappu_RoguelikeEventType::SACRIFICE,
    enum__Torappu_RoguelikeEventType::EXPEDITION,
    enum__Torappu_RoguelikeEventType::BATTLE_SHOP,
    enum__Torappu_RoguelikeEventType::PORTAL,
    enum__Torappu_RoguelikeEventType::MISSION,
    enum__Torappu_RoguelikeEventType::STORY,
    enum__Torappu_RoguelikeEventType::STORY_HIDDEN,
    enum__Torappu_RoguelikeEventType::ALCHEMY,
    enum__Torappu_RoguelikeEventType::DUEL,
    enum__Torappu_RoguelikeEventType::STASHED_RECRUIT,
    enum__Torappu_RoguelikeEventType::CHOICES,
    enum__Torappu_RoguelikeEventType::SPECIAL_ZONE,
    enum__Torappu_RoguelikeEventType::EVENTS,
    enum__Torappu_RoguelikeEventType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeEventType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeEventType {
    pub const NONE: Self = Self(0);
    pub const BATTLE_NORMAL: Self = Self(1);
    pub const BATTLE_ELITE: Self = Self(2);
    pub const BATTLE_BOSS: Self = Self(4);
    pub const BATTLES: Self = Self(7);
    pub const SHOP: Self = Self(8);
    pub const REST: Self = Self(16);
    pub const INCIDENT: Self = Self(32);
    pub const TREASURE: Self = Self(64);
    pub const ENTERTAINMENT: Self = Self(128);
    pub const UNKNOWN: Self = Self(256);
    pub const WISH: Self = Self(512);
    pub const SACRIFICE: Self = Self(1024);
    pub const EXPEDITION: Self = Self(2048);
    pub const BATTLE_SHOP: Self = Self(4096);
    pub const PORTAL: Self = Self(8192);
    pub const MISSION: Self = Self(16384);
    pub const STORY: Self = Self(32768);
    pub const STORY_HIDDEN: Self = Self(65536);
    pub const ALCHEMY: Self = Self(131072);
    pub const DUEL: Self = Self(262144);
    pub const STASHED_RECRUIT: Self = Self(524288);
    pub const CHOICES: Self = Self(913136);
    pub const SPECIAL_ZONE: Self = Self(1048576);
    pub const EVENTS: Self = Self(1965816);
    pub const ALL: Self = Self(1965823);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1965823;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::BATTLE_NORMAL,
        Self::BATTLE_ELITE,
        Self::BATTLE_BOSS,
        Self::BATTLES,
        Self::SHOP,
        Self::REST,
        Self::INCIDENT,
        Self::TREASURE,
        Self::ENTERTAINMENT,
        Self::UNKNOWN,
        Self::WISH,
        Self::SACRIFICE,
        Self::EXPEDITION,
        Self::BATTLE_SHOP,
        Self::PORTAL,
        Self::MISSION,
        Self::STORY,
        Self::STORY_HIDDEN,
        Self::ALCHEMY,
        Self::DUEL,
        Self::STASHED_RECRUIT,
        Self::CHOICES,
        Self::SPECIAL_ZONE,
        Self::EVENTS,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BATTLE_NORMAL => Some("BATTLE_NORMAL"),
            Self::BATTLE_ELITE => Some("BATTLE_ELITE"),
            Self::BATTLE_BOSS => Some("BATTLE_BOSS"),
            Self::BATTLES => Some("BATTLES"),
            Self::SHOP => Some("SHOP"),
            Self::REST => Some("REST"),
            Self::INCIDENT => Some("INCIDENT"),
            Self::TREASURE => Some("TREASURE"),
            Self::ENTERTAINMENT => Some("ENTERTAINMENT"),
            Self::UNKNOWN => Some("UNKNOWN"),
            Self::WISH => Some("WISH"),
            Self::SACRIFICE => Some("SACRIFICE"),
            Self::EXPEDITION => Some("EXPEDITION"),
            Self::BATTLE_SHOP => Some("BATTLE_SHOP"),
            Self::PORTAL => Some("PORTAL"),
            Self::MISSION => Some("MISSION"),
            Self::STORY => Some("STORY"),
            Self::STORY_HIDDEN => Some("STORY_HIDDEN"),
            Self::ALCHEMY => Some("ALCHEMY"),
            Self::DUEL => Some("DUEL"),
            Self::STASHED_RECRUIT => Some("STASHED_RECRUIT"),
            Self::CHOICES => Some("CHOICES"),
            Self::SPECIAL_ZONE => Some("SPECIAL_ZONE"),
            Self::EVENTS => Some("EVENTS"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeEventType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeEventType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeEventType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeEventType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeEventType {
    type Output = enum__Torappu_RoguelikeEventType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeEventType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeEventType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeEventType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_GAME_VARIATION_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_GAME_VARIATION_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_GAME_VARIATION_TYPE:
    [enum__Torappu_RoguelikeGameVariationType; 4] = [
    enum__Torappu_RoguelikeGameVariationType::NONE,
    enum__Torappu_RoguelikeGameVariationType::MAP,
    enum__Torappu_RoguelikeGameVariationType::RES,
    enum__Torappu_RoguelikeGameVariationType::BAT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeGameVariationType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeGameVariationType {
    pub const NONE: Self = Self(0);
    pub const MAP: Self = Self(1);
    pub const RES: Self = Self(2);
    pub const BAT: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::MAP, Self::RES, Self::BAT];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MAP => Some("MAP"),
            Self::RES => Some("RES"),
            Self::BAT => Some("BAT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeGameVariationType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeGameVariationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeGameVariationType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeGameVariationType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeGameVariationType {
    type Output = enum__Torappu_RoguelikeGameVariationType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeGameVariationType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeGameVariationType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeGameVariationType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_GAME_CHAR_BUFF_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_GAME_CHAR_BUFF_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_GAME_CHAR_BUFF_TYPE:
    [enum__Torappu_RoguelikeGameCharBuffType; 3] = [
    enum__Torappu_RoguelikeGameCharBuffType::NONE,
    enum__Torappu_RoguelikeGameCharBuffType::MUTATION,
    enum__Torappu_RoguelikeGameCharBuffType::EVOLUTION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeGameCharBuffType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeGameCharBuffType {
    pub const NONE: Self = Self(0);
    pub const MUTATION: Self = Self(1);
    pub const EVOLUTION: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::MUTATION, Self::EVOLUTION];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MUTATION => Some("MUTATION"),
            Self::EVOLUTION => Some("EVOLUTION"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeGameCharBuffType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeGameCharBuffType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeGameCharBuffType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeGameCharBuffType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeGameCharBuffType {
    type Output = enum__Torappu_RoguelikeGameCharBuffType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeGameCharBuffType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeGameCharBuffType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeGameCharBuffType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_TASK_RARITY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_TASK_RARITY: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_TASK_RARITY: [enum__Torappu_RoguelikeTaskRarity; 3] = [
    enum__Torappu_RoguelikeTaskRarity::NORMAL,
    enum__Torappu_RoguelikeTaskRarity::RARE,
    enum__Torappu_RoguelikeTaskRarity::SUPER_RARE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeTaskRarity(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeTaskRarity {
    pub const NORMAL: Self = Self(0);
    pub const RARE: Self = Self(1);
    pub const SUPER_RARE: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NORMAL, Self::RARE, Self::SUPER_RARE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::RARE => Some("RARE"),
            Self::SUPER_RARE => Some("SUPER_RARE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeTaskRarity {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeTaskRarity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeTaskRarity",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeTaskRarity {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeTaskRarity {
    type Output = enum__Torappu_RoguelikeTaskRarity;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeTaskRarity {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeTaskRarity {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeTaskRarity {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_BANK_REWARD_COUNT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_BANK_REWARD_COUNT_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_BANK_REWARD_COUNT_TYPE:
    [enum__Torappu_RoguelikeBankRewardCountType; 2] = [
    enum__Torappu_RoguelikeBankRewardCountType::HIGHEST_RECORD,
    enum__Torappu_RoguelikeBankRewardCountType::TOTAL_SUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeBankRewardCountType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeBankRewardCountType {
    pub const HIGHEST_RECORD: Self = Self(0);
    pub const TOTAL_SUM: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::HIGHEST_RECORD, Self::TOTAL_SUM];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::HIGHEST_RECORD => Some("HIGHEST_RECORD"),
            Self::TOTAL_SUM => Some("TOTAL_SUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeBankRewardCountType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeBankRewardCountType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeBankRewardCountType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeBankRewardCountType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeBankRewardCountType {
    type Output = enum__Torappu_RoguelikeBankRewardCountType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeBankRewardCountType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeBankRewardCountType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeBankRewardCountType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_REWARD_EX_DROP_TAG_SRC_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_REWARD_EX_DROP_TAG_SRC_TYPE: i32 = 5;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_REWARD_EX_DROP_TAG_SRC_TYPE:
    [enum__Torappu_RoguelikeRewardExDropTagSrcType; 6] = [
    enum__Torappu_RoguelikeRewardExDropTagSrcType::NONE,
    enum__Torappu_RoguelikeRewardExDropTagSrcType::TREASURE,
    enum__Torappu_RoguelikeRewardExDropTagSrcType::TOTEM,
    enum__Torappu_RoguelikeRewardExDropTagSrcType::EXPLORE_TOOL,
    enum__Torappu_RoguelikeRewardExDropTagSrcType::COPPER,
    enum__Torappu_RoguelikeRewardExDropTagSrcType::EVIL_TEMPLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeRewardExDropTagSrcType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeRewardExDropTagSrcType {
    pub const NONE: Self = Self(0);
    pub const TREASURE: Self = Self(1);
    pub const TOTEM: Self = Self(2);
    pub const EXPLORE_TOOL: Self = Self(3);
    pub const COPPER: Self = Self(4);
    pub const EVIL_TEMPLE: Self = Self(5);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 5;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::TREASURE,
        Self::TOTEM,
        Self::EXPLORE_TOOL,
        Self::COPPER,
        Self::EVIL_TEMPLE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TREASURE => Some("TREASURE"),
            Self::TOTEM => Some("TOTEM"),
            Self::EXPLORE_TOOL => Some("EXPLORE_TOOL"),
            Self::COPPER => Some("COPPER"),
            Self::EVIL_TEMPLE => Some("EVIL_TEMPLE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeRewardExDropTagSrcType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeRewardExDropTagSrcType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeRewardExDropTagSrcType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeRewardExDropTagSrcType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeRewardExDropTagSrcType {
    type Output = enum__Torappu_RoguelikeRewardExDropTagSrcType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeRewardExDropTagSrcType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeRewardExDropTagSrcType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeRewardExDropTagSrcType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_TIP_DATA_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_TIP_DATA_CATEGORY: i32 = 31;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_TIP_DATA_CATEGORY: [enum__Torappu_TipData_Category; 7] = [
    enum__Torappu_TipData_Category::NONE,
    enum__Torappu_TipData_Category::BATTLE,
    enum__Torappu_TipData_Category::UI,
    enum__Torappu_TipData_Category::BUILDING,
    enum__Torappu_TipData_Category::GACHA,
    enum__Torappu_TipData_Category::MISC,
    enum__Torappu_TipData_Category::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_TipData_Category(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_TipData_Category {
    pub const NONE: Self = Self(0);
    pub const BATTLE: Self = Self(1);
    pub const UI: Self = Self(2);
    pub const BUILDING: Self = Self(4);
    pub const GACHA: Self = Self(8);
    pub const MISC: Self = Self(16);
    pub const ALL: Self = Self(31);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 31;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::BATTLE,
        Self::UI,
        Self::BUILDING,
        Self::GACHA,
        Self::MISC,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BATTLE => Some("BATTLE"),
            Self::UI => Some("UI"),
            Self::BUILDING => Some("BUILDING"),
            Self::GACHA => Some("GACHA"),
            Self::MISC => Some("MISC"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_TipData_Category {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_TipData_Category {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_TipData_Category",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_TipData_Category {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_TipData_Category {
    type Output = enum__Torappu_TipData_Category;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_TipData_Category {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_TipData_Category {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_TipData_Category {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_GAME_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_GAME_ITEM_TYPE: i32 = 46;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_GAME_ITEM_TYPE:
    [enum__Torappu_RoguelikeGameItemType; 47] = [
    enum__Torappu_RoguelikeGameItemType::NONE,
    enum__Torappu_RoguelikeGameItemType::HP,
    enum__Torappu_RoguelikeGameItemType::HPMAX,
    enum__Torappu_RoguelikeGameItemType::GOLD,
    enum__Torappu_RoguelikeGameItemType::POPULATION,
    enum__Torappu_RoguelikeGameItemType::EXP,
    enum__Torappu_RoguelikeGameItemType::SQUAD_CAPACITY,
    enum__Torappu_RoguelikeGameItemType::RECRUIT_TICKET,
    enum__Torappu_RoguelikeGameItemType::UPGRADE_TICKET,
    enum__Torappu_RoguelikeGameItemType::RELIC,
    enum__Torappu_RoguelikeGameItemType::BP_POINT,
    enum__Torappu_RoguelikeGameItemType::GROW_POINT,
    enum__Torappu_RoguelikeGameItemType::BAND,
    enum__Torappu_RoguelikeGameItemType::ACTIVE_TOOL,
    enum__Torappu_RoguelikeGameItemType::CAPSULE,
    enum__Torappu_RoguelikeGameItemType::POOL,
    enum__Torappu_RoguelikeGameItemType::RL_BP,
    enum__Torappu_RoguelikeGameItemType::RL_GP,
    enum__Torappu_RoguelikeGameItemType::KEY_POINT,
    enum__Torappu_RoguelikeGameItemType::SAN_POINT,
    enum__Torappu_RoguelikeGameItemType::DICE_POINT,
    enum__Torappu_RoguelikeGameItemType::DICE_TYPE,
    enum__Torappu_RoguelikeGameItemType::SHIELD,
    enum__Torappu_RoguelikeGameItemType::LOCKED_TREASURE,
    enum__Torappu_RoguelikeGameItemType::CUSTOM_TICKET,
    enum__Torappu_RoguelikeGameItemType::TOTEM,
    enum__Torappu_RoguelikeGameItemType::TOTEM_EFFECT,
    enum__Torappu_RoguelikeGameItemType::FEATURE,
    enum__Torappu_RoguelikeGameItemType::VISION,
    enum__Torappu_RoguelikeGameItemType::CHAOS,
    enum__Torappu_RoguelikeGameItemType::CHAOS_PURIFY,
    enum__Torappu_RoguelikeGameItemType::CHAOS_LEVEL,
    enum__Torappu_RoguelikeGameItemType::EXPLORE_TOOL,
    enum__Torappu_RoguelikeGameItemType::FRAGMENT,
    enum__Torappu_RoguelikeGameItemType::MAX_WEIGHT,
    enum__Torappu_RoguelikeGameItemType::DISASTER,
    enum__Torappu_RoguelikeGameItemType::DISASTER_TYPE,
    enum__Torappu_RoguelikeGameItemType::ABSTRACT_DISASTER,
    enum__Torappu_RoguelikeGameItemType::PILL,
    enum__Torappu_RoguelikeGameItemType::BIGPILL,
    enum__Torappu_RoguelikeGameItemType::COPPER,
    enum__Torappu_RoguelikeGameItemType::COPPER_BUFF,
    enum__Torappu_RoguelikeGameItemType::DIVINATION_KIT,
    enum__Torappu_RoguelikeGameItemType::WRATH,
    enum__Torappu_RoguelikeGameItemType::SPECIAL_ZONE_AP,
    enum__Torappu_RoguelikeGameItemType::COPPER_DRAW_NUM,
    enum__Torappu_RoguelikeGameItemType::STASH_RECRUIT_LIMIT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeGameItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeGameItemType {
    pub const NONE: Self = Self(0);
    pub const HP: Self = Self(1);
    pub const HPMAX: Self = Self(2);
    pub const GOLD: Self = Self(3);
    pub const POPULATION: Self = Self(4);
    pub const EXP: Self = Self(5);
    pub const SQUAD_CAPACITY: Self = Self(6);
    pub const RECRUIT_TICKET: Self = Self(7);
    pub const UPGRADE_TICKET: Self = Self(8);
    pub const RELIC: Self = Self(9);
    pub const BP_POINT: Self = Self(10);
    pub const GROW_POINT: Self = Self(11);
    pub const BAND: Self = Self(12);
    pub const ACTIVE_TOOL: Self = Self(13);
    pub const CAPSULE: Self = Self(14);
    pub const POOL: Self = Self(15);
    pub const RL_BP: Self = Self(16);
    pub const RL_GP: Self = Self(17);
    pub const KEY_POINT: Self = Self(18);
    pub const SAN_POINT: Self = Self(19);
    pub const DICE_POINT: Self = Self(20);
    pub const DICE_TYPE: Self = Self(21);
    pub const SHIELD: Self = Self(22);
    pub const LOCKED_TREASURE: Self = Self(23);
    pub const CUSTOM_TICKET: Self = Self(24);
    pub const TOTEM: Self = Self(25);
    pub const TOTEM_EFFECT: Self = Self(26);
    pub const FEATURE: Self = Self(27);
    pub const VISION: Self = Self(28);
    pub const CHAOS: Self = Self(29);
    pub const CHAOS_PURIFY: Self = Self(30);
    pub const CHAOS_LEVEL: Self = Self(31);
    pub const EXPLORE_TOOL: Self = Self(32);
    pub const FRAGMENT: Self = Self(33);
    pub const MAX_WEIGHT: Self = Self(34);
    pub const DISASTER: Self = Self(35);
    pub const DISASTER_TYPE: Self = Self(36);
    pub const ABSTRACT_DISASTER: Self = Self(37);
    pub const PILL: Self = Self(38);
    pub const BIGPILL: Self = Self(39);
    pub const COPPER: Self = Self(40);
    pub const COPPER_BUFF: Self = Self(41);
    pub const DIVINATION_KIT: Self = Self(42);
    pub const WRATH: Self = Self(43);
    pub const SPECIAL_ZONE_AP: Self = Self(44);
    pub const COPPER_DRAW_NUM: Self = Self(45);
    pub const STASH_RECRUIT_LIMIT: Self = Self(46);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 46;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::HP,
        Self::HPMAX,
        Self::GOLD,
        Self::POPULATION,
        Self::EXP,
        Self::SQUAD_CAPACITY,
        Self::RECRUIT_TICKET,
        Self::UPGRADE_TICKET,
        Self::RELIC,
        Self::BP_POINT,
        Self::GROW_POINT,
        Self::BAND,
        Self::ACTIVE_TOOL,
        Self::CAPSULE,
        Self::POOL,
        Self::RL_BP,
        Self::RL_GP,
        Self::KEY_POINT,
        Self::SAN_POINT,
        Self::DICE_POINT,
        Self::DICE_TYPE,
        Self::SHIELD,
        Self::LOCKED_TREASURE,
        Self::CUSTOM_TICKET,
        Self::TOTEM,
        Self::TOTEM_EFFECT,
        Self::FEATURE,
        Self::VISION,
        Self::CHAOS,
        Self::CHAOS_PURIFY,
        Self::CHAOS_LEVEL,
        Self::EXPLORE_TOOL,
        Self::FRAGMENT,
        Self::MAX_WEIGHT,
        Self::DISASTER,
        Self::DISASTER_TYPE,
        Self::ABSTRACT_DISASTER,
        Self::PILL,
        Self::BIGPILL,
        Self::COPPER,
        Self::COPPER_BUFF,
        Self::DIVINATION_KIT,
        Self::WRATH,
        Self::SPECIAL_ZONE_AP,
        Self::COPPER_DRAW_NUM,
        Self::STASH_RECRUIT_LIMIT,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::HP => Some("HP"),
            Self::HPMAX => Some("HPMAX"),
            Self::GOLD => Some("GOLD"),
            Self::POPULATION => Some("POPULATION"),
            Self::EXP => Some("EXP"),
            Self::SQUAD_CAPACITY => Some("SQUAD_CAPACITY"),
            Self::RECRUIT_TICKET => Some("RECRUIT_TICKET"),
            Self::UPGRADE_TICKET => Some("UPGRADE_TICKET"),
            Self::RELIC => Some("RELIC"),
            Self::BP_POINT => Some("BP_POINT"),
            Self::GROW_POINT => Some("GROW_POINT"),
            Self::BAND => Some("BAND"),
            Self::ACTIVE_TOOL => Some("ACTIVE_TOOL"),
            Self::CAPSULE => Some("CAPSULE"),
            Self::POOL => Some("POOL"),
            Self::RL_BP => Some("RL_BP"),
            Self::RL_GP => Some("RL_GP"),
            Self::KEY_POINT => Some("KEY_POINT"),
            Self::SAN_POINT => Some("SAN_POINT"),
            Self::DICE_POINT => Some("DICE_POINT"),
            Self::DICE_TYPE => Some("DICE_TYPE"),
            Self::SHIELD => Some("SHIELD"),
            Self::LOCKED_TREASURE => Some("LOCKED_TREASURE"),
            Self::CUSTOM_TICKET => Some("CUSTOM_TICKET"),
            Self::TOTEM => Some("TOTEM"),
            Self::TOTEM_EFFECT => Some("TOTEM_EFFECT"),
            Self::FEATURE => Some("FEATURE"),
            Self::VISION => Some("VISION"),
            Self::CHAOS => Some("CHAOS"),
            Self::CHAOS_PURIFY => Some("CHAOS_PURIFY"),
            Self::CHAOS_LEVEL => Some("CHAOS_LEVEL"),
            Self::EXPLORE_TOOL => Some("EXPLORE_TOOL"),
            Self::FRAGMENT => Some("FRAGMENT"),
            Self::MAX_WEIGHT => Some("MAX_WEIGHT"),
            Self::DISASTER => Some("DISASTER"),
            Self::DISASTER_TYPE => Some("DISASTER_TYPE"),
            Self::ABSTRACT_DISASTER => Some("ABSTRACT_DISASTER"),
            Self::PILL => Some("PILL"),
            Self::BIGPILL => Some("BIGPILL"),
            Self::COPPER => Some("COPPER"),
            Self::COPPER_BUFF => Some("COPPER_BUFF"),
            Self::DIVINATION_KIT => Some("DIVINATION_KIT"),
            Self::WRATH => Some("WRATH"),
            Self::SPECIAL_ZONE_AP => Some("SPECIAL_ZONE_AP"),
            Self::COPPER_DRAW_NUM => Some("COPPER_DRAW_NUM"),
            Self::STASH_RECRUIT_LIMIT => Some("STASH_RECRUIT_LIMIT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeGameItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeGameItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeGameItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeGameItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeGameItemType {
    type Output = enum__Torappu_RoguelikeGameItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeGameItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeGameItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeGameItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_GAME_ITEM_SUB_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_GAME_ITEM_SUB_TYPE: i32 = 64;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_GAME_ITEM_SUB_TYPE:
    [enum__Torappu_RoguelikeGameItemSubType; 8] = [
    enum__Torappu_RoguelikeGameItemSubType::NONE,
    enum__Torappu_RoguelikeGameItemSubType::CURSE,
    enum__Torappu_RoguelikeGameItemSubType::TEMP_TICKET,
    enum__Torappu_RoguelikeGameItemSubType::TOTEM_UPPER,
    enum__Torappu_RoguelikeGameItemSubType::TOTEM_LOWER,
    enum__Torappu_RoguelikeGameItemSubType::SECRET,
    enum__Torappu_RoguelikeGameItemSubType::SINGLE_RAND_FREE,
    enum__Torappu_RoguelikeGameItemSubType::RED_CAPSULE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeGameItemSubType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeGameItemSubType {
    pub const NONE: Self = Self(0);
    pub const CURSE: Self = Self(1);
    pub const TEMP_TICKET: Self = Self(2);
    pub const TOTEM_UPPER: Self = Self(4);
    pub const TOTEM_LOWER: Self = Self(8);
    pub const SECRET: Self = Self(16);
    pub const SINGLE_RAND_FREE: Self = Self(32);
    pub const RED_CAPSULE: Self = Self(64);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 64;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CURSE,
        Self::TEMP_TICKET,
        Self::TOTEM_UPPER,
        Self::TOTEM_LOWER,
        Self::SECRET,
        Self::SINGLE_RAND_FREE,
        Self::RED_CAPSULE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CURSE => Some("CURSE"),
            Self::TEMP_TICKET => Some("TEMP_TICKET"),
            Self::TOTEM_UPPER => Some("TOTEM_UPPER"),
            Self::TOTEM_LOWER => Some("TOTEM_LOWER"),
            Self::SECRET => Some("SECRET"),
            Self::SINGLE_RAND_FREE => Some("SINGLE_RAND_FREE"),
            Self::RED_CAPSULE => Some("RED_CAPSULE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeGameItemSubType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeGameItemSubType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeGameItemSubType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeGameItemSubType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeGameItemSubType {
    type Output = enum__Torappu_RoguelikeGameItemSubType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeGameItemSubType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeGameItemSubType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeGameItemSubType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_GAME_ITEM_RARITY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_GAME_ITEM_RARITY: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_GAME_ITEM_RARITY:
    [enum__Torappu_RoguelikeGameItemRarity; 5] = [
    enum__Torappu_RoguelikeGameItemRarity::NONE,
    enum__Torappu_RoguelikeGameItemRarity::BORN,
    enum__Torappu_RoguelikeGameItemRarity::NORMAL,
    enum__Torappu_RoguelikeGameItemRarity::RARE,
    enum__Torappu_RoguelikeGameItemRarity::SUPER_RARE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeGameItemRarity(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeGameItemRarity {
    pub const NONE: Self = Self(0);
    pub const BORN: Self = Self(1);
    pub const NORMAL: Self = Self(2);
    pub const RARE: Self = Self(3);
    pub const SUPER_RARE: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::BORN,
        Self::NORMAL,
        Self::RARE,
        Self::SUPER_RARE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BORN => Some("BORN"),
            Self::NORMAL => Some("NORMAL"),
            Self::RARE => Some("RARE"),
            Self::SUPER_RARE => Some("SUPER_RARE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeGameItemRarity {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeGameItemRarity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeGameItemRarity",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeGameItemRarity {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeGameItemRarity {
    type Output = enum__Torappu_RoguelikeGameItemRarity;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeGameItemRarity {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeGameItemRarity {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeGameItemRarity {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_ENDING_DETAIL_TEXT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_ENDING_DETAIL_TEXT_TYPE: i32 = 15;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_ENDING_DETAIL_TEXT_TYPE:
    [enum__Torappu_RoguelikeEndingDetailText_Type; 16] = [
    enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_CHOICE,
    enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_RELIC,
    enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_CAPSULE,
    enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_ACTIVE_TOOL,
    enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_ACCELERATE_CHAR,
    enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_NORMAL_RECRUIT,
    enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_DIRECT_RECRUIT,
    enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_FRIEND_RECRUIT,
    enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_FREE_RECRUIT,
    enum__Torappu_RoguelikeEndingDetailText_Type::BUY,
    enum__Torappu_RoguelikeEndingDetailText_Type::INVEST,
    enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_STAGE,
    enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_CONST,
    enum__Torappu_RoguelikeEndingDetailText_Type::SUM,
    enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_BOSS_END,
    enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_BATTLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeEndingDetailText_Type(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeEndingDetailText_Type {
    pub const SHOW_CHOICE: Self = Self(0);
    pub const SHOW_RELIC: Self = Self(1);
    pub const SHOW_CAPSULE: Self = Self(2);
    pub const SHOW_ACTIVE_TOOL: Self = Self(3);
    pub const SHOW_ACCELERATE_CHAR: Self = Self(4);
    pub const SHOW_NORMAL_RECRUIT: Self = Self(5);
    pub const SHOW_DIRECT_RECRUIT: Self = Self(6);
    pub const SHOW_FRIEND_RECRUIT: Self = Self(7);
    pub const SHOW_FREE_RECRUIT: Self = Self(8);
    pub const BUY: Self = Self(9);
    pub const INVEST: Self = Self(10);
    pub const SHOW_STAGE: Self = Self(11);
    pub const SHOW_CONST: Self = Self(12);
    pub const SUM: Self = Self(13);
    pub const SHOW_BOSS_END: Self = Self(14);
    pub const SHOW_BATTLE: Self = Self(15);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 15;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::SHOW_CHOICE,
        Self::SHOW_RELIC,
        Self::SHOW_CAPSULE,
        Self::SHOW_ACTIVE_TOOL,
        Self::SHOW_ACCELERATE_CHAR,
        Self::SHOW_NORMAL_RECRUIT,
        Self::SHOW_DIRECT_RECRUIT,
        Self::SHOW_FRIEND_RECRUIT,
        Self::SHOW_FREE_RECRUIT,
        Self::BUY,
        Self::INVEST,
        Self::SHOW_STAGE,
        Self::SHOW_CONST,
        Self::SUM,
        Self::SHOW_BOSS_END,
        Self::SHOW_BATTLE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::SHOW_CHOICE => Some("SHOW_CHOICE"),
            Self::SHOW_RELIC => Some("SHOW_RELIC"),
            Self::SHOW_CAPSULE => Some("SHOW_CAPSULE"),
            Self::SHOW_ACTIVE_TOOL => Some("SHOW_ACTIVE_TOOL"),
            Self::SHOW_ACCELERATE_CHAR => Some("SHOW_ACCELERATE_CHAR"),
            Self::SHOW_NORMAL_RECRUIT => Some("SHOW_NORMAL_RECRUIT"),
            Self::SHOW_DIRECT_RECRUIT => Some("SHOW_DIRECT_RECRUIT"),
            Self::SHOW_FRIEND_RECRUIT => Some("SHOW_FRIEND_RECRUIT"),
            Self::SHOW_FREE_RECRUIT => Some("SHOW_FREE_RECRUIT"),
            Self::BUY => Some("BUY"),
            Self::INVEST => Some("INVEST"),
            Self::SHOW_STAGE => Some("SHOW_STAGE"),
            Self::SHOW_CONST => Some("SHOW_CONST"),
            Self::SUM => Some("SUM"),
            Self::SHOW_BOSS_END => Some("SHOW_BOSS_END"),
            Self::SHOW_BATTLE => Some("SHOW_BATTLE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeEndingDetailText_Type {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeEndingDetailText_Type {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeEndingDetailText_Type",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeEndingDetailText_Type {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeEndingDetailText_Type {
    type Output = enum__Torappu_RoguelikeEndingDetailText_Type;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeEndingDetailText_Type {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeEndingDetailText_Type {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeEndingDetailText_Type {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_EXP_STYLE_CONFIG_PARAM: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_EXP_STYLE_CONFIG_PARAM: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_EXP_STYLE_CONFIG_PARAM:
    [enum__Torappu_RoguelikeExpStyleConfigParam; 1] =
    [enum__Torappu_RoguelikeExpStyleConfigParam::BATTLE_END_HP_LOSE_TEXT];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeExpStyleConfigParam(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeExpStyleConfigParam {
    pub const BATTLE_END_HP_LOSE_TEXT: Self = Self(0);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 0;
    pub const ENUM_VALUES: &'static [Self] = &[Self::BATTLE_END_HP_LOSE_TEXT];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::BATTLE_END_HP_LOSE_TEXT => Some("BATTLE_END_HP_LOSE_TEXT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeExpStyleConfigParam {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeExpStyleConfigParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeExpStyleConfigParam",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeExpStyleConfigParam {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeExpStyleConfigParam {
    type Output = enum__Torappu_RoguelikeExpStyleConfigParam;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeExpStyleConfigParam {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeExpStyleConfigParam {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeExpStyleConfigParam {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_ACTIVITY_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_ACTIVITY_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_ACTIVITY_TYPE: [enum__Torappu_RoguelikeActivityType;
    2] = [
    enum__Torappu_RoguelikeActivityType::NONE,
    enum__Torappu_RoguelikeActivityType::SEED_MODE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeActivityType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeActivityType {
    pub const NONE: Self = Self(0);
    pub const SEED_MODE: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::SEED_MODE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SEED_MODE => Some("SEED_MODE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeActivityType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeActivityType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeActivityType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeActivityType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeActivityType {
    type Output = enum__Torappu_RoguelikeActivityType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeActivityType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeActivityType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeActivityType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SAN_EFFECT_RANK: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SAN_EFFECT_RANK: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SAN_EFFECT_RANK: [enum__Torappu_SanEffectRank; 4] = [
    enum__Torappu_SanEffectRank::SAN_EFFECT_0,
    enum__Torappu_SanEffectRank::SAN_EFFECT_1,
    enum__Torappu_SanEffectRank::SAN_EFFECT_2,
    enum__Torappu_SanEffectRank::SAN_EFFECT_3,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SanEffectRank(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SanEffectRank {
    pub const SAN_EFFECT_0: Self = Self(0);
    pub const SAN_EFFECT_1: Self = Self(1);
    pub const SAN_EFFECT_2: Self = Self(2);
    pub const SAN_EFFECT_3: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::SAN_EFFECT_0,
        Self::SAN_EFFECT_1,
        Self::SAN_EFFECT_2,
        Self::SAN_EFFECT_3,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::SAN_EFFECT_0 => Some("SAN_EFFECT_0"),
            Self::SAN_EFFECT_1 => Some("SAN_EFFECT_1"),
            Self::SAN_EFFECT_2 => Some("SAN_EFFECT_2"),
            Self::SAN_EFFECT_3 => Some("SAN_EFFECT_3"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SanEffectRank {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SanEffectRank {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SanEffectRank",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SanEffectRank {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SanEffectRank {
    type Output = enum__Torappu_SanEffectRank;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SanEffectRank {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SanEffectRank {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SanEffectRank {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_DICE_RESULT_CLASS: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_DICE_RESULT_CLASS: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_DICE_RESULT_CLASS: [enum__Torappu_DiceResultClass; 6] = [
    enum__Torappu_DiceResultClass::VERYBAD,
    enum__Torappu_DiceResultClass::BAD,
    enum__Torappu_DiceResultClass::NORMAL,
    enum__Torappu_DiceResultClass::GOOD,
    enum__Torappu_DiceResultClass::BEST,
    enum__Torappu_DiceResultClass::GREAT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_DiceResultClass(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_DiceResultClass {
    pub const VERYBAD: Self = Self(0);
    pub const BAD: Self = Self(1);
    pub const NORMAL: Self = Self(2);
    pub const GOOD: Self = Self(3);
    pub const BEST: Self = Self(4);
    pub const GREAT: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::VERYBAD,
        Self::BAD,
        Self::NORMAL,
        Self::GOOD,
        Self::BEST,
        Self::GREAT,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::VERYBAD => Some("VERYBAD"),
            Self::BAD => Some("BAD"),
            Self::NORMAL => Some("NORMAL"),
            Self::GOOD => Some("GOOD"),
            Self::BEST => Some("BEST"),
            Self::GREAT => Some("GREAT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_DiceResultClass {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_DiceResultClass {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_DiceResultClass",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_DiceResultClass {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_DiceResultClass {
    type Output = enum__Torappu_DiceResultClass;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_DiceResultClass {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_DiceResultClass {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_DiceResultClass {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_DICE_RESULT_SHOW_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_DICE_RESULT_SHOW_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_DICE_RESULT_SHOW_TYPE: [enum__Torappu_DiceResultShowType; 3] = [
    enum__Torappu_DiceResultShowType::RAW_TEXT,
    enum__Torappu_DiceResultShowType::MUTATION,
    enum__Torappu_DiceResultShowType::VIRTUE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_DiceResultShowType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_DiceResultShowType {
    pub const RAW_TEXT: Self = Self(0);
    pub const MUTATION: Self = Self(1);
    pub const VIRTUE: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::RAW_TEXT, Self::MUTATION, Self::VIRTUE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::RAW_TEXT => Some("RAW_TEXT"),
            Self::MUTATION => Some("MUTATION"),
            Self::VIRTUE => Some("VIRTUE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_DiceResultShowType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_DiceResultShowType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_DiceResultShowType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_DiceResultShowType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_DiceResultShowType {
    type Output = enum__Torappu_DiceResultShowType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_DiceResultShowType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_DiceResultShowType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_DiceResultShowType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_CHAOS_EFFECT_RANK: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_CHAOS_EFFECT_RANK: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_CHAOS_EFFECT_RANK: [enum__Torappu_ChaosEffectRank; 3] = [
    enum__Torappu_ChaosEffectRank::CHAOS_EFFECT_0,
    enum__Torappu_ChaosEffectRank::CHAOS_EFFECT_1,
    enum__Torappu_ChaosEffectRank::CHAOS_EFFECT_2,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ChaosEffectRank(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ChaosEffectRank {
    pub const CHAOS_EFFECT_0: Self = Self(0);
    pub const CHAOS_EFFECT_1: Self = Self(1);
    pub const CHAOS_EFFECT_2: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::CHAOS_EFFECT_0,
        Self::CHAOS_EFFECT_1,
        Self::CHAOS_EFFECT_2,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::CHAOS_EFFECT_0 => Some("CHAOS_EFFECT_0"),
            Self::CHAOS_EFFECT_1 => Some("CHAOS_EFFECT_1"),
            Self::CHAOS_EFFECT_2 => Some("CHAOS_EFFECT_2"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ChaosEffectRank {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ChaosEffectRank {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ChaosEffectRank",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ChaosEffectRank {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ChaosEffectRank {
    type Output = enum__Torappu_ChaosEffectRank;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ChaosEffectRank {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ChaosEffectRank {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ChaosEffectRank {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_TOTEM_COLOR_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_TOTEM_COLOR_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_TOTEM_COLOR_TYPE:
    [enum__Torappu_RoguelikeTotemColorType; 5] = [
    enum__Torappu_RoguelikeTotemColorType::NONE,
    enum__Torappu_RoguelikeTotemColorType::RED,
    enum__Torappu_RoguelikeTotemColorType::GREEN,
    enum__Torappu_RoguelikeTotemColorType::BLUE,
    enum__Torappu_RoguelikeTotemColorType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeTotemColorType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeTotemColorType {
    pub const NONE: Self = Self(0);
    pub const RED: Self = Self(1);
    pub const GREEN: Self = Self(2);
    pub const BLUE: Self = Self(3);
    pub const ALL: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::RED, Self::GREEN, Self::BLUE, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::RED => Some("RED"),
            Self::GREEN => Some("GREEN"),
            Self::BLUE => Some("BLUE"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeTotemColorType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeTotemColorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeTotemColorType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeTotemColorType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeTotemColorType {
    type Output = enum__Torappu_RoguelikeTotemColorType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeTotemColorType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeTotemColorType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeTotemColorType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_TOTEM_POS_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_TOTEM_POS_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_TOTEM_POS_TYPE:
    [enum__Torappu_RoguelikeTotemPosType; 2] = [
    enum__Torappu_RoguelikeTotemPosType::LOCATION,
    enum__Torappu_RoguelikeTotemPosType::EFFECT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeTotemPosType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeTotemPosType {
    pub const LOCATION: Self = Self(0);
    pub const EFFECT: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::LOCATION, Self::EFFECT];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::LOCATION => Some("LOCATION"),
            Self::EFFECT => Some("EFFECT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeTotemPosType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeTotemPosType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeTotemPosType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeTotemPosType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeTotemPosType {
    type Output = enum__Torappu_RoguelikeTotemPosType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeTotemPosType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeTotemPosType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeTotemPosType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_TOTEM_BLUR_NODE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_TOTEM_BLUR_NODE_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_TOTEM_BLUR_NODE_TYPE:
    [enum__Torappu_RoguelikeTotemBlurNodeType; 3] = [
    enum__Torappu_RoguelikeTotemBlurNodeType::NONE,
    enum__Torappu_RoguelikeTotemBlurNodeType::BATTLE,
    enum__Torappu_RoguelikeTotemBlurNodeType::NO_BATTLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeTotemBlurNodeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeTotemBlurNodeType {
    pub const NONE: Self = Self(0);
    pub const BATTLE: Self = Self(1);
    pub const NO_BATTLE: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::BATTLE, Self::NO_BATTLE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BATTLE => Some("BATTLE"),
            Self::NO_BATTLE => Some("NO_BATTLE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeTotemBlurNodeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeTotemBlurNodeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeTotemBlurNodeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeTotemBlurNodeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeTotemBlurNodeType {
    type Output = enum__Torappu_RoguelikeTotemBlurNodeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeTotemBlurNodeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeTotemBlurNodeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeTotemBlurNodeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_VISION_MODULE_DATA_VISION_CHOICE_CHECK_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_VISION_MODULE_DATA_VISION_CHOICE_CHECK_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_VISION_MODULE_DATA_VISION_CHOICE_CHECK_TYPE:
    [enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType; 2] = [
    enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType::LOWER,
    enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType::UPPER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType {
    pub const LOWER: Self = Self(0);
    pub const UPPER: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::LOWER, Self::UPPER];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::LOWER => Some("LOWER"),
            Self::UPPER => Some("UPPER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType {
    type Output = enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice
    for enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType
{
}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_FRAGMENT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_FRAGMENT_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_FRAGMENT_TYPE: [enum__Torappu_RoguelikeFragmentType;
    4] = [
    enum__Torappu_RoguelikeFragmentType::NONE,
    enum__Torappu_RoguelikeFragmentType::INSPIRATION,
    enum__Torappu_RoguelikeFragmentType::WISH,
    enum__Torappu_RoguelikeFragmentType::IDEA,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeFragmentType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeFragmentType {
    pub const NONE: Self = Self(0);
    pub const INSPIRATION: Self = Self(1);
    pub const WISH: Self = Self(2);
    pub const IDEA: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::INSPIRATION, Self::WISH, Self::IDEA];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::INSPIRATION => Some("INSPIRATION"),
            Self::WISH => Some("WISH"),
            Self::IDEA => Some("IDEA"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeFragmentType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeFragmentType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeFragmentType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeFragmentType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeFragmentType {
    type Output = enum__Torappu_RoguelikeFragmentType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeFragmentType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeFragmentType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeFragmentType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ALCHEMY_POOL_RARITY_TYPE: i32 = -1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ALCHEMY_POOL_RARITY_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ALCHEMY_POOL_RARITY_TYPE:
    [enum__Torappu_AlchemyPoolRarityType; 4] = [
    enum__Torappu_AlchemyPoolRarityType::NONE,
    enum__Torappu_AlchemyPoolRarityType::NORMAL,
    enum__Torappu_AlchemyPoolRarityType::RARE,
    enum__Torappu_AlchemyPoolRarityType::SUPER_RARE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_AlchemyPoolRarityType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_AlchemyPoolRarityType {
    pub const NONE: Self = Self(-1);
    pub const NORMAL: Self = Self(0);
    pub const RARE: Self = Self(1);
    pub const SUPER_RARE: Self = Self(2);

    pub const ENUM_MIN: i32 = -1;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::NORMAL, Self::RARE, Self::SUPER_RARE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NORMAL => Some("NORMAL"),
            Self::RARE => Some("RARE"),
            Self::SUPER_RARE => Some("SUPER_RARE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_AlchemyPoolRarityType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_AlchemyPoolRarityType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_AlchemyPoolRarityType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_AlchemyPoolRarityType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_AlchemyPoolRarityType {
    type Output = enum__Torappu_AlchemyPoolRarityType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_AlchemyPoolRarityType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_AlchemyPoolRarityType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_AlchemyPoolRarityType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_COPPER_BUFF_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_COPPER_BUFF_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_COPPER_BUFF_TYPE:
    [enum__Torappu_RoguelikeCopperBuffType; 3] = [
    enum__Torappu_RoguelikeCopperBuffType::NONE,
    enum__Torappu_RoguelikeCopperBuffType::REFRESH,
    enum__Torappu_RoguelikeCopperBuffType::MOVE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeCopperBuffType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeCopperBuffType {
    pub const NONE: Self = Self(0);
    pub const REFRESH: Self = Self(1);
    pub const MOVE: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::REFRESH, Self::MOVE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::REFRESH => Some("REFRESH"),
            Self::MOVE => Some("MOVE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeCopperBuffType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeCopperBuffType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeCopperBuffType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeCopperBuffType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeCopperBuffType {
    type Output = enum__Torappu_RoguelikeCopperBuffType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeCopperBuffType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeCopperBuffType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeCopperBuffType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_COPPER_DIVINE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_COPPER_DIVINE_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_COPPER_DIVINE_TYPE:
    [enum__Torappu_RoguelikeCopperDivineType; 3] = [
    enum__Torappu_RoguelikeCopperDivineType::NONE,
    enum__Torappu_RoguelikeCopperDivineType::DIVINE,
    enum__Torappu_RoguelikeCopperDivineType::EVENT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeCopperDivineType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeCopperDivineType {
    pub const NONE: Self = Self(0);
    pub const DIVINE: Self = Self(1);
    pub const EVENT: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::DIVINE, Self::EVENT];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::DIVINE => Some("DIVINE"),
            Self::EVENT => Some("EVENT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeCopperDivineType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeCopperDivineType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeCopperDivineType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeCopperDivineType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeCopperDivineType {
    type Output = enum__Torappu_RoguelikeCopperDivineType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeCopperDivineType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeCopperDivineType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeCopperDivineType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_COPPER_DIVINE_RESULT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_COPPER_DIVINE_RESULT_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_COPPER_DIVINE_RESULT_TYPE:
    [enum__Torappu_RoguelikeCopperDivineResultType; 4] = [
    enum__Torappu_RoguelikeCopperDivineResultType::NONE,
    enum__Torappu_RoguelikeCopperDivineResultType::GOOD,
    enum__Torappu_RoguelikeCopperDivineResultType::NORMAL,
    enum__Torappu_RoguelikeCopperDivineResultType::BAD,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeCopperDivineResultType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeCopperDivineResultType {
    pub const NONE: Self = Self(0);
    pub const GOOD: Self = Self(1);
    pub const NORMAL: Self = Self(2);
    pub const BAD: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::GOOD, Self::NORMAL, Self::BAD];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::GOOD => Some("GOOD"),
            Self::NORMAL => Some("NORMAL"),
            Self::BAD => Some("BAD"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeCopperDivineResultType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeCopperDivineResultType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeCopperDivineResultType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeCopperDivineResultType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeCopperDivineResultType {
    type Output = enum__Torappu_RoguelikeCopperDivineResultType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeCopperDivineResultType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeCopperDivineResultType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeCopperDivineResultType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_SKY_ZONE_NODE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_SKY_ZONE_NODE_TYPE: i32 = 3548;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_SKY_ZONE_NODE_TYPE:
    [enum__Torappu_RoguelikeSkyZoneNodeType; 15] = [
    enum__Torappu_RoguelikeSkyZoneNodeType::NONE,
    enum__Torappu_RoguelikeSkyZoneNodeType::ORIGIN,
    enum__Torappu_RoguelikeSkyZoneNodeType::BATTLE,
    enum__Torappu_RoguelikeSkyZoneNodeType::TRIAL_GATE,
    enum__Torappu_RoguelikeSkyZoneNodeType::INCIDENT,
    enum__Torappu_RoguelikeSkyZoneNodeType::TREASURE,
    enum__Torappu_RoguelikeSkyZoneNodeType::SHOP,
    enum__Torappu_RoguelikeSkyZoneNodeType::SACRIFICE,
    enum__Torappu_RoguelikeSkyZoneNodeType::ENTERTAINMENT,
    enum__Torappu_RoguelikeSkyZoneNodeType::MARKET,
    enum__Torappu_RoguelikeSkyZoneNodeType::BATTLE_HARD,
    enum__Torappu_RoguelikeSkyZoneNodeType::BATTLES,
    enum__Torappu_RoguelikeSkyZoneNodeType::INCIDENT_BOSS,
    enum__Torappu_RoguelikeSkyZoneNodeType::INCIDENT_BOSS_ONLY,
    enum__Torappu_RoguelikeSkyZoneNodeType::CHOICES,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeSkyZoneNodeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeSkyZoneNodeType {
    pub const NONE: Self = Self(0);
    pub const ORIGIN: Self = Self(1);
    pub const BATTLE: Self = Self(2);
    pub const TRIAL_GATE: Self = Self(4);
    pub const INCIDENT: Self = Self(8);
    pub const TREASURE: Self = Self(16);
    pub const SHOP: Self = Self(32);
    pub const SACRIFICE: Self = Self(64);
    pub const ENTERTAINMENT: Self = Self(128);
    pub const MARKET: Self = Self(256);
    pub const BATTLE_HARD: Self = Self(512);
    pub const BATTLES: Self = Self(514);
    pub const INCIDENT_BOSS: Self = Self(1024);
    pub const INCIDENT_BOSS_ONLY: Self = Self(2048);
    pub const CHOICES: Self = Self(3548);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3548;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ORIGIN,
        Self::BATTLE,
        Self::TRIAL_GATE,
        Self::INCIDENT,
        Self::TREASURE,
        Self::SHOP,
        Self::SACRIFICE,
        Self::ENTERTAINMENT,
        Self::MARKET,
        Self::BATTLE_HARD,
        Self::BATTLES,
        Self::INCIDENT_BOSS,
        Self::INCIDENT_BOSS_ONLY,
        Self::CHOICES,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ORIGIN => Some("ORIGIN"),
            Self::BATTLE => Some("BATTLE"),
            Self::TRIAL_GATE => Some("TRIAL_GATE"),
            Self::INCIDENT => Some("INCIDENT"),
            Self::TREASURE => Some("TREASURE"),
            Self::SHOP => Some("SHOP"),
            Self::SACRIFICE => Some("SACRIFICE"),
            Self::ENTERTAINMENT => Some("ENTERTAINMENT"),
            Self::MARKET => Some("MARKET"),
            Self::BATTLE_HARD => Some("BATTLE_HARD"),
            Self::BATTLES => Some("BATTLES"),
            Self::INCIDENT_BOSS => Some("INCIDENT_BOSS"),
            Self::INCIDENT_BOSS_ONLY => Some("INCIDENT_BOSS_ONLY"),
            Self::CHOICES => Some("CHOICES"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeSkyZoneNodeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeSkyZoneNodeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeSkyZoneNodeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeSkyZoneNodeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeSkyZoneNodeType {
    type Output = enum__Torappu_RoguelikeSkyZoneNodeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeSkyZoneNodeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeSkyZoneNodeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeSkyZoneNodeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_TOPIC_DEV_NODE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_TOPIC_DEV_NODE_TYPE: i32 = 10;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_TOPIC_DEV_NODE_TYPE:
    [enum__Torappu_RoguelikeTopicDevNodeType; 3] = [
    enum__Torappu_RoguelikeTopicDevNodeType::BRANCH,
    enum__Torappu_RoguelikeTopicDevNodeType::KEY,
    enum__Torappu_RoguelikeTopicDevNodeType::NONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeTopicDevNodeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeTopicDevNodeType {
    pub const BRANCH: Self = Self(0);
    pub const KEY: Self = Self(1);
    pub const NONE: Self = Self(10);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 10;
    pub const ENUM_VALUES: &'static [Self] = &[Self::BRANCH, Self::KEY, Self::NONE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::BRANCH => Some("BRANCH"),
            Self::KEY => Some("KEY"),
            Self::NONE => Some("NONE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeTopicDevNodeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeTopicDevNodeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeTopicDevNodeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeTopicDevNodeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeTopicDevNodeType {
    type Output = enum__Torappu_RoguelikeTopicDevNodeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeTopicDevNodeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeTopicDevNodeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeTopicDevNodeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_TOPIC_DEV_TOKEN_DISPLAY_FORM: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_TOPIC_DEV_TOKEN_DISPLAY_FORM: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_TOPIC_DEV_TOKEN_DISPLAY_FORM:
    [enum__Torappu_RoguelikeTopicDevTokenDisplayForm; 2] = [
    enum__Torappu_RoguelikeTopicDevTokenDisplayForm::ABSOLUTE_VAL,
    enum__Torappu_RoguelikeTopicDevTokenDisplayForm::PERCENTAGE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeTopicDevTokenDisplayForm(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeTopicDevTokenDisplayForm {
    pub const ABSOLUTE_VAL: Self = Self(0);
    pub const PERCENTAGE: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::ABSOLUTE_VAL, Self::PERCENTAGE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ABSOLUTE_VAL => Some("ABSOLUTE_VAL"),
            Self::PERCENTAGE => Some("PERCENTAGE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeTopicDevTokenDisplayForm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeTopicDevTokenDisplayForm {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeTopicDevTokenDisplayForm",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeTopicDevTokenDisplayForm {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeTopicDevTokenDisplayForm {
    type Output = enum__Torappu_RoguelikeTopicDevTokenDisplayForm;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeTopicDevTokenDisplayForm {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeTopicDevTokenDisplayForm {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeTopicDevTokenDisplayForm {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_RL_02_DEVELOPMENT_NODE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_RL_02_DEVELOPMENT_NODE_TYPE: i32 = 5;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_RL_02_DEVELOPMENT_NODE_TYPE:
    [enum__Torappu_RL02DevelopmentNodeType; 6] = [
    enum__Torappu_RL02DevelopmentNodeType::NONE,
    enum__Torappu_RL02DevelopmentNodeType::SMALL,
    enum__Torappu_RL02DevelopmentNodeType::NORMAL,
    enum__Torappu_RL02DevelopmentNodeType::LARGE_RHODES,
    enum__Torappu_RL02DevelopmentNodeType::LARGE_ABYSSAL,
    enum__Torappu_RL02DevelopmentNodeType::LARGE_IBERIA,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RL02DevelopmentNodeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RL02DevelopmentNodeType {
    pub const NONE: Self = Self(0);
    pub const SMALL: Self = Self(1);
    pub const NORMAL: Self = Self(2);
    pub const LARGE_RHODES: Self = Self(3);
    pub const LARGE_ABYSSAL: Self = Self(4);
    pub const LARGE_IBERIA: Self = Self(5);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 5;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::SMALL,
        Self::NORMAL,
        Self::LARGE_RHODES,
        Self::LARGE_ABYSSAL,
        Self::LARGE_IBERIA,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SMALL => Some("SMALL"),
            Self::NORMAL => Some("NORMAL"),
            Self::LARGE_RHODES => Some("LARGE_RHODES"),
            Self::LARGE_ABYSSAL => Some("LARGE_ABYSSAL"),
            Self::LARGE_IBERIA => Some("LARGE_IBERIA"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RL02DevelopmentNodeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RL02DevelopmentNodeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RL02DevelopmentNodeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RL02DevelopmentNodeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RL02DevelopmentNodeType {
    type Output = enum__Torappu_RL02DevelopmentNodeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RL02DevelopmentNodeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RL02DevelopmentNodeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RL02DevelopmentNodeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_RL_02_DEVELOPMENT_EFFECT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_RL_02_DEVELOPMENT_EFFECT_TYPE: i32 = 10;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_RL_02_DEVELOPMENT_EFFECT_TYPE:
    [enum__Torappu_RL02DevelopmentEffectType; 4] = [
    enum__Torappu_RL02DevelopmentEffectType::BUFF,
    enum__Torappu_RL02DevelopmentEffectType::RAW_TEXT_EFFECT,
    enum__Torappu_RL02DevelopmentEffectType::RAW_TEXT_BAND,
    enum__Torappu_RL02DevelopmentEffectType::NONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RL02DevelopmentEffectType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RL02DevelopmentEffectType {
    pub const BUFF: Self = Self(0);
    pub const RAW_TEXT_EFFECT: Self = Self(1);
    pub const RAW_TEXT_BAND: Self = Self(2);
    pub const NONE: Self = Self(10);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 10;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::BUFF,
        Self::RAW_TEXT_EFFECT,
        Self::RAW_TEXT_BAND,
        Self::NONE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::BUFF => Some("BUFF"),
            Self::RAW_TEXT_EFFECT => Some("RAW_TEXT_EFFECT"),
            Self::RAW_TEXT_BAND => Some("RAW_TEXT_BAND"),
            Self::NONE => Some("NONE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RL02DevelopmentEffectType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RL02DevelopmentEffectType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RL02DevelopmentEffectType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RL02DevelopmentEffectType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RL02DevelopmentEffectType {
    type Output = enum__Torappu_RL02DevelopmentEffectType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RL02DevelopmentEffectType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RL02DevelopmentEffectType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RL02DevelopmentEffectType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_RL_03_DEVELOPMENT_NODE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_RL_03_DEVELOPMENT_NODE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_RL_03_DEVELOPMENT_NODE_TYPE:
    [enum__Torappu_RL03DevelopmentNodeType; 4] = [
    enum__Torappu_RL03DevelopmentNodeType::NONE,
    enum__Torappu_RL03DevelopmentNodeType::NORMAL,
    enum__Torappu_RL03DevelopmentNodeType::KEY,
    enum__Torappu_RL03DevelopmentNodeType::DIFFICULTY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RL03DevelopmentNodeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RL03DevelopmentNodeType {
    pub const NONE: Self = Self(0);
    pub const NORMAL: Self = Self(1);
    pub const KEY: Self = Self(2);
    pub const DIFFICULTY: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::NORMAL, Self::KEY, Self::DIFFICULTY];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NORMAL => Some("NORMAL"),
            Self::KEY => Some("KEY"),
            Self::DIFFICULTY => Some("DIFFICULTY"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RL03DevelopmentNodeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RL03DevelopmentNodeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RL03DevelopmentNodeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RL03DevelopmentNodeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RL03DevelopmentNodeType {
    type Output = enum__Torappu_RL03DevelopmentNodeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RL03DevelopmentNodeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RL03DevelopmentNodeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RL03DevelopmentNodeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_RL_03_DEVELOPMENT_EFFECT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_RL_03_DEVELOPMENT_EFFECT_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_RL_03_DEVELOPMENT_EFFECT_TYPE:
    [enum__Torappu_RL03DevelopmentEffectType; 3] = [
    enum__Torappu_RL03DevelopmentEffectType::BUFF,
    enum__Torappu_RL03DevelopmentEffectType::RAW_TEXT_EFFECT,
    enum__Torappu_RL03DevelopmentEffectType::RAW_TEXT_BAND,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RL03DevelopmentEffectType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RL03DevelopmentEffectType {
    pub const BUFF: Self = Self(0);
    pub const RAW_TEXT_EFFECT: Self = Self(1);
    pub const RAW_TEXT_BAND: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::BUFF, Self::RAW_TEXT_EFFECT, Self::RAW_TEXT_BAND];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::BUFF => Some("BUFF"),
            Self::RAW_TEXT_EFFECT => Some("RAW_TEXT_EFFECT"),
            Self::RAW_TEXT_BAND => Some("RAW_TEXT_BAND"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RL03DevelopmentEffectType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RL03DevelopmentEffectType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RL03DevelopmentEffectType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RL03DevelopmentEffectType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RL03DevelopmentEffectType {
    type Output = enum__Torappu_RL03DevelopmentEffectType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RL03DevelopmentEffectType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RL03DevelopmentEffectType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RL03DevelopmentEffectType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_COMMON_DEVELOPMENT_NODE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_COMMON_DEVELOPMENT_NODE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_COMMON_DEVELOPMENT_NODE_TYPE:
    [enum__Torappu_RoguelikeCommonDevelopmentNodeType; 4] = [
    enum__Torappu_RoguelikeCommonDevelopmentNodeType::NONE,
    enum__Torappu_RoguelikeCommonDevelopmentNodeType::NORMAL,
    enum__Torappu_RoguelikeCommonDevelopmentNodeType::KEY,
    enum__Torappu_RoguelikeCommonDevelopmentNodeType::DIFFICULTY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeCommonDevelopmentNodeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeCommonDevelopmentNodeType {
    pub const NONE: Self = Self(0);
    pub const NORMAL: Self = Self(1);
    pub const KEY: Self = Self(2);
    pub const DIFFICULTY: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::NORMAL, Self::KEY, Self::DIFFICULTY];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NORMAL => Some("NORMAL"),
            Self::KEY => Some("KEY"),
            Self::DIFFICULTY => Some("DIFFICULTY"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeCommonDevelopmentNodeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeCommonDevelopmentNodeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeCommonDevelopmentNodeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeCommonDevelopmentNodeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeCommonDevelopmentNodeType {
    type Output = enum__Torappu_RoguelikeCommonDevelopmentNodeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeCommonDevelopmentNodeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeCommonDevelopmentNodeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeCommonDevelopmentNodeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ROGUELIKE_COMMON_DEVELOPMENT_EFFECT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ROGUELIKE_COMMON_DEVELOPMENT_EFFECT_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ROGUELIKE_COMMON_DEVELOPMENT_EFFECT_TYPE:
    [enum__Torappu_RoguelikeCommonDevelopmentEffectType; 3] = [
    enum__Torappu_RoguelikeCommonDevelopmentEffectType::BUFF,
    enum__Torappu_RoguelikeCommonDevelopmentEffectType::RAW_TEXT_EFFECT,
    enum__Torappu_RoguelikeCommonDevelopmentEffectType::RAW_TEXT_BAND,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RoguelikeCommonDevelopmentEffectType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RoguelikeCommonDevelopmentEffectType {
    pub const BUFF: Self = Self(0);
    pub const RAW_TEXT_EFFECT: Self = Self(1);
    pub const RAW_TEXT_BAND: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::BUFF, Self::RAW_TEXT_EFFECT, Self::RAW_TEXT_BAND];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::BUFF => Some("BUFF"),
            Self::RAW_TEXT_EFFECT => Some("RAW_TEXT_EFFECT"),
            Self::RAW_TEXT_BAND => Some("RAW_TEXT_BAND"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RoguelikeCommonDevelopmentEffectType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RoguelikeCommonDevelopmentEffectType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RoguelikeCommonDevelopmentEffectType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RoguelikeCommonDevelopmentEffectType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RoguelikeCommonDevelopmentEffectType {
    type Output = enum__Torappu_RoguelikeCommonDevelopmentEffectType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RoguelikeCommonDevelopmentEffectType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RoguelikeCommonDevelopmentEffectType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RoguelikeCommonDevelopmentEffectType {}
pub enum clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData<'a> {
    type Inner = clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData<'a> {
    pub const VT_TOPICID: flatbuffers::VOffsetT = 4;
    pub const VT_DISPLAYID: flatbuffers::VOffsetT = 6;
    pub const VT_STARTTS: flatbuffers::VOffsetT = 8;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData<'bldr>>
    {
        let mut builder =
            clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        if let Some(x) = args.displayId {
            builder.add_displayId(x);
        }
        if let Some(x) = args.topicId {
            builder.add_topicId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataT {
        let topicId = self.topicId().map(|x| x.to_string());
        let displayId = self.displayId().map(|x| x.to_string());
        let startTs = self.startTs();
        let endTs = self.endTs();
        clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataT {
            topicId,
            displayId,
            startTs,
            endTs,
        }
    }

    #[inline]
    pub fn topicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData::VT_TOPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn displayId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData::VT_DISPLAYID,
                None,
            )
        }
    }
    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData::VT_STARTTS,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData::VT_ENDTS,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("topicId", Self::VT_TOPICID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "displayId",
                Self::VT_DISPLAYID,
                false,
            )?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataArgs<'a> {
    pub topicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub displayId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTs: i64,
    pub endTs: i64,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataArgs {
            topicId: None,
            displayId: None,
            startTs: 0,
            endTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData",
            4,
        )?;
        if let Some(f) = self.topicId() {
            s.serialize_field("topicId", &f)?;
        } else {
            s.skip_field("topicId")?;
        }
        if let Some(f) = self.displayId() {
            s.serialize_field("displayId", &f)?;
        } else {
            s.skip_field("displayId")?;
        }
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_topicId(&mut self, topicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData::VT_TOPICID,
            topicId,
        );
    }
    #[inline]
    pub fn add_displayId(&mut self, displayId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData::VT_DISPLAYID,
            displayId,
        );
    }
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData::VT_STARTTS,
            startTs,
            0,
        );
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData::VT_ENDTS,
            endTs,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData");
        ds.field("topicId", &self.topicId());
        ds.field("displayId", &self.displayId());
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataT {
    pub topicId: Option<String>,
    pub displayId: Option<String>,
    pub startTs: i64,
    pub endTs: i64,
}
impl Default for clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataT {
    fn default() -> Self {
        Self {
            topicId: None,
            displayId: None,
            startTs: 0,
            endTs: 0,
        }
    }
}
impl clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData<'b>> {
        let topicId = self.topicId.as_ref().map(|x| _fbb.create_string(x));
        let displayId = self.displayId.as_ref().map(|x| _fbb.create_string(x));
        let startTs = self.startTs;
        let endTs = self.endTs;
        clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataArgs {
                topicId,
                displayId,
                startTs,
                endTs,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicConfig<'a> {
    type Inner = clz_Torappu_RoguelikeTopicConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicConfig<'a> {
    pub const VT_LOADCHARCARDPLUGIN: flatbuffers::VOffsetT = 4;
    pub const VT_WEBBUSTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_MONTHCHATTRIGTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_LOADREWARDHPDECOPLUGIN: flatbuffers::VOffsetT = 10;
    pub const VT_LOADREWARDEXTRAINFOPLUGIN: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicConfigArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConfig<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicConfigBuilder::new(_fbb);
        builder.add_monthChatTrigType(args.monthChatTrigType);
        if let Some(x) = args.webBusType {
            builder.add_webBusType(x);
        }
        builder.add_loadRewardExtraInfoPlugin(args.loadRewardExtraInfoPlugin);
        builder.add_loadRewardHpDecoPlugin(args.loadRewardHpDecoPlugin);
        builder.add_loadCharCardPlugin(args.loadCharCardPlugin);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicConfigT {
        let loadCharCardPlugin = self.loadCharCardPlugin();
        let webBusType = self.webBusType().map(|x| x.to_string());
        let monthChatTrigType = self.monthChatTrigType();
        let loadRewardHpDecoPlugin = self.loadRewardHpDecoPlugin();
        let loadRewardExtraInfoPlugin = self.loadRewardExtraInfoPlugin();
        clz_Torappu_RoguelikeTopicConfigT {
            loadCharCardPlugin,
            webBusType,
            monthChatTrigType,
            loadRewardHpDecoPlugin,
            loadRewardExtraInfoPlugin,
        }
    }

    #[inline]
    pub fn loadCharCardPlugin(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeTopicConfig::VT_LOADCHARCARDPLUGIN,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn webBusType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicConfig::VT_WEBBUSTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn monthChatTrigType(&self) -> enum__Torappu_RoguelikeMonthChatTrigType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeMonthChatTrigType>(
                    clz_Torappu_RoguelikeTopicConfig::VT_MONTHCHATTRIGTYPE,
                    Some(enum__Torappu_RoguelikeMonthChatTrigType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn loadRewardHpDecoPlugin(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeTopicConfig::VT_LOADREWARDHPDECOPLUGIN,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn loadRewardExtraInfoPlugin(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeTopicConfig::VT_LOADREWARDEXTRAINFOPLUGIN,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("loadCharCardPlugin", Self::VT_LOADCHARCARDPLUGIN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "webBusType",
                Self::VT_WEBBUSTYPE,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeMonthChatTrigType>(
                "monthChatTrigType",
                Self::VT_MONTHCHATTRIGTYPE,
                false,
            )?
            .visit_field::<bool>(
                "loadRewardHpDecoPlugin",
                Self::VT_LOADREWARDHPDECOPLUGIN,
                false,
            )?
            .visit_field::<bool>(
                "loadRewardExtraInfoPlugin",
                Self::VT_LOADREWARDEXTRAINFOPLUGIN,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicConfigArgs<'a> {
    pub loadCharCardPlugin: bool,
    pub webBusType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthChatTrigType: enum__Torappu_RoguelikeMonthChatTrigType,
    pub loadRewardHpDecoPlugin: bool,
    pub loadRewardExtraInfoPlugin: bool,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicConfigArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicConfigArgs {
            loadCharCardPlugin: false,
            webBusType: None,
            monthChatTrigType: enum__Torappu_RoguelikeMonthChatTrigType::NONE,
            loadRewardHpDecoPlugin: false,
            loadRewardExtraInfoPlugin: false,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicConfig<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicConfig", 5)?;
        s.serialize_field("loadCharCardPlugin", &self.loadCharCardPlugin())?;
        if let Some(f) = self.webBusType() {
            s.serialize_field("webBusType", &f)?;
        } else {
            s.skip_field("webBusType")?;
        }
        s.serialize_field("monthChatTrigType", &self.monthChatTrigType())?;
        s.serialize_field("loadRewardHpDecoPlugin", &self.loadRewardHpDecoPlugin())?;
        s.serialize_field(
            "loadRewardExtraInfoPlugin",
            &self.loadRewardExtraInfoPlugin(),
        )?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_loadCharCardPlugin(&mut self, loadCharCardPlugin: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeTopicConfig::VT_LOADCHARCARDPLUGIN,
            loadCharCardPlugin,
            false,
        );
    }
    #[inline]
    pub fn add_webBusType(&mut self, webBusType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicConfig::VT_WEBBUSTYPE,
            webBusType,
        );
    }
    #[inline]
    pub fn add_monthChatTrigType(
        &mut self,
        monthChatTrigType: enum__Torappu_RoguelikeMonthChatTrigType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeMonthChatTrigType>(
                clz_Torappu_RoguelikeTopicConfig::VT_MONTHCHATTRIGTYPE,
                monthChatTrigType,
                enum__Torappu_RoguelikeMonthChatTrigType::NONE,
            );
    }
    #[inline]
    pub fn add_loadRewardHpDecoPlugin(&mut self, loadRewardHpDecoPlugin: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeTopicConfig::VT_LOADREWARDHPDECOPLUGIN,
            loadRewardHpDecoPlugin,
            false,
        );
    }
    #[inline]
    pub fn add_loadRewardExtraInfoPlugin(&mut self, loadRewardExtraInfoPlugin: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeTopicConfig::VT_LOADREWARDEXTRAINFOPLUGIN,
            loadRewardExtraInfoPlugin,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicConfig");
        ds.field("loadCharCardPlugin", &self.loadCharCardPlugin());
        ds.field("webBusType", &self.webBusType());
        ds.field("monthChatTrigType", &self.monthChatTrigType());
        ds.field("loadRewardHpDecoPlugin", &self.loadRewardHpDecoPlugin());
        ds.field(
            "loadRewardExtraInfoPlugin",
            &self.loadRewardExtraInfoPlugin(),
        );
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicConfigT {
    pub loadCharCardPlugin: bool,
    pub webBusType: Option<String>,
    pub monthChatTrigType: enum__Torappu_RoguelikeMonthChatTrigType,
    pub loadRewardHpDecoPlugin: bool,
    pub loadRewardExtraInfoPlugin: bool,
}
impl Default for clz_Torappu_RoguelikeTopicConfigT {
    fn default() -> Self {
        Self {
            loadCharCardPlugin: false,
            webBusType: None,
            monthChatTrigType: enum__Torappu_RoguelikeMonthChatTrigType::NONE,
            loadRewardHpDecoPlugin: false,
            loadRewardExtraInfoPlugin: false,
        }
    }
}
impl clz_Torappu_RoguelikeTopicConfigT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConfig<'b>> {
        let loadCharCardPlugin = self.loadCharCardPlugin;
        let webBusType = self.webBusType.as_ref().map(|x| _fbb.create_string(x));
        let monthChatTrigType = self.monthChatTrigType;
        let loadRewardHpDecoPlugin = self.loadRewardHpDecoPlugin;
        let loadRewardExtraInfoPlugin = self.loadRewardExtraInfoPlugin;
        clz_Torappu_RoguelikeTopicConfig::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicConfigArgs {
                loadCharCardPlugin,
                webBusType,
                monthChatTrigType,
                loadRewardHpDecoPlugin,
                loadRewardExtraInfoPlugin,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicBasicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicBasicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicBasicData<'a> {
    type Inner = clz_Torappu_RoguelikeTopicBasicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicBasicData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 8;
    pub const VT_DISAPPEARTIMEONMAINSCREEN: flatbuffers::VOffsetT = 10;
    pub const VT_SORT: flatbuffers::VOffsetT = 12;
    pub const VT_SHOWMEDALID: flatbuffers::VOffsetT = 14;
    pub const VT_MEDALGROUPID: flatbuffers::VOffsetT = 16;
    pub const VT_FULLSTOREDTIME: flatbuffers::VOffsetT = 18;
    pub const VT_LINETEXT: flatbuffers::VOffsetT = 20;
    pub const VT_HOMEENTRYDISPLAYDATA: flatbuffers::VOffsetT = 22;
    pub const VT_MODULETYPES: flatbuffers::VOffsetT = 24;
    pub const VT_CONFIG: flatbuffers::VOffsetT = 26;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicBasicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicBasicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBasicData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicBasicDataBuilder::new(_fbb);
        builder.add_fullStoredTime(args.fullStoredTime);
        builder.add_disappearTimeOnMainScreen(args.disappearTimeOnMainScreen);
        builder.add_startTime(args.startTime);
        if let Some(x) = args.config {
            builder.add_config(x);
        }
        if let Some(x) = args.moduleTypes {
            builder.add_moduleTypes(x);
        }
        if let Some(x) = args.homeEntryDisplayData {
            builder.add_homeEntryDisplayData(x);
        }
        if let Some(x) = args.lineText {
            builder.add_lineText(x);
        }
        if let Some(x) = args.medalGroupId {
            builder.add_medalGroupId(x);
        }
        if let Some(x) = args.showMedalId {
            builder.add_showMedalId(x);
        }
        builder.add_sort(args.sort);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicBasicDataT {
        let id = self.id().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let startTime = self.startTime();
        let disappearTimeOnMainScreen = self.disappearTimeOnMainScreen();
        let sort = self.sort();
        let showMedalId = self.showMedalId().map(|x| x.to_string());
        let medalGroupId = self.medalGroupId().map(|x| x.to_string());
        let fullStoredTime = self.fullStoredTime();
        let lineText = self.lineText().map(|x| x.to_string());
        let homeEntryDisplayData = self
            .homeEntryDisplayData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let moduleTypes = self.moduleTypes().map(|x| x.into_iter().collect());
        let config = self.config().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeTopicBasicDataT {
            id,
            name,
            startTime,
            disappearTimeOnMainScreen,
            sort,
            showMedalId,
            medalGroupId,
            fullStoredTime,
            lineText,
            homeEntryDisplayData,
            moduleTypes,
            config,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBasicData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBasicData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_RoguelikeTopicBasicData::VT_STARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn disappearTimeOnMainScreen(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_RoguelikeTopicBasicData::VT_DISAPPEARTIMEONMAINSCREEN,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sort(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicBasicData::VT_SORT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn showMedalId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBasicData::VT_SHOWMEDALID,
                None,
            )
        }
    }
    #[inline]
    pub fn medalGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBasicData::VT_MEDALGROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn fullStoredTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_RoguelikeTopicBasicData::VT_FULLSTOREDTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn lineText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBasicData::VT_LINETEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn homeEntryDisplayData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeTopicBasicData::VT_HOMEENTRYDISPLAYDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn moduleTypes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_RoguelikeModuleType>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_RoguelikeModuleType>,
            >>(clz_Torappu_RoguelikeTopicBasicData::VT_MODULETYPES, None)
        }
    }
    #[inline]
    pub fn config(&self) -> Option<clz_Torappu_RoguelikeTopicConfig<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicConfig>>(
                    clz_Torappu_RoguelikeTopicBasicData::VT_CONFIG,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicBasicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<i64>(
                "disappearTimeOnMainScreen",
                Self::VT_DISAPPEARTIMEONMAINSCREEN,
                false,
            )?
            .visit_field::<i32>("sort", Self::VT_SORT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "showMedalId",
                Self::VT_SHOWMEDALID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "medalGroupId",
                Self::VT_MEDALGROUPID,
                false,
            )?
            .visit_field::<i64>("fullStoredTime", Self::VT_FULLSTOREDTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "lineText",
                Self::VT_LINETEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData,
                    >,
                >,
            >>("homeEntryDisplayData", Self::VT_HOMEENTRYDISPLAYDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, enum__Torappu_RoguelikeModuleType>,
            >>("moduleTypes", Self::VT_MODULETYPES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicConfig>>(
                "config",
                Self::VT_CONFIG,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicBasicDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub startTime: i64,
    pub disappearTimeOnMainScreen: i64,
    pub sort: i32,
    pub showMedalId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub medalGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fullStoredTime: i64,
    pub lineText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub homeEntryDisplayData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData<'a>,
                >,
            >,
        >,
    >,
    pub moduleTypes:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_RoguelikeModuleType>>>,
    pub config: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConfig<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicBasicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicBasicDataArgs {
            id: None,
            name: None,
            startTime: 0,
            disappearTimeOnMainScreen: 0,
            sort: 0,
            showMedalId: None,
            medalGroupId: None,
            fullStoredTime: 0,
            lineText: None,
            homeEntryDisplayData: None,
            moduleTypes: None,
            config: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicBasicData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicBasicData", 12)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        s.serialize_field("startTime", &self.startTime())?;
        s.serialize_field(
            "disappearTimeOnMainScreen",
            &self.disappearTimeOnMainScreen(),
        )?;
        s.serialize_field("sort", &self.sort())?;
        if let Some(f) = self.showMedalId() {
            s.serialize_field("showMedalId", &f)?;
        } else {
            s.skip_field("showMedalId")?;
        }
        if let Some(f) = self.medalGroupId() {
            s.serialize_field("medalGroupId", &f)?;
        } else {
            s.skip_field("medalGroupId")?;
        }
        s.serialize_field("fullStoredTime", &self.fullStoredTime())?;
        if let Some(f) = self.lineText() {
            s.serialize_field("lineText", &f)?;
        } else {
            s.skip_field("lineText")?;
        }
        if let Some(f) = self.homeEntryDisplayData() {
            s.serialize_field("homeEntryDisplayData", &f)?;
        } else {
            s.skip_field("homeEntryDisplayData")?;
        }
        if let Some(f) = self.moduleTypes() {
            s.serialize_field("moduleTypes", &f)?;
        } else {
            s.skip_field("moduleTypes")?;
        }
        if let Some(f) = self.config() {
            s.serialize_field("config", &f)?;
        } else {
            s.skip_field("config")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicBasicDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicBasicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBasicData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBasicData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeTopicBasicData::VT_STARTTIME,
            startTime,
            0,
        );
    }
    #[inline]
    pub fn add_disappearTimeOnMainScreen(&mut self, disappearTimeOnMainScreen: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeTopicBasicData::VT_DISAPPEARTIMEONMAINSCREEN,
            disappearTimeOnMainScreen,
            0,
        );
    }
    #[inline]
    pub fn add_sort(&mut self, sort: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeTopicBasicData::VT_SORT, sort, 0);
    }
    #[inline]
    pub fn add_showMedalId(&mut self, showMedalId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBasicData::VT_SHOWMEDALID,
            showMedalId,
        );
    }
    #[inline]
    pub fn add_medalGroupId(&mut self, medalGroupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBasicData::VT_MEDALGROUPID,
            medalGroupId,
        );
    }
    #[inline]
    pub fn add_fullStoredTime(&mut self, fullStoredTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeTopicBasicData::VT_FULLSTOREDTIME,
            fullStoredTime,
            0,
        );
    }
    #[inline]
    pub fn add_lineText(&mut self, lineText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBasicData::VT_LINETEXT,
            lineText,
        );
    }
    #[inline]
    pub fn add_homeEntryDisplayData(
        &mut self,
        homeEntryDisplayData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBasicData::VT_HOMEENTRYDISPLAYDATA,
            homeEntryDisplayData,
        );
    }
    #[inline]
    pub fn add_moduleTypes(
        &mut self,
        moduleTypes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_RoguelikeModuleType>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBasicData::VT_MODULETYPES,
            moduleTypes,
        );
    }
    #[inline]
    pub fn add_config(
        &mut self,
        config: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConfig<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConfig>>(
                clz_Torappu_RoguelikeTopicBasicData::VT_CONFIG,
                config,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicBasicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicBasicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBasicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicBasicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicBasicData");
        ds.field("id", &self.id());
        ds.field("name", &self.name());
        ds.field("startTime", &self.startTime());
        ds.field(
            "disappearTimeOnMainScreen",
            &self.disappearTimeOnMainScreen(),
        );
        ds.field("sort", &self.sort());
        ds.field("showMedalId", &self.showMedalId());
        ds.field("medalGroupId", &self.medalGroupId());
        ds.field("fullStoredTime", &self.fullStoredTime());
        ds.field("lineText", &self.lineText());
        ds.field("homeEntryDisplayData", &self.homeEntryDisplayData());
        ds.field("moduleTypes", &self.moduleTypes());
        ds.field("config", &self.config());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicBasicDataT {
    pub id: Option<String>,
    pub name: Option<String>,
    pub startTime: i64,
    pub disappearTimeOnMainScreen: i64,
    pub sort: i32,
    pub showMedalId: Option<String>,
    pub medalGroupId: Option<String>,
    pub fullStoredTime: i64,
    pub lineText: Option<String>,
    pub homeEntryDisplayData:
        Option<Vec<clz_Torappu_RoguelikeTopicBasicData_HomeEntryDisplayDataT>>,
    pub moduleTypes: Option<Vec<enum__Torappu_RoguelikeModuleType>>,
    pub config: Option<Box<clz_Torappu_RoguelikeTopicConfigT>>,
}
impl Default for clz_Torappu_RoguelikeTopicBasicDataT {
    fn default() -> Self {
        Self {
            id: None,
            name: None,
            startTime: 0,
            disappearTimeOnMainScreen: 0,
            sort: 0,
            showMedalId: None,
            medalGroupId: None,
            fullStoredTime: 0,
            lineText: None,
            homeEntryDisplayData: None,
            moduleTypes: None,
            config: None,
        }
    }
}
impl clz_Torappu_RoguelikeTopicBasicDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBasicData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let startTime = self.startTime;
        let disappearTimeOnMainScreen = self.disappearTimeOnMainScreen;
        let sort = self.sort;
        let showMedalId = self.showMedalId.as_ref().map(|x| _fbb.create_string(x));
        let medalGroupId = self.medalGroupId.as_ref().map(|x| _fbb.create_string(x));
        let fullStoredTime = self.fullStoredTime;
        let lineText = self.lineText.as_ref().map(|x| _fbb.create_string(x));
        let homeEntryDisplayData = self.homeEntryDisplayData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let moduleTypes = self.moduleTypes.as_ref().map(|x| _fbb.create_vector(x));
        let config = self.config.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeTopicBasicData::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicBasicDataArgs {
                id,
                name,
                startTime,
                disappearTimeOnMainScreen,
                sort,
                showMedalId,
                medalGroupId,
                fullStoredTime,
                lineText,
                homeEntryDisplayData,
                moduleTypes,
                config,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeTopicBasicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeTopicBasicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeTopicBasicData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeTopicBasicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeTopicBasicData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeTopicBasicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeTopicBasicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicBasicData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeTopicBasicDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeTopicBasicDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeTopicBasicDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeTopicBasicData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeTopicBasicData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeTopicBasicData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBasicData>>(
                    dict__string__clz_Torappu_RoguelikeTopicBasicData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeTopicBasicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBasicData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeTopicBasicDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBasicData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeTopicBasicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeTopicBasicDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeTopicBasicData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeTopicBasicData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeTopicBasicDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeTopicBasicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeTopicBasicData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBasicData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBasicData>>(
                dict__string__clz_Torappu_RoguelikeTopicBasicData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeTopicBasicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeTopicBasicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicBasicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeTopicBasicData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeTopicBasicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeTopicBasicData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeTopicBasicDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeTopicBasicDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeTopicBasicDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeTopicBasicDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicBasicData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeTopicBasicData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeTopicBasicDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicConst_PredefinedCharOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicConst_PredefinedChar<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicConst_PredefinedChar<'a> {
    type Inner = clz_Torappu_RoguelikeTopicConst_PredefinedChar<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicConst_PredefinedChar<'a> {
    pub const VT_CHARID: flatbuffers::VOffsetT = 4;
    pub const VT_CANBEFREE: flatbuffers::VOffsetT = 6;
    pub const VT_UNIEQUIPID: flatbuffers::VOffsetT = 8;
    pub const VT_RECRUITTYPE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicConst_PredefinedChar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicConst_PredefinedCharArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConst_PredefinedChar<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicConst_PredefinedCharBuilder::new(_fbb);
        builder.add_recruitType(args.recruitType);
        if let Some(x) = args.uniEquipId {
            builder.add_uniEquipId(x);
        }
        if let Some(x) = args.charId {
            builder.add_charId(x);
        }
        builder.add_canBeFree(args.canBeFree);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicConst_PredefinedCharT {
        let charId = self.charId().map(|x| x.to_string());
        let canBeFree = self.canBeFree();
        let uniEquipId = self.uniEquipId().map(|x| x.to_string());
        let recruitType = self.recruitType();
        clz_Torappu_RoguelikeTopicConst_PredefinedCharT {
            charId,
            canBeFree,
            uniEquipId,
            recruitType,
        }
    }

    #[inline]
    pub fn charId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicConst_PredefinedChar::VT_CHARID,
                None,
            )
        }
    }
    #[inline]
    pub fn canBeFree(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeTopicConst_PredefinedChar::VT_CANBEFREE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn uniEquipId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicConst_PredefinedChar::VT_UNIEQUIPID,
                None,
            )
        }
    }
    #[inline]
    pub fn recruitType(&self) -> enum__Torappu_RoguelikeCharState {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeCharState>(
                    clz_Torappu_RoguelikeTopicConst_PredefinedChar::VT_RECRUITTYPE,
                    Some(enum__Torappu_RoguelikeCharState::NORMAL),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicConst_PredefinedChar<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charId", Self::VT_CHARID, false)?
            .visit_field::<bool>("canBeFree", Self::VT_CANBEFREE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "uniEquipId",
                Self::VT_UNIEQUIPID,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeCharState>(
                "recruitType",
                Self::VT_RECRUITTYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicConst_PredefinedCharArgs<'a> {
    pub charId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub canBeFree: bool,
    pub uniEquipId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recruitType: enum__Torappu_RoguelikeCharState,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicConst_PredefinedCharArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicConst_PredefinedCharArgs {
            charId: None,
            canBeFree: false,
            uniEquipId: None,
            recruitType: enum__Torappu_RoguelikeCharState::NORMAL,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicConst_PredefinedChar<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeTopicConst_PredefinedChar", 4)?;
        if let Some(f) = self.charId() {
            s.serialize_field("charId", &f)?;
        } else {
            s.skip_field("charId")?;
        }
        s.serialize_field("canBeFree", &self.canBeFree())?;
        if let Some(f) = self.uniEquipId() {
            s.serialize_field("uniEquipId", &f)?;
        } else {
            s.skip_field("uniEquipId")?;
        }
        s.serialize_field("recruitType", &self.recruitType())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicConst_PredefinedCharBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicConst_PredefinedCharBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_charId(&mut self, charId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicConst_PredefinedChar::VT_CHARID,
            charId,
        );
    }
    #[inline]
    pub fn add_canBeFree(&mut self, canBeFree: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeTopicConst_PredefinedChar::VT_CANBEFREE,
            canBeFree,
            false,
        );
    }
    #[inline]
    pub fn add_uniEquipId(&mut self, uniEquipId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicConst_PredefinedChar::VT_UNIEQUIPID,
            uniEquipId,
        );
    }
    #[inline]
    pub fn add_recruitType(&mut self, recruitType: enum__Torappu_RoguelikeCharState) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeCharState>(
            clz_Torappu_RoguelikeTopicConst_PredefinedChar::VT_RECRUITTYPE,
            recruitType,
            enum__Torappu_RoguelikeCharState::NORMAL,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicConst_PredefinedCharBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicConst_PredefinedCharBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConst_PredefinedChar<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicConst_PredefinedChar<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicConst_PredefinedChar");
        ds.field("charId", &self.charId());
        ds.field("canBeFree", &self.canBeFree());
        ds.field("uniEquipId", &self.uniEquipId());
        ds.field("recruitType", &self.recruitType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicConst_PredefinedCharT {
    pub charId: Option<String>,
    pub canBeFree: bool,
    pub uniEquipId: Option<String>,
    pub recruitType: enum__Torappu_RoguelikeCharState,
}
impl Default for clz_Torappu_RoguelikeTopicConst_PredefinedCharT {
    fn default() -> Self {
        Self {
            charId: None,
            canBeFree: false,
            uniEquipId: None,
            recruitType: enum__Torappu_RoguelikeCharState::NORMAL,
        }
    }
}
impl clz_Torappu_RoguelikeTopicConst_PredefinedCharT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConst_PredefinedChar<'b>> {
        let charId = self.charId.as_ref().map(|x| _fbb.create_string(x));
        let canBeFree = self.canBeFree;
        let uniEquipId = self.uniEquipId.as_ref().map(|x| _fbb.create_string(x));
        let recruitType = self.recruitType;
        clz_Torappu_RoguelikeTopicConst_PredefinedChar::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicConst_PredefinedCharArgs {
                charId,
                canBeFree,
                uniEquipId,
                recruitType,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar<'a>
{
    type Inner = dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeTopicConst_PredefinedChar<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicConst_PredefinedChar>>(dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicConst_PredefinedChar>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConst_PredefinedChar<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConst_PredefinedChar<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConst_PredefinedChar>>(dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeTopicConst_PredefinedCharT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicConst<'a> {
    type Inner = clz_Torappu_RoguelikeTopicConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicConst<'a> {
    pub const VT_MILESTONETOKENRATIO: flatbuffers::VOffsetT = 4;
    pub const VT_OUTERBUFFTOKENRATIO: flatbuffers::VOffsetT = 6;
    pub const VT_RELICTOKENRATIO: flatbuffers::VOffsetT = 8;
    pub const VT_ROGUESYSTEMUNLOCKSTAGE: flatbuffers::VOffsetT = 10;
    pub const VT_ORDIMODEREOPENCOOLDOWN: flatbuffers::VOffsetT = 12;
    pub const VT_MONTHMODEREOPENCOOLDOWN: flatbuffers::VOffsetT = 14;
    pub const VT_MONTHLYTASKUNCOMPLETEDTIME: flatbuffers::VOffsetT = 16;
    pub const VT_MONTHLYTASKMANUALREFRESHLIMIT: flatbuffers::VOffsetT = 18;
    pub const VT_MONTHLYTEAMUNCOMPLETEDTIME: flatbuffers::VOffsetT = 20;
    pub const VT_BPPURCHASESYSTEMUNLOCKTIME: flatbuffers::VOffsetT = 22;
    pub const VT_PREDEFINEDCHARS: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicConstArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConst<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicConstBuilder::new(_fbb);
        builder.add_bpPurchaseSystemUnlockTime(args.bpPurchaseSystemUnlockTime);
        if let Some(x) = args.predefinedChars {
            builder.add_predefinedChars(x);
        }
        builder.add_monthlyTeamUncompletedTime(args.monthlyTeamUncompletedTime);
        builder.add_monthlyTaskManualRefreshLimit(args.monthlyTaskManualRefreshLimit);
        builder.add_monthlyTaskUncompletedTime(args.monthlyTaskUncompletedTime);
        builder.add_monthModeReOpenCoolDown(args.monthModeReOpenCoolDown);
        builder.add_ordiModeReOpenCoolDown(args.ordiModeReOpenCoolDown);
        if let Some(x) = args.rogueSystemUnlockStage {
            builder.add_rogueSystemUnlockStage(x);
        }
        builder.add_relicTokenRatio(args.relicTokenRatio);
        builder.add_outerBuffTokenRatio(args.outerBuffTokenRatio);
        builder.add_milestoneTokenRatio(args.milestoneTokenRatio);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicConstT {
        let milestoneTokenRatio = self.milestoneTokenRatio();
        let outerBuffTokenRatio = self.outerBuffTokenRatio();
        let relicTokenRatio = self.relicTokenRatio();
        let rogueSystemUnlockStage = self.rogueSystemUnlockStage().map(|x| x.to_string());
        let ordiModeReOpenCoolDown = self.ordiModeReOpenCoolDown();
        let monthModeReOpenCoolDown = self.monthModeReOpenCoolDown();
        let monthlyTaskUncompletedTime = self.monthlyTaskUncompletedTime();
        let monthlyTaskManualRefreshLimit = self.monthlyTaskManualRefreshLimit();
        let monthlyTeamUncompletedTime = self.monthlyTeamUncompletedTime();
        let bpPurchaseSystemUnlockTime = self.bpPurchaseSystemUnlockTime();
        let predefinedChars = self
            .predefinedChars()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeTopicConstT {
            milestoneTokenRatio,
            outerBuffTokenRatio,
            relicTokenRatio,
            rogueSystemUnlockStage,
            ordiModeReOpenCoolDown,
            monthModeReOpenCoolDown,
            monthlyTaskUncompletedTime,
            monthlyTaskManualRefreshLimit,
            monthlyTeamUncompletedTime,
            bpPurchaseSystemUnlockTime,
            predefinedChars,
        }
    }

    #[inline]
    pub fn milestoneTokenRatio(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicConst::VT_MILESTONETOKENRATIO,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn outerBuffTokenRatio(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_RoguelikeTopicConst::VT_OUTERBUFFTOKENRATIO,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn relicTokenRatio(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicConst::VT_RELICTOKENRATIO, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn rogueSystemUnlockStage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicConst::VT_ROGUESYSTEMUNLOCKSTAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn ordiModeReOpenCoolDown(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicConst::VT_ORDIMODEREOPENCOOLDOWN,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn monthModeReOpenCoolDown(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicConst::VT_MONTHMODEREOPENCOOLDOWN,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn monthlyTaskUncompletedTime(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicConst::VT_MONTHLYTASKUNCOMPLETEDTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn monthlyTaskManualRefreshLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicConst::VT_MONTHLYTASKMANUALREFRESHLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn monthlyTeamUncompletedTime(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicConst::VT_MONTHLYTEAMUNCOMPLETEDTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn bpPurchaseSystemUnlockTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_RoguelikeTopicConst::VT_BPPURCHASESYSTEMUNLOCKTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn predefinedChars(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicConst::VT_PREDEFINEDCHARS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("milestoneTokenRatio", Self::VT_MILESTONETOKENRATIO, false)?
            .visit_field::<f32>("outerBuffTokenRatio", Self::VT_OUTERBUFFTOKENRATIO, false)?
            .visit_field::<i32>("relicTokenRatio", Self::VT_RELICTOKENRATIO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rogueSystemUnlockStage",
                Self::VT_ROGUESYSTEMUNLOCKSTAGE,
                false,
            )?
            .visit_field::<i32>(
                "ordiModeReOpenCoolDown",
                Self::VT_ORDIMODEREOPENCOOLDOWN,
                false,
            )?
            .visit_field::<i32>(
                "monthModeReOpenCoolDown",
                Self::VT_MONTHMODEREOPENCOOLDOWN,
                false,
            )?
            .visit_field::<i32>(
                "monthlyTaskUncompletedTime",
                Self::VT_MONTHLYTASKUNCOMPLETEDTIME,
                false,
            )?
            .visit_field::<i32>(
                "monthlyTaskManualRefreshLimit",
                Self::VT_MONTHLYTASKMANUALREFRESHLIMIT,
                false,
            )?
            .visit_field::<i32>(
                "monthlyTeamUncompletedTime",
                Self::VT_MONTHLYTEAMUNCOMPLETEDTIME,
                false,
            )?
            .visit_field::<i64>(
                "bpPurchaseSystemUnlockTime",
                Self::VT_BPPURCHASESYSTEMUNLOCKTIME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar,
                    >,
                >,
            >>("predefinedChars", Self::VT_PREDEFINEDCHARS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicConstArgs<'a> {
    pub milestoneTokenRatio: i32,
    pub outerBuffTokenRatio: f32,
    pub relicTokenRatio: i32,
    pub rogueSystemUnlockStage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ordiModeReOpenCoolDown: i32,
    pub monthModeReOpenCoolDown: i32,
    pub monthlyTaskUncompletedTime: i32,
    pub monthlyTaskManualRefreshLimit: i32,
    pub monthlyTeamUncompletedTime: i32,
    pub bpPurchaseSystemUnlockTime: i64,
    pub predefinedChars: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicConstArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicConstArgs {
            milestoneTokenRatio: 0,
            outerBuffTokenRatio: 0.0,
            relicTokenRatio: 0,
            rogueSystemUnlockStage: None,
            ordiModeReOpenCoolDown: 0,
            monthModeReOpenCoolDown: 0,
            monthlyTaskUncompletedTime: 0,
            monthlyTaskManualRefreshLimit: 0,
            monthlyTeamUncompletedTime: 0,
            bpPurchaseSystemUnlockTime: 0,
            predefinedChars: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicConst<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicConst", 11)?;
        s.serialize_field("milestoneTokenRatio", &self.milestoneTokenRatio())?;
        s.serialize_field("outerBuffTokenRatio", &self.outerBuffTokenRatio())?;
        s.serialize_field("relicTokenRatio", &self.relicTokenRatio())?;
        if let Some(f) = self.rogueSystemUnlockStage() {
            s.serialize_field("rogueSystemUnlockStage", &f)?;
        } else {
            s.skip_field("rogueSystemUnlockStage")?;
        }
        s.serialize_field("ordiModeReOpenCoolDown", &self.ordiModeReOpenCoolDown())?;
        s.serialize_field("monthModeReOpenCoolDown", &self.monthModeReOpenCoolDown())?;
        s.serialize_field(
            "monthlyTaskUncompletedTime",
            &self.monthlyTaskUncompletedTime(),
        )?;
        s.serialize_field(
            "monthlyTaskManualRefreshLimit",
            &self.monthlyTaskManualRefreshLimit(),
        )?;
        s.serialize_field(
            "monthlyTeamUncompletedTime",
            &self.monthlyTeamUncompletedTime(),
        )?;
        s.serialize_field(
            "bpPurchaseSystemUnlockTime",
            &self.bpPurchaseSystemUnlockTime(),
        )?;
        if let Some(f) = self.predefinedChars() {
            s.serialize_field("predefinedChars", &f)?;
        } else {
            s.skip_field("predefinedChars")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RoguelikeTopicConstBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_milestoneTokenRatio(&mut self, milestoneTokenRatio: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicConst::VT_MILESTONETOKENRATIO,
            milestoneTokenRatio,
            0,
        );
    }
    #[inline]
    pub fn add_outerBuffTokenRatio(&mut self, outerBuffTokenRatio: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_RoguelikeTopicConst::VT_OUTERBUFFTOKENRATIO,
            outerBuffTokenRatio,
            0.0,
        );
    }
    #[inline]
    pub fn add_relicTokenRatio(&mut self, relicTokenRatio: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicConst::VT_RELICTOKENRATIO,
            relicTokenRatio,
            0,
        );
    }
    #[inline]
    pub fn add_rogueSystemUnlockStage(
        &mut self,
        rogueSystemUnlockStage: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicConst::VT_ROGUESYSTEMUNLOCKSTAGE,
            rogueSystemUnlockStage,
        );
    }
    #[inline]
    pub fn add_ordiModeReOpenCoolDown(&mut self, ordiModeReOpenCoolDown: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicConst::VT_ORDIMODEREOPENCOOLDOWN,
            ordiModeReOpenCoolDown,
            0,
        );
    }
    #[inline]
    pub fn add_monthModeReOpenCoolDown(&mut self, monthModeReOpenCoolDown: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicConst::VT_MONTHMODEREOPENCOOLDOWN,
            monthModeReOpenCoolDown,
            0,
        );
    }
    #[inline]
    pub fn add_monthlyTaskUncompletedTime(&mut self, monthlyTaskUncompletedTime: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicConst::VT_MONTHLYTASKUNCOMPLETEDTIME,
            monthlyTaskUncompletedTime,
            0,
        );
    }
    #[inline]
    pub fn add_monthlyTaskManualRefreshLimit(&mut self, monthlyTaskManualRefreshLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicConst::VT_MONTHLYTASKMANUALREFRESHLIMIT,
            monthlyTaskManualRefreshLimit,
            0,
        );
    }
    #[inline]
    pub fn add_monthlyTeamUncompletedTime(&mut self, monthlyTeamUncompletedTime: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicConst::VT_MONTHLYTEAMUNCOMPLETEDTIME,
            monthlyTeamUncompletedTime,
            0,
        );
    }
    #[inline]
    pub fn add_bpPurchaseSystemUnlockTime(&mut self, bpPurchaseSystemUnlockTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeTopicConst::VT_BPPURCHASESYSTEMUNLOCKTIME,
            bpPurchaseSystemUnlockTime,
            0,
        );
    }
    #[inline]
    pub fn add_predefinedChars(
        &mut self,
        predefinedChars: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedChar<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicConst::VT_PREDEFINEDCHARS,
            predefinedChars,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicConst");
        ds.field("milestoneTokenRatio", &self.milestoneTokenRatio());
        ds.field("outerBuffTokenRatio", &self.outerBuffTokenRatio());
        ds.field("relicTokenRatio", &self.relicTokenRatio());
        ds.field("rogueSystemUnlockStage", &self.rogueSystemUnlockStage());
        ds.field("ordiModeReOpenCoolDown", &self.ordiModeReOpenCoolDown());
        ds.field("monthModeReOpenCoolDown", &self.monthModeReOpenCoolDown());
        ds.field(
            "monthlyTaskUncompletedTime",
            &self.monthlyTaskUncompletedTime(),
        );
        ds.field(
            "monthlyTaskManualRefreshLimit",
            &self.monthlyTaskManualRefreshLimit(),
        );
        ds.field(
            "monthlyTeamUncompletedTime",
            &self.monthlyTeamUncompletedTime(),
        );
        ds.field(
            "bpPurchaseSystemUnlockTime",
            &self.bpPurchaseSystemUnlockTime(),
        );
        ds.field("predefinedChars", &self.predefinedChars());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicConstT {
    pub milestoneTokenRatio: i32,
    pub outerBuffTokenRatio: f32,
    pub relicTokenRatio: i32,
    pub rogueSystemUnlockStage: Option<String>,
    pub ordiModeReOpenCoolDown: i32,
    pub monthModeReOpenCoolDown: i32,
    pub monthlyTaskUncompletedTime: i32,
    pub monthlyTaskManualRefreshLimit: i32,
    pub monthlyTeamUncompletedTime: i32,
    pub bpPurchaseSystemUnlockTime: i64,
    pub predefinedChars: Option<Vec<dict__string__clz_Torappu_RoguelikeTopicConst_PredefinedCharT>>,
}
impl Default for clz_Torappu_RoguelikeTopicConstT {
    fn default() -> Self {
        Self {
            milestoneTokenRatio: 0,
            outerBuffTokenRatio: 0.0,
            relicTokenRatio: 0,
            rogueSystemUnlockStage: None,
            ordiModeReOpenCoolDown: 0,
            monthModeReOpenCoolDown: 0,
            monthlyTaskUncompletedTime: 0,
            monthlyTaskManualRefreshLimit: 0,
            monthlyTeamUncompletedTime: 0,
            bpPurchaseSystemUnlockTime: 0,
            predefinedChars: None,
        }
    }
}
impl clz_Torappu_RoguelikeTopicConstT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConst<'b>> {
        let milestoneTokenRatio = self.milestoneTokenRatio;
        let outerBuffTokenRatio = self.outerBuffTokenRatio;
        let relicTokenRatio = self.relicTokenRatio;
        let rogueSystemUnlockStage = self
            .rogueSystemUnlockStage
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let ordiModeReOpenCoolDown = self.ordiModeReOpenCoolDown;
        let monthModeReOpenCoolDown = self.monthModeReOpenCoolDown;
        let monthlyTaskUncompletedTime = self.monthlyTaskUncompletedTime;
        let monthlyTaskManualRefreshLimit = self.monthlyTaskManualRefreshLimit;
        let monthlyTeamUncompletedTime = self.monthlyTeamUncompletedTime;
        let bpPurchaseSystemUnlockTime = self.bpPurchaseSystemUnlockTime;
        let predefinedChars = self.predefinedChars.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeTopicConst::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicConstArgs {
                milestoneTokenRatio,
                outerBuffTokenRatio,
                relicTokenRatio,
                rogueSystemUnlockStage,
                ordiModeReOpenCoolDown,
                monthModeReOpenCoolDown,
                monthlyTaskUncompletedTime,
                monthlyTaskManualRefreshLimit,
                monthlyTeamUncompletedTime,
                bpPurchaseSystemUnlockTime,
                predefinedChars,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicUpdateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicUpdate<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicUpdate<'a> {
    type Inner = clz_Torappu_RoguelikeTopicUpdate<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicUpdate<'a> {
    pub const VT_UPDATEID: flatbuffers::VOffsetT = 4;
    pub const VT_TOPICUPDATETIME: flatbuffers::VOffsetT = 6;
    pub const VT_TOPICENDTIME: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicUpdate { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicUpdateArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicUpdate<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicUpdateBuilder::new(_fbb);
        builder.add_topicEndTime(args.topicEndTime);
        builder.add_topicUpdateTime(args.topicUpdateTime);
        if let Some(x) = args.updateId {
            builder.add_updateId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicUpdateT {
        let updateId = self.updateId().map(|x| x.to_string());
        let topicUpdateTime = self.topicUpdateTime();
        let topicEndTime = self.topicEndTime();
        clz_Torappu_RoguelikeTopicUpdateT {
            updateId,
            topicUpdateTime,
            topicEndTime,
        }
    }

    #[inline]
    pub fn updateId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicUpdate::VT_UPDATEID,
                None,
            )
        }
    }
    #[inline]
    pub fn topicUpdateTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_RoguelikeTopicUpdate::VT_TOPICUPDATETIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn topicEndTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_RoguelikeTopicUpdate::VT_TOPICENDTIME, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicUpdate<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "updateId",
                Self::VT_UPDATEID,
                false,
            )?
            .visit_field::<i64>("topicUpdateTime", Self::VT_TOPICUPDATETIME, false)?
            .visit_field::<i64>("topicEndTime", Self::VT_TOPICENDTIME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicUpdateArgs<'a> {
    pub updateId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub topicUpdateTime: i64,
    pub topicEndTime: i64,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicUpdateArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicUpdateArgs {
            updateId: None,
            topicUpdateTime: 0,
            topicEndTime: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicUpdate<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicUpdate", 3)?;
        if let Some(f) = self.updateId() {
            s.serialize_field("updateId", &f)?;
        } else {
            s.skip_field("updateId")?;
        }
        s.serialize_field("topicUpdateTime", &self.topicUpdateTime())?;
        s.serialize_field("topicEndTime", &self.topicEndTime())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicUpdateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicUpdateBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_updateId(&mut self, updateId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicUpdate::VT_UPDATEID,
            updateId,
        );
    }
    #[inline]
    pub fn add_topicUpdateTime(&mut self, topicUpdateTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeTopicUpdate::VT_TOPICUPDATETIME,
            topicUpdateTime,
            0,
        );
    }
    #[inline]
    pub fn add_topicEndTime(&mut self, topicEndTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeTopicUpdate::VT_TOPICENDTIME,
            topicEndTime,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicUpdateBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicUpdateBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicUpdate<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicUpdate<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicUpdate");
        ds.field("updateId", &self.updateId());
        ds.field("topicUpdateTime", &self.topicUpdateTime());
        ds.field("topicEndTime", &self.topicEndTime());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicUpdateT {
    pub updateId: Option<String>,
    pub topicUpdateTime: i64,
    pub topicEndTime: i64,
}
impl Default for clz_Torappu_RoguelikeTopicUpdateT {
    fn default() -> Self {
        Self {
            updateId: None,
            topicUpdateTime: 0,
            topicEndTime: 0,
        }
    }
}
impl clz_Torappu_RoguelikeTopicUpdateT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicUpdate<'b>> {
        let updateId = self.updateId.as_ref().map(|x| _fbb.create_string(x));
        let topicUpdateTime = self.topicUpdateTime;
        let topicEndTime = self.topicEndTime;
        clz_Torappu_RoguelikeTopicUpdate::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicUpdateArgs {
                updateId,
                topicUpdateTime,
                topicEndTime,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicEnrollOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicEnroll<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicEnroll<'a> {
    type Inner = clz_Torappu_RoguelikeTopicEnroll<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicEnroll<'a> {
    pub const VT_ENROLLID: flatbuffers::VOffsetT = 4;
    pub const VT_ENROLLTIME: flatbuffers::VOffsetT = 6;
    pub const VT_ENROLLTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_ENROLLNOTICEENDTIME: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicEnroll { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicEnrollArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicEnroll<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicEnrollBuilder::new(_fbb);
        builder.add_enrollNoticeEndTime(args.enrollNoticeEndTime);
        builder.add_enrollTime(args.enrollTime);
        builder.add_enrollType(args.enrollType);
        if let Some(x) = args.enrollId {
            builder.add_enrollId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicEnrollT {
        let enrollId = self.enrollId().map(|x| x.to_string());
        let enrollTime = self.enrollTime();
        let enrollType = self.enrollType();
        let enrollNoticeEndTime = self.enrollNoticeEndTime();
        clz_Torappu_RoguelikeTopicEnrollT {
            enrollId,
            enrollTime,
            enrollType,
            enrollNoticeEndTime,
        }
    }

    #[inline]
    pub fn enrollId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicEnroll::VT_ENROLLID,
                None,
            )
        }
    }
    #[inline]
    pub fn enrollTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_RoguelikeTopicEnroll::VT_ENROLLTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn enrollType(&self) -> enum__Torappu_RoguelikeEnrollType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeEnrollType>(
                    clz_Torappu_RoguelikeTopicEnroll::VT_ENROLLTYPE,
                    Some(enum__Torappu_RoguelikeEnrollType::DLC),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn enrollNoticeEndTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_RoguelikeTopicEnroll::VT_ENROLLNOTICEENDTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicEnroll<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollId",
                Self::VT_ENROLLID,
                false,
            )?
            .visit_field::<i64>("enrollTime", Self::VT_ENROLLTIME, false)?
            .visit_field::<enum__Torappu_RoguelikeEnrollType>(
                "enrollType",
                Self::VT_ENROLLTYPE,
                false,
            )?
            .visit_field::<i64>("enrollNoticeEndTime", Self::VT_ENROLLNOTICEENDTIME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicEnrollArgs<'a> {
    pub enrollId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enrollTime: i64,
    pub enrollType: enum__Torappu_RoguelikeEnrollType,
    pub enrollNoticeEndTime: i64,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicEnrollArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicEnrollArgs {
            enrollId: None,
            enrollTime: 0,
            enrollType: enum__Torappu_RoguelikeEnrollType::DLC,
            enrollNoticeEndTime: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicEnroll<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicEnroll", 4)?;
        if let Some(f) = self.enrollId() {
            s.serialize_field("enrollId", &f)?;
        } else {
            s.skip_field("enrollId")?;
        }
        s.serialize_field("enrollTime", &self.enrollTime())?;
        s.serialize_field("enrollType", &self.enrollType())?;
        s.serialize_field("enrollNoticeEndTime", &self.enrollNoticeEndTime())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicEnrollBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicEnrollBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_enrollId(&mut self, enrollId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicEnroll::VT_ENROLLID,
            enrollId,
        );
    }
    #[inline]
    pub fn add_enrollTime(&mut self, enrollTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeTopicEnroll::VT_ENROLLTIME,
            enrollTime,
            0,
        );
    }
    #[inline]
    pub fn add_enrollType(&mut self, enrollType: enum__Torappu_RoguelikeEnrollType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeEnrollType>(
            clz_Torappu_RoguelikeTopicEnroll::VT_ENROLLTYPE,
            enrollType,
            enum__Torappu_RoguelikeEnrollType::DLC,
        );
    }
    #[inline]
    pub fn add_enrollNoticeEndTime(&mut self, enrollNoticeEndTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeTopicEnroll::VT_ENROLLNOTICEENDTIME,
            enrollNoticeEndTime,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicEnrollBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicEnrollBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicEnroll<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicEnroll<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicEnroll");
        ds.field("enrollId", &self.enrollId());
        ds.field("enrollTime", &self.enrollTime());
        ds.field("enrollType", &self.enrollType());
        ds.field("enrollNoticeEndTime", &self.enrollNoticeEndTime());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicEnrollT {
    pub enrollId: Option<String>,
    pub enrollTime: i64,
    pub enrollType: enum__Torappu_RoguelikeEnrollType,
    pub enrollNoticeEndTime: i64,
}
impl Default for clz_Torappu_RoguelikeTopicEnrollT {
    fn default() -> Self {
        Self {
            enrollId: None,
            enrollTime: 0,
            enrollType: enum__Torappu_RoguelikeEnrollType::DLC,
            enrollNoticeEndTime: 0,
        }
    }
}
impl clz_Torappu_RoguelikeTopicEnrollT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicEnroll<'b>> {
        let enrollId = self.enrollId.as_ref().map(|x| _fbb.create_string(x));
        let enrollTime = self.enrollTime;
        let enrollType = self.enrollType;
        let enrollNoticeEndTime = self.enrollNoticeEndTime;
        clz_Torappu_RoguelikeTopicEnroll::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicEnrollArgs {
                enrollId,
                enrollTime,
                enrollType,
                enrollNoticeEndTime,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeTopicEnrollOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeTopicEnroll<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeTopicEnroll<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeTopicEnroll<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeTopicEnroll<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeTopicEnroll { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeTopicEnrollArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicEnroll<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeTopicEnrollBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeTopicEnrollT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeTopicEnrollT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeTopicEnroll::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeTopicEnroll,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeTopicEnroll<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicEnroll>>(
                    dict__string__clz_Torappu_RoguelikeTopicEnroll::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeTopicEnroll<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicEnroll>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeTopicEnrollArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicEnroll<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeTopicEnrollArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeTopicEnrollArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeTopicEnroll<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeTopicEnroll", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeTopicEnrollBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeTopicEnrollBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeTopicEnroll::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicEnroll<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicEnroll>>(
                dict__string__clz_Torappu_RoguelikeTopicEnroll::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeTopicEnrollBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeTopicEnrollBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicEnroll<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeTopicEnroll::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeTopicEnroll<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeTopicEnroll");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeTopicEnrollT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeTopicEnrollT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeTopicEnrollT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeTopicEnrollT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicEnroll<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeTopicEnroll::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeTopicEnrollArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicBPOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicBP<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicBP<'a> {
    type Inner = clz_Torappu_RoguelikeTopicBP<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicBP<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;
    pub const VT_TOKENNUM: flatbuffers::VOffsetT = 8;
    pub const VT_NEXTTOKENNUM: flatbuffers::VOffsetT = 10;
    pub const VT_ITEMID: flatbuffers::VOffsetT = 12;
    pub const VT_ITEMTYPE: flatbuffers::VOffsetT = 14;
    pub const VT_ITEMCOUNT: flatbuffers::VOffsetT = 16;
    pub const VT_ISGOODPRIZE: flatbuffers::VOffsetT = 18;
    pub const VT_ISGRANDPRIZE: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicBP { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicBPArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBP<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicBPBuilder::new(_fbb);
        builder.add_itemCount(args.itemCount);
        builder.add_itemType(args.itemType);
        if let Some(x) = args.itemID {
            builder.add_itemID(x);
        }
        builder.add_nextTokenNum(args.nextTokenNum);
        builder.add_tokenNum(args.tokenNum);
        builder.add_level(args.level);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_isGrandPrize(args.isGrandPrize);
        builder.add_isGoodPrize(args.isGoodPrize);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicBPT {
        let id = self.id().map(|x| x.to_string());
        let level = self.level();
        let tokenNum = self.tokenNum();
        let nextTokenNum = self.nextTokenNum();
        let itemID = self.itemID().map(|x| x.to_string());
        let itemType = self.itemType();
        let itemCount = self.itemCount();
        let isGoodPrize = self.isGoodPrize();
        let isGrandPrize = self.isGrandPrize();
        clz_Torappu_RoguelikeTopicBPT {
            id,
            level,
            tokenNum,
            nextTokenNum,
            itemID,
            itemType,
            itemCount,
            isGoodPrize,
            isGrandPrize,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBP::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicBP::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn tokenNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicBP::VT_TOKENNUM, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn nextTokenNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicBP::VT_NEXTTOKENNUM, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn itemID(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBP::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemType(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_RoguelikeTopicBP::VT_ITEMTYPE,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicBP::VT_ITEMCOUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn isGoodPrize(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_RoguelikeTopicBP::VT_ISGOODPRIZE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isGrandPrize(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_RoguelikeTopicBP::VT_ISGRANDPRIZE, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicBP<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .visit_field::<i32>("tokenNum", Self::VT_TOKENNUM, false)?
            .visit_field::<i32>("nextTokenNum", Self::VT_NEXTTOKENNUM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemID", Self::VT_ITEMID, false)?
            .visit_field::<enum__Torappu_ItemType>("itemType", Self::VT_ITEMTYPE, false)?
            .visit_field::<i32>("itemCount", Self::VT_ITEMCOUNT, false)?
            .visit_field::<bool>("isGoodPrize", Self::VT_ISGOODPRIZE, false)?
            .visit_field::<bool>("isGrandPrize", Self::VT_ISGRANDPRIZE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicBPArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub level: i32,
    pub tokenNum: i32,
    pub nextTokenNum: i32,
    pub itemID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemType: enum__Torappu_ItemType,
    pub itemCount: i32,
    pub isGoodPrize: bool,
    pub isGrandPrize: bool,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicBPArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicBPArgs {
            id: None,
            level: 0,
            tokenNum: 0,
            nextTokenNum: 0,
            itemID: None,
            itemType: enum__Torappu_ItemType::NONE,
            itemCount: 0,
            isGoodPrize: false,
            isGrandPrize: false,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicBP<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicBP", 9)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("level", &self.level())?;
        s.serialize_field("tokenNum", &self.tokenNum())?;
        s.serialize_field("nextTokenNum", &self.nextTokenNum())?;
        if let Some(f) = self.itemID() {
            s.serialize_field("itemID", &f)?;
        } else {
            s.skip_field("itemID")?;
        }
        s.serialize_field("itemType", &self.itemType())?;
        s.serialize_field("itemCount", &self.itemCount())?;
        s.serialize_field("isGoodPrize", &self.isGoodPrize())?;
        s.serialize_field("isGrandPrize", &self.isGrandPrize())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicBPBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RoguelikeTopicBPBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RoguelikeTopicBP::VT_ID, id);
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeTopicBP::VT_LEVEL, level, 0);
    }
    #[inline]
    pub fn add_tokenNum(&mut self, tokenNum: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeTopicBP::VT_TOKENNUM, tokenNum, 0);
    }
    #[inline]
    pub fn add_nextTokenNum(&mut self, nextTokenNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicBP::VT_NEXTTOKENNUM,
            nextTokenNum,
            0,
        );
    }
    #[inline]
    pub fn add_itemID(&mut self, itemID: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBP::VT_ITEMID,
            itemID,
        );
    }
    #[inline]
    pub fn add_itemType(&mut self, itemType: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_RoguelikeTopicBP::VT_ITEMTYPE,
            itemType,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_itemCount(&mut self, itemCount: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeTopicBP::VT_ITEMCOUNT, itemCount, 0);
    }
    #[inline]
    pub fn add_isGoodPrize(&mut self, isGoodPrize: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeTopicBP::VT_ISGOODPRIZE,
            isGoodPrize,
            false,
        );
    }
    #[inline]
    pub fn add_isGrandPrize(&mut self, isGrandPrize: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeTopicBP::VT_ISGRANDPRIZE,
            isGrandPrize,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicBPBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicBPBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBP<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicBP<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicBP");
        ds.field("id", &self.id());
        ds.field("level", &self.level());
        ds.field("tokenNum", &self.tokenNum());
        ds.field("nextTokenNum", &self.nextTokenNum());
        ds.field("itemID", &self.itemID());
        ds.field("itemType", &self.itemType());
        ds.field("itemCount", &self.itemCount());
        ds.field("isGoodPrize", &self.isGoodPrize());
        ds.field("isGrandPrize", &self.isGrandPrize());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicBPT {
    pub id: Option<String>,
    pub level: i32,
    pub tokenNum: i32,
    pub nextTokenNum: i32,
    pub itemID: Option<String>,
    pub itemType: enum__Torappu_ItemType,
    pub itemCount: i32,
    pub isGoodPrize: bool,
    pub isGrandPrize: bool,
}
impl Default for clz_Torappu_RoguelikeTopicBPT {
    fn default() -> Self {
        Self {
            id: None,
            level: 0,
            tokenNum: 0,
            nextTokenNum: 0,
            itemID: None,
            itemType: enum__Torappu_ItemType::NONE,
            itemCount: 0,
            isGoodPrize: false,
            isGrandPrize: false,
        }
    }
}
impl clz_Torappu_RoguelikeTopicBPT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBP<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let level = self.level;
        let tokenNum = self.tokenNum;
        let nextTokenNum = self.nextTokenNum;
        let itemID = self.itemID.as_ref().map(|x| _fbb.create_string(x));
        let itemType = self.itemType;
        let itemCount = self.itemCount;
        let isGoodPrize = self.isGoodPrize;
        let isGrandPrize = self.isGrandPrize;
        clz_Torappu_RoguelikeTopicBP::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicBPArgs {
                id,
                level,
                tokenNum,
                nextTokenNum,
                itemID,
                itemType,
                itemCount,
                isGoodPrize,
                isGrandPrize,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicMilestoneUpdateDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicMilestoneUpdateData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicMilestoneUpdateData<'a> {
    type Inner = clz_Torappu_RoguelikeTopicMilestoneUpdateData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicMilestoneUpdateData<'a> {
    pub const VT_UPDATETIME: flatbuffers::VOffsetT = 4;
    pub const VT_ENDTIME: flatbuffers::VOffsetT = 6;
    pub const VT_MAXBPLEVEL: flatbuffers::VOffsetT = 8;
    pub const VT_MAXBPCOUNT: flatbuffers::VOffsetT = 10;
    pub const VT_MAXDISPLAYBPCOUNT: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicMilestoneUpdateData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicMilestoneUpdateDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicMilestoneUpdateData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicMilestoneUpdateDataBuilder::new(_fbb);
        builder.add_endTime(args.endTime);
        builder.add_updateTime(args.updateTime);
        builder.add_maxDisplayBpCount(args.maxDisplayBpCount);
        builder.add_maxBpCount(args.maxBpCount);
        builder.add_maxBpLevel(args.maxBpLevel);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicMilestoneUpdateDataT {
        let updateTime = self.updateTime();
        let endTime = self.endTime();
        let maxBpLevel = self.maxBpLevel();
        let maxBpCount = self.maxBpCount();
        let maxDisplayBpCount = self.maxDisplayBpCount();
        clz_Torappu_RoguelikeTopicMilestoneUpdateDataT {
            updateTime,
            endTime,
            maxBpLevel,
            maxBpCount,
            maxDisplayBpCount,
        }
    }

    #[inline]
    pub fn updateTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_RoguelikeTopicMilestoneUpdateData::VT_UPDATETIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn endTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_RoguelikeTopicMilestoneUpdateData::VT_ENDTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxBpLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicMilestoneUpdateData::VT_MAXBPLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxBpCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicMilestoneUpdateData::VT_MAXBPCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxDisplayBpCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicMilestoneUpdateData::VT_MAXDISPLAYBPCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicMilestoneUpdateData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("updateTime", Self::VT_UPDATETIME, false)?
            .visit_field::<i64>("endTime", Self::VT_ENDTIME, false)?
            .visit_field::<i32>("maxBpLevel", Self::VT_MAXBPLEVEL, false)?
            .visit_field::<i32>("maxBpCount", Self::VT_MAXBPCOUNT, false)?
            .visit_field::<i32>("maxDisplayBpCount", Self::VT_MAXDISPLAYBPCOUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicMilestoneUpdateDataArgs {
    pub updateTime: i64,
    pub endTime: i64,
    pub maxBpLevel: i32,
    pub maxBpCount: i32,
    pub maxDisplayBpCount: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicMilestoneUpdateDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicMilestoneUpdateDataArgs {
            updateTime: 0,
            endTime: 0,
            maxBpLevel: 0,
            maxBpCount: 0,
            maxDisplayBpCount: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicMilestoneUpdateData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeTopicMilestoneUpdateData", 5)?;
        s.serialize_field("updateTime", &self.updateTime())?;
        s.serialize_field("endTime", &self.endTime())?;
        s.serialize_field("maxBpLevel", &self.maxBpLevel())?;
        s.serialize_field("maxBpCount", &self.maxBpCount())?;
        s.serialize_field("maxDisplayBpCount", &self.maxDisplayBpCount())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicMilestoneUpdateDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicMilestoneUpdateDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_updateTime(&mut self, updateTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeTopicMilestoneUpdateData::VT_UPDATETIME,
            updateTime,
            0,
        );
    }
    #[inline]
    pub fn add_endTime(&mut self, endTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeTopicMilestoneUpdateData::VT_ENDTIME,
            endTime,
            0,
        );
    }
    #[inline]
    pub fn add_maxBpLevel(&mut self, maxBpLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicMilestoneUpdateData::VT_MAXBPLEVEL,
            maxBpLevel,
            0,
        );
    }
    #[inline]
    pub fn add_maxBpCount(&mut self, maxBpCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicMilestoneUpdateData::VT_MAXBPCOUNT,
            maxBpCount,
            0,
        );
    }
    #[inline]
    pub fn add_maxDisplayBpCount(&mut self, maxDisplayBpCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicMilestoneUpdateData::VT_MAXDISPLAYBPCOUNT,
            maxDisplayBpCount,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicMilestoneUpdateDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicMilestoneUpdateDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicMilestoneUpdateData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicMilestoneUpdateData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicMilestoneUpdateData");
        ds.field("updateTime", &self.updateTime());
        ds.field("endTime", &self.endTime());
        ds.field("maxBpLevel", &self.maxBpLevel());
        ds.field("maxBpCount", &self.maxBpCount());
        ds.field("maxDisplayBpCount", &self.maxDisplayBpCount());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicMilestoneUpdateDataT {
    pub updateTime: i64,
    pub endTime: i64,
    pub maxBpLevel: i32,
    pub maxBpCount: i32,
    pub maxDisplayBpCount: i32,
}
impl Default for clz_Torappu_RoguelikeTopicMilestoneUpdateDataT {
    fn default() -> Self {
        Self {
            updateTime: 0,
            endTime: 0,
            maxBpLevel: 0,
            maxBpCount: 0,
            maxDisplayBpCount: 0,
        }
    }
}
impl clz_Torappu_RoguelikeTopicMilestoneUpdateDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicMilestoneUpdateData<'b>> {
        let updateTime = self.updateTime;
        let endTime = self.endTime;
        let maxBpLevel = self.maxBpLevel;
        let maxBpCount = self.maxBpCount;
        let maxDisplayBpCount = self.maxDisplayBpCount;
        clz_Torappu_RoguelikeTopicMilestoneUpdateData::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicMilestoneUpdateDataArgs {
                updateTime,
                endTime,
                maxBpLevel,
                maxBpCount,
                maxDisplayBpCount,
            },
        )
    }
}
pub enum clz_Torappu_ItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemBundle<'a> {
    type Inner = clz_Torappu_ItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'bldr>> {
        let mut builder = clz_Torappu_ItemBundleBuilder::new(_fbb);
        builder.add_type_(args.type_);
        builder.add_count(args.count);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemBundleT {
        let id = self.id().map(|x| x.to_string());
        let count = self.count();
        let type_ = self.type_();
        clz_Torappu_ItemBundleT { id, count, type_ }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemBundle::VT_ID, None)
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl<'a> Default for clz_Torappu_ItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemBundleArgs {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_ItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemBundle", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("count", &self.count())?;
        s.serialize_field("type_", &self.type_())?;
        s.end()
    }
}

pub struct clz_Torappu_ItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemBundle");
        ds.field("id", &self.id());
        ds.field("count", &self.count());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemBundleT {
    pub id: Option<String>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl Default for clz_Torappu_ItemBundleT {
    fn default() -> Self {
        Self {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}
impl clz_Torappu_ItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        let type_ = self.type_;
        clz_Torappu_ItemBundle::create(_fbb, &clz_Torappu_ItemBundleArgs { id, count, type_ })
    }
}
pub enum clz_Torappu_RoguelikeTopicBPGrandPrizeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicBPGrandPrize<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicBPGrandPrize<'a> {
    type Inner = clz_Torappu_RoguelikeTopicBPGrandPrize<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicBPGrandPrize<'a> {
    pub const VT_GRANDPRIZEDISPLAYID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_DISPLAYUNLOCKYEAR: flatbuffers::VOffsetT = 8;
    pub const VT_DISPLAYUNLOCKMONTH: flatbuffers::VOffsetT = 10;
    pub const VT_ACQUIRETITLE: flatbuffers::VOffsetT = 12;
    pub const VT_PURCHASETITLE: flatbuffers::VOffsetT = 14;
    pub const VT_DISPLAYNAME: flatbuffers::VOffsetT = 16;
    pub const VT_DISPLAYDISCRIPTION: flatbuffers::VOffsetT = 18;
    pub const VT_BPLEVELID: flatbuffers::VOffsetT = 20;
    pub const VT_ITEMBUNDLE: flatbuffers::VOffsetT = 22;
    pub const VT_DETAILANNOUNCETIME: flatbuffers::VOffsetT = 24;
    pub const VT_PICIDAFTRERUNLOCK: flatbuffers::VOffsetT = 26;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicBPGrandPrize { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicBPGrandPrizeArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBPGrandPrize<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicBPGrandPrizeBuilder::new(_fbb);
        if let Some(x) = args.picIdAftrerUnlock {
            builder.add_picIdAftrerUnlock(x);
        }
        if let Some(x) = args.detailAnnounceTime {
            builder.add_detailAnnounceTime(x);
        }
        if let Some(x) = args.itemBundle {
            builder.add_itemBundle(x);
        }
        if let Some(x) = args.bpLevelId {
            builder.add_bpLevelId(x);
        }
        if let Some(x) = args.displayDiscription {
            builder.add_displayDiscription(x);
        }
        if let Some(x) = args.displayName {
            builder.add_displayName(x);
        }
        if let Some(x) = args.purchaseTitle {
            builder.add_purchaseTitle(x);
        }
        if let Some(x) = args.acquireTitle {
            builder.add_acquireTitle(x);
        }
        builder.add_displayUnlockMonth(args.displayUnlockMonth);
        builder.add_displayUnlockYear(args.displayUnlockYear);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.grandPrizeDisplayId {
            builder.add_grandPrizeDisplayId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicBPGrandPrizeT {
        let grandPrizeDisplayId = self.grandPrizeDisplayId().map(|x| x.to_string());
        let sortId = self.sortId();
        let displayUnlockYear = self.displayUnlockYear();
        let displayUnlockMonth = self.displayUnlockMonth();
        let acquireTitle = self.acquireTitle().map(|x| x.to_string());
        let purchaseTitle = self.purchaseTitle().map(|x| x.to_string());
        let displayName = self.displayName().map(|x| x.to_string());
        let displayDiscription = self.displayDiscription().map(|x| x.to_string());
        let bpLevelId = self.bpLevelId().map(|x| x.to_string());
        let itemBundle = self.itemBundle().map(|x| Box::new(x.unpack()));
        let detailAnnounceTime = self.detailAnnounceTime().map(|x| x.to_string());
        let picIdAftrerUnlock = self.picIdAftrerUnlock().map(|x| x.to_string());
        clz_Torappu_RoguelikeTopicBPGrandPrizeT {
            grandPrizeDisplayId,
            sortId,
            displayUnlockYear,
            displayUnlockMonth,
            acquireTitle,
            purchaseTitle,
            displayName,
            displayDiscription,
            bpLevelId,
            itemBundle,
            detailAnnounceTime,
            picIdAftrerUnlock,
        }
    }

    #[inline]
    pub fn grandPrizeDisplayId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBPGrandPrize::VT_GRANDPRIZEDISPLAYID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicBPGrandPrize::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn displayUnlockYear(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicBPGrandPrize::VT_DISPLAYUNLOCKYEAR,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn displayUnlockMonth(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicBPGrandPrize::VT_DISPLAYUNLOCKMONTH,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn acquireTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBPGrandPrize::VT_ACQUIRETITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn purchaseTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBPGrandPrize::VT_PURCHASETITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn displayName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBPGrandPrize::VT_DISPLAYNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn displayDiscription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBPGrandPrize::VT_DISPLAYDISCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn bpLevelId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBPGrandPrize::VT_BPLEVELID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemBundle(&self) -> Option<clz_Torappu_ItemBundle<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>(
                    clz_Torappu_RoguelikeTopicBPGrandPrize::VT_ITEMBUNDLE,
                    None,
                )
        }
    }
    #[inline]
    pub fn detailAnnounceTime(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBPGrandPrize::VT_DETAILANNOUNCETIME,
                None,
            )
        }
    }
    #[inline]
    pub fn picIdAftrerUnlock(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBPGrandPrize::VT_PICIDAFTRERUNLOCK,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicBPGrandPrize<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "grandPrizeDisplayId",
                Self::VT_GRANDPRIZEDISPLAYID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<i32>("displayUnlockYear", Self::VT_DISPLAYUNLOCKYEAR, false)?
            .visit_field::<i32>("displayUnlockMonth", Self::VT_DISPLAYUNLOCKMONTH, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "acquireTitle",
                Self::VT_ACQUIRETITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "purchaseTitle",
                Self::VT_PURCHASETITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "displayName",
                Self::VT_DISPLAYNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "displayDiscription",
                Self::VT_DISPLAYDISCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bpLevelId",
                Self::VT_BPLEVELID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>(
                "itemBundle",
                Self::VT_ITEMBUNDLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "detailAnnounceTime",
                Self::VT_DETAILANNOUNCETIME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "picIdAftrerUnlock",
                Self::VT_PICIDAFTRERUNLOCK,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicBPGrandPrizeArgs<'a> {
    pub grandPrizeDisplayId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub displayUnlockYear: i32,
    pub displayUnlockMonth: i32,
    pub acquireTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub purchaseTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub displayName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub displayDiscription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bpLevelId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemBundle: Option<flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>>>,
    pub detailAnnounceTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picIdAftrerUnlock: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicBPGrandPrizeArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicBPGrandPrizeArgs {
            grandPrizeDisplayId: None,
            sortId: 0,
            displayUnlockYear: 0,
            displayUnlockMonth: 0,
            acquireTitle: None,
            purchaseTitle: None,
            displayName: None,
            displayDiscription: None,
            bpLevelId: None,
            itemBundle: None,
            detailAnnounceTime: None,
            picIdAftrerUnlock: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicBPGrandPrize<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicBPGrandPrize", 12)?;
        if let Some(f) = self.grandPrizeDisplayId() {
            s.serialize_field("grandPrizeDisplayId", &f)?;
        } else {
            s.skip_field("grandPrizeDisplayId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("displayUnlockYear", &self.displayUnlockYear())?;
        s.serialize_field("displayUnlockMonth", &self.displayUnlockMonth())?;
        if let Some(f) = self.acquireTitle() {
            s.serialize_field("acquireTitle", &f)?;
        } else {
            s.skip_field("acquireTitle")?;
        }
        if let Some(f) = self.purchaseTitle() {
            s.serialize_field("purchaseTitle", &f)?;
        } else {
            s.skip_field("purchaseTitle")?;
        }
        if let Some(f) = self.displayName() {
            s.serialize_field("displayName", &f)?;
        } else {
            s.skip_field("displayName")?;
        }
        if let Some(f) = self.displayDiscription() {
            s.serialize_field("displayDiscription", &f)?;
        } else {
            s.skip_field("displayDiscription")?;
        }
        if let Some(f) = self.bpLevelId() {
            s.serialize_field("bpLevelId", &f)?;
        } else {
            s.skip_field("bpLevelId")?;
        }
        if let Some(f) = self.itemBundle() {
            s.serialize_field("itemBundle", &f)?;
        } else {
            s.skip_field("itemBundle")?;
        }
        if let Some(f) = self.detailAnnounceTime() {
            s.serialize_field("detailAnnounceTime", &f)?;
        } else {
            s.skip_field("detailAnnounceTime")?;
        }
        if let Some(f) = self.picIdAftrerUnlock() {
            s.serialize_field("picIdAftrerUnlock", &f)?;
        } else {
            s.skip_field("picIdAftrerUnlock")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicBPGrandPrizeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicBPGrandPrizeBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_grandPrizeDisplayId(
        &mut self,
        grandPrizeDisplayId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBPGrandPrize::VT_GRANDPRIZEDISPLAYID,
            grandPrizeDisplayId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeTopicBPGrandPrize::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_displayUnlockYear(&mut self, displayUnlockYear: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicBPGrandPrize::VT_DISPLAYUNLOCKYEAR,
            displayUnlockYear,
            0,
        );
    }
    #[inline]
    pub fn add_displayUnlockMonth(&mut self, displayUnlockMonth: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicBPGrandPrize::VT_DISPLAYUNLOCKMONTH,
            displayUnlockMonth,
            0,
        );
    }
    #[inline]
    pub fn add_acquireTitle(&mut self, acquireTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBPGrandPrize::VT_ACQUIRETITLE,
            acquireTitle,
        );
    }
    #[inline]
    pub fn add_purchaseTitle(&mut self, purchaseTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBPGrandPrize::VT_PURCHASETITLE,
            purchaseTitle,
        );
    }
    #[inline]
    pub fn add_displayName(&mut self, displayName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBPGrandPrize::VT_DISPLAYNAME,
            displayName,
        );
    }
    #[inline]
    pub fn add_displayDiscription(&mut self, displayDiscription: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBPGrandPrize::VT_DISPLAYDISCRIPTION,
            displayDiscription,
        );
    }
    #[inline]
    pub fn add_bpLevelId(&mut self, bpLevelId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBPGrandPrize::VT_BPLEVELID,
            bpLevelId,
        );
    }
    #[inline]
    pub fn add_itemBundle(
        &mut self,
        itemBundle: flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ItemBundle>>(
                clz_Torappu_RoguelikeTopicBPGrandPrize::VT_ITEMBUNDLE,
                itemBundle,
            );
    }
    #[inline]
    pub fn add_detailAnnounceTime(&mut self, detailAnnounceTime: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBPGrandPrize::VT_DETAILANNOUNCETIME,
            detailAnnounceTime,
        );
    }
    #[inline]
    pub fn add_picIdAftrerUnlock(&mut self, picIdAftrerUnlock: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBPGrandPrize::VT_PICIDAFTRERUNLOCK,
            picIdAftrerUnlock,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicBPGrandPrizeBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicBPGrandPrizeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBPGrandPrize<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicBPGrandPrize<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicBPGrandPrize");
        ds.field("grandPrizeDisplayId", &self.grandPrizeDisplayId());
        ds.field("sortId", &self.sortId());
        ds.field("displayUnlockYear", &self.displayUnlockYear());
        ds.field("displayUnlockMonth", &self.displayUnlockMonth());
        ds.field("acquireTitle", &self.acquireTitle());
        ds.field("purchaseTitle", &self.purchaseTitle());
        ds.field("displayName", &self.displayName());
        ds.field("displayDiscription", &self.displayDiscription());
        ds.field("bpLevelId", &self.bpLevelId());
        ds.field("itemBundle", &self.itemBundle());
        ds.field("detailAnnounceTime", &self.detailAnnounceTime());
        ds.field("picIdAftrerUnlock", &self.picIdAftrerUnlock());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicBPGrandPrizeT {
    pub grandPrizeDisplayId: Option<String>,
    pub sortId: i32,
    pub displayUnlockYear: i32,
    pub displayUnlockMonth: i32,
    pub acquireTitle: Option<String>,
    pub purchaseTitle: Option<String>,
    pub displayName: Option<String>,
    pub displayDiscription: Option<String>,
    pub bpLevelId: Option<String>,
    pub itemBundle: Option<Box<clz_Torappu_ItemBundleT>>,
    pub detailAnnounceTime: Option<String>,
    pub picIdAftrerUnlock: Option<String>,
}
impl Default for clz_Torappu_RoguelikeTopicBPGrandPrizeT {
    fn default() -> Self {
        Self {
            grandPrizeDisplayId: None,
            sortId: 0,
            displayUnlockYear: 0,
            displayUnlockMonth: 0,
            acquireTitle: None,
            purchaseTitle: None,
            displayName: None,
            displayDiscription: None,
            bpLevelId: None,
            itemBundle: None,
            detailAnnounceTime: None,
            picIdAftrerUnlock: None,
        }
    }
}
impl clz_Torappu_RoguelikeTopicBPGrandPrizeT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBPGrandPrize<'b>> {
        let grandPrizeDisplayId = self
            .grandPrizeDisplayId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let displayUnlockYear = self.displayUnlockYear;
        let displayUnlockMonth = self.displayUnlockMonth;
        let acquireTitle = self.acquireTitle.as_ref().map(|x| _fbb.create_string(x));
        let purchaseTitle = self.purchaseTitle.as_ref().map(|x| _fbb.create_string(x));
        let displayName = self.displayName.as_ref().map(|x| _fbb.create_string(x));
        let displayDiscription = self
            .displayDiscription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let bpLevelId = self.bpLevelId.as_ref().map(|x| _fbb.create_string(x));
        let itemBundle = self.itemBundle.as_ref().map(|x| x.pack(_fbb));
        let detailAnnounceTime = self
            .detailAnnounceTime
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let picIdAftrerUnlock = self
            .picIdAftrerUnlock
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeTopicBPGrandPrize::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicBPGrandPrizeArgs {
                grandPrizeDisplayId,
                sortId,
                displayUnlockYear,
                displayUnlockMonth,
                acquireTitle,
                purchaseTitle,
                displayName,
                displayDiscription,
                bpLevelId,
                itemBundle,
                detailAnnounceTime,
                picIdAftrerUnlock,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicMonthMissionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicMonthMission<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicMonthMission<'a> {
    type Inner = clz_Torappu_RoguelikeTopicMonthMission<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicMonthMission<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TASKNAME: flatbuffers::VOffsetT = 6;
    pub const VT_TASKCLASS: flatbuffers::VOffsetT = 8;
    pub const VT_INNERCLASSWEIGHT: flatbuffers::VOffsetT = 10;
    pub const VT_TEMPLATE: flatbuffers::VOffsetT = 12;
    pub const VT_PARAMLIST: flatbuffers::VOffsetT = 14;
    pub const VT_DESC: flatbuffers::VOffsetT = 16;
    pub const VT_TOKENREWARDNUM: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicMonthMission { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicMonthMissionArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicMonthMission<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicMonthMissionBuilder::new(_fbb);
        builder.add_tokenRewardNum(args.tokenRewardNum);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.paramList {
            builder.add_paramList(x);
        }
        if let Some(x) = args.template {
            builder.add_template(x);
        }
        builder.add_innerClassWeight(args.innerClassWeight);
        builder.add_taskClass(args.taskClass);
        if let Some(x) = args.taskName {
            builder.add_taskName(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicMonthMissionT {
        let id = self.id().map(|x| x.to_string());
        let taskName = self.taskName().map(|x| x.to_string());
        let taskClass = self.taskClass();
        let innerClassWeight = self.innerClassWeight();
        let template = self.template().map(|x| x.to_string());
        let paramList = self
            .paramList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let desc = self.desc().map(|x| x.to_string());
        let tokenRewardNum = self.tokenRewardNum();
        clz_Torappu_RoguelikeTopicMonthMissionT {
            id,
            taskName,
            taskClass,
            innerClassWeight,
            template,
            paramList,
            desc,
            tokenRewardNum,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthMission::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn taskName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthMission::VT_TASKNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn taskClass(&self) -> enum__Torappu_RoguelikeGameMonthTaskClass {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeGameMonthTaskClass>(
                    clz_Torappu_RoguelikeTopicMonthMission::VT_TASKCLASS,
                    Some(enum__Torappu_RoguelikeGameMonthTaskClass::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn innerClassWeight(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicMonthMission::VT_INNERCLASSWEIGHT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn template(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthMission::VT_TEMPLATE,
                None,
            )
        }
    }
    #[inline]
    pub fn paramList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RoguelikeTopicMonthMission::VT_PARAMLIST, None)
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthMission::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn tokenRewardNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicMonthMission::VT_TOKENREWARDNUM,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicMonthMission<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "taskName",
                Self::VT_TASKNAME,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeGameMonthTaskClass>(
                "taskClass",
                Self::VT_TASKCLASS,
                false,
            )?
            .visit_field::<i32>("innerClassWeight", Self::VT_INNERCLASSWEIGHT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "template",
                Self::VT_TEMPLATE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("paramList", Self::VT_PARAMLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<i32>("tokenRewardNum", Self::VT_TOKENREWARDNUM, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicMonthMissionArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskClass: enum__Torappu_RoguelikeGameMonthTaskClass,
    pub innerClassWeight: i32,
    pub template: Option<flatbuffers::WIPOffset<&'a str>>,
    pub paramList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tokenRewardNum: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicMonthMissionArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicMonthMissionArgs {
            id: None,
            taskName: None,
            taskClass: enum__Torappu_RoguelikeGameMonthTaskClass::NONE,
            innerClassWeight: 0,
            template: None,
            paramList: None,
            desc: None,
            tokenRewardNum: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicMonthMission<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicMonthMission", 8)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.taskName() {
            s.serialize_field("taskName", &f)?;
        } else {
            s.skip_field("taskName")?;
        }
        s.serialize_field("taskClass", &self.taskClass())?;
        s.serialize_field("innerClassWeight", &self.innerClassWeight())?;
        if let Some(f) = self.template() {
            s.serialize_field("template", &f)?;
        } else {
            s.skip_field("template")?;
        }
        if let Some(f) = self.paramList() {
            s.serialize_field("paramList", &f)?;
        } else {
            s.skip_field("paramList")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.serialize_field("tokenRewardNum", &self.tokenRewardNum())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicMonthMissionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicMonthMissionBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthMission::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_taskName(&mut self, taskName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthMission::VT_TASKNAME,
            taskName,
        );
    }
    #[inline]
    pub fn add_taskClass(&mut self, taskClass: enum__Torappu_RoguelikeGameMonthTaskClass) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeGameMonthTaskClass>(
                clz_Torappu_RoguelikeTopicMonthMission::VT_TASKCLASS,
                taskClass,
                enum__Torappu_RoguelikeGameMonthTaskClass::NONE,
            );
    }
    #[inline]
    pub fn add_innerClassWeight(&mut self, innerClassWeight: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicMonthMission::VT_INNERCLASSWEIGHT,
            innerClassWeight,
            0,
        );
    }
    #[inline]
    pub fn add_template(&mut self, template: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthMission::VT_TEMPLATE,
            template,
        );
    }
    #[inline]
    pub fn add_paramList(
        &mut self,
        paramList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthMission::VT_PARAMLIST,
            paramList,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthMission::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_tokenRewardNum(&mut self, tokenRewardNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicMonthMission::VT_TOKENREWARDNUM,
            tokenRewardNum,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicMonthMissionBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicMonthMissionBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicMonthMission<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicMonthMission<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicMonthMission");
        ds.field("id", &self.id());
        ds.field("taskName", &self.taskName());
        ds.field("taskClass", &self.taskClass());
        ds.field("innerClassWeight", &self.innerClassWeight());
        ds.field("template", &self.template());
        ds.field("paramList", &self.paramList());
        ds.field("desc", &self.desc());
        ds.field("tokenRewardNum", &self.tokenRewardNum());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicMonthMissionT {
    pub id: Option<String>,
    pub taskName: Option<String>,
    pub taskClass: enum__Torappu_RoguelikeGameMonthTaskClass,
    pub innerClassWeight: i32,
    pub template: Option<String>,
    pub paramList: Option<Vec<String>>,
    pub desc: Option<String>,
    pub tokenRewardNum: i32,
}
impl Default for clz_Torappu_RoguelikeTopicMonthMissionT {
    fn default() -> Self {
        Self {
            id: None,
            taskName: None,
            taskClass: enum__Torappu_RoguelikeGameMonthTaskClass::NONE,
            innerClassWeight: 0,
            template: None,
            paramList: None,
            desc: None,
            tokenRewardNum: 0,
        }
    }
}
impl clz_Torappu_RoguelikeTopicMonthMissionT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicMonthMission<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let taskName = self.taskName.as_ref().map(|x| _fbb.create_string(x));
        let taskClass = self.taskClass;
        let innerClassWeight = self.innerClassWeight;
        let template = self.template.as_ref().map(|x| _fbb.create_string(x));
        let paramList = self.paramList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let tokenRewardNum = self.tokenRewardNum;
        clz_Torappu_RoguelikeTopicMonthMission::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicMonthMissionArgs {
                id,
                taskName,
                taskClass,
                innerClassWeight,
                template,
                paramList,
                desc,
                tokenRewardNum,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicMonthSquadTeamCharOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicMonthSquadTeamChar<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicMonthSquadTeamChar<'a> {
    type Inner = clz_Torappu_RoguelikeTopicMonthSquadTeamChar<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicMonthSquadTeamChar<'a> {
    pub const VT_TEAMCHARID: flatbuffers::VOffsetT = 4;
    pub const VT_TEAMTMPLID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicMonthSquadTeamChar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicMonthSquadTeamCharArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicMonthSquadTeamChar<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicMonthSquadTeamCharBuilder::new(_fbb);
        if let Some(x) = args.teamTmplId {
            builder.add_teamTmplId(x);
        }
        if let Some(x) = args.teamCharId {
            builder.add_teamCharId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicMonthSquadTeamCharT {
        let teamCharId = self.teamCharId().map(|x| x.to_string());
        let teamTmplId = self.teamTmplId().map(|x| x.to_string());
        clz_Torappu_RoguelikeTopicMonthSquadTeamCharT {
            teamCharId,
            teamTmplId,
        }
    }

    #[inline]
    pub fn teamCharId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthSquadTeamChar::VT_TEAMCHARID,
                None,
            )
        }
    }
    #[inline]
    pub fn teamTmplId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthSquadTeamChar::VT_TEAMTMPLID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicMonthSquadTeamChar<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamCharId",
                Self::VT_TEAMCHARID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamTmplId",
                Self::VT_TEAMTMPLID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicMonthSquadTeamCharArgs<'a> {
    pub teamCharId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamTmplId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicMonthSquadTeamCharArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicMonthSquadTeamCharArgs {
            teamCharId: None,
            teamTmplId: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicMonthSquadTeamChar<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeTopicMonthSquadTeamChar", 2)?;
        if let Some(f) = self.teamCharId() {
            s.serialize_field("teamCharId", &f)?;
        } else {
            s.skip_field("teamCharId")?;
        }
        if let Some(f) = self.teamTmplId() {
            s.serialize_field("teamTmplId", &f)?;
        } else {
            s.skip_field("teamTmplId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicMonthSquadTeamCharBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicMonthSquadTeamCharBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_teamCharId(&mut self, teamCharId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquadTeamChar::VT_TEAMCHARID,
            teamCharId,
        );
    }
    #[inline]
    pub fn add_teamTmplId(&mut self, teamTmplId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquadTeamChar::VT_TEAMTMPLID,
            teamTmplId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicMonthSquadTeamCharBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicMonthSquadTeamCharBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicMonthSquadTeamChar<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicMonthSquadTeamChar<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicMonthSquadTeamChar");
        ds.field("teamCharId", &self.teamCharId());
        ds.field("teamTmplId", &self.teamTmplId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicMonthSquadTeamCharT {
    pub teamCharId: Option<String>,
    pub teamTmplId: Option<String>,
}
impl Default for clz_Torappu_RoguelikeTopicMonthSquadTeamCharT {
    fn default() -> Self {
        Self {
            teamCharId: None,
            teamTmplId: None,
        }
    }
}
impl clz_Torappu_RoguelikeTopicMonthSquadTeamCharT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicMonthSquadTeamChar<'b>> {
        let teamCharId = self.teamCharId.as_ref().map(|x| _fbb.create_string(x));
        let teamTmplId = self.teamTmplId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeTopicMonthSquadTeamChar::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicMonthSquadTeamCharArgs {
                teamCharId,
                teamTmplId,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicMonthSquadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicMonthSquad<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicMonthSquad<'a> {
    type Inner = clz_Torappu_RoguelikeTopicMonthSquad<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicMonthSquad<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TEAMNAME: flatbuffers::VOffsetT = 6;
    pub const VT_TEAMSUBNAME: flatbuffers::VOffsetT = 8;
    pub const VT_TEAMFLAVORDESC: flatbuffers::VOffsetT = 10;
    pub const VT_TEAMDES: flatbuffers::VOffsetT = 12;
    pub const VT_TEAMCOLOR: flatbuffers::VOffsetT = 14;
    pub const VT_TEAMMONTH: flatbuffers::VOffsetT = 16;
    pub const VT_TEAMYEAR: flatbuffers::VOffsetT = 18;
    pub const VT_TEAMINDEX: flatbuffers::VOffsetT = 20;
    pub const VT_TEAMCHARS: flatbuffers::VOffsetT = 22;
    pub const VT_ZONEID: flatbuffers::VOffsetT = 24;
    pub const VT_CHATID: flatbuffers::VOffsetT = 26;
    pub const VT_TOKENREWARDNUM: flatbuffers::VOffsetT = 28;
    pub const VT_ITEMS: flatbuffers::VOffsetT = 30;
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 32;
    pub const VT_ENDTIME: flatbuffers::VOffsetT = 34;
    pub const VT_TASKDES: flatbuffers::VOffsetT = 36;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicMonthSquad { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicMonthSquadArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicMonthSquad<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicMonthSquadBuilder::new(_fbb);
        builder.add_endTime(args.endTime);
        builder.add_startTime(args.startTime);
        if let Some(x) = args.taskDes {
            builder.add_taskDes(x);
        }
        if let Some(x) = args.items {
            builder.add_items(x);
        }
        builder.add_tokenRewardNum(args.tokenRewardNum);
        if let Some(x) = args.chatId {
            builder.add_chatId(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        if let Some(x) = args.teamChars {
            builder.add_teamChars(x);
        }
        if let Some(x) = args.teamIndex {
            builder.add_teamIndex(x);
        }
        if let Some(x) = args.teamYear {
            builder.add_teamYear(x);
        }
        if let Some(x) = args.teamMonth {
            builder.add_teamMonth(x);
        }
        if let Some(x) = args.teamColor {
            builder.add_teamColor(x);
        }
        if let Some(x) = args.teamDes {
            builder.add_teamDes(x);
        }
        if let Some(x) = args.teamFlavorDesc {
            builder.add_teamFlavorDesc(x);
        }
        if let Some(x) = args.teamSubName {
            builder.add_teamSubName(x);
        }
        if let Some(x) = args.teamName {
            builder.add_teamName(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicMonthSquadT {
        let id = self.id().map(|x| x.to_string());
        let teamName = self.teamName().map(|x| x.to_string());
        let teamSubName = self.teamSubName().map(|x| x.to_string());
        let teamFlavorDesc = self.teamFlavorDesc().map(|x| x.to_string());
        let teamDes = self.teamDes().map(|x| x.to_string());
        let teamColor = self.teamColor().map(|x| x.to_string());
        let teamMonth = self.teamMonth().map(|x| x.to_string());
        let teamYear = self.teamYear().map(|x| x.to_string());
        let teamIndex = self.teamIndex().map(|x| x.to_string());
        let teamChars = self
            .teamChars()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let zoneId = self.zoneId().map(|x| x.to_string());
        let chatId = self.chatId().map(|x| x.to_string());
        let tokenRewardNum = self.tokenRewardNum();
        let items = self.items().map(|x| x.iter().map(|t| t.unpack()).collect());
        let startTime = self.startTime();
        let endTime = self.endTime();
        let taskDes = self.taskDes().map(|x| x.to_string());
        clz_Torappu_RoguelikeTopicMonthSquadT {
            id,
            teamName,
            teamSubName,
            teamFlavorDesc,
            teamDes,
            teamColor,
            teamMonth,
            teamYear,
            teamIndex,
            teamChars,
            zoneId,
            chatId,
            tokenRewardNum,
            items,
            startTime,
            endTime,
            taskDes,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthSquad::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn teamName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn teamSubName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMSUBNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn teamFlavorDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMFLAVORDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn teamDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMDES,
                None,
            )
        }
    }
    #[inline]
    pub fn teamColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMCOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn teamMonth(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMMONTH,
                None,
            )
        }
    }
    #[inline]
    pub fn teamYear(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMYEAR,
                None,
            )
        }
    }
    #[inline]
    pub fn teamIndex(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMINDEX,
                None,
            )
        }
    }
    #[inline]
    pub fn teamChars(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMonthSquadTeamChar<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMonthSquadTeamChar>,
                >,
            >>(clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMCHARS, None)
        }
    }
    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthSquad::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn chatId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthSquad::VT_CHATID,
                None,
            )
        }
    }
    #[inline]
    pub fn tokenRewardNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicMonthSquad::VT_TOKENREWARDNUM,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn items(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_RoguelikeTopicMonthSquad::VT_ITEMS, None)
        }
    }
    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_RoguelikeTopicMonthSquad::VT_STARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_RoguelikeTopicMonthSquad::VT_ENDTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn taskDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicMonthSquad::VT_TASKDES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicMonthSquad<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamName",
                Self::VT_TEAMNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamSubName",
                Self::VT_TEAMSUBNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamFlavorDesc",
                Self::VT_TEAMFLAVORDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("teamDes", Self::VT_TEAMDES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamColor",
                Self::VT_TEAMCOLOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamMonth",
                Self::VT_TEAMMONTH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamYear",
                Self::VT_TEAMYEAR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "teamIndex",
                Self::VT_TEAMINDEX,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMonthSquadTeamChar>,
                >,
            >>("teamChars", Self::VT_TEAMCHARS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("chatId", Self::VT_CHATID, false)?
            .visit_field::<i32>("tokenRewardNum", Self::VT_TOKENREWARDNUM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("items", Self::VT_ITEMS, false)?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<i64>("endTime", Self::VT_ENDTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskDes", Self::VT_TASKDES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicMonthSquadArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamSubName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamFlavorDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamMonth: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamYear: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamIndex: Option<flatbuffers::WIPOffset<&'a str>>,
    pub teamChars: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMonthSquadTeamChar<'a>>,
            >,
        >,
    >,
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub chatId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tokenRewardNum: i32,
    pub items: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
    pub startTime: i64,
    pub endTime: i64,
    pub taskDes: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicMonthSquadArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicMonthSquadArgs {
            id: None,
            teamName: None,
            teamSubName: None,
            teamFlavorDesc: None,
            teamDes: None,
            teamColor: None,
            teamMonth: None,
            teamYear: None,
            teamIndex: None,
            teamChars: None,
            zoneId: None,
            chatId: None,
            tokenRewardNum: 0,
            items: None,
            startTime: 0,
            endTime: 0,
            taskDes: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicMonthSquad<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicMonthSquad", 17)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.teamName() {
            s.serialize_field("teamName", &f)?;
        } else {
            s.skip_field("teamName")?;
        }
        if let Some(f) = self.teamSubName() {
            s.serialize_field("teamSubName", &f)?;
        } else {
            s.skip_field("teamSubName")?;
        }
        if let Some(f) = self.teamFlavorDesc() {
            s.serialize_field("teamFlavorDesc", &f)?;
        } else {
            s.skip_field("teamFlavorDesc")?;
        }
        if let Some(f) = self.teamDes() {
            s.serialize_field("teamDes", &f)?;
        } else {
            s.skip_field("teamDes")?;
        }
        if let Some(f) = self.teamColor() {
            s.serialize_field("teamColor", &f)?;
        } else {
            s.skip_field("teamColor")?;
        }
        if let Some(f) = self.teamMonth() {
            s.serialize_field("teamMonth", &f)?;
        } else {
            s.skip_field("teamMonth")?;
        }
        if let Some(f) = self.teamYear() {
            s.serialize_field("teamYear", &f)?;
        } else {
            s.skip_field("teamYear")?;
        }
        if let Some(f) = self.teamIndex() {
            s.serialize_field("teamIndex", &f)?;
        } else {
            s.skip_field("teamIndex")?;
        }
        if let Some(f) = self.teamChars() {
            s.serialize_field("teamChars", &f)?;
        } else {
            s.skip_field("teamChars")?;
        }
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.chatId() {
            s.serialize_field("chatId", &f)?;
        } else {
            s.skip_field("chatId")?;
        }
        s.serialize_field("tokenRewardNum", &self.tokenRewardNum())?;
        if let Some(f) = self.items() {
            s.serialize_field("items", &f)?;
        } else {
            s.skip_field("items")?;
        }
        s.serialize_field("startTime", &self.startTime())?;
        s.serialize_field("endTime", &self.endTime())?;
        if let Some(f) = self.taskDes() {
            s.serialize_field("taskDes", &f)?;
        } else {
            s.skip_field("taskDes")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicMonthSquadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicMonthSquadBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_teamName(&mut self, teamName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMNAME,
            teamName,
        );
    }
    #[inline]
    pub fn add_teamSubName(&mut self, teamSubName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMSUBNAME,
            teamSubName,
        );
    }
    #[inline]
    pub fn add_teamFlavorDesc(&mut self, teamFlavorDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMFLAVORDESC,
            teamFlavorDesc,
        );
    }
    #[inline]
    pub fn add_teamDes(&mut self, teamDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMDES,
            teamDes,
        );
    }
    #[inline]
    pub fn add_teamColor(&mut self, teamColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMCOLOR,
            teamColor,
        );
    }
    #[inline]
    pub fn add_teamMonth(&mut self, teamMonth: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMMONTH,
            teamMonth,
        );
    }
    #[inline]
    pub fn add_teamYear(&mut self, teamYear: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMYEAR,
            teamYear,
        );
    }
    #[inline]
    pub fn add_teamIndex(&mut self, teamIndex: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMINDEX,
            teamIndex,
        );
    }
    #[inline]
    pub fn add_teamChars(
        &mut self,
        teamChars: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMonthSquadTeamChar<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_TEAMCHARS,
            teamChars,
        );
    }
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_chatId(&mut self, chatId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_CHATID,
            chatId,
        );
    }
    #[inline]
    pub fn add_tokenRewardNum(&mut self, tokenRewardNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_TOKENREWARDNUM,
            tokenRewardNum,
            0,
        );
    }
    #[inline]
    pub fn add_items(
        &mut self,
        items: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_ITEMS,
            items,
        );
    }
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_STARTTIME,
            startTime,
            0,
        );
    }
    #[inline]
    pub fn add_endTime(&mut self, endTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_RoguelikeTopicMonthSquad::VT_ENDTIME, endTime, 0);
    }
    #[inline]
    pub fn add_taskDes(&mut self, taskDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicMonthSquad::VT_TASKDES,
            taskDes,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicMonthSquadBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicMonthSquadBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicMonthSquad<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicMonthSquad<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicMonthSquad");
        ds.field("id", &self.id());
        ds.field("teamName", &self.teamName());
        ds.field("teamSubName", &self.teamSubName());
        ds.field("teamFlavorDesc", &self.teamFlavorDesc());
        ds.field("teamDes", &self.teamDes());
        ds.field("teamColor", &self.teamColor());
        ds.field("teamMonth", &self.teamMonth());
        ds.field("teamYear", &self.teamYear());
        ds.field("teamIndex", &self.teamIndex());
        ds.field("teamChars", &self.teamChars());
        ds.field("zoneId", &self.zoneId());
        ds.field("chatId", &self.chatId());
        ds.field("tokenRewardNum", &self.tokenRewardNum());
        ds.field("items", &self.items());
        ds.field("startTime", &self.startTime());
        ds.field("endTime", &self.endTime());
        ds.field("taskDes", &self.taskDes());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicMonthSquadT {
    pub id: Option<String>,
    pub teamName: Option<String>,
    pub teamSubName: Option<String>,
    pub teamFlavorDesc: Option<String>,
    pub teamDes: Option<String>,
    pub teamColor: Option<String>,
    pub teamMonth: Option<String>,
    pub teamYear: Option<String>,
    pub teamIndex: Option<String>,
    pub teamChars: Option<Vec<clz_Torappu_RoguelikeTopicMonthSquadTeamCharT>>,
    pub zoneId: Option<String>,
    pub chatId: Option<String>,
    pub tokenRewardNum: i32,
    pub items: Option<Vec<clz_Torappu_ItemBundleT>>,
    pub startTime: i64,
    pub endTime: i64,
    pub taskDes: Option<String>,
}
impl Default for clz_Torappu_RoguelikeTopicMonthSquadT {
    fn default() -> Self {
        Self {
            id: None,
            teamName: None,
            teamSubName: None,
            teamFlavorDesc: None,
            teamDes: None,
            teamColor: None,
            teamMonth: None,
            teamYear: None,
            teamIndex: None,
            teamChars: None,
            zoneId: None,
            chatId: None,
            tokenRewardNum: 0,
            items: None,
            startTime: 0,
            endTime: 0,
            taskDes: None,
        }
    }
}
impl clz_Torappu_RoguelikeTopicMonthSquadT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicMonthSquad<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let teamName = self.teamName.as_ref().map(|x| _fbb.create_string(x));
        let teamSubName = self.teamSubName.as_ref().map(|x| _fbb.create_string(x));
        let teamFlavorDesc = self.teamFlavorDesc.as_ref().map(|x| _fbb.create_string(x));
        let teamDes = self.teamDes.as_ref().map(|x| _fbb.create_string(x));
        let teamColor = self.teamColor.as_ref().map(|x| _fbb.create_string(x));
        let teamMonth = self.teamMonth.as_ref().map(|x| _fbb.create_string(x));
        let teamYear = self.teamYear.as_ref().map(|x| _fbb.create_string(x));
        let teamIndex = self.teamIndex.as_ref().map(|x| _fbb.create_string(x));
        let teamChars = self.teamChars.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let chatId = self.chatId.as_ref().map(|x| _fbb.create_string(x));
        let tokenRewardNum = self.tokenRewardNum;
        let items = self.items.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let startTime = self.startTime;
        let endTime = self.endTime;
        let taskDes = self.taskDes.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeTopicMonthSquad::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicMonthSquadArgs {
                id,
                teamName,
                teamSubName,
                teamFlavorDesc,
                teamDes,
                teamColor,
                teamMonth,
                teamYear,
                teamIndex,
                teamChars,
                zoneId,
                chatId,
                tokenRewardNum,
                items,
                startTime,
                endTime,
                taskDes,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeTopicMonthSquadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeTopicMonthSquad<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeTopicMonthSquad<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeTopicMonthSquad<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeTopicMonthSquad<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeTopicMonthSquad { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeTopicMonthSquadArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicMonthSquad<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeTopicMonthSquadBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeTopicMonthSquadT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeTopicMonthSquadT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeTopicMonthSquad::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeTopicMonthSquad,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeTopicMonthSquad<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMonthSquad>>(
                    dict__string__clz_Torappu_RoguelikeTopicMonthSquad::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeTopicMonthSquad<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMonthSquad>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeTopicMonthSquadArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicMonthSquad<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeTopicMonthSquadArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeTopicMonthSquadArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeTopicMonthSquad<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeTopicMonthSquad", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeTopicMonthSquadBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeTopicMonthSquadBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeTopicMonthSquad::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicMonthSquad<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicMonthSquad>>(
                dict__string__clz_Torappu_RoguelikeTopicMonthSquad::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeTopicMonthSquadBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeTopicMonthSquadBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicMonthSquad<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeTopicMonthSquad::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeTopicMonthSquad<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeTopicMonthSquad");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeTopicMonthSquadT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeTopicMonthSquadT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeTopicMonthSquadT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeTopicMonthSquadT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicMonthSquad<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeTopicMonthSquad::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeTopicMonthSquadArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicChallengeTaskOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicChallengeTask<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicChallengeTask<'a> {
    type Inner = clz_Torappu_RoguelikeTopicChallengeTask<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicChallengeTask<'a> {
    pub const VT_TASKID: flatbuffers::VOffsetT = 4;
    pub const VT_TASKDES: flatbuffers::VOffsetT = 6;
    pub const VT_COMPLETIONCLASS: flatbuffers::VOffsetT = 8;
    pub const VT_COMPLETIONPARAMS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicChallengeTask { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicChallengeTaskArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicChallengeTask<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicChallengeTaskBuilder::new(_fbb);
        if let Some(x) = args.completionParams {
            builder.add_completionParams(x);
        }
        if let Some(x) = args.completionClass {
            builder.add_completionClass(x);
        }
        if let Some(x) = args.taskDes {
            builder.add_taskDes(x);
        }
        if let Some(x) = args.taskId {
            builder.add_taskId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicChallengeTaskT {
        let taskId = self.taskId().map(|x| x.to_string());
        let taskDes = self.taskDes().map(|x| x.to_string());
        let completionClass = self.completionClass().map(|x| x.to_string());
        let completionParams = self
            .completionParams()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_RoguelikeTopicChallengeTaskT {
            taskId,
            taskDes,
            completionClass,
            completionParams,
        }
    }

    #[inline]
    pub fn taskId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicChallengeTask::VT_TASKID,
                None,
            )
        }
    }
    #[inline]
    pub fn taskDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicChallengeTask::VT_TASKDES,
                None,
            )
        }
    }
    #[inline]
    pub fn completionClass(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicChallengeTask::VT_COMPLETIONCLASS,
                None,
            )
        }
    }
    #[inline]
    pub fn completionParams(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RoguelikeTopicChallengeTask::VT_COMPLETIONPARAMS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicChallengeTask<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskId", Self::VT_TASKID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskDes", Self::VT_TASKDES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "completionClass",
                Self::VT_COMPLETIONCLASS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("completionParams", Self::VT_COMPLETIONPARAMS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicChallengeTaskArgs<'a> {
    pub taskId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub completionClass: Option<flatbuffers::WIPOffset<&'a str>>,
    pub completionParams: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicChallengeTaskArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicChallengeTaskArgs {
            taskId: None,
            taskDes: None,
            completionClass: None,
            completionParams: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicChallengeTask<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicChallengeTask", 4)?;
        if let Some(f) = self.taskId() {
            s.serialize_field("taskId", &f)?;
        } else {
            s.skip_field("taskId")?;
        }
        if let Some(f) = self.taskDes() {
            s.serialize_field("taskDes", &f)?;
        } else {
            s.skip_field("taskDes")?;
        }
        if let Some(f) = self.completionClass() {
            s.serialize_field("completionClass", &f)?;
        } else {
            s.skip_field("completionClass")?;
        }
        if let Some(f) = self.completionParams() {
            s.serialize_field("completionParams", &f)?;
        } else {
            s.skip_field("completionParams")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicChallengeTaskBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicChallengeTaskBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_taskId(&mut self, taskId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicChallengeTask::VT_TASKID,
            taskId,
        );
    }
    #[inline]
    pub fn add_taskDes(&mut self, taskDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicChallengeTask::VT_TASKDES,
            taskDes,
        );
    }
    #[inline]
    pub fn add_completionClass(&mut self, completionClass: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicChallengeTask::VT_COMPLETIONCLASS,
            completionClass,
        );
    }
    #[inline]
    pub fn add_completionParams(
        &mut self,
        completionParams: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicChallengeTask::VT_COMPLETIONPARAMS,
            completionParams,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicChallengeTaskBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicChallengeTaskBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicChallengeTask<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicChallengeTask<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicChallengeTask");
        ds.field("taskId", &self.taskId());
        ds.field("taskDes", &self.taskDes());
        ds.field("completionClass", &self.completionClass());
        ds.field("completionParams", &self.completionParams());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicChallengeTaskT {
    pub taskId: Option<String>,
    pub taskDes: Option<String>,
    pub completionClass: Option<String>,
    pub completionParams: Option<Vec<String>>,
}
impl Default for clz_Torappu_RoguelikeTopicChallengeTaskT {
    fn default() -> Self {
        Self {
            taskId: None,
            taskDes: None,
            completionClass: None,
            completionParams: None,
        }
    }
}
impl clz_Torappu_RoguelikeTopicChallengeTaskT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicChallengeTask<'b>> {
        let taskId = self.taskId.as_ref().map(|x| _fbb.create_string(x));
        let taskDes = self.taskDes.as_ref().map(|x| _fbb.create_string(x));
        let completionClass = self.completionClass.as_ref().map(|x| _fbb.create_string(x));
        let completionParams = self.completionParams.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeTopicChallengeTask::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicChallengeTaskArgs {
                taskId,
                taskDes,
                completionClass,
                completionParams,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeTopicChallengeTaskOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeTopicChallengeTask<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeTopicChallengeTask<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeTopicChallengeTask<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeTopicChallengeTask<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeTopicChallengeTask { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeTopicChallengeTaskArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicChallengeTask<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeTopicChallengeTaskBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeTopicChallengeTaskT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeTopicChallengeTaskT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeTopicChallengeTask::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeTopicChallengeTask,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeTopicChallengeTask<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicChallengeTask>>(
                    dict__string__clz_Torappu_RoguelikeTopicChallengeTask::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeTopicChallengeTask<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicChallengeTask>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeTopicChallengeTaskArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicChallengeTask<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeTopicChallengeTaskArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeTopicChallengeTaskArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeTopicChallengeTask<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeTopicChallengeTask", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeTopicChallengeTaskBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeTopicChallengeTaskBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeTopicChallengeTask::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicChallengeTask<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicChallengeTask>>(
                dict__string__clz_Torappu_RoguelikeTopicChallengeTask::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeTopicChallengeTaskBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeTopicChallengeTaskBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicChallengeTask<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeTopicChallengeTask::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeTopicChallengeTask<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeTopicChallengeTask");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeTopicChallengeTaskT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeTopicChallengeTaskT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeTopicChallengeTaskT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeTopicChallengeTaskT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicChallengeTask<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeTopicChallengeTask::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeTopicChallengeTaskArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicChallengeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicChallenge<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicChallenge<'a> {
    type Inner = clz_Torappu_RoguelikeTopicChallenge<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicChallenge<'a> {
    pub const VT_CHALLENGEID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_CHALLENGENAME: flatbuffers::VOffsetT = 8;
    pub const VT_CHALLENGEGROUP: flatbuffers::VOffsetT = 10;
    pub const VT_CHALLENGEGROUPSORTID: flatbuffers::VOffsetT = 12;
    pub const VT_CHALLENGEGROUPNAME: flatbuffers::VOffsetT = 14;
    pub const VT_CHALLENGEUNLOCKDESC: flatbuffers::VOffsetT = 16;
    pub const VT_CHALLENGEUNLOCKTOASTDESC: flatbuffers::VOffsetT = 18;
    pub const VT_CHALLENGEDES: flatbuffers::VOffsetT = 20;
    pub const VT_CHALLENGECONDITIONDES: flatbuffers::VOffsetT = 22;
    pub const VT_CHALLENGETASKS: flatbuffers::VOffsetT = 24;
    pub const VT_DEFAULTTASKID: flatbuffers::VOffsetT = 26;
    pub const VT_REWARDS: flatbuffers::VOffsetT = 28;
    pub const VT_CHALLENGESTORYID: flatbuffers::VOffsetT = 30;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicChallenge { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicChallengeArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicChallenge<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicChallengeBuilder::new(_fbb);
        if let Some(x) = args.challengeStoryId {
            builder.add_challengeStoryId(x);
        }
        if let Some(x) = args.rewards {
            builder.add_rewards(x);
        }
        if let Some(x) = args.defaultTaskId {
            builder.add_defaultTaskId(x);
        }
        if let Some(x) = args.challengeTasks {
            builder.add_challengeTasks(x);
        }
        if let Some(x) = args.challengeConditionDes {
            builder.add_challengeConditionDes(x);
        }
        if let Some(x) = args.challengeDes {
            builder.add_challengeDes(x);
        }
        if let Some(x) = args.challengeUnlockToastDesc {
            builder.add_challengeUnlockToastDesc(x);
        }
        if let Some(x) = args.challengeUnlockDesc {
            builder.add_challengeUnlockDesc(x);
        }
        if let Some(x) = args.challengeGroupName {
            builder.add_challengeGroupName(x);
        }
        builder.add_challengeGroupSortId(args.challengeGroupSortId);
        builder.add_challengeGroup(args.challengeGroup);
        if let Some(x) = args.challengeName {
            builder.add_challengeName(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.challengeId {
            builder.add_challengeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicChallengeT {
        let challengeId = self.challengeId().map(|x| x.to_string());
        let sortId = self.sortId();
        let challengeName = self.challengeName().map(|x| x.to_string());
        let challengeGroup = self.challengeGroup();
        let challengeGroupSortId = self.challengeGroupSortId();
        let challengeGroupName = self.challengeGroupName().map(|x| x.to_string());
        let challengeUnlockDesc = self.challengeUnlockDesc().map(|x| x.to_string());
        let challengeUnlockToastDesc = self.challengeUnlockToastDesc().map(|x| x.to_string());
        let challengeDes = self.challengeDes().map(|x| x.to_string());
        let challengeConditionDes = self
            .challengeConditionDes()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let challengeTasks = self
            .challengeTasks()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let defaultTaskId = self.defaultTaskId().map(|x| x.to_string());
        let rewards = self
            .rewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let challengeStoryId = self.challengeStoryId().map(|x| x.to_string());
        clz_Torappu_RoguelikeTopicChallengeT {
            challengeId,
            sortId,
            challengeName,
            challengeGroup,
            challengeGroupSortId,
            challengeGroupName,
            challengeUnlockDesc,
            challengeUnlockToastDesc,
            challengeDes,
            challengeConditionDes,
            challengeTasks,
            defaultTaskId,
            rewards,
            challengeStoryId,
        }
    }

    #[inline]
    pub fn challengeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicChallenge::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn challengeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn challengeGroup(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGEGROUP,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn challengeGroupSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGEGROUPSORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn challengeGroupName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGEGROUPNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn challengeUnlockDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGEUNLOCKDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn challengeUnlockToastDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGEUNLOCKTOASTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn challengeDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGEDES,
                None,
            )
        }
    }
    #[inline]
    pub fn challengeConditionDes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGECONDITIONDES,
                None,
            )
        }
    }
    #[inline]
    pub fn challengeTasks(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicChallengeTask<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeTopicChallengeTask,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGETASKS, None)
        }
    }
    #[inline]
    pub fn defaultTaskId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicChallenge::VT_DEFAULTTASKID,
                None,
            )
        }
    }
    #[inline]
    pub fn rewards(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_RoguelikeTopicChallenge::VT_REWARDS, None)
        }
    }
    #[inline]
    pub fn challengeStoryId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGESTORYID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicChallenge<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "challengeId",
                Self::VT_CHALLENGEID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "challengeName",
                Self::VT_CHALLENGENAME,
                false,
            )?
            .visit_field::<i32>("challengeGroup", Self::VT_CHALLENGEGROUP, false)?
            .visit_field::<i32>("challengeGroupSortId", Self::VT_CHALLENGEGROUPSORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "challengeGroupName",
                Self::VT_CHALLENGEGROUPNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "challengeUnlockDesc",
                Self::VT_CHALLENGEUNLOCKDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "challengeUnlockToastDesc",
                Self::VT_CHALLENGEUNLOCKTOASTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "challengeDes",
                Self::VT_CHALLENGEDES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "challengeConditionDes",
                Self::VT_CHALLENGECONDITIONDES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeTopicChallengeTask,
                    >,
                >,
            >>("challengeTasks", Self::VT_CHALLENGETASKS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "defaultTaskId",
                Self::VT_DEFAULTTASKID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("rewards", Self::VT_REWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "challengeStoryId",
                Self::VT_CHALLENGESTORYID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicChallengeArgs<'a> {
    pub challengeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub challengeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub challengeGroup: i32,
    pub challengeGroupSortId: i32,
    pub challengeGroupName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub challengeUnlockDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub challengeUnlockToastDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub challengeDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub challengeConditionDes: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub challengeTasks: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeTopicChallengeTask<'a>,
                >,
            >,
        >,
    >,
    pub defaultTaskId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
    pub challengeStoryId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicChallengeArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicChallengeArgs {
            challengeId: None,
            sortId: 0,
            challengeName: None,
            challengeGroup: 0,
            challengeGroupSortId: 0,
            challengeGroupName: None,
            challengeUnlockDesc: None,
            challengeUnlockToastDesc: None,
            challengeDes: None,
            challengeConditionDes: None,
            challengeTasks: None,
            defaultTaskId: None,
            rewards: None,
            challengeStoryId: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicChallenge<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicChallenge", 14)?;
        if let Some(f) = self.challengeId() {
            s.serialize_field("challengeId", &f)?;
        } else {
            s.skip_field("challengeId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.challengeName() {
            s.serialize_field("challengeName", &f)?;
        } else {
            s.skip_field("challengeName")?;
        }
        s.serialize_field("challengeGroup", &self.challengeGroup())?;
        s.serialize_field("challengeGroupSortId", &self.challengeGroupSortId())?;
        if let Some(f) = self.challengeGroupName() {
            s.serialize_field("challengeGroupName", &f)?;
        } else {
            s.skip_field("challengeGroupName")?;
        }
        if let Some(f) = self.challengeUnlockDesc() {
            s.serialize_field("challengeUnlockDesc", &f)?;
        } else {
            s.skip_field("challengeUnlockDesc")?;
        }
        if let Some(f) = self.challengeUnlockToastDesc() {
            s.serialize_field("challengeUnlockToastDesc", &f)?;
        } else {
            s.skip_field("challengeUnlockToastDesc")?;
        }
        if let Some(f) = self.challengeDes() {
            s.serialize_field("challengeDes", &f)?;
        } else {
            s.skip_field("challengeDes")?;
        }
        if let Some(f) = self.challengeConditionDes() {
            s.serialize_field("challengeConditionDes", &f)?;
        } else {
            s.skip_field("challengeConditionDes")?;
        }
        if let Some(f) = self.challengeTasks() {
            s.serialize_field("challengeTasks", &f)?;
        } else {
            s.skip_field("challengeTasks")?;
        }
        if let Some(f) = self.defaultTaskId() {
            s.serialize_field("defaultTaskId", &f)?;
        } else {
            s.skip_field("defaultTaskId")?;
        }
        if let Some(f) = self.rewards() {
            s.serialize_field("rewards", &f)?;
        } else {
            s.skip_field("rewards")?;
        }
        if let Some(f) = self.challengeStoryId() {
            s.serialize_field("challengeStoryId", &f)?;
        } else {
            s.skip_field("challengeStoryId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicChallengeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicChallengeBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_challengeId(&mut self, challengeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGEID,
            challengeId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeTopicChallenge::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_challengeName(&mut self, challengeName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGENAME,
            challengeName,
        );
    }
    #[inline]
    pub fn add_challengeGroup(&mut self, challengeGroup: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGEGROUP,
            challengeGroup,
            0,
        );
    }
    #[inline]
    pub fn add_challengeGroupSortId(&mut self, challengeGroupSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGEGROUPSORTID,
            challengeGroupSortId,
            0,
        );
    }
    #[inline]
    pub fn add_challengeGroupName(&mut self, challengeGroupName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGEGROUPNAME,
            challengeGroupName,
        );
    }
    #[inline]
    pub fn add_challengeUnlockDesc(
        &mut self,
        challengeUnlockDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGEUNLOCKDESC,
            challengeUnlockDesc,
        );
    }
    #[inline]
    pub fn add_challengeUnlockToastDesc(
        &mut self,
        challengeUnlockToastDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGEUNLOCKTOASTDESC,
            challengeUnlockToastDesc,
        );
    }
    #[inline]
    pub fn add_challengeDes(&mut self, challengeDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGEDES,
            challengeDes,
        );
    }
    #[inline]
    pub fn add_challengeConditionDes(
        &mut self,
        challengeConditionDes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGECONDITIONDES,
            challengeConditionDes,
        );
    }
    #[inline]
    pub fn add_challengeTasks(
        &mut self,
        challengeTasks: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeTopicChallengeTask<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGETASKS,
            challengeTasks,
        );
    }
    #[inline]
    pub fn add_defaultTaskId(&mut self, defaultTaskId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicChallenge::VT_DEFAULTTASKID,
            defaultTaskId,
        );
    }
    #[inline]
    pub fn add_rewards(
        &mut self,
        rewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicChallenge::VT_REWARDS,
            rewards,
        );
    }
    #[inline]
    pub fn add_challengeStoryId(&mut self, challengeStoryId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicChallenge::VT_CHALLENGESTORYID,
            challengeStoryId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicChallengeBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicChallengeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicChallenge<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicChallenge<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicChallenge");
        ds.field("challengeId", &self.challengeId());
        ds.field("sortId", &self.sortId());
        ds.field("challengeName", &self.challengeName());
        ds.field("challengeGroup", &self.challengeGroup());
        ds.field("challengeGroupSortId", &self.challengeGroupSortId());
        ds.field("challengeGroupName", &self.challengeGroupName());
        ds.field("challengeUnlockDesc", &self.challengeUnlockDesc());
        ds.field("challengeUnlockToastDesc", &self.challengeUnlockToastDesc());
        ds.field("challengeDes", &self.challengeDes());
        ds.field("challengeConditionDes", &self.challengeConditionDes());
        ds.field("challengeTasks", &self.challengeTasks());
        ds.field("defaultTaskId", &self.defaultTaskId());
        ds.field("rewards", &self.rewards());
        ds.field("challengeStoryId", &self.challengeStoryId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicChallengeT {
    pub challengeId: Option<String>,
    pub sortId: i32,
    pub challengeName: Option<String>,
    pub challengeGroup: i32,
    pub challengeGroupSortId: i32,
    pub challengeGroupName: Option<String>,
    pub challengeUnlockDesc: Option<String>,
    pub challengeUnlockToastDesc: Option<String>,
    pub challengeDes: Option<String>,
    pub challengeConditionDes: Option<Vec<String>>,
    pub challengeTasks: Option<Vec<dict__string__clz_Torappu_RoguelikeTopicChallengeTaskT>>,
    pub defaultTaskId: Option<String>,
    pub rewards: Option<Vec<clz_Torappu_ItemBundleT>>,
    pub challengeStoryId: Option<String>,
}
impl Default for clz_Torappu_RoguelikeTopicChallengeT {
    fn default() -> Self {
        Self {
            challengeId: None,
            sortId: 0,
            challengeName: None,
            challengeGroup: 0,
            challengeGroupSortId: 0,
            challengeGroupName: None,
            challengeUnlockDesc: None,
            challengeUnlockToastDesc: None,
            challengeDes: None,
            challengeConditionDes: None,
            challengeTasks: None,
            defaultTaskId: None,
            rewards: None,
            challengeStoryId: None,
        }
    }
}
impl clz_Torappu_RoguelikeTopicChallengeT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicChallenge<'b>> {
        let challengeId = self.challengeId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let challengeName = self.challengeName.as_ref().map(|x| _fbb.create_string(x));
        let challengeGroup = self.challengeGroup;
        let challengeGroupSortId = self.challengeGroupSortId;
        let challengeGroupName = self
            .challengeGroupName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let challengeUnlockDesc = self
            .challengeUnlockDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let challengeUnlockToastDesc = self
            .challengeUnlockToastDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let challengeDes = self.challengeDes.as_ref().map(|x| _fbb.create_string(x));
        let challengeConditionDes = self.challengeConditionDes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let challengeTasks = self.challengeTasks.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let defaultTaskId = self.defaultTaskId.as_ref().map(|x| _fbb.create_string(x));
        let rewards = self.rewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let challengeStoryId = self
            .challengeStoryId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeTopicChallenge::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicChallengeArgs {
                challengeId,
                sortId,
                challengeName,
                challengeGroup,
                challengeGroupSortId,
                challengeGroupName,
                challengeUnlockDesc,
                challengeUnlockToastDesc,
                challengeDes,
                challengeConditionDes,
                challengeTasks,
                defaultTaskId,
                rewards,
                challengeStoryId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeTopicChallengeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeTopicChallenge<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeTopicChallenge<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeTopicChallenge<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeTopicChallenge<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeTopicChallenge { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeTopicChallengeArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicChallenge<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeTopicChallengeBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeTopicChallengeT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeTopicChallengeT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeTopicChallenge::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeTopicChallenge,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeTopicChallenge<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicChallenge>>(
                    dict__string__clz_Torappu_RoguelikeTopicChallenge::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeTopicChallenge<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicChallenge>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeTopicChallengeArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicChallenge<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeTopicChallengeArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeTopicChallengeArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeTopicChallenge<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeTopicChallenge", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeTopicChallengeBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeTopicChallengeBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeTopicChallenge::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicChallenge<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicChallenge>>(
                dict__string__clz_Torappu_RoguelikeTopicChallenge::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeTopicChallengeBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeTopicChallengeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicChallenge<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeTopicChallenge::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeTopicChallenge<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeTopicChallenge");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeTopicChallengeT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeTopicChallengeT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeTopicChallengeT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeTopicChallengeT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicChallenge<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeTopicChallenge::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeTopicChallengeArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement<'a> {
    type Inner = clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement<'a> {
    pub const VT_ENROLLID: flatbuffers::VOffsetT = 4;
    pub const VT_RULEDESC: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement<'bldr>>
    {
        let mut builder =
            clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementBuilder::new(_fbb);
        if let Some(x) = args.ruleDesc {
            builder.add_ruleDesc(x);
        }
        if let Some(x) = args.enrollId {
            builder.add_enrollId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementT {
        let enrollId = self.enrollId().map(|x| x.to_string());
        let ruleDesc = self.ruleDesc().map(|x| x.to_string());
        clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementT { enrollId, ruleDesc }
    }

    #[inline]
    pub fn enrollId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement::VT_ENROLLID,
                None,
            )
        }
    }
    #[inline]
    pub fn ruleDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement::VT_RULEDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollId",
                Self::VT_ENROLLID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "ruleDesc",
                Self::VT_RULEDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementArgs<'a> {
    pub enrollId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ruleDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementArgs {
            enrollId: None,
            ruleDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement",
            2,
        )?;
        if let Some(f) = self.enrollId() {
            s.serialize_field("enrollId", &f)?;
        } else {
            s.skip_field("enrollId")?;
        }
        if let Some(f) = self.ruleDesc() {
            s.serialize_field("ruleDesc", &f)?;
        } else {
            s.skip_field("ruleDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_enrollId(&mut self, enrollId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement::VT_ENROLLID,
            enrollId,
        );
    }
    #[inline]
    pub fn add_ruleDesc(&mut self, ruleDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement::VT_RULEDESC,
            ruleDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement");
        ds.field("enrollId", &self.enrollId());
        ds.field("ruleDesc", &self.ruleDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementT {
    pub enrollId: Option<String>,
    pub ruleDesc: Option<String>,
}
impl Default for clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementT {
    fn default() -> Self {
        Self {
            enrollId: None,
            ruleDesc: None,
        }
    }
}
impl clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement<'b>> {
        let enrollId = self.enrollId.as_ref().map(|x| _fbb.create_string(x));
        let ruleDesc = self.ruleDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementArgs { enrollId, ruleDesc },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicDifficultyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicDifficulty<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicDifficulty<'a> {
    type Inner = clz_Torappu_RoguelikeTopicDifficulty<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicDifficulty<'a> {
    pub const VT_MODEDIFFICULTY: flatbuffers::VOffsetT = 4;
    pub const VT_GRADE: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_NAMEIMAGE: flatbuffers::VOffsetT = 10;
    pub const VT_SUBNAME: flatbuffers::VOffsetT = 12;
    pub const VT_ENROLLID: flatbuffers::VOffsetT = 14;
    pub const VT_HAVEINITIALRELICICON: flatbuffers::VOffsetT = 16;
    pub const VT_SCOREFACTOR: flatbuffers::VOffsetT = 18;
    pub const VT_CANUNLOCKITEM: flatbuffers::VOffsetT = 20;
    pub const VT_DOMONTHTASK: flatbuffers::VOffsetT = 22;
    pub const VT_RULEDESC: flatbuffers::VOffsetT = 24;
    pub const VT_RULEDESCREPLACEMENTS: flatbuffers::VOffsetT = 26;
    pub const VT_FAILTITLE: flatbuffers::VOffsetT = 28;
    pub const VT_FAILIMAGEID: flatbuffers::VOffsetT = 30;
    pub const VT_FAILFORCEDESC: flatbuffers::VOffsetT = 32;
    pub const VT_SORTID: flatbuffers::VOffsetT = 34;
    pub const VT_EQUIVALENTGRADE: flatbuffers::VOffsetT = 36;
    pub const VT_COLOR: flatbuffers::VOffsetT = 38;
    pub const VT_BPVALUE: flatbuffers::VOffsetT = 40;
    pub const VT_BOSSVALUE: flatbuffers::VOffsetT = 42;
    pub const VT_ADDDESC: flatbuffers::VOffsetT = 44;
    pub const VT_WARNINGTYPE: flatbuffers::VOffsetT = 46;
    pub const VT_UNLOCKTEXT: flatbuffers::VOffsetT = 48;
    pub const VT_DISPLAYICONID: flatbuffers::VOffsetT = 50;
    pub const VT_HIDEENDINGSTORY: flatbuffers::VOffsetT = 52;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicDifficulty { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicDifficultyArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDifficulty<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicDifficultyBuilder::new(_fbb);
        if let Some(x) = args.displayIconId {
            builder.add_displayIconId(x);
        }
        if let Some(x) = args.unlockText {
            builder.add_unlockText(x);
        }
        builder.add_warningType(args.warningType);
        if let Some(x) = args.addDesc {
            builder.add_addDesc(x);
        }
        builder.add_bossValue(args.bossValue);
        builder.add_bpValue(args.bpValue);
        if let Some(x) = args.color {
            builder.add_color(x);
        }
        builder.add_equivalentGrade(args.equivalentGrade);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.failForceDesc {
            builder.add_failForceDesc(x);
        }
        if let Some(x) = args.failImageId {
            builder.add_failImageId(x);
        }
        if let Some(x) = args.failTitle {
            builder.add_failTitle(x);
        }
        if let Some(x) = args.ruleDescReplacements {
            builder.add_ruleDescReplacements(x);
        }
        if let Some(x) = args.ruleDesc {
            builder.add_ruleDesc(x);
        }
        builder.add_scoreFactor(args.scoreFactor);
        if let Some(x) = args.enrollId {
            builder.add_enrollId(x);
        }
        if let Some(x) = args.subName {
            builder.add_subName(x);
        }
        if let Some(x) = args.nameImage {
            builder.add_nameImage(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_grade(args.grade);
        builder.add_modeDifficulty(args.modeDifficulty);
        builder.add_hideEndingStory(args.hideEndingStory);
        builder.add_doMonthTask(args.doMonthTask);
        builder.add_canUnlockItem(args.canUnlockItem);
        builder.add_haveInitialRelicIcon(args.haveInitialRelicIcon);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicDifficultyT {
        let modeDifficulty = self.modeDifficulty();
        let grade = self.grade();
        let name = self.name().map(|x| x.to_string());
        let nameImage = self.nameImage().map(|x| x.to_string());
        let subName = self.subName().map(|x| x.to_string());
        let enrollId = self.enrollId().map(|x| x.to_string());
        let haveInitialRelicIcon = self.haveInitialRelicIcon();
        let scoreFactor = self.scoreFactor();
        let canUnlockItem = self.canUnlockItem();
        let doMonthTask = self.doMonthTask();
        let ruleDesc = self.ruleDesc().map(|x| x.to_string());
        let ruleDescReplacements = self
            .ruleDescReplacements()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let failTitle = self.failTitle().map(|x| x.to_string());
        let failImageId = self.failImageId().map(|x| x.to_string());
        let failForceDesc = self.failForceDesc().map(|x| x.to_string());
        let sortId = self.sortId();
        let equivalentGrade = self.equivalentGrade();
        let color = self.color().map(|x| x.to_string());
        let bpValue = self.bpValue();
        let bossValue = self.bossValue();
        let addDesc = self.addDesc().map(|x| x.to_string());
        let warningType = self.warningType();
        let unlockText = self.unlockText().map(|x| x.to_string());
        let displayIconId = self.displayIconId().map(|x| x.to_string());
        let hideEndingStory = self.hideEndingStory();
        clz_Torappu_RoguelikeTopicDifficultyT {
            modeDifficulty,
            grade,
            name,
            nameImage,
            subName,
            enrollId,
            haveInitialRelicIcon,
            scoreFactor,
            canUnlockItem,
            doMonthTask,
            ruleDesc,
            ruleDescReplacements,
            failTitle,
            failImageId,
            failForceDesc,
            sortId,
            equivalentGrade,
            color,
            bpValue,
            bossValue,
            addDesc,
            warningType,
            unlockText,
            displayIconId,
            hideEndingStory,
        }
    }

    #[inline]
    pub fn modeDifficulty(&self) -> enum__Torappu_RoguelikeTopicMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTopicMode>(
                    clz_Torappu_RoguelikeTopicDifficulty::VT_MODEDIFFICULTY,
                    Some(enum__Torappu_RoguelikeTopicMode::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn grade(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicDifficulty::VT_GRADE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDifficulty::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn nameImage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDifficulty::VT_NAMEIMAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn subName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDifficulty::VT_SUBNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn enrollId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDifficulty::VT_ENROLLID,
                None,
            )
        }
    }
    #[inline]
    pub fn haveInitialRelicIcon(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeTopicDifficulty::VT_HAVEINITIALRELICICON,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn scoreFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_RoguelikeTopicDifficulty::VT_SCOREFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn canUnlockItem(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeTopicDifficulty::VT_CANUNLOCKITEM,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn doMonthTask(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeTopicDifficulty::VT_DOMONTHTASK,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn ruleDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDifficulty::VT_RULEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn ruleDescReplacements(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeTopicDifficulty::VT_RULEDESCREPLACEMENTS,
                None,
            )
        }
    }
    #[inline]
    pub fn failTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDifficulty::VT_FAILTITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn failImageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDifficulty::VT_FAILIMAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn failForceDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDifficulty::VT_FAILFORCEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicDifficulty::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn equivalentGrade(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicDifficulty::VT_EQUIVALENTGRADE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn color(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDifficulty::VT_COLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn bpValue(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicDifficulty::VT_BPVALUE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn bossValue(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicDifficulty::VT_BOSSVALUE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn addDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDifficulty::VT_ADDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn warningType(&self) -> enum__Torappu_RoguelikeTopicDifficultyWarningType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTopicDifficultyWarningType>(
                    clz_Torappu_RoguelikeTopicDifficulty::VT_WARNINGTYPE,
                    Some(enum__Torappu_RoguelikeTopicDifficultyWarningType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDifficulty::VT_UNLOCKTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn displayIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDifficulty::VT_DISPLAYICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn hideEndingStory(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeTopicDifficulty::VT_HIDEENDINGSTORY,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicDifficulty<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeTopicMode>(
                "modeDifficulty",
                Self::VT_MODEDIFFICULTY,
                false,
            )?
            .visit_field::<i32>("grade", Self::VT_GRADE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nameImage",
                Self::VT_NAMEIMAGE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subName", Self::VT_SUBNAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollId",
                Self::VT_ENROLLID,
                false,
            )?
            .visit_field::<bool>("haveInitialRelicIcon", Self::VT_HAVEINITIALRELICICON, false)?
            .visit_field::<f32>("scoreFactor", Self::VT_SCOREFACTOR, false)?
            .visit_field::<bool>("canUnlockItem", Self::VT_CANUNLOCKITEM, false)?
            .visit_field::<bool>("doMonthTask", Self::VT_DOMONTHTASK, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "ruleDesc",
                Self::VT_RULEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement,
                    >,
                >,
            >>("ruleDescReplacements", Self::VT_RULEDESCREPLACEMENTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "failTitle",
                Self::VT_FAILTITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "failImageId",
                Self::VT_FAILIMAGEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "failForceDesc",
                Self::VT_FAILFORCEDESC,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<i32>("equivalentGrade", Self::VT_EQUIVALENTGRADE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("color", Self::VT_COLOR, false)?
            .visit_field::<i32>("bpValue", Self::VT_BPVALUE, false)?
            .visit_field::<i32>("bossValue", Self::VT_BOSSVALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("addDesc", Self::VT_ADDDESC, false)?
            .visit_field::<enum__Torappu_RoguelikeTopicDifficultyWarningType>(
                "warningType",
                Self::VT_WARNINGTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockText",
                Self::VT_UNLOCKTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "displayIconId",
                Self::VT_DISPLAYICONID,
                false,
            )?
            .visit_field::<bool>("hideEndingStory", Self::VT_HIDEENDINGSTORY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicDifficultyArgs<'a> {
    pub modeDifficulty: enum__Torappu_RoguelikeTopicMode,
    pub grade: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nameImage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enrollId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub haveInitialRelicIcon: bool,
    pub scoreFactor: f32,
    pub canUnlockItem: bool,
    pub doMonthTask: bool,
    pub ruleDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ruleDescReplacements: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement<'a>,
                >,
            >,
        >,
    >,
    pub failTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub failImageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub failForceDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub equivalentGrade: i32,
    pub color: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bpValue: i32,
    pub bossValue: i32,
    pub addDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub warningType: enum__Torappu_RoguelikeTopicDifficultyWarningType,
    pub unlockText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub displayIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hideEndingStory: bool,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicDifficultyArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicDifficultyArgs {
            modeDifficulty: enum__Torappu_RoguelikeTopicMode::NONE,
            grade: 0,
            name: None,
            nameImage: None,
            subName: None,
            enrollId: None,
            haveInitialRelicIcon: false,
            scoreFactor: 0.0,
            canUnlockItem: false,
            doMonthTask: false,
            ruleDesc: None,
            ruleDescReplacements: None,
            failTitle: None,
            failImageId: None,
            failForceDesc: None,
            sortId: 0,
            equivalentGrade: 0,
            color: None,
            bpValue: 0,
            bossValue: 0,
            addDesc: None,
            warningType: enum__Torappu_RoguelikeTopicDifficultyWarningType::NONE,
            unlockText: None,
            displayIconId: None,
            hideEndingStory: false,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicDifficulty<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicDifficulty", 25)?;
        s.serialize_field("modeDifficulty", &self.modeDifficulty())?;
        s.serialize_field("grade", &self.grade())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.nameImage() {
            s.serialize_field("nameImage", &f)?;
        } else {
            s.skip_field("nameImage")?;
        }
        if let Some(f) = self.subName() {
            s.serialize_field("subName", &f)?;
        } else {
            s.skip_field("subName")?;
        }
        if let Some(f) = self.enrollId() {
            s.serialize_field("enrollId", &f)?;
        } else {
            s.skip_field("enrollId")?;
        }
        s.serialize_field("haveInitialRelicIcon", &self.haveInitialRelicIcon())?;
        s.serialize_field("scoreFactor", &self.scoreFactor())?;
        s.serialize_field("canUnlockItem", &self.canUnlockItem())?;
        s.serialize_field("doMonthTask", &self.doMonthTask())?;
        if let Some(f) = self.ruleDesc() {
            s.serialize_field("ruleDesc", &f)?;
        } else {
            s.skip_field("ruleDesc")?;
        }
        if let Some(f) = self.ruleDescReplacements() {
            s.serialize_field("ruleDescReplacements", &f)?;
        } else {
            s.skip_field("ruleDescReplacements")?;
        }
        if let Some(f) = self.failTitle() {
            s.serialize_field("failTitle", &f)?;
        } else {
            s.skip_field("failTitle")?;
        }
        if let Some(f) = self.failImageId() {
            s.serialize_field("failImageId", &f)?;
        } else {
            s.skip_field("failImageId")?;
        }
        if let Some(f) = self.failForceDesc() {
            s.serialize_field("failForceDesc", &f)?;
        } else {
            s.skip_field("failForceDesc")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("equivalentGrade", &self.equivalentGrade())?;
        if let Some(f) = self.color() {
            s.serialize_field("color", &f)?;
        } else {
            s.skip_field("color")?;
        }
        s.serialize_field("bpValue", &self.bpValue())?;
        s.serialize_field("bossValue", &self.bossValue())?;
        if let Some(f) = self.addDesc() {
            s.serialize_field("addDesc", &f)?;
        } else {
            s.skip_field("addDesc")?;
        }
        s.serialize_field("warningType", &self.warningType())?;
        if let Some(f) = self.unlockText() {
            s.serialize_field("unlockText", &f)?;
        } else {
            s.skip_field("unlockText")?;
        }
        if let Some(f) = self.displayIconId() {
            s.serialize_field("displayIconId", &f)?;
        } else {
            s.skip_field("displayIconId")?;
        }
        s.serialize_field("hideEndingStory", &self.hideEndingStory())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicDifficultyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicDifficultyBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_modeDifficulty(&mut self, modeDifficulty: enum__Torappu_RoguelikeTopicMode) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeTopicMode>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_MODEDIFFICULTY,
            modeDifficulty,
            enum__Torappu_RoguelikeTopicMode::NONE,
        );
    }
    #[inline]
    pub fn add_grade(&mut self, grade: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeTopicDifficulty::VT_GRADE, grade, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_nameImage(&mut self, nameImage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_NAMEIMAGE,
            nameImage,
        );
    }
    #[inline]
    pub fn add_subName(&mut self, subName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_SUBNAME,
            subName,
        );
    }
    #[inline]
    pub fn add_enrollId(&mut self, enrollId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_ENROLLID,
            enrollId,
        );
    }
    #[inline]
    pub fn add_haveInitialRelicIcon(&mut self, haveInitialRelicIcon: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_HAVEINITIALRELICICON,
            haveInitialRelicIcon,
            false,
        );
    }
    #[inline]
    pub fn add_scoreFactor(&mut self, scoreFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_SCOREFACTOR,
            scoreFactor,
            0.0,
        );
    }
    #[inline]
    pub fn add_canUnlockItem(&mut self, canUnlockItem: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_CANUNLOCKITEM,
            canUnlockItem,
            false,
        );
    }
    #[inline]
    pub fn add_doMonthTask(&mut self, doMonthTask: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_DOMONTHTASK,
            doMonthTask,
            false,
        );
    }
    #[inline]
    pub fn add_ruleDesc(&mut self, ruleDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_RULEDESC,
            ruleDesc,
        );
    }
    #[inline]
    pub fn add_ruleDescReplacements(
        &mut self,
        ruleDescReplacements: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacement<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_RULEDESCREPLACEMENTS,
            ruleDescReplacements,
        );
    }
    #[inline]
    pub fn add_failTitle(&mut self, failTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_FAILTITLE,
            failTitle,
        );
    }
    #[inline]
    pub fn add_failImageId(&mut self, failImageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_FAILIMAGEID,
            failImageId,
        );
    }
    #[inline]
    pub fn add_failForceDesc(&mut self, failForceDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_FAILFORCEDESC,
            failForceDesc,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeTopicDifficulty::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_equivalentGrade(&mut self, equivalentGrade: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_EQUIVALENTGRADE,
            equivalentGrade,
            0,
        );
    }
    #[inline]
    pub fn add_color(&mut self, color: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_COLOR,
            color,
        );
    }
    #[inline]
    pub fn add_bpValue(&mut self, bpValue: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeTopicDifficulty::VT_BPVALUE, bpValue, 0);
    }
    #[inline]
    pub fn add_bossValue(&mut self, bossValue: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_BOSSVALUE,
            bossValue,
            0,
        );
    }
    #[inline]
    pub fn add_addDesc(&mut self, addDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_ADDDESC,
            addDesc,
        );
    }
    #[inline]
    pub fn add_warningType(
        &mut self,
        warningType: enum__Torappu_RoguelikeTopicDifficultyWarningType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeTopicDifficultyWarningType>(
                clz_Torappu_RoguelikeTopicDifficulty::VT_WARNINGTYPE,
                warningType,
                enum__Torappu_RoguelikeTopicDifficultyWarningType::NONE,
            );
    }
    #[inline]
    pub fn add_unlockText(&mut self, unlockText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_UNLOCKTEXT,
            unlockText,
        );
    }
    #[inline]
    pub fn add_displayIconId(&mut self, displayIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_DISPLAYICONID,
            displayIconId,
        );
    }
    #[inline]
    pub fn add_hideEndingStory(&mut self, hideEndingStory: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeTopicDifficulty::VT_HIDEENDINGSTORY,
            hideEndingStory,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicDifficultyBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicDifficultyBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDifficulty<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicDifficulty<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicDifficulty");
        ds.field("modeDifficulty", &self.modeDifficulty());
        ds.field("grade", &self.grade());
        ds.field("name", &self.name());
        ds.field("nameImage", &self.nameImage());
        ds.field("subName", &self.subName());
        ds.field("enrollId", &self.enrollId());
        ds.field("haveInitialRelicIcon", &self.haveInitialRelicIcon());
        ds.field("scoreFactor", &self.scoreFactor());
        ds.field("canUnlockItem", &self.canUnlockItem());
        ds.field("doMonthTask", &self.doMonthTask());
        ds.field("ruleDesc", &self.ruleDesc());
        ds.field("ruleDescReplacements", &self.ruleDescReplacements());
        ds.field("failTitle", &self.failTitle());
        ds.field("failImageId", &self.failImageId());
        ds.field("failForceDesc", &self.failForceDesc());
        ds.field("sortId", &self.sortId());
        ds.field("equivalentGrade", &self.equivalentGrade());
        ds.field("color", &self.color());
        ds.field("bpValue", &self.bpValue());
        ds.field("bossValue", &self.bossValue());
        ds.field("addDesc", &self.addDesc());
        ds.field("warningType", &self.warningType());
        ds.field("unlockText", &self.unlockText());
        ds.field("displayIconId", &self.displayIconId());
        ds.field("hideEndingStory", &self.hideEndingStory());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicDifficultyT {
    pub modeDifficulty: enum__Torappu_RoguelikeTopicMode,
    pub grade: i32,
    pub name: Option<String>,
    pub nameImage: Option<String>,
    pub subName: Option<String>,
    pub enrollId: Option<String>,
    pub haveInitialRelicIcon: bool,
    pub scoreFactor: f32,
    pub canUnlockItem: bool,
    pub doMonthTask: bool,
    pub ruleDesc: Option<String>,
    pub ruleDescReplacements:
        Option<Vec<clz_Torappu_RoguelikeTopicDifficulty_RuleDescReplacementT>>,
    pub failTitle: Option<String>,
    pub failImageId: Option<String>,
    pub failForceDesc: Option<String>,
    pub sortId: i32,
    pub equivalentGrade: i32,
    pub color: Option<String>,
    pub bpValue: i32,
    pub bossValue: i32,
    pub addDesc: Option<String>,
    pub warningType: enum__Torappu_RoguelikeTopicDifficultyWarningType,
    pub unlockText: Option<String>,
    pub displayIconId: Option<String>,
    pub hideEndingStory: bool,
}
impl Default for clz_Torappu_RoguelikeTopicDifficultyT {
    fn default() -> Self {
        Self {
            modeDifficulty: enum__Torappu_RoguelikeTopicMode::NONE,
            grade: 0,
            name: None,
            nameImage: None,
            subName: None,
            enrollId: None,
            haveInitialRelicIcon: false,
            scoreFactor: 0.0,
            canUnlockItem: false,
            doMonthTask: false,
            ruleDesc: None,
            ruleDescReplacements: None,
            failTitle: None,
            failImageId: None,
            failForceDesc: None,
            sortId: 0,
            equivalentGrade: 0,
            color: None,
            bpValue: 0,
            bossValue: 0,
            addDesc: None,
            warningType: enum__Torappu_RoguelikeTopicDifficultyWarningType::NONE,
            unlockText: None,
            displayIconId: None,
            hideEndingStory: false,
        }
    }
}
impl clz_Torappu_RoguelikeTopicDifficultyT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDifficulty<'b>> {
        let modeDifficulty = self.modeDifficulty;
        let grade = self.grade;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let nameImage = self.nameImage.as_ref().map(|x| _fbb.create_string(x));
        let subName = self.subName.as_ref().map(|x| _fbb.create_string(x));
        let enrollId = self.enrollId.as_ref().map(|x| _fbb.create_string(x));
        let haveInitialRelicIcon = self.haveInitialRelicIcon;
        let scoreFactor = self.scoreFactor;
        let canUnlockItem = self.canUnlockItem;
        let doMonthTask = self.doMonthTask;
        let ruleDesc = self.ruleDesc.as_ref().map(|x| _fbb.create_string(x));
        let ruleDescReplacements = self.ruleDescReplacements.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let failTitle = self.failTitle.as_ref().map(|x| _fbb.create_string(x));
        let failImageId = self.failImageId.as_ref().map(|x| _fbb.create_string(x));
        let failForceDesc = self.failForceDesc.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let equivalentGrade = self.equivalentGrade;
        let color = self.color.as_ref().map(|x| _fbb.create_string(x));
        let bpValue = self.bpValue;
        let bossValue = self.bossValue;
        let addDesc = self.addDesc.as_ref().map(|x| _fbb.create_string(x));
        let warningType = self.warningType;
        let unlockText = self.unlockText.as_ref().map(|x| _fbb.create_string(x));
        let displayIconId = self.displayIconId.as_ref().map(|x| _fbb.create_string(x));
        let hideEndingStory = self.hideEndingStory;
        clz_Torappu_RoguelikeTopicDifficulty::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicDifficultyArgs {
                modeDifficulty,
                grade,
                name,
                nameImage,
                subName,
                enrollId,
                haveInitialRelicIcon,
                scoreFactor,
                canUnlockItem,
                doMonthTask,
                ruleDesc,
                ruleDescReplacements,
                failTitle,
                failImageId,
                failForceDesc,
                sortId,
                equivalentGrade,
                color,
                bpValue,
                bossValue,
                addDesc,
                warningType,
                unlockText,
                displayIconId,
                hideEndingStory,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicBankRewardOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicBankReward<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicBankReward<'a> {
    type Inner = clz_Torappu_RoguelikeTopicBankReward<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicBankReward<'a> {
    pub const VT_REWARDID: flatbuffers::VOffsetT = 4;
    pub const VT_UNLOCKGOLDCNT: flatbuffers::VOffsetT = 6;
    pub const VT_REWARDTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_DESC: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicBankReward { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicBankRewardArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBankReward<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicBankRewardBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        builder.add_rewardType(args.rewardType);
        builder.add_unlockGoldCnt(args.unlockGoldCnt);
        if let Some(x) = args.rewardId {
            builder.add_rewardId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicBankRewardT {
        let rewardId = self.rewardId().map(|x| x.to_string());
        let unlockGoldCnt = self.unlockGoldCnt();
        let rewardType = self.rewardType();
        let desc = self.desc().map(|x| x.to_string());
        clz_Torappu_RoguelikeTopicBankRewardT {
            rewardId,
            unlockGoldCnt,
            rewardType,
            desc,
        }
    }

    #[inline]
    pub fn rewardId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBankReward::VT_REWARDID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockGoldCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicBankReward::VT_UNLOCKGOLDCNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rewardType(&self) -> enum__Torappu_RoguelikeTopicBankRewardType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTopicBankRewardType>(
                    clz_Torappu_RoguelikeTopicBankReward::VT_REWARDTYPE,
                    Some(enum__Torappu_RoguelikeTopicBankRewardType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicBankReward::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicBankReward<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardId",
                Self::VT_REWARDID,
                false,
            )?
            .visit_field::<i32>("unlockGoldCnt", Self::VT_UNLOCKGOLDCNT, false)?
            .visit_field::<enum__Torappu_RoguelikeTopicBankRewardType>(
                "rewardType",
                Self::VT_REWARDTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicBankRewardArgs<'a> {
    pub rewardId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockGoldCnt: i32,
    pub rewardType: enum__Torappu_RoguelikeTopicBankRewardType,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicBankRewardArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicBankRewardArgs {
            rewardId: None,
            unlockGoldCnt: 0,
            rewardType: enum__Torappu_RoguelikeTopicBankRewardType::NONE,
            desc: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicBankReward<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicBankReward", 4)?;
        if let Some(f) = self.rewardId() {
            s.serialize_field("rewardId", &f)?;
        } else {
            s.skip_field("rewardId")?;
        }
        s.serialize_field("unlockGoldCnt", &self.unlockGoldCnt())?;
        s.serialize_field("rewardType", &self.rewardType())?;
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicBankRewardBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicBankRewardBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_rewardId(&mut self, rewardId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBankReward::VT_REWARDID,
            rewardId,
        );
    }
    #[inline]
    pub fn add_unlockGoldCnt(&mut self, unlockGoldCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicBankReward::VT_UNLOCKGOLDCNT,
            unlockGoldCnt,
            0,
        );
    }
    #[inline]
    pub fn add_rewardType(&mut self, rewardType: enum__Torappu_RoguelikeTopicBankRewardType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeTopicBankRewardType>(
                clz_Torappu_RoguelikeTopicBankReward::VT_REWARDTYPE,
                rewardType,
                enum__Torappu_RoguelikeTopicBankRewardType::NONE,
            );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicBankReward::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicBankRewardBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicBankRewardBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBankReward<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicBankReward<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicBankReward");
        ds.field("rewardId", &self.rewardId());
        ds.field("unlockGoldCnt", &self.unlockGoldCnt());
        ds.field("rewardType", &self.rewardType());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicBankRewardT {
    pub rewardId: Option<String>,
    pub unlockGoldCnt: i32,
    pub rewardType: enum__Torappu_RoguelikeTopicBankRewardType,
    pub desc: Option<String>,
}
impl Default for clz_Torappu_RoguelikeTopicBankRewardT {
    fn default() -> Self {
        Self {
            rewardId: None,
            unlockGoldCnt: 0,
            rewardType: enum__Torappu_RoguelikeTopicBankRewardType::NONE,
            desc: None,
        }
    }
}
impl clz_Torappu_RoguelikeTopicBankRewardT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicBankReward<'b>> {
        let rewardId = self.rewardId.as_ref().map(|x| _fbb.create_string(x));
        let unlockGoldCnt = self.unlockGoldCnt;
        let rewardType = self.rewardType;
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeTopicBankReward::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicBankRewardArgs {
                rewardId,
                unlockGoldCnt,
                rewardType,
                desc,
            },
        )
    }
}
pub enum clz_Torappu_ActArchiveRelicItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveRelicItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveRelicItemData<'a> {
    type Inner = clz_Torappu_ActArchiveRelicItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveRelicItemData<'a> {
    pub const VT_RELICID: flatbuffers::VOffsetT = 4;
    pub const VT_RELICSORTID: flatbuffers::VOffsetT = 6;
    pub const VT_RELICGROUPID: flatbuffers::VOffsetT = 8;
    pub const VT_ORDERID: flatbuffers::VOffsetT = 10;
    pub const VT_ISSPRELIC: flatbuffers::VOffsetT = 12;
    pub const VT_ENROLLID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveRelicItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveRelicItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveRelicItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveRelicItemDataBuilder::new(_fbb);
        if let Some(x) = args.enrollId {
            builder.add_enrollId(x);
        }
        if let Some(x) = args.orderId {
            builder.add_orderId(x);
        }
        builder.add_relicGroupId(args.relicGroupId);
        builder.add_relicSortId(args.relicSortId);
        if let Some(x) = args.relicId {
            builder.add_relicId(x);
        }
        builder.add_isSpRelic(args.isSpRelic);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveRelicItemDataT {
        let relicId = self.relicId().map(|x| x.to_string());
        let relicSortId = self.relicSortId();
        let relicGroupId = self.relicGroupId();
        let orderId = self.orderId().map(|x| x.to_string());
        let isSpRelic = self.isSpRelic();
        let enrollId = self.enrollId().map(|x| x.to_string());
        clz_Torappu_ActArchiveRelicItemDataT {
            relicId,
            relicSortId,
            relicGroupId,
            orderId,
            isSpRelic,
            enrollId,
        }
    }

    #[inline]
    pub fn relicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveRelicItemData::VT_RELICID,
                None,
            )
        }
    }
    #[inline]
    pub fn relicSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveRelicItemData::VT_RELICSORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn relicGroupId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ActArchiveRelicItemData::VT_RELICGROUPID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn orderId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveRelicItemData::VT_ORDERID,
                None,
            )
        }
    }
    #[inline]
    pub fn isSpRelic(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_ActArchiveRelicItemData::VT_ISSPRELIC,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn enrollId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveRelicItemData::VT_ENROLLID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveRelicItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("relicId", Self::VT_RELICID, false)?
            .visit_field::<i32>("relicSortId", Self::VT_RELICSORTID, false)?
            .visit_field::<i32>("relicGroupId", Self::VT_RELICGROUPID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("orderId", Self::VT_ORDERID, false)?
            .visit_field::<bool>("isSpRelic", Self::VT_ISSPRELIC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollId",
                Self::VT_ENROLLID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveRelicItemDataArgs<'a> {
    pub relicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relicSortId: i32,
    pub relicGroupId: i32,
    pub orderId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isSpRelic: bool,
    pub enrollId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveRelicItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveRelicItemDataArgs {
            relicId: None,
            relicSortId: 0,
            relicGroupId: 0,
            orderId: None,
            isSpRelic: false,
            enrollId: None,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveRelicItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveRelicItemData", 6)?;
        if let Some(f) = self.relicId() {
            s.serialize_field("relicId", &f)?;
        } else {
            s.skip_field("relicId")?;
        }
        s.serialize_field("relicSortId", &self.relicSortId())?;
        s.serialize_field("relicGroupId", &self.relicGroupId())?;
        if let Some(f) = self.orderId() {
            s.serialize_field("orderId", &f)?;
        } else {
            s.skip_field("orderId")?;
        }
        s.serialize_field("isSpRelic", &self.isSpRelic())?;
        if let Some(f) = self.enrollId() {
            s.serialize_field("enrollId", &f)?;
        } else {
            s.skip_field("enrollId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveRelicItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveRelicItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_relicId(&mut self, relicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveRelicItemData::VT_RELICID,
            relicId,
        );
    }
    #[inline]
    pub fn add_relicSortId(&mut self, relicSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchiveRelicItemData::VT_RELICSORTID,
            relicSortId,
            0,
        );
    }
    #[inline]
    pub fn add_relicGroupId(&mut self, relicGroupId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchiveRelicItemData::VT_RELICGROUPID,
            relicGroupId,
            0,
        );
    }
    #[inline]
    pub fn add_orderId(&mut self, orderId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveRelicItemData::VT_ORDERID,
            orderId,
        );
    }
    #[inline]
    pub fn add_isSpRelic(&mut self, isSpRelic: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_ActArchiveRelicItemData::VT_ISSPRELIC,
            isSpRelic,
            false,
        );
    }
    #[inline]
    pub fn add_enrollId(&mut self, enrollId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveRelicItemData::VT_ENROLLID,
            enrollId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveRelicItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveRelicItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveRelicItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveRelicItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveRelicItemData");
        ds.field("relicId", &self.relicId());
        ds.field("relicSortId", &self.relicSortId());
        ds.field("relicGroupId", &self.relicGroupId());
        ds.field("orderId", &self.orderId());
        ds.field("isSpRelic", &self.isSpRelic());
        ds.field("enrollId", &self.enrollId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveRelicItemDataT {
    pub relicId: Option<String>,
    pub relicSortId: i32,
    pub relicGroupId: i32,
    pub orderId: Option<String>,
    pub isSpRelic: bool,
    pub enrollId: Option<String>,
}
impl Default for clz_Torappu_ActArchiveRelicItemDataT {
    fn default() -> Self {
        Self {
            relicId: None,
            relicSortId: 0,
            relicGroupId: 0,
            orderId: None,
            isSpRelic: false,
            enrollId: None,
        }
    }
}
impl clz_Torappu_ActArchiveRelicItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveRelicItemData<'b>> {
        let relicId = self.relicId.as_ref().map(|x| _fbb.create_string(x));
        let relicSortId = self.relicSortId;
        let relicGroupId = self.relicGroupId;
        let orderId = self.orderId.as_ref().map(|x| _fbb.create_string(x));
        let isSpRelic = self.isSpRelic;
        let enrollId = self.enrollId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ActArchiveRelicItemData::create(
            _fbb,
            &clz_Torappu_ActArchiveRelicItemDataArgs {
                relicId,
                relicSortId,
                relicGroupId,
                orderId,
                isSpRelic,
                enrollId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActArchiveRelicItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveRelicItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveRelicItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveRelicItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveRelicItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveRelicItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveRelicItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveRelicItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveRelicItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActArchiveRelicItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActArchiveRelicItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveRelicItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveRelicItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveRelicItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveRelicItemData>>(
                    dict__string__clz_Torappu_ActArchiveRelicItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveRelicItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveRelicItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveRelicItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveRelicItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveRelicItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveRelicItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActArchiveRelicItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ActArchiveRelicItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActArchiveRelicItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveRelicItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveRelicItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveRelicItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveRelicItemData>>(
                dict__string__clz_Torappu_ActArchiveRelicItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveRelicItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveRelicItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveRelicItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveRelicItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveRelicItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveRelicItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActArchiveRelicItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActArchiveRelicItemDataT>>,
}
impl Default for dict__string__clz_Torappu_ActArchiveRelicItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActArchiveRelicItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveRelicItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActArchiveRelicItemData::create(
            _fbb,
            &dict__string__clz_Torappu_ActArchiveRelicItemDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActArchiveRelicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveRelicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveRelicData<'a> {
    type Inner = clz_Torappu_ActArchiveRelicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveRelicData<'a> {
    pub const VT_RELIC: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveRelicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveRelicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveRelicData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveRelicDataBuilder::new(_fbb);
        if let Some(x) = args.relic {
            builder.add_relic(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveRelicDataT {
        let relic = self.relic().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActArchiveRelicDataT { relic }
    }

    #[inline]
    pub fn relic(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveRelicItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveRelicItemData>,
                >,
            >>(clz_Torappu_ActArchiveRelicData::VT_RELIC, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveRelicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveRelicItemData>,
                >,
            >>("relic", Self::VT_RELIC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveRelicDataArgs<'a> {
    pub relic: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveRelicItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveRelicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveRelicDataArgs { relic: None }
    }
}

impl Serialize for clz_Torappu_ActArchiveRelicData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveRelicData", 1)?;
        if let Some(f) = self.relic() {
            s.serialize_field("relic", &f)?;
        } else {
            s.skip_field("relic")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveRelicDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ActArchiveRelicDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_relic(
        &mut self,
        relic: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveRelicItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveRelicData::VT_RELIC,
            relic,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveRelicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveRelicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveRelicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveRelicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveRelicData");
        ds.field("relic", &self.relic());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveRelicDataT {
    pub relic: Option<Vec<dict__string__clz_Torappu_ActArchiveRelicItemDataT>>,
}
impl Default for clz_Torappu_ActArchiveRelicDataT {
    fn default() -> Self {
        Self { relic: None }
    }
}
impl clz_Torappu_ActArchiveRelicDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveRelicData<'b>> {
        let relic = self.relic.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActArchiveRelicData::create(
            _fbb,
            &clz_Torappu_ActArchiveRelicDataArgs { relic },
        )
    }
}
pub enum clz_Torappu_ActArchiveCapsuleItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveCapsuleItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveCapsuleItemData<'a> {
    type Inner = clz_Torappu_ActArchiveCapsuleItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveCapsuleItemData<'a> {
    pub const VT_CAPSULEID: flatbuffers::VOffsetT = 4;
    pub const VT_CAPSULESORTID: flatbuffers::VOffsetT = 6;
    pub const VT_ENGLISHNAME: flatbuffers::VOffsetT = 8;
    pub const VT_ENROLLID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveCapsuleItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveCapsuleItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCapsuleItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveCapsuleItemDataBuilder::new(_fbb);
        if let Some(x) = args.enrollId {
            builder.add_enrollId(x);
        }
        if let Some(x) = args.englishName {
            builder.add_englishName(x);
        }
        builder.add_capsuleSortId(args.capsuleSortId);
        if let Some(x) = args.capsuleId {
            builder.add_capsuleId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveCapsuleItemDataT {
        let capsuleId = self.capsuleId().map(|x| x.to_string());
        let capsuleSortId = self.capsuleSortId();
        let englishName = self.englishName().map(|x| x.to_string());
        let enrollId = self.enrollId().map(|x| x.to_string());
        clz_Torappu_ActArchiveCapsuleItemDataT {
            capsuleId,
            capsuleSortId,
            englishName,
            enrollId,
        }
    }

    #[inline]
    pub fn capsuleId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveCapsuleItemData::VT_CAPSULEID,
                None,
            )
        }
    }
    #[inline]
    pub fn capsuleSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ActArchiveCapsuleItemData::VT_CAPSULESORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn englishName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveCapsuleItemData::VT_ENGLISHNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn enrollId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveCapsuleItemData::VT_ENROLLID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveCapsuleItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "capsuleId",
                Self::VT_CAPSULEID,
                false,
            )?
            .visit_field::<i32>("capsuleSortId", Self::VT_CAPSULESORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "englishName",
                Self::VT_ENGLISHNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollId",
                Self::VT_ENROLLID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveCapsuleItemDataArgs<'a> {
    pub capsuleId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub capsuleSortId: i32,
    pub englishName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enrollId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveCapsuleItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveCapsuleItemDataArgs {
            capsuleId: None,
            capsuleSortId: 0,
            englishName: None,
            enrollId: None,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveCapsuleItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveCapsuleItemData", 4)?;
        if let Some(f) = self.capsuleId() {
            s.serialize_field("capsuleId", &f)?;
        } else {
            s.skip_field("capsuleId")?;
        }
        s.serialize_field("capsuleSortId", &self.capsuleSortId())?;
        if let Some(f) = self.englishName() {
            s.serialize_field("englishName", &f)?;
        } else {
            s.skip_field("englishName")?;
        }
        if let Some(f) = self.enrollId() {
            s.serialize_field("enrollId", &f)?;
        } else {
            s.skip_field("enrollId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveCapsuleItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveCapsuleItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_capsuleId(&mut self, capsuleId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCapsuleItemData::VT_CAPSULEID,
            capsuleId,
        );
    }
    #[inline]
    pub fn add_capsuleSortId(&mut self, capsuleSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchiveCapsuleItemData::VT_CAPSULESORTID,
            capsuleSortId,
            0,
        );
    }
    #[inline]
    pub fn add_englishName(&mut self, englishName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCapsuleItemData::VT_ENGLISHNAME,
            englishName,
        );
    }
    #[inline]
    pub fn add_enrollId(&mut self, enrollId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCapsuleItemData::VT_ENROLLID,
            enrollId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveCapsuleItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveCapsuleItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCapsuleItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveCapsuleItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveCapsuleItemData");
        ds.field("capsuleId", &self.capsuleId());
        ds.field("capsuleSortId", &self.capsuleSortId());
        ds.field("englishName", &self.englishName());
        ds.field("enrollId", &self.enrollId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveCapsuleItemDataT {
    pub capsuleId: Option<String>,
    pub capsuleSortId: i32,
    pub englishName: Option<String>,
    pub enrollId: Option<String>,
}
impl Default for clz_Torappu_ActArchiveCapsuleItemDataT {
    fn default() -> Self {
        Self {
            capsuleId: None,
            capsuleSortId: 0,
            englishName: None,
            enrollId: None,
        }
    }
}
impl clz_Torappu_ActArchiveCapsuleItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCapsuleItemData<'b>> {
        let capsuleId = self.capsuleId.as_ref().map(|x| _fbb.create_string(x));
        let capsuleSortId = self.capsuleSortId;
        let englishName = self.englishName.as_ref().map(|x| _fbb.create_string(x));
        let enrollId = self.enrollId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ActArchiveCapsuleItemData::create(
            _fbb,
            &clz_Torappu_ActArchiveCapsuleItemDataArgs {
                capsuleId,
                capsuleSortId,
                englishName,
                enrollId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActArchiveCapsuleItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveCapsuleItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveCapsuleItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveCapsuleItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveCapsuleItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveCapsuleItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveCapsuleItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveCapsuleItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveCapsuleItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActArchiveCapsuleItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActArchiveCapsuleItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveCapsuleItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveCapsuleItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveCapsuleItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveCapsuleItemData>>(
                    dict__string__clz_Torappu_ActArchiveCapsuleItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveCapsuleItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveCapsuleItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveCapsuleItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveCapsuleItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveCapsuleItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveCapsuleItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActArchiveCapsuleItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_ActArchiveCapsuleItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActArchiveCapsuleItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveCapsuleItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveCapsuleItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveCapsuleItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveCapsuleItemData>>(
                dict__string__clz_Torappu_ActArchiveCapsuleItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveCapsuleItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveCapsuleItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveCapsuleItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveCapsuleItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveCapsuleItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveCapsuleItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActArchiveCapsuleItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActArchiveCapsuleItemDataT>>,
}
impl Default for dict__string__clz_Torappu_ActArchiveCapsuleItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActArchiveCapsuleItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveCapsuleItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActArchiveCapsuleItemData::create(
            _fbb,
            &dict__string__clz_Torappu_ActArchiveCapsuleItemDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActArchiveCapsuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveCapsuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveCapsuleData<'a> {
    type Inner = clz_Torappu_ActArchiveCapsuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveCapsuleData<'a> {
    pub const VT_CAPSULE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveCapsuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveCapsuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCapsuleData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveCapsuleDataBuilder::new(_fbb);
        if let Some(x) = args.capsule {
            builder.add_capsule(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveCapsuleDataT {
        let capsule = self
            .capsule()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActArchiveCapsuleDataT { capsule }
    }

    #[inline]
    pub fn capsule(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveCapsuleItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveCapsuleItemData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveCapsuleData::VT_CAPSULE, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveCapsuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveCapsuleItemData,
                    >,
                >,
            >>("capsule", Self::VT_CAPSULE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveCapsuleDataArgs<'a> {
    pub capsule: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveCapsuleItemData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveCapsuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveCapsuleDataArgs { capsule: None }
    }
}

impl Serialize for clz_Torappu_ActArchiveCapsuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveCapsuleData", 1)?;
        if let Some(f) = self.capsule() {
            s.serialize_field("capsule", &f)?;
        } else {
            s.skip_field("capsule")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveCapsuleDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveCapsuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_capsule(
        &mut self,
        capsule: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveCapsuleItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCapsuleData::VT_CAPSULE,
            capsule,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveCapsuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveCapsuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCapsuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveCapsuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveCapsuleData");
        ds.field("capsule", &self.capsule());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveCapsuleDataT {
    pub capsule: Option<Vec<dict__string__clz_Torappu_ActArchiveCapsuleItemDataT>>,
}
impl Default for clz_Torappu_ActArchiveCapsuleDataT {
    fn default() -> Self {
        Self { capsule: None }
    }
}
impl clz_Torappu_ActArchiveCapsuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCapsuleData<'b>> {
        let capsule = self.capsule.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActArchiveCapsuleData::create(
            _fbb,
            &clz_Torappu_ActArchiveCapsuleDataArgs { capsule },
        )
    }
}
pub enum clz_Torappu_ActArchiveTrapItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveTrapItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveTrapItemData<'a> {
    type Inner = clz_Torappu_ActArchiveTrapItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveTrapItemData<'a> {
    pub const VT_TRAPID: flatbuffers::VOffsetT = 4;
    pub const VT_TRAPSORTID: flatbuffers::VOffsetT = 6;
    pub const VT_ORDERID: flatbuffers::VOffsetT = 8;
    pub const VT_ENROLLID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveTrapItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveTrapItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTrapItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveTrapItemDataBuilder::new(_fbb);
        if let Some(x) = args.enrollId {
            builder.add_enrollId(x);
        }
        if let Some(x) = args.orderId {
            builder.add_orderId(x);
        }
        builder.add_trapSortId(args.trapSortId);
        if let Some(x) = args.trapId {
            builder.add_trapId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveTrapItemDataT {
        let trapId = self.trapId().map(|x| x.to_string());
        let trapSortId = self.trapSortId();
        let orderId = self.orderId().map(|x| x.to_string());
        let enrollId = self.enrollId().map(|x| x.to_string());
        clz_Torappu_ActArchiveTrapItemDataT {
            trapId,
            trapSortId,
            orderId,
            enrollId,
        }
    }

    #[inline]
    pub fn trapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveTrapItemData::VT_TRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn trapSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveTrapItemData::VT_TRAPSORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn orderId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveTrapItemData::VT_ORDERID,
                None,
            )
        }
    }
    #[inline]
    pub fn enrollId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveTrapItemData::VT_ENROLLID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveTrapItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trapId", Self::VT_TRAPID, false)?
            .visit_field::<i32>("trapSortId", Self::VT_TRAPSORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("orderId", Self::VT_ORDERID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollId",
                Self::VT_ENROLLID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveTrapItemDataArgs<'a> {
    pub trapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapSortId: i32,
    pub orderId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enrollId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveTrapItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveTrapItemDataArgs {
            trapId: None,
            trapSortId: 0,
            orderId: None,
            enrollId: None,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveTrapItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveTrapItemData", 4)?;
        if let Some(f) = self.trapId() {
            s.serialize_field("trapId", &f)?;
        } else {
            s.skip_field("trapId")?;
        }
        s.serialize_field("trapSortId", &self.trapSortId())?;
        if let Some(f) = self.orderId() {
            s.serialize_field("orderId", &f)?;
        } else {
            s.skip_field("orderId")?;
        }
        if let Some(f) = self.enrollId() {
            s.serialize_field("enrollId", &f)?;
        } else {
            s.skip_field("enrollId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveTrapItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveTrapItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_trapId(&mut self, trapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTrapItemData::VT_TRAPID,
            trapId,
        );
    }
    #[inline]
    pub fn add_trapSortId(&mut self, trapSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchiveTrapItemData::VT_TRAPSORTID,
            trapSortId,
            0,
        );
    }
    #[inline]
    pub fn add_orderId(&mut self, orderId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTrapItemData::VT_ORDERID,
            orderId,
        );
    }
    #[inline]
    pub fn add_enrollId(&mut self, enrollId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTrapItemData::VT_ENROLLID,
            enrollId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveTrapItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveTrapItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTrapItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveTrapItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveTrapItemData");
        ds.field("trapId", &self.trapId());
        ds.field("trapSortId", &self.trapSortId());
        ds.field("orderId", &self.orderId());
        ds.field("enrollId", &self.enrollId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveTrapItemDataT {
    pub trapId: Option<String>,
    pub trapSortId: i32,
    pub orderId: Option<String>,
    pub enrollId: Option<String>,
}
impl Default for clz_Torappu_ActArchiveTrapItemDataT {
    fn default() -> Self {
        Self {
            trapId: None,
            trapSortId: 0,
            orderId: None,
            enrollId: None,
        }
    }
}
impl clz_Torappu_ActArchiveTrapItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTrapItemData<'b>> {
        let trapId = self.trapId.as_ref().map(|x| _fbb.create_string(x));
        let trapSortId = self.trapSortId;
        let orderId = self.orderId.as_ref().map(|x| _fbb.create_string(x));
        let enrollId = self.enrollId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ActArchiveTrapItemData::create(
            _fbb,
            &clz_Torappu_ActArchiveTrapItemDataArgs {
                trapId,
                trapSortId,
                orderId,
                enrollId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActArchiveTrapItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveTrapItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveTrapItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveTrapItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveTrapItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveTrapItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveTrapItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveTrapItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveTrapItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActArchiveTrapItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActArchiveTrapItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveTrapItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveTrapItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveTrapItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveTrapItemData>>(
                    dict__string__clz_Torappu_ActArchiveTrapItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveTrapItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveTrapItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveTrapItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveTrapItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveTrapItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveTrapItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActArchiveTrapItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ActArchiveTrapItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActArchiveTrapItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveTrapItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveTrapItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveTrapItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveTrapItemData>>(
                dict__string__clz_Torappu_ActArchiveTrapItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveTrapItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveTrapItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveTrapItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveTrapItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveTrapItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveTrapItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActArchiveTrapItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActArchiveTrapItemDataT>>,
}
impl Default for dict__string__clz_Torappu_ActArchiveTrapItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActArchiveTrapItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveTrapItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActArchiveTrapItemData::create(
            _fbb,
            &dict__string__clz_Torappu_ActArchiveTrapItemDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActArchiveTrapDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveTrapData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveTrapData<'a> {
    type Inner = clz_Torappu_ActArchiveTrapData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveTrapData<'a> {
    pub const VT_TRAP: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveTrapData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveTrapDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTrapData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveTrapDataBuilder::new(_fbb);
        if let Some(x) = args.trap {
            builder.add_trap(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveTrapDataT {
        let trap = self.trap().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActArchiveTrapDataT { trap }
    }

    #[inline]
    pub fn trap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveTrapItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveTrapItemData>,
                >,
            >>(clz_Torappu_ActArchiveTrapData::VT_TRAP, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveTrapData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveTrapItemData>,
                >,
            >>("trap", Self::VT_TRAP, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveTrapDataArgs<'a> {
    pub trap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveTrapItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveTrapDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveTrapDataArgs { trap: None }
    }
}

impl Serialize for clz_Torappu_ActArchiveTrapData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveTrapData", 1)?;
        if let Some(f) = self.trap() {
            s.serialize_field("trap", &f)?;
        } else {
            s.skip_field("trap")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveTrapDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ActArchiveTrapDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_trap(
        &mut self,
        trap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveTrapItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTrapData::VT_TRAP,
            trap,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveTrapDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveTrapDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTrapData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveTrapData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveTrapData");
        ds.field("trap", &self.trap());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveTrapDataT {
    pub trap: Option<Vec<dict__string__clz_Torappu_ActArchiveTrapItemDataT>>,
}
impl Default for clz_Torappu_ActArchiveTrapDataT {
    fn default() -> Self {
        Self { trap: None }
    }
}
impl clz_Torappu_ActArchiveTrapDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTrapData<'b>> {
        let trap = self.trap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActArchiveTrapData::create(_fbb, &clz_Torappu_ActArchiveTrapDataArgs { trap })
    }
}
pub enum clz_Torappu_ActArchiveChatItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveChatItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveChatItemData<'a> {
    type Inner = clz_Torappu_ActArchiveChatItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveChatItemData<'a> {
    pub const VT_FLOOR: flatbuffers::VOffsetT = 4;
    pub const VT_CHATZONEID: flatbuffers::VOffsetT = 6;
    pub const VT_CHATDESC: flatbuffers::VOffsetT = 8;
    pub const VT_CHATSTORYID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveChatItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveChatItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChatItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveChatItemDataBuilder::new(_fbb);
        if let Some(x) = args.chatStoryId {
            builder.add_chatStoryId(x);
        }
        if let Some(x) = args.chatDesc {
            builder.add_chatDesc(x);
        }
        if let Some(x) = args.chatZoneId {
            builder.add_chatZoneId(x);
        }
        builder.add_floor(args.floor);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveChatItemDataT {
        let floor = self.floor();
        let chatZoneId = self.chatZoneId().map(|x| x.to_string());
        let chatDesc = self.chatDesc().map(|x| x.to_string());
        let chatStoryId = self.chatStoryId().map(|x| x.to_string());
        clz_Torappu_ActArchiveChatItemDataT {
            floor,
            chatZoneId,
            chatDesc,
            chatStoryId,
        }
    }

    #[inline]
    pub fn floor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveChatItemData::VT_FLOOR, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn chatZoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveChatItemData::VT_CHATZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn chatDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveChatItemData::VT_CHATDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn chatStoryId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveChatItemData::VT_CHATSTORYID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveChatItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("floor", Self::VT_FLOOR, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "chatZoneId",
                Self::VT_CHATZONEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "chatDesc",
                Self::VT_CHATDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "chatStoryId",
                Self::VT_CHATSTORYID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveChatItemDataArgs<'a> {
    pub floor: i32,
    pub chatZoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub chatDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub chatStoryId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveChatItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveChatItemDataArgs {
            floor: 0,
            chatZoneId: None,
            chatDesc: None,
            chatStoryId: None,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveChatItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveChatItemData", 4)?;
        s.serialize_field("floor", &self.floor())?;
        if let Some(f) = self.chatZoneId() {
            s.serialize_field("chatZoneId", &f)?;
        } else {
            s.skip_field("chatZoneId")?;
        }
        if let Some(f) = self.chatDesc() {
            s.serialize_field("chatDesc", &f)?;
        } else {
            s.skip_field("chatDesc")?;
        }
        if let Some(f) = self.chatStoryId() {
            s.serialize_field("chatStoryId", &f)?;
        } else {
            s.skip_field("chatStoryId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveChatItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveChatItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_floor(&mut self, floor: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ActArchiveChatItemData::VT_FLOOR, floor, 0);
    }
    #[inline]
    pub fn add_chatZoneId(&mut self, chatZoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveChatItemData::VT_CHATZONEID,
            chatZoneId,
        );
    }
    #[inline]
    pub fn add_chatDesc(&mut self, chatDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveChatItemData::VT_CHATDESC,
            chatDesc,
        );
    }
    #[inline]
    pub fn add_chatStoryId(&mut self, chatStoryId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveChatItemData::VT_CHATSTORYID,
            chatStoryId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveChatItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveChatItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChatItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveChatItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveChatItemData");
        ds.field("floor", &self.floor());
        ds.field("chatZoneId", &self.chatZoneId());
        ds.field("chatDesc", &self.chatDesc());
        ds.field("chatStoryId", &self.chatStoryId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveChatItemDataT {
    pub floor: i32,
    pub chatZoneId: Option<String>,
    pub chatDesc: Option<String>,
    pub chatStoryId: Option<String>,
}
impl Default for clz_Torappu_ActArchiveChatItemDataT {
    fn default() -> Self {
        Self {
            floor: 0,
            chatZoneId: None,
            chatDesc: None,
            chatStoryId: None,
        }
    }
}
impl clz_Torappu_ActArchiveChatItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChatItemData<'b>> {
        let floor = self.floor;
        let chatZoneId = self.chatZoneId.as_ref().map(|x| _fbb.create_string(x));
        let chatDesc = self.chatDesc.as_ref().map(|x| _fbb.create_string(x));
        let chatStoryId = self.chatStoryId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ActArchiveChatItemData::create(
            _fbb,
            &clz_Torappu_ActArchiveChatItemDataArgs {
                floor,
                chatZoneId,
                chatDesc,
                chatStoryId,
            },
        )
    }
}
pub enum clz_Torappu_ActArchiveChatGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveChatGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveChatGroupData<'a> {
    type Inner = clz_Torappu_ActArchiveChatGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveChatGroupData<'a> {
    pub const VT_SORTID: flatbuffers::VOffsetT = 4;
    pub const VT_CHATITEMLIST: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveChatGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveChatGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChatGroupData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveChatGroupDataBuilder::new(_fbb);
        if let Some(x) = args.chatItemList {
            builder.add_chatItemList(x);
        }
        builder.add_sortId(args.sortId);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveChatGroupDataT {
        let sortId = self.sortId();
        let chatItemList = self
            .chatItemList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActArchiveChatGroupDataT {
            sortId,
            chatItemList,
        }
    }

    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveChatGroupData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn chatItemList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChatItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChatItemData>,
                >,
            >>(clz_Torappu_ActArchiveChatGroupData::VT_CHATITEMLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveChatGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChatItemData>,
                >,
            >>("chatItemList", Self::VT_CHATITEMLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveChatGroupDataArgs<'a> {
    pub sortId: i32,
    pub chatItemList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChatItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveChatGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveChatGroupDataArgs {
            sortId: 0,
            chatItemList: None,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveChatGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveChatGroupData", 2)?;
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.chatItemList() {
            s.serialize_field("chatItemList", &f)?;
        } else {
            s.skip_field("chatItemList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveChatGroupDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveChatGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ActArchiveChatGroupData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_chatItemList(
        &mut self,
        chatItemList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChatItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveChatGroupData::VT_CHATITEMLIST,
            chatItemList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveChatGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveChatGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChatGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveChatGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveChatGroupData");
        ds.field("sortId", &self.sortId());
        ds.field("chatItemList", &self.chatItemList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveChatGroupDataT {
    pub sortId: i32,
    pub chatItemList: Option<Vec<clz_Torappu_ActArchiveChatItemDataT>>,
}
impl Default for clz_Torappu_ActArchiveChatGroupDataT {
    fn default() -> Self {
        Self {
            sortId: 0,
            chatItemList: None,
        }
    }
}
impl clz_Torappu_ActArchiveChatGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChatGroupData<'b>> {
        let sortId = self.sortId;
        let chatItemList = self.chatItemList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActArchiveChatGroupData::create(
            _fbb,
            &clz_Torappu_ActArchiveChatGroupDataArgs {
                sortId,
                chatItemList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActArchiveChatGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveChatGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveChatGroupData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveChatGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveChatGroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveChatGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveChatGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveChatGroupData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveChatGroupDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActArchiveChatGroupDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActArchiveChatGroupDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveChatGroupData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveChatGroupData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveChatGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChatGroupData>>(
                    dict__string__clz_Torappu_ActArchiveChatGroupData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveChatGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChatGroupData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveChatGroupDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveChatGroupData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveChatGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveChatGroupDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActArchiveChatGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ActArchiveChatGroupData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActArchiveChatGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveChatGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveChatGroupData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveChatGroupData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveChatGroupData>>(
                dict__string__clz_Torappu_ActArchiveChatGroupData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveChatGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveChatGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveChatGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveChatGroupData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveChatGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveChatGroupData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActArchiveChatGroupDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActArchiveChatGroupDataT>>,
}
impl Default for dict__string__clz_Torappu_ActArchiveChatGroupDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActArchiveChatGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveChatGroupData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActArchiveChatGroupData::create(
            _fbb,
            &dict__string__clz_Torappu_ActArchiveChatGroupDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActArchiveChatDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveChatData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveChatData<'a> {
    type Inner = clz_Torappu_ActArchiveChatData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveChatData<'a> {
    pub const VT_CHAT: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveChatData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveChatDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChatData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveChatDataBuilder::new(_fbb);
        if let Some(x) = args.chat {
            builder.add_chat(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveChatDataT {
        let chat = self.chat().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActArchiveChatDataT { chat }
    }

    #[inline]
    pub fn chat(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveChatGroupData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveChatGroupData>,
                >,
            >>(clz_Torappu_ActArchiveChatData::VT_CHAT, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveChatData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveChatGroupData>,
                >,
            >>("chat", Self::VT_CHAT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveChatDataArgs<'a> {
    pub chat: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveChatGroupData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveChatDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveChatDataArgs { chat: None }
    }
}

impl Serialize for clz_Torappu_ActArchiveChatData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveChatData", 1)?;
        if let Some(f) = self.chat() {
            s.serialize_field("chat", &f)?;
        } else {
            s.skip_field("chat")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveChatDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ActArchiveChatDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_chat(
        &mut self,
        chat: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveChatGroupData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveChatData::VT_CHAT,
            chat,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveChatDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveChatDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChatData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveChatData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveChatData");
        ds.field("chat", &self.chat());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveChatDataT {
    pub chat: Option<Vec<dict__string__clz_Torappu_ActArchiveChatGroupDataT>>,
}
impl Default for clz_Torappu_ActArchiveChatDataT {
    fn default() -> Self {
        Self { chat: None }
    }
}
impl clz_Torappu_ActArchiveChatDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChatData<'b>> {
        let chat = self.chat.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActArchiveChatData::create(_fbb, &clz_Torappu_ActArchiveChatDataArgs { chat })
    }
}
pub enum clz_Torappu_ActArchiveEndbookItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveEndbookItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveEndbookItemData<'a> {
    type Inner = clz_Torappu_ActArchiveEndbookItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveEndbookItemData<'a> {
    pub const VT_ENDBOOKID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_ENROLLID: flatbuffers::VOffsetT = 8;
    pub const VT_ISLAST: flatbuffers::VOffsetT = 10;
    pub const VT_ENDBOOKNAME: flatbuffers::VOffsetT = 12;
    pub const VT_UNLOCKDESC: flatbuffers::VOffsetT = 14;
    pub const VT_TEXTID: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveEndbookItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveEndbookItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveEndbookItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveEndbookItemDataBuilder::new(_fbb);
        if let Some(x) = args.textId {
            builder.add_textId(x);
        }
        if let Some(x) = args.unlockDesc {
            builder.add_unlockDesc(x);
        }
        if let Some(x) = args.endbookName {
            builder.add_endbookName(x);
        }
        if let Some(x) = args.enrollId {
            builder.add_enrollId(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.endBookId {
            builder.add_endBookId(x);
        }
        builder.add_isLast(args.isLast);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveEndbookItemDataT {
        let endBookId = self.endBookId().map(|x| x.to_string());
        let sortId = self.sortId();
        let enrollId = self.enrollId().map(|x| x.to_string());
        let isLast = self.isLast();
        let endbookName = self.endbookName().map(|x| x.to_string());
        let unlockDesc = self.unlockDesc().map(|x| x.to_string());
        let textId = self.textId().map(|x| x.to_string());
        clz_Torappu_ActArchiveEndbookItemDataT {
            endBookId,
            sortId,
            enrollId,
            isLast,
            endbookName,
            unlockDesc,
            textId,
        }
    }

    #[inline]
    pub fn endBookId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveEndbookItemData::VT_ENDBOOKID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveEndbookItemData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn enrollId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveEndbookItemData::VT_ENROLLID,
                None,
            )
        }
    }
    #[inline]
    pub fn isLast(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_ActArchiveEndbookItemData::VT_ISLAST,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn endbookName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveEndbookItemData::VT_ENDBOOKNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveEndbookItemData::VT_UNLOCKDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn textId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveEndbookItemData::VT_TEXTID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveEndbookItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "endBookId",
                Self::VT_ENDBOOKID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollId",
                Self::VT_ENROLLID,
                false,
            )?
            .visit_field::<bool>("isLast", Self::VT_ISLAST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "endbookName",
                Self::VT_ENDBOOKNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockDesc",
                Self::VT_UNLOCKDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("textId", Self::VT_TEXTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveEndbookItemDataArgs<'a> {
    pub endBookId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub enrollId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isLast: bool,
    pub endbookName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub textId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveEndbookItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveEndbookItemDataArgs {
            endBookId: None,
            sortId: 0,
            enrollId: None,
            isLast: false,
            endbookName: None,
            unlockDesc: None,
            textId: None,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveEndbookItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveEndbookItemData", 7)?;
        if let Some(f) = self.endBookId() {
            s.serialize_field("endBookId", &f)?;
        } else {
            s.skip_field("endBookId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.enrollId() {
            s.serialize_field("enrollId", &f)?;
        } else {
            s.skip_field("enrollId")?;
        }
        s.serialize_field("isLast", &self.isLast())?;
        if let Some(f) = self.endbookName() {
            s.serialize_field("endbookName", &f)?;
        } else {
            s.skip_field("endbookName")?;
        }
        if let Some(f) = self.unlockDesc() {
            s.serialize_field("unlockDesc", &f)?;
        } else {
            s.skip_field("unlockDesc")?;
        }
        if let Some(f) = self.textId() {
            s.serialize_field("textId", &f)?;
        } else {
            s.skip_field("textId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveEndbookItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveEndbookItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_endBookId(&mut self, endBookId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveEndbookItemData::VT_ENDBOOKID,
            endBookId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ActArchiveEndbookItemData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_enrollId(&mut self, enrollId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveEndbookItemData::VT_ENROLLID,
            enrollId,
        );
    }
    #[inline]
    pub fn add_isLast(&mut self, isLast: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_ActArchiveEndbookItemData::VT_ISLAST,
            isLast,
            false,
        );
    }
    #[inline]
    pub fn add_endbookName(&mut self, endbookName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveEndbookItemData::VT_ENDBOOKNAME,
            endbookName,
        );
    }
    #[inline]
    pub fn add_unlockDesc(&mut self, unlockDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveEndbookItemData::VT_UNLOCKDESC,
            unlockDesc,
        );
    }
    #[inline]
    pub fn add_textId(&mut self, textId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveEndbookItemData::VT_TEXTID,
            textId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveEndbookItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveEndbookItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveEndbookItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveEndbookItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveEndbookItemData");
        ds.field("endBookId", &self.endBookId());
        ds.field("sortId", &self.sortId());
        ds.field("enrollId", &self.enrollId());
        ds.field("isLast", &self.isLast());
        ds.field("endbookName", &self.endbookName());
        ds.field("unlockDesc", &self.unlockDesc());
        ds.field("textId", &self.textId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveEndbookItemDataT {
    pub endBookId: Option<String>,
    pub sortId: i32,
    pub enrollId: Option<String>,
    pub isLast: bool,
    pub endbookName: Option<String>,
    pub unlockDesc: Option<String>,
    pub textId: Option<String>,
}
impl Default for clz_Torappu_ActArchiveEndbookItemDataT {
    fn default() -> Self {
        Self {
            endBookId: None,
            sortId: 0,
            enrollId: None,
            isLast: false,
            endbookName: None,
            unlockDesc: None,
            textId: None,
        }
    }
}
impl clz_Torappu_ActArchiveEndbookItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveEndbookItemData<'b>> {
        let endBookId = self.endBookId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let enrollId = self.enrollId.as_ref().map(|x| _fbb.create_string(x));
        let isLast = self.isLast;
        let endbookName = self.endbookName.as_ref().map(|x| _fbb.create_string(x));
        let unlockDesc = self.unlockDesc.as_ref().map(|x| _fbb.create_string(x));
        let textId = self.textId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ActArchiveEndbookItemData::create(
            _fbb,
            &clz_Torappu_ActArchiveEndbookItemDataArgs {
                endBookId,
                sortId,
                enrollId,
                isLast,
                endbookName,
                unlockDesc,
                textId,
            },
        )
    }
}
pub enum clz_Torappu_ActArchiveEndbookGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveEndbookGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveEndbookGroupData<'a> {
    type Inner = clz_Torappu_ActArchiveEndbookGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveEndbookGroupData<'a> {
    pub const VT_ENDID: flatbuffers::VOffsetT = 4;
    pub const VT_ENDINGID: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;
    pub const VT_TITLE: flatbuffers::VOffsetT = 10;
    pub const VT_CGID: flatbuffers::VOffsetT = 12;
    pub const VT_BACKBLURID: flatbuffers::VOffsetT = 14;
    pub const VT_CARDID: flatbuffers::VOffsetT = 16;
    pub const VT_HASAVG: flatbuffers::VOffsetT = 18;
    pub const VT_AVGID: flatbuffers::VOffsetT = 20;
    pub const VT_CLIENTENDBOOKITEMDATAS: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveEndbookGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveEndbookGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveEndbookGroupData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveEndbookGroupDataBuilder::new(_fbb);
        if let Some(x) = args.clientEndbookItemDatas {
            builder.add_clientEndbookItemDatas(x);
        }
        if let Some(x) = args.avgId {
            builder.add_avgId(x);
        }
        if let Some(x) = args.cardId {
            builder.add_cardId(x);
        }
        if let Some(x) = args.backBlurId {
            builder.add_backBlurId(x);
        }
        if let Some(x) = args.cgId {
            builder.add_cgId(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.endingId {
            builder.add_endingId(x);
        }
        if let Some(x) = args.endId {
            builder.add_endId(x);
        }
        builder.add_hasAvg(args.hasAvg);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveEndbookGroupDataT {
        let endId = self.endId().map(|x| x.to_string());
        let endingId = self.endingId().map(|x| x.to_string());
        let sortId = self.sortId();
        let title = self.title().map(|x| x.to_string());
        let cgId = self.cgId().map(|x| x.to_string());
        let backBlurId = self.backBlurId().map(|x| x.to_string());
        let cardId = self.cardId().map(|x| x.to_string());
        let hasAvg = self.hasAvg();
        let avgId = self.avgId().map(|x| x.to_string());
        let clientEndbookItemDatas = self
            .clientEndbookItemDatas()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActArchiveEndbookGroupDataT {
            endId,
            endingId,
            sortId,
            title,
            cgId,
            backBlurId,
            cardId,
            hasAvg,
            avgId,
            clientEndbookItemDatas,
        }
    }

    #[inline]
    pub fn endId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveEndbookGroupData::VT_ENDID,
                None,
            )
        }
    }
    #[inline]
    pub fn endingId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveEndbookGroupData::VT_ENDINGID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveEndbookGroupData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveEndbookGroupData::VT_TITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn cgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveEndbookGroupData::VT_CGID,
                None,
            )
        }
    }
    #[inline]
    pub fn backBlurId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveEndbookGroupData::VT_BACKBLURID,
                None,
            )
        }
    }
    #[inline]
    pub fn cardId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveEndbookGroupData::VT_CARDID,
                None,
            )
        }
    }
    #[inline]
    pub fn hasAvg(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_ActArchiveEndbookGroupData::VT_HASAVG,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn avgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveEndbookGroupData::VT_AVGID,
                None,
            )
        }
    }
    #[inline]
    pub fn clientEndbookItemDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveEndbookItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveEndbookItemData>,
                >,
            >>(
                clz_Torappu_ActArchiveEndbookGroupData::VT_CLIENTENDBOOKITEMDATAS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveEndbookGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("endId", Self::VT_ENDID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "endingId",
                Self::VT_ENDINGID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cgId", Self::VT_CGID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "backBlurId",
                Self::VT_BACKBLURID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cardId", Self::VT_CARDID, false)?
            .visit_field::<bool>("hasAvg", Self::VT_HASAVG, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("avgId", Self::VT_AVGID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveEndbookItemData>,
                >,
            >>(
                "clientEndbookItemDatas",
                Self::VT_CLIENTENDBOOKITEMDATAS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveEndbookGroupDataArgs<'a> {
    pub endId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endingId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub backBlurId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cardId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hasAvg: bool,
    pub avgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub clientEndbookItemDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveEndbookItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveEndbookGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveEndbookGroupDataArgs {
            endId: None,
            endingId: None,
            sortId: 0,
            title: None,
            cgId: None,
            backBlurId: None,
            cardId: None,
            hasAvg: false,
            avgId: None,
            clientEndbookItemDatas: None,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveEndbookGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveEndbookGroupData", 10)?;
        if let Some(f) = self.endId() {
            s.serialize_field("endId", &f)?;
        } else {
            s.skip_field("endId")?;
        }
        if let Some(f) = self.endingId() {
            s.serialize_field("endingId", &f)?;
        } else {
            s.skip_field("endingId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.title() {
            s.serialize_field("title", &f)?;
        } else {
            s.skip_field("title")?;
        }
        if let Some(f) = self.cgId() {
            s.serialize_field("cgId", &f)?;
        } else {
            s.skip_field("cgId")?;
        }
        if let Some(f) = self.backBlurId() {
            s.serialize_field("backBlurId", &f)?;
        } else {
            s.skip_field("backBlurId")?;
        }
        if let Some(f) = self.cardId() {
            s.serialize_field("cardId", &f)?;
        } else {
            s.skip_field("cardId")?;
        }
        s.serialize_field("hasAvg", &self.hasAvg())?;
        if let Some(f) = self.avgId() {
            s.serialize_field("avgId", &f)?;
        } else {
            s.skip_field("avgId")?;
        }
        if let Some(f) = self.clientEndbookItemDatas() {
            s.serialize_field("clientEndbookItemDatas", &f)?;
        } else {
            s.skip_field("clientEndbookItemDatas")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveEndbookGroupDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveEndbookGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_endId(&mut self, endId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveEndbookGroupData::VT_ENDID,
            endId,
        );
    }
    #[inline]
    pub fn add_endingId(&mut self, endingId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveEndbookGroupData::VT_ENDINGID,
            endingId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ActArchiveEndbookGroupData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveEndbookGroupData::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_cgId(&mut self, cgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveEndbookGroupData::VT_CGID,
            cgId,
        );
    }
    #[inline]
    pub fn add_backBlurId(&mut self, backBlurId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveEndbookGroupData::VT_BACKBLURID,
            backBlurId,
        );
    }
    #[inline]
    pub fn add_cardId(&mut self, cardId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveEndbookGroupData::VT_CARDID,
            cardId,
        );
    }
    #[inline]
    pub fn add_hasAvg(&mut self, hasAvg: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_ActArchiveEndbookGroupData::VT_HASAVG,
            hasAvg,
            false,
        );
    }
    #[inline]
    pub fn add_avgId(&mut self, avgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveEndbookGroupData::VT_AVGID,
            avgId,
        );
    }
    #[inline]
    pub fn add_clientEndbookItemDatas(
        &mut self,
        clientEndbookItemDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveEndbookItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveEndbookGroupData::VT_CLIENTENDBOOKITEMDATAS,
            clientEndbookItemDatas,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveEndbookGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveEndbookGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveEndbookGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveEndbookGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveEndbookGroupData");
        ds.field("endId", &self.endId());
        ds.field("endingId", &self.endingId());
        ds.field("sortId", &self.sortId());
        ds.field("title", &self.title());
        ds.field("cgId", &self.cgId());
        ds.field("backBlurId", &self.backBlurId());
        ds.field("cardId", &self.cardId());
        ds.field("hasAvg", &self.hasAvg());
        ds.field("avgId", &self.avgId());
        ds.field("clientEndbookItemDatas", &self.clientEndbookItemDatas());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveEndbookGroupDataT {
    pub endId: Option<String>,
    pub endingId: Option<String>,
    pub sortId: i32,
    pub title: Option<String>,
    pub cgId: Option<String>,
    pub backBlurId: Option<String>,
    pub cardId: Option<String>,
    pub hasAvg: bool,
    pub avgId: Option<String>,
    pub clientEndbookItemDatas: Option<Vec<clz_Torappu_ActArchiveEndbookItemDataT>>,
}
impl Default for clz_Torappu_ActArchiveEndbookGroupDataT {
    fn default() -> Self {
        Self {
            endId: None,
            endingId: None,
            sortId: 0,
            title: None,
            cgId: None,
            backBlurId: None,
            cardId: None,
            hasAvg: false,
            avgId: None,
            clientEndbookItemDatas: None,
        }
    }
}
impl clz_Torappu_ActArchiveEndbookGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveEndbookGroupData<'b>> {
        let endId = self.endId.as_ref().map(|x| _fbb.create_string(x));
        let endingId = self.endingId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let title = self.title.as_ref().map(|x| _fbb.create_string(x));
        let cgId = self.cgId.as_ref().map(|x| _fbb.create_string(x));
        let backBlurId = self.backBlurId.as_ref().map(|x| _fbb.create_string(x));
        let cardId = self.cardId.as_ref().map(|x| _fbb.create_string(x));
        let hasAvg = self.hasAvg;
        let avgId = self.avgId.as_ref().map(|x| _fbb.create_string(x));
        let clientEndbookItemDatas = self.clientEndbookItemDatas.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActArchiveEndbookGroupData::create(
            _fbb,
            &clz_Torappu_ActArchiveEndbookGroupDataArgs {
                endId,
                endingId,
                sortId,
                title,
                cgId,
                backBlurId,
                cardId,
                hasAvg,
                avgId,
                clientEndbookItemDatas,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActArchiveEndbookGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveEndbookGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveEndbookGroupData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveEndbookGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveEndbookGroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveEndbookGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveEndbookGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveEndbookGroupData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveEndbookGroupDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActArchiveEndbookGroupDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActArchiveEndbookGroupDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveEndbookGroupData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveEndbookGroupData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveEndbookGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveEndbookGroupData>>(
                    dict__string__clz_Torappu_ActArchiveEndbookGroupData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveEndbookGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveEndbookGroupData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveEndbookGroupDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveEndbookGroupData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveEndbookGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveEndbookGroupDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActArchiveEndbookGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_ActArchiveEndbookGroupData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActArchiveEndbookGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveEndbookGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveEndbookGroupData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveEndbookGroupData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveEndbookGroupData>>(
                dict__string__clz_Torappu_ActArchiveEndbookGroupData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveEndbookGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveEndbookGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveEndbookGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveEndbookGroupData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveEndbookGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveEndbookGroupData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActArchiveEndbookGroupDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActArchiveEndbookGroupDataT>>,
}
impl Default for dict__string__clz_Torappu_ActArchiveEndbookGroupDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActArchiveEndbookGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveEndbookGroupData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActArchiveEndbookGroupData::create(
            _fbb,
            &dict__string__clz_Torappu_ActArchiveEndbookGroupDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActArchiveEndbookDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveEndbookData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveEndbookData<'a> {
    type Inner = clz_Torappu_ActArchiveEndbookData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveEndbookData<'a> {
    pub const VT_ENDBOOK: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveEndbookData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveEndbookDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveEndbookData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveEndbookDataBuilder::new(_fbb);
        if let Some(x) = args.endbook {
            builder.add_endbook(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveEndbookDataT {
        let endbook = self
            .endbook()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActArchiveEndbookDataT { endbook }
    }

    #[inline]
    pub fn endbook(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveEndbookGroupData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveEndbookGroupData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveEndbookData::VT_ENDBOOK, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveEndbookData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveEndbookGroupData,
                    >,
                >,
            >>("endbook", Self::VT_ENDBOOK, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveEndbookDataArgs<'a> {
    pub endbook: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveEndbookGroupData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveEndbookDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveEndbookDataArgs { endbook: None }
    }
}

impl Serialize for clz_Torappu_ActArchiveEndbookData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveEndbookData", 1)?;
        if let Some(f) = self.endbook() {
            s.serialize_field("endbook", &f)?;
        } else {
            s.skip_field("endbook")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveEndbookDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveEndbookDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_endbook(
        &mut self,
        endbook: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveEndbookGroupData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveEndbookData::VT_ENDBOOK,
            endbook,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveEndbookDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveEndbookDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveEndbookData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveEndbookData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveEndbookData");
        ds.field("endbook", &self.endbook());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveEndbookDataT {
    pub endbook: Option<Vec<dict__string__clz_Torappu_ActArchiveEndbookGroupDataT>>,
}
impl Default for clz_Torappu_ActArchiveEndbookDataT {
    fn default() -> Self {
        Self { endbook: None }
    }
}
impl clz_Torappu_ActArchiveEndbookDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveEndbookData<'b>> {
        let endbook = self.endbook.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActArchiveEndbookData::create(
            _fbb,
            &clz_Torappu_ActArchiveEndbookDataArgs { endbook },
        )
    }
}
pub enum clz_Torappu_ActArchiveBuffItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveBuffItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveBuffItemData<'a> {
    type Inner = clz_Torappu_ActArchiveBuffItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveBuffItemData<'a> {
    pub const VT_BUFFID: flatbuffers::VOffsetT = 4;
    pub const VT_BUFFGROUPINDEX: flatbuffers::VOffsetT = 6;
    pub const VT_INNERSORTID: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_ICONID: flatbuffers::VOffsetT = 12;
    pub const VT_USAGE: flatbuffers::VOffsetT = 14;
    pub const VT_DESC: flatbuffers::VOffsetT = 16;
    pub const VT_COLOR: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveBuffItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveBuffItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveBuffItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveBuffItemDataBuilder::new(_fbb);
        if let Some(x) = args.color {
            builder.add_color(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.usage {
            builder.add_usage(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_innerSortId(args.innerSortId);
        builder.add_buffGroupIndex(args.buffGroupIndex);
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveBuffItemDataT {
        let buffId = self.buffId().map(|x| x.to_string());
        let buffGroupIndex = self.buffGroupIndex();
        let innerSortId = self.innerSortId();
        let name = self.name().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        let usage = self.usage().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let color = self.color().map(|x| x.to_string());
        clz_Torappu_ActArchiveBuffItemDataT {
            buffId,
            buffGroupIndex,
            innerSortId,
            name,
            iconId,
            usage,
            desc,
            color,
        }
    }

    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveBuffItemData::VT_BUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn buffGroupIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_ActArchiveBuffItemData::VT_BUFFGROUPINDEX,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn innerSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveBuffItemData::VT_INNERSORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveBuffItemData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveBuffItemData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn usage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveBuffItemData::VT_USAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveBuffItemData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn color(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveBuffItemData::VT_COLOR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveBuffItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .visit_field::<i32>("buffGroupIndex", Self::VT_BUFFGROUPINDEX, false)?
            .visit_field::<i32>("innerSortId", Self::VT_INNERSORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("usage", Self::VT_USAGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("color", Self::VT_COLOR, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveBuffItemDataArgs<'a> {
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffGroupIndex: i32,
    pub innerSortId: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub usage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub color: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveBuffItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveBuffItemDataArgs {
            buffId: None,
            buffGroupIndex: 0,
            innerSortId: 0,
            name: None,
            iconId: None,
            usage: None,
            desc: None,
            color: None,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveBuffItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveBuffItemData", 8)?;
        if let Some(f) = self.buffId() {
            s.serialize_field("buffId", &f)?;
        } else {
            s.skip_field("buffId")?;
        }
        s.serialize_field("buffGroupIndex", &self.buffGroupIndex())?;
        s.serialize_field("innerSortId", &self.innerSortId())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.usage() {
            s.serialize_field("usage", &f)?;
        } else {
            s.skip_field("usage")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.color() {
            s.serialize_field("color", &f)?;
        } else {
            s.skip_field("color")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveBuffItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveBuffItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveBuffItemData::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn add_buffGroupIndex(&mut self, buffGroupIndex: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchiveBuffItemData::VT_BUFFGROUPINDEX,
            buffGroupIndex,
            0,
        );
    }
    #[inline]
    pub fn add_innerSortId(&mut self, innerSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_ActArchiveBuffItemData::VT_INNERSORTID,
            innerSortId,
            0,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveBuffItemData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveBuffItemData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_usage(&mut self, usage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveBuffItemData::VT_USAGE,
            usage,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveBuffItemData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_color(&mut self, color: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveBuffItemData::VT_COLOR,
            color,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveBuffItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveBuffItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveBuffItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveBuffItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveBuffItemData");
        ds.field("buffId", &self.buffId());
        ds.field("buffGroupIndex", &self.buffGroupIndex());
        ds.field("innerSortId", &self.innerSortId());
        ds.field("name", &self.name());
        ds.field("iconId", &self.iconId());
        ds.field("usage", &self.usage());
        ds.field("desc", &self.desc());
        ds.field("color", &self.color());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveBuffItemDataT {
    pub buffId: Option<String>,
    pub buffGroupIndex: i32,
    pub innerSortId: i32,
    pub name: Option<String>,
    pub iconId: Option<String>,
    pub usage: Option<String>,
    pub desc: Option<String>,
    pub color: Option<String>,
}
impl Default for clz_Torappu_ActArchiveBuffItemDataT {
    fn default() -> Self {
        Self {
            buffId: None,
            buffGroupIndex: 0,
            innerSortId: 0,
            name: None,
            iconId: None,
            usage: None,
            desc: None,
            color: None,
        }
    }
}
impl clz_Torappu_ActArchiveBuffItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveBuffItemData<'b>> {
        let buffId = self.buffId.as_ref().map(|x| _fbb.create_string(x));
        let buffGroupIndex = self.buffGroupIndex;
        let innerSortId = self.innerSortId;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let usage = self.usage.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let color = self.color.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ActArchiveBuffItemData::create(
            _fbb,
            &clz_Torappu_ActArchiveBuffItemDataArgs {
                buffId,
                buffGroupIndex,
                innerSortId,
                name,
                iconId,
                usage,
                desc,
                color,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActArchiveBuffItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveBuffItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveBuffItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveBuffItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveBuffItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveBuffItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveBuffItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveBuffItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveBuffItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActArchiveBuffItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActArchiveBuffItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveBuffItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveBuffItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveBuffItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveBuffItemData>>(
                    dict__string__clz_Torappu_ActArchiveBuffItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveBuffItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveBuffItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveBuffItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveBuffItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveBuffItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveBuffItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActArchiveBuffItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ActArchiveBuffItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActArchiveBuffItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveBuffItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveBuffItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveBuffItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveBuffItemData>>(
                dict__string__clz_Torappu_ActArchiveBuffItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveBuffItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveBuffItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveBuffItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveBuffItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveBuffItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveBuffItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActArchiveBuffItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActArchiveBuffItemDataT>>,
}
impl Default for dict__string__clz_Torappu_ActArchiveBuffItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActArchiveBuffItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveBuffItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActArchiveBuffItemData::create(
            _fbb,
            &dict__string__clz_Torappu_ActArchiveBuffItemDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActArchiveBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveBuffData<'a> {
    type Inner = clz_Torappu_ActArchiveBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveBuffData<'a> {
    pub const VT_BUFF: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveBuffData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveBuffDataBuilder::new(_fbb);
        if let Some(x) = args.buff {
            builder.add_buff(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveBuffDataT {
        let buff = self.buff().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActArchiveBuffDataT { buff }
    }

    #[inline]
    pub fn buff(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveBuffItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveBuffItemData>,
                >,
            >>(clz_Torappu_ActArchiveBuffData::VT_BUFF, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveBuffItemData>,
                >,
            >>("buff", Self::VT_BUFF, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveBuffDataArgs<'a> {
    pub buff: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveBuffItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveBuffDataArgs { buff: None }
    }
}

impl Serialize for clz_Torappu_ActArchiveBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveBuffData", 1)?;
        if let Some(f) = self.buff() {
            s.serialize_field("buff", &f)?;
        } else {
            s.skip_field("buff")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveBuffDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ActArchiveBuffDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_buff(
        &mut self,
        buff: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveBuffItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveBuffData::VT_BUFF,
            buff,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveBuffData");
        ds.field("buff", &self.buff());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveBuffDataT {
    pub buff: Option<Vec<dict__string__clz_Torappu_ActArchiveBuffItemDataT>>,
}
impl Default for clz_Torappu_ActArchiveBuffDataT {
    fn default() -> Self {
        Self { buff: None }
    }
}
impl clz_Torappu_ActArchiveBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveBuffData<'b>> {
        let buff = self.buff.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActArchiveBuffData::create(_fbb, &clz_Torappu_ActArchiveBuffDataArgs { buff })
    }
}
pub enum clz_Torappu_ActArchiveTotemItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveTotemItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveTotemItemData<'a> {
    type Inner = clz_Torappu_ActArchiveTotemItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveTotemItemData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_ENROLLCONDITIONID: flatbuffers::VOffsetT = 8;
    pub const VT_SORTID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveTotemItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveTotemItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTotemItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveTotemItemDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.enrollConditionId {
            builder.add_enrollConditionId(x);
        }
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveTotemItemDataT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        let enrollConditionId = self.enrollConditionId().map(|x| x.to_string());
        let sortId = self.sortId();
        clz_Torappu_ActArchiveTotemItemDataT {
            id,
            type_,
            enrollConditionId,
            sortId,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveTotemItemData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ActArchiveTotemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ActArchiveTotemType>(
                    clz_Torappu_ActArchiveTotemItemData::VT_TYPE_,
                    Some(enum__Torappu_ActArchiveTotemType::LOCATION),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn enrollConditionId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveTotemItemData::VT_ENROLLCONDITIONID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveTotemItemData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveTotemItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_ActArchiveTotemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollConditionId",
                Self::VT_ENROLLCONDITIONID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveTotemItemDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_ActArchiveTotemType,
    pub enrollConditionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_ActArchiveTotemItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveTotemItemDataArgs {
            id: None,
            type_: enum__Torappu_ActArchiveTotemType::LOCATION,
            enrollConditionId: None,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveTotemItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveTotemItemData", 4)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.enrollConditionId() {
            s.serialize_field("enrollConditionId", &f)?;
        } else {
            s.skip_field("enrollConditionId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveTotemItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveTotemItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTotemItemData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ActArchiveTotemType) {
        self.fbb_.push_slot::<enum__Torappu_ActArchiveTotemType>(
            clz_Torappu_ActArchiveTotemItemData::VT_TYPE_,
            type_,
            enum__Torappu_ActArchiveTotemType::LOCATION,
        );
    }
    #[inline]
    pub fn add_enrollConditionId(&mut self, enrollConditionId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTotemItemData::VT_ENROLLCONDITIONID,
            enrollConditionId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ActArchiveTotemItemData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveTotemItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveTotemItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTotemItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveTotemItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveTotemItemData");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("enrollConditionId", &self.enrollConditionId());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveTotemItemDataT {
    pub id: Option<String>,
    pub type_: enum__Torappu_ActArchiveTotemType,
    pub enrollConditionId: Option<String>,
    pub sortId: i32,
}
impl Default for clz_Torappu_ActArchiveTotemItemDataT {
    fn default() -> Self {
        Self {
            id: None,
            type_: enum__Torappu_ActArchiveTotemType::LOCATION,
            enrollConditionId: None,
            sortId: 0,
        }
    }
}
impl clz_Torappu_ActArchiveTotemItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTotemItemData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let enrollConditionId = self
            .enrollConditionId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        clz_Torappu_ActArchiveTotemItemData::create(
            _fbb,
            &clz_Torappu_ActArchiveTotemItemDataArgs {
                id,
                type_,
                enrollConditionId,
                sortId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActArchiveTotemItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveTotemItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveTotemItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveTotemItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveTotemItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveTotemItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveTotemItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveTotemItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveTotemItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActArchiveTotemItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActArchiveTotemItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveTotemItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveTotemItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveTotemItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveTotemItemData>>(
                    dict__string__clz_Torappu_ActArchiveTotemItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveTotemItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveTotemItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveTotemItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveTotemItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveTotemItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveTotemItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActArchiveTotemItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ActArchiveTotemItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActArchiveTotemItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveTotemItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveTotemItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveTotemItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveTotemItemData>>(
                dict__string__clz_Torappu_ActArchiveTotemItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveTotemItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveTotemItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveTotemItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveTotemItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveTotemItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveTotemItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActArchiveTotemItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActArchiveTotemItemDataT>>,
}
impl Default for dict__string__clz_Torappu_ActArchiveTotemItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActArchiveTotemItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveTotemItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActArchiveTotemItemData::create(
            _fbb,
            &dict__string__clz_Torappu_ActArchiveTotemItemDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActArchiveTotemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveTotemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveTotemData<'a> {
    type Inner = clz_Torappu_ActArchiveTotemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveTotemData<'a> {
    pub const VT_TOTEM: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveTotemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveTotemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTotemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveTotemDataBuilder::new(_fbb);
        if let Some(x) = args.totem {
            builder.add_totem(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveTotemDataT {
        let totem = self.totem().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActArchiveTotemDataT { totem }
    }

    #[inline]
    pub fn totem(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveTotemItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveTotemItemData>,
                >,
            >>(clz_Torappu_ActArchiveTotemData::VT_TOTEM, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveTotemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveTotemItemData>,
                >,
            >>("totem", Self::VT_TOTEM, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveTotemDataArgs<'a> {
    pub totem: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveTotemItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveTotemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveTotemDataArgs { totem: None }
    }
}

impl Serialize for clz_Torappu_ActArchiveTotemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveTotemData", 1)?;
        if let Some(f) = self.totem() {
            s.serialize_field("totem", &f)?;
        } else {
            s.skip_field("totem")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveTotemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ActArchiveTotemDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_totem(
        &mut self,
        totem: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveTotemItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveTotemData::VT_TOTEM,
            totem,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveTotemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveTotemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTotemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveTotemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveTotemData");
        ds.field("totem", &self.totem());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveTotemDataT {
    pub totem: Option<Vec<dict__string__clz_Torappu_ActArchiveTotemItemDataT>>,
}
impl Default for clz_Torappu_ActArchiveTotemDataT {
    fn default() -> Self {
        Self { totem: None }
    }
}
impl clz_Torappu_ActArchiveTotemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveTotemData<'b>> {
        let totem = self.totem.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActArchiveTotemData::create(
            _fbb,
            &clz_Torappu_ActArchiveTotemDataArgs { totem },
        )
    }
}
pub enum clz_Torappu_ActArchiveChaosItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveChaosItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveChaosItemData<'a> {
    type Inner = clz_Torappu_ActArchiveChaosItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveChaosItemData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_ISHIDDEN: flatbuffers::VOffsetT = 6;
    pub const VT_ENROLLID: flatbuffers::VOffsetT = 8;
    pub const VT_SORTID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveChaosItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveChaosItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChaosItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveChaosItemDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.enrollId {
            builder.add_enrollId(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_isHidden(args.isHidden);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveChaosItemDataT {
        let id = self.id().map(|x| x.to_string());
        let isHidden = self.isHidden();
        let enrollId = self.enrollId().map(|x| x.to_string());
        let sortId = self.sortId();
        clz_Torappu_ActArchiveChaosItemDataT {
            id,
            isHidden,
            enrollId,
            sortId,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveChaosItemData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn isHidden(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_ActArchiveChaosItemData::VT_ISHIDDEN,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn enrollId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveChaosItemData::VT_ENROLLID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveChaosItemData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveChaosItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<bool>("isHidden", Self::VT_ISHIDDEN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollId",
                Self::VT_ENROLLID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveChaosItemDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isHidden: bool,
    pub enrollId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_ActArchiveChaosItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveChaosItemDataArgs {
            id: None,
            isHidden: false,
            enrollId: None,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveChaosItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveChaosItemData", 4)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("isHidden", &self.isHidden())?;
        if let Some(f) = self.enrollId() {
            s.serialize_field("enrollId", &f)?;
        } else {
            s.skip_field("enrollId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveChaosItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveChaosItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveChaosItemData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_isHidden(&mut self, isHidden: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_ActArchiveChaosItemData::VT_ISHIDDEN,
            isHidden,
            false,
        );
    }
    #[inline]
    pub fn add_enrollId(&mut self, enrollId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveChaosItemData::VT_ENROLLID,
            enrollId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ActArchiveChaosItemData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveChaosItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveChaosItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChaosItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveChaosItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveChaosItemData");
        ds.field("id", &self.id());
        ds.field("isHidden", &self.isHidden());
        ds.field("enrollId", &self.enrollId());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveChaosItemDataT {
    pub id: Option<String>,
    pub isHidden: bool,
    pub enrollId: Option<String>,
    pub sortId: i32,
}
impl Default for clz_Torappu_ActArchiveChaosItemDataT {
    fn default() -> Self {
        Self {
            id: None,
            isHidden: false,
            enrollId: None,
            sortId: 0,
        }
    }
}
impl clz_Torappu_ActArchiveChaosItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChaosItemData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let isHidden = self.isHidden;
        let enrollId = self.enrollId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        clz_Torappu_ActArchiveChaosItemData::create(
            _fbb,
            &clz_Torappu_ActArchiveChaosItemDataArgs {
                id,
                isHidden,
                enrollId,
                sortId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActArchiveChaosItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveChaosItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveChaosItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveChaosItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveChaosItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveChaosItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveChaosItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveChaosItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveChaosItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActArchiveChaosItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActArchiveChaosItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveChaosItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveChaosItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveChaosItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChaosItemData>>(
                    dict__string__clz_Torappu_ActArchiveChaosItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveChaosItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChaosItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveChaosItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveChaosItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveChaosItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveChaosItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActArchiveChaosItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ActArchiveChaosItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActArchiveChaosItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveChaosItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveChaosItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveChaosItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveChaosItemData>>(
                dict__string__clz_Torappu_ActArchiveChaosItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveChaosItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveChaosItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveChaosItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveChaosItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveChaosItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveChaosItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActArchiveChaosItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActArchiveChaosItemDataT>>,
}
impl Default for dict__string__clz_Torappu_ActArchiveChaosItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActArchiveChaosItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveChaosItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActArchiveChaosItemData::create(
            _fbb,
            &dict__string__clz_Torappu_ActArchiveChaosItemDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActArchiveChaosDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveChaosData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveChaosData<'a> {
    type Inner = clz_Torappu_ActArchiveChaosData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveChaosData<'a> {
    pub const VT_CHAOS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveChaosData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveChaosDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChaosData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveChaosDataBuilder::new(_fbb);
        if let Some(x) = args.chaos {
            builder.add_chaos(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveChaosDataT {
        let chaos = self.chaos().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActArchiveChaosDataT { chaos }
    }

    #[inline]
    pub fn chaos(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveChaosItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveChaosItemData>,
                >,
            >>(clz_Torappu_ActArchiveChaosData::VT_CHAOS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveChaosData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveChaosItemData>,
                >,
            >>("chaos", Self::VT_CHAOS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveChaosDataArgs<'a> {
    pub chaos: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveChaosItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveChaosDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveChaosDataArgs { chaos: None }
    }
}

impl Serialize for clz_Torappu_ActArchiveChaosData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveChaosData", 1)?;
        if let Some(f) = self.chaos() {
            s.serialize_field("chaos", &f)?;
        } else {
            s.skip_field("chaos")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveChaosDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ActArchiveChaosDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_chaos(
        &mut self,
        chaos: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveChaosItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveChaosData::VT_CHAOS,
            chaos,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveChaosDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveChaosDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChaosData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveChaosData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveChaosData");
        ds.field("chaos", &self.chaos());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveChaosDataT {
    pub chaos: Option<Vec<dict__string__clz_Torappu_ActArchiveChaosItemDataT>>,
}
impl Default for clz_Torappu_ActArchiveChaosDataT {
    fn default() -> Self {
        Self { chaos: None }
    }
}
impl clz_Torappu_ActArchiveChaosDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveChaosData<'b>> {
        let chaos = self.chaos.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActArchiveChaosData::create(
            _fbb,
            &clz_Torappu_ActArchiveChaosDataArgs { chaos },
        )
    }
}
pub enum clz_Torappu_ActArchiveFragmentItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveFragmentItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveFragmentItemData<'a> {
    type Inner = clz_Torappu_ActArchiveFragmentItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveFragmentItemData<'a> {
    pub const VT_FRAGMENTID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_ENROLLCONDITIONID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveFragmentItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveFragmentItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveFragmentItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveFragmentItemDataBuilder::new(_fbb);
        if let Some(x) = args.enrollConditionId {
            builder.add_enrollConditionId(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.fragmentId {
            builder.add_fragmentId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveFragmentItemDataT {
        let fragmentId = self.fragmentId().map(|x| x.to_string());
        let sortId = self.sortId();
        let enrollConditionId = self.enrollConditionId().map(|x| x.to_string());
        clz_Torappu_ActArchiveFragmentItemDataT {
            fragmentId,
            sortId,
            enrollConditionId,
        }
    }

    #[inline]
    pub fn fragmentId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveFragmentItemData::VT_FRAGMENTID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveFragmentItemData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn enrollConditionId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveFragmentItemData::VT_ENROLLCONDITIONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveFragmentItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "fragmentId",
                Self::VT_FRAGMENTID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollConditionId",
                Self::VT_ENROLLCONDITIONID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveFragmentItemDataArgs<'a> {
    pub fragmentId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub enrollConditionId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveFragmentItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveFragmentItemDataArgs {
            fragmentId: None,
            sortId: 0,
            enrollConditionId: None,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveFragmentItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveFragmentItemData", 3)?;
        if let Some(f) = self.fragmentId() {
            s.serialize_field("fragmentId", &f)?;
        } else {
            s.skip_field("fragmentId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.enrollConditionId() {
            s.serialize_field("enrollConditionId", &f)?;
        } else {
            s.skip_field("enrollConditionId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveFragmentItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveFragmentItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_fragmentId(&mut self, fragmentId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveFragmentItemData::VT_FRAGMENTID,
            fragmentId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ActArchiveFragmentItemData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_enrollConditionId(&mut self, enrollConditionId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveFragmentItemData::VT_ENROLLCONDITIONID,
            enrollConditionId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveFragmentItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveFragmentItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveFragmentItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveFragmentItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveFragmentItemData");
        ds.field("fragmentId", &self.fragmentId());
        ds.field("sortId", &self.sortId());
        ds.field("enrollConditionId", &self.enrollConditionId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveFragmentItemDataT {
    pub fragmentId: Option<String>,
    pub sortId: i32,
    pub enrollConditionId: Option<String>,
}
impl Default for clz_Torappu_ActArchiveFragmentItemDataT {
    fn default() -> Self {
        Self {
            fragmentId: None,
            sortId: 0,
            enrollConditionId: None,
        }
    }
}
impl clz_Torappu_ActArchiveFragmentItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveFragmentItemData<'b>> {
        let fragmentId = self.fragmentId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let enrollConditionId = self
            .enrollConditionId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_ActArchiveFragmentItemData::create(
            _fbb,
            &clz_Torappu_ActArchiveFragmentItemDataArgs {
                fragmentId,
                sortId,
                enrollConditionId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActArchiveFragmentItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveFragmentItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveFragmentItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveFragmentItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveFragmentItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveFragmentItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveFragmentItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveFragmentItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveFragmentItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActArchiveFragmentItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActArchiveFragmentItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveFragmentItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveFragmentItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveFragmentItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveFragmentItemData>>(
                    dict__string__clz_Torappu_ActArchiveFragmentItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveFragmentItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveFragmentItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveFragmentItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveFragmentItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveFragmentItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveFragmentItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActArchiveFragmentItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_ActArchiveFragmentItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActArchiveFragmentItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveFragmentItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveFragmentItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveFragmentItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveFragmentItemData>>(
                dict__string__clz_Torappu_ActArchiveFragmentItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveFragmentItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveFragmentItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveFragmentItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveFragmentItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveFragmentItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveFragmentItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActArchiveFragmentItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActArchiveFragmentItemDataT>>,
}
impl Default for dict__string__clz_Torappu_ActArchiveFragmentItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActArchiveFragmentItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveFragmentItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActArchiveFragmentItemData::create(
            _fbb,
            &dict__string__clz_Torappu_ActArchiveFragmentItemDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActArchiveFragmentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveFragmentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveFragmentData<'a> {
    type Inner = clz_Torappu_ActArchiveFragmentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveFragmentData<'a> {
    pub const VT_FRAGMENT: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveFragmentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveFragmentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveFragmentData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveFragmentDataBuilder::new(_fbb);
        if let Some(x) = args.fragment {
            builder.add_fragment(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveFragmentDataT {
        let fragment = self
            .fragment()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActArchiveFragmentDataT { fragment }
    }

    #[inline]
    pub fn fragment(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveFragmentItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveFragmentItemData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveFragmentData::VT_FRAGMENT, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveFragmentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveFragmentItemData,
                    >,
                >,
            >>("fragment", Self::VT_FRAGMENT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveFragmentDataArgs<'a> {
    pub fragment: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveFragmentItemData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveFragmentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveFragmentDataArgs { fragment: None }
    }
}

impl Serialize for clz_Torappu_ActArchiveFragmentData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveFragmentData", 1)?;
        if let Some(f) = self.fragment() {
            s.serialize_field("fragment", &f)?;
        } else {
            s.skip_field("fragment")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveFragmentDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveFragmentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_fragment(
        &mut self,
        fragment: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveFragmentItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveFragmentData::VT_FRAGMENT,
            fragment,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveFragmentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveFragmentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveFragmentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveFragmentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveFragmentData");
        ds.field("fragment", &self.fragment());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveFragmentDataT {
    pub fragment: Option<Vec<dict__string__clz_Torappu_ActArchiveFragmentItemDataT>>,
}
impl Default for clz_Torappu_ActArchiveFragmentDataT {
    fn default() -> Self {
        Self { fragment: None }
    }
}
impl clz_Torappu_ActArchiveFragmentDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveFragmentData<'b>> {
        let fragment = self.fragment.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActArchiveFragmentData::create(
            _fbb,
            &clz_Torappu_ActArchiveFragmentDataArgs { fragment },
        )
    }
}
pub enum clz_Torappu_ActArchiveDisasterItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveDisasterItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveDisasterItemData<'a> {
    type Inner = clz_Torappu_ActArchiveDisasterItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveDisasterItemData<'a> {
    pub const VT_DISASTERID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_ENROLLCONDITIONID: flatbuffers::VOffsetT = 8;
    pub const VT_PICSMALLID: flatbuffers::VOffsetT = 10;
    pub const VT_PICBIGACTIVEID: flatbuffers::VOffsetT = 12;
    pub const VT_PICBIGINACTIVEID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveDisasterItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveDisasterItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveDisasterItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveDisasterItemDataBuilder::new(_fbb);
        if let Some(x) = args.picBigInactiveId {
            builder.add_picBigInactiveId(x);
        }
        if let Some(x) = args.picBigActiveId {
            builder.add_picBigActiveId(x);
        }
        if let Some(x) = args.picSmallId {
            builder.add_picSmallId(x);
        }
        if let Some(x) = args.enrollConditionId {
            builder.add_enrollConditionId(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.disasterId {
            builder.add_disasterId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveDisasterItemDataT {
        let disasterId = self.disasterId().map(|x| x.to_string());
        let sortId = self.sortId();
        let enrollConditionId = self.enrollConditionId().map(|x| x.to_string());
        let picSmallId = self.picSmallId().map(|x| x.to_string());
        let picBigActiveId = self.picBigActiveId().map(|x| x.to_string());
        let picBigInactiveId = self.picBigInactiveId().map(|x| x.to_string());
        clz_Torappu_ActArchiveDisasterItemDataT {
            disasterId,
            sortId,
            enrollConditionId,
            picSmallId,
            picBigActiveId,
            picBigInactiveId,
        }
    }

    #[inline]
    pub fn disasterId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveDisasterItemData::VT_DISASTERID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveDisasterItemData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn enrollConditionId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveDisasterItemData::VT_ENROLLCONDITIONID,
                None,
            )
        }
    }
    #[inline]
    pub fn picSmallId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveDisasterItemData::VT_PICSMALLID,
                None,
            )
        }
    }
    #[inline]
    pub fn picBigActiveId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveDisasterItemData::VT_PICBIGACTIVEID,
                None,
            )
        }
    }
    #[inline]
    pub fn picBigInactiveId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveDisasterItemData::VT_PICBIGINACTIVEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveDisasterItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "disasterId",
                Self::VT_DISASTERID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollConditionId",
                Self::VT_ENROLLCONDITIONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "picSmallId",
                Self::VT_PICSMALLID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "picBigActiveId",
                Self::VT_PICBIGACTIVEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "picBigInactiveId",
                Self::VT_PICBIGINACTIVEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveDisasterItemDataArgs<'a> {
    pub disasterId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub enrollConditionId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picSmallId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picBigActiveId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picBigInactiveId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveDisasterItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveDisasterItemDataArgs {
            disasterId: None,
            sortId: 0,
            enrollConditionId: None,
            picSmallId: None,
            picBigActiveId: None,
            picBigInactiveId: None,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveDisasterItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveDisasterItemData", 6)?;
        if let Some(f) = self.disasterId() {
            s.serialize_field("disasterId", &f)?;
        } else {
            s.skip_field("disasterId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.enrollConditionId() {
            s.serialize_field("enrollConditionId", &f)?;
        } else {
            s.skip_field("enrollConditionId")?;
        }
        if let Some(f) = self.picSmallId() {
            s.serialize_field("picSmallId", &f)?;
        } else {
            s.skip_field("picSmallId")?;
        }
        if let Some(f) = self.picBigActiveId() {
            s.serialize_field("picBigActiveId", &f)?;
        } else {
            s.skip_field("picBigActiveId")?;
        }
        if let Some(f) = self.picBigInactiveId() {
            s.serialize_field("picBigInactiveId", &f)?;
        } else {
            s.skip_field("picBigInactiveId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveDisasterItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveDisasterItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_disasterId(&mut self, disasterId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveDisasterItemData::VT_DISASTERID,
            disasterId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ActArchiveDisasterItemData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_enrollConditionId(&mut self, enrollConditionId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveDisasterItemData::VT_ENROLLCONDITIONID,
            enrollConditionId,
        );
    }
    #[inline]
    pub fn add_picSmallId(&mut self, picSmallId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveDisasterItemData::VT_PICSMALLID,
            picSmallId,
        );
    }
    #[inline]
    pub fn add_picBigActiveId(&mut self, picBigActiveId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveDisasterItemData::VT_PICBIGACTIVEID,
            picBigActiveId,
        );
    }
    #[inline]
    pub fn add_picBigInactiveId(&mut self, picBigInactiveId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveDisasterItemData::VT_PICBIGINACTIVEID,
            picBigInactiveId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveDisasterItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveDisasterItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveDisasterItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveDisasterItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveDisasterItemData");
        ds.field("disasterId", &self.disasterId());
        ds.field("sortId", &self.sortId());
        ds.field("enrollConditionId", &self.enrollConditionId());
        ds.field("picSmallId", &self.picSmallId());
        ds.field("picBigActiveId", &self.picBigActiveId());
        ds.field("picBigInactiveId", &self.picBigInactiveId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveDisasterItemDataT {
    pub disasterId: Option<String>,
    pub sortId: i32,
    pub enrollConditionId: Option<String>,
    pub picSmallId: Option<String>,
    pub picBigActiveId: Option<String>,
    pub picBigInactiveId: Option<String>,
}
impl Default for clz_Torappu_ActArchiveDisasterItemDataT {
    fn default() -> Self {
        Self {
            disasterId: None,
            sortId: 0,
            enrollConditionId: None,
            picSmallId: None,
            picBigActiveId: None,
            picBigInactiveId: None,
        }
    }
}
impl clz_Torappu_ActArchiveDisasterItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveDisasterItemData<'b>> {
        let disasterId = self.disasterId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let enrollConditionId = self
            .enrollConditionId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let picSmallId = self.picSmallId.as_ref().map(|x| _fbb.create_string(x));
        let picBigActiveId = self.picBigActiveId.as_ref().map(|x| _fbb.create_string(x));
        let picBigInactiveId = self
            .picBigInactiveId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_ActArchiveDisasterItemData::create(
            _fbb,
            &clz_Torappu_ActArchiveDisasterItemDataArgs {
                disasterId,
                sortId,
                enrollConditionId,
                picSmallId,
                picBigActiveId,
                picBigInactiveId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActArchiveDisasterItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveDisasterItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveDisasterItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveDisasterItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveDisasterItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveDisasterItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveDisasterItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveDisasterItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveDisasterItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActArchiveDisasterItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActArchiveDisasterItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveDisasterItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveDisasterItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveDisasterItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveDisasterItemData>>(
                    dict__string__clz_Torappu_ActArchiveDisasterItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveDisasterItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveDisasterItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveDisasterItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveDisasterItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveDisasterItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveDisasterItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActArchiveDisasterItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_ActArchiveDisasterItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActArchiveDisasterItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveDisasterItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveDisasterItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveDisasterItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveDisasterItemData>>(
                dict__string__clz_Torappu_ActArchiveDisasterItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveDisasterItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveDisasterItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveDisasterItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveDisasterItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveDisasterItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveDisasterItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActArchiveDisasterItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActArchiveDisasterItemDataT>>,
}
impl Default for dict__string__clz_Torappu_ActArchiveDisasterItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActArchiveDisasterItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveDisasterItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActArchiveDisasterItemData::create(
            _fbb,
            &dict__string__clz_Torappu_ActArchiveDisasterItemDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActArchiveDisasterDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveDisasterData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveDisasterData<'a> {
    type Inner = clz_Torappu_ActArchiveDisasterData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveDisasterData<'a> {
    pub const VT_DISASTERS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveDisasterData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveDisasterDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveDisasterData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveDisasterDataBuilder::new(_fbb);
        if let Some(x) = args.disasters {
            builder.add_disasters(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveDisasterDataT {
        let disasters = self
            .disasters()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActArchiveDisasterDataT { disasters }
    }

    #[inline]
    pub fn disasters(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveDisasterItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveDisasterItemData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveDisasterData::VT_DISASTERS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveDisasterData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveDisasterItemData,
                    >,
                >,
            >>("disasters", Self::VT_DISASTERS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveDisasterDataArgs<'a> {
    pub disasters: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveDisasterItemData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveDisasterDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveDisasterDataArgs { disasters: None }
    }
}

impl Serialize for clz_Torappu_ActArchiveDisasterData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveDisasterData", 1)?;
        if let Some(f) = self.disasters() {
            s.serialize_field("disasters", &f)?;
        } else {
            s.skip_field("disasters")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveDisasterDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveDisasterDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_disasters(
        &mut self,
        disasters: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveDisasterItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveDisasterData::VT_DISASTERS,
            disasters,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveDisasterDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveDisasterDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveDisasterData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveDisasterData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveDisasterData");
        ds.field("disasters", &self.disasters());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveDisasterDataT {
    pub disasters: Option<Vec<dict__string__clz_Torappu_ActArchiveDisasterItemDataT>>,
}
impl Default for clz_Torappu_ActArchiveDisasterDataT {
    fn default() -> Self {
        Self { disasters: None }
    }
}
impl clz_Torappu_ActArchiveDisasterDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveDisasterData<'b>> {
        let disasters = self.disasters.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActArchiveDisasterData::create(
            _fbb,
            &clz_Torappu_ActArchiveDisasterDataArgs { disasters },
        )
    }
}
pub enum clz_Torappu_ActArchiveWrathItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveWrathItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveWrathItemData<'a> {
    type Inner = clz_Torappu_ActArchiveWrathItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveWrathItemData<'a> {
    pub const VT_WRATHID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_PICTITLEID: flatbuffers::VOffsetT = 8;
    pub const VT_PICSMALLINACTIVEID: flatbuffers::VOffsetT = 10;
    pub const VT_PICSMALLACTIVEID: flatbuffers::VOffsetT = 12;
    pub const VT_PICBIGACTIVEID: flatbuffers::VOffsetT = 14;
    pub const VT_PICBIGINACTIVEID: flatbuffers::VOffsetT = 16;
    pub const VT_ENROLLID: flatbuffers::VOffsetT = 18;
    pub const VT_ISSP: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveWrathItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveWrathItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveWrathItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveWrathItemDataBuilder::new(_fbb);
        if let Some(x) = args.enrollId {
            builder.add_enrollId(x);
        }
        if let Some(x) = args.picBigInactiveId {
            builder.add_picBigInactiveId(x);
        }
        if let Some(x) = args.picBigActiveId {
            builder.add_picBigActiveId(x);
        }
        if let Some(x) = args.picSmallActiveId {
            builder.add_picSmallActiveId(x);
        }
        if let Some(x) = args.picSmallInactiveId {
            builder.add_picSmallInactiveId(x);
        }
        if let Some(x) = args.picTitleId {
            builder.add_picTitleId(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.wrathId {
            builder.add_wrathId(x);
        }
        builder.add_isSp(args.isSp);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveWrathItemDataT {
        let wrathId = self.wrathId().map(|x| x.to_string());
        let sortId = self.sortId();
        let picTitleId = self.picTitleId().map(|x| x.to_string());
        let picSmallInactiveId = self.picSmallInactiveId().map(|x| x.to_string());
        let picSmallActiveId = self.picSmallActiveId().map(|x| x.to_string());
        let picBigActiveId = self.picBigActiveId().map(|x| x.to_string());
        let picBigInactiveId = self.picBigInactiveId().map(|x| x.to_string());
        let enrollId = self.enrollId().map(|x| x.to_string());
        let isSp = self.isSp();
        clz_Torappu_ActArchiveWrathItemDataT {
            wrathId,
            sortId,
            picTitleId,
            picSmallInactiveId,
            picSmallActiveId,
            picBigActiveId,
            picBigInactiveId,
            enrollId,
            isSp,
        }
    }

    #[inline]
    pub fn wrathId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveWrathItemData::VT_WRATHID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveWrathItemData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn picTitleId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveWrathItemData::VT_PICTITLEID,
                None,
            )
        }
    }
    #[inline]
    pub fn picSmallInactiveId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveWrathItemData::VT_PICSMALLINACTIVEID,
                None,
            )
        }
    }
    #[inline]
    pub fn picSmallActiveId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveWrathItemData::VT_PICSMALLACTIVEID,
                None,
            )
        }
    }
    #[inline]
    pub fn picBigActiveId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveWrathItemData::VT_PICBIGACTIVEID,
                None,
            )
        }
    }
    #[inline]
    pub fn picBigInactiveId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveWrathItemData::VT_PICBIGINACTIVEID,
                None,
            )
        }
    }
    #[inline]
    pub fn enrollId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveWrathItemData::VT_ENROLLID,
                None,
            )
        }
    }
    #[inline]
    pub fn isSp(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_ActArchiveWrathItemData::VT_ISSP, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveWrathItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("wrathId", Self::VT_WRATHID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "picTitleId",
                Self::VT_PICTITLEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "picSmallInactiveId",
                Self::VT_PICSMALLINACTIVEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "picSmallActiveId",
                Self::VT_PICSMALLACTIVEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "picBigActiveId",
                Self::VT_PICBIGACTIVEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "picBigInactiveId",
                Self::VT_PICBIGINACTIVEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollId",
                Self::VT_ENROLLID,
                false,
            )?
            .visit_field::<bool>("isSp", Self::VT_ISSP, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveWrathItemDataArgs<'a> {
    pub wrathId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub picTitleId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picSmallInactiveId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picSmallActiveId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picBigActiveId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub picBigInactiveId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enrollId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isSp: bool,
}
impl<'a> Default for clz_Torappu_ActArchiveWrathItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveWrathItemDataArgs {
            wrathId: None,
            sortId: 0,
            picTitleId: None,
            picSmallInactiveId: None,
            picSmallActiveId: None,
            picBigActiveId: None,
            picBigInactiveId: None,
            enrollId: None,
            isSp: false,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveWrathItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveWrathItemData", 9)?;
        if let Some(f) = self.wrathId() {
            s.serialize_field("wrathId", &f)?;
        } else {
            s.skip_field("wrathId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.picTitleId() {
            s.serialize_field("picTitleId", &f)?;
        } else {
            s.skip_field("picTitleId")?;
        }
        if let Some(f) = self.picSmallInactiveId() {
            s.serialize_field("picSmallInactiveId", &f)?;
        } else {
            s.skip_field("picSmallInactiveId")?;
        }
        if let Some(f) = self.picSmallActiveId() {
            s.serialize_field("picSmallActiveId", &f)?;
        } else {
            s.skip_field("picSmallActiveId")?;
        }
        if let Some(f) = self.picBigActiveId() {
            s.serialize_field("picBigActiveId", &f)?;
        } else {
            s.skip_field("picBigActiveId")?;
        }
        if let Some(f) = self.picBigInactiveId() {
            s.serialize_field("picBigInactiveId", &f)?;
        } else {
            s.skip_field("picBigInactiveId")?;
        }
        if let Some(f) = self.enrollId() {
            s.serialize_field("enrollId", &f)?;
        } else {
            s.skip_field("enrollId")?;
        }
        s.serialize_field("isSp", &self.isSp())?;
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveWrathItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveWrathItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_wrathId(&mut self, wrathId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveWrathItemData::VT_WRATHID,
            wrathId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ActArchiveWrathItemData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_picTitleId(&mut self, picTitleId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveWrathItemData::VT_PICTITLEID,
            picTitleId,
        );
    }
    #[inline]
    pub fn add_picSmallInactiveId(&mut self, picSmallInactiveId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveWrathItemData::VT_PICSMALLINACTIVEID,
            picSmallInactiveId,
        );
    }
    #[inline]
    pub fn add_picSmallActiveId(&mut self, picSmallActiveId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveWrathItemData::VT_PICSMALLACTIVEID,
            picSmallActiveId,
        );
    }
    #[inline]
    pub fn add_picBigActiveId(&mut self, picBigActiveId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveWrathItemData::VT_PICBIGACTIVEID,
            picBigActiveId,
        );
    }
    #[inline]
    pub fn add_picBigInactiveId(&mut self, picBigInactiveId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveWrathItemData::VT_PICBIGINACTIVEID,
            picBigInactiveId,
        );
    }
    #[inline]
    pub fn add_enrollId(&mut self, enrollId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveWrathItemData::VT_ENROLLID,
            enrollId,
        );
    }
    #[inline]
    pub fn add_isSp(&mut self, isSp: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_ActArchiveWrathItemData::VT_ISSP, isSp, false);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveWrathItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveWrathItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveWrathItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveWrathItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveWrathItemData");
        ds.field("wrathId", &self.wrathId());
        ds.field("sortId", &self.sortId());
        ds.field("picTitleId", &self.picTitleId());
        ds.field("picSmallInactiveId", &self.picSmallInactiveId());
        ds.field("picSmallActiveId", &self.picSmallActiveId());
        ds.field("picBigActiveId", &self.picBigActiveId());
        ds.field("picBigInactiveId", &self.picBigInactiveId());
        ds.field("enrollId", &self.enrollId());
        ds.field("isSp", &self.isSp());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveWrathItemDataT {
    pub wrathId: Option<String>,
    pub sortId: i32,
    pub picTitleId: Option<String>,
    pub picSmallInactiveId: Option<String>,
    pub picSmallActiveId: Option<String>,
    pub picBigActiveId: Option<String>,
    pub picBigInactiveId: Option<String>,
    pub enrollId: Option<String>,
    pub isSp: bool,
}
impl Default for clz_Torappu_ActArchiveWrathItemDataT {
    fn default() -> Self {
        Self {
            wrathId: None,
            sortId: 0,
            picTitleId: None,
            picSmallInactiveId: None,
            picSmallActiveId: None,
            picBigActiveId: None,
            picBigInactiveId: None,
            enrollId: None,
            isSp: false,
        }
    }
}
impl clz_Torappu_ActArchiveWrathItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveWrathItemData<'b>> {
        let wrathId = self.wrathId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let picTitleId = self.picTitleId.as_ref().map(|x| _fbb.create_string(x));
        let picSmallInactiveId = self
            .picSmallInactiveId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let picSmallActiveId = self
            .picSmallActiveId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let picBigActiveId = self.picBigActiveId.as_ref().map(|x| _fbb.create_string(x));
        let picBigInactiveId = self
            .picBigInactiveId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let enrollId = self.enrollId.as_ref().map(|x| _fbb.create_string(x));
        let isSp = self.isSp;
        clz_Torappu_ActArchiveWrathItemData::create(
            _fbb,
            &clz_Torappu_ActArchiveWrathItemDataArgs {
                wrathId,
                sortId,
                picTitleId,
                picSmallInactiveId,
                picSmallActiveId,
                picBigActiveId,
                picBigInactiveId,
                enrollId,
                isSp,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActArchiveWrathItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveWrathItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveWrathItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveWrathItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveWrathItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveWrathItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveWrathItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveWrathItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveWrathItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActArchiveWrathItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActArchiveWrathItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveWrathItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveWrathItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveWrathItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveWrathItemData>>(
                    dict__string__clz_Torappu_ActArchiveWrathItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveWrathItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveWrathItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveWrathItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveWrathItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveWrathItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveWrathItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActArchiveWrathItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ActArchiveWrathItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActArchiveWrathItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveWrathItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveWrathItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveWrathItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveWrathItemData>>(
                dict__string__clz_Torappu_ActArchiveWrathItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveWrathItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveWrathItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveWrathItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveWrathItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveWrathItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveWrathItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActArchiveWrathItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActArchiveWrathItemDataT>>,
}
impl Default for dict__string__clz_Torappu_ActArchiveWrathItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActArchiveWrathItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveWrathItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActArchiveWrathItemData::create(
            _fbb,
            &dict__string__clz_Torappu_ActArchiveWrathItemDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActArchiveWrathDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveWrathData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveWrathData<'a> {
    type Inner = clz_Torappu_ActArchiveWrathData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveWrathData<'a> {
    pub const VT_WRATHS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveWrathData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveWrathDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveWrathData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveWrathDataBuilder::new(_fbb);
        if let Some(x) = args.wraths {
            builder.add_wraths(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveWrathDataT {
        let wraths = self
            .wraths()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActArchiveWrathDataT { wraths }
    }

    #[inline]
    pub fn wraths(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveWrathItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveWrathItemData>,
                >,
            >>(clz_Torappu_ActArchiveWrathData::VT_WRATHS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveWrathData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveWrathItemData>,
                >,
            >>("wraths", Self::VT_WRATHS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveWrathDataArgs<'a> {
    pub wraths: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveWrathItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveWrathDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveWrathDataArgs { wraths: None }
    }
}

impl Serialize for clz_Torappu_ActArchiveWrathData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveWrathData", 1)?;
        if let Some(f) = self.wraths() {
            s.serialize_field("wraths", &f)?;
        } else {
            s.skip_field("wraths")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveWrathDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ActArchiveWrathDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_wraths(
        &mut self,
        wraths: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveWrathItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveWrathData::VT_WRATHS,
            wraths,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveWrathDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveWrathDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveWrathData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveWrathData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveWrathData");
        ds.field("wraths", &self.wraths());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveWrathDataT {
    pub wraths: Option<Vec<dict__string__clz_Torappu_ActArchiveWrathItemDataT>>,
}
impl Default for clz_Torappu_ActArchiveWrathDataT {
    fn default() -> Self {
        Self { wraths: None }
    }
}
impl clz_Torappu_ActArchiveWrathDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveWrathData<'b>> {
        let wraths = self.wraths.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActArchiveWrathData::create(
            _fbb,
            &clz_Torappu_ActArchiveWrathDataArgs { wraths },
        )
    }
}
pub enum clz_Torappu_ActArchiveCopperItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveCopperItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveCopperItemData<'a> {
    type Inner = clz_Torappu_ActArchiveCopperItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveCopperItemData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DISPLAYCOPPERID: flatbuffers::VOffsetT = 6;
    pub const VT_ARCHIVETYPE: flatbuffers::VOffsetT = 8;
    pub const VT_COPPERTYPE: flatbuffers::VOffsetT = 10;
    pub const VT_SORTID: flatbuffers::VOffsetT = 12;
    pub const VT_ENROLLID: flatbuffers::VOffsetT = 14;
    pub const VT_COPPERSINGROUP: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveCopperItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveCopperItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperItemData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveCopperItemDataBuilder::new(_fbb);
        if let Some(x) = args.coppersInGroup {
            builder.add_coppersInGroup(x);
        }
        if let Some(x) = args.enrollId {
            builder.add_enrollId(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_copperType(args.copperType);
        builder.add_archiveType(args.archiveType);
        if let Some(x) = args.displayCopperId {
            builder.add_displayCopperId(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveCopperItemDataT {
        let id = self.id().map(|x| x.to_string());
        let displayCopperId = self.displayCopperId().map(|x| x.to_string());
        let archiveType = self.archiveType();
        let copperType = self.copperType();
        let sortId = self.sortId();
        let enrollId = self.enrollId().map(|x| x.to_string());
        let coppersInGroup = self
            .coppersInGroup()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_ActArchiveCopperItemDataT {
            id,
            displayCopperId,
            archiveType,
            copperType,
            sortId,
            enrollId,
            coppersInGroup,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveCopperItemData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn displayCopperId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveCopperItemData::VT_DISPLAYCOPPERID,
                None,
            )
        }
    }
    #[inline]
    pub fn archiveType(&self) -> enum__Torappu_ActArchiveCopperType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ActArchiveCopperType>(
                    clz_Torappu_ActArchiveCopperItemData::VT_ARCHIVETYPE,
                    Some(enum__Torappu_ActArchiveCopperType::ERR_ZERO),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn copperType(&self) -> enum__Torappu_RoguelikeCopperType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeCopperType>(
                    clz_Torappu_ActArchiveCopperItemData::VT_COPPERTYPE,
                    Some(enum__Torappu_RoguelikeCopperType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ActArchiveCopperItemData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn enrollId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveCopperItemData::VT_ENROLLID,
                None,
            )
        }
    }
    #[inline]
    pub fn coppersInGroup(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_ActArchiveCopperItemData::VT_COPPERSINGROUP,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveCopperItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "displayCopperId",
                Self::VT_DISPLAYCOPPERID,
                false,
            )?
            .visit_field::<enum__Torappu_ActArchiveCopperType>(
                "archiveType",
                Self::VT_ARCHIVETYPE,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeCopperType>(
                "copperType",
                Self::VT_COPPERTYPE,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollId",
                Self::VT_ENROLLID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("coppersInGroup", Self::VT_COPPERSINGROUP, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveCopperItemDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub displayCopperId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub archiveType: enum__Torappu_ActArchiveCopperType,
    pub copperType: enum__Torappu_RoguelikeCopperType,
    pub sortId: i32,
    pub enrollId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub coppersInGroup: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveCopperItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveCopperItemDataArgs {
            id: None,
            displayCopperId: None,
            archiveType: enum__Torappu_ActArchiveCopperType::ERR_ZERO,
            copperType: enum__Torappu_RoguelikeCopperType::NONE,
            sortId: 0,
            enrollId: None,
            coppersInGroup: None,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveCopperItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveCopperItemData", 7)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.displayCopperId() {
            s.serialize_field("displayCopperId", &f)?;
        } else {
            s.skip_field("displayCopperId")?;
        }
        s.serialize_field("archiveType", &self.archiveType())?;
        s.serialize_field("copperType", &self.copperType())?;
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.enrollId() {
            s.serialize_field("enrollId", &f)?;
        } else {
            s.skip_field("enrollId")?;
        }
        if let Some(f) = self.coppersInGroup() {
            s.serialize_field("coppersInGroup", &f)?;
        } else {
            s.skip_field("coppersInGroup")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveCopperItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveCopperItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperItemData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_displayCopperId(&mut self, displayCopperId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperItemData::VT_DISPLAYCOPPERID,
            displayCopperId,
        );
    }
    #[inline]
    pub fn add_archiveType(&mut self, archiveType: enum__Torappu_ActArchiveCopperType) {
        self.fbb_.push_slot::<enum__Torappu_ActArchiveCopperType>(
            clz_Torappu_ActArchiveCopperItemData::VT_ARCHIVETYPE,
            archiveType,
            enum__Torappu_ActArchiveCopperType::ERR_ZERO,
        );
    }
    #[inline]
    pub fn add_copperType(&mut self, copperType: enum__Torappu_RoguelikeCopperType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeCopperType>(
            clz_Torappu_ActArchiveCopperItemData::VT_COPPERTYPE,
            copperType,
            enum__Torappu_RoguelikeCopperType::NONE,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ActArchiveCopperItemData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_enrollId(&mut self, enrollId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperItemData::VT_ENROLLID,
            enrollId,
        );
    }
    #[inline]
    pub fn add_coppersInGroup(
        &mut self,
        coppersInGroup: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperItemData::VT_COPPERSINGROUP,
            coppersInGroup,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveCopperItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveCopperItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveCopperItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveCopperItemData");
        ds.field("id", &self.id());
        ds.field("displayCopperId", &self.displayCopperId());
        ds.field("archiveType", &self.archiveType());
        ds.field("copperType", &self.copperType());
        ds.field("sortId", &self.sortId());
        ds.field("enrollId", &self.enrollId());
        ds.field("coppersInGroup", &self.coppersInGroup());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveCopperItemDataT {
    pub id: Option<String>,
    pub displayCopperId: Option<String>,
    pub archiveType: enum__Torappu_ActArchiveCopperType,
    pub copperType: enum__Torappu_RoguelikeCopperType,
    pub sortId: i32,
    pub enrollId: Option<String>,
    pub coppersInGroup: Option<Vec<String>>,
}
impl Default for clz_Torappu_ActArchiveCopperItemDataT {
    fn default() -> Self {
        Self {
            id: None,
            displayCopperId: None,
            archiveType: enum__Torappu_ActArchiveCopperType::ERR_ZERO,
            copperType: enum__Torappu_RoguelikeCopperType::NONE,
            sortId: 0,
            enrollId: None,
            coppersInGroup: None,
        }
    }
}
impl clz_Torappu_ActArchiveCopperItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperItemData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let displayCopperId = self.displayCopperId.as_ref().map(|x| _fbb.create_string(x));
        let archiveType = self.archiveType;
        let copperType = self.copperType;
        let sortId = self.sortId;
        let enrollId = self.enrollId.as_ref().map(|x| _fbb.create_string(x));
        let coppersInGroup = self.coppersInGroup.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActArchiveCopperItemData::create(
            _fbb,
            &clz_Torappu_ActArchiveCopperItemDataArgs {
                id,
                displayCopperId,
                archiveType,
                copperType,
                sortId,
                enrollId,
                coppersInGroup,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActArchiveCopperItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveCopperItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveCopperItemData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveCopperItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveCopperItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveCopperItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveCopperItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveCopperItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveCopperItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActArchiveCopperItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActArchiveCopperItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveCopperItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveCopperItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveCopperItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveCopperItemData>>(
                    dict__string__clz_Torappu_ActArchiveCopperItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveCopperItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveCopperItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveCopperItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveCopperItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveCopperItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActArchiveCopperItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ActArchiveCopperItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActArchiveCopperItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveCopperItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveCopperItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperItemData>>(
                dict__string__clz_Torappu_ActArchiveCopperItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveCopperItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveCopperItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveCopperItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveCopperItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveCopperItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveCopperItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActArchiveCopperItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActArchiveCopperItemDataT>>,
}
impl Default for dict__string__clz_Torappu_ActArchiveCopperItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActArchiveCopperItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveCopperItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActArchiveCopperItemData::create(
            _fbb,
            &dict__string__clz_Torappu_ActArchiveCopperItemDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActArchiveCopperTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveCopperTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveCopperTypeData<'a> {
    type Inner = clz_Torappu_ActArchiveCopperTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveCopperTypeData<'a> {
    pub const VT_COPPERTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_TYPENAME: flatbuffers::VOffsetT = 6;
    pub const VT_TYPEICONID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveCopperTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveCopperTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperTypeData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveCopperTypeDataBuilder::new(_fbb);
        if let Some(x) = args.typeIconId {
            builder.add_typeIconId(x);
        }
        if let Some(x) = args.typeName {
            builder.add_typeName(x);
        }
        builder.add_copperType(args.copperType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveCopperTypeDataT {
        let copperType = self.copperType();
        let typeName = self.typeName().map(|x| x.to_string());
        let typeIconId = self.typeIconId().map(|x| x.to_string());
        clz_Torappu_ActArchiveCopperTypeDataT {
            copperType,
            typeName,
            typeIconId,
        }
    }

    #[inline]
    pub fn copperType(&self) -> enum__Torappu_RoguelikeCopperType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeCopperType>(
                    clz_Torappu_ActArchiveCopperTypeData::VT_COPPERTYPE,
                    Some(enum__Torappu_RoguelikeCopperType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn typeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveCopperTypeData::VT_TYPENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn typeIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveCopperTypeData::VT_TYPEICONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveCopperTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeCopperType>(
                "copperType",
                Self::VT_COPPERTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "typeName",
                Self::VT_TYPENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "typeIconId",
                Self::VT_TYPEICONID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveCopperTypeDataArgs<'a> {
    pub copperType: enum__Torappu_RoguelikeCopperType,
    pub typeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub typeIconId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveCopperTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveCopperTypeDataArgs {
            copperType: enum__Torappu_RoguelikeCopperType::NONE,
            typeName: None,
            typeIconId: None,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveCopperTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveCopperTypeData", 3)?;
        s.serialize_field("copperType", &self.copperType())?;
        if let Some(f) = self.typeName() {
            s.serialize_field("typeName", &f)?;
        } else {
            s.skip_field("typeName")?;
        }
        if let Some(f) = self.typeIconId() {
            s.serialize_field("typeIconId", &f)?;
        } else {
            s.skip_field("typeIconId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveCopperTypeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveCopperTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_copperType(&mut self, copperType: enum__Torappu_RoguelikeCopperType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeCopperType>(
            clz_Torappu_ActArchiveCopperTypeData::VT_COPPERTYPE,
            copperType,
            enum__Torappu_RoguelikeCopperType::NONE,
        );
    }
    #[inline]
    pub fn add_typeName(&mut self, typeName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperTypeData::VT_TYPENAME,
            typeName,
        );
    }
    #[inline]
    pub fn add_typeIconId(&mut self, typeIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperTypeData::VT_TYPEICONID,
            typeIconId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveCopperTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveCopperTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveCopperTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveCopperTypeData");
        ds.field("copperType", &self.copperType());
        ds.field("typeName", &self.typeName());
        ds.field("typeIconId", &self.typeIconId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveCopperTypeDataT {
    pub copperType: enum__Torappu_RoguelikeCopperType,
    pub typeName: Option<String>,
    pub typeIconId: Option<String>,
}
impl Default for clz_Torappu_ActArchiveCopperTypeDataT {
    fn default() -> Self {
        Self {
            copperType: enum__Torappu_RoguelikeCopperType::NONE,
            typeName: None,
            typeIconId: None,
        }
    }
}
impl clz_Torappu_ActArchiveCopperTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperTypeData<'b>> {
        let copperType = self.copperType;
        let typeName = self.typeName.as_ref().map(|x| _fbb.create_string(x));
        let typeIconId = self.typeIconId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ActArchiveCopperTypeData::create(
            _fbb,
            &clz_Torappu_ActArchiveCopperTypeDataArgs {
                copperType,
                typeName,
                typeIconId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActArchiveCopperTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveCopperTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveCopperTypeData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveCopperTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveCopperTypeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveCopperTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveCopperTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveCopperTypeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveCopperTypeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActArchiveCopperTypeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActArchiveCopperTypeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveCopperTypeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveCopperTypeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveCopperTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveCopperTypeData>>(
                    dict__string__clz_Torappu_ActArchiveCopperTypeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveCopperTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveCopperTypeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveCopperTypeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperTypeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveCopperTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveCopperTypeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActArchiveCopperTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ActArchiveCopperTypeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActArchiveCopperTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveCopperTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveCopperTypeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperTypeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperTypeData>>(
                dict__string__clz_Torappu_ActArchiveCopperTypeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveCopperTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveCopperTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveCopperTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveCopperTypeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveCopperTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveCopperTypeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActArchiveCopperTypeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActArchiveCopperTypeDataT>>,
}
impl Default for dict__string__clz_Torappu_ActArchiveCopperTypeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActArchiveCopperTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveCopperTypeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActArchiveCopperTypeData::create(
            _fbb,
            &dict__string__clz_Torappu_ActArchiveCopperTypeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActArchiveCopperGildDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveCopperGildData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveCopperGildData<'a> {
    type Inner = clz_Torappu_ActArchiveCopperGildData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveCopperGildData<'a> {
    pub const VT_GILDTYPEID: flatbuffers::VOffsetT = 4;
    pub const VT_GILDNAME: flatbuffers::VOffsetT = 6;
    pub const VT_GILDDESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveCopperGildData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveCopperGildDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperGildData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveCopperGildDataBuilder::new(_fbb);
        if let Some(x) = args.gildDesc {
            builder.add_gildDesc(x);
        }
        if let Some(x) = args.gildName {
            builder.add_gildName(x);
        }
        if let Some(x) = args.gildTypeId {
            builder.add_gildTypeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveCopperGildDataT {
        let gildTypeId = self.gildTypeId().map(|x| x.to_string());
        let gildName = self.gildName().map(|x| x.to_string());
        let gildDesc = self.gildDesc().map(|x| x.to_string());
        clz_Torappu_ActArchiveCopperGildDataT {
            gildTypeId,
            gildName,
            gildDesc,
        }
    }

    #[inline]
    pub fn gildTypeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveCopperGildData::VT_GILDTYPEID,
                None,
            )
        }
    }
    #[inline]
    pub fn gildName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveCopperGildData::VT_GILDNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn gildDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveCopperGildData::VT_GILDDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveCopperGildData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "gildTypeId",
                Self::VT_GILDTYPEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "gildName",
                Self::VT_GILDNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "gildDesc",
                Self::VT_GILDDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveCopperGildDataArgs<'a> {
    pub gildTypeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gildName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gildDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveCopperGildDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveCopperGildDataArgs {
            gildTypeId: None,
            gildName: None,
            gildDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveCopperGildData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveCopperGildData", 3)?;
        if let Some(f) = self.gildTypeId() {
            s.serialize_field("gildTypeId", &f)?;
        } else {
            s.skip_field("gildTypeId")?;
        }
        if let Some(f) = self.gildName() {
            s.serialize_field("gildName", &f)?;
        } else {
            s.skip_field("gildName")?;
        }
        if let Some(f) = self.gildDesc() {
            s.serialize_field("gildDesc", &f)?;
        } else {
            s.skip_field("gildDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveCopperGildDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveCopperGildDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_gildTypeId(&mut self, gildTypeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperGildData::VT_GILDTYPEID,
            gildTypeId,
        );
    }
    #[inline]
    pub fn add_gildName(&mut self, gildName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperGildData::VT_GILDNAME,
            gildName,
        );
    }
    #[inline]
    pub fn add_gildDesc(&mut self, gildDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperGildData::VT_GILDDESC,
            gildDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveCopperGildDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveCopperGildDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperGildData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveCopperGildData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveCopperGildData");
        ds.field("gildTypeId", &self.gildTypeId());
        ds.field("gildName", &self.gildName());
        ds.field("gildDesc", &self.gildDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveCopperGildDataT {
    pub gildTypeId: Option<String>,
    pub gildName: Option<String>,
    pub gildDesc: Option<String>,
}
impl Default for clz_Torappu_ActArchiveCopperGildDataT {
    fn default() -> Self {
        Self {
            gildTypeId: None,
            gildName: None,
            gildDesc: None,
        }
    }
}
impl clz_Torappu_ActArchiveCopperGildDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperGildData<'b>> {
        let gildTypeId = self.gildTypeId.as_ref().map(|x| _fbb.create_string(x));
        let gildName = self.gildName.as_ref().map(|x| _fbb.create_string(x));
        let gildDesc = self.gildDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ActArchiveCopperGildData::create(
            _fbb,
            &clz_Torappu_ActArchiveCopperGildDataArgs {
                gildTypeId,
                gildName,
                gildDesc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActArchiveCopperGildDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveCopperGildData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveCopperGildData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveCopperGildData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveCopperGildData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveCopperGildData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveCopperGildDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveCopperGildData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_ActArchiveCopperGildDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActArchiveCopperGildDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActArchiveCopperGildDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveCopperGildData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveCopperGildData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveCopperGildData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveCopperGildData>>(
                    dict__string__clz_Torappu_ActArchiveCopperGildData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveCopperGildData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveCopperGildData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveCopperGildDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperGildData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveCopperGildDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveCopperGildDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActArchiveCopperGildData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_ActArchiveCopperGildData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActArchiveCopperGildDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveCopperGildDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveCopperGildData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperGildData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperGildData>>(
                dict__string__clz_Torappu_ActArchiveCopperGildData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveCopperGildDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveCopperGildDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveCopperGildData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveCopperGildData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveCopperGildData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveCopperGildData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActArchiveCopperGildDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActArchiveCopperGildDataT>>,
}
impl Default for dict__string__clz_Torappu_ActArchiveCopperGildDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActArchiveCopperGildDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveCopperGildData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActArchiveCopperGildData::create(
            _fbb,
            &dict__string__clz_Torappu_ActArchiveCopperGildDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActArchiveCopperLuckyLevelDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveCopperLuckyLevelData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveCopperLuckyLevelData<'a> {
    type Inner = clz_Torappu_ActArchiveCopperLuckyLevelData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveCopperLuckyLevelData<'a> {
    pub const VT_LUCKYLEVEL: flatbuffers::VOffsetT = 4;
    pub const VT_LUCKYNAME: flatbuffers::VOffsetT = 6;
    pub const VT_LUCKYDESC: flatbuffers::VOffsetT = 8;
    pub const VT_LUCKYUSAGE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveCopperLuckyLevelData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveCopperLuckyLevelDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperLuckyLevelData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveCopperLuckyLevelDataBuilder::new(_fbb);
        if let Some(x) = args.luckyUsage {
            builder.add_luckyUsage(x);
        }
        if let Some(x) = args.luckyDesc {
            builder.add_luckyDesc(x);
        }
        if let Some(x) = args.luckyName {
            builder.add_luckyName(x);
        }
        builder.add_luckyLevel(args.luckyLevel);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveCopperLuckyLevelDataT {
        let luckyLevel = self.luckyLevel();
        let luckyName = self.luckyName().map(|x| x.to_string());
        let luckyDesc = self.luckyDesc().map(|x| x.to_string());
        let luckyUsage = self.luckyUsage().map(|x| x.to_string());
        clz_Torappu_ActArchiveCopperLuckyLevelDataT {
            luckyLevel,
            luckyName,
            luckyDesc,
            luckyUsage,
        }
    }

    #[inline]
    pub fn luckyLevel(&self) -> enum__Torappu_RoguelikeCopperLuckyLevel {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeCopperLuckyLevel>(
                    clz_Torappu_ActArchiveCopperLuckyLevelData::VT_LUCKYLEVEL,
                    Some(enum__Torappu_RoguelikeCopperLuckyLevel::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn luckyName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveCopperLuckyLevelData::VT_LUCKYNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn luckyDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveCopperLuckyLevelData::VT_LUCKYDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn luckyUsage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_ActArchiveCopperLuckyLevelData::VT_LUCKYUSAGE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveCopperLuckyLevelData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeCopperLuckyLevel>(
                "luckyLevel",
                Self::VT_LUCKYLEVEL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "luckyName",
                Self::VT_LUCKYNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "luckyDesc",
                Self::VT_LUCKYDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "luckyUsage",
                Self::VT_LUCKYUSAGE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveCopperLuckyLevelDataArgs<'a> {
    pub luckyLevel: enum__Torappu_RoguelikeCopperLuckyLevel,
    pub luckyName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub luckyDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub luckyUsage: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_ActArchiveCopperLuckyLevelDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveCopperLuckyLevelDataArgs {
            luckyLevel: enum__Torappu_RoguelikeCopperLuckyLevel::NONE,
            luckyName: None,
            luckyDesc: None,
            luckyUsage: None,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveCopperLuckyLevelData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveCopperLuckyLevelData", 4)?;
        s.serialize_field("luckyLevel", &self.luckyLevel())?;
        if let Some(f) = self.luckyName() {
            s.serialize_field("luckyName", &f)?;
        } else {
            s.skip_field("luckyName")?;
        }
        if let Some(f) = self.luckyDesc() {
            s.serialize_field("luckyDesc", &f)?;
        } else {
            s.skip_field("luckyDesc")?;
        }
        if let Some(f) = self.luckyUsage() {
            s.serialize_field("luckyUsage", &f)?;
        } else {
            s.skip_field("luckyUsage")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveCopperLuckyLevelDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveCopperLuckyLevelDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_luckyLevel(&mut self, luckyLevel: enum__Torappu_RoguelikeCopperLuckyLevel) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeCopperLuckyLevel>(
                clz_Torappu_ActArchiveCopperLuckyLevelData::VT_LUCKYLEVEL,
                luckyLevel,
                enum__Torappu_RoguelikeCopperLuckyLevel::NONE,
            );
    }
    #[inline]
    pub fn add_luckyName(&mut self, luckyName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperLuckyLevelData::VT_LUCKYNAME,
            luckyName,
        );
    }
    #[inline]
    pub fn add_luckyDesc(&mut self, luckyDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperLuckyLevelData::VT_LUCKYDESC,
            luckyDesc,
        );
    }
    #[inline]
    pub fn add_luckyUsage(&mut self, luckyUsage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperLuckyLevelData::VT_LUCKYUSAGE,
            luckyUsage,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveCopperLuckyLevelDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveCopperLuckyLevelDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperLuckyLevelData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveCopperLuckyLevelData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveCopperLuckyLevelData");
        ds.field("luckyLevel", &self.luckyLevel());
        ds.field("luckyName", &self.luckyName());
        ds.field("luckyDesc", &self.luckyDesc());
        ds.field("luckyUsage", &self.luckyUsage());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveCopperLuckyLevelDataT {
    pub luckyLevel: enum__Torappu_RoguelikeCopperLuckyLevel,
    pub luckyName: Option<String>,
    pub luckyDesc: Option<String>,
    pub luckyUsage: Option<String>,
}
impl Default for clz_Torappu_ActArchiveCopperLuckyLevelDataT {
    fn default() -> Self {
        Self {
            luckyLevel: enum__Torappu_RoguelikeCopperLuckyLevel::NONE,
            luckyName: None,
            luckyDesc: None,
            luckyUsage: None,
        }
    }
}
impl clz_Torappu_ActArchiveCopperLuckyLevelDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperLuckyLevelData<'b>> {
        let luckyLevel = self.luckyLevel;
        let luckyName = self.luckyName.as_ref().map(|x| _fbb.create_string(x));
        let luckyDesc = self.luckyDesc.as_ref().map(|x| _fbb.create_string(x));
        let luckyUsage = self.luckyUsage.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_ActArchiveCopperLuckyLevelData::create(
            _fbb,
            &clz_Torappu_ActArchiveCopperLuckyLevelDataArgs {
                luckyLevel,
                luckyName,
                luckyDesc,
                luckyUsage,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData<'a> {
    type Inner = dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActArchiveCopperLuckyLevelData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveCopperLuckyLevelData>>(
                    dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveCopperLuckyLevelData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperLuckyLevelData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperLuckyLevelData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperLuckyLevelData>>(
                dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActArchiveCopperLuckyLevelDataT>>,
}
impl Default for dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData::create(
            _fbb,
            &dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActArchiveCopperDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActArchiveCopperData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActArchiveCopperData<'a> {
    type Inner = clz_Torappu_ActArchiveCopperData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActArchiveCopperData<'a> {
    pub const VT_COPPERS: flatbuffers::VOffsetT = 4;
    pub const VT_COPPERTYPES: flatbuffers::VOffsetT = 6;
    pub const VT_GILDS: flatbuffers::VOffsetT = 8;
    pub const VT_LUCKYLEVELS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActArchiveCopperData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActArchiveCopperDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperData<'bldr>> {
        let mut builder = clz_Torappu_ActArchiveCopperDataBuilder::new(_fbb);
        if let Some(x) = args.luckyLevels {
            builder.add_luckyLevels(x);
        }
        if let Some(x) = args.gilds {
            builder.add_gilds(x);
        }
        if let Some(x) = args.copperTypes {
            builder.add_copperTypes(x);
        }
        if let Some(x) = args.coppers {
            builder.add_coppers(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActArchiveCopperDataT {
        let coppers = self
            .coppers()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let copperTypes = self
            .copperTypes()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let gilds = self.gilds().map(|x| x.iter().map(|t| t.unpack()).collect());
        let luckyLevels = self
            .luckyLevels()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActArchiveCopperDataT {
            coppers,
            copperTypes,
            gilds,
            luckyLevels,
        }
    }

    #[inline]
    pub fn coppers(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveCopperItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveCopperItemData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveCopperData::VT_COPPERS, None)
        }
    }
    #[inline]
    pub fn copperTypes(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveCopperTypeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveCopperTypeData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveCopperData::VT_COPPERTYPES, None)
        }
    }
    #[inline]
    pub fn gilds(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_ActArchiveCopperGildData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveCopperGildData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveCopperData::VT_GILDS, None)
        }
    }
    #[inline]
    pub fn luckyLevels(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData,
                    >,
                >,
            >>(clz_Torappu_ActArchiveCopperData::VT_LUCKYLEVELS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActArchiveCopperData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveCopperItemData,
                    >,
                >,
            >>("coppers", Self::VT_COPPERS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveCopperTypeData,
                    >,
                >,
            >>("copperTypes", Self::VT_COPPERTYPES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveCopperGildData,
                    >,
                >,
            >>("gilds", Self::VT_GILDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData,
                    >,
                >,
            >>("luckyLevels", Self::VT_LUCKYLEVELS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActArchiveCopperDataArgs<'a> {
    pub coppers: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveCopperItemData<'a>,
                >,
            >,
        >,
    >,
    pub copperTypes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveCopperTypeData<'a>,
                >,
            >,
        >,
    >,
    pub gilds: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveCopperGildData<'a>,
                >,
            >,
        >,
    >,
    pub luckyLevels: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActArchiveCopperDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActArchiveCopperDataArgs {
            coppers: None,
            copperTypes: None,
            gilds: None,
            luckyLevels: None,
        }
    }
}

impl Serialize for clz_Torappu_ActArchiveCopperData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActArchiveCopperData", 4)?;
        if let Some(f) = self.coppers() {
            s.serialize_field("coppers", &f)?;
        } else {
            s.skip_field("coppers")?;
        }
        if let Some(f) = self.copperTypes() {
            s.serialize_field("copperTypes", &f)?;
        } else {
            s.skip_field("copperTypes")?;
        }
        if let Some(f) = self.gilds() {
            s.serialize_field("gilds", &f)?;
        } else {
            s.skip_field("gilds")?;
        }
        if let Some(f) = self.luckyLevels() {
            s.serialize_field("luckyLevels", &f)?;
        } else {
            s.skip_field("luckyLevels")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActArchiveCopperDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActArchiveCopperDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_coppers(
        &mut self,
        coppers: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveCopperItemData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperData::VT_COPPERS,
            coppers,
        );
    }
    #[inline]
    pub fn add_copperTypes(
        &mut self,
        copperTypes: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveCopperTypeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperData::VT_COPPERTYPES,
            copperTypes,
        );
    }
    #[inline]
    pub fn add_gilds(
        &mut self,
        gilds: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveCopperGildData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperData::VT_GILDS,
            gilds,
        );
    }
    #[inline]
    pub fn add_luckyLevels(
        &mut self,
        luckyLevels: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActArchiveCopperLuckyLevelData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActArchiveCopperData::VT_LUCKYLEVELS,
            luckyLevels,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActArchiveCopperDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActArchiveCopperDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActArchiveCopperData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActArchiveCopperData");
        ds.field("coppers", &self.coppers());
        ds.field("copperTypes", &self.copperTypes());
        ds.field("gilds", &self.gilds());
        ds.field("luckyLevels", &self.luckyLevels());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActArchiveCopperDataT {
    pub coppers: Option<Vec<dict__string__clz_Torappu_ActArchiveCopperItemDataT>>,
    pub copperTypes: Option<Vec<dict__string__clz_Torappu_ActArchiveCopperTypeDataT>>,
    pub gilds: Option<Vec<dict__string__clz_Torappu_ActArchiveCopperGildDataT>>,
    pub luckyLevels: Option<Vec<dict__string__clz_Torappu_ActArchiveCopperLuckyLevelDataT>>,
}
impl Default for clz_Torappu_ActArchiveCopperDataT {
    fn default() -> Self {
        Self {
            coppers: None,
            copperTypes: None,
            gilds: None,
            luckyLevels: None,
        }
    }
}
impl clz_Torappu_ActArchiveCopperDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperData<'b>> {
        let coppers = self.coppers.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let copperTypes = self.copperTypes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let gilds = self.gilds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let luckyLevels = self.luckyLevels.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActArchiveCopperData::create(
            _fbb,
            &clz_Torappu_ActArchiveCopperDataArgs {
                coppers,
                copperTypes,
                gilds,
                luckyLevels,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeArchiveComponentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeArchiveComponentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeArchiveComponentData<'a> {
    type Inner = clz_Torappu_RoguelikeArchiveComponentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeArchiveComponentData<'a> {
    pub const VT_RELIC: flatbuffers::VOffsetT = 4;
    pub const VT_CAPSULE: flatbuffers::VOffsetT = 6;
    pub const VT_TRAP: flatbuffers::VOffsetT = 8;
    pub const VT_CHAT: flatbuffers::VOffsetT = 10;
    pub const VT_ENDBOOK: flatbuffers::VOffsetT = 12;
    pub const VT_BUFF: flatbuffers::VOffsetT = 14;
    pub const VT_TOTEM: flatbuffers::VOffsetT = 16;
    pub const VT_CHAOS: flatbuffers::VOffsetT = 18;
    pub const VT_FRAGMENT: flatbuffers::VOffsetT = 20;
    pub const VT_DISASTER: flatbuffers::VOffsetT = 22;
    pub const VT_WRATH: flatbuffers::VOffsetT = 24;
    pub const VT_COPPER: flatbuffers::VOffsetT = 26;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeArchiveComponentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeArchiveComponentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveComponentData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeArchiveComponentDataBuilder::new(_fbb);
        if let Some(x) = args.copper {
            builder.add_copper(x);
        }
        if let Some(x) = args.wrath {
            builder.add_wrath(x);
        }
        if let Some(x) = args.disaster {
            builder.add_disaster(x);
        }
        if let Some(x) = args.fragment {
            builder.add_fragment(x);
        }
        if let Some(x) = args.chaos {
            builder.add_chaos(x);
        }
        if let Some(x) = args.totem {
            builder.add_totem(x);
        }
        if let Some(x) = args.buff {
            builder.add_buff(x);
        }
        if let Some(x) = args.endbook {
            builder.add_endbook(x);
        }
        if let Some(x) = args.chat {
            builder.add_chat(x);
        }
        if let Some(x) = args.trap {
            builder.add_trap(x);
        }
        if let Some(x) = args.capsule {
            builder.add_capsule(x);
        }
        if let Some(x) = args.relic {
            builder.add_relic(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeArchiveComponentDataT {
        let relic = self.relic().map(|x| Box::new(x.unpack()));
        let capsule = self.capsule().map(|x| Box::new(x.unpack()));
        let trap = self.trap().map(|x| Box::new(x.unpack()));
        let chat = self.chat().map(|x| Box::new(x.unpack()));
        let endbook = self.endbook().map(|x| Box::new(x.unpack()));
        let buff = self.buff().map(|x| Box::new(x.unpack()));
        let totem = self.totem().map(|x| Box::new(x.unpack()));
        let chaos = self.chaos().map(|x| Box::new(x.unpack()));
        let fragment = self.fragment().map(|x| Box::new(x.unpack()));
        let disaster = self.disaster().map(|x| Box::new(x.unpack()));
        let wrath = self.wrath().map(|x| Box::new(x.unpack()));
        let copper = self.copper().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeArchiveComponentDataT {
            relic,
            capsule,
            trap,
            chat,
            endbook,
            buff,
            totem,
            chaos,
            fragment,
            disaster,
            wrath,
            copper,
        }
    }

    #[inline]
    pub fn relic(&self) -> Option<clz_Torappu_ActArchiveRelicData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveRelicData>>(
                    clz_Torappu_RoguelikeArchiveComponentData::VT_RELIC,
                    None,
                )
        }
    }
    #[inline]
    pub fn capsule(&self) -> Option<clz_Torappu_ActArchiveCapsuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveCapsuleData>>(
                    clz_Torappu_RoguelikeArchiveComponentData::VT_CAPSULE,
                    None,
                )
        }
    }
    #[inline]
    pub fn trap(&self) -> Option<clz_Torappu_ActArchiveTrapData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveTrapData>>(
                    clz_Torappu_RoguelikeArchiveComponentData::VT_TRAP,
                    None,
                )
        }
    }
    #[inline]
    pub fn chat(&self) -> Option<clz_Torappu_ActArchiveChatData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChatData>>(
                    clz_Torappu_RoguelikeArchiveComponentData::VT_CHAT,
                    None,
                )
        }
    }
    #[inline]
    pub fn endbook(&self) -> Option<clz_Torappu_ActArchiveEndbookData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveEndbookData>>(
                    clz_Torappu_RoguelikeArchiveComponentData::VT_ENDBOOK,
                    None,
                )
        }
    }
    #[inline]
    pub fn buff(&self) -> Option<clz_Torappu_ActArchiveBuffData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveBuffData>>(
                    clz_Torappu_RoguelikeArchiveComponentData::VT_BUFF,
                    None,
                )
        }
    }
    #[inline]
    pub fn totem(&self) -> Option<clz_Torappu_ActArchiveTotemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveTotemData>>(
                    clz_Torappu_RoguelikeArchiveComponentData::VT_TOTEM,
                    None,
                )
        }
    }
    #[inline]
    pub fn chaos(&self) -> Option<clz_Torappu_ActArchiveChaosData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChaosData>>(
                    clz_Torappu_RoguelikeArchiveComponentData::VT_CHAOS,
                    None,
                )
        }
    }
    #[inline]
    pub fn fragment(&self) -> Option<clz_Torappu_ActArchiveFragmentData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveFragmentData>>(
                    clz_Torappu_RoguelikeArchiveComponentData::VT_FRAGMENT,
                    None,
                )
        }
    }
    #[inline]
    pub fn disaster(&self) -> Option<clz_Torappu_ActArchiveDisasterData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveDisasterData>>(
                    clz_Torappu_RoguelikeArchiveComponentData::VT_DISASTER,
                    None,
                )
        }
    }
    #[inline]
    pub fn wrath(&self) -> Option<clz_Torappu_ActArchiveWrathData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveWrathData>>(
                    clz_Torappu_RoguelikeArchiveComponentData::VT_WRATH,
                    None,
                )
        }
    }
    #[inline]
    pub fn copper(&self) -> Option<clz_Torappu_ActArchiveCopperData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveCopperData>>(
                    clz_Torappu_RoguelikeArchiveComponentData::VT_COPPER,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeArchiveComponentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveRelicData>>(
                "relic",
                Self::VT_RELIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveCapsuleData>>(
                "capsule",
                Self::VT_CAPSULE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveTrapData>>(
                "trap",
                Self::VT_TRAP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChatData>>(
                "chat",
                Self::VT_CHAT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveEndbookData>>(
                "endbook",
                Self::VT_ENDBOOK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveBuffData>>(
                "buff",
                Self::VT_BUFF,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveTotemData>>(
                "totem",
                Self::VT_TOTEM,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveChaosData>>(
                "chaos",
                Self::VT_CHAOS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveFragmentData>>(
                "fragment",
                Self::VT_FRAGMENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveDisasterData>>(
                "disaster",
                Self::VT_DISASTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveWrathData>>(
                "wrath",
                Self::VT_WRATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActArchiveCopperData>>(
                "copper",
                Self::VT_COPPER,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeArchiveComponentDataArgs<'a> {
    pub relic: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveRelicData<'a>>>,
    pub capsule: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveCapsuleData<'a>>>,
    pub trap: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveTrapData<'a>>>,
    pub chat: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveChatData<'a>>>,
    pub endbook: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveEndbookData<'a>>>,
    pub buff: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveBuffData<'a>>>,
    pub totem: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveTotemData<'a>>>,
    pub chaos: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveChaosData<'a>>>,
    pub fragment: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveFragmentData<'a>>>,
    pub disaster: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveDisasterData<'a>>>,
    pub wrath: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveWrathData<'a>>>,
    pub copper: Option<flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperData<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeArchiveComponentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeArchiveComponentDataArgs {
            relic: None,
            capsule: None,
            trap: None,
            chat: None,
            endbook: None,
            buff: None,
            totem: None,
            chaos: None,
            fragment: None,
            disaster: None,
            wrath: None,
            copper: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeArchiveComponentData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeArchiveComponentData", 12)?;
        if let Some(f) = self.relic() {
            s.serialize_field("relic", &f)?;
        } else {
            s.skip_field("relic")?;
        }
        if let Some(f) = self.capsule() {
            s.serialize_field("capsule", &f)?;
        } else {
            s.skip_field("capsule")?;
        }
        if let Some(f) = self.trap() {
            s.serialize_field("trap", &f)?;
        } else {
            s.skip_field("trap")?;
        }
        if let Some(f) = self.chat() {
            s.serialize_field("chat", &f)?;
        } else {
            s.skip_field("chat")?;
        }
        if let Some(f) = self.endbook() {
            s.serialize_field("endbook", &f)?;
        } else {
            s.skip_field("endbook")?;
        }
        if let Some(f) = self.buff() {
            s.serialize_field("buff", &f)?;
        } else {
            s.skip_field("buff")?;
        }
        if let Some(f) = self.totem() {
            s.serialize_field("totem", &f)?;
        } else {
            s.skip_field("totem")?;
        }
        if let Some(f) = self.chaos() {
            s.serialize_field("chaos", &f)?;
        } else {
            s.skip_field("chaos")?;
        }
        if let Some(f) = self.fragment() {
            s.serialize_field("fragment", &f)?;
        } else {
            s.skip_field("fragment")?;
        }
        if let Some(f) = self.disaster() {
            s.serialize_field("disaster", &f)?;
        } else {
            s.skip_field("disaster")?;
        }
        if let Some(f) = self.wrath() {
            s.serialize_field("wrath", &f)?;
        } else {
            s.skip_field("wrath")?;
        }
        if let Some(f) = self.copper() {
            s.serialize_field("copper", &f)?;
        } else {
            s.skip_field("copper")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeArchiveComponentDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeArchiveComponentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_relic(
        &mut self,
        relic: flatbuffers::WIPOffset<clz_Torappu_ActArchiveRelicData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveRelicData>>(
                clz_Torappu_RoguelikeArchiveComponentData::VT_RELIC,
                relic,
            );
    }
    #[inline]
    pub fn add_capsule(
        &mut self,
        capsule: flatbuffers::WIPOffset<clz_Torappu_ActArchiveCapsuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveCapsuleData>>(
                clz_Torappu_RoguelikeArchiveComponentData::VT_CAPSULE,
                capsule,
            );
    }
    #[inline]
    pub fn add_trap(&mut self, trap: flatbuffers::WIPOffset<clz_Torappu_ActArchiveTrapData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveTrapData>>(
                clz_Torappu_RoguelikeArchiveComponentData::VT_TRAP,
                trap,
            );
    }
    #[inline]
    pub fn add_chat(&mut self, chat: flatbuffers::WIPOffset<clz_Torappu_ActArchiveChatData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveChatData>>(
                clz_Torappu_RoguelikeArchiveComponentData::VT_CHAT,
                chat,
            );
    }
    #[inline]
    pub fn add_endbook(
        &mut self,
        endbook: flatbuffers::WIPOffset<clz_Torappu_ActArchiveEndbookData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveEndbookData>>(
                clz_Torappu_RoguelikeArchiveComponentData::VT_ENDBOOK,
                endbook,
            );
    }
    #[inline]
    pub fn add_buff(&mut self, buff: flatbuffers::WIPOffset<clz_Torappu_ActArchiveBuffData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveBuffData>>(
                clz_Torappu_RoguelikeArchiveComponentData::VT_BUFF,
                buff,
            );
    }
    #[inline]
    pub fn add_totem(
        &mut self,
        totem: flatbuffers::WIPOffset<clz_Torappu_ActArchiveTotemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveTotemData>>(
                clz_Torappu_RoguelikeArchiveComponentData::VT_TOTEM,
                totem,
            );
    }
    #[inline]
    pub fn add_chaos(
        &mut self,
        chaos: flatbuffers::WIPOffset<clz_Torappu_ActArchiveChaosData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveChaosData>>(
                clz_Torappu_RoguelikeArchiveComponentData::VT_CHAOS,
                chaos,
            );
    }
    #[inline]
    pub fn add_fragment(
        &mut self,
        fragment: flatbuffers::WIPOffset<clz_Torappu_ActArchiveFragmentData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveFragmentData>>(
                clz_Torappu_RoguelikeArchiveComponentData::VT_FRAGMENT,
                fragment,
            );
    }
    #[inline]
    pub fn add_disaster(
        &mut self,
        disaster: flatbuffers::WIPOffset<clz_Torappu_ActArchiveDisasterData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveDisasterData>>(
                clz_Torappu_RoguelikeArchiveComponentData::VT_DISASTER,
                disaster,
            );
    }
    #[inline]
    pub fn add_wrath(
        &mut self,
        wrath: flatbuffers::WIPOffset<clz_Torappu_ActArchiveWrathData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveWrathData>>(
                clz_Torappu_RoguelikeArchiveComponentData::VT_WRATH,
                wrath,
            );
    }
    #[inline]
    pub fn add_copper(
        &mut self,
        copper: flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActArchiveCopperData>>(
                clz_Torappu_RoguelikeArchiveComponentData::VT_COPPER,
                copper,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeArchiveComponentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeArchiveComponentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveComponentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeArchiveComponentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeArchiveComponentData");
        ds.field("relic", &self.relic());
        ds.field("capsule", &self.capsule());
        ds.field("trap", &self.trap());
        ds.field("chat", &self.chat());
        ds.field("endbook", &self.endbook());
        ds.field("buff", &self.buff());
        ds.field("totem", &self.totem());
        ds.field("chaos", &self.chaos());
        ds.field("fragment", &self.fragment());
        ds.field("disaster", &self.disaster());
        ds.field("wrath", &self.wrath());
        ds.field("copper", &self.copper());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeArchiveComponentDataT {
    pub relic: Option<Box<clz_Torappu_ActArchiveRelicDataT>>,
    pub capsule: Option<Box<clz_Torappu_ActArchiveCapsuleDataT>>,
    pub trap: Option<Box<clz_Torappu_ActArchiveTrapDataT>>,
    pub chat: Option<Box<clz_Torappu_ActArchiveChatDataT>>,
    pub endbook: Option<Box<clz_Torappu_ActArchiveEndbookDataT>>,
    pub buff: Option<Box<clz_Torappu_ActArchiveBuffDataT>>,
    pub totem: Option<Box<clz_Torappu_ActArchiveTotemDataT>>,
    pub chaos: Option<Box<clz_Torappu_ActArchiveChaosDataT>>,
    pub fragment: Option<Box<clz_Torappu_ActArchiveFragmentDataT>>,
    pub disaster: Option<Box<clz_Torappu_ActArchiveDisasterDataT>>,
    pub wrath: Option<Box<clz_Torappu_ActArchiveWrathDataT>>,
    pub copper: Option<Box<clz_Torappu_ActArchiveCopperDataT>>,
}
impl Default for clz_Torappu_RoguelikeArchiveComponentDataT {
    fn default() -> Self {
        Self {
            relic: None,
            capsule: None,
            trap: None,
            chat: None,
            endbook: None,
            buff: None,
            totem: None,
            chaos: None,
            fragment: None,
            disaster: None,
            wrath: None,
            copper: None,
        }
    }
}
impl clz_Torappu_RoguelikeArchiveComponentDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveComponentData<'b>> {
        let relic = self.relic.as_ref().map(|x| x.pack(_fbb));
        let capsule = self.capsule.as_ref().map(|x| x.pack(_fbb));
        let trap = self.trap.as_ref().map(|x| x.pack(_fbb));
        let chat = self.chat.as_ref().map(|x| x.pack(_fbb));
        let endbook = self.endbook.as_ref().map(|x| x.pack(_fbb));
        let buff = self.buff.as_ref().map(|x| x.pack(_fbb));
        let totem = self.totem.as_ref().map(|x| x.pack(_fbb));
        let chaos = self.chaos.as_ref().map(|x| x.pack(_fbb));
        let fragment = self.fragment.as_ref().map(|x| x.pack(_fbb));
        let disaster = self.disaster.as_ref().map(|x| x.pack(_fbb));
        let wrath = self.wrath.as_ref().map(|x| x.pack(_fbb));
        let copper = self.copper.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeArchiveComponentData::create(
            _fbb,
            &clz_Torappu_RoguelikeArchiveComponentDataArgs {
                relic,
                capsule,
                trap,
                chat,
                endbook,
                buff,
                totem,
                chaos,
                fragment,
                disaster,
                wrath,
                copper,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeArchiveUnlockCondDescOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeArchiveUnlockCondDesc<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeArchiveUnlockCondDesc<'a> {
    type Inner = clz_Torappu_RoguelikeArchiveUnlockCondDesc<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeArchiveUnlockCondDesc<'a> {
    pub const VT_ARCHIVETYPE: flatbuffers::VOffsetT = 4;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeArchiveUnlockCondDesc { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeArchiveUnlockCondDescArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveUnlockCondDesc<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeArchiveUnlockCondDescBuilder::new(_fbb);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        builder.add_archiveType(args.archiveType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeArchiveUnlockCondDescT {
        let archiveType = self.archiveType();
        let description = self.description().map(|x| x.to_string());
        clz_Torappu_RoguelikeArchiveUnlockCondDescT {
            archiveType,
            description,
        }
    }

    #[inline]
    pub fn archiveType(&self) -> enum__Torappu_ActArchiveType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ActArchiveType>(
                    clz_Torappu_RoguelikeArchiveUnlockCondDesc::VT_ARCHIVETYPE,
                    Some(enum__Torappu_ActArchiveType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeArchiveUnlockCondDesc::VT_DESCRIPTION,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeArchiveUnlockCondDesc<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ActArchiveType>(
                "archiveType",
                Self::VT_ARCHIVETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeArchiveUnlockCondDescArgs<'a> {
    pub archiveType: enum__Torappu_ActArchiveType,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeArchiveUnlockCondDescArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeArchiveUnlockCondDescArgs {
            archiveType: enum__Torappu_ActArchiveType::NONE,
            description: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeArchiveUnlockCondDesc<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeArchiveUnlockCondDesc", 2)?;
        s.serialize_field("archiveType", &self.archiveType())?;
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeArchiveUnlockCondDescBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeArchiveUnlockCondDescBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_archiveType(&mut self, archiveType: enum__Torappu_ActArchiveType) {
        self.fbb_.push_slot::<enum__Torappu_ActArchiveType>(
            clz_Torappu_RoguelikeArchiveUnlockCondDesc::VT_ARCHIVETYPE,
            archiveType,
            enum__Torappu_ActArchiveType::NONE,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeArchiveUnlockCondDesc::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeArchiveUnlockCondDescBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeArchiveUnlockCondDescBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveUnlockCondDesc<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeArchiveUnlockCondDesc<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeArchiveUnlockCondDesc");
        ds.field("archiveType", &self.archiveType());
        ds.field("description", &self.description());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeArchiveUnlockCondDescT {
    pub archiveType: enum__Torappu_ActArchiveType,
    pub description: Option<String>,
}
impl Default for clz_Torappu_RoguelikeArchiveUnlockCondDescT {
    fn default() -> Self {
        Self {
            archiveType: enum__Torappu_ActArchiveType::NONE,
            description: None,
        }
    }
}
impl clz_Torappu_RoguelikeArchiveUnlockCondDescT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveUnlockCondDesc<'b>> {
        let archiveType = self.archiveType;
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeArchiveUnlockCondDesc::create(
            _fbb,
            &clz_Torappu_RoguelikeArchiveUnlockCondDescArgs {
                archiveType,
                description,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeArchiveUnlockCondDesc<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeArchiveUnlockCondDesc>>(
                    dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeArchiveUnlockCondDesc>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveUnlockCondDesc<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveUnlockCondDesc<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveUnlockCondDesc>>(
                dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeArchiveUnlockCondDescT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeArchiveEnrollOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeArchiveEnroll<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeArchiveEnroll<'a> {
    type Inner = clz_Torappu_RoguelikeArchiveEnroll<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeArchiveEnroll<'a> {
    pub const VT_ARCHIVETYPE: flatbuffers::VOffsetT = 4;
    pub const VT_ENROLLID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeArchiveEnroll { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeArchiveEnrollArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveEnroll<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeArchiveEnrollBuilder::new(_fbb);
        if let Some(x) = args.enrollId {
            builder.add_enrollId(x);
        }
        builder.add_archiveType(args.archiveType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeArchiveEnrollT {
        let archiveType = self.archiveType();
        let enrollId = self.enrollId().map(|x| x.to_string());
        clz_Torappu_RoguelikeArchiveEnrollT {
            archiveType,
            enrollId,
        }
    }

    #[inline]
    pub fn archiveType(&self) -> enum__Torappu_ActArchiveType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ActArchiveType>(
                    clz_Torappu_RoguelikeArchiveEnroll::VT_ARCHIVETYPE,
                    Some(enum__Torappu_ActArchiveType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn enrollId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeArchiveEnroll::VT_ENROLLID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeArchiveEnroll<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ActArchiveType>(
                "archiveType",
                Self::VT_ARCHIVETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollId",
                Self::VT_ENROLLID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeArchiveEnrollArgs<'a> {
    pub archiveType: enum__Torappu_ActArchiveType,
    pub enrollId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeArchiveEnrollArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeArchiveEnrollArgs {
            archiveType: enum__Torappu_ActArchiveType::NONE,
            enrollId: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeArchiveEnroll<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeArchiveEnroll", 2)?;
        s.serialize_field("archiveType", &self.archiveType())?;
        if let Some(f) = self.enrollId() {
            s.serialize_field("enrollId", &f)?;
        } else {
            s.skip_field("enrollId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeArchiveEnrollBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeArchiveEnrollBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_archiveType(&mut self, archiveType: enum__Torappu_ActArchiveType) {
        self.fbb_.push_slot::<enum__Torappu_ActArchiveType>(
            clz_Torappu_RoguelikeArchiveEnroll::VT_ARCHIVETYPE,
            archiveType,
            enum__Torappu_ActArchiveType::NONE,
        );
    }
    #[inline]
    pub fn add_enrollId(&mut self, enrollId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeArchiveEnroll::VT_ENROLLID,
            enrollId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeArchiveEnrollBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeArchiveEnrollBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveEnroll<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeArchiveEnroll<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeArchiveEnroll");
        ds.field("archiveType", &self.archiveType());
        ds.field("enrollId", &self.enrollId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeArchiveEnrollT {
    pub archiveType: enum__Torappu_ActArchiveType,
    pub enrollId: Option<String>,
}
impl Default for clz_Torappu_RoguelikeArchiveEnrollT {
    fn default() -> Self {
        Self {
            archiveType: enum__Torappu_ActArchiveType::NONE,
            enrollId: None,
        }
    }
}
impl clz_Torappu_RoguelikeArchiveEnrollT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveEnroll<'b>> {
        let archiveType = self.archiveType;
        let enrollId = self.enrollId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeArchiveEnroll::create(
            _fbb,
            &clz_Torappu_RoguelikeArchiveEnrollArgs {
                archiveType,
                enrollId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeArchiveEnrollOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeArchiveEnroll<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeArchiveEnroll<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeArchiveEnroll<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeArchiveEnroll<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeArchiveEnroll { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeArchiveEnrollArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeArchiveEnroll<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeArchiveEnrollBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeArchiveEnrollT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeArchiveEnrollT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeArchiveEnroll::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeArchiveEnroll,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeArchiveEnroll<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeArchiveEnroll>>(
                    dict__string__clz_Torappu_RoguelikeArchiveEnroll::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeArchiveEnroll<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeArchiveEnroll>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeArchiveEnrollArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveEnroll<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeArchiveEnrollArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeArchiveEnrollArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeArchiveEnroll<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeArchiveEnroll", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeArchiveEnrollBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeArchiveEnrollBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeArchiveEnroll::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveEnroll<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveEnroll>>(
                dict__string__clz_Torappu_RoguelikeArchiveEnroll::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeArchiveEnrollBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeArchiveEnrollBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeArchiveEnroll<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeArchiveEnroll::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeArchiveEnroll<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeArchiveEnroll");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeArchiveEnrollT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeArchiveEnrollT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeArchiveEnrollT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeArchiveEnrollT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeArchiveEnroll<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeArchiveEnroll::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeArchiveEnrollArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeArchiveUnlockCondDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeArchiveUnlockCondData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeArchiveUnlockCondData<'a> {
    type Inner = clz_Torappu_RoguelikeArchiveUnlockCondData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeArchiveUnlockCondData<'a> {
    pub const VT_UNLOCKCONDDESC: flatbuffers::VOffsetT = 4;
    pub const VT_ENROLL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeArchiveUnlockCondData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeArchiveUnlockCondDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveUnlockCondData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeArchiveUnlockCondDataBuilder::new(_fbb);
        if let Some(x) = args.enroll {
            builder.add_enroll(x);
        }
        if let Some(x) = args.unlockCondDesc {
            builder.add_unlockCondDesc(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeArchiveUnlockCondDataT {
        let unlockCondDesc = self
            .unlockCondDesc()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let enroll = self
            .enroll()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeArchiveUnlockCondDataT {
            unlockCondDesc,
            enroll,
        }
    }

    #[inline]
    pub fn unlockCondDesc(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeArchiveUnlockCondData::VT_UNLOCKCONDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn enroll(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeArchiveEnroll<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeArchiveEnroll>,
                >,
            >>(clz_Torappu_RoguelikeArchiveUnlockCondData::VT_ENROLL, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeArchiveUnlockCondData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc,
                    >,
                >,
            >>("unlockCondDesc", Self::VT_UNLOCKCONDDESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeArchiveEnroll>,
                >,
            >>("enroll", Self::VT_ENROLL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeArchiveUnlockCondDataArgs<'a> {
    pub unlockCondDesc: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc<'a>,
                >,
            >,
        >,
    >,
    pub enroll: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeArchiveEnroll<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeArchiveUnlockCondDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeArchiveUnlockCondDataArgs {
            unlockCondDesc: None,
            enroll: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeArchiveUnlockCondData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeArchiveUnlockCondData", 2)?;
        if let Some(f) = self.unlockCondDesc() {
            s.serialize_field("unlockCondDesc", &f)?;
        } else {
            s.skip_field("unlockCondDesc")?;
        }
        if let Some(f) = self.enroll() {
            s.serialize_field("enroll", &f)?;
        } else {
            s.skip_field("enroll")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeArchiveUnlockCondDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeArchiveUnlockCondDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_unlockCondDesc(
        &mut self,
        unlockCondDesc: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDesc<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeArchiveUnlockCondData::VT_UNLOCKCONDDESC,
            unlockCondDesc,
        );
    }
    #[inline]
    pub fn add_enroll(
        &mut self,
        enroll: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeArchiveEnroll<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeArchiveUnlockCondData::VT_ENROLL,
            enroll,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeArchiveUnlockCondDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeArchiveUnlockCondDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveUnlockCondData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeArchiveUnlockCondData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeArchiveUnlockCondData");
        ds.field("unlockCondDesc", &self.unlockCondDesc());
        ds.field("enroll", &self.enroll());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeArchiveUnlockCondDataT {
    pub unlockCondDesc: Option<Vec<dict__string__clz_Torappu_RoguelikeArchiveUnlockCondDescT>>,
    pub enroll: Option<Vec<dict__string__clz_Torappu_RoguelikeArchiveEnrollT>>,
}
impl Default for clz_Torappu_RoguelikeArchiveUnlockCondDataT {
    fn default() -> Self {
        Self {
            unlockCondDesc: None,
            enroll: None,
        }
    }
}
impl clz_Torappu_RoguelikeArchiveUnlockCondDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveUnlockCondData<'b>> {
        let unlockCondDesc = self.unlockCondDesc.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let enroll = self.enroll.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeArchiveUnlockCondData::create(
            _fbb,
            &clz_Torappu_RoguelikeArchiveUnlockCondDataArgs {
                unlockCondDesc,
                enroll,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a> {
    type Inner = clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a> {
    pub const VT_EXP: flatbuffers::VOffsetT = 4;
    pub const VT_POPULATIONUP: flatbuffers::VOffsetT = 6;
    pub const VT_SQUADCAPACITYUP: flatbuffers::VOffsetT = 8;
    pub const VT_BATTLECHARLIMITUP: flatbuffers::VOffsetT = 10;
    pub const VT_MAXHPUP: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataBuilder::new(_fbb);
        builder.add_maxHpUp(args.maxHpUp);
        builder.add_battleCharLimitUp(args.battleCharLimitUp);
        builder.add_squadCapacityUp(args.squadCapacityUp);
        builder.add_populationUp(args.populationUp);
        builder.add_exp(args.exp);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataT {
        let exp = self.exp();
        let populationUp = self.populationUp();
        let squadCapacityUp = self.squadCapacityUp();
        let battleCharLimitUp = self.battleCharLimitUp();
        let maxHpUp = self.maxHpUp();
        clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataT {
            exp,
            populationUp,
            squadCapacityUp,
            battleCharLimitUp,
            maxHpUp,
        }
    }

    #[inline]
    pub fn exp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::VT_EXP,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn populationUp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::VT_POPULATIONUP,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn squadCapacityUp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::VT_SQUADCAPACITYUP,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn battleCharLimitUp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::VT_BATTLECHARLIMITUP,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxHpUp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::VT_MAXHPUP,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("exp", Self::VT_EXP, false)?
            .visit_field::<i32>("populationUp", Self::VT_POPULATIONUP, false)?
            .visit_field::<i32>("squadCapacityUp", Self::VT_SQUADCAPACITYUP, false)?
            .visit_field::<i32>("battleCharLimitUp", Self::VT_BATTLECHARLIMITUP, false)?
            .visit_field::<i32>("maxHpUp", Self::VT_MAXHPUP, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataArgs {
    pub exp: i32,
    pub populationUp: i32,
    pub squadCapacityUp: i32,
    pub battleCharLimitUp: i32,
    pub maxHpUp: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataArgs {
            exp: 0,
            populationUp: 0,
            squadCapacityUp: 0,
            battleCharLimitUp: 0,
            maxHpUp: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData", 5)?;
        s.serialize_field("exp", &self.exp())?;
        s.serialize_field("populationUp", &self.populationUp())?;
        s.serialize_field("squadCapacityUp", &self.squadCapacityUp())?;
        s.serialize_field("battleCharLimitUp", &self.battleCharLimitUp())?;
        s.serialize_field("maxHpUp", &self.maxHpUp())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_exp(&mut self, exp: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::VT_EXP,
            exp,
            0,
        );
    }
    #[inline]
    pub fn add_populationUp(&mut self, populationUp: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::VT_POPULATIONUP,
            populationUp,
            0,
        );
    }
    #[inline]
    pub fn add_squadCapacityUp(&mut self, squadCapacityUp: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::VT_SQUADCAPACITYUP,
            squadCapacityUp,
            0,
        );
    }
    #[inline]
    pub fn add_battleCharLimitUp(&mut self, battleCharLimitUp: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::VT_BATTLECHARLIMITUP,
            battleCharLimitUp,
            0,
        );
    }
    #[inline]
    pub fn add_maxHpUp(&mut self, maxHpUp: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::VT_MAXHPUP,
            maxHpUp,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData");
        ds.field("exp", &self.exp());
        ds.field("populationUp", &self.populationUp());
        ds.field("squadCapacityUp", &self.squadCapacityUp());
        ds.field("battleCharLimitUp", &self.battleCharLimitUp());
        ds.field("maxHpUp", &self.maxHpUp());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataT {
    pub exp: i32,
    pub populationUp: i32,
    pub squadCapacityUp: i32,
    pub battleCharLimitUp: i32,
    pub maxHpUp: i32,
}
impl Default for clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataT {
    fn default() -> Self {
        Self {
            exp: 0,
            populationUp: 0,
            squadCapacityUp: 0,
            battleCharLimitUp: 0,
            maxHpUp: 0,
        }
    }
}
impl clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'b>> {
        let exp = self.exp;
        let populationUp = self.populationUp;
        let squadCapacityUp = self.squadCapacityUp;
        let battleCharLimitUp = self.battleCharLimitUp;
        let maxHpUp = self.maxHpUp;
        clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataArgs {
                exp,
                populationUp,
                squadCapacityUp,
                battleCharLimitUp,
                maxHpUp,
            },
        )
    }
}
pub enum dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a>
{
    type Inner = dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'bldr>,
    > {
        let mut builder =
            dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataT {
        let key = self.key();
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData,
            >>(
                dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<i32>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataArgs<'a> {
    pub key: i32,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a>>>,
}
impl<'a> Default for dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataArgs {
            key: 0,
            value: None,
        }
    }
}

impl Serialize for dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData>>(dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataT {
    pub key: i32,
    pub value: Option<Box<clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataT>>,
}
impl Default for dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataT {
    fn default() -> Self {
        Self {
            key: 0,
            value: None,
        }
    }
}
impl dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'b>>
    {
        let key = self.key;
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData::create(
            _fbb,
            &dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'a> {
    type Inner = clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'a> {
    pub const VT_EVOLVEPHASE: flatbuffers::VOffsetT = 4;
    pub const VT_SKILLLEVEL: flatbuffers::VOffsetT = 6;
    pub const VT_SKILLSPECIALIZELEVEL: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataBuilder::new(_fbb);
        builder.add_skillSpecializeLevel(args.skillSpecializeLevel);
        builder.add_skillLevel(args.skillLevel);
        builder.add_evolvePhase(args.evolvePhase);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataT {
        let evolvePhase = self.evolvePhase();
        let skillLevel = self.skillLevel();
        let skillSpecializeLevel = self.skillSpecializeLevel();
        clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataT {
            evolvePhase,
            skillLevel,
            skillSpecializeLevel,
        }
    }

    #[inline]
    pub fn evolvePhase(&self) -> enum__Torappu_EvolvePhase {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EvolvePhase>(
                    clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData::VT_EVOLVEPHASE,
                    Some(enum__Torappu_EvolvePhase::PHASE_0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn skillLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData::VT_SKILLLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn skillSpecializeLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData::VT_SKILLSPECIALIZELEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_EvolvePhase>("evolvePhase", Self::VT_EVOLVEPHASE, false)?
            .visit_field::<i32>("skillLevel", Self::VT_SKILLLEVEL, false)?
            .visit_field::<i32>("skillSpecializeLevel", Self::VT_SKILLSPECIALIZELEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataArgs {
    pub evolvePhase: enum__Torappu_EvolvePhase,
    pub skillLevel: i32,
    pub skillSpecializeLevel: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataArgs {
            evolvePhase: enum__Torappu_EvolvePhase::PHASE_0,
            skillLevel: 0,
            skillSpecializeLevel: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData", 3)?;
        s.serialize_field("evolvePhase", &self.evolvePhase())?;
        s.serialize_field("skillLevel", &self.skillLevel())?;
        s.serialize_field("skillSpecializeLevel", &self.skillSpecializeLevel())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_evolvePhase(&mut self, evolvePhase: enum__Torappu_EvolvePhase) {
        self.fbb_.push_slot::<enum__Torappu_EvolvePhase>(
            clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData::VT_EVOLVEPHASE,
            evolvePhase,
            enum__Torappu_EvolvePhase::PHASE_0,
        );
    }
    #[inline]
    pub fn add_skillLevel(&mut self, skillLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData::VT_SKILLLEVEL,
            skillLevel,
            0,
        );
    }
    #[inline]
    pub fn add_skillSpecializeLevel(&mut self, skillSpecializeLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData::VT_SKILLSPECIALIZELEVEL,
            skillSpecializeLevel,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData");
        ds.field("evolvePhase", &self.evolvePhase());
        ds.field("skillLevel", &self.skillLevel());
        ds.field("skillSpecializeLevel", &self.skillSpecializeLevel());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataT {
    pub evolvePhase: enum__Torappu_EvolvePhase,
    pub skillLevel: i32,
    pub skillSpecializeLevel: i32,
}
impl Default for clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataT {
    fn default() -> Self {
        Self {
            evolvePhase: enum__Torappu_EvolvePhase::PHASE_0,
            skillLevel: 0,
            skillSpecializeLevel: 0,
        }
    }
}
impl clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'b>> {
        let evolvePhase = self.evolvePhase;
        let skillLevel = self.skillLevel;
        let skillSpecializeLevel = self.skillSpecializeLevel;
        clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataArgs {
                evolvePhase,
                skillLevel,
                skillSpecializeLevel,
            },
        )
    }
}
pub enum dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'a>
{
    type Inner = dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'bldr>,
    > {
        let mut builder =
            dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataT {
        let key = self.key();
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData,
            >>(
                dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<i32>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataArgs<'a> {
    pub key: i32,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'a>>>,
}
impl<'a> Default for dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataArgs {
            key: 0,
            value: None,
        }
    }
}

impl Serialize for dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData>>(dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataT {
    pub key: i32,
    pub value: Option<Box<clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataT>>,
}
impl Default for dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataT {
    fn default() -> Self {
        Self {
            key: 0,
            value: None,
        }
    }
}
impl dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'b>>
    {
        let key = self.key;
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData::create(
            _fbb,
            &dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataArgs { key, value },
        )
    }
}
pub enum dict__int__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__int__string<'a> {
    type Inner = dict__int__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__int__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__string<'bldr>> {
        let mut builder = dict__int__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__int__stringT {
        let key = self.key();
        let value = self.value().map(|x| x.to_string());
        dict__int__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(dict__int__string::VT_KEY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__int__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__int__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__int__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__int__stringArgs<'a> {
    pub key: i32,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__int__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__stringArgs {
            key: 0,
            value: None,
        }
    }
}

impl Serialize for dict__int__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__int__string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__int__stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__int__stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_
            .push_slot::<i32>(dict__int__string::VT_KEY, key, 0);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__int__string::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__int__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__int__stringT {
    pub key: i32,
    pub value: Option<String>,
}
impl Default for dict__int__stringT {
    fn default() -> Self {
        Self {
            key: 0,
            value: None,
        }
    }
}
impl dict__int__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__int__string<'b>> {
        let key = self.key;
        let value = self.value.as_ref().map(|x| _fbb.create_string(x));
        dict__int__string::create(_fbb, &dict__int__stringArgs { key, value })
    }
}
pub enum clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'a>
{
    type Inner = clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'a> {
    pub const VT_LEVELS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'bldr>,
    > {
        let mut builder =
            clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataBuilder::new(_fbb);
        if let Some(x) = args.levels {
            builder.add_levels(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataT {
        let levels = self
            .levels()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataT { levels }
    }

    #[inline]
    pub fn levels(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData::VT_LEVELS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData,
                    >,
                >,
            >>("levels", Self::VT_LEVELS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataArgs<'a> {
    pub levels: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataArgs { levels: None }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData",
            1,
        )?;
        if let Some(f) = self.levels() {
            s.serialize_field("levels", &f)?;
        } else {
            s.skip_field("levels")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_levels(
        &mut self,
        levels: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData::VT_LEVELS,
            levels,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData");
        ds.field("levels", &self.levels());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataT {
    pub levels: Option<Vec<dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataT>>,
}
impl Default for clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataT {
    fn default() -> Self {
        Self { levels: None }
    }
}
impl clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'b>>
    {
        let levels = self.levels.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataArgs { levels },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'a>
{
    type Inner = dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'bldr>,
    > {
        let mut builder = dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(
        &self,
    ) -> dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataT {
            key,
            value,
        }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData::VT_KEY, None).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData>>(dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'a>>,
    >,
}
impl<'a> Default
    for dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize
    for dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'_>
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<
            clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData,
        >>(
            dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataBuilder<
        'a,
        'b,
        A,
    > {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData",
        );
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'b>,
    > {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataArgs {
                key,
                value,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicDetailConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicDetailConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicDetailConst<'a> {
    type Inner = clz_Torappu_RoguelikeTopicDetailConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicDetailConst<'a> {
    pub const VT_PLAYERLEVELTABLE: flatbuffers::VOffsetT = 4;
    pub const VT_CHARUPGRADETABLE: flatbuffers::VOffsetT = 6;
    pub const VT_DIFFICULTYUPGRADERELICDESCTABLE: flatbuffers::VOffsetT = 8;
    pub const VT_PREDEFINEDLEVELTABLE: flatbuffers::VOffsetT = 10;
    pub const VT_TOKENBPID: flatbuffers::VOffsetT = 12;
    pub const VT_TOKENOUTERBUFFID: flatbuffers::VOffsetT = 14;
    pub const VT_SPOPERATORLOCKEDMESSAGE: flatbuffers::VOffsetT = 16;
    pub const VT_PREVIEWEDREWARDSACCORDINGUPDATEID: flatbuffers::VOffsetT = 18;
    pub const VT_TIPBUTTONNAME: flatbuffers::VOffsetT = 20;
    pub const VT_COLLECTBUTTONNAME: flatbuffers::VOffsetT = 22;
    pub const VT_BPSYSTEMNAME: flatbuffers::VOffsetT = 24;
    pub const VT_AUTOSETKV: flatbuffers::VOffsetT = 26;
    pub const VT_BPPURCHASEACTIVEENROLL: flatbuffers::VOffsetT = 28;
    pub const VT_DEFAULTEXPEDITIONSELECTDESC: flatbuffers::VOffsetT = 30;
    pub const VT_GOTCHARMUTATIONBUFFTOAST: flatbuffers::VOffsetT = 32;
    pub const VT_GOTCHAREVOLUTIONBUFFTOAST: flatbuffers::VOffsetT = 34;
    pub const VT_GOTSQUADBUFFTOAST: flatbuffers::VOffsetT = 36;
    pub const VT_LOSECHARBUFFTOAST: flatbuffers::VOffsetT = 38;
    pub const VT_MONTHTEAMSYSTEMNAME: flatbuffers::VOffsetT = 40;
    pub const VT_BATTLEPASSUPDATENAME: flatbuffers::VOffsetT = 42;
    pub const VT_MONTHCHARCARDTAGNAME: flatbuffers::VOffsetT = 44;
    pub const VT_MONTHTEAMDESCTAGNAME: flatbuffers::VOffsetT = 46;
    pub const VT_OUTERBUFFCOMPLETETEXT: flatbuffers::VOffsetT = 48;
    pub const VT_OUTERPROGRESSTEXTCOLOR: flatbuffers::VOffsetT = 50;
    pub const VT_CHALLENGETASKTARGETNAME: flatbuffers::VOffsetT = 52;
    pub const VT_CHALLENGETASKCONDITIONNAME: flatbuffers::VOffsetT = 54;
    pub const VT_CHALLENGETASKREWARDNAME: flatbuffers::VOffsetT = 56;
    pub const VT_CHALLENGETASKMODENAME: flatbuffers::VOffsetT = 58;
    pub const VT_CHALLENGETASKNAME: flatbuffers::VOffsetT = 60;
    pub const VT_OUTERBUFFTOKENSUM: flatbuffers::VOffsetT = 62;
    pub const VT_NEEDALLFRONTNODE: flatbuffers::VOffsetT = 64;
    pub const VT_SHOWBLURBACK: flatbuffers::VOffsetT = 66;
    pub const VT_ENDINGICONBORDERDIFFICULTY: flatbuffers::VOffsetT = 68;
    pub const VT_ENDINGICONBORDERCOUNT: flatbuffers::VOffsetT = 70;
    pub const VT_COPYSEEDMODEINFO: flatbuffers::VOffsetT = 72;
    pub const VT_COPYSUCCEEDEDTEXTHINT: flatbuffers::VOffsetT = 74;
    pub const VT_HISTORICALRECORDSCOUNT: flatbuffers::VOffsetT = 76;
    pub const VT_HISTORICALRECORDSSTARTTIME: flatbuffers::VOffsetT = 78;
    pub const VT_HISTORICALRECORDSMODE: flatbuffers::VOffsetT = 80;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicDetailConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicDetailConstArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicDetailConstBuilder::new(_fbb);
        builder.add_historicalRecordsStartTime(args.historicalRecordsStartTime);
        builder.add_historicalRecordsMode(args.historicalRecordsMode);
        builder.add_historicalRecordsCount(args.historicalRecordsCount);
        if let Some(x) = args.copySucceededTextHint {
            builder.add_copySucceededTextHint(x);
        }
        if let Some(x) = args.copySeedModeInfo {
            builder.add_copySeedModeInfo(x);
        }
        builder.add_endingIconBorderCount(args.endingIconBorderCount);
        builder.add_endingIconBorderDifficulty(args.endingIconBorderDifficulty);
        builder.add_outerBuffTokenSum(args.outerBuffTokenSum);
        if let Some(x) = args.challengeTaskName {
            builder.add_challengeTaskName(x);
        }
        if let Some(x) = args.challengeTaskModeName {
            builder.add_challengeTaskModeName(x);
        }
        if let Some(x) = args.challengeTaskRewardName {
            builder.add_challengeTaskRewardName(x);
        }
        if let Some(x) = args.challengeTaskConditionName {
            builder.add_challengeTaskConditionName(x);
        }
        if let Some(x) = args.challengeTaskTargetName {
            builder.add_challengeTaskTargetName(x);
        }
        if let Some(x) = args.outerProgressTextColor {
            builder.add_outerProgressTextColor(x);
        }
        if let Some(x) = args.outerBuffCompleteText {
            builder.add_outerBuffCompleteText(x);
        }
        if let Some(x) = args.monthTeamDescTagName {
            builder.add_monthTeamDescTagName(x);
        }
        if let Some(x) = args.monthCharCardTagName {
            builder.add_monthCharCardTagName(x);
        }
        if let Some(x) = args.battlePassUpdateName {
            builder.add_battlePassUpdateName(x);
        }
        if let Some(x) = args.monthTeamSystemName {
            builder.add_monthTeamSystemName(x);
        }
        if let Some(x) = args.loseCharBuffToast {
            builder.add_loseCharBuffToast(x);
        }
        if let Some(x) = args.gotSquadBuffToast {
            builder.add_gotSquadBuffToast(x);
        }
        if let Some(x) = args.gotCharEvolutionBuffToast {
            builder.add_gotCharEvolutionBuffToast(x);
        }
        if let Some(x) = args.gotCharMutationBuffToast {
            builder.add_gotCharMutationBuffToast(x);
        }
        if let Some(x) = args.defaultExpeditionSelectDesc {
            builder.add_defaultExpeditionSelectDesc(x);
        }
        if let Some(x) = args.bpPurchaseActiveEnroll {
            builder.add_bpPurchaseActiveEnroll(x);
        }
        if let Some(x) = args.autoSetKV {
            builder.add_autoSetKV(x);
        }
        if let Some(x) = args.bpSystemName {
            builder.add_bpSystemName(x);
        }
        if let Some(x) = args.collectButtonName {
            builder.add_collectButtonName(x);
        }
        if let Some(x) = args.tipButtonName {
            builder.add_tipButtonName(x);
        }
        if let Some(x) = args.previewedRewardsAccordingUpdateId {
            builder.add_previewedRewardsAccordingUpdateId(x);
        }
        if let Some(x) = args.spOperatorLockedMessage {
            builder.add_spOperatorLockedMessage(x);
        }
        if let Some(x) = args.tokenOuterBuffId {
            builder.add_tokenOuterBuffId(x);
        }
        if let Some(x) = args.tokenBpId {
            builder.add_tokenBpId(x);
        }
        if let Some(x) = args.predefinedLevelTable {
            builder.add_predefinedLevelTable(x);
        }
        if let Some(x) = args.difficultyUpgradeRelicDescTable {
            builder.add_difficultyUpgradeRelicDescTable(x);
        }
        if let Some(x) = args.charUpgradeTable {
            builder.add_charUpgradeTable(x);
        }
        if let Some(x) = args.playerLevelTable {
            builder.add_playerLevelTable(x);
        }
        builder.add_showBlurBack(args.showBlurBack);
        builder.add_needAllFrontNode(args.needAllFrontNode);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicDetailConstT {
        let playerLevelTable = self
            .playerLevelTable()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let charUpgradeTable = self
            .charUpgradeTable()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let difficultyUpgradeRelicDescTable = self
            .difficultyUpgradeRelicDescTable()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let predefinedLevelTable = self
            .predefinedLevelTable()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let tokenBpId = self.tokenBpId().map(|x| x.to_string());
        let tokenOuterBuffId = self.tokenOuterBuffId().map(|x| x.to_string());
        let spOperatorLockedMessage = self.spOperatorLockedMessage().map(|x| x.to_string());
        let previewedRewardsAccordingUpdateId = self
            .previewedRewardsAccordingUpdateId()
            .map(|x| x.to_string());
        let tipButtonName = self.tipButtonName().map(|x| x.to_string());
        let collectButtonName = self.collectButtonName().map(|x| x.to_string());
        let bpSystemName = self.bpSystemName().map(|x| x.to_string());
        let autoSetKV = self.autoSetKV().map(|x| x.to_string());
        let bpPurchaseActiveEnroll = self.bpPurchaseActiveEnroll().map(|x| x.to_string());
        let defaultExpeditionSelectDesc = self.defaultExpeditionSelectDesc().map(|x| x.to_string());
        let gotCharMutationBuffToast = self.gotCharMutationBuffToast().map(|x| x.to_string());
        let gotCharEvolutionBuffToast = self.gotCharEvolutionBuffToast().map(|x| x.to_string());
        let gotSquadBuffToast = self.gotSquadBuffToast().map(|x| x.to_string());
        let loseCharBuffToast = self.loseCharBuffToast().map(|x| x.to_string());
        let monthTeamSystemName = self.monthTeamSystemName().map(|x| x.to_string());
        let battlePassUpdateName = self.battlePassUpdateName().map(|x| x.to_string());
        let monthCharCardTagName = self.monthCharCardTagName().map(|x| x.to_string());
        let monthTeamDescTagName = self.monthTeamDescTagName().map(|x| x.to_string());
        let outerBuffCompleteText = self.outerBuffCompleteText().map(|x| x.to_string());
        let outerProgressTextColor = self.outerProgressTextColor().map(|x| x.to_string());
        let challengeTaskTargetName = self.challengeTaskTargetName().map(|x| x.to_string());
        let challengeTaskConditionName = self.challengeTaskConditionName().map(|x| x.to_string());
        let challengeTaskRewardName = self.challengeTaskRewardName().map(|x| x.to_string());
        let challengeTaskModeName = self.challengeTaskModeName().map(|x| x.to_string());
        let challengeTaskName = self.challengeTaskName().map(|x| x.to_string());
        let outerBuffTokenSum = self.outerBuffTokenSum();
        let needAllFrontNode = self.needAllFrontNode();
        let showBlurBack = self.showBlurBack();
        let endingIconBorderDifficulty = self.endingIconBorderDifficulty();
        let endingIconBorderCount = self.endingIconBorderCount();
        let copySeedModeInfo = self.copySeedModeInfo().map(|x| x.to_string());
        let copySucceededTextHint = self.copySucceededTextHint().map(|x| x.to_string());
        let historicalRecordsCount = self.historicalRecordsCount();
        let historicalRecordsStartTime = self.historicalRecordsStartTime();
        let historicalRecordsMode = self.historicalRecordsMode();
        clz_Torappu_RoguelikeTopicDetailConstT {
            playerLevelTable,
            charUpgradeTable,
            difficultyUpgradeRelicDescTable,
            predefinedLevelTable,
            tokenBpId,
            tokenOuterBuffId,
            spOperatorLockedMessage,
            previewedRewardsAccordingUpdateId,
            tipButtonName,
            collectButtonName,
            bpSystemName,
            autoSetKV,
            bpPurchaseActiveEnroll,
            defaultExpeditionSelectDesc,
            gotCharMutationBuffToast,
            gotCharEvolutionBuffToast,
            gotSquadBuffToast,
            loseCharBuffToast,
            monthTeamSystemName,
            battlePassUpdateName,
            monthCharCardTagName,
            monthTeamDescTagName,
            outerBuffCompleteText,
            outerProgressTextColor,
            challengeTaskTargetName,
            challengeTaskConditionName,
            challengeTaskRewardName,
            challengeTaskModeName,
            challengeTaskName,
            outerBuffTokenSum,
            needAllFrontNode,
            showBlurBack,
            endingIconBorderDifficulty,
            endingIconBorderCount,
            copySeedModeInfo,
            copySucceededTextHint,
            historicalRecordsCount,
            historicalRecordsStartTime,
            historicalRecordsMode,
        }
    }

    #[inline]
    pub fn playerLevelTable(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_PLAYERLEVELTABLE,
                None,
            )
        }
    }
    #[inline]
    pub fn charUpgradeTable(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_CHARUPGRADETABLE,
                None,
            )
        }
    }
    #[inline]
    pub fn difficultyUpgradeRelicDescTable(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__int__string<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__int__string>>,
            >>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_DIFFICULTYUPGRADERELICDESCTABLE,
                None,
            )
        }
    }
    #[inline]
    pub fn predefinedLevelTable(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData>>>>(clz_Torappu_RoguelikeTopicDetailConst::VT_PREDEFINEDLEVELTABLE, None)
        }
    }
    #[inline]
    pub fn tokenBpId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_TOKENBPID,
                None,
            )
        }
    }
    #[inline]
    pub fn tokenOuterBuffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_TOKENOUTERBUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn spOperatorLockedMessage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_SPOPERATORLOCKEDMESSAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn previewedRewardsAccordingUpdateId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_PREVIEWEDREWARDSACCORDINGUPDATEID,
                None,
            )
        }
    }
    #[inline]
    pub fn tipButtonName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_TIPBUTTONNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn collectButtonName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_COLLECTBUTTONNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn bpSystemName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_BPSYSTEMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn autoSetKV(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_AUTOSETKV,
                None,
            )
        }
    }
    #[inline]
    pub fn bpPurchaseActiveEnroll(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_BPPURCHASEACTIVEENROLL,
                None,
            )
        }
    }
    #[inline]
    pub fn defaultExpeditionSelectDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_DEFAULTEXPEDITIONSELECTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn gotCharMutationBuffToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_GOTCHARMUTATIONBUFFTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn gotCharEvolutionBuffToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_GOTCHAREVOLUTIONBUFFTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn gotSquadBuffToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_GOTSQUADBUFFTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn loseCharBuffToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_LOSECHARBUFFTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn monthTeamSystemName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_MONTHTEAMSYSTEMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn battlePassUpdateName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_BATTLEPASSUPDATENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn monthCharCardTagName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_MONTHCHARCARDTAGNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn monthTeamDescTagName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_MONTHTEAMDESCTAGNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn outerBuffCompleteText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_OUTERBUFFCOMPLETETEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn outerProgressTextColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_OUTERPROGRESSTEXTCOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn challengeTaskTargetName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_CHALLENGETASKTARGETNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn challengeTaskConditionName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_CHALLENGETASKCONDITIONNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn challengeTaskRewardName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_CHALLENGETASKREWARDNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn challengeTaskModeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_CHALLENGETASKMODENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn challengeTaskName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_CHALLENGETASKNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn outerBuffTokenSum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicDetailConst::VT_OUTERBUFFTOKENSUM,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn needAllFrontNode(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeTopicDetailConst::VT_NEEDALLFRONTNODE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn showBlurBack(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeTopicDetailConst::VT_SHOWBLURBACK,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn endingIconBorderDifficulty(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicDetailConst::VT_ENDINGICONBORDERDIFFICULTY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn endingIconBorderCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicDetailConst::VT_ENDINGICONBORDERCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn copySeedModeInfo(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_COPYSEEDMODEINFO,
                None,
            )
        }
    }
    #[inline]
    pub fn copySucceededTextHint(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDetailConst::VT_COPYSUCCEEDEDTEXTHINT,
                None,
            )
        }
    }
    #[inline]
    pub fn historicalRecordsCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicDetailConst::VT_HISTORICALRECORDSCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn historicalRecordsStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_RoguelikeTopicDetailConst::VT_HISTORICALRECORDSSTARTTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn historicalRecordsMode(&self) -> enum__Torappu_RoguelikeTopicMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTopicMode>(
                    clz_Torappu_RoguelikeTopicDetailConst::VT_HISTORICALRECORDSMODE,
                    Some(enum__Torappu_RoguelikeTopicMode::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicDetailConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData>>>>("playerLevelTable", Self::VT_PLAYERLEVELTABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData>>>>("charUpgradeTable", Self::VT_CHARUPGRADETABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__int__string>>>>("difficultyUpgradeRelicDescTable", Self::VT_DIFFICULTYUPGRADERELICDESCTABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData>>>>("predefinedLevelTable", Self::VT_PREDEFINEDLEVELTABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tokenBpId", Self::VT_TOKENBPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tokenOuterBuffId", Self::VT_TOKENOUTERBUFFID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("spOperatorLockedMessage", Self::VT_SPOPERATORLOCKEDMESSAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("previewedRewardsAccordingUpdateId", Self::VT_PREVIEWEDREWARDSACCORDINGUPDATEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tipButtonName", Self::VT_TIPBUTTONNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("collectButtonName", Self::VT_COLLECTBUTTONNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bpSystemName", Self::VT_BPSYSTEMNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("autoSetKV", Self::VT_AUTOSETKV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bpPurchaseActiveEnroll", Self::VT_BPPURCHASEACTIVEENROLL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("defaultExpeditionSelectDesc", Self::VT_DEFAULTEXPEDITIONSELECTDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("gotCharMutationBuffToast", Self::VT_GOTCHARMUTATIONBUFFTOAST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("gotCharEvolutionBuffToast", Self::VT_GOTCHAREVOLUTIONBUFFTOAST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("gotSquadBuffToast", Self::VT_GOTSQUADBUFFTOAST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("loseCharBuffToast", Self::VT_LOSECHARBUFFTOAST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("monthTeamSystemName", Self::VT_MONTHTEAMSYSTEMNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("battlePassUpdateName", Self::VT_BATTLEPASSUPDATENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("monthCharCardTagName", Self::VT_MONTHCHARCARDTAGNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("monthTeamDescTagName", Self::VT_MONTHTEAMDESCTAGNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("outerBuffCompleteText", Self::VT_OUTERBUFFCOMPLETETEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("outerProgressTextColor", Self::VT_OUTERPROGRESSTEXTCOLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("challengeTaskTargetName", Self::VT_CHALLENGETASKTARGETNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("challengeTaskConditionName", Self::VT_CHALLENGETASKCONDITIONNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("challengeTaskRewardName", Self::VT_CHALLENGETASKREWARDNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("challengeTaskModeName", Self::VT_CHALLENGETASKMODENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("challengeTaskName", Self::VT_CHALLENGETASKNAME, false)?
     .visit_field::<i32>("outerBuffTokenSum", Self::VT_OUTERBUFFTOKENSUM, false)?
     .visit_field::<bool>("needAllFrontNode", Self::VT_NEEDALLFRONTNODE, false)?
     .visit_field::<bool>("showBlurBack", Self::VT_SHOWBLURBACK, false)?
     .visit_field::<i32>("endingIconBorderDifficulty", Self::VT_ENDINGICONBORDERDIFFICULTY, false)?
     .visit_field::<i32>("endingIconBorderCount", Self::VT_ENDINGICONBORDERCOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("copySeedModeInfo", Self::VT_COPYSEEDMODEINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("copySucceededTextHint", Self::VT_COPYSUCCEEDEDTEXTHINT, false)?
     .visit_field::<i32>("historicalRecordsCount", Self::VT_HISTORICALRECORDSCOUNT, false)?
     .visit_field::<i64>("historicalRecordsStartTime", Self::VT_HISTORICALRECORDSSTARTTIME, false)?
     .visit_field::<enum__Torappu_RoguelikeTopicMode>("historicalRecordsMode", Self::VT_HISTORICALRECORDSMODE, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicDetailConstArgs<'a> {
    pub playerLevelTable: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'a>,
                >,
            >,
        >,
    >,
    pub charUpgradeTable: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'a>,
                >,
            >,
        >,
    >,
    pub difficultyUpgradeRelicDescTable: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__int__string<'a>>>,
        >,
    >,
    pub predefinedLevelTable: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<
                        'a,
                    >,
                >,
            >,
        >,
    >,
    pub tokenBpId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tokenOuterBuffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub spOperatorLockedMessage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub previewedRewardsAccordingUpdateId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tipButtonName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub collectButtonName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bpSystemName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub autoSetKV: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bpPurchaseActiveEnroll: Option<flatbuffers::WIPOffset<&'a str>>,
    pub defaultExpeditionSelectDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gotCharMutationBuffToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gotCharEvolutionBuffToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gotSquadBuffToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub loseCharBuffToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthTeamSystemName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub battlePassUpdateName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthCharCardTagName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub monthTeamDescTagName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub outerBuffCompleteText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub outerProgressTextColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub challengeTaskTargetName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub challengeTaskConditionName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub challengeTaskRewardName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub challengeTaskModeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub challengeTaskName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub outerBuffTokenSum: i32,
    pub needAllFrontNode: bool,
    pub showBlurBack: bool,
    pub endingIconBorderDifficulty: i32,
    pub endingIconBorderCount: i32,
    pub copySeedModeInfo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub copySucceededTextHint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub historicalRecordsCount: i32,
    pub historicalRecordsStartTime: i64,
    pub historicalRecordsMode: enum__Torappu_RoguelikeTopicMode,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicDetailConstArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicDetailConstArgs {
            playerLevelTable: None,
            charUpgradeTable: None,
            difficultyUpgradeRelicDescTable: None,
            predefinedLevelTable: None,
            tokenBpId: None,
            tokenOuterBuffId: None,
            spOperatorLockedMessage: None,
            previewedRewardsAccordingUpdateId: None,
            tipButtonName: None,
            collectButtonName: None,
            bpSystemName: None,
            autoSetKV: None,
            bpPurchaseActiveEnroll: None,
            defaultExpeditionSelectDesc: None,
            gotCharMutationBuffToast: None,
            gotCharEvolutionBuffToast: None,
            gotSquadBuffToast: None,
            loseCharBuffToast: None,
            monthTeamSystemName: None,
            battlePassUpdateName: None,
            monthCharCardTagName: None,
            monthTeamDescTagName: None,
            outerBuffCompleteText: None,
            outerProgressTextColor: None,
            challengeTaskTargetName: None,
            challengeTaskConditionName: None,
            challengeTaskRewardName: None,
            challengeTaskModeName: None,
            challengeTaskName: None,
            outerBuffTokenSum: 0,
            needAllFrontNode: false,
            showBlurBack: false,
            endingIconBorderDifficulty: 0,
            endingIconBorderCount: 0,
            copySeedModeInfo: None,
            copySucceededTextHint: None,
            historicalRecordsCount: 0,
            historicalRecordsStartTime: 0,
            historicalRecordsMode: enum__Torappu_RoguelikeTopicMode::NONE,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicDetailConst<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicDetailConst", 39)?;
        if let Some(f) = self.playerLevelTable() {
            s.serialize_field("playerLevelTable", &f)?;
        } else {
            s.skip_field("playerLevelTable")?;
        }
        if let Some(f) = self.charUpgradeTable() {
            s.serialize_field("charUpgradeTable", &f)?;
        } else {
            s.skip_field("charUpgradeTable")?;
        }
        if let Some(f) = self.difficultyUpgradeRelicDescTable() {
            s.serialize_field("difficultyUpgradeRelicDescTable", &f)?;
        } else {
            s.skip_field("difficultyUpgradeRelicDescTable")?;
        }
        if let Some(f) = self.predefinedLevelTable() {
            s.serialize_field("predefinedLevelTable", &f)?;
        } else {
            s.skip_field("predefinedLevelTable")?;
        }
        if let Some(f) = self.tokenBpId() {
            s.serialize_field("tokenBpId", &f)?;
        } else {
            s.skip_field("tokenBpId")?;
        }
        if let Some(f) = self.tokenOuterBuffId() {
            s.serialize_field("tokenOuterBuffId", &f)?;
        } else {
            s.skip_field("tokenOuterBuffId")?;
        }
        if let Some(f) = self.spOperatorLockedMessage() {
            s.serialize_field("spOperatorLockedMessage", &f)?;
        } else {
            s.skip_field("spOperatorLockedMessage")?;
        }
        if let Some(f) = self.previewedRewardsAccordingUpdateId() {
            s.serialize_field("previewedRewardsAccordingUpdateId", &f)?;
        } else {
            s.skip_field("previewedRewardsAccordingUpdateId")?;
        }
        if let Some(f) = self.tipButtonName() {
            s.serialize_field("tipButtonName", &f)?;
        } else {
            s.skip_field("tipButtonName")?;
        }
        if let Some(f) = self.collectButtonName() {
            s.serialize_field("collectButtonName", &f)?;
        } else {
            s.skip_field("collectButtonName")?;
        }
        if let Some(f) = self.bpSystemName() {
            s.serialize_field("bpSystemName", &f)?;
        } else {
            s.skip_field("bpSystemName")?;
        }
        if let Some(f) = self.autoSetKV() {
            s.serialize_field("autoSetKV", &f)?;
        } else {
            s.skip_field("autoSetKV")?;
        }
        if let Some(f) = self.bpPurchaseActiveEnroll() {
            s.serialize_field("bpPurchaseActiveEnroll", &f)?;
        } else {
            s.skip_field("bpPurchaseActiveEnroll")?;
        }
        if let Some(f) = self.defaultExpeditionSelectDesc() {
            s.serialize_field("defaultExpeditionSelectDesc", &f)?;
        } else {
            s.skip_field("defaultExpeditionSelectDesc")?;
        }
        if let Some(f) = self.gotCharMutationBuffToast() {
            s.serialize_field("gotCharMutationBuffToast", &f)?;
        } else {
            s.skip_field("gotCharMutationBuffToast")?;
        }
        if let Some(f) = self.gotCharEvolutionBuffToast() {
            s.serialize_field("gotCharEvolutionBuffToast", &f)?;
        } else {
            s.skip_field("gotCharEvolutionBuffToast")?;
        }
        if let Some(f) = self.gotSquadBuffToast() {
            s.serialize_field("gotSquadBuffToast", &f)?;
        } else {
            s.skip_field("gotSquadBuffToast")?;
        }
        if let Some(f) = self.loseCharBuffToast() {
            s.serialize_field("loseCharBuffToast", &f)?;
        } else {
            s.skip_field("loseCharBuffToast")?;
        }
        if let Some(f) = self.monthTeamSystemName() {
            s.serialize_field("monthTeamSystemName", &f)?;
        } else {
            s.skip_field("monthTeamSystemName")?;
        }
        if let Some(f) = self.battlePassUpdateName() {
            s.serialize_field("battlePassUpdateName", &f)?;
        } else {
            s.skip_field("battlePassUpdateName")?;
        }
        if let Some(f) = self.monthCharCardTagName() {
            s.serialize_field("monthCharCardTagName", &f)?;
        } else {
            s.skip_field("monthCharCardTagName")?;
        }
        if let Some(f) = self.monthTeamDescTagName() {
            s.serialize_field("monthTeamDescTagName", &f)?;
        } else {
            s.skip_field("monthTeamDescTagName")?;
        }
        if let Some(f) = self.outerBuffCompleteText() {
            s.serialize_field("outerBuffCompleteText", &f)?;
        } else {
            s.skip_field("outerBuffCompleteText")?;
        }
        if let Some(f) = self.outerProgressTextColor() {
            s.serialize_field("outerProgressTextColor", &f)?;
        } else {
            s.skip_field("outerProgressTextColor")?;
        }
        if let Some(f) = self.challengeTaskTargetName() {
            s.serialize_field("challengeTaskTargetName", &f)?;
        } else {
            s.skip_field("challengeTaskTargetName")?;
        }
        if let Some(f) = self.challengeTaskConditionName() {
            s.serialize_field("challengeTaskConditionName", &f)?;
        } else {
            s.skip_field("challengeTaskConditionName")?;
        }
        if let Some(f) = self.challengeTaskRewardName() {
            s.serialize_field("challengeTaskRewardName", &f)?;
        } else {
            s.skip_field("challengeTaskRewardName")?;
        }
        if let Some(f) = self.challengeTaskModeName() {
            s.serialize_field("challengeTaskModeName", &f)?;
        } else {
            s.skip_field("challengeTaskModeName")?;
        }
        if let Some(f) = self.challengeTaskName() {
            s.serialize_field("challengeTaskName", &f)?;
        } else {
            s.skip_field("challengeTaskName")?;
        }
        s.serialize_field("outerBuffTokenSum", &self.outerBuffTokenSum())?;
        s.serialize_field("needAllFrontNode", &self.needAllFrontNode())?;
        s.serialize_field("showBlurBack", &self.showBlurBack())?;
        s.serialize_field(
            "endingIconBorderDifficulty",
            &self.endingIconBorderDifficulty(),
        )?;
        s.serialize_field("endingIconBorderCount", &self.endingIconBorderCount())?;
        if let Some(f) = self.copySeedModeInfo() {
            s.serialize_field("copySeedModeInfo", &f)?;
        } else {
            s.skip_field("copySeedModeInfo")?;
        }
        if let Some(f) = self.copySucceededTextHint() {
            s.serialize_field("copySucceededTextHint", &f)?;
        } else {
            s.skip_field("copySucceededTextHint")?;
        }
        s.serialize_field("historicalRecordsCount", &self.historicalRecordsCount())?;
        s.serialize_field(
            "historicalRecordsStartTime",
            &self.historicalRecordsStartTime(),
        )?;
        s.serialize_field("historicalRecordsMode", &self.historicalRecordsMode())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicDetailConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicDetailConstBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_playerLevelTable(
        &mut self,
        playerLevelTable: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_PLAYERLEVELTABLE,
            playerLevelTable,
        );
    }
    #[inline]
    pub fn add_charUpgradeTable(
        &mut self,
        charUpgradeTable: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_CHARUPGRADETABLE,
            charUpgradeTable,
        );
    }
    #[inline]
    pub fn add_difficultyUpgradeRelicDescTable(
        &mut self,
        difficultyUpgradeRelicDescTable: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__int__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_DIFFICULTYUPGRADERELICDESCTABLE,
            difficultyUpgradeRelicDescTable,
        );
    }
    #[inline]
    pub fn add_predefinedLevelTable(
        &mut self,
        predefinedLevelTable: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelData<
                        'b,
                    >,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_PREDEFINEDLEVELTABLE,
            predefinedLevelTable,
        );
    }
    #[inline]
    pub fn add_tokenBpId(&mut self, tokenBpId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_TOKENBPID,
            tokenBpId,
        );
    }
    #[inline]
    pub fn add_tokenOuterBuffId(&mut self, tokenOuterBuffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_TOKENOUTERBUFFID,
            tokenOuterBuffId,
        );
    }
    #[inline]
    pub fn add_spOperatorLockedMessage(
        &mut self,
        spOperatorLockedMessage: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_SPOPERATORLOCKEDMESSAGE,
            spOperatorLockedMessage,
        );
    }
    #[inline]
    pub fn add_previewedRewardsAccordingUpdateId(
        &mut self,
        previewedRewardsAccordingUpdateId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_PREVIEWEDREWARDSACCORDINGUPDATEID,
            previewedRewardsAccordingUpdateId,
        );
    }
    #[inline]
    pub fn add_tipButtonName(&mut self, tipButtonName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_TIPBUTTONNAME,
            tipButtonName,
        );
    }
    #[inline]
    pub fn add_collectButtonName(&mut self, collectButtonName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_COLLECTBUTTONNAME,
            collectButtonName,
        );
    }
    #[inline]
    pub fn add_bpSystemName(&mut self, bpSystemName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_BPSYSTEMNAME,
            bpSystemName,
        );
    }
    #[inline]
    pub fn add_autoSetKV(&mut self, autoSetKV: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_AUTOSETKV,
            autoSetKV,
        );
    }
    #[inline]
    pub fn add_bpPurchaseActiveEnroll(
        &mut self,
        bpPurchaseActiveEnroll: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_BPPURCHASEACTIVEENROLL,
            bpPurchaseActiveEnroll,
        );
    }
    #[inline]
    pub fn add_defaultExpeditionSelectDesc(
        &mut self,
        defaultExpeditionSelectDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_DEFAULTEXPEDITIONSELECTDESC,
            defaultExpeditionSelectDesc,
        );
    }
    #[inline]
    pub fn add_gotCharMutationBuffToast(
        &mut self,
        gotCharMutationBuffToast: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_GOTCHARMUTATIONBUFFTOAST,
            gotCharMutationBuffToast,
        );
    }
    #[inline]
    pub fn add_gotCharEvolutionBuffToast(
        &mut self,
        gotCharEvolutionBuffToast: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_GOTCHAREVOLUTIONBUFFTOAST,
            gotCharEvolutionBuffToast,
        );
    }
    #[inline]
    pub fn add_gotSquadBuffToast(&mut self, gotSquadBuffToast: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_GOTSQUADBUFFTOAST,
            gotSquadBuffToast,
        );
    }
    #[inline]
    pub fn add_loseCharBuffToast(&mut self, loseCharBuffToast: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_LOSECHARBUFFTOAST,
            loseCharBuffToast,
        );
    }
    #[inline]
    pub fn add_monthTeamSystemName(
        &mut self,
        monthTeamSystemName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_MONTHTEAMSYSTEMNAME,
            monthTeamSystemName,
        );
    }
    #[inline]
    pub fn add_battlePassUpdateName(
        &mut self,
        battlePassUpdateName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_BATTLEPASSUPDATENAME,
            battlePassUpdateName,
        );
    }
    #[inline]
    pub fn add_monthCharCardTagName(
        &mut self,
        monthCharCardTagName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_MONTHCHARCARDTAGNAME,
            monthCharCardTagName,
        );
    }
    #[inline]
    pub fn add_monthTeamDescTagName(
        &mut self,
        monthTeamDescTagName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_MONTHTEAMDESCTAGNAME,
            monthTeamDescTagName,
        );
    }
    #[inline]
    pub fn add_outerBuffCompleteText(
        &mut self,
        outerBuffCompleteText: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_OUTERBUFFCOMPLETETEXT,
            outerBuffCompleteText,
        );
    }
    #[inline]
    pub fn add_outerProgressTextColor(
        &mut self,
        outerProgressTextColor: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_OUTERPROGRESSTEXTCOLOR,
            outerProgressTextColor,
        );
    }
    #[inline]
    pub fn add_challengeTaskTargetName(
        &mut self,
        challengeTaskTargetName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_CHALLENGETASKTARGETNAME,
            challengeTaskTargetName,
        );
    }
    #[inline]
    pub fn add_challengeTaskConditionName(
        &mut self,
        challengeTaskConditionName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_CHALLENGETASKCONDITIONNAME,
            challengeTaskConditionName,
        );
    }
    #[inline]
    pub fn add_challengeTaskRewardName(
        &mut self,
        challengeTaskRewardName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_CHALLENGETASKREWARDNAME,
            challengeTaskRewardName,
        );
    }
    #[inline]
    pub fn add_challengeTaskModeName(
        &mut self,
        challengeTaskModeName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_CHALLENGETASKMODENAME,
            challengeTaskModeName,
        );
    }
    #[inline]
    pub fn add_challengeTaskName(&mut self, challengeTaskName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_CHALLENGETASKNAME,
            challengeTaskName,
        );
    }
    #[inline]
    pub fn add_outerBuffTokenSum(&mut self, outerBuffTokenSum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_OUTERBUFFTOKENSUM,
            outerBuffTokenSum,
            0,
        );
    }
    #[inline]
    pub fn add_needAllFrontNode(&mut self, needAllFrontNode: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_NEEDALLFRONTNODE,
            needAllFrontNode,
            false,
        );
    }
    #[inline]
    pub fn add_showBlurBack(&mut self, showBlurBack: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_SHOWBLURBACK,
            showBlurBack,
            false,
        );
    }
    #[inline]
    pub fn add_endingIconBorderDifficulty(&mut self, endingIconBorderDifficulty: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_ENDINGICONBORDERDIFFICULTY,
            endingIconBorderDifficulty,
            0,
        );
    }
    #[inline]
    pub fn add_endingIconBorderCount(&mut self, endingIconBorderCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_ENDINGICONBORDERCOUNT,
            endingIconBorderCount,
            0,
        );
    }
    #[inline]
    pub fn add_copySeedModeInfo(&mut self, copySeedModeInfo: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_COPYSEEDMODEINFO,
            copySeedModeInfo,
        );
    }
    #[inline]
    pub fn add_copySucceededTextHint(
        &mut self,
        copySucceededTextHint: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_COPYSUCCEEDEDTEXTHINT,
            copySucceededTextHint,
        );
    }
    #[inline]
    pub fn add_historicalRecordsCount(&mut self, historicalRecordsCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_HISTORICALRECORDSCOUNT,
            historicalRecordsCount,
            0,
        );
    }
    #[inline]
    pub fn add_historicalRecordsStartTime(&mut self, historicalRecordsStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_HISTORICALRECORDSSTARTTIME,
            historicalRecordsStartTime,
            0,
        );
    }
    #[inline]
    pub fn add_historicalRecordsMode(
        &mut self,
        historicalRecordsMode: enum__Torappu_RoguelikeTopicMode,
    ) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeTopicMode>(
            clz_Torappu_RoguelikeTopicDetailConst::VT_HISTORICALRECORDSMODE,
            historicalRecordsMode,
            enum__Torappu_RoguelikeTopicMode::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicDetailConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicDetailConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicDetailConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicDetailConst");
        ds.field("playerLevelTable", &self.playerLevelTable());
        ds.field("charUpgradeTable", &self.charUpgradeTable());
        ds.field(
            "difficultyUpgradeRelicDescTable",
            &self.difficultyUpgradeRelicDescTable(),
        );
        ds.field("predefinedLevelTable", &self.predefinedLevelTable());
        ds.field("tokenBpId", &self.tokenBpId());
        ds.field("tokenOuterBuffId", &self.tokenOuterBuffId());
        ds.field("spOperatorLockedMessage", &self.spOperatorLockedMessage());
        ds.field(
            "previewedRewardsAccordingUpdateId",
            &self.previewedRewardsAccordingUpdateId(),
        );
        ds.field("tipButtonName", &self.tipButtonName());
        ds.field("collectButtonName", &self.collectButtonName());
        ds.field("bpSystemName", &self.bpSystemName());
        ds.field("autoSetKV", &self.autoSetKV());
        ds.field("bpPurchaseActiveEnroll", &self.bpPurchaseActiveEnroll());
        ds.field(
            "defaultExpeditionSelectDesc",
            &self.defaultExpeditionSelectDesc(),
        );
        ds.field("gotCharMutationBuffToast", &self.gotCharMutationBuffToast());
        ds.field(
            "gotCharEvolutionBuffToast",
            &self.gotCharEvolutionBuffToast(),
        );
        ds.field("gotSquadBuffToast", &self.gotSquadBuffToast());
        ds.field("loseCharBuffToast", &self.loseCharBuffToast());
        ds.field("monthTeamSystemName", &self.monthTeamSystemName());
        ds.field("battlePassUpdateName", &self.battlePassUpdateName());
        ds.field("monthCharCardTagName", &self.monthCharCardTagName());
        ds.field("monthTeamDescTagName", &self.monthTeamDescTagName());
        ds.field("outerBuffCompleteText", &self.outerBuffCompleteText());
        ds.field("outerProgressTextColor", &self.outerProgressTextColor());
        ds.field("challengeTaskTargetName", &self.challengeTaskTargetName());
        ds.field(
            "challengeTaskConditionName",
            &self.challengeTaskConditionName(),
        );
        ds.field("challengeTaskRewardName", &self.challengeTaskRewardName());
        ds.field("challengeTaskModeName", &self.challengeTaskModeName());
        ds.field("challengeTaskName", &self.challengeTaskName());
        ds.field("outerBuffTokenSum", &self.outerBuffTokenSum());
        ds.field("needAllFrontNode", &self.needAllFrontNode());
        ds.field("showBlurBack", &self.showBlurBack());
        ds.field(
            "endingIconBorderDifficulty",
            &self.endingIconBorderDifficulty(),
        );
        ds.field("endingIconBorderCount", &self.endingIconBorderCount());
        ds.field("copySeedModeInfo", &self.copySeedModeInfo());
        ds.field("copySucceededTextHint", &self.copySucceededTextHint());
        ds.field("historicalRecordsCount", &self.historicalRecordsCount());
        ds.field(
            "historicalRecordsStartTime",
            &self.historicalRecordsStartTime(),
        );
        ds.field("historicalRecordsMode", &self.historicalRecordsMode());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicDetailConstT {
    pub playerLevelTable:
        Option<Vec<dict__int__clz_Torappu_RoguelikeTopicDetailConst_PlayerLevelDataT>>,
    pub charUpgradeTable:
        Option<Vec<dict__int__clz_Torappu_RoguelikeTopicDetailConst_CharUpgradeDataT>>,
    pub difficultyUpgradeRelicDescTable: Option<Vec<dict__int__stringT>>,
    pub predefinedLevelTable:
        Option<Vec<dict__string__clz_Torappu_RoguelikeTopicDetailConst_PredefinedPlayerLevelDataT>>,
    pub tokenBpId: Option<String>,
    pub tokenOuterBuffId: Option<String>,
    pub spOperatorLockedMessage: Option<String>,
    pub previewedRewardsAccordingUpdateId: Option<String>,
    pub tipButtonName: Option<String>,
    pub collectButtonName: Option<String>,
    pub bpSystemName: Option<String>,
    pub autoSetKV: Option<String>,
    pub bpPurchaseActiveEnroll: Option<String>,
    pub defaultExpeditionSelectDesc: Option<String>,
    pub gotCharMutationBuffToast: Option<String>,
    pub gotCharEvolutionBuffToast: Option<String>,
    pub gotSquadBuffToast: Option<String>,
    pub loseCharBuffToast: Option<String>,
    pub monthTeamSystemName: Option<String>,
    pub battlePassUpdateName: Option<String>,
    pub monthCharCardTagName: Option<String>,
    pub monthTeamDescTagName: Option<String>,
    pub outerBuffCompleteText: Option<String>,
    pub outerProgressTextColor: Option<String>,
    pub challengeTaskTargetName: Option<String>,
    pub challengeTaskConditionName: Option<String>,
    pub challengeTaskRewardName: Option<String>,
    pub challengeTaskModeName: Option<String>,
    pub challengeTaskName: Option<String>,
    pub outerBuffTokenSum: i32,
    pub needAllFrontNode: bool,
    pub showBlurBack: bool,
    pub endingIconBorderDifficulty: i32,
    pub endingIconBorderCount: i32,
    pub copySeedModeInfo: Option<String>,
    pub copySucceededTextHint: Option<String>,
    pub historicalRecordsCount: i32,
    pub historicalRecordsStartTime: i64,
    pub historicalRecordsMode: enum__Torappu_RoguelikeTopicMode,
}
impl Default for clz_Torappu_RoguelikeTopicDetailConstT {
    fn default() -> Self {
        Self {
            playerLevelTable: None,
            charUpgradeTable: None,
            difficultyUpgradeRelicDescTable: None,
            predefinedLevelTable: None,
            tokenBpId: None,
            tokenOuterBuffId: None,
            spOperatorLockedMessage: None,
            previewedRewardsAccordingUpdateId: None,
            tipButtonName: None,
            collectButtonName: None,
            bpSystemName: None,
            autoSetKV: None,
            bpPurchaseActiveEnroll: None,
            defaultExpeditionSelectDesc: None,
            gotCharMutationBuffToast: None,
            gotCharEvolutionBuffToast: None,
            gotSquadBuffToast: None,
            loseCharBuffToast: None,
            monthTeamSystemName: None,
            battlePassUpdateName: None,
            monthCharCardTagName: None,
            monthTeamDescTagName: None,
            outerBuffCompleteText: None,
            outerProgressTextColor: None,
            challengeTaskTargetName: None,
            challengeTaskConditionName: None,
            challengeTaskRewardName: None,
            challengeTaskModeName: None,
            challengeTaskName: None,
            outerBuffTokenSum: 0,
            needAllFrontNode: false,
            showBlurBack: false,
            endingIconBorderDifficulty: 0,
            endingIconBorderCount: 0,
            copySeedModeInfo: None,
            copySucceededTextHint: None,
            historicalRecordsCount: 0,
            historicalRecordsStartTime: 0,
            historicalRecordsMode: enum__Torappu_RoguelikeTopicMode::NONE,
        }
    }
}
impl clz_Torappu_RoguelikeTopicDetailConstT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst<'b>> {
        let playerLevelTable = self.playerLevelTable.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let charUpgradeTable = self.charUpgradeTable.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let difficultyUpgradeRelicDescTable =
            self.difficultyUpgradeRelicDescTable.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
        let predefinedLevelTable = self.predefinedLevelTable.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let tokenBpId = self.tokenBpId.as_ref().map(|x| _fbb.create_string(x));
        let tokenOuterBuffId = self
            .tokenOuterBuffId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let spOperatorLockedMessage = self
            .spOperatorLockedMessage
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let previewedRewardsAccordingUpdateId = self
            .previewedRewardsAccordingUpdateId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let tipButtonName = self.tipButtonName.as_ref().map(|x| _fbb.create_string(x));
        let collectButtonName = self
            .collectButtonName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let bpSystemName = self.bpSystemName.as_ref().map(|x| _fbb.create_string(x));
        let autoSetKV = self.autoSetKV.as_ref().map(|x| _fbb.create_string(x));
        let bpPurchaseActiveEnroll = self
            .bpPurchaseActiveEnroll
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let defaultExpeditionSelectDesc = self
            .defaultExpeditionSelectDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let gotCharMutationBuffToast = self
            .gotCharMutationBuffToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let gotCharEvolutionBuffToast = self
            .gotCharEvolutionBuffToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let gotSquadBuffToast = self
            .gotSquadBuffToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let loseCharBuffToast = self
            .loseCharBuffToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let monthTeamSystemName = self
            .monthTeamSystemName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let battlePassUpdateName = self
            .battlePassUpdateName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let monthCharCardTagName = self
            .monthCharCardTagName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let monthTeamDescTagName = self
            .monthTeamDescTagName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let outerBuffCompleteText = self
            .outerBuffCompleteText
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let outerProgressTextColor = self
            .outerProgressTextColor
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let challengeTaskTargetName = self
            .challengeTaskTargetName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let challengeTaskConditionName = self
            .challengeTaskConditionName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let challengeTaskRewardName = self
            .challengeTaskRewardName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let challengeTaskModeName = self
            .challengeTaskModeName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let challengeTaskName = self
            .challengeTaskName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let outerBuffTokenSum = self.outerBuffTokenSum;
        let needAllFrontNode = self.needAllFrontNode;
        let showBlurBack = self.showBlurBack;
        let endingIconBorderDifficulty = self.endingIconBorderDifficulty;
        let endingIconBorderCount = self.endingIconBorderCount;
        let copySeedModeInfo = self
            .copySeedModeInfo
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let copySucceededTextHint = self
            .copySucceededTextHint
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let historicalRecordsCount = self.historicalRecordsCount;
        let historicalRecordsStartTime = self.historicalRecordsStartTime;
        let historicalRecordsMode = self.historicalRecordsMode;
        clz_Torappu_RoguelikeTopicDetailConst::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicDetailConstArgs {
                playerLevelTable,
                charUpgradeTable,
                difficultyUpgradeRelicDescTable,
                predefinedLevelTable,
                tokenBpId,
                tokenOuterBuffId,
                spOperatorLockedMessage,
                previewedRewardsAccordingUpdateId,
                tipButtonName,
                collectButtonName,
                bpSystemName,
                autoSetKV,
                bpPurchaseActiveEnroll,
                defaultExpeditionSelectDesc,
                gotCharMutationBuffToast,
                gotCharEvolutionBuffToast,
                gotSquadBuffToast,
                loseCharBuffToast,
                monthTeamSystemName,
                battlePassUpdateName,
                monthCharCardTagName,
                monthTeamDescTagName,
                outerBuffCompleteText,
                outerProgressTextColor,
                challengeTaskTargetName,
                challengeTaskConditionName,
                challengeTaskRewardName,
                challengeTaskModeName,
                challengeTaskName,
                outerBuffTokenSum,
                needAllFrontNode,
                showBlurBack,
                endingIconBorderDifficulty,
                endingIconBorderCount,
                copySeedModeInfo,
                copySucceededTextHint,
                historicalRecordsCount,
                historicalRecordsStartTime,
                historicalRecordsMode,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameInitDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameInitData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameInitData<'a> {
    type Inner = clz_Torappu_RoguelikeGameInitData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameInitData<'a> {
    pub const VT_MODEID: flatbuffers::VOffsetT = 4;
    pub const VT_MODEGRADE: flatbuffers::VOffsetT = 6;
    pub const VT_PREDEFINEDID: flatbuffers::VOffsetT = 8;
    pub const VT_PREDEFINEDSTYLE: flatbuffers::VOffsetT = 10;
    pub const VT_INITIALBANDRELIC: flatbuffers::VOffsetT = 12;
    pub const VT_INITIALRECRUITGROUP: flatbuffers::VOffsetT = 14;
    pub const VT_INITIALHP: flatbuffers::VOffsetT = 16;
    pub const VT_INITIALPOPULATION: flatbuffers::VOffsetT = 18;
    pub const VT_INITIALGOLD: flatbuffers::VOffsetT = 20;
    pub const VT_INITIALSQUADCAPACITY: flatbuffers::VOffsetT = 22;
    pub const VT_INITIALSHIELD: flatbuffers::VOffsetT = 24;
    pub const VT_INITIALMAXHP: flatbuffers::VOffsetT = 26;
    pub const VT_INITIALKEY: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameInitData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameInitDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameInitData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameInitDataBuilder::new(_fbb);
        builder.add_initialKey(args.initialKey);
        builder.add_initialMaxHp(args.initialMaxHp);
        builder.add_initialShield(args.initialShield);
        builder.add_initialSquadCapacity(args.initialSquadCapacity);
        builder.add_initialGold(args.initialGold);
        builder.add_initialPopulation(args.initialPopulation);
        builder.add_initialHp(args.initialHp);
        if let Some(x) = args.initialRecruitGroup {
            builder.add_initialRecruitGroup(x);
        }
        if let Some(x) = args.initialBandRelic {
            builder.add_initialBandRelic(x);
        }
        if let Some(x) = args.predefinedStyle {
            builder.add_predefinedStyle(x);
        }
        if let Some(x) = args.predefinedId {
            builder.add_predefinedId(x);
        }
        builder.add_modeGrade(args.modeGrade);
        builder.add_modeId(args.modeId);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameInitDataT {
        let modeId = self.modeId();
        let modeGrade = self.modeGrade();
        let predefinedId = self.predefinedId().map(|x| x.to_string());
        let predefinedStyle = self.predefinedStyle().map(|x| x.to_string());
        let initialBandRelic = self
            .initialBandRelic()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let initialRecruitGroup = self
            .initialRecruitGroup()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let initialHp = self.initialHp();
        let initialPopulation = self.initialPopulation();
        let initialGold = self.initialGold();
        let initialSquadCapacity = self.initialSquadCapacity();
        let initialShield = self.initialShield();
        let initialMaxHp = self.initialMaxHp();
        let initialKey = self.initialKey();
        clz_Torappu_RoguelikeGameInitDataT {
            modeId,
            modeGrade,
            predefinedId,
            predefinedStyle,
            initialBandRelic,
            initialRecruitGroup,
            initialHp,
            initialPopulation,
            initialGold,
            initialSquadCapacity,
            initialShield,
            initialMaxHp,
            initialKey,
        }
    }

    #[inline]
    pub fn modeId(&self) -> enum__Torappu_RoguelikeTopicMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTopicMode>(
                    clz_Torappu_RoguelikeGameInitData::VT_MODEID,
                    Some(enum__Torappu_RoguelikeTopicMode::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn modeGrade(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameInitData::VT_MODEGRADE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn predefinedId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameInitData::VT_PREDEFINEDID,
                None,
            )
        }
    }
    #[inline]
    pub fn predefinedStyle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameInitData::VT_PREDEFINEDSTYLE,
                None,
            )
        }
    }
    #[inline]
    pub fn initialBandRelic(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RoguelikeGameInitData::VT_INITIALBANDRELIC, None)
        }
    }
    #[inline]
    pub fn initialRecruitGroup(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RoguelikeGameInitData::VT_INITIALRECRUITGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn initialHp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameInitData::VT_INITIALHP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn initialPopulation(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeGameInitData::VT_INITIALPOPULATION,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn initialGold(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameInitData::VT_INITIALGOLD, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn initialSquadCapacity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeGameInitData::VT_INITIALSQUADCAPACITY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn initialShield(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameInitData::VT_INITIALSHIELD, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn initialMaxHp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameInitData::VT_INITIALMAXHP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn initialKey(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameInitData::VT_INITIALKEY, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameInitData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeTopicMode>("modeId", Self::VT_MODEID, false)?
            .visit_field::<i32>("modeGrade", Self::VT_MODEGRADE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "predefinedId",
                Self::VT_PREDEFINEDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "predefinedStyle",
                Self::VT_PREDEFINEDSTYLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("initialBandRelic", Self::VT_INITIALBANDRELIC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("initialRecruitGroup", Self::VT_INITIALRECRUITGROUP, false)?
            .visit_field::<i32>("initialHp", Self::VT_INITIALHP, false)?
            .visit_field::<i32>("initialPopulation", Self::VT_INITIALPOPULATION, false)?
            .visit_field::<i32>("initialGold", Self::VT_INITIALGOLD, false)?
            .visit_field::<i32>("initialSquadCapacity", Self::VT_INITIALSQUADCAPACITY, false)?
            .visit_field::<i32>("initialShield", Self::VT_INITIALSHIELD, false)?
            .visit_field::<i32>("initialMaxHp", Self::VT_INITIALMAXHP, false)?
            .visit_field::<i32>("initialKey", Self::VT_INITIALKEY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameInitDataArgs<'a> {
    pub modeId: enum__Torappu_RoguelikeTopicMode,
    pub modeGrade: i32,
    pub predefinedId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub predefinedStyle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub initialBandRelic: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub initialRecruitGroup: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub initialHp: i32,
    pub initialPopulation: i32,
    pub initialGold: i32,
    pub initialSquadCapacity: i32,
    pub initialShield: i32,
    pub initialMaxHp: i32,
    pub initialKey: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeGameInitDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameInitDataArgs {
            modeId: enum__Torappu_RoguelikeTopicMode::NONE,
            modeGrade: 0,
            predefinedId: None,
            predefinedStyle: None,
            initialBandRelic: None,
            initialRecruitGroup: None,
            initialHp: 0,
            initialPopulation: 0,
            initialGold: 0,
            initialSquadCapacity: 0,
            initialShield: 0,
            initialMaxHp: 0,
            initialKey: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameInitData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameInitData", 13)?;
        s.serialize_field("modeId", &self.modeId())?;
        s.serialize_field("modeGrade", &self.modeGrade())?;
        if let Some(f) = self.predefinedId() {
            s.serialize_field("predefinedId", &f)?;
        } else {
            s.skip_field("predefinedId")?;
        }
        if let Some(f) = self.predefinedStyle() {
            s.serialize_field("predefinedStyle", &f)?;
        } else {
            s.skip_field("predefinedStyle")?;
        }
        if let Some(f) = self.initialBandRelic() {
            s.serialize_field("initialBandRelic", &f)?;
        } else {
            s.skip_field("initialBandRelic")?;
        }
        if let Some(f) = self.initialRecruitGroup() {
            s.serialize_field("initialRecruitGroup", &f)?;
        } else {
            s.skip_field("initialRecruitGroup")?;
        }
        s.serialize_field("initialHp", &self.initialHp())?;
        s.serialize_field("initialPopulation", &self.initialPopulation())?;
        s.serialize_field("initialGold", &self.initialGold())?;
        s.serialize_field("initialSquadCapacity", &self.initialSquadCapacity())?;
        s.serialize_field("initialShield", &self.initialShield())?;
        s.serialize_field("initialMaxHp", &self.initialMaxHp())?;
        s.serialize_field("initialKey", &self.initialKey())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameInitDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameInitDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_modeId(&mut self, modeId: enum__Torappu_RoguelikeTopicMode) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeTopicMode>(
            clz_Torappu_RoguelikeGameInitData::VT_MODEID,
            modeId,
            enum__Torappu_RoguelikeTopicMode::NONE,
        );
    }
    #[inline]
    pub fn add_modeGrade(&mut self, modeGrade: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameInitData::VT_MODEGRADE,
            modeGrade,
            0,
        );
    }
    #[inline]
    pub fn add_predefinedId(&mut self, predefinedId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameInitData::VT_PREDEFINEDID,
            predefinedId,
        );
    }
    #[inline]
    pub fn add_predefinedStyle(&mut self, predefinedStyle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameInitData::VT_PREDEFINEDSTYLE,
            predefinedStyle,
        );
    }
    #[inline]
    pub fn add_initialBandRelic(
        &mut self,
        initialBandRelic: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameInitData::VT_INITIALBANDRELIC,
            initialBandRelic,
        );
    }
    #[inline]
    pub fn add_initialRecruitGroup(
        &mut self,
        initialRecruitGroup: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameInitData::VT_INITIALRECRUITGROUP,
            initialRecruitGroup,
        );
    }
    #[inline]
    pub fn add_initialHp(&mut self, initialHp: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameInitData::VT_INITIALHP,
            initialHp,
            0,
        );
    }
    #[inline]
    pub fn add_initialPopulation(&mut self, initialPopulation: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameInitData::VT_INITIALPOPULATION,
            initialPopulation,
            0,
        );
    }
    #[inline]
    pub fn add_initialGold(&mut self, initialGold: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameInitData::VT_INITIALGOLD,
            initialGold,
            0,
        );
    }
    #[inline]
    pub fn add_initialSquadCapacity(&mut self, initialSquadCapacity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameInitData::VT_INITIALSQUADCAPACITY,
            initialSquadCapacity,
            0,
        );
    }
    #[inline]
    pub fn add_initialShield(&mut self, initialShield: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameInitData::VT_INITIALSHIELD,
            initialShield,
            0,
        );
    }
    #[inline]
    pub fn add_initialMaxHp(&mut self, initialMaxHp: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameInitData::VT_INITIALMAXHP,
            initialMaxHp,
            0,
        );
    }
    #[inline]
    pub fn add_initialKey(&mut self, initialKey: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameInitData::VT_INITIALKEY,
            initialKey,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameInitDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameInitDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameInitData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameInitData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameInitData");
        ds.field("modeId", &self.modeId());
        ds.field("modeGrade", &self.modeGrade());
        ds.field("predefinedId", &self.predefinedId());
        ds.field("predefinedStyle", &self.predefinedStyle());
        ds.field("initialBandRelic", &self.initialBandRelic());
        ds.field("initialRecruitGroup", &self.initialRecruitGroup());
        ds.field("initialHp", &self.initialHp());
        ds.field("initialPopulation", &self.initialPopulation());
        ds.field("initialGold", &self.initialGold());
        ds.field("initialSquadCapacity", &self.initialSquadCapacity());
        ds.field("initialShield", &self.initialShield());
        ds.field("initialMaxHp", &self.initialMaxHp());
        ds.field("initialKey", &self.initialKey());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameInitDataT {
    pub modeId: enum__Torappu_RoguelikeTopicMode,
    pub modeGrade: i32,
    pub predefinedId: Option<String>,
    pub predefinedStyle: Option<String>,
    pub initialBandRelic: Option<Vec<String>>,
    pub initialRecruitGroup: Option<Vec<String>>,
    pub initialHp: i32,
    pub initialPopulation: i32,
    pub initialGold: i32,
    pub initialSquadCapacity: i32,
    pub initialShield: i32,
    pub initialMaxHp: i32,
    pub initialKey: i32,
}
impl Default for clz_Torappu_RoguelikeGameInitDataT {
    fn default() -> Self {
        Self {
            modeId: enum__Torappu_RoguelikeTopicMode::NONE,
            modeGrade: 0,
            predefinedId: None,
            predefinedStyle: None,
            initialBandRelic: None,
            initialRecruitGroup: None,
            initialHp: 0,
            initialPopulation: 0,
            initialGold: 0,
            initialSquadCapacity: 0,
            initialShield: 0,
            initialMaxHp: 0,
            initialKey: 0,
        }
    }
}
impl clz_Torappu_RoguelikeGameInitDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameInitData<'b>> {
        let modeId = self.modeId;
        let modeGrade = self.modeGrade;
        let predefinedId = self.predefinedId.as_ref().map(|x| _fbb.create_string(x));
        let predefinedStyle = self.predefinedStyle.as_ref().map(|x| _fbb.create_string(x));
        let initialBandRelic = self.initialBandRelic.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let initialRecruitGroup = self.initialRecruitGroup.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let initialHp = self.initialHp;
        let initialPopulation = self.initialPopulation;
        let initialGold = self.initialGold;
        let initialSquadCapacity = self.initialSquadCapacity;
        let initialShield = self.initialShield;
        let initialMaxHp = self.initialMaxHp;
        let initialKey = self.initialKey;
        clz_Torappu_RoguelikeGameInitData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameInitDataArgs {
                modeId,
                modeGrade,
                predefinedId,
                predefinedStyle,
                initialBandRelic,
                initialRecruitGroup,
                initialHp,
                initialPopulation,
                initialGold,
                initialSquadCapacity,
                initialShield,
                initialMaxHp,
                initialKey,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameStageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameStageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameStageData<'a> {
    type Inner = clz_Torappu_RoguelikeGameStageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameStageData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_LINKEDSTAGEID: flatbuffers::VOffsetT = 6;
    pub const VT_LEVELID: flatbuffers::VOffsetT = 8;
    pub const VT_LEVELREPLACEIDS: flatbuffers::VOffsetT = 10;
    pub const VT_CODE: flatbuffers::VOffsetT = 12;
    pub const VT_NAME: flatbuffers::VOffsetT = 14;
    pub const VT_LOADINGPICID: flatbuffers::VOffsetT = 16;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 18;
    pub const VT_ELITEDESC: flatbuffers::VOffsetT = 20;
    pub const VT_ISBOSS: flatbuffers::VOffsetT = 22;
    pub const VT_ISELITE: flatbuffers::VOffsetT = 24;
    pub const VT_DIFFICULTY: flatbuffers::VOffsetT = 26;
    pub const VT_CAPSULEPOOL: flatbuffers::VOffsetT = 28;
    pub const VT_CAPSULEPROB: flatbuffers::VOffsetT = 30;
    pub const VT_VUTRESPROB: flatbuffers::VOffsetT = 32;
    pub const VT_BOXPROB: flatbuffers::VOffsetT = 34;
    pub const VT_SPECIALNODEID: flatbuffers::VOffsetT = 36;
    pub const VT_REDCAPSULEPOOL: flatbuffers::VOffsetT = 38;
    pub const VT_REDCAPSULEPROB: flatbuffers::VOffsetT = 40;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameStageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameStageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameStageData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameStageDataBuilder::new(_fbb);
        builder.add_redCapsuleProb(args.redCapsuleProb);
        if let Some(x) = args.redCapsulePool {
            builder.add_redCapsulePool(x);
        }
        if let Some(x) = args.specialNodeId {
            builder.add_specialNodeId(x);
        }
        if let Some(x) = args.boxProb {
            builder.add_boxProb(x);
        }
        if let Some(x) = args.vutresProb {
            builder.add_vutresProb(x);
        }
        builder.add_capsuleProb(args.capsuleProb);
        if let Some(x) = args.capsulePool {
            builder.add_capsulePool(x);
        }
        builder.add_difficulty(args.difficulty);
        builder.add_isElite(args.isElite);
        builder.add_isBoss(args.isBoss);
        if let Some(x) = args.eliteDesc {
            builder.add_eliteDesc(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.loadingPicId {
            builder.add_loadingPicId(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.code {
            builder.add_code(x);
        }
        if let Some(x) = args.levelReplaceIds {
            builder.add_levelReplaceIds(x);
        }
        if let Some(x) = args.levelId {
            builder.add_levelId(x);
        }
        if let Some(x) = args.linkedStageId {
            builder.add_linkedStageId(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameStageDataT {
        let id = self.id().map(|x| x.to_string());
        let linkedStageId = self.linkedStageId().map(|x| x.to_string());
        let levelId = self.levelId().map(|x| x.to_string());
        let levelReplaceIds = self
            .levelReplaceIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let code = self.code().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let loadingPicId = self.loadingPicId().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let eliteDesc = self.eliteDesc().map(|x| x.to_string());
        let isBoss = self.isBoss();
        let isElite = self.isElite();
        let difficulty = self.difficulty();
        let capsulePool = self.capsulePool().map(|x| x.to_string());
        let capsuleProb = self.capsuleProb();
        let vutresProb = self.vutresProb().map(|x| x.into_iter().collect());
        let boxProb = self.boxProb().map(|x| x.into_iter().collect());
        let specialNodeId = self.specialNodeId().map(|x| x.to_string());
        let redCapsulePool = self.redCapsulePool().map(|x| x.to_string());
        let redCapsuleProb = self.redCapsuleProb();
        clz_Torappu_RoguelikeGameStageDataT {
            id,
            linkedStageId,
            levelId,
            levelReplaceIds,
            code,
            name,
            loadingPicId,
            description,
            eliteDesc,
            isBoss,
            isElite,
            difficulty,
            capsulePool,
            capsuleProb,
            vutresProb,
            boxProb,
            specialNodeId,
            redCapsulePool,
            redCapsuleProb,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameStageData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn linkedStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameStageData::VT_LINKEDSTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn levelId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameStageData::VT_LEVELID,
                None,
            )
        }
    }
    #[inline]
    pub fn levelReplaceIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RoguelikeGameStageData::VT_LEVELREPLACEIDS, None)
        }
    }
    #[inline]
    pub fn code(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameStageData::VT_CODE,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameStageData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn loadingPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameStageData::VT_LOADINGPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameStageData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn eliteDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameStageData::VT_ELITEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn isBoss(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameStageData::VT_ISBOSS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn isElite(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameStageData::VT_ISELITE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn difficulty(&self) -> enum__Torappu_LevelData_Difficulty {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_LevelData_Difficulty>(
                    clz_Torappu_RoguelikeGameStageData::VT_DIFFICULTY,
                    Some(enum__Torappu_LevelData_Difficulty::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn capsulePool(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameStageData::VT_CAPSULEPOOL,
                None,
            )
        }
    }
    #[inline]
    pub fn capsuleProb(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_RoguelikeGameStageData::VT_CAPSULEPROB,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn vutresProb(&self) -> Option<flatbuffers::Vector<'a, f64>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(
                    clz_Torappu_RoguelikeGameStageData::VT_VUTRESPROB,
                    None,
                )
        }
    }
    #[inline]
    pub fn boxProb(&self) -> Option<flatbuffers::Vector<'a, f64>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(
                    clz_Torappu_RoguelikeGameStageData::VT_BOXPROB,
                    None,
                )
        }
    }
    #[inline]
    pub fn specialNodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameStageData::VT_SPECIALNODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn redCapsulePool(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameStageData::VT_REDCAPSULEPOOL,
                None,
            )
        }
    }
    #[inline]
    pub fn redCapsuleProb(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_RoguelikeGameStageData::VT_REDCAPSULEPROB,
                    Some(0.0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameStageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "linkedStageId",
                Self::VT_LINKEDSTAGEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("levelId", Self::VT_LEVELID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("levelReplaceIds", Self::VT_LEVELREPLACEIDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("code", Self::VT_CODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "loadingPicId",
                Self::VT_LOADINGPICID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "eliteDesc",
                Self::VT_ELITEDESC,
                false,
            )?
            .visit_field::<i32>("isBoss", Self::VT_ISBOSS, false)?
            .visit_field::<i32>("isElite", Self::VT_ISELITE, false)?
            .visit_field::<enum__Torappu_LevelData_Difficulty>(
                "difficulty",
                Self::VT_DIFFICULTY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "capsulePool",
                Self::VT_CAPSULEPOOL,
                false,
            )?
            .visit_field::<f32>("capsuleProb", Self::VT_CAPSULEPROB, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(
                "vutresProb",
                Self::VT_VUTRESPROB,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(
                "boxProb",
                Self::VT_BOXPROB,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "specialNodeId",
                Self::VT_SPECIALNODEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "redCapsulePool",
                Self::VT_REDCAPSULEPOOL,
                false,
            )?
            .visit_field::<f32>("redCapsuleProb", Self::VT_REDCAPSULEPROB, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameStageDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub linkedStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub levelId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub levelReplaceIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub code: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub loadingPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eliteDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isBoss: i32,
    pub isElite: i32,
    pub difficulty: enum__Torappu_LevelData_Difficulty,
    pub capsulePool: Option<flatbuffers::WIPOffset<&'a str>>,
    pub capsuleProb: f32,
    pub vutresProb: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub boxProb: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub specialNodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub redCapsulePool: Option<flatbuffers::WIPOffset<&'a str>>,
    pub redCapsuleProb: f32,
}
impl<'a> Default for clz_Torappu_RoguelikeGameStageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameStageDataArgs {
            id: None,
            linkedStageId: None,
            levelId: None,
            levelReplaceIds: None,
            code: None,
            name: None,
            loadingPicId: None,
            description: None,
            eliteDesc: None,
            isBoss: 0,
            isElite: 0,
            difficulty: enum__Torappu_LevelData_Difficulty::NONE,
            capsulePool: None,
            capsuleProb: 0.0,
            vutresProb: None,
            boxProb: None,
            specialNodeId: None,
            redCapsulePool: None,
            redCapsuleProb: 0.0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameStageData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameStageData", 19)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.linkedStageId() {
            s.serialize_field("linkedStageId", &f)?;
        } else {
            s.skip_field("linkedStageId")?;
        }
        if let Some(f) = self.levelId() {
            s.serialize_field("levelId", &f)?;
        } else {
            s.skip_field("levelId")?;
        }
        if let Some(f) = self.levelReplaceIds() {
            s.serialize_field("levelReplaceIds", &f)?;
        } else {
            s.skip_field("levelReplaceIds")?;
        }
        if let Some(f) = self.code() {
            s.serialize_field("code", &f)?;
        } else {
            s.skip_field("code")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.loadingPicId() {
            s.serialize_field("loadingPicId", &f)?;
        } else {
            s.skip_field("loadingPicId")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.eliteDesc() {
            s.serialize_field("eliteDesc", &f)?;
        } else {
            s.skip_field("eliteDesc")?;
        }
        s.serialize_field("isBoss", &self.isBoss())?;
        s.serialize_field("isElite", &self.isElite())?;
        s.serialize_field("difficulty", &self.difficulty())?;
        if let Some(f) = self.capsulePool() {
            s.serialize_field("capsulePool", &f)?;
        } else {
            s.skip_field("capsulePool")?;
        }
        s.serialize_field("capsuleProb", &self.capsuleProb())?;
        if let Some(f) = self.vutresProb() {
            s.serialize_field("vutresProb", &f)?;
        } else {
            s.skip_field("vutresProb")?;
        }
        if let Some(f) = self.boxProb() {
            s.serialize_field("boxProb", &f)?;
        } else {
            s.skip_field("boxProb")?;
        }
        if let Some(f) = self.specialNodeId() {
            s.serialize_field("specialNodeId", &f)?;
        } else {
            s.skip_field("specialNodeId")?;
        }
        if let Some(f) = self.redCapsulePool() {
            s.serialize_field("redCapsulePool", &f)?;
        } else {
            s.skip_field("redCapsulePool")?;
        }
        s.serialize_field("redCapsuleProb", &self.redCapsuleProb())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameStageDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameStageDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStageData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_linkedStageId(&mut self, linkedStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStageData::VT_LINKEDSTAGEID,
            linkedStageId,
        );
    }
    #[inline]
    pub fn add_levelId(&mut self, levelId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStageData::VT_LEVELID,
            levelId,
        );
    }
    #[inline]
    pub fn add_levelReplaceIds(
        &mut self,
        levelReplaceIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStageData::VT_LEVELREPLACEIDS,
            levelReplaceIds,
        );
    }
    #[inline]
    pub fn add_code(&mut self, code: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStageData::VT_CODE,
            code,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStageData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_loadingPicId(&mut self, loadingPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStageData::VT_LOADINGPICID,
            loadingPicId,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStageData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_eliteDesc(&mut self, eliteDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStageData::VT_ELITEDESC,
            eliteDesc,
        );
    }
    #[inline]
    pub fn add_isBoss(&mut self, isBoss: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeGameStageData::VT_ISBOSS, isBoss, 0);
    }
    #[inline]
    pub fn add_isElite(&mut self, isElite: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeGameStageData::VT_ISELITE, isElite, 0);
    }
    #[inline]
    pub fn add_difficulty(&mut self, difficulty: enum__Torappu_LevelData_Difficulty) {
        self.fbb_.push_slot::<enum__Torappu_LevelData_Difficulty>(
            clz_Torappu_RoguelikeGameStageData::VT_DIFFICULTY,
            difficulty,
            enum__Torappu_LevelData_Difficulty::NONE,
        );
    }
    #[inline]
    pub fn add_capsulePool(&mut self, capsulePool: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStageData::VT_CAPSULEPOOL,
            capsulePool,
        );
    }
    #[inline]
    pub fn add_capsuleProb(&mut self, capsuleProb: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_RoguelikeGameStageData::VT_CAPSULEPROB,
            capsuleProb,
            0.0,
        );
    }
    #[inline]
    pub fn add_vutresProb(
        &mut self,
        vutresProb: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f64>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStageData::VT_VUTRESPROB,
            vutresProb,
        );
    }
    #[inline]
    pub fn add_boxProb(&mut self, boxProb: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f64>>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStageData::VT_BOXPROB,
            boxProb,
        );
    }
    #[inline]
    pub fn add_specialNodeId(&mut self, specialNodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStageData::VT_SPECIALNODEID,
            specialNodeId,
        );
    }
    #[inline]
    pub fn add_redCapsulePool(&mut self, redCapsulePool: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStageData::VT_REDCAPSULEPOOL,
            redCapsulePool,
        );
    }
    #[inline]
    pub fn add_redCapsuleProb(&mut self, redCapsuleProb: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_RoguelikeGameStageData::VT_REDCAPSULEPROB,
            redCapsuleProb,
            0.0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameStageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameStageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameStageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameStageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameStageData");
        ds.field("id", &self.id());
        ds.field("linkedStageId", &self.linkedStageId());
        ds.field("levelId", &self.levelId());
        ds.field("levelReplaceIds", &self.levelReplaceIds());
        ds.field("code", &self.code());
        ds.field("name", &self.name());
        ds.field("loadingPicId", &self.loadingPicId());
        ds.field("description", &self.description());
        ds.field("eliteDesc", &self.eliteDesc());
        ds.field("isBoss", &self.isBoss());
        ds.field("isElite", &self.isElite());
        ds.field("difficulty", &self.difficulty());
        ds.field("capsulePool", &self.capsulePool());
        ds.field("capsuleProb", &self.capsuleProb());
        ds.field("vutresProb", &self.vutresProb());
        ds.field("boxProb", &self.boxProb());
        ds.field("specialNodeId", &self.specialNodeId());
        ds.field("redCapsulePool", &self.redCapsulePool());
        ds.field("redCapsuleProb", &self.redCapsuleProb());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameStageDataT {
    pub id: Option<String>,
    pub linkedStageId: Option<String>,
    pub levelId: Option<String>,
    pub levelReplaceIds: Option<Vec<String>>,
    pub code: Option<String>,
    pub name: Option<String>,
    pub loadingPicId: Option<String>,
    pub description: Option<String>,
    pub eliteDesc: Option<String>,
    pub isBoss: i32,
    pub isElite: i32,
    pub difficulty: enum__Torappu_LevelData_Difficulty,
    pub capsulePool: Option<String>,
    pub capsuleProb: f32,
    pub vutresProb: Option<Vec<f64>>,
    pub boxProb: Option<Vec<f64>>,
    pub specialNodeId: Option<String>,
    pub redCapsulePool: Option<String>,
    pub redCapsuleProb: f32,
}
impl Default for clz_Torappu_RoguelikeGameStageDataT {
    fn default() -> Self {
        Self {
            id: None,
            linkedStageId: None,
            levelId: None,
            levelReplaceIds: None,
            code: None,
            name: None,
            loadingPicId: None,
            description: None,
            eliteDesc: None,
            isBoss: 0,
            isElite: 0,
            difficulty: enum__Torappu_LevelData_Difficulty::NONE,
            capsulePool: None,
            capsuleProb: 0.0,
            vutresProb: None,
            boxProb: None,
            specialNodeId: None,
            redCapsulePool: None,
            redCapsuleProb: 0.0,
        }
    }
}
impl clz_Torappu_RoguelikeGameStageDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameStageData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let linkedStageId = self.linkedStageId.as_ref().map(|x| _fbb.create_string(x));
        let levelId = self.levelId.as_ref().map(|x| _fbb.create_string(x));
        let levelReplaceIds = self.levelReplaceIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let code = self.code.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let loadingPicId = self.loadingPicId.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let eliteDesc = self.eliteDesc.as_ref().map(|x| _fbb.create_string(x));
        let isBoss = self.isBoss;
        let isElite = self.isElite;
        let difficulty = self.difficulty;
        let capsulePool = self.capsulePool.as_ref().map(|x| _fbb.create_string(x));
        let capsuleProb = self.capsuleProb;
        let vutresProb = self.vutresProb.as_ref().map(|x| _fbb.create_vector(x));
        let boxProb = self.boxProb.as_ref().map(|x| _fbb.create_vector(x));
        let specialNodeId = self.specialNodeId.as_ref().map(|x| _fbb.create_string(x));
        let redCapsulePool = self.redCapsulePool.as_ref().map(|x| _fbb.create_string(x));
        let redCapsuleProb = self.redCapsuleProb;
        clz_Torappu_RoguelikeGameStageData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameStageDataArgs {
                id,
                linkedStageId,
                levelId,
                levelReplaceIds,
                code,
                name,
                loadingPicId,
                description,
                eliteDesc,
                isBoss,
                isElite,
                difficulty,
                capsulePool,
                capsuleProb,
                vutresProb,
                boxProb,
                specialNodeId,
                redCapsulePool,
                redCapsuleProb,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameStageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameStageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameStageData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameStageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameStageData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameStageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameStageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameStageData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameStageDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameStageDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameStageDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameStageData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameStageData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameStageData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameStageData>>(
                    dict__string__clz_Torappu_RoguelikeGameStageData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameStageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameStageData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameStageDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameStageData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameStageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameStageDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameStageData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeGameStageData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameStageDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameStageDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameStageData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameStageData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameStageData>>(
                dict__string__clz_Torappu_RoguelikeGameStageData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameStageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameStageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameStageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameStageData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameStageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameStageData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameStageDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameStageDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameStageDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameStageDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameStageData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameStageData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameStageDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameZoneData<'a> {
    type Inner = clz_Torappu_RoguelikeGameZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameZoneData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_CLOCKPERFORMANCE: flatbuffers::VOffsetT = 8;
    pub const VT_DISPLAYTIME: flatbuffers::VOffsetT = 10;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 12;
    pub const VT_BUFFDESCRIPTION: flatbuffers::VOffsetT = 14;
    pub const VT_ENDINGDESCRIPTION: flatbuffers::VOffsetT = 16;
    pub const VT_BACKGROUNDID: flatbuffers::VOffsetT = 18;
    pub const VT_ZONEICONID: flatbuffers::VOffsetT = 20;
    pub const VT_ISHIDDENZONE: flatbuffers::VOffsetT = 22;
    pub const VT_BGMSIGNAL: flatbuffers::VOffsetT = 24;
    pub const VT_BGMSIGNALWITHLOWSAN: flatbuffers::VOffsetT = 26;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameZoneData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameZoneDataBuilder::new(_fbb);
        if let Some(x) = args.bgmSignalWithLowSan {
            builder.add_bgmSignalWithLowSan(x);
        }
        if let Some(x) = args.bgmSignal {
            builder.add_bgmSignal(x);
        }
        if let Some(x) = args.zoneIconId {
            builder.add_zoneIconId(x);
        }
        if let Some(x) = args.backgroundId {
            builder.add_backgroundId(x);
        }
        if let Some(x) = args.endingDescription {
            builder.add_endingDescription(x);
        }
        if let Some(x) = args.buffDescription {
            builder.add_buffDescription(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.displayTime {
            builder.add_displayTime(x);
        }
        if let Some(x) = args.clockPerformance {
            builder.add_clockPerformance(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_isHiddenZone(args.isHiddenZone);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameZoneDataT {
        let id = self.id().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let clockPerformance = self.clockPerformance().map(|x| x.to_string());
        let displayTime = self.displayTime().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let buffDescription = self.buffDescription().map(|x| x.to_string());
        let endingDescription = self.endingDescription().map(|x| x.to_string());
        let backgroundId = self.backgroundId().map(|x| x.to_string());
        let zoneIconId = self.zoneIconId().map(|x| x.to_string());
        let isHiddenZone = self.isHiddenZone();
        let bgmSignal = self.bgmSignal().map(|x| x.to_string());
        let bgmSignalWithLowSan = self.bgmSignalWithLowSan().map(|x| x.to_string());
        clz_Torappu_RoguelikeGameZoneDataT {
            id,
            name,
            clockPerformance,
            displayTime,
            description,
            buffDescription,
            endingDescription,
            backgroundId,
            zoneIconId,
            isHiddenZone,
            bgmSignal,
            bgmSignalWithLowSan,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameZoneData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameZoneData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn clockPerformance(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameZoneData::VT_CLOCKPERFORMANCE,
                None,
            )
        }
    }
    #[inline]
    pub fn displayTime(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameZoneData::VT_DISPLAYTIME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameZoneData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn buffDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameZoneData::VT_BUFFDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn endingDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameZoneData::VT_ENDINGDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn backgroundId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameZoneData::VT_BACKGROUNDID,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameZoneData::VT_ZONEICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn isHiddenZone(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeGameZoneData::VT_ISHIDDENZONE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn bgmSignal(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameZoneData::VT_BGMSIGNAL,
                None,
            )
        }
    }
    #[inline]
    pub fn bgmSignalWithLowSan(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameZoneData::VT_BGMSIGNALWITHLOWSAN,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "clockPerformance",
                Self::VT_CLOCKPERFORMANCE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "displayTime",
                Self::VT_DISPLAYTIME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffDescription",
                Self::VT_BUFFDESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "endingDescription",
                Self::VT_ENDINGDESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "backgroundId",
                Self::VT_BACKGROUNDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "zoneIconId",
                Self::VT_ZONEICONID,
                false,
            )?
            .visit_field::<bool>("isHiddenZone", Self::VT_ISHIDDENZONE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bgmSignal",
                Self::VT_BGMSIGNAL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bgmSignalWithLowSan",
                Self::VT_BGMSIGNALWITHLOWSAN,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameZoneDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub clockPerformance: Option<flatbuffers::WIPOffset<&'a str>>,
    pub displayTime: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endingDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub backgroundId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isHiddenZone: bool,
    pub bgmSignal: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bgmSignalWithLowSan: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeGameZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameZoneDataArgs {
            id: None,
            name: None,
            clockPerformance: None,
            displayTime: None,
            description: None,
            buffDescription: None,
            endingDescription: None,
            backgroundId: None,
            zoneIconId: None,
            isHiddenZone: false,
            bgmSignal: None,
            bgmSignalWithLowSan: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameZoneData", 12)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.clockPerformance() {
            s.serialize_field("clockPerformance", &f)?;
        } else {
            s.skip_field("clockPerformance")?;
        }
        if let Some(f) = self.displayTime() {
            s.serialize_field("displayTime", &f)?;
        } else {
            s.skip_field("displayTime")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.buffDescription() {
            s.serialize_field("buffDescription", &f)?;
        } else {
            s.skip_field("buffDescription")?;
        }
        if let Some(f) = self.endingDescription() {
            s.serialize_field("endingDescription", &f)?;
        } else {
            s.skip_field("endingDescription")?;
        }
        if let Some(f) = self.backgroundId() {
            s.serialize_field("backgroundId", &f)?;
        } else {
            s.skip_field("backgroundId")?;
        }
        if let Some(f) = self.zoneIconId() {
            s.serialize_field("zoneIconId", &f)?;
        } else {
            s.skip_field("zoneIconId")?;
        }
        s.serialize_field("isHiddenZone", &self.isHiddenZone())?;
        if let Some(f) = self.bgmSignal() {
            s.serialize_field("bgmSignal", &f)?;
        } else {
            s.skip_field("bgmSignal")?;
        }
        if let Some(f) = self.bgmSignalWithLowSan() {
            s.serialize_field("bgmSignalWithLowSan", &f)?;
        } else {
            s.skip_field("bgmSignalWithLowSan")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameZoneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameZoneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameZoneData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameZoneData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_clockPerformance(&mut self, clockPerformance: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameZoneData::VT_CLOCKPERFORMANCE,
            clockPerformance,
        );
    }
    #[inline]
    pub fn add_displayTime(&mut self, displayTime: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameZoneData::VT_DISPLAYTIME,
            displayTime,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameZoneData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_buffDescription(&mut self, buffDescription: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameZoneData::VT_BUFFDESCRIPTION,
            buffDescription,
        );
    }
    #[inline]
    pub fn add_endingDescription(&mut self, endingDescription: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameZoneData::VT_ENDINGDESCRIPTION,
            endingDescription,
        );
    }
    #[inline]
    pub fn add_backgroundId(&mut self, backgroundId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameZoneData::VT_BACKGROUNDID,
            backgroundId,
        );
    }
    #[inline]
    pub fn add_zoneIconId(&mut self, zoneIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameZoneData::VT_ZONEICONID,
            zoneIconId,
        );
    }
    #[inline]
    pub fn add_isHiddenZone(&mut self, isHiddenZone: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeGameZoneData::VT_ISHIDDENZONE,
            isHiddenZone,
            false,
        );
    }
    #[inline]
    pub fn add_bgmSignal(&mut self, bgmSignal: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameZoneData::VT_BGMSIGNAL,
            bgmSignal,
        );
    }
    #[inline]
    pub fn add_bgmSignalWithLowSan(
        &mut self,
        bgmSignalWithLowSan: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameZoneData::VT_BGMSIGNALWITHLOWSAN,
            bgmSignalWithLowSan,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameZoneData");
        ds.field("id", &self.id());
        ds.field("name", &self.name());
        ds.field("clockPerformance", &self.clockPerformance());
        ds.field("displayTime", &self.displayTime());
        ds.field("description", &self.description());
        ds.field("buffDescription", &self.buffDescription());
        ds.field("endingDescription", &self.endingDescription());
        ds.field("backgroundId", &self.backgroundId());
        ds.field("zoneIconId", &self.zoneIconId());
        ds.field("isHiddenZone", &self.isHiddenZone());
        ds.field("bgmSignal", &self.bgmSignal());
        ds.field("bgmSignalWithLowSan", &self.bgmSignalWithLowSan());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameZoneDataT {
    pub id: Option<String>,
    pub name: Option<String>,
    pub clockPerformance: Option<String>,
    pub displayTime: Option<String>,
    pub description: Option<String>,
    pub buffDescription: Option<String>,
    pub endingDescription: Option<String>,
    pub backgroundId: Option<String>,
    pub zoneIconId: Option<String>,
    pub isHiddenZone: bool,
    pub bgmSignal: Option<String>,
    pub bgmSignalWithLowSan: Option<String>,
}
impl Default for clz_Torappu_RoguelikeGameZoneDataT {
    fn default() -> Self {
        Self {
            id: None,
            name: None,
            clockPerformance: None,
            displayTime: None,
            description: None,
            buffDescription: None,
            endingDescription: None,
            backgroundId: None,
            zoneIconId: None,
            isHiddenZone: false,
            bgmSignal: None,
            bgmSignalWithLowSan: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameZoneData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let clockPerformance = self
            .clockPerformance
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let displayTime = self.displayTime.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let buffDescription = self.buffDescription.as_ref().map(|x| _fbb.create_string(x));
        let endingDescription = self
            .endingDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let backgroundId = self.backgroundId.as_ref().map(|x| _fbb.create_string(x));
        let zoneIconId = self.zoneIconId.as_ref().map(|x| _fbb.create_string(x));
        let isHiddenZone = self.isHiddenZone;
        let bgmSignal = self.bgmSignal.as_ref().map(|x| _fbb.create_string(x));
        let bgmSignalWithLowSan = self
            .bgmSignalWithLowSan
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeGameZoneData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameZoneDataArgs {
                id,
                name,
                clockPerformance,
                displayTime,
                description,
                buffDescription,
                endingDescription,
                backgroundId,
                zoneIconId,
                isHiddenZone,
                bgmSignal,
                bgmSignalWithLowSan,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameZoneData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameZoneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameZoneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameZoneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameZoneDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameZoneDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameZoneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameZoneData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameZoneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameZoneData>>(
                    dict__string__clz_Torappu_RoguelikeGameZoneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameZoneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameZoneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameZoneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameZoneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeGameZoneData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameZoneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameZoneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameZoneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameZoneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameZoneData>>(
                dict__string__clz_Torappu_RoguelikeGameZoneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameZoneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameZoneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameZoneDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameZoneDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameZoneDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameZoneData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameZoneData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameZoneDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeZoneVariationDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeZoneVariationData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeZoneVariationData<'a> {
    type Inner = clz_Torappu_RoguelikeZoneVariationData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeZoneVariationData<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeZoneVariationData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        _args: &'args clz_Torappu_RoguelikeZoneVariationDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeZoneVariationData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeZoneVariationDataBuilder::new(_fbb);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeZoneVariationDataT {
        clz_Torappu_RoguelikeZoneVariationDataT {}
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeZoneVariationData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeZoneVariationDataArgs {}
impl<'a> Default for clz_Torappu_RoguelikeZoneVariationDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeZoneVariationDataArgs {}
    }
}

impl Serialize for clz_Torappu_RoguelikeZoneVariationData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let s = serializer.serialize_struct("clz_Torappu_RoguelikeZoneVariationData", 0)?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeZoneVariationDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeZoneVariationDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeZoneVariationDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeZoneVariationDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeZoneVariationData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeZoneVariationData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeZoneVariationData");
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeZoneVariationDataT {}
impl Default for clz_Torappu_RoguelikeZoneVariationDataT {
    fn default() -> Self {
        Self {}
    }
}
impl clz_Torappu_RoguelikeZoneVariationDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeZoneVariationData<'b>> {
        clz_Torappu_RoguelikeZoneVariationData::create(
            _fbb,
            &clz_Torappu_RoguelikeZoneVariationDataArgs {},
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeZoneVariationDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeZoneVariationData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeZoneVariationData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeZoneVariationData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeZoneVariationData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeZoneVariationData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeZoneVariationDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeZoneVariationData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeZoneVariationDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeZoneVariationDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeZoneVariationDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeZoneVariationData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeZoneVariationData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeZoneVariationData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeZoneVariationData>>(
                    dict__string__clz_Torappu_RoguelikeZoneVariationData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeZoneVariationData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeZoneVariationData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeZoneVariationDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeZoneVariationData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeZoneVariationDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeZoneVariationDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeZoneVariationData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeZoneVariationData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeZoneVariationDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeZoneVariationDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeZoneVariationData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeZoneVariationData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeZoneVariationData>>(
                dict__string__clz_Torappu_RoguelikeZoneVariationData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeZoneVariationDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeZoneVariationDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeZoneVariationData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeZoneVariationData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeZoneVariationData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeZoneVariationData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeZoneVariationDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeZoneVariationDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeZoneVariationDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeZoneVariationDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeZoneVariationData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeZoneVariationData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeZoneVariationDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameTrapDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameTrapData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameTrapData<'a> {
    type Inner = clz_Torappu_RoguelikeGameTrapData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameTrapData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_TRAPID: flatbuffers::VOffsetT = 6;
    pub const VT_TRAPDESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameTrapData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameTrapDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameTrapData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameTrapDataBuilder::new(_fbb);
        if let Some(x) = args.trapDesc {
            builder.add_trapDesc(x);
        }
        if let Some(x) = args.trapId {
            builder.add_trapId(x);
        }
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameTrapDataT {
        let itemId = self.itemId().map(|x| x.to_string());
        let trapId = self.trapId().map(|x| x.to_string());
        let trapDesc = self.trapDesc().map(|x| x.to_string());
        clz_Torappu_RoguelikeGameTrapDataT {
            itemId,
            trapId,
            trapDesc,
        }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameTrapData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn trapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameTrapData::VT_TRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn trapDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameTrapData::VT_TRAPDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameTrapData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trapId", Self::VT_TRAPID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "trapDesc",
                Self::VT_TRAPDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameTrapDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeGameTrapDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameTrapDataArgs {
            itemId: None,
            trapId: None,
            trapDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameTrapData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameTrapData", 3)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        if let Some(f) = self.trapId() {
            s.serialize_field("trapId", &f)?;
        } else {
            s.skip_field("trapId")?;
        }
        if let Some(f) = self.trapDesc() {
            s.serialize_field("trapDesc", &f)?;
        } else {
            s.skip_field("trapDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameTrapDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameTrapDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameTrapData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_trapId(&mut self, trapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameTrapData::VT_TRAPID,
            trapId,
        );
    }
    #[inline]
    pub fn add_trapDesc(&mut self, trapDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameTrapData::VT_TRAPDESC,
            trapDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameTrapDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameTrapDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameTrapData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameTrapData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameTrapData");
        ds.field("itemId", &self.itemId());
        ds.field("trapId", &self.trapId());
        ds.field("trapDesc", &self.trapDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameTrapDataT {
    pub itemId: Option<String>,
    pub trapId: Option<String>,
    pub trapDesc: Option<String>,
}
impl Default for clz_Torappu_RoguelikeGameTrapDataT {
    fn default() -> Self {
        Self {
            itemId: None,
            trapId: None,
            trapDesc: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameTrapDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameTrapData<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let trapId = self.trapId.as_ref().map(|x| _fbb.create_string(x));
        let trapDesc = self.trapDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeGameTrapData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameTrapDataArgs {
                itemId,
                trapId,
                trapDesc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameTrapDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameTrapData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameTrapData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameTrapData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameTrapData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameTrapData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameTrapDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameTrapData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameTrapDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameTrapDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameTrapDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameTrapData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameTrapData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameTrapData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameTrapData>>(
                    dict__string__clz_Torappu_RoguelikeGameTrapData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameTrapData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameTrapData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameTrapDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameTrapData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameTrapDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameTrapDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameTrapData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeGameTrapData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameTrapDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameTrapDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameTrapData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameTrapData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameTrapData>>(
                dict__string__clz_Torappu_RoguelikeGameTrapData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameTrapDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameTrapDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameTrapData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameTrapData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameTrapData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameTrapData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameTrapDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameTrapDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameTrapDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameTrapDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameTrapData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameTrapData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameTrapDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameRecruitTicketDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameRecruitTicketData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameRecruitTicketData<'a> {
    type Inner = clz_Torappu_RoguelikeGameRecruitTicketData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameRecruitTicketData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_PROFESSION: flatbuffers::VOffsetT = 6;
    pub const VT_RARITY: flatbuffers::VOffsetT = 8;
    pub const VT_PROFESSIONLIST: flatbuffers::VOffsetT = 10;
    pub const VT_RARITYLIST: flatbuffers::VOffsetT = 12;
    pub const VT_EXTRAELITENUM: flatbuffers::VOffsetT = 14;
    pub const VT_EXTRAFREERARITY: flatbuffers::VOffsetT = 16;
    pub const VT_EXTRACHARIDS: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameRecruitTicketData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameRecruitTicketDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRecruitTicketData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameRecruitTicketDataBuilder::new(_fbb);
        if let Some(x) = args.extraCharIds {
            builder.add_extraCharIds(x);
        }
        if let Some(x) = args.extraFreeRarity {
            builder.add_extraFreeRarity(x);
        }
        builder.add_extraEliteNum(args.extraEliteNum);
        if let Some(x) = args.rarityList {
            builder.add_rarityList(x);
        }
        if let Some(x) = args.professionList {
            builder.add_professionList(x);
        }
        builder.add_rarity(args.rarity);
        builder.add_profession(args.profession);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameRecruitTicketDataT {
        let id = self.id().map(|x| x.to_string());
        let profession = self.profession();
        let rarity = self.rarity();
        let professionList = self.professionList().map(|x| x.into_iter().collect());
        let rarityList = self.rarityList().map(|x| x.into_iter().collect());
        let extraEliteNum = self.extraEliteNum();
        let extraFreeRarity = self.extraFreeRarity().map(|x| x.into_iter().collect());
        let extraCharIds = self
            .extraCharIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_RoguelikeGameRecruitTicketDataT {
            id,
            profession,
            rarity,
            professionList,
            rarityList,
            extraEliteNum,
            extraFreeRarity,
            extraCharIds,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameRecruitTicketData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn profession(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_RoguelikeGameRecruitTicketData::VT_PROFESSION,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rarity(&self) -> enum__Torappu_RarityRankMask {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RarityRankMask>(
                    clz_Torappu_RoguelikeGameRecruitTicketData::VT_RARITY,
                    Some(enum__Torappu_RarityRankMask::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn professionList(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_ProfessionID>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_ProfessionID>,
            >>(
                clz_Torappu_RoguelikeGameRecruitTicketData::VT_PROFESSIONLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn rarityList(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_RarityRank>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, enum__Torappu_RarityRank>>>(clz_Torappu_RoguelikeGameRecruitTicketData::VT_RARITYLIST, None)
        }
    }
    #[inline]
    pub fn extraEliteNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeGameRecruitTicketData::VT_EXTRAELITENUM,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn extraFreeRarity(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_RarityRank>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, enum__Torappu_RarityRank>>>(clz_Torappu_RoguelikeGameRecruitTicketData::VT_EXTRAFREERARITY, None)
        }
    }
    #[inline]
    pub fn extraCharIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RoguelikeGameRecruitTicketData::VT_EXTRACHARIDS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameRecruitTicketData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<enum__Torappu_ProfessionCategory>("profession", Self::VT_PROFESSION, false)?
     .visit_field::<enum__Torappu_RarityRankMask>("rarity", Self::VT_RARITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_ProfessionID>>>("professionList", Self::VT_PROFESSIONLIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_RarityRank>>>("rarityList", Self::VT_RARITYLIST, false)?
     .visit_field::<i32>("extraEliteNum", Self::VT_EXTRAELITENUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_RarityRank>>>("extraFreeRarity", Self::VT_EXTRAFREERARITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("extraCharIds", Self::VT_EXTRACHARIDS, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameRecruitTicketDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub profession: enum__Torappu_ProfessionCategory,
    pub rarity: enum__Torappu_RarityRankMask,
    pub professionList:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_ProfessionID>>>,
    pub rarityList:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_RarityRank>>>,
    pub extraEliteNum: i32,
    pub extraFreeRarity:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_RarityRank>>>,
    pub extraCharIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeGameRecruitTicketDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameRecruitTicketDataArgs {
            id: None,
            profession: enum__Torappu_ProfessionCategory::NONE,
            rarity: enum__Torappu_RarityRankMask::NONE,
            professionList: None,
            rarityList: None,
            extraEliteNum: 0,
            extraFreeRarity: None,
            extraCharIds: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameRecruitTicketData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameRecruitTicketData", 8)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("profession", &self.profession())?;
        s.serialize_field("rarity", &self.rarity())?;
        if let Some(f) = self.professionList() {
            s.serialize_field("professionList", &f)?;
        } else {
            s.skip_field("professionList")?;
        }
        if let Some(f) = self.rarityList() {
            s.serialize_field("rarityList", &f)?;
        } else {
            s.skip_field("rarityList")?;
        }
        s.serialize_field("extraEliteNum", &self.extraEliteNum())?;
        if let Some(f) = self.extraFreeRarity() {
            s.serialize_field("extraFreeRarity", &f)?;
        } else {
            s.skip_field("extraFreeRarity")?;
        }
        if let Some(f) = self.extraCharIds() {
            s.serialize_field("extraCharIds", &f)?;
        } else {
            s.skip_field("extraCharIds")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameRecruitTicketDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameRecruitTicketDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRecruitTicketData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_profession(&mut self, profession: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_RoguelikeGameRecruitTicketData::VT_PROFESSION,
            profession,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_rarity(&mut self, rarity: enum__Torappu_RarityRankMask) {
        self.fbb_.push_slot::<enum__Torappu_RarityRankMask>(
            clz_Torappu_RoguelikeGameRecruitTicketData::VT_RARITY,
            rarity,
            enum__Torappu_RarityRankMask::NONE,
        );
    }
    #[inline]
    pub fn add_professionList(
        &mut self,
        professionList: flatbuffers::WIPOffset<flatbuffers::Vector<'b, enum__Torappu_ProfessionID>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRecruitTicketData::VT_PROFESSIONLIST,
            professionList,
        );
    }
    #[inline]
    pub fn add_rarityList(
        &mut self,
        rarityList: flatbuffers::WIPOffset<flatbuffers::Vector<'b, enum__Torappu_RarityRank>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRecruitTicketData::VT_RARITYLIST,
            rarityList,
        );
    }
    #[inline]
    pub fn add_extraEliteNum(&mut self, extraEliteNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameRecruitTicketData::VT_EXTRAELITENUM,
            extraEliteNum,
            0,
        );
    }
    #[inline]
    pub fn add_extraFreeRarity(
        &mut self,
        extraFreeRarity: flatbuffers::WIPOffset<flatbuffers::Vector<'b, enum__Torappu_RarityRank>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRecruitTicketData::VT_EXTRAFREERARITY,
            extraFreeRarity,
        );
    }
    #[inline]
    pub fn add_extraCharIds(
        &mut self,
        extraCharIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRecruitTicketData::VT_EXTRACHARIDS,
            extraCharIds,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameRecruitTicketDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameRecruitTicketDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRecruitTicketData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameRecruitTicketData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameRecruitTicketData");
        ds.field("id", &self.id());
        ds.field("profession", &self.profession());
        ds.field("rarity", &self.rarity());
        ds.field("professionList", &self.professionList());
        ds.field("rarityList", &self.rarityList());
        ds.field("extraEliteNum", &self.extraEliteNum());
        ds.field("extraFreeRarity", &self.extraFreeRarity());
        ds.field("extraCharIds", &self.extraCharIds());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameRecruitTicketDataT {
    pub id: Option<String>,
    pub profession: enum__Torappu_ProfessionCategory,
    pub rarity: enum__Torappu_RarityRankMask,
    pub professionList: Option<Vec<enum__Torappu_ProfessionID>>,
    pub rarityList: Option<Vec<enum__Torappu_RarityRank>>,
    pub extraEliteNum: i32,
    pub extraFreeRarity: Option<Vec<enum__Torappu_RarityRank>>,
    pub extraCharIds: Option<Vec<String>>,
}
impl Default for clz_Torappu_RoguelikeGameRecruitTicketDataT {
    fn default() -> Self {
        Self {
            id: None,
            profession: enum__Torappu_ProfessionCategory::NONE,
            rarity: enum__Torappu_RarityRankMask::NONE,
            professionList: None,
            rarityList: None,
            extraEliteNum: 0,
            extraFreeRarity: None,
            extraCharIds: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameRecruitTicketDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRecruitTicketData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let profession = self.profession;
        let rarity = self.rarity;
        let professionList = self.professionList.as_ref().map(|x| _fbb.create_vector(x));
        let rarityList = self.rarityList.as_ref().map(|x| _fbb.create_vector(x));
        let extraEliteNum = self.extraEliteNum;
        let extraFreeRarity = self.extraFreeRarity.as_ref().map(|x| _fbb.create_vector(x));
        let extraCharIds = self.extraCharIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeGameRecruitTicketData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameRecruitTicketDataArgs {
                id,
                profession,
                rarity,
                professionList,
                rarityList,
                extraEliteNum,
                extraFreeRarity,
                extraCharIds,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameRecruitTicketData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameRecruitTicketData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameRecruitTicketData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameRecruitTicketData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameRecruitTicketData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameRecruitTicketData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameRecruitTicketData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameRecruitTicketData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameRecruitTicketData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameRecruitTicketData>>(
                    dict__string__clz_Torappu_RoguelikeGameRecruitTicketData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameRecruitTicketData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameRecruitTicketData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRecruitTicketData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameRecruitTicketData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_RoguelikeGameRecruitTicketData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameRecruitTicketData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRecruitTicketData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRecruitTicketData>>(
                dict__string__clz_Torappu_RoguelikeGameRecruitTicketData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameRecruitTicketData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameRecruitTicketData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameRecruitTicketData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameRecruitTicketData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameRecruitTicketDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameRecruitTicketData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameRecruitTicketData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameUpgradeTicketDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameUpgradeTicketData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameUpgradeTicketData<'a> {
    type Inner = clz_Torappu_RoguelikeGameUpgradeTicketData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameUpgradeTicketData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_PROFESSION: flatbuffers::VOffsetT = 6;
    pub const VT_RARITY: flatbuffers::VOffsetT = 8;
    pub const VT_PROFESSIONLIST: flatbuffers::VOffsetT = 10;
    pub const VT_RARITYLIST: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameUpgradeTicketData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameUpgradeTicketDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameUpgradeTicketData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameUpgradeTicketDataBuilder::new(_fbb);
        if let Some(x) = args.rarityList {
            builder.add_rarityList(x);
        }
        if let Some(x) = args.professionList {
            builder.add_professionList(x);
        }
        builder.add_rarity(args.rarity);
        builder.add_profession(args.profession);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameUpgradeTicketDataT {
        let id = self.id().map(|x| x.to_string());
        let profession = self.profession();
        let rarity = self.rarity();
        let professionList = self.professionList().map(|x| x.into_iter().collect());
        let rarityList = self.rarityList().map(|x| x.into_iter().collect());
        clz_Torappu_RoguelikeGameUpgradeTicketDataT {
            id,
            profession,
            rarity,
            professionList,
            rarityList,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameUpgradeTicketData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn profession(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_RoguelikeGameUpgradeTicketData::VT_PROFESSION,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rarity(&self) -> enum__Torappu_RarityRankMask {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RarityRankMask>(
                    clz_Torappu_RoguelikeGameUpgradeTicketData::VT_RARITY,
                    Some(enum__Torappu_RarityRankMask::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn professionList(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_ProfessionID>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_ProfessionID>,
            >>(
                clz_Torappu_RoguelikeGameUpgradeTicketData::VT_PROFESSIONLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn rarityList(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_RarityRank>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, enum__Torappu_RarityRank>>>(clz_Torappu_RoguelikeGameUpgradeTicketData::VT_RARITYLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameUpgradeTicketData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<enum__Torappu_ProfessionCategory>("profession", Self::VT_PROFESSION, false)?
     .visit_field::<enum__Torappu_RarityRankMask>("rarity", Self::VT_RARITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_ProfessionID>>>("professionList", Self::VT_PROFESSIONLIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_RarityRank>>>("rarityList", Self::VT_RARITYLIST, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameUpgradeTicketDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub profession: enum__Torappu_ProfessionCategory,
    pub rarity: enum__Torappu_RarityRankMask,
    pub professionList:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_ProfessionID>>>,
    pub rarityList:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_RarityRank>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeGameUpgradeTicketDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameUpgradeTicketDataArgs {
            id: None,
            profession: enum__Torappu_ProfessionCategory::NONE,
            rarity: enum__Torappu_RarityRankMask::NONE,
            professionList: None,
            rarityList: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameUpgradeTicketData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameUpgradeTicketData", 5)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("profession", &self.profession())?;
        s.serialize_field("rarity", &self.rarity())?;
        if let Some(f) = self.professionList() {
            s.serialize_field("professionList", &f)?;
        } else {
            s.skip_field("professionList")?;
        }
        if let Some(f) = self.rarityList() {
            s.serialize_field("rarityList", &f)?;
        } else {
            s.skip_field("rarityList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameUpgradeTicketDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameUpgradeTicketDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameUpgradeTicketData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_profession(&mut self, profession: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_RoguelikeGameUpgradeTicketData::VT_PROFESSION,
            profession,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_rarity(&mut self, rarity: enum__Torappu_RarityRankMask) {
        self.fbb_.push_slot::<enum__Torappu_RarityRankMask>(
            clz_Torappu_RoguelikeGameUpgradeTicketData::VT_RARITY,
            rarity,
            enum__Torappu_RarityRankMask::NONE,
        );
    }
    #[inline]
    pub fn add_professionList(
        &mut self,
        professionList: flatbuffers::WIPOffset<flatbuffers::Vector<'b, enum__Torappu_ProfessionID>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameUpgradeTicketData::VT_PROFESSIONLIST,
            professionList,
        );
    }
    #[inline]
    pub fn add_rarityList(
        &mut self,
        rarityList: flatbuffers::WIPOffset<flatbuffers::Vector<'b, enum__Torappu_RarityRank>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameUpgradeTicketData::VT_RARITYLIST,
            rarityList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameUpgradeTicketDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameUpgradeTicketDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameUpgradeTicketData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameUpgradeTicketData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameUpgradeTicketData");
        ds.field("id", &self.id());
        ds.field("profession", &self.profession());
        ds.field("rarity", &self.rarity());
        ds.field("professionList", &self.professionList());
        ds.field("rarityList", &self.rarityList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameUpgradeTicketDataT {
    pub id: Option<String>,
    pub profession: enum__Torappu_ProfessionCategory,
    pub rarity: enum__Torappu_RarityRankMask,
    pub professionList: Option<Vec<enum__Torappu_ProfessionID>>,
    pub rarityList: Option<Vec<enum__Torappu_RarityRank>>,
}
impl Default for clz_Torappu_RoguelikeGameUpgradeTicketDataT {
    fn default() -> Self {
        Self {
            id: None,
            profession: enum__Torappu_ProfessionCategory::NONE,
            rarity: enum__Torappu_RarityRankMask::NONE,
            professionList: None,
            rarityList: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameUpgradeTicketDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameUpgradeTicketData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let profession = self.profession;
        let rarity = self.rarity;
        let professionList = self.professionList.as_ref().map(|x| _fbb.create_vector(x));
        let rarityList = self.rarityList.as_ref().map(|x| _fbb.create_vector(x));
        clz_Torappu_RoguelikeGameUpgradeTicketData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameUpgradeTicketDataArgs {
                id,
                profession,
                rarity,
                professionList,
                rarityList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameUpgradeTicketData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameUpgradeTicketData>>(
                    dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameUpgradeTicketData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameUpgradeTicketData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameUpgradeTicketData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameUpgradeTicketData>>(
                dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameUpgradeTicketDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameCustomTicketDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameCustomTicketData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameCustomTicketData<'a> {
    type Inner = clz_Torappu_RoguelikeGameCustomTicketData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameCustomTicketData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SUBTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DISCARDTEXT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameCustomTicketData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameCustomTicketDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameCustomTicketData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameCustomTicketDataBuilder::new(_fbb);
        if let Some(x) = args.discardText {
            builder.add_discardText(x);
        }
        builder.add_subType(args.subType);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameCustomTicketDataT {
        let id = self.id().map(|x| x.to_string());
        let subType = self.subType();
        let discardText = self.discardText().map(|x| x.to_string());
        clz_Torappu_RoguelikeGameCustomTicketDataT {
            id,
            subType,
            discardText,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameCustomTicketData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn subType(&self) -> enum__Torappu_CustomTicketType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_CustomTicketType>(
                    clz_Torappu_RoguelikeGameCustomTicketData::VT_SUBTYPE,
                    Some(enum__Torappu_CustomTicketType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn discardText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameCustomTicketData::VT_DISCARDTEXT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameCustomTicketData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_CustomTicketType>("subType", Self::VT_SUBTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "discardText",
                Self::VT_DISCARDTEXT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameCustomTicketDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subType: enum__Torappu_CustomTicketType,
    pub discardText: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeGameCustomTicketDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameCustomTicketDataArgs {
            id: None,
            subType: enum__Torappu_CustomTicketType::NONE,
            discardText: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameCustomTicketData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameCustomTicketData", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("subType", &self.subType())?;
        if let Some(f) = self.discardText() {
            s.serialize_field("discardText", &f)?;
        } else {
            s.skip_field("discardText")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameCustomTicketDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameCustomTicketDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameCustomTicketData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_subType(&mut self, subType: enum__Torappu_CustomTicketType) {
        self.fbb_.push_slot::<enum__Torappu_CustomTicketType>(
            clz_Torappu_RoguelikeGameCustomTicketData::VT_SUBTYPE,
            subType,
            enum__Torappu_CustomTicketType::NONE,
        );
    }
    #[inline]
    pub fn add_discardText(&mut self, discardText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameCustomTicketData::VT_DISCARDTEXT,
            discardText,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameCustomTicketDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameCustomTicketDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameCustomTicketData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameCustomTicketData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameCustomTicketData");
        ds.field("id", &self.id());
        ds.field("subType", &self.subType());
        ds.field("discardText", &self.discardText());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameCustomTicketDataT {
    pub id: Option<String>,
    pub subType: enum__Torappu_CustomTicketType,
    pub discardText: Option<String>,
}
impl Default for clz_Torappu_RoguelikeGameCustomTicketDataT {
    fn default() -> Self {
        Self {
            id: None,
            subType: enum__Torappu_CustomTicketType::NONE,
            discardText: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameCustomTicketDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameCustomTicketData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let subType = self.subType;
        let discardText = self.discardText.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeGameCustomTicketData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameCustomTicketDataArgs {
                id,
                subType,
                discardText,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameCustomTicketDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameCustomTicketData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameCustomTicketData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameCustomTicketData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameCustomTicketData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameCustomTicketData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameCustomTicketDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameCustomTicketData<'bldr>>
    {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameCustomTicketDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameCustomTicketDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameCustomTicketDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameCustomTicketData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameCustomTicketData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameCustomTicketData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameCustomTicketData>>(
                    dict__string__clz_Torappu_RoguelikeGameCustomTicketData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameCustomTicketData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameCustomTicketData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameCustomTicketDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameCustomTicketData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameCustomTicketDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameCustomTicketDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameCustomTicketData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeGameCustomTicketData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameCustomTicketDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameCustomTicketDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameCustomTicketData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameCustomTicketData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameCustomTicketData>>(
                dict__string__clz_Torappu_RoguelikeGameCustomTicketData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameCustomTicketDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameCustomTicketDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameCustomTicketData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameCustomTicketData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameCustomTicketData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameCustomTicketData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameCustomTicketDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameCustomTicketDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameCustomTicketDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameCustomTicketDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameCustomTicketData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameCustomTicketData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameCustomTicketDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameStashableTicketDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameStashableTicketData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameStashableTicketData<'a> {
    type Inner = clz_Torappu_RoguelikeGameStashableTicketData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameStashableTicketData<'a> {
    pub const VT_TICKETID: flatbuffers::VOffsetT = 4;
    pub const VT_STASHEDTICKETID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameStashableTicketData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameStashableTicketDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameStashableTicketData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameStashableTicketDataBuilder::new(_fbb);
        if let Some(x) = args.stashedTicketId {
            builder.add_stashedTicketId(x);
        }
        if let Some(x) = args.ticketId {
            builder.add_ticketId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameStashableTicketDataT {
        let ticketId = self.ticketId().map(|x| x.to_string());
        let stashedTicketId = self.stashedTicketId().map(|x| x.to_string());
        clz_Torappu_RoguelikeGameStashableTicketDataT {
            ticketId,
            stashedTicketId,
        }
    }

    #[inline]
    pub fn ticketId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameStashableTicketData::VT_TICKETID,
                None,
            )
        }
    }
    #[inline]
    pub fn stashedTicketId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameStashableTicketData::VT_STASHEDTICKETID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameStashableTicketData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "ticketId",
                Self::VT_TICKETID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "stashedTicketId",
                Self::VT_STASHEDTICKETID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameStashableTicketDataArgs<'a> {
    pub ticketId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stashedTicketId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeGameStashableTicketDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameStashableTicketDataArgs {
            ticketId: None,
            stashedTicketId: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameStashableTicketData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeGameStashableTicketData", 2)?;
        if let Some(f) = self.ticketId() {
            s.serialize_field("ticketId", &f)?;
        } else {
            s.skip_field("ticketId")?;
        }
        if let Some(f) = self.stashedTicketId() {
            s.serialize_field("stashedTicketId", &f)?;
        } else {
            s.skip_field("stashedTicketId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameStashableTicketDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameStashableTicketDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_ticketId(&mut self, ticketId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStashableTicketData::VT_TICKETID,
            ticketId,
        );
    }
    #[inline]
    pub fn add_stashedTicketId(&mut self, stashedTicketId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameStashableTicketData::VT_STASHEDTICKETID,
            stashedTicketId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameStashableTicketDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameStashableTicketDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameStashableTicketData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameStashableTicketData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameStashableTicketData");
        ds.field("ticketId", &self.ticketId());
        ds.field("stashedTicketId", &self.stashedTicketId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameStashableTicketDataT {
    pub ticketId: Option<String>,
    pub stashedTicketId: Option<String>,
}
impl Default for clz_Torappu_RoguelikeGameStashableTicketDataT {
    fn default() -> Self {
        Self {
            ticketId: None,
            stashedTicketId: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameStashableTicketDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameStashableTicketData<'b>> {
        let ticketId = self.ticketId.as_ref().map(|x| _fbb.create_string(x));
        let stashedTicketId = self.stashedTicketId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeGameStashableTicketData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameStashableTicketDataArgs {
                ticketId,
                stashedTicketId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameStashableTicketDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameStashableTicketData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_RoguelikeGameStashableTicketData<'a>
{
    type Inner = dict__string__clz_Torappu_RoguelikeGameStashableTicketData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameStashableTicketData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameStashableTicketData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameStashableTicketDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameStashableTicketData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_RoguelikeGameStashableTicketDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameStashableTicketDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameStashableTicketDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameStashableTicketData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameStashableTicketData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameStashableTicketData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameStashableTicketData>>(
                    dict__string__clz_Torappu_RoguelikeGameStashableTicketData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameStashableTicketData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameStashableTicketData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameStashableTicketDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameStashableTicketData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameStashableTicketDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameStashableTicketDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameStashableTicketData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_RoguelikeGameStashableTicketData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameStashableTicketDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameStashableTicketDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameStashableTicketData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameStashableTicketData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameStashableTicketData>>(dict__string__clz_Torappu_RoguelikeGameStashableTicketData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameStashableTicketDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameStashableTicketDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameStashableTicketData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameStashableTicketData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameStashableTicketData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameStashableTicketData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameStashableTicketDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameStashableTicketDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameStashableTicketDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameStashableTicketDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameStashableTicketData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameStashableTicketData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameStashableTicketDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Blackboard_DataPairOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Blackboard_DataPair<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Blackboard_DataPair<'a> {
    type Inner = clz_Torappu_Blackboard_DataPair<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Blackboard_DataPair<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_VALUESTR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Blackboard_DataPair { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Blackboard_DataPairArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'bldr>> {
        let mut builder = clz_Torappu_Blackboard_DataPairBuilder::new(_fbb);
        if let Some(x) = args.valueStr {
            builder.add_valueStr(x);
        }
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Blackboard_DataPairT {
        let key = self.key().map(|x| x.to_string());
        let value = self.value();
        let valueStr = self.valueStr().map(|x| x.to_string());
        clz_Torappu_Blackboard_DataPairT {
            key,
            value,
            valueStr,
        }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn valueStr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Blackboard_DataPair<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "valueStr",
                Self::VT_VALUESTR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Blackboard_DataPairArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f32,
    pub valueStr: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Blackboard_DataPairArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Blackboard_DataPairArgs {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}

impl Serialize for clz_Torappu_Blackboard_DataPair<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Blackboard_DataPair", 3)?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        s.serialize_field("value", &self.value())?;
        if let Some(f) = self.valueStr() {
            s.serialize_field("valueStr", &f)?;
        } else {
            s.skip_field("valueStr")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Blackboard_DataPairBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn add_valueStr(&mut self, valueStr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
            valueStr,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Blackboard_DataPairBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Blackboard_DataPair<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Blackboard_DataPair");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.field("valueStr", &self.valueStr());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Blackboard_DataPairT {
    pub key: Option<String>,
    pub value: f32,
    pub valueStr: Option<String>,
}
impl Default for clz_Torappu_Blackboard_DataPairT {
    fn default() -> Self {
        Self {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}
impl clz_Torappu_Blackboard_DataPairT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let value = self.value;
        let valueStr = self.valueStr.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Blackboard_DataPair::create(
            _fbb,
            &clz_Torappu_Blackboard_DataPairArgs {
                key,
                value,
                valueStr,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeBuffOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeBuff<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeBuff<'a> {
    type Inner = clz_Torappu_RoguelikeBuff<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeBuff<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeBuff { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeBuffArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeBuff<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeBuffBuilder::new(_fbb);
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeBuffT {
        let key = self.key().map(|x| x.to_string());
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeBuffT { key, blackboard }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeBuff::VT_KEY, None)
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_RoguelikeBuff::VT_BLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeBuff<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeBuffArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeBuffArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeBuffArgs {
            key: None,
            blackboard: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeBuff<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeBuff", 2)?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        if let Some(f) = self.blackboard() {
            s.serialize_field("blackboard", &f)?;
        } else {
            s.skip_field("blackboard")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeBuffBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RoguelikeBuffBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RoguelikeBuff::VT_KEY, key);
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeBuff::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeBuffBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeBuffBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeBuff<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeBuff<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeBuff");
        ds.field("key", &self.key());
        ds.field("blackboard", &self.blackboard());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeBuffT {
    pub key: Option<String>,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for clz_Torappu_RoguelikeBuffT {
    fn default() -> Self {
        Self {
            key: None,
            blackboard: None,
        }
    }
}
impl clz_Torappu_RoguelikeBuffT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeBuff<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeBuff::create(_fbb, &clz_Torappu_RoguelikeBuffArgs { key, blackboard })
    }
}
pub enum clz_Torappu_RoguelikeGameRelicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameRelicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameRelicData<'a> {
    type Inner = clz_Torappu_RoguelikeGameRelicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameRelicData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_BUFFS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameRelicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameRelicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRelicData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameRelicDataBuilder::new(_fbb);
        if let Some(x) = args.buffs {
            builder.add_buffs(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameRelicDataT {
        let id = self.id().map(|x| x.to_string());
        let buffs = self.buffs().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeGameRelicDataT { id, buffs }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameRelicData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn buffs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBuff<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBuff>>,
            >>(clz_Torappu_RoguelikeGameRelicData::VT_BUFFS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameRelicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBuff>>,
            >>("buffs", Self::VT_BUFFS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameRelicDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBuff<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeGameRelicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameRelicDataArgs {
            id: None,
            buffs: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameRelicData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameRelicData", 2)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.buffs() {
            s.serialize_field("buffs", &f)?;
        } else {
            s.skip_field("buffs")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameRelicDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameRelicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRelicData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_buffs(
        &mut self,
        buffs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBuff<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRelicData::VT_BUFFS,
            buffs,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameRelicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameRelicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRelicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameRelicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameRelicData");
        ds.field("id", &self.id());
        ds.field("buffs", &self.buffs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameRelicDataT {
    pub id: Option<String>,
    pub buffs: Option<Vec<clz_Torappu_RoguelikeBuffT>>,
}
impl Default for clz_Torappu_RoguelikeGameRelicDataT {
    fn default() -> Self {
        Self {
            id: None,
            buffs: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameRelicDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRelicData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let buffs = self.buffs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeGameRelicData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameRelicDataArgs { id, buffs },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameRelicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameRelicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameRelicData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameRelicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameRelicData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameRelicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameRelicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameRelicData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameRelicDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameRelicDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameRelicDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameRelicData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameRelicData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameRelicData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameRelicData>>(
                    dict__string__clz_Torappu_RoguelikeGameRelicData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameRelicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameRelicData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameRelicDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRelicData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameRelicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameRelicDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameRelicData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeGameRelicData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameRelicDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameRelicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameRelicData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRelicData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRelicData>>(
                dict__string__clz_Torappu_RoguelikeGameRelicData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameRelicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameRelicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameRelicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameRelicData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameRelicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameRelicData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameRelicDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameRelicDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameRelicDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameRelicDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameRelicData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameRelicData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameRelicDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameRelicCheckParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameRelicCheckParam<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameRelicCheckParam<'a> {
    type Inner = clz_Torappu_RoguelikeGameRelicCheckParam<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameRelicCheckParam<'a> {
    pub const VT_VALUEPROFESSIONMASK: flatbuffers::VOffsetT = 4;
    pub const VT_VALUESTRS: flatbuffers::VOffsetT = 6;
    pub const VT_VALUEINT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameRelicCheckParam { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameRelicCheckParamArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRelicCheckParam<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameRelicCheckParamBuilder::new(_fbb);
        builder.add_valueInt(args.valueInt);
        if let Some(x) = args.valueStrs {
            builder.add_valueStrs(x);
        }
        builder.add_valueProfessionMask(args.valueProfessionMask);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameRelicCheckParamT {
        let valueProfessionMask = self.valueProfessionMask();
        let valueStrs = self
            .valueStrs()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let valueInt = self.valueInt();
        clz_Torappu_RoguelikeGameRelicCheckParamT {
            valueProfessionMask,
            valueStrs,
            valueInt,
        }
    }

    #[inline]
    pub fn valueProfessionMask(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_RoguelikeGameRelicCheckParam::VT_VALUEPROFESSIONMASK,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn valueStrs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RoguelikeGameRelicCheckParam::VT_VALUESTRS, None)
        }
    }
    #[inline]
    pub fn valueInt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeGameRelicCheckParam::VT_VALUEINT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameRelicCheckParam<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ProfessionCategory>(
                "valueProfessionMask",
                Self::VT_VALUEPROFESSIONMASK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("valueStrs", Self::VT_VALUESTRS, false)?
            .visit_field::<i32>("valueInt", Self::VT_VALUEINT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameRelicCheckParamArgs<'a> {
    pub valueProfessionMask: enum__Torappu_ProfessionCategory,
    pub valueStrs: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub valueInt: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeGameRelicCheckParamArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameRelicCheckParamArgs {
            valueProfessionMask: enum__Torappu_ProfessionCategory::NONE,
            valueStrs: None,
            valueInt: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameRelicCheckParam<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameRelicCheckParam", 3)?;
        s.serialize_field("valueProfessionMask", &self.valueProfessionMask())?;
        if let Some(f) = self.valueStrs() {
            s.serialize_field("valueStrs", &f)?;
        } else {
            s.skip_field("valueStrs")?;
        }
        s.serialize_field("valueInt", &self.valueInt())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameRelicCheckParamBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameRelicCheckParamBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_valueProfessionMask(
        &mut self,
        valueProfessionMask: enum__Torappu_ProfessionCategory,
    ) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_RoguelikeGameRelicCheckParam::VT_VALUEPROFESSIONMASK,
            valueProfessionMask,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_valueStrs(
        &mut self,
        valueStrs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRelicCheckParam::VT_VALUESTRS,
            valueStrs,
        );
    }
    #[inline]
    pub fn add_valueInt(&mut self, valueInt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameRelicCheckParam::VT_VALUEINT,
            valueInt,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameRelicCheckParamBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameRelicCheckParamBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRelicCheckParam<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameRelicCheckParam<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameRelicCheckParam");
        ds.field("valueProfessionMask", &self.valueProfessionMask());
        ds.field("valueStrs", &self.valueStrs());
        ds.field("valueInt", &self.valueInt());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameRelicCheckParamT {
    pub valueProfessionMask: enum__Torappu_ProfessionCategory,
    pub valueStrs: Option<Vec<String>>,
    pub valueInt: i32,
}
impl Default for clz_Torappu_RoguelikeGameRelicCheckParamT {
    fn default() -> Self {
        Self {
            valueProfessionMask: enum__Torappu_ProfessionCategory::NONE,
            valueStrs: None,
            valueInt: 0,
        }
    }
}
impl clz_Torappu_RoguelikeGameRelicCheckParamT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRelicCheckParam<'b>> {
        let valueProfessionMask = self.valueProfessionMask;
        let valueStrs = self.valueStrs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let valueInt = self.valueInt;
        clz_Torappu_RoguelikeGameRelicCheckParam::create(
            _fbb,
            &clz_Torappu_RoguelikeGameRelicCheckParamArgs {
                valueProfessionMask,
                valueStrs,
                valueInt,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameRelicParamDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameRelicParamData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameRelicParamData<'a> {
    type Inner = clz_Torappu_RoguelikeGameRelicParamData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameRelicParamData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_CHECKCHARBOXTYPES: flatbuffers::VOffsetT = 6;
    pub const VT_CHECKCHARBOXPARAMS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameRelicParamData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameRelicParamDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRelicParamData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameRelicParamDataBuilder::new(_fbb);
        if let Some(x) = args.checkCharBoxParams {
            builder.add_checkCharBoxParams(x);
        }
        if let Some(x) = args.checkCharBoxTypes {
            builder.add_checkCharBoxTypes(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameRelicParamDataT {
        let id = self.id().map(|x| x.to_string());
        let checkCharBoxTypes = self.checkCharBoxTypes().map(|x| x.into_iter().collect());
        let checkCharBoxParams = self
            .checkCharBoxParams()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeGameRelicParamDataT {
            id,
            checkCharBoxTypes,
            checkCharBoxParams,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameRelicParamData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn checkCharBoxTypes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_RoguelikeGameRelicCheckType>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_RoguelikeGameRelicCheckType>,
            >>(
                clz_Torappu_RoguelikeGameRelicParamData::VT_CHECKCHARBOXTYPES,
                None,
            )
        }
    }
    #[inline]
    pub fn checkCharBoxParams(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameRelicCheckParam<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameRelicCheckParam>,
                >,
            >>(
                clz_Torappu_RoguelikeGameRelicParamData::VT_CHECKCHARBOXPARAMS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameRelicParamData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, enum__Torappu_RoguelikeGameRelicCheckType>,
            >>("checkCharBoxTypes", Self::VT_CHECKCHARBOXTYPES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameRelicCheckParam>,
                >,
            >>("checkCharBoxParams", Self::VT_CHECKCHARBOXPARAMS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameRelicParamDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub checkCharBoxTypes: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_RoguelikeGameRelicCheckType>>,
    >,
    pub checkCharBoxParams: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameRelicCheckParam<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeGameRelicParamDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameRelicParamDataArgs {
            id: None,
            checkCharBoxTypes: None,
            checkCharBoxParams: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameRelicParamData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameRelicParamData", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.checkCharBoxTypes() {
            s.serialize_field("checkCharBoxTypes", &f)?;
        } else {
            s.skip_field("checkCharBoxTypes")?;
        }
        if let Some(f) = self.checkCharBoxParams() {
            s.serialize_field("checkCharBoxParams", &f)?;
        } else {
            s.skip_field("checkCharBoxParams")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameRelicParamDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameRelicParamDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRelicParamData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_checkCharBoxTypes(
        &mut self,
        checkCharBoxTypes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_RoguelikeGameRelicCheckType>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRelicParamData::VT_CHECKCHARBOXTYPES,
            checkCharBoxTypes,
        );
    }
    #[inline]
    pub fn add_checkCharBoxParams(
        &mut self,
        checkCharBoxParams: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameRelicCheckParam<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRelicParamData::VT_CHECKCHARBOXPARAMS,
            checkCharBoxParams,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameRelicParamDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameRelicParamDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRelicParamData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameRelicParamData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameRelicParamData");
        ds.field("id", &self.id());
        ds.field("checkCharBoxTypes", &self.checkCharBoxTypes());
        ds.field("checkCharBoxParams", &self.checkCharBoxParams());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameRelicParamDataT {
    pub id: Option<String>,
    pub checkCharBoxTypes: Option<Vec<enum__Torappu_RoguelikeGameRelicCheckType>>,
    pub checkCharBoxParams: Option<Vec<clz_Torappu_RoguelikeGameRelicCheckParamT>>,
}
impl Default for clz_Torappu_RoguelikeGameRelicParamDataT {
    fn default() -> Self {
        Self {
            id: None,
            checkCharBoxTypes: None,
            checkCharBoxParams: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameRelicParamDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRelicParamData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let checkCharBoxTypes = self
            .checkCharBoxTypes
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let checkCharBoxParams = self.checkCharBoxParams.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeGameRelicParamData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameRelicParamDataArgs {
                id,
                checkCharBoxTypes,
                checkCharBoxParams,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameRelicParamDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameRelicParamData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameRelicParamData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameRelicParamData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameRelicParamData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameRelicParamData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameRelicParamDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameRelicParamData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameRelicParamDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameRelicParamDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameRelicParamDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameRelicParamData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameRelicParamData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameRelicParamData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameRelicParamData>>(
                    dict__string__clz_Torappu_RoguelikeGameRelicParamData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameRelicParamData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameRelicParamData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameRelicParamDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRelicParamData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameRelicParamDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameRelicParamDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameRelicParamData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeGameRelicParamData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameRelicParamDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameRelicParamDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameRelicParamData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRelicParamData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRelicParamData>>(
                dict__string__clz_Torappu_RoguelikeGameRelicParamData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameRelicParamDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameRelicParamDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameRelicParamData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameRelicParamData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameRelicParamData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameRelicParamData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameRelicParamDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameRelicParamDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameRelicParamDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameRelicParamDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameRelicParamData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameRelicParamData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameRelicParamDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameRecruitGrpDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameRecruitGrpData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameRecruitGrpData<'a> {
    type Inner = clz_Torappu_RoguelikeGameRecruitGrpData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameRecruitGrpData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_ICONID: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_DESC: flatbuffers::VOffsetT = 10;
    pub const VT_UNLOCKDESC: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameRecruitGrpData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameRecruitGrpDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRecruitGrpData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameRecruitGrpDataBuilder::new(_fbb);
        if let Some(x) = args.unlockDesc {
            builder.add_unlockDesc(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameRecruitGrpDataT {
        let id = self.id().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let unlockDesc = self.unlockDesc().map(|x| x.to_string());
        clz_Torappu_RoguelikeGameRecruitGrpDataT {
            id,
            iconId,
            name,
            desc,
            unlockDesc,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameRecruitGrpData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameRecruitGrpData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameRecruitGrpData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameRecruitGrpData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameRecruitGrpData::VT_UNLOCKDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameRecruitGrpData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockDesc",
                Self::VT_UNLOCKDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameRecruitGrpDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeGameRecruitGrpDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameRecruitGrpDataArgs {
            id: None,
            iconId: None,
            name: None,
            desc: None,
            unlockDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameRecruitGrpData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameRecruitGrpData", 5)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.unlockDesc() {
            s.serialize_field("unlockDesc", &f)?;
        } else {
            s.skip_field("unlockDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameRecruitGrpDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameRecruitGrpDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRecruitGrpData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRecruitGrpData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRecruitGrpData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRecruitGrpData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_unlockDesc(&mut self, unlockDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameRecruitGrpData::VT_UNLOCKDESC,
            unlockDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameRecruitGrpDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameRecruitGrpDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRecruitGrpData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameRecruitGrpData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameRecruitGrpData");
        ds.field("id", &self.id());
        ds.field("iconId", &self.iconId());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.field("unlockDesc", &self.unlockDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameRecruitGrpDataT {
    pub id: Option<String>,
    pub iconId: Option<String>,
    pub name: Option<String>,
    pub desc: Option<String>,
    pub unlockDesc: Option<String>,
}
impl Default for clz_Torappu_RoguelikeGameRecruitGrpDataT {
    fn default() -> Self {
        Self {
            id: None,
            iconId: None,
            name: None,
            desc: None,
            unlockDesc: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameRecruitGrpDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRecruitGrpData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let unlockDesc = self.unlockDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeGameRecruitGrpData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameRecruitGrpDataArgs {
                id,
                iconId,
                name,
                desc,
                unlockDesc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameRecruitGrpData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameRecruitGrpData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameRecruitGrpData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameRecruitGrpData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameRecruitGrpData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameRecruitGrpData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameRecruitGrpData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameRecruitGrpData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameRecruitGrpData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameRecruitGrpData>>(
                    dict__string__clz_Torappu_RoguelikeGameRecruitGrpData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameRecruitGrpData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameRecruitGrpData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRecruitGrpData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameRecruitGrpData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeGameRecruitGrpData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameRecruitGrpData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRecruitGrpData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameRecruitGrpData>>(
                dict__string__clz_Torappu_RoguelikeGameRecruitGrpData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameRecruitGrpData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameRecruitGrpData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameRecruitGrpData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameRecruitGrpData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameRecruitGrpDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameRecruitGrpData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameRecruitGrpData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeChoiceDisplayDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeChoiceDisplayData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeChoiceDisplayData<'a> {
    type Inner = clz_Torappu_RoguelikeChoiceDisplayData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeChoiceDisplayData<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_COSTHINTTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_EFFECTHINTTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_FUNCICONID: flatbuffers::VOffsetT = 10;
    pub const VT_ITEMID: flatbuffers::VOffsetT = 12;
    pub const VT_DIFFICULTYUPGRADERELICGROUPID: flatbuffers::VOffsetT = 14;
    pub const VT_TASKID: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeChoiceDisplayData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeChoiceDisplayDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChoiceDisplayData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeChoiceDisplayDataBuilder::new(_fbb);
        if let Some(x) = args.taskId {
            builder.add_taskId(x);
        }
        if let Some(x) = args.difficultyUpgradeRelicGroupId {
            builder.add_difficultyUpgradeRelicGroupId(x);
        }
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        if let Some(x) = args.funcIconId {
            builder.add_funcIconId(x);
        }
        builder.add_effectHintType(args.effectHintType);
        builder.add_costHintType(args.costHintType);
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeChoiceDisplayDataT {
        let type_ = self.type_();
        let costHintType = self.costHintType();
        let effectHintType = self.effectHintType();
        let funcIconId = self.funcIconId().map(|x| x.to_string());
        let itemId = self.itemId().map(|x| x.to_string());
        let difficultyUpgradeRelicGroupId =
            self.difficultyUpgradeRelicGroupId().map(|x| x.to_string());
        let taskId = self.taskId().map(|x| x.to_string());
        clz_Torappu_RoguelikeChoiceDisplayDataT {
            type_,
            costHintType,
            effectHintType,
            funcIconId,
            itemId,
            difficultyUpgradeRelicGroupId,
            taskId,
        }
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_RoguelikeChoiceDisplayType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeChoiceDisplayType>(
                    clz_Torappu_RoguelikeChoiceDisplayData::VT_TYPE_,
                    Some(enum__Torappu_RoguelikeChoiceDisplayType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn costHintType(&self) -> enum__Torappu_RoguelikeChoiceHintType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeChoiceHintType>(
                    clz_Torappu_RoguelikeChoiceDisplayData::VT_COSTHINTTYPE,
                    Some(enum__Torappu_RoguelikeChoiceHintType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn effectHintType(&self) -> enum__Torappu_RoguelikeChoiceHintType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeChoiceHintType>(
                    clz_Torappu_RoguelikeChoiceDisplayData::VT_EFFECTHINTTYPE,
                    Some(enum__Torappu_RoguelikeChoiceHintType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn funcIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeChoiceDisplayData::VT_FUNCICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeChoiceDisplayData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn difficultyUpgradeRelicGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeChoiceDisplayData::VT_DIFFICULTYUPGRADERELICGROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn taskId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeChoiceDisplayData::VT_TASKID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeChoiceDisplayData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeChoiceDisplayType>(
                "type_",
                Self::VT_TYPE_,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeChoiceHintType>(
                "costHintType",
                Self::VT_COSTHINTTYPE,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeChoiceHintType>(
                "effectHintType",
                Self::VT_EFFECTHINTTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "funcIconId",
                Self::VT_FUNCICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "difficultyUpgradeRelicGroupId",
                Self::VT_DIFFICULTYUPGRADERELICGROUPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskId", Self::VT_TASKID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeChoiceDisplayDataArgs<'a> {
    pub type_: enum__Torappu_RoguelikeChoiceDisplayType,
    pub costHintType: enum__Torappu_RoguelikeChoiceHintType,
    pub effectHintType: enum__Torappu_RoguelikeChoiceHintType,
    pub funcIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub difficultyUpgradeRelicGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeChoiceDisplayDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeChoiceDisplayDataArgs {
            type_: enum__Torappu_RoguelikeChoiceDisplayType::NONE,
            costHintType: enum__Torappu_RoguelikeChoiceHintType::NONE,
            effectHintType: enum__Torappu_RoguelikeChoiceHintType::NONE,
            funcIconId: None,
            itemId: None,
            difficultyUpgradeRelicGroupId: None,
            taskId: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeChoiceDisplayData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeChoiceDisplayData", 7)?;
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("costHintType", &self.costHintType())?;
        s.serialize_field("effectHintType", &self.effectHintType())?;
        if let Some(f) = self.funcIconId() {
            s.serialize_field("funcIconId", &f)?;
        } else {
            s.skip_field("funcIconId")?;
        }
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        if let Some(f) = self.difficultyUpgradeRelicGroupId() {
            s.serialize_field("difficultyUpgradeRelicGroupId", &f)?;
        } else {
            s.skip_field("difficultyUpgradeRelicGroupId")?;
        }
        if let Some(f) = self.taskId() {
            s.serialize_field("taskId", &f)?;
        } else {
            s.skip_field("taskId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeChoiceDisplayDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeChoiceDisplayDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_RoguelikeChoiceDisplayType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeChoiceDisplayType>(
                clz_Torappu_RoguelikeChoiceDisplayData::VT_TYPE_,
                type_,
                enum__Torappu_RoguelikeChoiceDisplayType::NONE,
            );
    }
    #[inline]
    pub fn add_costHintType(&mut self, costHintType: enum__Torappu_RoguelikeChoiceHintType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeChoiceHintType>(
                clz_Torappu_RoguelikeChoiceDisplayData::VT_COSTHINTTYPE,
                costHintType,
                enum__Torappu_RoguelikeChoiceHintType::NONE,
            );
    }
    #[inline]
    pub fn add_effectHintType(&mut self, effectHintType: enum__Torappu_RoguelikeChoiceHintType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeChoiceHintType>(
                clz_Torappu_RoguelikeChoiceDisplayData::VT_EFFECTHINTTYPE,
                effectHintType,
                enum__Torappu_RoguelikeChoiceHintType::NONE,
            );
    }
    #[inline]
    pub fn add_funcIconId(&mut self, funcIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChoiceDisplayData::VT_FUNCICONID,
            funcIconId,
        );
    }
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChoiceDisplayData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_difficultyUpgradeRelicGroupId(
        &mut self,
        difficultyUpgradeRelicGroupId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChoiceDisplayData::VT_DIFFICULTYUPGRADERELICGROUPID,
            difficultyUpgradeRelicGroupId,
        );
    }
    #[inline]
    pub fn add_taskId(&mut self, taskId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChoiceDisplayData::VT_TASKID,
            taskId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeChoiceDisplayDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeChoiceDisplayDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChoiceDisplayData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeChoiceDisplayData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeChoiceDisplayData");
        ds.field("type_", &self.type_());
        ds.field("costHintType", &self.costHintType());
        ds.field("effectHintType", &self.effectHintType());
        ds.field("funcIconId", &self.funcIconId());
        ds.field("itemId", &self.itemId());
        ds.field(
            "difficultyUpgradeRelicGroupId",
            &self.difficultyUpgradeRelicGroupId(),
        );
        ds.field("taskId", &self.taskId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeChoiceDisplayDataT {
    pub type_: enum__Torappu_RoguelikeChoiceDisplayType,
    pub costHintType: enum__Torappu_RoguelikeChoiceHintType,
    pub effectHintType: enum__Torappu_RoguelikeChoiceHintType,
    pub funcIconId: Option<String>,
    pub itemId: Option<String>,
    pub difficultyUpgradeRelicGroupId: Option<String>,
    pub taskId: Option<String>,
}
impl Default for clz_Torappu_RoguelikeChoiceDisplayDataT {
    fn default() -> Self {
        Self {
            type_: enum__Torappu_RoguelikeChoiceDisplayType::NONE,
            costHintType: enum__Torappu_RoguelikeChoiceHintType::NONE,
            effectHintType: enum__Torappu_RoguelikeChoiceHintType::NONE,
            funcIconId: None,
            itemId: None,
            difficultyUpgradeRelicGroupId: None,
            taskId: None,
        }
    }
}
impl clz_Torappu_RoguelikeChoiceDisplayDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChoiceDisplayData<'b>> {
        let type_ = self.type_;
        let costHintType = self.costHintType;
        let effectHintType = self.effectHintType;
        let funcIconId = self.funcIconId.as_ref().map(|x| _fbb.create_string(x));
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let difficultyUpgradeRelicGroupId = self
            .difficultyUpgradeRelicGroupId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let taskId = self.taskId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeChoiceDisplayData::create(
            _fbb,
            &clz_Torappu_RoguelikeChoiceDisplayDataArgs {
                type_,
                costHintType,
                effectHintType,
                funcIconId,
                itemId,
                difficultyUpgradeRelicGroupId,
                taskId,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameChoiceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameChoiceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameChoiceData<'a> {
    type Inner = clz_Torappu_RoguelikeGameChoiceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameChoiceData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TITLE: flatbuffers::VOffsetT = 6;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
    pub const VT_LOCKEDCOVERDESC: flatbuffers::VOffsetT = 10;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 12;
    pub const VT_LEFTDECOTYPE: flatbuffers::VOffsetT = 14;
    pub const VT_NEXTSCENEID: flatbuffers::VOffsetT = 16;
    pub const VT_ICON: flatbuffers::VOffsetT = 18;
    pub const VT_DISPLAYDATA: flatbuffers::VOffsetT = 20;
    pub const VT_FORCESHOWWHENONLYLEAVE: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameChoiceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameChoiceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameChoiceData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameChoiceDataBuilder::new(_fbb);
        if let Some(x) = args.displayData {
            builder.add_displayData(x);
        }
        if let Some(x) = args.icon {
            builder.add_icon(x);
        }
        if let Some(x) = args.nextSceneId {
            builder.add_nextSceneId(x);
        }
        builder.add_leftDecoType(args.leftDecoType);
        builder.add_type_(args.type_);
        if let Some(x) = args.lockedCoverDesc {
            builder.add_lockedCoverDesc(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_forceShowWhenOnlyLeave(args.forceShowWhenOnlyLeave);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameChoiceDataT {
        let id = self.id().map(|x| x.to_string());
        let title = self.title().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let lockedCoverDesc = self.lockedCoverDesc().map(|x| x.to_string());
        let type_ = self.type_();
        let leftDecoType = self.leftDecoType();
        let nextSceneId = self.nextSceneId().map(|x| x.to_string());
        let icon = self.icon().map(|x| x.to_string());
        let displayData = self.displayData().map(|x| Box::new(x.unpack()));
        let forceShowWhenOnlyLeave = self.forceShowWhenOnlyLeave();
        clz_Torappu_RoguelikeGameChoiceDataT {
            id,
            title,
            description,
            lockedCoverDesc,
            type_,
            leftDecoType,
            nextSceneId,
            icon,
            displayData,
            forceShowWhenOnlyLeave,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameChoiceData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameChoiceData::VT_TITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameChoiceData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn lockedCoverDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameChoiceData::VT_LOCKEDCOVERDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_RoguelikeGameChoiceType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeGameChoiceType>(
                    clz_Torappu_RoguelikeGameChoiceData::VT_TYPE_,
                    Some(enum__Torappu_RoguelikeGameChoiceType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn leftDecoType(&self) -> enum__Torappu_RoguelikeChoiceLeftDecoType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeChoiceLeftDecoType>(
                    clz_Torappu_RoguelikeGameChoiceData::VT_LEFTDECOTYPE,
                    Some(enum__Torappu_RoguelikeChoiceLeftDecoType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn nextSceneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameChoiceData::VT_NEXTSCENEID,
                None,
            )
        }
    }
    #[inline]
    pub fn icon(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameChoiceData::VT_ICON,
                None,
            )
        }
    }
    #[inline]
    pub fn displayData(&self) -> Option<clz_Torappu_RoguelikeChoiceDisplayData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeChoiceDisplayData>>(
                    clz_Torappu_RoguelikeGameChoiceData::VT_DISPLAYDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn forceShowWhenOnlyLeave(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeGameChoiceData::VT_FORCESHOWWHENONLYLEAVE,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameChoiceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "lockedCoverDesc",
                Self::VT_LOCKEDCOVERDESC,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeGameChoiceType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<enum__Torappu_RoguelikeChoiceLeftDecoType>(
                "leftDecoType",
                Self::VT_LEFTDECOTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nextSceneId",
                Self::VT_NEXTSCENEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("icon", Self::VT_ICON, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeChoiceDisplayData>>(
                "displayData",
                Self::VT_DISPLAYDATA,
                false,
            )?
            .visit_field::<bool>(
                "forceShowWhenOnlyLeave",
                Self::VT_FORCESHOWWHENONLYLEAVE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameChoiceDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lockedCoverDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_RoguelikeGameChoiceType,
    pub leftDecoType: enum__Torappu_RoguelikeChoiceLeftDecoType,
    pub nextSceneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub icon: Option<flatbuffers::WIPOffset<&'a str>>,
    pub displayData: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeChoiceDisplayData<'a>>>,
    pub forceShowWhenOnlyLeave: bool,
}
impl<'a> Default for clz_Torappu_RoguelikeGameChoiceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameChoiceDataArgs {
            id: None,
            title: None,
            description: None,
            lockedCoverDesc: None,
            type_: enum__Torappu_RoguelikeGameChoiceType::NONE,
            leftDecoType: enum__Torappu_RoguelikeChoiceLeftDecoType::NONE,
            nextSceneId: None,
            icon: None,
            displayData: None,
            forceShowWhenOnlyLeave: false,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameChoiceData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameChoiceData", 10)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.title() {
            s.serialize_field("title", &f)?;
        } else {
            s.skip_field("title")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.lockedCoverDesc() {
            s.serialize_field("lockedCoverDesc", &f)?;
        } else {
            s.skip_field("lockedCoverDesc")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("leftDecoType", &self.leftDecoType())?;
        if let Some(f) = self.nextSceneId() {
            s.serialize_field("nextSceneId", &f)?;
        } else {
            s.skip_field("nextSceneId")?;
        }
        if let Some(f) = self.icon() {
            s.serialize_field("icon", &f)?;
        } else {
            s.skip_field("icon")?;
        }
        if let Some(f) = self.displayData() {
            s.serialize_field("displayData", &f)?;
        } else {
            s.skip_field("displayData")?;
        }
        s.serialize_field("forceShowWhenOnlyLeave", &self.forceShowWhenOnlyLeave())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameChoiceDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameChoiceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameChoiceData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameChoiceData::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameChoiceData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_lockedCoverDesc(&mut self, lockedCoverDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameChoiceData::VT_LOCKEDCOVERDESC,
            lockedCoverDesc,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_RoguelikeGameChoiceType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeGameChoiceType>(
                clz_Torappu_RoguelikeGameChoiceData::VT_TYPE_,
                type_,
                enum__Torappu_RoguelikeGameChoiceType::NONE,
            );
    }
    #[inline]
    pub fn add_leftDecoType(&mut self, leftDecoType: enum__Torappu_RoguelikeChoiceLeftDecoType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeChoiceLeftDecoType>(
                clz_Torappu_RoguelikeGameChoiceData::VT_LEFTDECOTYPE,
                leftDecoType,
                enum__Torappu_RoguelikeChoiceLeftDecoType::NONE,
            );
    }
    #[inline]
    pub fn add_nextSceneId(&mut self, nextSceneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameChoiceData::VT_NEXTSCENEID,
            nextSceneId,
        );
    }
    #[inline]
    pub fn add_icon(&mut self, icon: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameChoiceData::VT_ICON,
            icon,
        );
    }
    #[inline]
    pub fn add_displayData(
        &mut self,
        displayData: flatbuffers::WIPOffset<clz_Torappu_RoguelikeChoiceDisplayData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeChoiceDisplayData>>(
                clz_Torappu_RoguelikeGameChoiceData::VT_DISPLAYDATA,
                displayData,
            );
    }
    #[inline]
    pub fn add_forceShowWhenOnlyLeave(&mut self, forceShowWhenOnlyLeave: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeGameChoiceData::VT_FORCESHOWWHENONLYLEAVE,
            forceShowWhenOnlyLeave,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameChoiceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameChoiceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameChoiceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameChoiceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameChoiceData");
        ds.field("id", &self.id());
        ds.field("title", &self.title());
        ds.field("description", &self.description());
        ds.field("lockedCoverDesc", &self.lockedCoverDesc());
        ds.field("type_", &self.type_());
        ds.field("leftDecoType", &self.leftDecoType());
        ds.field("nextSceneId", &self.nextSceneId());
        ds.field("icon", &self.icon());
        ds.field("displayData", &self.displayData());
        ds.field("forceShowWhenOnlyLeave", &self.forceShowWhenOnlyLeave());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameChoiceDataT {
    pub id: Option<String>,
    pub title: Option<String>,
    pub description: Option<String>,
    pub lockedCoverDesc: Option<String>,
    pub type_: enum__Torappu_RoguelikeGameChoiceType,
    pub leftDecoType: enum__Torappu_RoguelikeChoiceLeftDecoType,
    pub nextSceneId: Option<String>,
    pub icon: Option<String>,
    pub displayData: Option<Box<clz_Torappu_RoguelikeChoiceDisplayDataT>>,
    pub forceShowWhenOnlyLeave: bool,
}
impl Default for clz_Torappu_RoguelikeGameChoiceDataT {
    fn default() -> Self {
        Self {
            id: None,
            title: None,
            description: None,
            lockedCoverDesc: None,
            type_: enum__Torappu_RoguelikeGameChoiceType::NONE,
            leftDecoType: enum__Torappu_RoguelikeChoiceLeftDecoType::NONE,
            nextSceneId: None,
            icon: None,
            displayData: None,
            forceShowWhenOnlyLeave: false,
        }
    }
}
impl clz_Torappu_RoguelikeGameChoiceDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameChoiceData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let title = self.title.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let lockedCoverDesc = self.lockedCoverDesc.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let leftDecoType = self.leftDecoType;
        let nextSceneId = self.nextSceneId.as_ref().map(|x| _fbb.create_string(x));
        let icon = self.icon.as_ref().map(|x| _fbb.create_string(x));
        let displayData = self.displayData.as_ref().map(|x| x.pack(_fbb));
        let forceShowWhenOnlyLeave = self.forceShowWhenOnlyLeave;
        clz_Torappu_RoguelikeGameChoiceData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameChoiceDataArgs {
                id,
                title,
                description,
                lockedCoverDesc,
                type_,
                leftDecoType,
                nextSceneId,
                icon,
                displayData,
                forceShowWhenOnlyLeave,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameChoiceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameChoiceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameChoiceData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameChoiceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameChoiceData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameChoiceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameChoiceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameChoiceData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameChoiceDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameChoiceDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameChoiceDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameChoiceData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameChoiceData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameChoiceData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameChoiceData>>(
                    dict__string__clz_Torappu_RoguelikeGameChoiceData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameChoiceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameChoiceData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameChoiceDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameChoiceData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameChoiceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameChoiceDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameChoiceData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeGameChoiceData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameChoiceDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameChoiceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameChoiceData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameChoiceData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameChoiceData>>(
                dict__string__clz_Torappu_RoguelikeGameChoiceData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameChoiceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameChoiceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameChoiceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameChoiceData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameChoiceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameChoiceData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameChoiceDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameChoiceDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameChoiceDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameChoiceDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameChoiceData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameChoiceData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameChoiceDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameChoiceSceneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameChoiceSceneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameChoiceSceneData<'a> {
    type Inner = clz_Torappu_RoguelikeGameChoiceSceneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameChoiceSceneData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TITLE: flatbuffers::VOffsetT = 6;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
    pub const VT_BACKGROUND: flatbuffers::VOffsetT = 10;
    pub const VT_TITLEICON: flatbuffers::VOffsetT = 12;
    pub const VT_SUBTYPEID: flatbuffers::VOffsetT = 14;
    pub const VT_USEHIDDENMUSIC: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameChoiceSceneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameChoiceSceneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameChoiceSceneData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameChoiceSceneDataBuilder::new(_fbb);
        builder.add_subTypeId(args.subTypeId);
        if let Some(x) = args.titleIcon {
            builder.add_titleIcon(x);
        }
        if let Some(x) = args.background {
            builder.add_background(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_useHiddenMusic(args.useHiddenMusic);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameChoiceSceneDataT {
        let id = self.id().map(|x| x.to_string());
        let title = self.title().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let background = self.background().map(|x| x.to_string());
        let titleIcon = self.titleIcon().map(|x| x.to_string());
        let subTypeId = self.subTypeId();
        let useHiddenMusic = self.useHiddenMusic();
        clz_Torappu_RoguelikeGameChoiceSceneDataT {
            id,
            title,
            description,
            background,
            titleIcon,
            subTypeId,
            useHiddenMusic,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameChoiceSceneData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameChoiceSceneData::VT_TITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameChoiceSceneData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn background(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameChoiceSceneData::VT_BACKGROUND,
                None,
            )
        }
    }
    #[inline]
    pub fn titleIcon(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameChoiceSceneData::VT_TITLEICON,
                None,
            )
        }
    }
    #[inline]
    pub fn subTypeId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeGameChoiceSceneData::VT_SUBTYPEID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn useHiddenMusic(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeGameChoiceSceneData::VT_USEHIDDENMUSIC,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameChoiceSceneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "background",
                Self::VT_BACKGROUND,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "titleIcon",
                Self::VT_TITLEICON,
                false,
            )?
            .visit_field::<i32>("subTypeId", Self::VT_SUBTYPEID, false)?
            .visit_field::<bool>("useHiddenMusic", Self::VT_USEHIDDENMUSIC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameChoiceSceneDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub background: Option<flatbuffers::WIPOffset<&'a str>>,
    pub titleIcon: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subTypeId: i32,
    pub useHiddenMusic: bool,
}
impl<'a> Default for clz_Torappu_RoguelikeGameChoiceSceneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameChoiceSceneDataArgs {
            id: None,
            title: None,
            description: None,
            background: None,
            titleIcon: None,
            subTypeId: 0,
            useHiddenMusic: false,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameChoiceSceneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameChoiceSceneData", 7)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.title() {
            s.serialize_field("title", &f)?;
        } else {
            s.skip_field("title")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.background() {
            s.serialize_field("background", &f)?;
        } else {
            s.skip_field("background")?;
        }
        if let Some(f) = self.titleIcon() {
            s.serialize_field("titleIcon", &f)?;
        } else {
            s.skip_field("titleIcon")?;
        }
        s.serialize_field("subTypeId", &self.subTypeId())?;
        s.serialize_field("useHiddenMusic", &self.useHiddenMusic())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameChoiceSceneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameChoiceSceneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameChoiceSceneData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameChoiceSceneData::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameChoiceSceneData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_background(&mut self, background: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameChoiceSceneData::VT_BACKGROUND,
            background,
        );
    }
    #[inline]
    pub fn add_titleIcon(&mut self, titleIcon: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameChoiceSceneData::VT_TITLEICON,
            titleIcon,
        );
    }
    #[inline]
    pub fn add_subTypeId(&mut self, subTypeId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameChoiceSceneData::VT_SUBTYPEID,
            subTypeId,
            0,
        );
    }
    #[inline]
    pub fn add_useHiddenMusic(&mut self, useHiddenMusic: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeGameChoiceSceneData::VT_USEHIDDENMUSIC,
            useHiddenMusic,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameChoiceSceneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameChoiceSceneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameChoiceSceneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameChoiceSceneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameChoiceSceneData");
        ds.field("id", &self.id());
        ds.field("title", &self.title());
        ds.field("description", &self.description());
        ds.field("background", &self.background());
        ds.field("titleIcon", &self.titleIcon());
        ds.field("subTypeId", &self.subTypeId());
        ds.field("useHiddenMusic", &self.useHiddenMusic());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameChoiceSceneDataT {
    pub id: Option<String>,
    pub title: Option<String>,
    pub description: Option<String>,
    pub background: Option<String>,
    pub titleIcon: Option<String>,
    pub subTypeId: i32,
    pub useHiddenMusic: bool,
}
impl Default for clz_Torappu_RoguelikeGameChoiceSceneDataT {
    fn default() -> Self {
        Self {
            id: None,
            title: None,
            description: None,
            background: None,
            titleIcon: None,
            subTypeId: 0,
            useHiddenMusic: false,
        }
    }
}
impl clz_Torappu_RoguelikeGameChoiceSceneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameChoiceSceneData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let title = self.title.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let background = self.background.as_ref().map(|x| _fbb.create_string(x));
        let titleIcon = self.titleIcon.as_ref().map(|x| _fbb.create_string(x));
        let subTypeId = self.subTypeId;
        let useHiddenMusic = self.useHiddenMusic;
        clz_Torappu_RoguelikeGameChoiceSceneData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameChoiceSceneDataArgs {
                id,
                title,
                description,
                background,
                titleIcon,
                subTypeId,
                useHiddenMusic,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameChoiceSceneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameChoiceSceneData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameChoiceSceneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameChoiceSceneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameChoiceSceneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameChoiceSceneData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameChoiceSceneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameChoiceSceneData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameChoiceSceneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameChoiceSceneData>>(
                    dict__string__clz_Torappu_RoguelikeGameChoiceSceneData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameChoiceSceneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameChoiceSceneData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameChoiceSceneData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameChoiceSceneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeGameChoiceSceneData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameChoiceSceneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameChoiceSceneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameChoiceSceneData>>(
                dict__string__clz_Torappu_RoguelikeGameChoiceSceneData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameChoiceSceneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameChoiceSceneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameChoiceSceneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameChoiceSceneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameChoiceSceneDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameChoiceSceneData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameChoiceSceneData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameNodeTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameNodeTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameNodeTypeData<'a> {
    type Inner = clz_Torappu_RoguelikeGameNodeTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameNodeTypeData<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameNodeTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameNodeTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameNodeTypeData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameNodeTypeDataBuilder::new(_fbb);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameNodeTypeDataT {
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        clz_Torappu_RoguelikeGameNodeTypeDataT { name, description }
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameNodeTypeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameNodeTypeData::VT_DESCRIPTION,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameNodeTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameNodeTypeDataArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeGameNodeTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameNodeTypeDataArgs {
            name: None,
            description: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameNodeTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameNodeTypeData", 2)?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameNodeTypeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameNodeTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameNodeTypeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameNodeTypeData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameNodeTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameNodeTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameNodeTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameNodeTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameNodeTypeData");
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameNodeTypeDataT {
    pub name: Option<String>,
    pub description: Option<String>,
}
impl Default for clz_Torappu_RoguelikeGameNodeTypeDataT {
    fn default() -> Self {
        Self {
            name: None,
            description: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameNodeTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameNodeTypeData<'b>> {
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeGameNodeTypeData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameNodeTypeDataArgs { name, description },
        )
    }
}
pub enum dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData<'a>
{
    type Inner = dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData<'bldr>,
    > {
        let mut builder = dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(
        &self,
    ) -> dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataT {
        let key = self.key();
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataT {
            key,
            value,
        }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_RoguelikeEventType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<enum__Torappu_RoguelikeEventType>(dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData::VT_KEY, Some(enum__Torappu_RoguelikeEventType::NONE)).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_RoguelikeEventType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameNodeTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameNodeTypeData>>(dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeEventType>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameNodeTypeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataArgs<'a> {
    pub key: enum__Torappu_RoguelikeEventType,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameNodeTypeData<'a>>>,
}
impl<'a> Default
    for dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataArgs {
            key: enum__Torappu_RoguelikeEventType::NONE,
            value: None,
        }
    }
}

impl Serialize
    for dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData<'_>
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_RoguelikeEventType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeEventType>(
            dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData::VT_KEY,
            key,
            enum__Torappu_RoguelikeEventType::NONE,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameNodeTypeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameNodeTypeData>>(
            dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataBuilder<
        'a,
        'b,
        A,
    > {
        let start = _fbb.start_table();
        dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData",
        );
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataT {
    pub key: enum__Torappu_RoguelikeEventType,
    pub value: Option<Box<clz_Torappu_RoguelikeGameNodeTypeDataT>>,
}
impl Default for dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataT {
    fn default() -> Self {
        Self {
            key: enum__Torappu_RoguelikeEventType::NONE,
            value: None,
        }
    }
}
impl dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData<'b>,
    > {
        let key = self.key;
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData::create(
            _fbb,
            &dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataArgs {
                key,
                value,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameNodeSubTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameNodeSubTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameNodeSubTypeData<'a> {
    type Inner = clz_Torappu_RoguelikeGameNodeSubTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameNodeSubTypeData<'a> {
    pub const VT_EVENTTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_SUBTYPEID: flatbuffers::VOffsetT = 6;
    pub const VT_ICONID: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameNodeSubTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameNodeSubTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameNodeSubTypeData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameNodeSubTypeDataBuilder::new(_fbb);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        builder.add_subTypeId(args.subTypeId);
        builder.add_eventType(args.eventType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameNodeSubTypeDataT {
        let eventType = self.eventType();
        let subTypeId = self.subTypeId();
        let iconId = self.iconId().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        clz_Torappu_RoguelikeGameNodeSubTypeDataT {
            eventType,
            subTypeId,
            iconId,
            name,
            description,
        }
    }

    #[inline]
    pub fn eventType(&self) -> enum__Torappu_RoguelikeEventType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeEventType>(
                    clz_Torappu_RoguelikeGameNodeSubTypeData::VT_EVENTTYPE,
                    Some(enum__Torappu_RoguelikeEventType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn subTypeId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeGameNodeSubTypeData::VT_SUBTYPEID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameNodeSubTypeData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameNodeSubTypeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameNodeSubTypeData::VT_DESCRIPTION,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameNodeSubTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeEventType>(
                "eventType",
                Self::VT_EVENTTYPE,
                false,
            )?
            .visit_field::<i32>("subTypeId", Self::VT_SUBTYPEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameNodeSubTypeDataArgs<'a> {
    pub eventType: enum__Torappu_RoguelikeEventType,
    pub subTypeId: i32,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeGameNodeSubTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameNodeSubTypeDataArgs {
            eventType: enum__Torappu_RoguelikeEventType::NONE,
            subTypeId: 0,
            iconId: None,
            name: None,
            description: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameNodeSubTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameNodeSubTypeData", 5)?;
        s.serialize_field("eventType", &self.eventType())?;
        s.serialize_field("subTypeId", &self.subTypeId())?;
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameNodeSubTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameNodeSubTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_eventType(&mut self, eventType: enum__Torappu_RoguelikeEventType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeEventType>(
            clz_Torappu_RoguelikeGameNodeSubTypeData::VT_EVENTTYPE,
            eventType,
            enum__Torappu_RoguelikeEventType::NONE,
        );
    }
    #[inline]
    pub fn add_subTypeId(&mut self, subTypeId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameNodeSubTypeData::VT_SUBTYPEID,
            subTypeId,
            0,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameNodeSubTypeData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameNodeSubTypeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameNodeSubTypeData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameNodeSubTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameNodeSubTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameNodeSubTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameNodeSubTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameNodeSubTypeData");
        ds.field("eventType", &self.eventType());
        ds.field("subTypeId", &self.subTypeId());
        ds.field("iconId", &self.iconId());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameNodeSubTypeDataT {
    pub eventType: enum__Torappu_RoguelikeEventType,
    pub subTypeId: i32,
    pub iconId: Option<String>,
    pub name: Option<String>,
    pub description: Option<String>,
}
impl Default for clz_Torappu_RoguelikeGameNodeSubTypeDataT {
    fn default() -> Self {
        Self {
            eventType: enum__Torappu_RoguelikeEventType::NONE,
            subTypeId: 0,
            iconId: None,
            name: None,
            description: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameNodeSubTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameNodeSubTypeData<'b>> {
        let eventType = self.eventType;
        let subTypeId = self.subTypeId;
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeGameNodeSubTypeData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameNodeSubTypeDataArgs {
                eventType,
                subTypeId,
                iconId,
                name,
                description,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameVariationDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameVariationData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameVariationData<'a> {
    type Inner = clz_Torappu_RoguelikeGameVariationData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameVariationData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_OUTERNAME: flatbuffers::VOffsetT = 8;
    pub const VT_INNERNAME: flatbuffers::VOffsetT = 10;
    pub const VT_FUNCTIONDESC: flatbuffers::VOffsetT = 12;
    pub const VT_DESC: flatbuffers::VOffsetT = 14;
    pub const VT_ICONID: flatbuffers::VOffsetT = 16;
    pub const VT_SOUND: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameVariationData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameVariationDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameVariationData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameVariationDataBuilder::new(_fbb);
        if let Some(x) = args.sound {
            builder.add_sound(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.functionDesc {
            builder.add_functionDesc(x);
        }
        if let Some(x) = args.innerName {
            builder.add_innerName(x);
        }
        if let Some(x) = args.outerName {
            builder.add_outerName(x);
        }
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameVariationDataT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        let outerName = self.outerName().map(|x| x.to_string());
        let innerName = self.innerName().map(|x| x.to_string());
        let functionDesc = self.functionDesc().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        let sound = self.sound().map(|x| x.to_string());
        clz_Torappu_RoguelikeGameVariationDataT {
            id,
            type_,
            outerName,
            innerName,
            functionDesc,
            desc,
            iconId,
            sound,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameVariationData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_RoguelikeGameVariationType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeGameVariationType>(
                    clz_Torappu_RoguelikeGameVariationData::VT_TYPE_,
                    Some(enum__Torappu_RoguelikeGameVariationType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn outerName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameVariationData::VT_OUTERNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn innerName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameVariationData::VT_INNERNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn functionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameVariationData::VT_FUNCTIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameVariationData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameVariationData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn sound(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameVariationData::VT_SOUND,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameVariationData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_RoguelikeGameVariationType>(
                "type_",
                Self::VT_TYPE_,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "outerName",
                Self::VT_OUTERNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "innerName",
                Self::VT_INNERNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "functionDesc",
                Self::VT_FUNCTIONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sound", Self::VT_SOUND, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameVariationDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_RoguelikeGameVariationType,
    pub outerName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub innerName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub functionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sound: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeGameVariationDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameVariationDataArgs {
            id: None,
            type_: enum__Torappu_RoguelikeGameVariationType::NONE,
            outerName: None,
            innerName: None,
            functionDesc: None,
            desc: None,
            iconId: None,
            sound: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameVariationData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameVariationData", 8)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.outerName() {
            s.serialize_field("outerName", &f)?;
        } else {
            s.skip_field("outerName")?;
        }
        if let Some(f) = self.innerName() {
            s.serialize_field("innerName", &f)?;
        } else {
            s.skip_field("innerName")?;
        }
        if let Some(f) = self.functionDesc() {
            s.serialize_field("functionDesc", &f)?;
        } else {
            s.skip_field("functionDesc")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.sound() {
            s.serialize_field("sound", &f)?;
        } else {
            s.skip_field("sound")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameVariationDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameVariationDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameVariationData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_RoguelikeGameVariationType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeGameVariationType>(
                clz_Torappu_RoguelikeGameVariationData::VT_TYPE_,
                type_,
                enum__Torappu_RoguelikeGameVariationType::NONE,
            );
    }
    #[inline]
    pub fn add_outerName(&mut self, outerName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameVariationData::VT_OUTERNAME,
            outerName,
        );
    }
    #[inline]
    pub fn add_innerName(&mut self, innerName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameVariationData::VT_INNERNAME,
            innerName,
        );
    }
    #[inline]
    pub fn add_functionDesc(&mut self, functionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameVariationData::VT_FUNCTIONDESC,
            functionDesc,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameVariationData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameVariationData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_sound(&mut self, sound: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameVariationData::VT_SOUND,
            sound,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameVariationDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameVariationDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameVariationData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameVariationData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameVariationData");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("outerName", &self.outerName());
        ds.field("innerName", &self.innerName());
        ds.field("functionDesc", &self.functionDesc());
        ds.field("desc", &self.desc());
        ds.field("iconId", &self.iconId());
        ds.field("sound", &self.sound());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameVariationDataT {
    pub id: Option<String>,
    pub type_: enum__Torappu_RoguelikeGameVariationType,
    pub outerName: Option<String>,
    pub innerName: Option<String>,
    pub functionDesc: Option<String>,
    pub desc: Option<String>,
    pub iconId: Option<String>,
    pub sound: Option<String>,
}
impl Default for clz_Torappu_RoguelikeGameVariationDataT {
    fn default() -> Self {
        Self {
            id: None,
            type_: enum__Torappu_RoguelikeGameVariationType::NONE,
            outerName: None,
            innerName: None,
            functionDesc: None,
            desc: None,
            iconId: None,
            sound: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameVariationDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameVariationData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let outerName = self.outerName.as_ref().map(|x| _fbb.create_string(x));
        let innerName = self.innerName.as_ref().map(|x| _fbb.create_string(x));
        let functionDesc = self.functionDesc.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let sound = self.sound.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeGameVariationData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameVariationDataArgs {
                id,
                type_,
                outerName,
                innerName,
                functionDesc,
                desc,
                iconId,
                sound,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameVariationDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameVariationData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameVariationData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameVariationData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameVariationData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameVariationData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameVariationDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameVariationData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameVariationDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameVariationDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameVariationDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameVariationData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameVariationData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameVariationData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameVariationData>>(
                    dict__string__clz_Torappu_RoguelikeGameVariationData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameVariationData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameVariationData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameVariationDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameVariationData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameVariationDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameVariationDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameVariationData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeGameVariationData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameVariationDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameVariationDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameVariationData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameVariationData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameVariationData>>(
                dict__string__clz_Torappu_RoguelikeGameVariationData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameVariationDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameVariationDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameVariationData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameVariationData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameVariationData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameVariationData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameVariationDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameVariationDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameVariationDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameVariationDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameVariationData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameVariationData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameVariationDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameFusionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameFusionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameFusionData<'a> {
    type Inner = clz_Torappu_RoguelikeGameFusionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameFusionData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_FUNCTIONDESC: flatbuffers::VOffsetT = 10;
    pub const VT_DESC: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameFusionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameFusionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameFusionData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameFusionDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.functionDesc {
            builder.add_functionDesc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameFusionDataT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        let name = self.name().map(|x| x.to_string());
        let functionDesc = self.functionDesc().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        clz_Torappu_RoguelikeGameFusionDataT {
            id,
            type_,
            name,
            functionDesc,
            desc,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameFusionData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_RoguelikeGameVariationType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeGameVariationType>(
                    clz_Torappu_RoguelikeGameFusionData::VT_TYPE_,
                    Some(enum__Torappu_RoguelikeGameVariationType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameFusionData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn functionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameFusionData::VT_FUNCTIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameFusionData::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameFusionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_RoguelikeGameVariationType>(
                "type_",
                Self::VT_TYPE_,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "functionDesc",
                Self::VT_FUNCTIONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameFusionDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_RoguelikeGameVariationType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub functionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeGameFusionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameFusionDataArgs {
            id: None,
            type_: enum__Torappu_RoguelikeGameVariationType::NONE,
            name: None,
            functionDesc: None,
            desc: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameFusionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameFusionData", 5)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.functionDesc() {
            s.serialize_field("functionDesc", &f)?;
        } else {
            s.skip_field("functionDesc")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameFusionDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameFusionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameFusionData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_RoguelikeGameVariationType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeGameVariationType>(
                clz_Torappu_RoguelikeGameFusionData::VT_TYPE_,
                type_,
                enum__Torappu_RoguelikeGameVariationType::NONE,
            );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameFusionData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_functionDesc(&mut self, functionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameFusionData::VT_FUNCTIONDESC,
            functionDesc,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameFusionData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameFusionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameFusionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameFusionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameFusionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameFusionData");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("name", &self.name());
        ds.field("functionDesc", &self.functionDesc());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameFusionDataT {
    pub id: Option<String>,
    pub type_: enum__Torappu_RoguelikeGameVariationType,
    pub name: Option<String>,
    pub functionDesc: Option<String>,
    pub desc: Option<String>,
}
impl Default for clz_Torappu_RoguelikeGameFusionDataT {
    fn default() -> Self {
        Self {
            id: None,
            type_: enum__Torappu_RoguelikeGameVariationType::NONE,
            name: None,
            functionDesc: None,
            desc: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameFusionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameFusionData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let functionDesc = self.functionDesc.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeGameFusionData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameFusionDataArgs {
                id,
                type_,
                name,
                functionDesc,
                desc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameFusionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameFusionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameFusionData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameFusionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameFusionData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameFusionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameFusionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameFusionData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameFusionDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameFusionDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameFusionDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameFusionData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameFusionData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameFusionData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameFusionData>>(
                    dict__string__clz_Torappu_RoguelikeGameFusionData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameFusionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameFusionData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameFusionDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameFusionData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameFusionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameFusionDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameFusionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeGameFusionData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameFusionDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameFusionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameFusionData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameFusionData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameFusionData>>(
                dict__string__clz_Torappu_RoguelikeGameFusionData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameFusionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameFusionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameFusionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameFusionData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameFusionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameFusionData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameFusionDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameFusionDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameFusionDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameFusionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameFusionData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameFusionData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameFusionDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameCharBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameCharBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameCharBuffData<'a> {
    type Inner = clz_Torappu_RoguelikeGameCharBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameCharBuffData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_BUFFTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_ICONID: flatbuffers::VOffsetT = 8;
    pub const VT_OUTERNAME: flatbuffers::VOffsetT = 10;
    pub const VT_INNERNAME: flatbuffers::VOffsetT = 12;
    pub const VT_FUNCTIONDESC: flatbuffers::VOffsetT = 14;
    pub const VT_DESC: flatbuffers::VOffsetT = 16;
    pub const VT_BUFFS: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameCharBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameCharBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameCharBuffData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameCharBuffDataBuilder::new(_fbb);
        if let Some(x) = args.buffs {
            builder.add_buffs(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.functionDesc {
            builder.add_functionDesc(x);
        }
        if let Some(x) = args.innerName {
            builder.add_innerName(x);
        }
        if let Some(x) = args.outerName {
            builder.add_outerName(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        builder.add_buffType(args.buffType);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameCharBuffDataT {
        let id = self.id().map(|x| x.to_string());
        let buffType = self.buffType();
        let iconId = self.iconId().map(|x| x.to_string());
        let outerName = self.outerName().map(|x| x.to_string());
        let innerName = self.innerName().map(|x| x.to_string());
        let functionDesc = self.functionDesc().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let buffs = self.buffs().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeGameCharBuffDataT {
            id,
            buffType,
            iconId,
            outerName,
            innerName,
            functionDesc,
            desc,
            buffs,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameCharBuffData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn buffType(&self) -> enum__Torappu_RoguelikeGameCharBuffType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeGameCharBuffType>(
                    clz_Torappu_RoguelikeGameCharBuffData::VT_BUFFTYPE,
                    Some(enum__Torappu_RoguelikeGameCharBuffType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameCharBuffData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn outerName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameCharBuffData::VT_OUTERNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn innerName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameCharBuffData::VT_INNERNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn functionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameCharBuffData::VT_FUNCTIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameCharBuffData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn buffs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBuff<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBuff>>,
            >>(clz_Torappu_RoguelikeGameCharBuffData::VT_BUFFS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameCharBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_RoguelikeGameCharBuffType>(
                "buffType",
                Self::VT_BUFFTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "outerName",
                Self::VT_OUTERNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "innerName",
                Self::VT_INNERNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "functionDesc",
                Self::VT_FUNCTIONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBuff>>,
            >>("buffs", Self::VT_BUFFS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameCharBuffDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffType: enum__Torappu_RoguelikeGameCharBuffType,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub outerName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub innerName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub functionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBuff<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeGameCharBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameCharBuffDataArgs {
            id: None,
            buffType: enum__Torappu_RoguelikeGameCharBuffType::NONE,
            iconId: None,
            outerName: None,
            innerName: None,
            functionDesc: None,
            desc: None,
            buffs: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameCharBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameCharBuffData", 8)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("buffType", &self.buffType())?;
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.outerName() {
            s.serialize_field("outerName", &f)?;
        } else {
            s.skip_field("outerName")?;
        }
        if let Some(f) = self.innerName() {
            s.serialize_field("innerName", &f)?;
        } else {
            s.skip_field("innerName")?;
        }
        if let Some(f) = self.functionDesc() {
            s.serialize_field("functionDesc", &f)?;
        } else {
            s.skip_field("functionDesc")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.buffs() {
            s.serialize_field("buffs", &f)?;
        } else {
            s.skip_field("buffs")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameCharBuffDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameCharBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameCharBuffData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_buffType(&mut self, buffType: enum__Torappu_RoguelikeGameCharBuffType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeGameCharBuffType>(
                clz_Torappu_RoguelikeGameCharBuffData::VT_BUFFTYPE,
                buffType,
                enum__Torappu_RoguelikeGameCharBuffType::NONE,
            );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameCharBuffData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_outerName(&mut self, outerName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameCharBuffData::VT_OUTERNAME,
            outerName,
        );
    }
    #[inline]
    pub fn add_innerName(&mut self, innerName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameCharBuffData::VT_INNERNAME,
            innerName,
        );
    }
    #[inline]
    pub fn add_functionDesc(&mut self, functionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameCharBuffData::VT_FUNCTIONDESC,
            functionDesc,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameCharBuffData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_buffs(
        &mut self,
        buffs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBuff<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameCharBuffData::VT_BUFFS,
            buffs,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameCharBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameCharBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameCharBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameCharBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameCharBuffData");
        ds.field("id", &self.id());
        ds.field("buffType", &self.buffType());
        ds.field("iconId", &self.iconId());
        ds.field("outerName", &self.outerName());
        ds.field("innerName", &self.innerName());
        ds.field("functionDesc", &self.functionDesc());
        ds.field("desc", &self.desc());
        ds.field("buffs", &self.buffs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameCharBuffDataT {
    pub id: Option<String>,
    pub buffType: enum__Torappu_RoguelikeGameCharBuffType,
    pub iconId: Option<String>,
    pub outerName: Option<String>,
    pub innerName: Option<String>,
    pub functionDesc: Option<String>,
    pub desc: Option<String>,
    pub buffs: Option<Vec<clz_Torappu_RoguelikeBuffT>>,
}
impl Default for clz_Torappu_RoguelikeGameCharBuffDataT {
    fn default() -> Self {
        Self {
            id: None,
            buffType: enum__Torappu_RoguelikeGameCharBuffType::NONE,
            iconId: None,
            outerName: None,
            innerName: None,
            functionDesc: None,
            desc: None,
            buffs: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameCharBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameCharBuffData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let buffType = self.buffType;
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let outerName = self.outerName.as_ref().map(|x| _fbb.create_string(x));
        let innerName = self.innerName.as_ref().map(|x| _fbb.create_string(x));
        let functionDesc = self.functionDesc.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let buffs = self.buffs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeGameCharBuffData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameCharBuffDataArgs {
                id,
                buffType,
                iconId,
                outerName,
                innerName,
                functionDesc,
                desc,
                buffs,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameCharBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameCharBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameCharBuffData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameCharBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameCharBuffData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameCharBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameCharBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameCharBuffData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameCharBuffDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameCharBuffDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameCharBuffDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameCharBuffData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameCharBuffData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameCharBuffData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameCharBuffData>>(
                    dict__string__clz_Torappu_RoguelikeGameCharBuffData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameCharBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameCharBuffData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameCharBuffDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameCharBuffData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameCharBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameCharBuffDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameCharBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeGameCharBuffData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameCharBuffDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameCharBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameCharBuffData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameCharBuffData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameCharBuffData>>(
                dict__string__clz_Torappu_RoguelikeGameCharBuffData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameCharBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameCharBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameCharBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameCharBuffData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameCharBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameCharBuffData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameCharBuffDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameCharBuffDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameCharBuffDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameCharBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameCharBuffData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameCharBuffData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameCharBuffDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameSquadBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameSquadBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameSquadBuffData<'a> {
    type Inner = clz_Torappu_RoguelikeGameSquadBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameSquadBuffData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_ICONID: flatbuffers::VOffsetT = 6;
    pub const VT_OUTERNAME: flatbuffers::VOffsetT = 8;
    pub const VT_INNERNAME: flatbuffers::VOffsetT = 10;
    pub const VT_FUNCTIONDESC: flatbuffers::VOffsetT = 12;
    pub const VT_DESC: flatbuffers::VOffsetT = 14;
    pub const VT_BUFFS: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameSquadBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameSquadBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameSquadBuffData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameSquadBuffDataBuilder::new(_fbb);
        if let Some(x) = args.buffs {
            builder.add_buffs(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.functionDesc {
            builder.add_functionDesc(x);
        }
        if let Some(x) = args.innerName {
            builder.add_innerName(x);
        }
        if let Some(x) = args.outerName {
            builder.add_outerName(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameSquadBuffDataT {
        let id = self.id().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        let outerName = self.outerName().map(|x| x.to_string());
        let innerName = self.innerName().map(|x| x.to_string());
        let functionDesc = self.functionDesc().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let buffs = self.buffs().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeGameSquadBuffDataT {
            id,
            iconId,
            outerName,
            innerName,
            functionDesc,
            desc,
            buffs,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameSquadBuffData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameSquadBuffData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn outerName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameSquadBuffData::VT_OUTERNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn innerName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameSquadBuffData::VT_INNERNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn functionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameSquadBuffData::VT_FUNCTIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameSquadBuffData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn buffs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBuff<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBuff>>,
            >>(clz_Torappu_RoguelikeGameSquadBuffData::VT_BUFFS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameSquadBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "outerName",
                Self::VT_OUTERNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "innerName",
                Self::VT_INNERNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "functionDesc",
                Self::VT_FUNCTIONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBuff>>,
            >>("buffs", Self::VT_BUFFS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameSquadBuffDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub outerName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub innerName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub functionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBuff<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeGameSquadBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameSquadBuffDataArgs {
            id: None,
            iconId: None,
            outerName: None,
            innerName: None,
            functionDesc: None,
            desc: None,
            buffs: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameSquadBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameSquadBuffData", 7)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.outerName() {
            s.serialize_field("outerName", &f)?;
        } else {
            s.skip_field("outerName")?;
        }
        if let Some(f) = self.innerName() {
            s.serialize_field("innerName", &f)?;
        } else {
            s.skip_field("innerName")?;
        }
        if let Some(f) = self.functionDesc() {
            s.serialize_field("functionDesc", &f)?;
        } else {
            s.skip_field("functionDesc")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.buffs() {
            s.serialize_field("buffs", &f)?;
        } else {
            s.skip_field("buffs")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameSquadBuffDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameSquadBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameSquadBuffData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameSquadBuffData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_outerName(&mut self, outerName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameSquadBuffData::VT_OUTERNAME,
            outerName,
        );
    }
    #[inline]
    pub fn add_innerName(&mut self, innerName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameSquadBuffData::VT_INNERNAME,
            innerName,
        );
    }
    #[inline]
    pub fn add_functionDesc(&mut self, functionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameSquadBuffData::VT_FUNCTIONDESC,
            functionDesc,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameSquadBuffData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_buffs(
        &mut self,
        buffs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBuff<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameSquadBuffData::VT_BUFFS,
            buffs,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameSquadBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameSquadBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameSquadBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameSquadBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameSquadBuffData");
        ds.field("id", &self.id());
        ds.field("iconId", &self.iconId());
        ds.field("outerName", &self.outerName());
        ds.field("innerName", &self.innerName());
        ds.field("functionDesc", &self.functionDesc());
        ds.field("desc", &self.desc());
        ds.field("buffs", &self.buffs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameSquadBuffDataT {
    pub id: Option<String>,
    pub iconId: Option<String>,
    pub outerName: Option<String>,
    pub innerName: Option<String>,
    pub functionDesc: Option<String>,
    pub desc: Option<String>,
    pub buffs: Option<Vec<clz_Torappu_RoguelikeBuffT>>,
}
impl Default for clz_Torappu_RoguelikeGameSquadBuffDataT {
    fn default() -> Self {
        Self {
            id: None,
            iconId: None,
            outerName: None,
            innerName: None,
            functionDesc: None,
            desc: None,
            buffs: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameSquadBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameSquadBuffData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let outerName = self.outerName.as_ref().map(|x| _fbb.create_string(x));
        let innerName = self.innerName.as_ref().map(|x| _fbb.create_string(x));
        let functionDesc = self.functionDesc.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let buffs = self.buffs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeGameSquadBuffData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameSquadBuffDataArgs {
                id,
                iconId,
                outerName,
                innerName,
                functionDesc,
                desc,
                buffs,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameSquadBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameSquadBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameSquadBuffData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameSquadBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameSquadBuffData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameSquadBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameSquadBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameSquadBuffData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameSquadBuffDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameSquadBuffDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameSquadBuffDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameSquadBuffData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameSquadBuffData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameSquadBuffData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameSquadBuffData>>(
                    dict__string__clz_Torappu_RoguelikeGameSquadBuffData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameSquadBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameSquadBuffData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameSquadBuffDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameSquadBuffData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameSquadBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameSquadBuffDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameSquadBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeGameSquadBuffData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameSquadBuffDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameSquadBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameSquadBuffData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameSquadBuffData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameSquadBuffData>>(
                dict__string__clz_Torappu_RoguelikeGameSquadBuffData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameSquadBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameSquadBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameSquadBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameSquadBuffData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameSquadBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameSquadBuffData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameSquadBuffDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameSquadBuffDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameSquadBuffDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameSquadBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameSquadBuffData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameSquadBuffData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameSquadBuffDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeTaskDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTaskData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTaskData<'a> {
    type Inner = clz_Torappu_RoguelikeTaskData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTaskData<'a> {
    pub const VT_TASKID: flatbuffers::VOffsetT = 4;
    pub const VT_TASKNAME: flatbuffers::VOffsetT = 6;
    pub const VT_TASKDESC: flatbuffers::VOffsetT = 8;
    pub const VT_REWARDSCENEID: flatbuffers::VOffsetT = 10;
    pub const VT_TASKRARITY: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTaskData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTaskDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTaskData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTaskDataBuilder::new(_fbb);
        builder.add_taskRarity(args.taskRarity);
        if let Some(x) = args.rewardSceneId {
            builder.add_rewardSceneId(x);
        }
        if let Some(x) = args.taskDesc {
            builder.add_taskDesc(x);
        }
        if let Some(x) = args.taskName {
            builder.add_taskName(x);
        }
        if let Some(x) = args.taskId {
            builder.add_taskId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTaskDataT {
        let taskId = self.taskId().map(|x| x.to_string());
        let taskName = self.taskName().map(|x| x.to_string());
        let taskDesc = self.taskDesc().map(|x| x.to_string());
        let rewardSceneId = self.rewardSceneId().map(|x| x.to_string());
        let taskRarity = self.taskRarity();
        clz_Torappu_RoguelikeTaskDataT {
            taskId,
            taskName,
            taskDesc,
            rewardSceneId,
            taskRarity,
        }
    }

    #[inline]
    pub fn taskId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTaskData::VT_TASKID,
                None,
            )
        }
    }
    #[inline]
    pub fn taskName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTaskData::VT_TASKNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn taskDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTaskData::VT_TASKDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardSceneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTaskData::VT_REWARDSCENEID,
                None,
            )
        }
    }
    #[inline]
    pub fn taskRarity(&self) -> enum__Torappu_RoguelikeTaskRarity {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTaskRarity>(
                    clz_Torappu_RoguelikeTaskData::VT_TASKRARITY,
                    Some(enum__Torappu_RoguelikeTaskRarity::NORMAL),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTaskData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("taskId", Self::VT_TASKID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "taskName",
                Self::VT_TASKNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "taskDesc",
                Self::VT_TASKDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardSceneId",
                Self::VT_REWARDSCENEID,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeTaskRarity>(
                "taskRarity",
                Self::VT_TASKRARITY,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTaskDataArgs<'a> {
    pub taskId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardSceneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub taskRarity: enum__Torappu_RoguelikeTaskRarity,
}
impl<'a> Default for clz_Torappu_RoguelikeTaskDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTaskDataArgs {
            taskId: None,
            taskName: None,
            taskDesc: None,
            rewardSceneId: None,
            taskRarity: enum__Torappu_RoguelikeTaskRarity::NORMAL,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTaskData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTaskData", 5)?;
        if let Some(f) = self.taskId() {
            s.serialize_field("taskId", &f)?;
        } else {
            s.skip_field("taskId")?;
        }
        if let Some(f) = self.taskName() {
            s.serialize_field("taskName", &f)?;
        } else {
            s.skip_field("taskName")?;
        }
        if let Some(f) = self.taskDesc() {
            s.serialize_field("taskDesc", &f)?;
        } else {
            s.skip_field("taskDesc")?;
        }
        if let Some(f) = self.rewardSceneId() {
            s.serialize_field("rewardSceneId", &f)?;
        } else {
            s.skip_field("rewardSceneId")?;
        }
        s.serialize_field("taskRarity", &self.taskRarity())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTaskDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RoguelikeTaskDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_taskId(&mut self, taskId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTaskData::VT_TASKID,
            taskId,
        );
    }
    #[inline]
    pub fn add_taskName(&mut self, taskName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTaskData::VT_TASKNAME,
            taskName,
        );
    }
    #[inline]
    pub fn add_taskDesc(&mut self, taskDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTaskData::VT_TASKDESC,
            taskDesc,
        );
    }
    #[inline]
    pub fn add_rewardSceneId(&mut self, rewardSceneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTaskData::VT_REWARDSCENEID,
            rewardSceneId,
        );
    }
    #[inline]
    pub fn add_taskRarity(&mut self, taskRarity: enum__Torappu_RoguelikeTaskRarity) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeTaskRarity>(
            clz_Torappu_RoguelikeTaskData::VT_TASKRARITY,
            taskRarity,
            enum__Torappu_RoguelikeTaskRarity::NORMAL,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTaskDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTaskDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTaskData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTaskData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTaskData");
        ds.field("taskId", &self.taskId());
        ds.field("taskName", &self.taskName());
        ds.field("taskDesc", &self.taskDesc());
        ds.field("rewardSceneId", &self.rewardSceneId());
        ds.field("taskRarity", &self.taskRarity());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTaskDataT {
    pub taskId: Option<String>,
    pub taskName: Option<String>,
    pub taskDesc: Option<String>,
    pub rewardSceneId: Option<String>,
    pub taskRarity: enum__Torappu_RoguelikeTaskRarity,
}
impl Default for clz_Torappu_RoguelikeTaskDataT {
    fn default() -> Self {
        Self {
            taskId: None,
            taskName: None,
            taskDesc: None,
            rewardSceneId: None,
            taskRarity: enum__Torappu_RoguelikeTaskRarity::NORMAL,
        }
    }
}
impl clz_Torappu_RoguelikeTaskDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTaskData<'b>> {
        let taskId = self.taskId.as_ref().map(|x| _fbb.create_string(x));
        let taskName = self.taskName.as_ref().map(|x| _fbb.create_string(x));
        let taskDesc = self.taskDesc.as_ref().map(|x| _fbb.create_string(x));
        let rewardSceneId = self.rewardSceneId.as_ref().map(|x| _fbb.create_string(x));
        let taskRarity = self.taskRarity;
        clz_Torappu_RoguelikeTaskData::create(
            _fbb,
            &clz_Torappu_RoguelikeTaskDataArgs {
                taskId,
                taskName,
                taskDesc,
                rewardSceneId,
                taskRarity,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeTaskDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeTaskData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeTaskData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeTaskData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeTaskData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeTaskData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeTaskDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTaskData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeTaskDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeTaskDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeTaskDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeTaskData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_RoguelikeTaskData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeTaskData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTaskData>>(
                    dict__string__clz_Torappu_RoguelikeTaskData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeTaskData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTaskData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeTaskDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTaskData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeTaskDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeTaskDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeTaskData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeTaskData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeTaskDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeTaskDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeTaskData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTaskData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTaskData>>(
                dict__string__clz_Torappu_RoguelikeTaskData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeTaskDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeTaskDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTaskData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeTaskData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeTaskData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeTaskData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeTaskDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeTaskDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeTaskDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeTaskDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTaskData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeTaskData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeTaskDataArgs { key, value },
        )
    }
}
pub enum dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string<'a>
{
    type Inner = dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string<'bldr>>
    {
        let mut builder =
            dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringT {
        let key = self.key();
        let value = self.value().map(|x| x.to_string());
        dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_RoguelikeRewardExDropTagSrcType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeRewardExDropTagSrcType>(
                    dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string::VT_KEY,
                    Some(enum__Torappu_RoguelikeRewardExDropTagSrcType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_RoguelikeRewardExDropTagSrcType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeRewardExDropTagSrcType>(
                "key",
                Self::VT_KEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringArgs<'a> {
    pub key: enum__Torappu_RoguelikeRewardExDropTagSrcType,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringArgs {
            key: enum__Torappu_RoguelikeRewardExDropTagSrcType::NONE,
            value: None,
        }
    }
}

impl Serialize for dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_RoguelikeRewardExDropTagSrcType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeRewardExDropTagSrcType>(
                dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string::VT_KEY,
                key,
                enum__Torappu_RoguelikeRewardExDropTagSrcType::NONE,
            );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringT {
    pub key: enum__Torappu_RoguelikeRewardExDropTagSrcType,
    pub value: Option<String>,
}
impl Default for dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringT {
    fn default() -> Self {
        Self {
            key: enum__Torappu_RoguelikeRewardExDropTagSrcType::NONE,
            value: None,
        }
    }
}
impl dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string<'b>>
    {
        let key = self.key;
        let value = self.value.as_ref().map(|x| _fbb.create_string(x));
        dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string::create(
            _fbb,
            &dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameConstOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameConst<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameConst<'a> {
    type Inner = clz_Torappu_RoguelikeGameConst<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameConst<'a> {
    pub const VT_INITSCENENAME: flatbuffers::VOffsetT = 4;
    pub const VT_FAILSCENENAME: flatbuffers::VOffsetT = 6;
    pub const VT_HPITEMID: flatbuffers::VOffsetT = 8;
    pub const VT_GOLDITEMID: flatbuffers::VOffsetT = 10;
    pub const VT_POPULATIONITEMID: flatbuffers::VOffsetT = 12;
    pub const VT_SQUADCAPACITYITEMID: flatbuffers::VOffsetT = 14;
    pub const VT_EXPITEMID: flatbuffers::VOffsetT = 16;
    pub const VT_INITIALBANDSHOWGRADEFLAG: flatbuffers::VOffsetT = 18;
    pub const VT_BANKMAXGOLD: flatbuffers::VOffsetT = 20;
    pub const VT_BANKCOSTID: flatbuffers::VOffsetT = 22;
    pub const VT_BANKDRAWCOUNT: flatbuffers::VOffsetT = 24;
    pub const VT_BANKDRAWLIMIT: flatbuffers::VOffsetT = 26;
    pub const VT_BANKREWARDCOUNTTYPE: flatbuffers::VOffsetT = 28;
    pub const VT_SPZONESHOPBGMSIGNAL: flatbuffers::VOffsetT = 30;
    pub const VT_MIMICENEMYIDS: flatbuffers::VOffsetT = 32;
    pub const VT_BOSSIDS: flatbuffers::VOffsetT = 34;
    pub const VT_GOLDCHESTTRAPID: flatbuffers::VOffsetT = 36;
    pub const VT_NORMBOXTRAPID: flatbuffers::VOffsetT = 38;
    pub const VT_RAREBOXTRAPID: flatbuffers::VOffsetT = 40;
    pub const VT_BADBOXTRAPID: flatbuffers::VOffsetT = 42;
    pub const VT_MAXHPITEMID: flatbuffers::VOffsetT = 44;
    pub const VT_SHIELDITEMID: flatbuffers::VOffsetT = 46;
    pub const VT_KEYITEMID: flatbuffers::VOffsetT = 48;
    pub const VT_DIVINATIONKITITEMID: flatbuffers::VOffsetT = 50;
    pub const VT_CHESTKEYCNT: flatbuffers::VOffsetT = 52;
    pub const VT_CHESTKEYITEMID: flatbuffers::VOffsetT = 54;
    pub const VT_KEYCOLORID: flatbuffers::VOffsetT = 56;
    pub const VT_ONCENODETYPELIST: flatbuffers::VOffsetT = 58;
    pub const VT_VERTNODECOSTDIALOGUSEITEMICONTYPE: flatbuffers::VOffsetT = 60;
    pub const VT_GPSCORERATIO: flatbuffers::VOffsetT = 62;
    pub const VT_OVERFLOWUSAGESQUADBUFF: flatbuffers::VOffsetT = 64;
    pub const VT_SPECIALTRAPID: flatbuffers::VOffsetT = 66;
    pub const VT_TRAPREWARDRELICID: flatbuffers::VOffsetT = 68;
    pub const VT_UNLOCKROUTEITEMID: flatbuffers::VOffsetT = 70;
    pub const VT_UNLOCKROUTEITEMCOUNT: flatbuffers::VOffsetT = 72;
    pub const VT_HIDEBATTLENODENAME: flatbuffers::VOffsetT = 74;
    pub const VT_HIDEBATTLENODEDESCRIPTION: flatbuffers::VOffsetT = 76;
    pub const VT_HIDENONBATTLENODENAME: flatbuffers::VOffsetT = 78;
    pub const VT_HIDENONBATTLENODEDESCRIPTION: flatbuffers::VOffsetT = 80;
    pub const VT_CHARSELECTEXPEDITIONCONFLICTTOAST: flatbuffers::VOffsetT = 82;
    pub const VT_CHARSELECTNOUPGRADECONFLICTTOAST: flatbuffers::VOffsetT = 84;
    pub const VT_ITEMDROPTAGDICT: flatbuffers::VOffsetT = 86;
    pub const VT_SHOPREFRESHCOSTID: flatbuffers::VOffsetT = 88;
    pub const VT_EXPEDITIONLEAVETOASTFORMAT: flatbuffers::VOffsetT = 90;
    pub const VT_EXPEDITIONRETURNDESCCUREUPGRADE: flatbuffers::VOffsetT = 92;
    pub const VT_EXPEDITIONRETURNDESCUPGRADE: flatbuffers::VOffsetT = 94;
    pub const VT_EXPEDITIONRETURNDESCCURE: flatbuffers::VOffsetT = 96;
    pub const VT_EXPEDITIONRETURNDESC: flatbuffers::VOffsetT = 98;
    pub const VT_EXPEDITIONSELECTDESCFORMAT: flatbuffers::VOffsetT = 100;
    pub const VT_EXPEDITIONRETURNDESCITEM: flatbuffers::VOffsetT = 102;
    pub const VT_EXPEDITIONRETURNREWARDBLACKLIST: flatbuffers::VOffsetT = 104;
    pub const VT_TRAVELLEAVETOASTFORMAT: flatbuffers::VOffsetT = 106;
    pub const VT_CHARSELECTTRAVELCONFLICTTOAST: flatbuffers::VOffsetT = 108;
    pub const VT_TRAVELRETURNDESCUPGRADE: flatbuffers::VOffsetT = 110;
    pub const VT_TRAVELRETURNDESC: flatbuffers::VOffsetT = 112;
    pub const VT_TRAVELRETURNDESCITEM: flatbuffers::VOffsetT = 114;
    pub const VT_TRADERRETURNTITLE: flatbuffers::VOffsetT = 116;
    pub const VT_TRADERRETURNDESC: flatbuffers::VOffsetT = 118;
    pub const VT_CANDLERETURNDESCCANDLEUPGRADE: flatbuffers::VOffsetT = 120;
    pub const VT_CANDLERETURNDESCCANDLE: flatbuffers::VOffsetT = 122;
    pub const VT_CHARSELECTCANDLECONFLICTTOAST: flatbuffers::VOffsetT = 124;
    pub const VT_CHARSELECTGUIDEDCONFLICTTOAST: flatbuffers::VOffsetT = 126;
    pub const VT_CHARSELECTNONGUIDEDCONFLICTTOAST: flatbuffers::VOffsetT = 128;
    pub const VT_GAINBUFFDIFFGRADE: flatbuffers::VOffsetT = 130;
    pub const VT_DSPREDICTTIPS: flatbuffers::VOffsetT = 132;
    pub const VT_DSBUFFACTIVETIPS: flatbuffers::VOffsetT = 134;
    pub const VT_TOTEMDESC: flatbuffers::VOffsetT = 136;
    pub const VT_COPPERGILDDESC: flatbuffers::VOffsetT = 138;
    pub const VT_RELICDESC: flatbuffers::VOffsetT = 140;
    pub const VT_BUFFDESC: flatbuffers::VOffsetT = 142;
    pub const VT_REFRESHNODEITEMID: flatbuffers::VOffsetT = 144;
    pub const VT_STORINGRECRUITDESC: flatbuffers::VOffsetT = 146;
    pub const VT_STORINGRECRUITSUCCEEDTOAST: flatbuffers::VOffsetT = 148;
    pub const VT_SPECIALRECRUITREDUCTIONDESC: flatbuffers::VOffsetT = 150;
    pub const VT_SPECIALRECRUITFUNCDESC: flatbuffers::VOffsetT = 152;
    pub const VT_SPECIALRECRUITDETAILDESC: flatbuffers::VOffsetT = 154;
    pub const VT_PORTALZONES: flatbuffers::VOffsetT = 156;
    pub const VT_DIFFDISPLAYZONEID: flatbuffers::VOffsetT = 158;
    pub const VT_EXPLOREEXPONKILL: flatbuffers::VOffsetT = 160;
    pub const VT_FUSIONNAME: flatbuffers::VOffsetT = 162;
    pub const VT_FUSIONNOTIFYTOAST: flatbuffers::VOffsetT = 164;
    pub const VT_HAVESPZONE: flatbuffers::VOffsetT = 166;
    pub const VT_GOTCHARCANDLEBUFFTOAST: flatbuffers::VOffsetT = 168;
    pub const VT_GOTCHARSCANDLEBUFFTOAST: flatbuffers::VOffsetT = 170;
    pub const VT_STASHEDRECRUITNODEDESCRIPTION: flatbuffers::VOffsetT = 172;
    pub const VT_STASHEDRECRUITEMPTYNODEDESCRIPTION: flatbuffers::VOffsetT = 174;
    pub const VT_RECRUITSTASHMAXNUM: flatbuffers::VOffsetT = 176;
    pub const VT_RECRUITSTASHMINNUM: flatbuffers::VOffsetT = 178;
    pub const VT_HASTOPICCHARSELECTMENUBUTTON: flatbuffers::VOffsetT = 180;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameConst { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameConstArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameConst<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameConstBuilder::new(_fbb);
        builder.add_recruitStashMinNum(args.recruitStashMinNum);
        builder.add_recruitStashMaxNum(args.recruitStashMaxNum);
        if let Some(x) = args.stashedRecruitEmptyNodeDescription {
            builder.add_stashedRecruitEmptyNodeDescription(x);
        }
        if let Some(x) = args.stashedRecruitNodeDescription {
            builder.add_stashedRecruitNodeDescription(x);
        }
        if let Some(x) = args.gotCharsCandleBuffToast {
            builder.add_gotCharsCandleBuffToast(x);
        }
        if let Some(x) = args.gotCharCandleBuffToast {
            builder.add_gotCharCandleBuffToast(x);
        }
        if let Some(x) = args.fusionNotifyToast {
            builder.add_fusionNotifyToast(x);
        }
        if let Some(x) = args.fusionName {
            builder.add_fusionName(x);
        }
        if let Some(x) = args.exploreExpOnKill {
            builder.add_exploreExpOnKill(x);
        }
        if let Some(x) = args.diffDisplayZoneId {
            builder.add_diffDisplayZoneId(x);
        }
        if let Some(x) = args.portalZones {
            builder.add_portalZones(x);
        }
        if let Some(x) = args.specialRecruitDetailDesc {
            builder.add_specialRecruitDetailDesc(x);
        }
        if let Some(x) = args.specialRecruitFuncDesc {
            builder.add_specialRecruitFuncDesc(x);
        }
        if let Some(x) = args.specialRecruitReductionDesc {
            builder.add_specialRecruitReductionDesc(x);
        }
        if let Some(x) = args.storingRecruitSucceedToast {
            builder.add_storingRecruitSucceedToast(x);
        }
        if let Some(x) = args.storingRecruitDesc {
            builder.add_storingRecruitDesc(x);
        }
        if let Some(x) = args.refreshNodeItemId {
            builder.add_refreshNodeItemId(x);
        }
        if let Some(x) = args.buffDesc {
            builder.add_buffDesc(x);
        }
        if let Some(x) = args.relicDesc {
            builder.add_relicDesc(x);
        }
        if let Some(x) = args.copperGildDesc {
            builder.add_copperGildDesc(x);
        }
        if let Some(x) = args.totemDesc {
            builder.add_totemDesc(x);
        }
        if let Some(x) = args.dsBuffActiveTips {
            builder.add_dsBuffActiveTips(x);
        }
        if let Some(x) = args.dsPredictTips {
            builder.add_dsPredictTips(x);
        }
        builder.add_gainBuffDiffGrade(args.gainBuffDiffGrade);
        if let Some(x) = args.charSelectNonGuidedConflictToast {
            builder.add_charSelectNonGuidedConflictToast(x);
        }
        if let Some(x) = args.charSelectGuidedConflictToast {
            builder.add_charSelectGuidedConflictToast(x);
        }
        if let Some(x) = args.charSelectCandleConflictToast {
            builder.add_charSelectCandleConflictToast(x);
        }
        if let Some(x) = args.candleReturnDescCandle {
            builder.add_candleReturnDescCandle(x);
        }
        if let Some(x) = args.candleReturnDescCandleUpgrade {
            builder.add_candleReturnDescCandleUpgrade(x);
        }
        if let Some(x) = args.traderReturnDesc {
            builder.add_traderReturnDesc(x);
        }
        if let Some(x) = args.traderReturnTitle {
            builder.add_traderReturnTitle(x);
        }
        if let Some(x) = args.travelReturnDescItem {
            builder.add_travelReturnDescItem(x);
        }
        if let Some(x) = args.travelReturnDesc {
            builder.add_travelReturnDesc(x);
        }
        if let Some(x) = args.travelReturnDescUpgrade {
            builder.add_travelReturnDescUpgrade(x);
        }
        if let Some(x) = args.charSelectTravelConflictToast {
            builder.add_charSelectTravelConflictToast(x);
        }
        if let Some(x) = args.travelLeaveToastFormat {
            builder.add_travelLeaveToastFormat(x);
        }
        if let Some(x) = args.expeditionReturnRewardBlackList {
            builder.add_expeditionReturnRewardBlackList(x);
        }
        if let Some(x) = args.expeditionReturnDescItem {
            builder.add_expeditionReturnDescItem(x);
        }
        if let Some(x) = args.expeditionSelectDescFormat {
            builder.add_expeditionSelectDescFormat(x);
        }
        if let Some(x) = args.expeditionReturnDesc {
            builder.add_expeditionReturnDesc(x);
        }
        if let Some(x) = args.expeditionReturnDescCure {
            builder.add_expeditionReturnDescCure(x);
        }
        if let Some(x) = args.expeditionReturnDescUpgrade {
            builder.add_expeditionReturnDescUpgrade(x);
        }
        if let Some(x) = args.expeditionReturnDescCureUpgrade {
            builder.add_expeditionReturnDescCureUpgrade(x);
        }
        if let Some(x) = args.expeditionLeaveToastFormat {
            builder.add_expeditionLeaveToastFormat(x);
        }
        if let Some(x) = args.shopRefreshCostId {
            builder.add_shopRefreshCostId(x);
        }
        if let Some(x) = args.itemDropTagDict {
            builder.add_itemDropTagDict(x);
        }
        if let Some(x) = args.charSelectNoUpgradeConflictToast {
            builder.add_charSelectNoUpgradeConflictToast(x);
        }
        if let Some(x) = args.charSelectExpeditionConflictToast {
            builder.add_charSelectExpeditionConflictToast(x);
        }
        if let Some(x) = args.hideNonBattleNodeDescription {
            builder.add_hideNonBattleNodeDescription(x);
        }
        if let Some(x) = args.hideNonBattleNodeName {
            builder.add_hideNonBattleNodeName(x);
        }
        if let Some(x) = args.hideBattleNodeDescription {
            builder.add_hideBattleNodeDescription(x);
        }
        if let Some(x) = args.hideBattleNodeName {
            builder.add_hideBattleNodeName(x);
        }
        builder.add_unlockRouteItemCount(args.unlockRouteItemCount);
        if let Some(x) = args.unlockRouteItemId {
            builder.add_unlockRouteItemId(x);
        }
        if let Some(x) = args.trapRewardRelicId {
            builder.add_trapRewardRelicId(x);
        }
        if let Some(x) = args.specialTrapId {
            builder.add_specialTrapId(x);
        }
        if let Some(x) = args.overflowUsageSquadBuff {
            builder.add_overflowUsageSquadBuff(x);
        }
        builder.add_gpScoreRatio(args.gpScoreRatio);
        if let Some(x) = args.onceNodeTypeList {
            builder.add_onceNodeTypeList(x);
        }
        if let Some(x) = args.keyColorId {
            builder.add_keyColorId(x);
        }
        if let Some(x) = args.chestKeyItemId {
            builder.add_chestKeyItemId(x);
        }
        builder.add_chestKeyCnt(args.chestKeyCnt);
        if let Some(x) = args.divinationKitItemId {
            builder.add_divinationKitItemId(x);
        }
        if let Some(x) = args.keyItemId {
            builder.add_keyItemId(x);
        }
        if let Some(x) = args.shieldItemId {
            builder.add_shieldItemId(x);
        }
        if let Some(x) = args.maxHpItemId {
            builder.add_maxHpItemId(x);
        }
        if let Some(x) = args.badBoxTrapId {
            builder.add_badBoxTrapId(x);
        }
        if let Some(x) = args.rareBoxTrapId {
            builder.add_rareBoxTrapId(x);
        }
        if let Some(x) = args.normBoxTrapId {
            builder.add_normBoxTrapId(x);
        }
        if let Some(x) = args.goldChestTrapId {
            builder.add_goldChestTrapId(x);
        }
        if let Some(x) = args.bossIds {
            builder.add_bossIds(x);
        }
        if let Some(x) = args.mimicEnemyIds {
            builder.add_mimicEnemyIds(x);
        }
        if let Some(x) = args.spZoneShopBgmSignal {
            builder.add_spZoneShopBgmSignal(x);
        }
        builder.add_bankRewardCountType(args.bankRewardCountType);
        builder.add_bankDrawLimit(args.bankDrawLimit);
        builder.add_bankDrawCount(args.bankDrawCount);
        if let Some(x) = args.bankCostId {
            builder.add_bankCostId(x);
        }
        builder.add_bankMaxGold(args.bankMaxGold);
        if let Some(x) = args.expItemId {
            builder.add_expItemId(x);
        }
        if let Some(x) = args.squadCapacityItemId {
            builder.add_squadCapacityItemId(x);
        }
        if let Some(x) = args.populationItemId {
            builder.add_populationItemId(x);
        }
        if let Some(x) = args.goldItemId {
            builder.add_goldItemId(x);
        }
        if let Some(x) = args.hpItemId {
            builder.add_hpItemId(x);
        }
        if let Some(x) = args.failSceneName {
            builder.add_failSceneName(x);
        }
        if let Some(x) = args.initSceneName {
            builder.add_initSceneName(x);
        }
        builder.add_hasTopicCharSelectMenuButton(args.hasTopicCharSelectMenuButton);
        builder.add_haveSpZone(args.haveSpZone);
        builder.add_vertNodeCostDialogUseItemIconType(args.vertNodeCostDialogUseItemIconType);
        builder.add_initialBandShowGradeFlag(args.initialBandShowGradeFlag);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameConstT {
        let initSceneName = self.initSceneName().map(|x| x.to_string());
        let failSceneName = self.failSceneName().map(|x| x.to_string());
        let hpItemId = self.hpItemId().map(|x| x.to_string());
        let goldItemId = self.goldItemId().map(|x| x.to_string());
        let populationItemId = self.populationItemId().map(|x| x.to_string());
        let squadCapacityItemId = self.squadCapacityItemId().map(|x| x.to_string());
        let expItemId = self.expItemId().map(|x| x.to_string());
        let initialBandShowGradeFlag = self.initialBandShowGradeFlag();
        let bankMaxGold = self.bankMaxGold();
        let bankCostId = self.bankCostId().map(|x| x.to_string());
        let bankDrawCount = self.bankDrawCount();
        let bankDrawLimit = self.bankDrawLimit();
        let bankRewardCountType = self.bankRewardCountType();
        let spZoneShopBgmSignal = self.spZoneShopBgmSignal().map(|x| x.to_string());
        let mimicEnemyIds = self
            .mimicEnemyIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let bossIds = self
            .bossIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let goldChestTrapId = self.goldChestTrapId().map(|x| x.to_string());
        let normBoxTrapId = self.normBoxTrapId().map(|x| x.to_string());
        let rareBoxTrapId = self.rareBoxTrapId().map(|x| x.to_string());
        let badBoxTrapId = self.badBoxTrapId().map(|x| x.to_string());
        let maxHpItemId = self.maxHpItemId().map(|x| x.to_string());
        let shieldItemId = self.shieldItemId().map(|x| x.to_string());
        let keyItemId = self.keyItemId().map(|x| x.to_string());
        let divinationKitItemId = self.divinationKitItemId().map(|x| x.to_string());
        let chestKeyCnt = self.chestKeyCnt();
        let chestKeyItemId = self.chestKeyItemId().map(|x| x.to_string());
        let keyColorId = self.keyColorId().map(|x| x.to_string());
        let onceNodeTypeList = self.onceNodeTypeList().map(|x| x.into_iter().collect());
        let vertNodeCostDialogUseItemIconType = self.vertNodeCostDialogUseItemIconType();
        let gpScoreRatio = self.gpScoreRatio();
        let overflowUsageSquadBuff = self.overflowUsageSquadBuff().map(|x| x.to_string());
        let specialTrapId = self.specialTrapId().map(|x| x.to_string());
        let trapRewardRelicId = self.trapRewardRelicId().map(|x| x.to_string());
        let unlockRouteItemId = self.unlockRouteItemId().map(|x| x.to_string());
        let unlockRouteItemCount = self.unlockRouteItemCount();
        let hideBattleNodeName = self.hideBattleNodeName().map(|x| x.to_string());
        let hideBattleNodeDescription = self.hideBattleNodeDescription().map(|x| x.to_string());
        let hideNonBattleNodeName = self.hideNonBattleNodeName().map(|x| x.to_string());
        let hideNonBattleNodeDescription =
            self.hideNonBattleNodeDescription().map(|x| x.to_string());
        let charSelectExpeditionConflictToast = self
            .charSelectExpeditionConflictToast()
            .map(|x| x.to_string());
        let charSelectNoUpgradeConflictToast = self
            .charSelectNoUpgradeConflictToast()
            .map(|x| x.to_string());
        let itemDropTagDict = self
            .itemDropTagDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let shopRefreshCostId = self.shopRefreshCostId().map(|x| x.to_string());
        let expeditionLeaveToastFormat = self.expeditionLeaveToastFormat().map(|x| x.to_string());
        let expeditionReturnDescCureUpgrade = self
            .expeditionReturnDescCureUpgrade()
            .map(|x| x.to_string());
        let expeditionReturnDescUpgrade = self.expeditionReturnDescUpgrade().map(|x| x.to_string());
        let expeditionReturnDescCure = self.expeditionReturnDescCure().map(|x| x.to_string());
        let expeditionReturnDesc = self.expeditionReturnDesc().map(|x| x.to_string());
        let expeditionSelectDescFormat = self.expeditionSelectDescFormat().map(|x| x.to_string());
        let expeditionReturnDescItem = self.expeditionReturnDescItem().map(|x| x.to_string());
        let expeditionReturnRewardBlackList = self
            .expeditionReturnRewardBlackList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let travelLeaveToastFormat = self.travelLeaveToastFormat().map(|x| x.to_string());
        let charSelectTravelConflictToast =
            self.charSelectTravelConflictToast().map(|x| x.to_string());
        let travelReturnDescUpgrade = self.travelReturnDescUpgrade().map(|x| x.to_string());
        let travelReturnDesc = self.travelReturnDesc().map(|x| x.to_string());
        let travelReturnDescItem = self.travelReturnDescItem().map(|x| x.to_string());
        let traderReturnTitle = self.traderReturnTitle().map(|x| x.to_string());
        let traderReturnDesc = self.traderReturnDesc().map(|x| x.to_string());
        let candleReturnDescCandleUpgrade =
            self.candleReturnDescCandleUpgrade().map(|x| x.to_string());
        let candleReturnDescCandle = self.candleReturnDescCandle().map(|x| x.to_string());
        let charSelectCandleConflictToast =
            self.charSelectCandleConflictToast().map(|x| x.to_string());
        let charSelectGuidedConflictToast =
            self.charSelectGuidedConflictToast().map(|x| x.to_string());
        let charSelectNonGuidedConflictToast = self
            .charSelectNonGuidedConflictToast()
            .map(|x| x.to_string());
        let gainBuffDiffGrade = self.gainBuffDiffGrade();
        let dsPredictTips = self.dsPredictTips().map(|x| x.to_string());
        let dsBuffActiveTips = self.dsBuffActiveTips().map(|x| x.to_string());
        let totemDesc = self.totemDesc().map(|x| x.to_string());
        let copperGildDesc = self.copperGildDesc().map(|x| x.to_string());
        let relicDesc = self.relicDesc().map(|x| x.to_string());
        let buffDesc = self.buffDesc().map(|x| x.to_string());
        let refreshNodeItemId = self.refreshNodeItemId().map(|x| x.to_string());
        let storingRecruitDesc = self.storingRecruitDesc().map(|x| x.to_string());
        let storingRecruitSucceedToast = self.storingRecruitSucceedToast().map(|x| x.to_string());
        let specialRecruitReductionDesc = self.specialRecruitReductionDesc().map(|x| x.to_string());
        let specialRecruitFuncDesc = self.specialRecruitFuncDesc().map(|x| x.to_string());
        let specialRecruitDetailDesc = self.specialRecruitDetailDesc().map(|x| x.to_string());
        let portalZones = self
            .portalZones()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let diffDisplayZoneId = self.diffDisplayZoneId().map(|x| x.to_string());
        let exploreExpOnKill = self.exploreExpOnKill().map(|x| x.to_string());
        let fusionName = self.fusionName().map(|x| x.to_string());
        let fusionNotifyToast = self.fusionNotifyToast().map(|x| x.to_string());
        let haveSpZone = self.haveSpZone();
        let gotCharCandleBuffToast = self.gotCharCandleBuffToast().map(|x| x.to_string());
        let gotCharsCandleBuffToast = self.gotCharsCandleBuffToast().map(|x| x.to_string());
        let stashedRecruitNodeDescription =
            self.stashedRecruitNodeDescription().map(|x| x.to_string());
        let stashedRecruitEmptyNodeDescription = self
            .stashedRecruitEmptyNodeDescription()
            .map(|x| x.to_string());
        let recruitStashMaxNum = self.recruitStashMaxNum();
        let recruitStashMinNum = self.recruitStashMinNum();
        let hasTopicCharSelectMenuButton = self.hasTopicCharSelectMenuButton();
        clz_Torappu_RoguelikeGameConstT {
            initSceneName,
            failSceneName,
            hpItemId,
            goldItemId,
            populationItemId,
            squadCapacityItemId,
            expItemId,
            initialBandShowGradeFlag,
            bankMaxGold,
            bankCostId,
            bankDrawCount,
            bankDrawLimit,
            bankRewardCountType,
            spZoneShopBgmSignal,
            mimicEnemyIds,
            bossIds,
            goldChestTrapId,
            normBoxTrapId,
            rareBoxTrapId,
            badBoxTrapId,
            maxHpItemId,
            shieldItemId,
            keyItemId,
            divinationKitItemId,
            chestKeyCnt,
            chestKeyItemId,
            keyColorId,
            onceNodeTypeList,
            vertNodeCostDialogUseItemIconType,
            gpScoreRatio,
            overflowUsageSquadBuff,
            specialTrapId,
            trapRewardRelicId,
            unlockRouteItemId,
            unlockRouteItemCount,
            hideBattleNodeName,
            hideBattleNodeDescription,
            hideNonBattleNodeName,
            hideNonBattleNodeDescription,
            charSelectExpeditionConflictToast,
            charSelectNoUpgradeConflictToast,
            itemDropTagDict,
            shopRefreshCostId,
            expeditionLeaveToastFormat,
            expeditionReturnDescCureUpgrade,
            expeditionReturnDescUpgrade,
            expeditionReturnDescCure,
            expeditionReturnDesc,
            expeditionSelectDescFormat,
            expeditionReturnDescItem,
            expeditionReturnRewardBlackList,
            travelLeaveToastFormat,
            charSelectTravelConflictToast,
            travelReturnDescUpgrade,
            travelReturnDesc,
            travelReturnDescItem,
            traderReturnTitle,
            traderReturnDesc,
            candleReturnDescCandleUpgrade,
            candleReturnDescCandle,
            charSelectCandleConflictToast,
            charSelectGuidedConflictToast,
            charSelectNonGuidedConflictToast,
            gainBuffDiffGrade,
            dsPredictTips,
            dsBuffActiveTips,
            totemDesc,
            copperGildDesc,
            relicDesc,
            buffDesc,
            refreshNodeItemId,
            storingRecruitDesc,
            storingRecruitSucceedToast,
            specialRecruitReductionDesc,
            specialRecruitFuncDesc,
            specialRecruitDetailDesc,
            portalZones,
            diffDisplayZoneId,
            exploreExpOnKill,
            fusionName,
            fusionNotifyToast,
            haveSpZone,
            gotCharCandleBuffToast,
            gotCharsCandleBuffToast,
            stashedRecruitNodeDescription,
            stashedRecruitEmptyNodeDescription,
            recruitStashMaxNum,
            recruitStashMinNum,
            hasTopicCharSelectMenuButton,
        }
    }

    #[inline]
    pub fn initSceneName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_INITSCENENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn failSceneName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_FAILSCENENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn hpItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_HPITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn goldItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_GOLDITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn populationItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_POPULATIONITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn squadCapacityItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_SQUADCAPACITYITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn expItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_EXPITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn initialBandShowGradeFlag(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeGameConst::VT_INITIALBANDSHOWGRADEFLAG,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn bankMaxGold(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameConst::VT_BANKMAXGOLD, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn bankCostId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_BANKCOSTID,
                None,
            )
        }
    }
    #[inline]
    pub fn bankDrawCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameConst::VT_BANKDRAWCOUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn bankDrawLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameConst::VT_BANKDRAWLIMIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn bankRewardCountType(&self) -> enum__Torappu_RoguelikeBankRewardCountType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeBankRewardCountType>(
                    clz_Torappu_RoguelikeGameConst::VT_BANKREWARDCOUNTTYPE,
                    Some(enum__Torappu_RoguelikeBankRewardCountType::HIGHEST_RECORD),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn spZoneShopBgmSignal(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_SPZONESHOPBGMSIGNAL,
                None,
            )
        }
    }
    #[inline]
    pub fn mimicEnemyIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RoguelikeGameConst::VT_MIMICENEMYIDS, None)
        }
    }
    #[inline]
    pub fn bossIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RoguelikeGameConst::VT_BOSSIDS, None)
        }
    }
    #[inline]
    pub fn goldChestTrapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_GOLDCHESTTRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn normBoxTrapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_NORMBOXTRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn rareBoxTrapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_RAREBOXTRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn badBoxTrapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_BADBOXTRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn maxHpItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_MAXHPITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn shieldItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_SHIELDITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn keyItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_KEYITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn divinationKitItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_DIVINATIONKITITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn chestKeyCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameConst::VT_CHESTKEYCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn chestKeyItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_CHESTKEYITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn keyColorId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_KEYCOLORID,
                None,
            )
        }
    }
    #[inline]
    pub fn onceNodeTypeList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_RoguelikeEventType>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_RoguelikeEventType>,
            >>(clz_Torappu_RoguelikeGameConst::VT_ONCENODETYPELIST, None)
        }
    }
    #[inline]
    pub fn vertNodeCostDialogUseItemIconType(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeGameConst::VT_VERTNODECOSTDIALOGUSEITEMICONTYPE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn gpScoreRatio(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameConst::VT_GPSCORERATIO, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn overflowUsageSquadBuff(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_OVERFLOWUSAGESQUADBUFF,
                None,
            )
        }
    }
    #[inline]
    pub fn specialTrapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_SPECIALTRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn trapRewardRelicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_TRAPREWARDRELICID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockRouteItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_UNLOCKROUTEITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockRouteItemCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeGameConst::VT_UNLOCKROUTEITEMCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn hideBattleNodeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_HIDEBATTLENODENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn hideBattleNodeDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_HIDEBATTLENODEDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn hideNonBattleNodeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_HIDENONBATTLENODENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn hideNonBattleNodeDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_HIDENONBATTLENODEDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn charSelectExpeditionConflictToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_CHARSELECTEXPEDITIONCONFLICTTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn charSelectNoUpgradeConflictToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_CHARSELECTNOUPGRADECONFLICTTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn itemDropTagDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string,
                    >,
                >,
            >>(clz_Torappu_RoguelikeGameConst::VT_ITEMDROPTAGDICT, None)
        }
    }
    #[inline]
    pub fn shopRefreshCostId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_SHOPREFRESHCOSTID,
                None,
            )
        }
    }
    #[inline]
    pub fn expeditionLeaveToastFormat(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONLEAVETOASTFORMAT,
                None,
            )
        }
    }
    #[inline]
    pub fn expeditionReturnDescCureUpgrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONRETURNDESCCUREUPGRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn expeditionReturnDescUpgrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONRETURNDESCUPGRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn expeditionReturnDescCure(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONRETURNDESCCURE,
                None,
            )
        }
    }
    #[inline]
    pub fn expeditionReturnDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONRETURNDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn expeditionSelectDescFormat(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONSELECTDESCFORMAT,
                None,
            )
        }
    }
    #[inline]
    pub fn expeditionReturnDescItem(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONRETURNDESCITEM,
                None,
            )
        }
    }
    #[inline]
    pub fn expeditionReturnRewardBlackList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONRETURNREWARDBLACKLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn travelLeaveToastFormat(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_TRAVELLEAVETOASTFORMAT,
                None,
            )
        }
    }
    #[inline]
    pub fn charSelectTravelConflictToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_CHARSELECTTRAVELCONFLICTTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn travelReturnDescUpgrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_TRAVELRETURNDESCUPGRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn travelReturnDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_TRAVELRETURNDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn travelReturnDescItem(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_TRAVELRETURNDESCITEM,
                None,
            )
        }
    }
    #[inline]
    pub fn traderReturnTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_TRADERRETURNTITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn traderReturnDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_TRADERRETURNDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn candleReturnDescCandleUpgrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_CANDLERETURNDESCCANDLEUPGRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn candleReturnDescCandle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_CANDLERETURNDESCCANDLE,
                None,
            )
        }
    }
    #[inline]
    pub fn charSelectCandleConflictToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_CHARSELECTCANDLECONFLICTTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn charSelectGuidedConflictToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_CHARSELECTGUIDEDCONFLICTTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn charSelectNonGuidedConflictToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_CHARSELECTNONGUIDEDCONFLICTTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn gainBuffDiffGrade(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeGameConst::VT_GAINBUFFDIFFGRADE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn dsPredictTips(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_DSPREDICTTIPS,
                None,
            )
        }
    }
    #[inline]
    pub fn dsBuffActiveTips(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_DSBUFFACTIVETIPS,
                None,
            )
        }
    }
    #[inline]
    pub fn totemDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_TOTEMDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn copperGildDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_COPPERGILDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn relicDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_RELICDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn buffDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_BUFFDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn refreshNodeItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_REFRESHNODEITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn storingRecruitDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_STORINGRECRUITDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn storingRecruitSucceedToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_STORINGRECRUITSUCCEEDTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn specialRecruitReductionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_SPECIALRECRUITREDUCTIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn specialRecruitFuncDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_SPECIALRECRUITFUNCDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn specialRecruitDetailDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_SPECIALRECRUITDETAILDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn portalZones(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RoguelikeGameConst::VT_PORTALZONES, None)
        }
    }
    #[inline]
    pub fn diffDisplayZoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_DIFFDISPLAYZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn exploreExpOnKill(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_EXPLOREEXPONKILL,
                None,
            )
        }
    }
    #[inline]
    pub fn fusionName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_FUSIONNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn fusionNotifyToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_FUSIONNOTIFYTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn haveSpZone(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_RoguelikeGameConst::VT_HAVESPZONE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn gotCharCandleBuffToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_GOTCHARCANDLEBUFFTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn gotCharsCandleBuffToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_GOTCHARSCANDLEBUFFTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn stashedRecruitNodeDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_STASHEDRECRUITNODEDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn stashedRecruitEmptyNodeDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameConst::VT_STASHEDRECRUITEMPTYNODEDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn recruitStashMaxNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeGameConst::VT_RECRUITSTASHMAXNUM,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn recruitStashMinNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeGameConst::VT_RECRUITSTASHMINNUM,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn hasTopicCharSelectMenuButton(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeGameConst::VT_HASTOPICCHARSELECTMENUBUTTON,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameConst<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("initSceneName", Self::VT_INITSCENENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("failSceneName", Self::VT_FAILSCENENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("hpItemId", Self::VT_HPITEMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("goldItemId", Self::VT_GOLDITEMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("populationItemId", Self::VT_POPULATIONITEMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("squadCapacityItemId", Self::VT_SQUADCAPACITYITEMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("expItemId", Self::VT_EXPITEMID, false)?
     .visit_field::<bool>("initialBandShowGradeFlag", Self::VT_INITIALBANDSHOWGRADEFLAG, false)?
     .visit_field::<i32>("bankMaxGold", Self::VT_BANKMAXGOLD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bankCostId", Self::VT_BANKCOSTID, false)?
     .visit_field::<i32>("bankDrawCount", Self::VT_BANKDRAWCOUNT, false)?
     .visit_field::<i32>("bankDrawLimit", Self::VT_BANKDRAWLIMIT, false)?
     .visit_field::<enum__Torappu_RoguelikeBankRewardCountType>("bankRewardCountType", Self::VT_BANKREWARDCOUNTTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("spZoneShopBgmSignal", Self::VT_SPZONESHOPBGMSIGNAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("mimicEnemyIds", Self::VT_MIMICENEMYIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("bossIds", Self::VT_BOSSIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("goldChestTrapId", Self::VT_GOLDCHESTTRAPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("normBoxTrapId", Self::VT_NORMBOXTRAPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rareBoxTrapId", Self::VT_RAREBOXTRAPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("badBoxTrapId", Self::VT_BADBOXTRAPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("maxHpItemId", Self::VT_MAXHPITEMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("shieldItemId", Self::VT_SHIELDITEMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("keyItemId", Self::VT_KEYITEMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("divinationKitItemId", Self::VT_DIVINATIONKITITEMID, false)?
     .visit_field::<i32>("chestKeyCnt", Self::VT_CHESTKEYCNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("chestKeyItemId", Self::VT_CHESTKEYITEMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("keyColorId", Self::VT_KEYCOLORID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_RoguelikeEventType>>>("onceNodeTypeList", Self::VT_ONCENODETYPELIST, false)?
     .visit_field::<bool>("vertNodeCostDialogUseItemIconType", Self::VT_VERTNODECOSTDIALOGUSEITEMICONTYPE, false)?
     .visit_field::<i32>("gpScoreRatio", Self::VT_GPSCORERATIO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("overflowUsageSquadBuff", Self::VT_OVERFLOWUSAGESQUADBUFF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("specialTrapId", Self::VT_SPECIALTRAPID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trapRewardRelicId", Self::VT_TRAPREWARDRELICID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unlockRouteItemId", Self::VT_UNLOCKROUTEITEMID, false)?
     .visit_field::<i32>("unlockRouteItemCount", Self::VT_UNLOCKROUTEITEMCOUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("hideBattleNodeName", Self::VT_HIDEBATTLENODENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("hideBattleNodeDescription", Self::VT_HIDEBATTLENODEDESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("hideNonBattleNodeName", Self::VT_HIDENONBATTLENODENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("hideNonBattleNodeDescription", Self::VT_HIDENONBATTLENODEDESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charSelectExpeditionConflictToast", Self::VT_CHARSELECTEXPEDITIONCONFLICTTOAST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charSelectNoUpgradeConflictToast", Self::VT_CHARSELECTNOUPGRADECONFLICTTOAST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string>>>>("itemDropTagDict", Self::VT_ITEMDROPTAGDICT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("shopRefreshCostId", Self::VT_SHOPREFRESHCOSTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("expeditionLeaveToastFormat", Self::VT_EXPEDITIONLEAVETOASTFORMAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("expeditionReturnDescCureUpgrade", Self::VT_EXPEDITIONRETURNDESCCUREUPGRADE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("expeditionReturnDescUpgrade", Self::VT_EXPEDITIONRETURNDESCUPGRADE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("expeditionReturnDescCure", Self::VT_EXPEDITIONRETURNDESCCURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("expeditionReturnDesc", Self::VT_EXPEDITIONRETURNDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("expeditionSelectDescFormat", Self::VT_EXPEDITIONSELECTDESCFORMAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("expeditionReturnDescItem", Self::VT_EXPEDITIONRETURNDESCITEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("expeditionReturnRewardBlackList", Self::VT_EXPEDITIONRETURNREWARDBLACKLIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("travelLeaveToastFormat", Self::VT_TRAVELLEAVETOASTFORMAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charSelectTravelConflictToast", Self::VT_CHARSELECTTRAVELCONFLICTTOAST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("travelReturnDescUpgrade", Self::VT_TRAVELRETURNDESCUPGRADE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("travelReturnDesc", Self::VT_TRAVELRETURNDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("travelReturnDescItem", Self::VT_TRAVELRETURNDESCITEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("traderReturnTitle", Self::VT_TRADERRETURNTITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("traderReturnDesc", Self::VT_TRADERRETURNDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("candleReturnDescCandleUpgrade", Self::VT_CANDLERETURNDESCCANDLEUPGRADE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("candleReturnDescCandle", Self::VT_CANDLERETURNDESCCANDLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charSelectCandleConflictToast", Self::VT_CHARSELECTCANDLECONFLICTTOAST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charSelectGuidedConflictToast", Self::VT_CHARSELECTGUIDEDCONFLICTTOAST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charSelectNonGuidedConflictToast", Self::VT_CHARSELECTNONGUIDEDCONFLICTTOAST, false)?
     .visit_field::<i32>("gainBuffDiffGrade", Self::VT_GAINBUFFDIFFGRADE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dsPredictTips", Self::VT_DSPREDICTTIPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dsBuffActiveTips", Self::VT_DSBUFFACTIVETIPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("totemDesc", Self::VT_TOTEMDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("copperGildDesc", Self::VT_COPPERGILDDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("relicDesc", Self::VT_RELICDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffDesc", Self::VT_BUFFDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("refreshNodeItemId", Self::VT_REFRESHNODEITEMID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("storingRecruitDesc", Self::VT_STORINGRECRUITDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("storingRecruitSucceedToast", Self::VT_STORINGRECRUITSUCCEEDTOAST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("specialRecruitReductionDesc", Self::VT_SPECIALRECRUITREDUCTIONDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("specialRecruitFuncDesc", Self::VT_SPECIALRECRUITFUNCDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("specialRecruitDetailDesc", Self::VT_SPECIALRECRUITDETAILDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("portalZones", Self::VT_PORTALZONES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("diffDisplayZoneId", Self::VT_DIFFDISPLAYZONEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("exploreExpOnKill", Self::VT_EXPLOREEXPONKILL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fusionName", Self::VT_FUSIONNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fusionNotifyToast", Self::VT_FUSIONNOTIFYTOAST, false)?
     .visit_field::<bool>("haveSpZone", Self::VT_HAVESPZONE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("gotCharCandleBuffToast", Self::VT_GOTCHARCANDLEBUFFTOAST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("gotCharsCandleBuffToast", Self::VT_GOTCHARSCANDLEBUFFTOAST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stashedRecruitNodeDescription", Self::VT_STASHEDRECRUITNODEDESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stashedRecruitEmptyNodeDescription", Self::VT_STASHEDRECRUITEMPTYNODEDESCRIPTION, false)?
     .visit_field::<i32>("recruitStashMaxNum", Self::VT_RECRUITSTASHMAXNUM, false)?
     .visit_field::<i32>("recruitStashMinNum", Self::VT_RECRUITSTASHMINNUM, false)?
     .visit_field::<bool>("hasTopicCharSelectMenuButton", Self::VT_HASTOPICCHARSELECTMENUBUTTON, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameConstArgs<'a> {
    pub initSceneName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub failSceneName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hpItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub goldItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub populationItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub squadCapacityItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub expItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub initialBandShowGradeFlag: bool,
    pub bankMaxGold: i32,
    pub bankCostId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bankDrawCount: i32,
    pub bankDrawLimit: i32,
    pub bankRewardCountType: enum__Torappu_RoguelikeBankRewardCountType,
    pub spZoneShopBgmSignal: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mimicEnemyIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub bossIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub goldChestTrapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub normBoxTrapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rareBoxTrapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub badBoxTrapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maxHpItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub shieldItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub keyItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub divinationKitItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub chestKeyCnt: i32,
    pub chestKeyItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub keyColorId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub onceNodeTypeList:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_RoguelikeEventType>>>,
    pub vertNodeCostDialogUseItemIconType: bool,
    pub gpScoreRatio: i32,
    pub overflowUsageSquadBuff: Option<flatbuffers::WIPOffset<&'a str>>,
    pub specialTrapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapRewardRelicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockRouteItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockRouteItemCount: i32,
    pub hideBattleNodeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hideBattleNodeDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hideNonBattleNodeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hideNonBattleNodeDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub charSelectExpeditionConflictToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub charSelectNoUpgradeConflictToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemDropTagDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string<'a>,
                >,
            >,
        >,
    >,
    pub shopRefreshCostId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub expeditionLeaveToastFormat: Option<flatbuffers::WIPOffset<&'a str>>,
    pub expeditionReturnDescCureUpgrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub expeditionReturnDescUpgrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub expeditionReturnDescCure: Option<flatbuffers::WIPOffset<&'a str>>,
    pub expeditionReturnDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub expeditionSelectDescFormat: Option<flatbuffers::WIPOffset<&'a str>>,
    pub expeditionReturnDescItem: Option<flatbuffers::WIPOffset<&'a str>>,
    pub expeditionReturnRewardBlackList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub travelLeaveToastFormat: Option<flatbuffers::WIPOffset<&'a str>>,
    pub charSelectTravelConflictToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub travelReturnDescUpgrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub travelReturnDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub travelReturnDescItem: Option<flatbuffers::WIPOffset<&'a str>>,
    pub traderReturnTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub traderReturnDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub candleReturnDescCandleUpgrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub candleReturnDescCandle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub charSelectCandleConflictToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub charSelectGuidedConflictToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub charSelectNonGuidedConflictToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gainBuffDiffGrade: i32,
    pub dsPredictTips: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dsBuffActiveTips: Option<flatbuffers::WIPOffset<&'a str>>,
    pub totemDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub copperGildDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relicDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub refreshNodeItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storingRecruitDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storingRecruitSucceedToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub specialRecruitReductionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub specialRecruitFuncDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub specialRecruitDetailDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub portalZones: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub diffDisplayZoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub exploreExpOnKill: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fusionName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fusionNotifyToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub haveSpZone: bool,
    pub gotCharCandleBuffToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gotCharsCandleBuffToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stashedRecruitNodeDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stashedRecruitEmptyNodeDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recruitStashMaxNum: i32,
    pub recruitStashMinNum: i32,
    pub hasTopicCharSelectMenuButton: bool,
}
impl<'a> Default for clz_Torappu_RoguelikeGameConstArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameConstArgs {
            initSceneName: None,
            failSceneName: None,
            hpItemId: None,
            goldItemId: None,
            populationItemId: None,
            squadCapacityItemId: None,
            expItemId: None,
            initialBandShowGradeFlag: false,
            bankMaxGold: 0,
            bankCostId: None,
            bankDrawCount: 0,
            bankDrawLimit: 0,
            bankRewardCountType: enum__Torappu_RoguelikeBankRewardCountType::HIGHEST_RECORD,
            spZoneShopBgmSignal: None,
            mimicEnemyIds: None,
            bossIds: None,
            goldChestTrapId: None,
            normBoxTrapId: None,
            rareBoxTrapId: None,
            badBoxTrapId: None,
            maxHpItemId: None,
            shieldItemId: None,
            keyItemId: None,
            divinationKitItemId: None,
            chestKeyCnt: 0,
            chestKeyItemId: None,
            keyColorId: None,
            onceNodeTypeList: None,
            vertNodeCostDialogUseItemIconType: false,
            gpScoreRatio: 0,
            overflowUsageSquadBuff: None,
            specialTrapId: None,
            trapRewardRelicId: None,
            unlockRouteItemId: None,
            unlockRouteItemCount: 0,
            hideBattleNodeName: None,
            hideBattleNodeDescription: None,
            hideNonBattleNodeName: None,
            hideNonBattleNodeDescription: None,
            charSelectExpeditionConflictToast: None,
            charSelectNoUpgradeConflictToast: None,
            itemDropTagDict: None,
            shopRefreshCostId: None,
            expeditionLeaveToastFormat: None,
            expeditionReturnDescCureUpgrade: None,
            expeditionReturnDescUpgrade: None,
            expeditionReturnDescCure: None,
            expeditionReturnDesc: None,
            expeditionSelectDescFormat: None,
            expeditionReturnDescItem: None,
            expeditionReturnRewardBlackList: None,
            travelLeaveToastFormat: None,
            charSelectTravelConflictToast: None,
            travelReturnDescUpgrade: None,
            travelReturnDesc: None,
            travelReturnDescItem: None,
            traderReturnTitle: None,
            traderReturnDesc: None,
            candleReturnDescCandleUpgrade: None,
            candleReturnDescCandle: None,
            charSelectCandleConflictToast: None,
            charSelectGuidedConflictToast: None,
            charSelectNonGuidedConflictToast: None,
            gainBuffDiffGrade: 0,
            dsPredictTips: None,
            dsBuffActiveTips: None,
            totemDesc: None,
            copperGildDesc: None,
            relicDesc: None,
            buffDesc: None,
            refreshNodeItemId: None,
            storingRecruitDesc: None,
            storingRecruitSucceedToast: None,
            specialRecruitReductionDesc: None,
            specialRecruitFuncDesc: None,
            specialRecruitDetailDesc: None,
            portalZones: None,
            diffDisplayZoneId: None,
            exploreExpOnKill: None,
            fusionName: None,
            fusionNotifyToast: None,
            haveSpZone: false,
            gotCharCandleBuffToast: None,
            gotCharsCandleBuffToast: None,
            stashedRecruitNodeDescription: None,
            stashedRecruitEmptyNodeDescription: None,
            recruitStashMaxNum: 0,
            recruitStashMinNum: 0,
            hasTopicCharSelectMenuButton: false,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameConst<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameConst", 89)?;
        if let Some(f) = self.initSceneName() {
            s.serialize_field("initSceneName", &f)?;
        } else {
            s.skip_field("initSceneName")?;
        }
        if let Some(f) = self.failSceneName() {
            s.serialize_field("failSceneName", &f)?;
        } else {
            s.skip_field("failSceneName")?;
        }
        if let Some(f) = self.hpItemId() {
            s.serialize_field("hpItemId", &f)?;
        } else {
            s.skip_field("hpItemId")?;
        }
        if let Some(f) = self.goldItemId() {
            s.serialize_field("goldItemId", &f)?;
        } else {
            s.skip_field("goldItemId")?;
        }
        if let Some(f) = self.populationItemId() {
            s.serialize_field("populationItemId", &f)?;
        } else {
            s.skip_field("populationItemId")?;
        }
        if let Some(f) = self.squadCapacityItemId() {
            s.serialize_field("squadCapacityItemId", &f)?;
        } else {
            s.skip_field("squadCapacityItemId")?;
        }
        if let Some(f) = self.expItemId() {
            s.serialize_field("expItemId", &f)?;
        } else {
            s.skip_field("expItemId")?;
        }
        s.serialize_field("initialBandShowGradeFlag", &self.initialBandShowGradeFlag())?;
        s.serialize_field("bankMaxGold", &self.bankMaxGold())?;
        if let Some(f) = self.bankCostId() {
            s.serialize_field("bankCostId", &f)?;
        } else {
            s.skip_field("bankCostId")?;
        }
        s.serialize_field("bankDrawCount", &self.bankDrawCount())?;
        s.serialize_field("bankDrawLimit", &self.bankDrawLimit())?;
        s.serialize_field("bankRewardCountType", &self.bankRewardCountType())?;
        if let Some(f) = self.spZoneShopBgmSignal() {
            s.serialize_field("spZoneShopBgmSignal", &f)?;
        } else {
            s.skip_field("spZoneShopBgmSignal")?;
        }
        if let Some(f) = self.mimicEnemyIds() {
            s.serialize_field("mimicEnemyIds", &f)?;
        } else {
            s.skip_field("mimicEnemyIds")?;
        }
        if let Some(f) = self.bossIds() {
            s.serialize_field("bossIds", &f)?;
        } else {
            s.skip_field("bossIds")?;
        }
        if let Some(f) = self.goldChestTrapId() {
            s.serialize_field("goldChestTrapId", &f)?;
        } else {
            s.skip_field("goldChestTrapId")?;
        }
        if let Some(f) = self.normBoxTrapId() {
            s.serialize_field("normBoxTrapId", &f)?;
        } else {
            s.skip_field("normBoxTrapId")?;
        }
        if let Some(f) = self.rareBoxTrapId() {
            s.serialize_field("rareBoxTrapId", &f)?;
        } else {
            s.skip_field("rareBoxTrapId")?;
        }
        if let Some(f) = self.badBoxTrapId() {
            s.serialize_field("badBoxTrapId", &f)?;
        } else {
            s.skip_field("badBoxTrapId")?;
        }
        if let Some(f) = self.maxHpItemId() {
            s.serialize_field("maxHpItemId", &f)?;
        } else {
            s.skip_field("maxHpItemId")?;
        }
        if let Some(f) = self.shieldItemId() {
            s.serialize_field("shieldItemId", &f)?;
        } else {
            s.skip_field("shieldItemId")?;
        }
        if let Some(f) = self.keyItemId() {
            s.serialize_field("keyItemId", &f)?;
        } else {
            s.skip_field("keyItemId")?;
        }
        if let Some(f) = self.divinationKitItemId() {
            s.serialize_field("divinationKitItemId", &f)?;
        } else {
            s.skip_field("divinationKitItemId")?;
        }
        s.serialize_field("chestKeyCnt", &self.chestKeyCnt())?;
        if let Some(f) = self.chestKeyItemId() {
            s.serialize_field("chestKeyItemId", &f)?;
        } else {
            s.skip_field("chestKeyItemId")?;
        }
        if let Some(f) = self.keyColorId() {
            s.serialize_field("keyColorId", &f)?;
        } else {
            s.skip_field("keyColorId")?;
        }
        if let Some(f) = self.onceNodeTypeList() {
            s.serialize_field("onceNodeTypeList", &f)?;
        } else {
            s.skip_field("onceNodeTypeList")?;
        }
        s.serialize_field(
            "vertNodeCostDialogUseItemIconType",
            &self.vertNodeCostDialogUseItemIconType(),
        )?;
        s.serialize_field("gpScoreRatio", &self.gpScoreRatio())?;
        if let Some(f) = self.overflowUsageSquadBuff() {
            s.serialize_field("overflowUsageSquadBuff", &f)?;
        } else {
            s.skip_field("overflowUsageSquadBuff")?;
        }
        if let Some(f) = self.specialTrapId() {
            s.serialize_field("specialTrapId", &f)?;
        } else {
            s.skip_field("specialTrapId")?;
        }
        if let Some(f) = self.trapRewardRelicId() {
            s.serialize_field("trapRewardRelicId", &f)?;
        } else {
            s.skip_field("trapRewardRelicId")?;
        }
        if let Some(f) = self.unlockRouteItemId() {
            s.serialize_field("unlockRouteItemId", &f)?;
        } else {
            s.skip_field("unlockRouteItemId")?;
        }
        s.serialize_field("unlockRouteItemCount", &self.unlockRouteItemCount())?;
        if let Some(f) = self.hideBattleNodeName() {
            s.serialize_field("hideBattleNodeName", &f)?;
        } else {
            s.skip_field("hideBattleNodeName")?;
        }
        if let Some(f) = self.hideBattleNodeDescription() {
            s.serialize_field("hideBattleNodeDescription", &f)?;
        } else {
            s.skip_field("hideBattleNodeDescription")?;
        }
        if let Some(f) = self.hideNonBattleNodeName() {
            s.serialize_field("hideNonBattleNodeName", &f)?;
        } else {
            s.skip_field("hideNonBattleNodeName")?;
        }
        if let Some(f) = self.hideNonBattleNodeDescription() {
            s.serialize_field("hideNonBattleNodeDescription", &f)?;
        } else {
            s.skip_field("hideNonBattleNodeDescription")?;
        }
        if let Some(f) = self.charSelectExpeditionConflictToast() {
            s.serialize_field("charSelectExpeditionConflictToast", &f)?;
        } else {
            s.skip_field("charSelectExpeditionConflictToast")?;
        }
        if let Some(f) = self.charSelectNoUpgradeConflictToast() {
            s.serialize_field("charSelectNoUpgradeConflictToast", &f)?;
        } else {
            s.skip_field("charSelectNoUpgradeConflictToast")?;
        }
        if let Some(f) = self.itemDropTagDict() {
            s.serialize_field("itemDropTagDict", &f)?;
        } else {
            s.skip_field("itemDropTagDict")?;
        }
        if let Some(f) = self.shopRefreshCostId() {
            s.serialize_field("shopRefreshCostId", &f)?;
        } else {
            s.skip_field("shopRefreshCostId")?;
        }
        if let Some(f) = self.expeditionLeaveToastFormat() {
            s.serialize_field("expeditionLeaveToastFormat", &f)?;
        } else {
            s.skip_field("expeditionLeaveToastFormat")?;
        }
        if let Some(f) = self.expeditionReturnDescCureUpgrade() {
            s.serialize_field("expeditionReturnDescCureUpgrade", &f)?;
        } else {
            s.skip_field("expeditionReturnDescCureUpgrade")?;
        }
        if let Some(f) = self.expeditionReturnDescUpgrade() {
            s.serialize_field("expeditionReturnDescUpgrade", &f)?;
        } else {
            s.skip_field("expeditionReturnDescUpgrade")?;
        }
        if let Some(f) = self.expeditionReturnDescCure() {
            s.serialize_field("expeditionReturnDescCure", &f)?;
        } else {
            s.skip_field("expeditionReturnDescCure")?;
        }
        if let Some(f) = self.expeditionReturnDesc() {
            s.serialize_field("expeditionReturnDesc", &f)?;
        } else {
            s.skip_field("expeditionReturnDesc")?;
        }
        if let Some(f) = self.expeditionSelectDescFormat() {
            s.serialize_field("expeditionSelectDescFormat", &f)?;
        } else {
            s.skip_field("expeditionSelectDescFormat")?;
        }
        if let Some(f) = self.expeditionReturnDescItem() {
            s.serialize_field("expeditionReturnDescItem", &f)?;
        } else {
            s.skip_field("expeditionReturnDescItem")?;
        }
        if let Some(f) = self.expeditionReturnRewardBlackList() {
            s.serialize_field("expeditionReturnRewardBlackList", &f)?;
        } else {
            s.skip_field("expeditionReturnRewardBlackList")?;
        }
        if let Some(f) = self.travelLeaveToastFormat() {
            s.serialize_field("travelLeaveToastFormat", &f)?;
        } else {
            s.skip_field("travelLeaveToastFormat")?;
        }
        if let Some(f) = self.charSelectTravelConflictToast() {
            s.serialize_field("charSelectTravelConflictToast", &f)?;
        } else {
            s.skip_field("charSelectTravelConflictToast")?;
        }
        if let Some(f) = self.travelReturnDescUpgrade() {
            s.serialize_field("travelReturnDescUpgrade", &f)?;
        } else {
            s.skip_field("travelReturnDescUpgrade")?;
        }
        if let Some(f) = self.travelReturnDesc() {
            s.serialize_field("travelReturnDesc", &f)?;
        } else {
            s.skip_field("travelReturnDesc")?;
        }
        if let Some(f) = self.travelReturnDescItem() {
            s.serialize_field("travelReturnDescItem", &f)?;
        } else {
            s.skip_field("travelReturnDescItem")?;
        }
        if let Some(f) = self.traderReturnTitle() {
            s.serialize_field("traderReturnTitle", &f)?;
        } else {
            s.skip_field("traderReturnTitle")?;
        }
        if let Some(f) = self.traderReturnDesc() {
            s.serialize_field("traderReturnDesc", &f)?;
        } else {
            s.skip_field("traderReturnDesc")?;
        }
        if let Some(f) = self.candleReturnDescCandleUpgrade() {
            s.serialize_field("candleReturnDescCandleUpgrade", &f)?;
        } else {
            s.skip_field("candleReturnDescCandleUpgrade")?;
        }
        if let Some(f) = self.candleReturnDescCandle() {
            s.serialize_field("candleReturnDescCandle", &f)?;
        } else {
            s.skip_field("candleReturnDescCandle")?;
        }
        if let Some(f) = self.charSelectCandleConflictToast() {
            s.serialize_field("charSelectCandleConflictToast", &f)?;
        } else {
            s.skip_field("charSelectCandleConflictToast")?;
        }
        if let Some(f) = self.charSelectGuidedConflictToast() {
            s.serialize_field("charSelectGuidedConflictToast", &f)?;
        } else {
            s.skip_field("charSelectGuidedConflictToast")?;
        }
        if let Some(f) = self.charSelectNonGuidedConflictToast() {
            s.serialize_field("charSelectNonGuidedConflictToast", &f)?;
        } else {
            s.skip_field("charSelectNonGuidedConflictToast")?;
        }
        s.serialize_field("gainBuffDiffGrade", &self.gainBuffDiffGrade())?;
        if let Some(f) = self.dsPredictTips() {
            s.serialize_field("dsPredictTips", &f)?;
        } else {
            s.skip_field("dsPredictTips")?;
        }
        if let Some(f) = self.dsBuffActiveTips() {
            s.serialize_field("dsBuffActiveTips", &f)?;
        } else {
            s.skip_field("dsBuffActiveTips")?;
        }
        if let Some(f) = self.totemDesc() {
            s.serialize_field("totemDesc", &f)?;
        } else {
            s.skip_field("totemDesc")?;
        }
        if let Some(f) = self.copperGildDesc() {
            s.serialize_field("copperGildDesc", &f)?;
        } else {
            s.skip_field("copperGildDesc")?;
        }
        if let Some(f) = self.relicDesc() {
            s.serialize_field("relicDesc", &f)?;
        } else {
            s.skip_field("relicDesc")?;
        }
        if let Some(f) = self.buffDesc() {
            s.serialize_field("buffDesc", &f)?;
        } else {
            s.skip_field("buffDesc")?;
        }
        if let Some(f) = self.refreshNodeItemId() {
            s.serialize_field("refreshNodeItemId", &f)?;
        } else {
            s.skip_field("refreshNodeItemId")?;
        }
        if let Some(f) = self.storingRecruitDesc() {
            s.serialize_field("storingRecruitDesc", &f)?;
        } else {
            s.skip_field("storingRecruitDesc")?;
        }
        if let Some(f) = self.storingRecruitSucceedToast() {
            s.serialize_field("storingRecruitSucceedToast", &f)?;
        } else {
            s.skip_field("storingRecruitSucceedToast")?;
        }
        if let Some(f) = self.specialRecruitReductionDesc() {
            s.serialize_field("specialRecruitReductionDesc", &f)?;
        } else {
            s.skip_field("specialRecruitReductionDesc")?;
        }
        if let Some(f) = self.specialRecruitFuncDesc() {
            s.serialize_field("specialRecruitFuncDesc", &f)?;
        } else {
            s.skip_field("specialRecruitFuncDesc")?;
        }
        if let Some(f) = self.specialRecruitDetailDesc() {
            s.serialize_field("specialRecruitDetailDesc", &f)?;
        } else {
            s.skip_field("specialRecruitDetailDesc")?;
        }
        if let Some(f) = self.portalZones() {
            s.serialize_field("portalZones", &f)?;
        } else {
            s.skip_field("portalZones")?;
        }
        if let Some(f) = self.diffDisplayZoneId() {
            s.serialize_field("diffDisplayZoneId", &f)?;
        } else {
            s.skip_field("diffDisplayZoneId")?;
        }
        if let Some(f) = self.exploreExpOnKill() {
            s.serialize_field("exploreExpOnKill", &f)?;
        } else {
            s.skip_field("exploreExpOnKill")?;
        }
        if let Some(f) = self.fusionName() {
            s.serialize_field("fusionName", &f)?;
        } else {
            s.skip_field("fusionName")?;
        }
        if let Some(f) = self.fusionNotifyToast() {
            s.serialize_field("fusionNotifyToast", &f)?;
        } else {
            s.skip_field("fusionNotifyToast")?;
        }
        s.serialize_field("haveSpZone", &self.haveSpZone())?;
        if let Some(f) = self.gotCharCandleBuffToast() {
            s.serialize_field("gotCharCandleBuffToast", &f)?;
        } else {
            s.skip_field("gotCharCandleBuffToast")?;
        }
        if let Some(f) = self.gotCharsCandleBuffToast() {
            s.serialize_field("gotCharsCandleBuffToast", &f)?;
        } else {
            s.skip_field("gotCharsCandleBuffToast")?;
        }
        if let Some(f) = self.stashedRecruitNodeDescription() {
            s.serialize_field("stashedRecruitNodeDescription", &f)?;
        } else {
            s.skip_field("stashedRecruitNodeDescription")?;
        }
        if let Some(f) = self.stashedRecruitEmptyNodeDescription() {
            s.serialize_field("stashedRecruitEmptyNodeDescription", &f)?;
        } else {
            s.skip_field("stashedRecruitEmptyNodeDescription")?;
        }
        s.serialize_field("recruitStashMaxNum", &self.recruitStashMaxNum())?;
        s.serialize_field("recruitStashMinNum", &self.recruitStashMinNum())?;
        s.serialize_field(
            "hasTopicCharSelectMenuButton",
            &self.hasTopicCharSelectMenuButton(),
        )?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameConstBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RoguelikeGameConstBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_initSceneName(&mut self, initSceneName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_INITSCENENAME,
            initSceneName,
        );
    }
    #[inline]
    pub fn add_failSceneName(&mut self, failSceneName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_FAILSCENENAME,
            failSceneName,
        );
    }
    #[inline]
    pub fn add_hpItemId(&mut self, hpItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_HPITEMID,
            hpItemId,
        );
    }
    #[inline]
    pub fn add_goldItemId(&mut self, goldItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_GOLDITEMID,
            goldItemId,
        );
    }
    #[inline]
    pub fn add_populationItemId(&mut self, populationItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_POPULATIONITEMID,
            populationItemId,
        );
    }
    #[inline]
    pub fn add_squadCapacityItemId(
        &mut self,
        squadCapacityItemId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_SQUADCAPACITYITEMID,
            squadCapacityItemId,
        );
    }
    #[inline]
    pub fn add_expItemId(&mut self, expItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_EXPITEMID,
            expItemId,
        );
    }
    #[inline]
    pub fn add_initialBandShowGradeFlag(&mut self, initialBandShowGradeFlag: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeGameConst::VT_INITIALBANDSHOWGRADEFLAG,
            initialBandShowGradeFlag,
            false,
        );
    }
    #[inline]
    pub fn add_bankMaxGold(&mut self, bankMaxGold: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameConst::VT_BANKMAXGOLD,
            bankMaxGold,
            0,
        );
    }
    #[inline]
    pub fn add_bankCostId(&mut self, bankCostId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_BANKCOSTID,
            bankCostId,
        );
    }
    #[inline]
    pub fn add_bankDrawCount(&mut self, bankDrawCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameConst::VT_BANKDRAWCOUNT,
            bankDrawCount,
            0,
        );
    }
    #[inline]
    pub fn add_bankDrawLimit(&mut self, bankDrawLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameConst::VT_BANKDRAWLIMIT,
            bankDrawLimit,
            0,
        );
    }
    #[inline]
    pub fn add_bankRewardCountType(
        &mut self,
        bankRewardCountType: enum__Torappu_RoguelikeBankRewardCountType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeBankRewardCountType>(
                clz_Torappu_RoguelikeGameConst::VT_BANKREWARDCOUNTTYPE,
                bankRewardCountType,
                enum__Torappu_RoguelikeBankRewardCountType::HIGHEST_RECORD,
            );
    }
    #[inline]
    pub fn add_spZoneShopBgmSignal(
        &mut self,
        spZoneShopBgmSignal: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_SPZONESHOPBGMSIGNAL,
            spZoneShopBgmSignal,
        );
    }
    #[inline]
    pub fn add_mimicEnemyIds(
        &mut self,
        mimicEnemyIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_MIMICENEMYIDS,
            mimicEnemyIds,
        );
    }
    #[inline]
    pub fn add_bossIds(
        &mut self,
        bossIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_BOSSIDS,
            bossIds,
        );
    }
    #[inline]
    pub fn add_goldChestTrapId(&mut self, goldChestTrapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_GOLDCHESTTRAPID,
            goldChestTrapId,
        );
    }
    #[inline]
    pub fn add_normBoxTrapId(&mut self, normBoxTrapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_NORMBOXTRAPID,
            normBoxTrapId,
        );
    }
    #[inline]
    pub fn add_rareBoxTrapId(&mut self, rareBoxTrapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_RAREBOXTRAPID,
            rareBoxTrapId,
        );
    }
    #[inline]
    pub fn add_badBoxTrapId(&mut self, badBoxTrapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_BADBOXTRAPID,
            badBoxTrapId,
        );
    }
    #[inline]
    pub fn add_maxHpItemId(&mut self, maxHpItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_MAXHPITEMID,
            maxHpItemId,
        );
    }
    #[inline]
    pub fn add_shieldItemId(&mut self, shieldItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_SHIELDITEMID,
            shieldItemId,
        );
    }
    #[inline]
    pub fn add_keyItemId(&mut self, keyItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_KEYITEMID,
            keyItemId,
        );
    }
    #[inline]
    pub fn add_divinationKitItemId(
        &mut self,
        divinationKitItemId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_DIVINATIONKITITEMID,
            divinationKitItemId,
        );
    }
    #[inline]
    pub fn add_chestKeyCnt(&mut self, chestKeyCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameConst::VT_CHESTKEYCNT,
            chestKeyCnt,
            0,
        );
    }
    #[inline]
    pub fn add_chestKeyItemId(&mut self, chestKeyItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_CHESTKEYITEMID,
            chestKeyItemId,
        );
    }
    #[inline]
    pub fn add_keyColorId(&mut self, keyColorId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_KEYCOLORID,
            keyColorId,
        );
    }
    #[inline]
    pub fn add_onceNodeTypeList(
        &mut self,
        onceNodeTypeList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_RoguelikeEventType>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_ONCENODETYPELIST,
            onceNodeTypeList,
        );
    }
    #[inline]
    pub fn add_vertNodeCostDialogUseItemIconType(
        &mut self,
        vertNodeCostDialogUseItemIconType: bool,
    ) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeGameConst::VT_VERTNODECOSTDIALOGUSEITEMICONTYPE,
            vertNodeCostDialogUseItemIconType,
            false,
        );
    }
    #[inline]
    pub fn add_gpScoreRatio(&mut self, gpScoreRatio: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameConst::VT_GPSCORERATIO,
            gpScoreRatio,
            0,
        );
    }
    #[inline]
    pub fn add_overflowUsageSquadBuff(
        &mut self,
        overflowUsageSquadBuff: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_OVERFLOWUSAGESQUADBUFF,
            overflowUsageSquadBuff,
        );
    }
    #[inline]
    pub fn add_specialTrapId(&mut self, specialTrapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_SPECIALTRAPID,
            specialTrapId,
        );
    }
    #[inline]
    pub fn add_trapRewardRelicId(&mut self, trapRewardRelicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_TRAPREWARDRELICID,
            trapRewardRelicId,
        );
    }
    #[inline]
    pub fn add_unlockRouteItemId(&mut self, unlockRouteItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_UNLOCKROUTEITEMID,
            unlockRouteItemId,
        );
    }
    #[inline]
    pub fn add_unlockRouteItemCount(&mut self, unlockRouteItemCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameConst::VT_UNLOCKROUTEITEMCOUNT,
            unlockRouteItemCount,
            0,
        );
    }
    #[inline]
    pub fn add_hideBattleNodeName(&mut self, hideBattleNodeName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_HIDEBATTLENODENAME,
            hideBattleNodeName,
        );
    }
    #[inline]
    pub fn add_hideBattleNodeDescription(
        &mut self,
        hideBattleNodeDescription: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_HIDEBATTLENODEDESCRIPTION,
            hideBattleNodeDescription,
        );
    }
    #[inline]
    pub fn add_hideNonBattleNodeName(
        &mut self,
        hideNonBattleNodeName: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_HIDENONBATTLENODENAME,
            hideNonBattleNodeName,
        );
    }
    #[inline]
    pub fn add_hideNonBattleNodeDescription(
        &mut self,
        hideNonBattleNodeDescription: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_HIDENONBATTLENODEDESCRIPTION,
            hideNonBattleNodeDescription,
        );
    }
    #[inline]
    pub fn add_charSelectExpeditionConflictToast(
        &mut self,
        charSelectExpeditionConflictToast: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_CHARSELECTEXPEDITIONCONFLICTTOAST,
            charSelectExpeditionConflictToast,
        );
    }
    #[inline]
    pub fn add_charSelectNoUpgradeConflictToast(
        &mut self,
        charSelectNoUpgradeConflictToast: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_CHARSELECTNOUPGRADECONFLICTTOAST,
            charSelectNoUpgradeConflictToast,
        );
    }
    #[inline]
    pub fn add_itemDropTagDict(
        &mut self,
        itemDropTagDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__string<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_ITEMDROPTAGDICT,
            itemDropTagDict,
        );
    }
    #[inline]
    pub fn add_shopRefreshCostId(&mut self, shopRefreshCostId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_SHOPREFRESHCOSTID,
            shopRefreshCostId,
        );
    }
    #[inline]
    pub fn add_expeditionLeaveToastFormat(
        &mut self,
        expeditionLeaveToastFormat: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONLEAVETOASTFORMAT,
            expeditionLeaveToastFormat,
        );
    }
    #[inline]
    pub fn add_expeditionReturnDescCureUpgrade(
        &mut self,
        expeditionReturnDescCureUpgrade: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONRETURNDESCCUREUPGRADE,
            expeditionReturnDescCureUpgrade,
        );
    }
    #[inline]
    pub fn add_expeditionReturnDescUpgrade(
        &mut self,
        expeditionReturnDescUpgrade: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONRETURNDESCUPGRADE,
            expeditionReturnDescUpgrade,
        );
    }
    #[inline]
    pub fn add_expeditionReturnDescCure(
        &mut self,
        expeditionReturnDescCure: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONRETURNDESCCURE,
            expeditionReturnDescCure,
        );
    }
    #[inline]
    pub fn add_expeditionReturnDesc(
        &mut self,
        expeditionReturnDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONRETURNDESC,
            expeditionReturnDesc,
        );
    }
    #[inline]
    pub fn add_expeditionSelectDescFormat(
        &mut self,
        expeditionSelectDescFormat: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONSELECTDESCFORMAT,
            expeditionSelectDescFormat,
        );
    }
    #[inline]
    pub fn add_expeditionReturnDescItem(
        &mut self,
        expeditionReturnDescItem: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONRETURNDESCITEM,
            expeditionReturnDescItem,
        );
    }
    #[inline]
    pub fn add_expeditionReturnRewardBlackList(
        &mut self,
        expeditionReturnRewardBlackList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_EXPEDITIONRETURNREWARDBLACKLIST,
            expeditionReturnRewardBlackList,
        );
    }
    #[inline]
    pub fn add_travelLeaveToastFormat(
        &mut self,
        travelLeaveToastFormat: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_TRAVELLEAVETOASTFORMAT,
            travelLeaveToastFormat,
        );
    }
    #[inline]
    pub fn add_charSelectTravelConflictToast(
        &mut self,
        charSelectTravelConflictToast: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_CHARSELECTTRAVELCONFLICTTOAST,
            charSelectTravelConflictToast,
        );
    }
    #[inline]
    pub fn add_travelReturnDescUpgrade(
        &mut self,
        travelReturnDescUpgrade: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_TRAVELRETURNDESCUPGRADE,
            travelReturnDescUpgrade,
        );
    }
    #[inline]
    pub fn add_travelReturnDesc(&mut self, travelReturnDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_TRAVELRETURNDESC,
            travelReturnDesc,
        );
    }
    #[inline]
    pub fn add_travelReturnDescItem(
        &mut self,
        travelReturnDescItem: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_TRAVELRETURNDESCITEM,
            travelReturnDescItem,
        );
    }
    #[inline]
    pub fn add_traderReturnTitle(&mut self, traderReturnTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_TRADERRETURNTITLE,
            traderReturnTitle,
        );
    }
    #[inline]
    pub fn add_traderReturnDesc(&mut self, traderReturnDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_TRADERRETURNDESC,
            traderReturnDesc,
        );
    }
    #[inline]
    pub fn add_candleReturnDescCandleUpgrade(
        &mut self,
        candleReturnDescCandleUpgrade: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_CANDLERETURNDESCCANDLEUPGRADE,
            candleReturnDescCandleUpgrade,
        );
    }
    #[inline]
    pub fn add_candleReturnDescCandle(
        &mut self,
        candleReturnDescCandle: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_CANDLERETURNDESCCANDLE,
            candleReturnDescCandle,
        );
    }
    #[inline]
    pub fn add_charSelectCandleConflictToast(
        &mut self,
        charSelectCandleConflictToast: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_CHARSELECTCANDLECONFLICTTOAST,
            charSelectCandleConflictToast,
        );
    }
    #[inline]
    pub fn add_charSelectGuidedConflictToast(
        &mut self,
        charSelectGuidedConflictToast: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_CHARSELECTGUIDEDCONFLICTTOAST,
            charSelectGuidedConflictToast,
        );
    }
    #[inline]
    pub fn add_charSelectNonGuidedConflictToast(
        &mut self,
        charSelectNonGuidedConflictToast: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_CHARSELECTNONGUIDEDCONFLICTTOAST,
            charSelectNonGuidedConflictToast,
        );
    }
    #[inline]
    pub fn add_gainBuffDiffGrade(&mut self, gainBuffDiffGrade: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameConst::VT_GAINBUFFDIFFGRADE,
            gainBuffDiffGrade,
            0,
        );
    }
    #[inline]
    pub fn add_dsPredictTips(&mut self, dsPredictTips: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_DSPREDICTTIPS,
            dsPredictTips,
        );
    }
    #[inline]
    pub fn add_dsBuffActiveTips(&mut self, dsBuffActiveTips: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_DSBUFFACTIVETIPS,
            dsBuffActiveTips,
        );
    }
    #[inline]
    pub fn add_totemDesc(&mut self, totemDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_TOTEMDESC,
            totemDesc,
        );
    }
    #[inline]
    pub fn add_copperGildDesc(&mut self, copperGildDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_COPPERGILDDESC,
            copperGildDesc,
        );
    }
    #[inline]
    pub fn add_relicDesc(&mut self, relicDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_RELICDESC,
            relicDesc,
        );
    }
    #[inline]
    pub fn add_buffDesc(&mut self, buffDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_BUFFDESC,
            buffDesc,
        );
    }
    #[inline]
    pub fn add_refreshNodeItemId(&mut self, refreshNodeItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_REFRESHNODEITEMID,
            refreshNodeItemId,
        );
    }
    #[inline]
    pub fn add_storingRecruitDesc(&mut self, storingRecruitDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_STORINGRECRUITDESC,
            storingRecruitDesc,
        );
    }
    #[inline]
    pub fn add_storingRecruitSucceedToast(
        &mut self,
        storingRecruitSucceedToast: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_STORINGRECRUITSUCCEEDTOAST,
            storingRecruitSucceedToast,
        );
    }
    #[inline]
    pub fn add_specialRecruitReductionDesc(
        &mut self,
        specialRecruitReductionDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_SPECIALRECRUITREDUCTIONDESC,
            specialRecruitReductionDesc,
        );
    }
    #[inline]
    pub fn add_specialRecruitFuncDesc(
        &mut self,
        specialRecruitFuncDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_SPECIALRECRUITFUNCDESC,
            specialRecruitFuncDesc,
        );
    }
    #[inline]
    pub fn add_specialRecruitDetailDesc(
        &mut self,
        specialRecruitDetailDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_SPECIALRECRUITDETAILDESC,
            specialRecruitDetailDesc,
        );
    }
    #[inline]
    pub fn add_portalZones(
        &mut self,
        portalZones: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_PORTALZONES,
            portalZones,
        );
    }
    #[inline]
    pub fn add_diffDisplayZoneId(&mut self, diffDisplayZoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_DIFFDISPLAYZONEID,
            diffDisplayZoneId,
        );
    }
    #[inline]
    pub fn add_exploreExpOnKill(&mut self, exploreExpOnKill: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_EXPLOREEXPONKILL,
            exploreExpOnKill,
        );
    }
    #[inline]
    pub fn add_fusionName(&mut self, fusionName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_FUSIONNAME,
            fusionName,
        );
    }
    #[inline]
    pub fn add_fusionNotifyToast(&mut self, fusionNotifyToast: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_FUSIONNOTIFYTOAST,
            fusionNotifyToast,
        );
    }
    #[inline]
    pub fn add_haveSpZone(&mut self, haveSpZone: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeGameConst::VT_HAVESPZONE,
            haveSpZone,
            false,
        );
    }
    #[inline]
    pub fn add_gotCharCandleBuffToast(
        &mut self,
        gotCharCandleBuffToast: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_GOTCHARCANDLEBUFFTOAST,
            gotCharCandleBuffToast,
        );
    }
    #[inline]
    pub fn add_gotCharsCandleBuffToast(
        &mut self,
        gotCharsCandleBuffToast: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_GOTCHARSCANDLEBUFFTOAST,
            gotCharsCandleBuffToast,
        );
    }
    #[inline]
    pub fn add_stashedRecruitNodeDescription(
        &mut self,
        stashedRecruitNodeDescription: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_STASHEDRECRUITNODEDESCRIPTION,
            stashedRecruitNodeDescription,
        );
    }
    #[inline]
    pub fn add_stashedRecruitEmptyNodeDescription(
        &mut self,
        stashedRecruitEmptyNodeDescription: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameConst::VT_STASHEDRECRUITEMPTYNODEDESCRIPTION,
            stashedRecruitEmptyNodeDescription,
        );
    }
    #[inline]
    pub fn add_recruitStashMaxNum(&mut self, recruitStashMaxNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameConst::VT_RECRUITSTASHMAXNUM,
            recruitStashMaxNum,
            0,
        );
    }
    #[inline]
    pub fn add_recruitStashMinNum(&mut self, recruitStashMinNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameConst::VT_RECRUITSTASHMINNUM,
            recruitStashMinNum,
            0,
        );
    }
    #[inline]
    pub fn add_hasTopicCharSelectMenuButton(&mut self, hasTopicCharSelectMenuButton: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeGameConst::VT_HASTOPICCHARSELECTMENUBUTTON,
            hasTopicCharSelectMenuButton,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameConstBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameConstBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameConst<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameConst<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameConst");
        ds.field("initSceneName", &self.initSceneName());
        ds.field("failSceneName", &self.failSceneName());
        ds.field("hpItemId", &self.hpItemId());
        ds.field("goldItemId", &self.goldItemId());
        ds.field("populationItemId", &self.populationItemId());
        ds.field("squadCapacityItemId", &self.squadCapacityItemId());
        ds.field("expItemId", &self.expItemId());
        ds.field("initialBandShowGradeFlag", &self.initialBandShowGradeFlag());
        ds.field("bankMaxGold", &self.bankMaxGold());
        ds.field("bankCostId", &self.bankCostId());
        ds.field("bankDrawCount", &self.bankDrawCount());
        ds.field("bankDrawLimit", &self.bankDrawLimit());
        ds.field("bankRewardCountType", &self.bankRewardCountType());
        ds.field("spZoneShopBgmSignal", &self.spZoneShopBgmSignal());
        ds.field("mimicEnemyIds", &self.mimicEnemyIds());
        ds.field("bossIds", &self.bossIds());
        ds.field("goldChestTrapId", &self.goldChestTrapId());
        ds.field("normBoxTrapId", &self.normBoxTrapId());
        ds.field("rareBoxTrapId", &self.rareBoxTrapId());
        ds.field("badBoxTrapId", &self.badBoxTrapId());
        ds.field("maxHpItemId", &self.maxHpItemId());
        ds.field("shieldItemId", &self.shieldItemId());
        ds.field("keyItemId", &self.keyItemId());
        ds.field("divinationKitItemId", &self.divinationKitItemId());
        ds.field("chestKeyCnt", &self.chestKeyCnt());
        ds.field("chestKeyItemId", &self.chestKeyItemId());
        ds.field("keyColorId", &self.keyColorId());
        ds.field("onceNodeTypeList", &self.onceNodeTypeList());
        ds.field(
            "vertNodeCostDialogUseItemIconType",
            &self.vertNodeCostDialogUseItemIconType(),
        );
        ds.field("gpScoreRatio", &self.gpScoreRatio());
        ds.field("overflowUsageSquadBuff", &self.overflowUsageSquadBuff());
        ds.field("specialTrapId", &self.specialTrapId());
        ds.field("trapRewardRelicId", &self.trapRewardRelicId());
        ds.field("unlockRouteItemId", &self.unlockRouteItemId());
        ds.field("unlockRouteItemCount", &self.unlockRouteItemCount());
        ds.field("hideBattleNodeName", &self.hideBattleNodeName());
        ds.field(
            "hideBattleNodeDescription",
            &self.hideBattleNodeDescription(),
        );
        ds.field("hideNonBattleNodeName", &self.hideNonBattleNodeName());
        ds.field(
            "hideNonBattleNodeDescription",
            &self.hideNonBattleNodeDescription(),
        );
        ds.field(
            "charSelectExpeditionConflictToast",
            &self.charSelectExpeditionConflictToast(),
        );
        ds.field(
            "charSelectNoUpgradeConflictToast",
            &self.charSelectNoUpgradeConflictToast(),
        );
        ds.field("itemDropTagDict", &self.itemDropTagDict());
        ds.field("shopRefreshCostId", &self.shopRefreshCostId());
        ds.field(
            "expeditionLeaveToastFormat",
            &self.expeditionLeaveToastFormat(),
        );
        ds.field(
            "expeditionReturnDescCureUpgrade",
            &self.expeditionReturnDescCureUpgrade(),
        );
        ds.field(
            "expeditionReturnDescUpgrade",
            &self.expeditionReturnDescUpgrade(),
        );
        ds.field("expeditionReturnDescCure", &self.expeditionReturnDescCure());
        ds.field("expeditionReturnDesc", &self.expeditionReturnDesc());
        ds.field(
            "expeditionSelectDescFormat",
            &self.expeditionSelectDescFormat(),
        );
        ds.field("expeditionReturnDescItem", &self.expeditionReturnDescItem());
        ds.field(
            "expeditionReturnRewardBlackList",
            &self.expeditionReturnRewardBlackList(),
        );
        ds.field("travelLeaveToastFormat", &self.travelLeaveToastFormat());
        ds.field(
            "charSelectTravelConflictToast",
            &self.charSelectTravelConflictToast(),
        );
        ds.field("travelReturnDescUpgrade", &self.travelReturnDescUpgrade());
        ds.field("travelReturnDesc", &self.travelReturnDesc());
        ds.field("travelReturnDescItem", &self.travelReturnDescItem());
        ds.field("traderReturnTitle", &self.traderReturnTitle());
        ds.field("traderReturnDesc", &self.traderReturnDesc());
        ds.field(
            "candleReturnDescCandleUpgrade",
            &self.candleReturnDescCandleUpgrade(),
        );
        ds.field("candleReturnDescCandle", &self.candleReturnDescCandle());
        ds.field(
            "charSelectCandleConflictToast",
            &self.charSelectCandleConflictToast(),
        );
        ds.field(
            "charSelectGuidedConflictToast",
            &self.charSelectGuidedConflictToast(),
        );
        ds.field(
            "charSelectNonGuidedConflictToast",
            &self.charSelectNonGuidedConflictToast(),
        );
        ds.field("gainBuffDiffGrade", &self.gainBuffDiffGrade());
        ds.field("dsPredictTips", &self.dsPredictTips());
        ds.field("dsBuffActiveTips", &self.dsBuffActiveTips());
        ds.field("totemDesc", &self.totemDesc());
        ds.field("copperGildDesc", &self.copperGildDesc());
        ds.field("relicDesc", &self.relicDesc());
        ds.field("buffDesc", &self.buffDesc());
        ds.field("refreshNodeItemId", &self.refreshNodeItemId());
        ds.field("storingRecruitDesc", &self.storingRecruitDesc());
        ds.field(
            "storingRecruitSucceedToast",
            &self.storingRecruitSucceedToast(),
        );
        ds.field(
            "specialRecruitReductionDesc",
            &self.specialRecruitReductionDesc(),
        );
        ds.field("specialRecruitFuncDesc", &self.specialRecruitFuncDesc());
        ds.field("specialRecruitDetailDesc", &self.specialRecruitDetailDesc());
        ds.field("portalZones", &self.portalZones());
        ds.field("diffDisplayZoneId", &self.diffDisplayZoneId());
        ds.field("exploreExpOnKill", &self.exploreExpOnKill());
        ds.field("fusionName", &self.fusionName());
        ds.field("fusionNotifyToast", &self.fusionNotifyToast());
        ds.field("haveSpZone", &self.haveSpZone());
        ds.field("gotCharCandleBuffToast", &self.gotCharCandleBuffToast());
        ds.field("gotCharsCandleBuffToast", &self.gotCharsCandleBuffToast());
        ds.field(
            "stashedRecruitNodeDescription",
            &self.stashedRecruitNodeDescription(),
        );
        ds.field(
            "stashedRecruitEmptyNodeDescription",
            &self.stashedRecruitEmptyNodeDescription(),
        );
        ds.field("recruitStashMaxNum", &self.recruitStashMaxNum());
        ds.field("recruitStashMinNum", &self.recruitStashMinNum());
        ds.field(
            "hasTopicCharSelectMenuButton",
            &self.hasTopicCharSelectMenuButton(),
        );
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameConstT {
    pub initSceneName: Option<String>,
    pub failSceneName: Option<String>,
    pub hpItemId: Option<String>,
    pub goldItemId: Option<String>,
    pub populationItemId: Option<String>,
    pub squadCapacityItemId: Option<String>,
    pub expItemId: Option<String>,
    pub initialBandShowGradeFlag: bool,
    pub bankMaxGold: i32,
    pub bankCostId: Option<String>,
    pub bankDrawCount: i32,
    pub bankDrawLimit: i32,
    pub bankRewardCountType: enum__Torappu_RoguelikeBankRewardCountType,
    pub spZoneShopBgmSignal: Option<String>,
    pub mimicEnemyIds: Option<Vec<String>>,
    pub bossIds: Option<Vec<String>>,
    pub goldChestTrapId: Option<String>,
    pub normBoxTrapId: Option<String>,
    pub rareBoxTrapId: Option<String>,
    pub badBoxTrapId: Option<String>,
    pub maxHpItemId: Option<String>,
    pub shieldItemId: Option<String>,
    pub keyItemId: Option<String>,
    pub divinationKitItemId: Option<String>,
    pub chestKeyCnt: i32,
    pub chestKeyItemId: Option<String>,
    pub keyColorId: Option<String>,
    pub onceNodeTypeList: Option<Vec<enum__Torappu_RoguelikeEventType>>,
    pub vertNodeCostDialogUseItemIconType: bool,
    pub gpScoreRatio: i32,
    pub overflowUsageSquadBuff: Option<String>,
    pub specialTrapId: Option<String>,
    pub trapRewardRelicId: Option<String>,
    pub unlockRouteItemId: Option<String>,
    pub unlockRouteItemCount: i32,
    pub hideBattleNodeName: Option<String>,
    pub hideBattleNodeDescription: Option<String>,
    pub hideNonBattleNodeName: Option<String>,
    pub hideNonBattleNodeDescription: Option<String>,
    pub charSelectExpeditionConflictToast: Option<String>,
    pub charSelectNoUpgradeConflictToast: Option<String>,
    pub itemDropTagDict: Option<Vec<dict__enum__Torappu_RoguelikeRewardExDropTagSrcType__stringT>>,
    pub shopRefreshCostId: Option<String>,
    pub expeditionLeaveToastFormat: Option<String>,
    pub expeditionReturnDescCureUpgrade: Option<String>,
    pub expeditionReturnDescUpgrade: Option<String>,
    pub expeditionReturnDescCure: Option<String>,
    pub expeditionReturnDesc: Option<String>,
    pub expeditionSelectDescFormat: Option<String>,
    pub expeditionReturnDescItem: Option<String>,
    pub expeditionReturnRewardBlackList: Option<Vec<String>>,
    pub travelLeaveToastFormat: Option<String>,
    pub charSelectTravelConflictToast: Option<String>,
    pub travelReturnDescUpgrade: Option<String>,
    pub travelReturnDesc: Option<String>,
    pub travelReturnDescItem: Option<String>,
    pub traderReturnTitle: Option<String>,
    pub traderReturnDesc: Option<String>,
    pub candleReturnDescCandleUpgrade: Option<String>,
    pub candleReturnDescCandle: Option<String>,
    pub charSelectCandleConflictToast: Option<String>,
    pub charSelectGuidedConflictToast: Option<String>,
    pub charSelectNonGuidedConflictToast: Option<String>,
    pub gainBuffDiffGrade: i32,
    pub dsPredictTips: Option<String>,
    pub dsBuffActiveTips: Option<String>,
    pub totemDesc: Option<String>,
    pub copperGildDesc: Option<String>,
    pub relicDesc: Option<String>,
    pub buffDesc: Option<String>,
    pub refreshNodeItemId: Option<String>,
    pub storingRecruitDesc: Option<String>,
    pub storingRecruitSucceedToast: Option<String>,
    pub specialRecruitReductionDesc: Option<String>,
    pub specialRecruitFuncDesc: Option<String>,
    pub specialRecruitDetailDesc: Option<String>,
    pub portalZones: Option<Vec<String>>,
    pub diffDisplayZoneId: Option<String>,
    pub exploreExpOnKill: Option<String>,
    pub fusionName: Option<String>,
    pub fusionNotifyToast: Option<String>,
    pub haveSpZone: bool,
    pub gotCharCandleBuffToast: Option<String>,
    pub gotCharsCandleBuffToast: Option<String>,
    pub stashedRecruitNodeDescription: Option<String>,
    pub stashedRecruitEmptyNodeDescription: Option<String>,
    pub recruitStashMaxNum: i32,
    pub recruitStashMinNum: i32,
    pub hasTopicCharSelectMenuButton: bool,
}
impl Default for clz_Torappu_RoguelikeGameConstT {
    fn default() -> Self {
        Self {
            initSceneName: None,
            failSceneName: None,
            hpItemId: None,
            goldItemId: None,
            populationItemId: None,
            squadCapacityItemId: None,
            expItemId: None,
            initialBandShowGradeFlag: false,
            bankMaxGold: 0,
            bankCostId: None,
            bankDrawCount: 0,
            bankDrawLimit: 0,
            bankRewardCountType: enum__Torappu_RoguelikeBankRewardCountType::HIGHEST_RECORD,
            spZoneShopBgmSignal: None,
            mimicEnemyIds: None,
            bossIds: None,
            goldChestTrapId: None,
            normBoxTrapId: None,
            rareBoxTrapId: None,
            badBoxTrapId: None,
            maxHpItemId: None,
            shieldItemId: None,
            keyItemId: None,
            divinationKitItemId: None,
            chestKeyCnt: 0,
            chestKeyItemId: None,
            keyColorId: None,
            onceNodeTypeList: None,
            vertNodeCostDialogUseItemIconType: false,
            gpScoreRatio: 0,
            overflowUsageSquadBuff: None,
            specialTrapId: None,
            trapRewardRelicId: None,
            unlockRouteItemId: None,
            unlockRouteItemCount: 0,
            hideBattleNodeName: None,
            hideBattleNodeDescription: None,
            hideNonBattleNodeName: None,
            hideNonBattleNodeDescription: None,
            charSelectExpeditionConflictToast: None,
            charSelectNoUpgradeConflictToast: None,
            itemDropTagDict: None,
            shopRefreshCostId: None,
            expeditionLeaveToastFormat: None,
            expeditionReturnDescCureUpgrade: None,
            expeditionReturnDescUpgrade: None,
            expeditionReturnDescCure: None,
            expeditionReturnDesc: None,
            expeditionSelectDescFormat: None,
            expeditionReturnDescItem: None,
            expeditionReturnRewardBlackList: None,
            travelLeaveToastFormat: None,
            charSelectTravelConflictToast: None,
            travelReturnDescUpgrade: None,
            travelReturnDesc: None,
            travelReturnDescItem: None,
            traderReturnTitle: None,
            traderReturnDesc: None,
            candleReturnDescCandleUpgrade: None,
            candleReturnDescCandle: None,
            charSelectCandleConflictToast: None,
            charSelectGuidedConflictToast: None,
            charSelectNonGuidedConflictToast: None,
            gainBuffDiffGrade: 0,
            dsPredictTips: None,
            dsBuffActiveTips: None,
            totemDesc: None,
            copperGildDesc: None,
            relicDesc: None,
            buffDesc: None,
            refreshNodeItemId: None,
            storingRecruitDesc: None,
            storingRecruitSucceedToast: None,
            specialRecruitReductionDesc: None,
            specialRecruitFuncDesc: None,
            specialRecruitDetailDesc: None,
            portalZones: None,
            diffDisplayZoneId: None,
            exploreExpOnKill: None,
            fusionName: None,
            fusionNotifyToast: None,
            haveSpZone: false,
            gotCharCandleBuffToast: None,
            gotCharsCandleBuffToast: None,
            stashedRecruitNodeDescription: None,
            stashedRecruitEmptyNodeDescription: None,
            recruitStashMaxNum: 0,
            recruitStashMinNum: 0,
            hasTopicCharSelectMenuButton: false,
        }
    }
}
impl clz_Torappu_RoguelikeGameConstT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameConst<'b>> {
        let initSceneName = self.initSceneName.as_ref().map(|x| _fbb.create_string(x));
        let failSceneName = self.failSceneName.as_ref().map(|x| _fbb.create_string(x));
        let hpItemId = self.hpItemId.as_ref().map(|x| _fbb.create_string(x));
        let goldItemId = self.goldItemId.as_ref().map(|x| _fbb.create_string(x));
        let populationItemId = self
            .populationItemId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let squadCapacityItemId = self
            .squadCapacityItemId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let expItemId = self.expItemId.as_ref().map(|x| _fbb.create_string(x));
        let initialBandShowGradeFlag = self.initialBandShowGradeFlag;
        let bankMaxGold = self.bankMaxGold;
        let bankCostId = self.bankCostId.as_ref().map(|x| _fbb.create_string(x));
        let bankDrawCount = self.bankDrawCount;
        let bankDrawLimit = self.bankDrawLimit;
        let bankRewardCountType = self.bankRewardCountType;
        let spZoneShopBgmSignal = self
            .spZoneShopBgmSignal
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let mimicEnemyIds = self.mimicEnemyIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let bossIds = self.bossIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let goldChestTrapId = self.goldChestTrapId.as_ref().map(|x| _fbb.create_string(x));
        let normBoxTrapId = self.normBoxTrapId.as_ref().map(|x| _fbb.create_string(x));
        let rareBoxTrapId = self.rareBoxTrapId.as_ref().map(|x| _fbb.create_string(x));
        let badBoxTrapId = self.badBoxTrapId.as_ref().map(|x| _fbb.create_string(x));
        let maxHpItemId = self.maxHpItemId.as_ref().map(|x| _fbb.create_string(x));
        let shieldItemId = self.shieldItemId.as_ref().map(|x| _fbb.create_string(x));
        let keyItemId = self.keyItemId.as_ref().map(|x| _fbb.create_string(x));
        let divinationKitItemId = self
            .divinationKitItemId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let chestKeyCnt = self.chestKeyCnt;
        let chestKeyItemId = self.chestKeyItemId.as_ref().map(|x| _fbb.create_string(x));
        let keyColorId = self.keyColorId.as_ref().map(|x| _fbb.create_string(x));
        let onceNodeTypeList = self
            .onceNodeTypeList
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let vertNodeCostDialogUseItemIconType = self.vertNodeCostDialogUseItemIconType;
        let gpScoreRatio = self.gpScoreRatio;
        let overflowUsageSquadBuff = self
            .overflowUsageSquadBuff
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let specialTrapId = self.specialTrapId.as_ref().map(|x| _fbb.create_string(x));
        let trapRewardRelicId = self
            .trapRewardRelicId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let unlockRouteItemId = self
            .unlockRouteItemId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let unlockRouteItemCount = self.unlockRouteItemCount;
        let hideBattleNodeName = self
            .hideBattleNodeName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let hideBattleNodeDescription = self
            .hideBattleNodeDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let hideNonBattleNodeName = self
            .hideNonBattleNodeName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let hideNonBattleNodeDescription = self
            .hideNonBattleNodeDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let charSelectExpeditionConflictToast = self
            .charSelectExpeditionConflictToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let charSelectNoUpgradeConflictToast = self
            .charSelectNoUpgradeConflictToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let itemDropTagDict = self.itemDropTagDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let shopRefreshCostId = self
            .shopRefreshCostId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let expeditionLeaveToastFormat = self
            .expeditionLeaveToastFormat
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let expeditionReturnDescCureUpgrade = self
            .expeditionReturnDescCureUpgrade
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let expeditionReturnDescUpgrade = self
            .expeditionReturnDescUpgrade
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let expeditionReturnDescCure = self
            .expeditionReturnDescCure
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let expeditionReturnDesc = self
            .expeditionReturnDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let expeditionSelectDescFormat = self
            .expeditionSelectDescFormat
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let expeditionReturnDescItem = self
            .expeditionReturnDescItem
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let expeditionReturnRewardBlackList =
            self.expeditionReturnRewardBlackList.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
                _fbb.create_vector(&w)
            });
        let travelLeaveToastFormat = self
            .travelLeaveToastFormat
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let charSelectTravelConflictToast = self
            .charSelectTravelConflictToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let travelReturnDescUpgrade = self
            .travelReturnDescUpgrade
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let travelReturnDesc = self
            .travelReturnDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let travelReturnDescItem = self
            .travelReturnDescItem
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let traderReturnTitle = self
            .traderReturnTitle
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let traderReturnDesc = self
            .traderReturnDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let candleReturnDescCandleUpgrade = self
            .candleReturnDescCandleUpgrade
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let candleReturnDescCandle = self
            .candleReturnDescCandle
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let charSelectCandleConflictToast = self
            .charSelectCandleConflictToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let charSelectGuidedConflictToast = self
            .charSelectGuidedConflictToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let charSelectNonGuidedConflictToast = self
            .charSelectNonGuidedConflictToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let gainBuffDiffGrade = self.gainBuffDiffGrade;
        let dsPredictTips = self.dsPredictTips.as_ref().map(|x| _fbb.create_string(x));
        let dsBuffActiveTips = self
            .dsBuffActiveTips
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let totemDesc = self.totemDesc.as_ref().map(|x| _fbb.create_string(x));
        let copperGildDesc = self.copperGildDesc.as_ref().map(|x| _fbb.create_string(x));
        let relicDesc = self.relicDesc.as_ref().map(|x| _fbb.create_string(x));
        let buffDesc = self.buffDesc.as_ref().map(|x| _fbb.create_string(x));
        let refreshNodeItemId = self
            .refreshNodeItemId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let storingRecruitDesc = self
            .storingRecruitDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let storingRecruitSucceedToast = self
            .storingRecruitSucceedToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let specialRecruitReductionDesc = self
            .specialRecruitReductionDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let specialRecruitFuncDesc = self
            .specialRecruitFuncDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let specialRecruitDetailDesc = self
            .specialRecruitDetailDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let portalZones = self.portalZones.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let diffDisplayZoneId = self
            .diffDisplayZoneId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let exploreExpOnKill = self
            .exploreExpOnKill
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let fusionName = self.fusionName.as_ref().map(|x| _fbb.create_string(x));
        let fusionNotifyToast = self
            .fusionNotifyToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let haveSpZone = self.haveSpZone;
        let gotCharCandleBuffToast = self
            .gotCharCandleBuffToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let gotCharsCandleBuffToast = self
            .gotCharsCandleBuffToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let stashedRecruitNodeDescription = self
            .stashedRecruitNodeDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let stashedRecruitEmptyNodeDescription = self
            .stashedRecruitEmptyNodeDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let recruitStashMaxNum = self.recruitStashMaxNum;
        let recruitStashMinNum = self.recruitStashMinNum;
        let hasTopicCharSelectMenuButton = self.hasTopicCharSelectMenuButton;
        clz_Torappu_RoguelikeGameConst::create(
            _fbb,
            &clz_Torappu_RoguelikeGameConstArgs {
                initSceneName,
                failSceneName,
                hpItemId,
                goldItemId,
                populationItemId,
                squadCapacityItemId,
                expItemId,
                initialBandShowGradeFlag,
                bankMaxGold,
                bankCostId,
                bankDrawCount,
                bankDrawLimit,
                bankRewardCountType,
                spZoneShopBgmSignal,
                mimicEnemyIds,
                bossIds,
                goldChestTrapId,
                normBoxTrapId,
                rareBoxTrapId,
                badBoxTrapId,
                maxHpItemId,
                shieldItemId,
                keyItemId,
                divinationKitItemId,
                chestKeyCnt,
                chestKeyItemId,
                keyColorId,
                onceNodeTypeList,
                vertNodeCostDialogUseItemIconType,
                gpScoreRatio,
                overflowUsageSquadBuff,
                specialTrapId,
                trapRewardRelicId,
                unlockRouteItemId,
                unlockRouteItemCount,
                hideBattleNodeName,
                hideBattleNodeDescription,
                hideNonBattleNodeName,
                hideNonBattleNodeDescription,
                charSelectExpeditionConflictToast,
                charSelectNoUpgradeConflictToast,
                itemDropTagDict,
                shopRefreshCostId,
                expeditionLeaveToastFormat,
                expeditionReturnDescCureUpgrade,
                expeditionReturnDescUpgrade,
                expeditionReturnDescCure,
                expeditionReturnDesc,
                expeditionSelectDescFormat,
                expeditionReturnDescItem,
                expeditionReturnRewardBlackList,
                travelLeaveToastFormat,
                charSelectTravelConflictToast,
                travelReturnDescUpgrade,
                travelReturnDesc,
                travelReturnDescItem,
                traderReturnTitle,
                traderReturnDesc,
                candleReturnDescCandleUpgrade,
                candleReturnDescCandle,
                charSelectCandleConflictToast,
                charSelectGuidedConflictToast,
                charSelectNonGuidedConflictToast,
                gainBuffDiffGrade,
                dsPredictTips,
                dsBuffActiveTips,
                totemDesc,
                copperGildDesc,
                relicDesc,
                buffDesc,
                refreshNodeItemId,
                storingRecruitDesc,
                storingRecruitSucceedToast,
                specialRecruitReductionDesc,
                specialRecruitFuncDesc,
                specialRecruitDetailDesc,
                portalZones,
                diffDisplayZoneId,
                exploreExpOnKill,
                fusionName,
                fusionNotifyToast,
                haveSpZone,
                gotCharCandleBuffToast,
                gotCharsCandleBuffToast,
                stashedRecruitNodeDescription,
                stashedRecruitEmptyNodeDescription,
                recruitStashMaxNum,
                recruitStashMinNum,
                hasTopicCharSelectMenuButton,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameShopDialogGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameShopDialogGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameShopDialogGroupData<'a> {
    type Inner = clz_Torappu_RoguelikeGameShopDialogGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameShopDialogGroupData<'a> {
    pub const VT_CONTENT: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameShopDialogGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameShopDialogGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogGroupData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameShopDialogGroupDataBuilder::new(_fbb);
        if let Some(x) = args.content {
            builder.add_content(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameShopDialogGroupDataT {
        let content = self
            .content()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_RoguelikeGameShopDialogGroupDataT { content }
    }

    #[inline]
    pub fn content(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RoguelikeGameShopDialogGroupData::VT_CONTENT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameShopDialogGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("content", Self::VT_CONTENT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameShopDialogGroupDataArgs<'a> {
    pub content: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeGameShopDialogGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameShopDialogGroupDataArgs { content: None }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameShopDialogGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeGameShopDialogGroupData", 1)?;
        if let Some(f) = self.content() {
            s.serialize_field("content", &f)?;
        } else {
            s.skip_field("content")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameShopDialogGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameShopDialogGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_content(
        &mut self,
        content: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameShopDialogGroupData::VT_CONTENT,
            content,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameShopDialogGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameShopDialogGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameShopDialogGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameShopDialogGroupData");
        ds.field("content", &self.content());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameShopDialogGroupDataT {
    pub content: Option<Vec<String>>,
}
impl Default for clz_Torappu_RoguelikeGameShopDialogGroupDataT {
    fn default() -> Self {
        Self { content: None }
    }
}
impl clz_Torappu_RoguelikeGameShopDialogGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogGroupData<'b>> {
        let content = self.content.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeGameShopDialogGroupData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameShopDialogGroupDataArgs { content },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData<'a>
{
    type Inner = dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameShopDialogGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameShopDialogGroupData>>(
                    dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameShopDialogGroupData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogGroupData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogGroupData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogGroupData>>(dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameShopDialogGroupDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameShopDialogTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameShopDialogTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameShopDialogTypeData<'a> {
    type Inner = clz_Torappu_RoguelikeGameShopDialogTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameShopDialogTypeData<'a> {
    pub const VT_GROUPS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameShopDialogTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameShopDialogTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogTypeData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameShopDialogTypeDataBuilder::new(_fbb);
        if let Some(x) = args.groups {
            builder.add_groups(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameShopDialogTypeDataT {
        let groups = self
            .groups()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeGameShopDialogTypeDataT { groups }
    }

    #[inline]
    pub fn groups(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeGameShopDialogTypeData::VT_GROUPS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameShopDialogTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData,
                    >,
                >,
            >>("groups", Self::VT_GROUPS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameShopDialogTypeDataArgs<'a> {
    pub groups: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeGameShopDialogTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameShopDialogTypeDataArgs { groups: None }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameShopDialogTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeGameShopDialogTypeData", 1)?;
        if let Some(f) = self.groups() {
            s.serialize_field("groups", &f)?;
        } else {
            s.skip_field("groups")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameShopDialogTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameShopDialogTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_groups(
        &mut self,
        groups: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameShopDialogGroupData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameShopDialogTypeData::VT_GROUPS,
            groups,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameShopDialogTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameShopDialogTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameShopDialogTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameShopDialogTypeData");
        ds.field("groups", &self.groups());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameShopDialogTypeDataT {
    pub groups: Option<Vec<dict__string__clz_Torappu_RoguelikeGameShopDialogGroupDataT>>,
}
impl Default for clz_Torappu_RoguelikeGameShopDialogTypeDataT {
    fn default() -> Self {
        Self { groups: None }
    }
}
impl clz_Torappu_RoguelikeGameShopDialogTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogTypeData<'b>> {
        let groups = self.groups.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeGameShopDialogTypeData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameShopDialogTypeDataArgs { groups },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameShopDialogTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameShopDialogTypeData>>(
                    dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameShopDialogTypeData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogTypeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogTypeData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogTypeData>>(dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameShopDialogTypeDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameShopDialogDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameShopDialogData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameShopDialogData<'a> {
    type Inner = clz_Torappu_RoguelikeGameShopDialogData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameShopDialogData<'a> {
    pub const VT_TYPES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameShopDialogData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameShopDialogDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameShopDialogDataBuilder::new(_fbb);
        if let Some(x) = args.types {
            builder.add_types(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameShopDialogDataT {
        let types = self.types().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeGameShopDialogDataT { types }
    }

    #[inline]
    pub fn types(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeGameShopDialogData::VT_TYPES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameShopDialogData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData,
                    >,
                >,
            >>("types", Self::VT_TYPES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameShopDialogDataArgs<'a> {
    pub types: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeGameShopDialogDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameShopDialogDataArgs { types: None }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameShopDialogData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameShopDialogData", 1)?;
        if let Some(f) = self.types() {
            s.serialize_field("types", &f)?;
        } else {
            s.skip_field("types")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameShopDialogDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameShopDialogDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_types(
        &mut self,
        types: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameShopDialogTypeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameShopDialogData::VT_TYPES,
            types,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameShopDialogDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameShopDialogDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameShopDialogData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameShopDialogData");
        ds.field("types", &self.types());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameShopDialogDataT {
    pub types: Option<Vec<dict__string__clz_Torappu_RoguelikeGameShopDialogTypeDataT>>,
}
impl Default for clz_Torappu_RoguelikeGameShopDialogDataT {
    fn default() -> Self {
        Self { types: None }
    }
}
impl clz_Torappu_RoguelikeGameShopDialogDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogData<'b>> {
        let types = self.types.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeGameShopDialogData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameShopDialogDataArgs { types },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicCapsuleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicCapsule<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicCapsule<'a> {
    type Inner = clz_Torappu_RoguelikeTopicCapsule<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicCapsule<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_MASKTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_INNERCOLOR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicCapsule { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicCapsuleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicCapsule<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicCapsuleBuilder::new(_fbb);
        if let Some(x) = args.innerColor {
            builder.add_innerColor(x);
        }
        builder.add_maskType(args.maskType);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicCapsuleT {
        let itemId = self.itemId().map(|x| x.to_string());
        let maskType = self.maskType();
        let innerColor = self.innerColor().map(|x| x.to_string());
        clz_Torappu_RoguelikeTopicCapsuleT {
            itemId,
            maskType,
            innerColor,
        }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicCapsule::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn maskType(&self) -> enum__Torappu_RoguelikeEventType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeEventType>(
                    clz_Torappu_RoguelikeTopicCapsule::VT_MASKTYPE,
                    Some(enum__Torappu_RoguelikeEventType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn innerColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicCapsule::VT_INNERCOLOR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicCapsule<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<enum__Torappu_RoguelikeEventType>("maskType", Self::VT_MASKTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "innerColor",
                Self::VT_INNERCOLOR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicCapsuleArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maskType: enum__Torappu_RoguelikeEventType,
    pub innerColor: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicCapsuleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicCapsuleArgs {
            itemId: None,
            maskType: enum__Torappu_RoguelikeEventType::NONE,
            innerColor: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicCapsule<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicCapsule", 3)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        s.serialize_field("maskType", &self.maskType())?;
        if let Some(f) = self.innerColor() {
            s.serialize_field("innerColor", &f)?;
        } else {
            s.skip_field("innerColor")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicCapsuleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicCapsuleBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicCapsule::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_maskType(&mut self, maskType: enum__Torappu_RoguelikeEventType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeEventType>(
            clz_Torappu_RoguelikeTopicCapsule::VT_MASKTYPE,
            maskType,
            enum__Torappu_RoguelikeEventType::NONE,
        );
    }
    #[inline]
    pub fn add_innerColor(&mut self, innerColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicCapsule::VT_INNERCOLOR,
            innerColor,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicCapsuleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicCapsuleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicCapsule<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicCapsule<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicCapsule");
        ds.field("itemId", &self.itemId());
        ds.field("maskType", &self.maskType());
        ds.field("innerColor", &self.innerColor());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicCapsuleT {
    pub itemId: Option<String>,
    pub maskType: enum__Torappu_RoguelikeEventType,
    pub innerColor: Option<String>,
}
impl Default for clz_Torappu_RoguelikeTopicCapsuleT {
    fn default() -> Self {
        Self {
            itemId: None,
            maskType: enum__Torappu_RoguelikeEventType::NONE,
            innerColor: None,
        }
    }
}
impl clz_Torappu_RoguelikeTopicCapsuleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicCapsule<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let maskType = self.maskType;
        let innerColor = self.innerColor.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeTopicCapsule::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicCapsuleArgs {
                itemId,
                maskType,
                innerColor,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeTopicCapsuleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeTopicCapsule<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeTopicCapsule<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeTopicCapsule<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeTopicCapsule<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeTopicCapsule { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeTopicCapsuleArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicCapsule<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeTopicCapsuleBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeTopicCapsuleT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeTopicCapsuleT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeTopicCapsule::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeTopicCapsule,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeTopicCapsule<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicCapsule>>(
                    dict__string__clz_Torappu_RoguelikeTopicCapsule::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeTopicCapsule<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicCapsule>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeTopicCapsuleArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicCapsule<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeTopicCapsuleArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeTopicCapsuleArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeTopicCapsule<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeTopicCapsule", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeTopicCapsuleBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeTopicCapsuleBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeTopicCapsule::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicCapsule<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicCapsule>>(
                dict__string__clz_Torappu_RoguelikeTopicCapsule::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeTopicCapsuleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeTopicCapsuleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicCapsule<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeTopicCapsule::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeTopicCapsule<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeTopicCapsule");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeTopicCapsuleT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeTopicCapsuleT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeTopicCapsuleT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeTopicCapsuleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicCapsule<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeTopicCapsule::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeTopicCapsuleArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameEndingData_LevelIconOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameEndingData_LevelIcon<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameEndingData_LevelIcon<'a> {
    type Inner = clz_Torappu_RoguelikeGameEndingData_LevelIcon<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameEndingData_LevelIcon<'a> {
    pub const VT_LEVEL: flatbuffers::VOffsetT = 4;
    pub const VT_ICONID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameEndingData_LevelIcon { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameEndingData_LevelIconArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameEndingData_LevelIcon<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameEndingData_LevelIconBuilder::new(_fbb);
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        builder.add_level(args.level);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameEndingData_LevelIconT {
        let level = self.level();
        let iconId = self.iconId().map(|x| x.to_string());
        clz_Torappu_RoguelikeGameEndingData_LevelIconT { level, iconId }
    }

    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeGameEndingData_LevelIcon::VT_LEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameEndingData_LevelIcon::VT_ICONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameEndingData_LevelIcon<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameEndingData_LevelIconArgs<'a> {
    pub level: i32,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeGameEndingData_LevelIconArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameEndingData_LevelIconArgs {
            level: 0,
            iconId: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameEndingData_LevelIcon<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeGameEndingData_LevelIcon", 2)?;
        s.serialize_field("level", &self.level())?;
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameEndingData_LevelIconBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameEndingData_LevelIconBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameEndingData_LevelIcon::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameEndingData_LevelIcon::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameEndingData_LevelIconBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameEndingData_LevelIconBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameEndingData_LevelIcon<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameEndingData_LevelIcon<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameEndingData_LevelIcon");
        ds.field("level", &self.level());
        ds.field("iconId", &self.iconId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameEndingData_LevelIconT {
    pub level: i32,
    pub iconId: Option<String>,
}
impl Default for clz_Torappu_RoguelikeGameEndingData_LevelIconT {
    fn default() -> Self {
        Self {
            level: 0,
            iconId: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameEndingData_LevelIconT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameEndingData_LevelIcon<'b>> {
        let level = self.level;
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeGameEndingData_LevelIcon::create(
            _fbb,
            &clz_Torappu_RoguelikeGameEndingData_LevelIconArgs { level, iconId },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameEndingDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameEndingData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameEndingData<'a> {
    type Inner = clz_Torappu_RoguelikeGameEndingData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameEndingData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_FAMILYID: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_DESC: flatbuffers::VOffsetT = 10;
    pub const VT_BGID: flatbuffers::VOffsetT = 12;
    pub const VT_ICONS: flatbuffers::VOffsetT = 14;
    pub const VT_PRIORITY: flatbuffers::VOffsetT = 16;
    pub const VT_CHANGEENDINGDESC: flatbuffers::VOffsetT = 18;
    pub const VT_BOSSICONID: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameEndingData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameEndingDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameEndingData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameEndingDataBuilder::new(_fbb);
        if let Some(x) = args.bossIconId {
            builder.add_bossIconId(x);
        }
        if let Some(x) = args.changeEndingDesc {
            builder.add_changeEndingDesc(x);
        }
        builder.add_priority(args.priority);
        if let Some(x) = args.icons {
            builder.add_icons(x);
        }
        if let Some(x) = args.bgId {
            builder.add_bgId(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_familyId(args.familyId);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameEndingDataT {
        let id = self.id().map(|x| x.to_string());
        let familyId = self.familyId();
        let name = self.name().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let bgId = self.bgId().map(|x| x.to_string());
        let icons = self.icons().map(|x| x.iter().map(|t| t.unpack()).collect());
        let priority = self.priority();
        let changeEndingDesc = self.changeEndingDesc().map(|x| x.to_string());
        let bossIconId = self.bossIconId().map(|x| x.to_string());
        clz_Torappu_RoguelikeGameEndingDataT {
            id,
            familyId,
            name,
            desc,
            bgId,
            icons,
            priority,
            changeEndingDesc,
            bossIconId,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameEndingData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn familyId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameEndingData::VT_FAMILYID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameEndingData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameEndingData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn bgId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameEndingData::VT_BGID,
                None,
            )
        }
    }
    #[inline]
    pub fn icons(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameEndingData_LevelIcon<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameEndingData_LevelIcon>,
                >,
            >>(clz_Torappu_RoguelikeGameEndingData::VT_ICONS, None)
        }
    }
    #[inline]
    pub fn priority(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameEndingData::VT_PRIORITY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn changeEndingDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameEndingData::VT_CHANGEENDINGDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn bossIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameEndingData::VT_BOSSICONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameEndingData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("familyId", Self::VT_FAMILYID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bgId", Self::VT_BGID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameEndingData_LevelIcon>,
                >,
            >>("icons", Self::VT_ICONS, false)?
            .visit_field::<i32>("priority", Self::VT_PRIORITY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "changeEndingDesc",
                Self::VT_CHANGEENDINGDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bossIconId",
                Self::VT_BOSSICONID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameEndingDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub familyId: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bgId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub icons: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameEndingData_LevelIcon<'a>>,
            >,
        >,
    >,
    pub priority: i32,
    pub changeEndingDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bossIconId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeGameEndingDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameEndingDataArgs {
            id: None,
            familyId: 0,
            name: None,
            desc: None,
            bgId: None,
            icons: None,
            priority: 0,
            changeEndingDesc: None,
            bossIconId: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameEndingData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameEndingData", 9)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("familyId", &self.familyId())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.bgId() {
            s.serialize_field("bgId", &f)?;
        } else {
            s.skip_field("bgId")?;
        }
        if let Some(f) = self.icons() {
            s.serialize_field("icons", &f)?;
        } else {
            s.skip_field("icons")?;
        }
        s.serialize_field("priority", &self.priority())?;
        if let Some(f) = self.changeEndingDesc() {
            s.serialize_field("changeEndingDesc", &f)?;
        } else {
            s.skip_field("changeEndingDesc")?;
        }
        if let Some(f) = self.bossIconId() {
            s.serialize_field("bossIconId", &f)?;
        } else {
            s.skip_field("bossIconId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameEndingDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameEndingDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameEndingData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_familyId(&mut self, familyId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameEndingData::VT_FAMILYID,
            familyId,
            0,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameEndingData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameEndingData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_bgId(&mut self, bgId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameEndingData::VT_BGID,
            bgId,
        );
    }
    #[inline]
    pub fn add_icons(
        &mut self,
        icons: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameEndingData_LevelIcon<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameEndingData::VT_ICONS,
            icons,
        );
    }
    #[inline]
    pub fn add_priority(&mut self, priority: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameEndingData::VT_PRIORITY,
            priority,
            0,
        );
    }
    #[inline]
    pub fn add_changeEndingDesc(&mut self, changeEndingDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameEndingData::VT_CHANGEENDINGDESC,
            changeEndingDesc,
        );
    }
    #[inline]
    pub fn add_bossIconId(&mut self, bossIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameEndingData::VT_BOSSICONID,
            bossIconId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameEndingDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameEndingDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameEndingData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameEndingData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameEndingData");
        ds.field("id", &self.id());
        ds.field("familyId", &self.familyId());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.field("bgId", &self.bgId());
        ds.field("icons", &self.icons());
        ds.field("priority", &self.priority());
        ds.field("changeEndingDesc", &self.changeEndingDesc());
        ds.field("bossIconId", &self.bossIconId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameEndingDataT {
    pub id: Option<String>,
    pub familyId: i32,
    pub name: Option<String>,
    pub desc: Option<String>,
    pub bgId: Option<String>,
    pub icons: Option<Vec<clz_Torappu_RoguelikeGameEndingData_LevelIconT>>,
    pub priority: i32,
    pub changeEndingDesc: Option<String>,
    pub bossIconId: Option<String>,
}
impl Default for clz_Torappu_RoguelikeGameEndingDataT {
    fn default() -> Self {
        Self {
            id: None,
            familyId: 0,
            name: None,
            desc: None,
            bgId: None,
            icons: None,
            priority: 0,
            changeEndingDesc: None,
            bossIconId: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameEndingDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameEndingData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let familyId = self.familyId;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let bgId = self.bgId.as_ref().map(|x| _fbb.create_string(x));
        let icons = self.icons.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let priority = self.priority;
        let changeEndingDesc = self
            .changeEndingDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let bossIconId = self.bossIconId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeGameEndingData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameEndingDataArgs {
                id,
                familyId,
                name,
                desc,
                bgId,
                icons,
                priority,
                changeEndingDesc,
                bossIconId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameEndingDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameEndingData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameEndingData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameEndingData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameEndingData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameEndingData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameEndingDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameEndingData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameEndingDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameEndingDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameEndingDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameEndingData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameEndingData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameEndingData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameEndingData>>(
                    dict__string__clz_Torappu_RoguelikeGameEndingData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameEndingData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameEndingData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameEndingDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameEndingData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameEndingDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameEndingDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameEndingData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeGameEndingData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameEndingDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameEndingDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameEndingData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameEndingData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameEndingData>>(
                dict__string__clz_Torappu_RoguelikeGameEndingData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameEndingDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameEndingDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameEndingData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameEndingData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameEndingData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameEndingData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameEndingDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameEndingDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameEndingDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameEndingDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameEndingData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameEndingData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameEndingDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameFailEndingDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameFailEndingData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameFailEndingData<'a> {
    type Inner = clz_Torappu_RoguelikeGameFailEndingData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameFailEndingData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DESC: flatbuffers::VOffsetT = 8;
    pub const VT_ICONID: flatbuffers::VOffsetT = 10;
    pub const VT_PRIORITY: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameFailEndingData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameFailEndingDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameFailEndingData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameFailEndingDataBuilder::new(_fbb);
        builder.add_priority(args.priority);
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameFailEndingDataT {
        let id = self.id().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        let priority = self.priority();
        clz_Torappu_RoguelikeGameFailEndingDataT {
            id,
            name,
            desc,
            iconId,
            priority,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameFailEndingData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameFailEndingData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameFailEndingData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameFailEndingData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn priority(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeGameFailEndingData::VT_PRIORITY,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameFailEndingData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<i32>("priority", Self::VT_PRIORITY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameFailEndingDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub priority: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeGameFailEndingDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameFailEndingDataArgs {
            id: None,
            name: None,
            desc: None,
            iconId: None,
            priority: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameFailEndingData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameFailEndingData", 5)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        s.serialize_field("priority", &self.priority())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameFailEndingDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameFailEndingDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameFailEndingData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameFailEndingData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameFailEndingData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameFailEndingData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_priority(&mut self, priority: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameFailEndingData::VT_PRIORITY,
            priority,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameFailEndingDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameFailEndingDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameFailEndingData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameFailEndingData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameFailEndingData");
        ds.field("id", &self.id());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.field("iconId", &self.iconId());
        ds.field("priority", &self.priority());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameFailEndingDataT {
    pub id: Option<String>,
    pub name: Option<String>,
    pub desc: Option<String>,
    pub iconId: Option<String>,
    pub priority: i32,
}
impl Default for clz_Torappu_RoguelikeGameFailEndingDataT {
    fn default() -> Self {
        Self {
            id: None,
            name: None,
            desc: None,
            iconId: None,
            priority: 0,
        }
    }
}
impl clz_Torappu_RoguelikeGameFailEndingDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameFailEndingData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let priority = self.priority;
        clz_Torappu_RoguelikeGameFailEndingData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameFailEndingDataArgs {
                id,
                name,
                desc,
                iconId,
                priority,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameFailEndingDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameFailEndingData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameFailEndingData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameFailEndingData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameFailEndingData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameFailEndingData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameFailEndingDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameFailEndingData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameFailEndingDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameFailEndingDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameFailEndingDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameFailEndingData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameFailEndingData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameFailEndingData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameFailEndingData>>(
                    dict__string__clz_Torappu_RoguelikeGameFailEndingData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameFailEndingData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameFailEndingData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameFailEndingDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameFailEndingData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameFailEndingDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameFailEndingDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameFailEndingData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeGameFailEndingData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameFailEndingDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameFailEndingDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameFailEndingData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameFailEndingData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameFailEndingData>>(
                dict__string__clz_Torappu_RoguelikeGameFailEndingData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameFailEndingDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameFailEndingDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameFailEndingData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameFailEndingData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameFailEndingData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameFailEndingData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameFailEndingDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameFailEndingDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameFailEndingDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameFailEndingDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameFailEndingData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameFailEndingData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameFailEndingDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeBattleSummeryDescriptionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeBattleSummeryDescriptionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeBattleSummeryDescriptionData<'a> {
    type Inner = clz_Torappu_RoguelikeBattleSummeryDescriptionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeBattleSummeryDescriptionData<'a> {
    pub const VT_RANDOMDESCRIPTIONLIST: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeBattleSummeryDescriptionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeBattleSummeryDescriptionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeBattleSummeryDescriptionData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeBattleSummeryDescriptionDataBuilder::new(_fbb);
        if let Some(x) = args.randomDescriptionList {
            builder.add_randomDescriptionList(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeBattleSummeryDescriptionDataT {
        let randomDescriptionList = self
            .randomDescriptionList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_RoguelikeBattleSummeryDescriptionDataT {
            randomDescriptionList,
        }
    }

    #[inline]
    pub fn randomDescriptionList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RoguelikeBattleSummeryDescriptionData::VT_RANDOMDESCRIPTIONLIST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeBattleSummeryDescriptionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "randomDescriptionList",
                Self::VT_RANDOMDESCRIPTIONLIST,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeBattleSummeryDescriptionDataArgs<'a> {
    pub randomDescriptionList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeBattleSummeryDescriptionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeBattleSummeryDescriptionDataArgs {
            randomDescriptionList: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeBattleSummeryDescriptionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeBattleSummeryDescriptionData", 1)?;
        if let Some(f) = self.randomDescriptionList() {
            s.serialize_field("randomDescriptionList", &f)?;
        } else {
            s.skip_field("randomDescriptionList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeBattleSummeryDescriptionDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeBattleSummeryDescriptionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_randomDescriptionList(
        &mut self,
        randomDescriptionList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeBattleSummeryDescriptionData::VT_RANDOMDESCRIPTIONLIST,
            randomDescriptionList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeBattleSummeryDescriptionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeBattleSummeryDescriptionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeBattleSummeryDescriptionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeBattleSummeryDescriptionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeBattleSummeryDescriptionData");
        ds.field("randomDescriptionList", &self.randomDescriptionList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeBattleSummeryDescriptionDataT {
    pub randomDescriptionList: Option<Vec<String>>,
}
impl Default for clz_Torappu_RoguelikeBattleSummeryDescriptionDataT {
    fn default() -> Self {
        Self {
            randomDescriptionList: None,
        }
    }
}
impl clz_Torappu_RoguelikeBattleSummeryDescriptionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeBattleSummeryDescriptionData<'b>> {
        let randomDescriptionList = self.randomDescriptionList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeBattleSummeryDescriptionData::create(
            _fbb,
            &clz_Torappu_RoguelikeBattleSummeryDescriptionDataArgs {
                randomDescriptionList,
            },
        )
    }
}
pub enum dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataOffset
{}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData<
    'a,
> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData<
        'a,
    >
{
    type Inner =
        dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData<
            'a,
        >;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a>
    dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData<'a>
{
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData<
            'bldr,
        >,
    > {
        let mut builder = dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(
        &self,
    ) -> dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataT
    {
        let key = self.key();
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataT {
            key,
            value,
        }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_RoguelikeTopicMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<enum__Torappu_RoguelikeTopicMode>(dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData::VT_KEY, Some(enum__Torappu_RoguelikeTopicMode::NONE)).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_RoguelikeTopicMode,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeBattleSummeryDescriptionData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBattleSummeryDescriptionData>>(dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData<
        '_,
    >
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<enum__Torappu_RoguelikeTopicMode>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBattleSummeryDescriptionData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataArgs<
    'a,
> {
    pub key: enum__Torappu_RoguelikeTopicMode,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeBattleSummeryDescriptionData<'a>>>,
}
impl<'a> Default for dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataArgs {
      key: enum__Torappu_RoguelikeTopicMode::NONE,
      value: None,
    }
  }
}

impl Serialize
    for dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData<
        '_,
    >
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataBuilder<
        'a,
        'b,
        A,
    >
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_RoguelikeTopicMode) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeTopicMode>(dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData::VT_KEY, key, enum__Torappu_RoguelikeTopicMode::NONE);
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeBattleSummeryDescriptionData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeBattleSummeryDescriptionData>>(dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataBuilder<'a, 'b, A>{
        let start = _fbb.start_table();
        dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData<
            'a,
        >,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData<
        '_,
    >
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataT
{
    pub key: enum__Torappu_RoguelikeTopicMode,
    pub value: Option<Box<clz_Torappu_RoguelikeBattleSummeryDescriptionDataT>>,
}
impl Default
    for dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataT
{
    fn default() -> Self {
        Self {
            key: enum__Torappu_RoguelikeTopicMode::NONE,
            value: None,
        }
    }
}
impl dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData<
            'b,
        >,
    > {
        let key = self.key;
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData::create(_fbb, &dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataArgs{
      key,
      value,
    })
    }
}
pub enum clz_Torappu_TipDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TipData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TipData<'a> {
    type Inner = clz_Torappu_TipData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_TipData<'a> {
    pub const VT_TIP: flatbuffers::VOffsetT = 4;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;
    pub const VT_CATEGORY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TipData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TipDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'bldr>> {
        let mut builder = clz_Torappu_TipDataBuilder::new(_fbb);
        builder.add_category(args.category);
        builder.add_weight(args.weight);
        if let Some(x) = args.tip {
            builder.add_tip(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_TipDataT {
        let tip = self.tip().map(|x| x.to_string());
        let weight = self.weight();
        let category = self.category();
        clz_Torappu_TipDataT {
            tip,
            weight,
            category,
        }
    }

    #[inline]
    pub fn tip(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_TipData::VT_TIP, None)
        }
    }
    #[inline]
    pub fn weight(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_TipData::VT_WEIGHT, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn category(&self) -> enum__Torappu_TipData_Category {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_TipData_Category>(
                    clz_Torappu_TipData::VT_CATEGORY,
                    Some(enum__Torappu_TipData_Category::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TipData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tip", Self::VT_TIP, false)?
            .visit_field::<f32>("weight", Self::VT_WEIGHT, false)?
            .visit_field::<enum__Torappu_TipData_Category>("category", Self::VT_CATEGORY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TipDataArgs<'a> {
    pub tip: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weight: f32,
    pub category: enum__Torappu_TipData_Category,
}
impl<'a> Default for clz_Torappu_TipDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TipDataArgs {
            tip: None,
            weight: 0.0,
            category: enum__Torappu_TipData_Category::NONE,
        }
    }
}

impl Serialize for clz_Torappu_TipData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_TipData", 3)?;
        if let Some(f) = self.tip() {
            s.serialize_field("tip", &f)?;
        } else {
            s.skip_field("tip")?;
        }
        s.serialize_field("weight", &self.weight())?;
        s.serialize_field("category", &self.category())?;
        s.end()
    }
}

pub struct clz_Torappu_TipDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TipDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_tip(&mut self, tip: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_TipData::VT_TIP, tip);
    }
    #[inline]
    pub fn add_weight(&mut self, weight: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_TipData::VT_WEIGHT, weight, 0.0);
    }
    #[inline]
    pub fn add_category(&mut self, category: enum__Torappu_TipData_Category) {
        self.fbb_.push_slot::<enum__Torappu_TipData_Category>(
            clz_Torappu_TipData::VT_CATEGORY,
            category,
            enum__Torappu_TipData_Category::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TipDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TipDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TipData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TipData");
        ds.field("tip", &self.tip());
        ds.field("weight", &self.weight());
        ds.field("category", &self.category());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_TipDataT {
    pub tip: Option<String>,
    pub weight: f32,
    pub category: enum__Torappu_TipData_Category,
}
impl Default for clz_Torappu_TipDataT {
    fn default() -> Self {
        Self {
            tip: None,
            weight: 0.0,
            category: enum__Torappu_TipData_Category::NONE,
        }
    }
}
impl clz_Torappu_TipDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'b>> {
        let tip = self.tip.as_ref().map(|x| _fbb.create_string(x));
        let weight = self.weight;
        let category = self.category;
        clz_Torappu_TipData::create(
            _fbb,
            &clz_Torappu_TipDataArgs {
                tip,
                weight,
                category,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameItemData<'a> {
    type Inner = clz_Torappu_RoguelikeGameItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameItemData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
    pub const VT_USAGE: flatbuffers::VOffsetT = 10;
    pub const VT_OBTAINAPPROACH: flatbuffers::VOffsetT = 12;
    pub const VT_ICONID: flatbuffers::VOffsetT = 14;
    pub const VT_ITEMICONGROUPID: flatbuffers::VOffsetT = 16;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 18;
    pub const VT_SUBTYPE: flatbuffers::VOffsetT = 20;
    pub const VT_RARITY: flatbuffers::VOffsetT = 22;
    pub const VT_SORTID: flatbuffers::VOffsetT = 24;
    pub const VT_CANSACRIFICE: flatbuffers::VOffsetT = 26;
    pub const VT_TINYICONCOLOR: flatbuffers::VOffsetT = 28;
    pub const VT_UNLOCKCONDDESC: flatbuffers::VOffsetT = 30;
    pub const VT_SHORTUSAGE: flatbuffers::VOffsetT = 32;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameItemData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameItemDataBuilder::new(_fbb);
        if let Some(x) = args.shortUsage {
            builder.add_shortUsage(x);
        }
        if let Some(x) = args.unlockCondDesc {
            builder.add_unlockCondDesc(x);
        }
        if let Some(x) = args.tinyIconColor {
            builder.add_tinyIconColor(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_rarity(args.rarity);
        builder.add_subType(args.subType);
        builder.add_type_(args.type_);
        if let Some(x) = args.itemIconGroupId {
            builder.add_itemIconGroupId(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.obtainApproach {
            builder.add_obtainApproach(x);
        }
        if let Some(x) = args.usage {
            builder.add_usage(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_canSacrifice(args.canSacrifice);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameItemDataT {
        let id = self.id().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let usage = self.usage().map(|x| x.to_string());
        let obtainApproach = self.obtainApproach().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        let itemIconGroupId = self.itemIconGroupId().map(|x| x.to_string());
        let type_ = self.type_();
        let subType = self.subType();
        let rarity = self.rarity();
        let sortId = self.sortId();
        let canSacrifice = self.canSacrifice();
        let tinyIconColor = self.tinyIconColor().map(|x| x.to_string());
        let unlockCondDesc = self.unlockCondDesc().map(|x| x.to_string());
        let shortUsage = self.shortUsage().map(|x| x.to_string());
        clz_Torappu_RoguelikeGameItemDataT {
            id,
            name,
            description,
            usage,
            obtainApproach,
            iconId,
            itemIconGroupId,
            type_,
            subType,
            rarity,
            sortId,
            canSacrifice,
            tinyIconColor,
            unlockCondDesc,
            shortUsage,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameItemData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameItemData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameItemData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn usage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameItemData::VT_USAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn obtainApproach(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameItemData::VT_OBTAINAPPROACH,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameItemData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemIconGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameItemData::VT_ITEMICONGROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_RoguelikeGameItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeGameItemType>(
                    clz_Torappu_RoguelikeGameItemData::VT_TYPE_,
                    Some(enum__Torappu_RoguelikeGameItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn subType(&self) -> enum__Torappu_RoguelikeGameItemSubType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeGameItemSubType>(
                    clz_Torappu_RoguelikeGameItemData::VT_SUBTYPE,
                    Some(enum__Torappu_RoguelikeGameItemSubType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rarity(&self) -> enum__Torappu_RoguelikeGameItemRarity {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeGameItemRarity>(
                    clz_Torappu_RoguelikeGameItemData::VT_RARITY,
                    Some(enum__Torappu_RoguelikeGameItemRarity::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameItemData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn canSacrifice(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeGameItemData::VT_CANSACRIFICE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn tinyIconColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameItemData::VT_TINYICONCOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockCondDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameItemData::VT_UNLOCKCONDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn shortUsage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameItemData::VT_SHORTUSAGE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("usage", Self::VT_USAGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obtainApproach",
                Self::VT_OBTAINAPPROACH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "itemIconGroupId",
                Self::VT_ITEMICONGROUPID,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeGameItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<enum__Torappu_RoguelikeGameItemSubType>(
                "subType",
                Self::VT_SUBTYPE,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeGameItemRarity>("rarity", Self::VT_RARITY, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<bool>("canSacrifice", Self::VT_CANSACRIFICE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tinyIconColor",
                Self::VT_TINYICONCOLOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockCondDesc",
                Self::VT_UNLOCKCONDDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "shortUsage",
                Self::VT_SHORTUSAGE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameItemDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub usage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obtainApproach: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemIconGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_RoguelikeGameItemType,
    pub subType: enum__Torappu_RoguelikeGameItemSubType,
    pub rarity: enum__Torappu_RoguelikeGameItemRarity,
    pub sortId: i32,
    pub canSacrifice: bool,
    pub tinyIconColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockCondDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub shortUsage: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeGameItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameItemDataArgs {
            id: None,
            name: None,
            description: None,
            usage: None,
            obtainApproach: None,
            iconId: None,
            itemIconGroupId: None,
            type_: enum__Torappu_RoguelikeGameItemType::NONE,
            subType: enum__Torappu_RoguelikeGameItemSubType::NONE,
            rarity: enum__Torappu_RoguelikeGameItemRarity::NONE,
            sortId: 0,
            canSacrifice: false,
            tinyIconColor: None,
            unlockCondDesc: None,
            shortUsage: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameItemData", 15)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.usage() {
            s.serialize_field("usage", &f)?;
        } else {
            s.skip_field("usage")?;
        }
        if let Some(f) = self.obtainApproach() {
            s.serialize_field("obtainApproach", &f)?;
        } else {
            s.skip_field("obtainApproach")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.itemIconGroupId() {
            s.serialize_field("itemIconGroupId", &f)?;
        } else {
            s.skip_field("itemIconGroupId")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("subType", &self.subType())?;
        s.serialize_field("rarity", &self.rarity())?;
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("canSacrifice", &self.canSacrifice())?;
        if let Some(f) = self.tinyIconColor() {
            s.serialize_field("tinyIconColor", &f)?;
        } else {
            s.skip_field("tinyIconColor")?;
        }
        if let Some(f) = self.unlockCondDesc() {
            s.serialize_field("unlockCondDesc", &f)?;
        } else {
            s.skip_field("unlockCondDesc")?;
        }
        if let Some(f) = self.shortUsage() {
            s.serialize_field("shortUsage", &f)?;
        } else {
            s.skip_field("shortUsage")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameItemDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameItemData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameItemData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameItemData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_usage(&mut self, usage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameItemData::VT_USAGE,
            usage,
        );
    }
    #[inline]
    pub fn add_obtainApproach(&mut self, obtainApproach: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameItemData::VT_OBTAINAPPROACH,
            obtainApproach,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameItemData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_itemIconGroupId(&mut self, itemIconGroupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameItemData::VT_ITEMICONGROUPID,
            itemIconGroupId,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_RoguelikeGameItemType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeGameItemType>(
            clz_Torappu_RoguelikeGameItemData::VT_TYPE_,
            type_,
            enum__Torappu_RoguelikeGameItemType::NONE,
        );
    }
    #[inline]
    pub fn add_subType(&mut self, subType: enum__Torappu_RoguelikeGameItemSubType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeGameItemSubType>(
                clz_Torappu_RoguelikeGameItemData::VT_SUBTYPE,
                subType,
                enum__Torappu_RoguelikeGameItemSubType::NONE,
            );
    }
    #[inline]
    pub fn add_rarity(&mut self, rarity: enum__Torappu_RoguelikeGameItemRarity) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeGameItemRarity>(
                clz_Torappu_RoguelikeGameItemData::VT_RARITY,
                rarity,
                enum__Torappu_RoguelikeGameItemRarity::NONE,
            );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeGameItemData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_canSacrifice(&mut self, canSacrifice: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeGameItemData::VT_CANSACRIFICE,
            canSacrifice,
            false,
        );
    }
    #[inline]
    pub fn add_tinyIconColor(&mut self, tinyIconColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameItemData::VT_TINYICONCOLOR,
            tinyIconColor,
        );
    }
    #[inline]
    pub fn add_unlockCondDesc(&mut self, unlockCondDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameItemData::VT_UNLOCKCONDDESC,
            unlockCondDesc,
        );
    }
    #[inline]
    pub fn add_shortUsage(&mut self, shortUsage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameItemData::VT_SHORTUSAGE,
            shortUsage,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameItemData");
        ds.field("id", &self.id());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("usage", &self.usage());
        ds.field("obtainApproach", &self.obtainApproach());
        ds.field("iconId", &self.iconId());
        ds.field("itemIconGroupId", &self.itemIconGroupId());
        ds.field("type_", &self.type_());
        ds.field("subType", &self.subType());
        ds.field("rarity", &self.rarity());
        ds.field("sortId", &self.sortId());
        ds.field("canSacrifice", &self.canSacrifice());
        ds.field("tinyIconColor", &self.tinyIconColor());
        ds.field("unlockCondDesc", &self.unlockCondDesc());
        ds.field("shortUsage", &self.shortUsage());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameItemDataT {
    pub id: Option<String>,
    pub name: Option<String>,
    pub description: Option<String>,
    pub usage: Option<String>,
    pub obtainApproach: Option<String>,
    pub iconId: Option<String>,
    pub itemIconGroupId: Option<String>,
    pub type_: enum__Torappu_RoguelikeGameItemType,
    pub subType: enum__Torappu_RoguelikeGameItemSubType,
    pub rarity: enum__Torappu_RoguelikeGameItemRarity,
    pub sortId: i32,
    pub canSacrifice: bool,
    pub tinyIconColor: Option<String>,
    pub unlockCondDesc: Option<String>,
    pub shortUsage: Option<String>,
}
impl Default for clz_Torappu_RoguelikeGameItemDataT {
    fn default() -> Self {
        Self {
            id: None,
            name: None,
            description: None,
            usage: None,
            obtainApproach: None,
            iconId: None,
            itemIconGroupId: None,
            type_: enum__Torappu_RoguelikeGameItemType::NONE,
            subType: enum__Torappu_RoguelikeGameItemSubType::NONE,
            rarity: enum__Torappu_RoguelikeGameItemRarity::NONE,
            sortId: 0,
            canSacrifice: false,
            tinyIconColor: None,
            unlockCondDesc: None,
            shortUsage: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameItemData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let usage = self.usage.as_ref().map(|x| _fbb.create_string(x));
        let obtainApproach = self.obtainApproach.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let itemIconGroupId = self.itemIconGroupId.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let subType = self.subType;
        let rarity = self.rarity;
        let sortId = self.sortId;
        let canSacrifice = self.canSacrifice;
        let tinyIconColor = self.tinyIconColor.as_ref().map(|x| _fbb.create_string(x));
        let unlockCondDesc = self.unlockCondDesc.as_ref().map(|x| _fbb.create_string(x));
        let shortUsage = self.shortUsage.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeGameItemData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameItemDataArgs {
                id,
                name,
                description,
                usage,
                obtainApproach,
                iconId,
                itemIconGroupId,
                type_,
                subType,
                rarity,
                sortId,
                canSacrifice,
                tinyIconColor,
                unlockCondDesc,
                shortUsage,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameItemData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameItemData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameItemData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameItemDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameItemDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameItemDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameItemData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameItemData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameItemData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameItemData>>(
                    dict__string__clz_Torappu_RoguelikeGameItemData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameItemData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameItemDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameItemData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameItemDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeGameItemData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameItemData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameItemData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameItemData>>(
                dict__string__clz_Torappu_RoguelikeGameItemData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameItemData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameItemData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameItemDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameItemDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameItemDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameItemData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameItemData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameItemDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeBandRefDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeBandRefData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeBandRefData<'a> {
    type Inner = clz_Torappu_RoguelikeBandRefData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeBandRefData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_BANDLEVEL: flatbuffers::VOffsetT = 6;
    pub const VT_NORMALBANDID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeBandRefData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeBandRefDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeBandRefData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeBandRefDataBuilder::new(_fbb);
        if let Some(x) = args.normalBandId {
            builder.add_normalBandId(x);
        }
        builder.add_bandLevel(args.bandLevel);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeBandRefDataT {
        let itemId = self.itemId().map(|x| x.to_string());
        let bandLevel = self.bandLevel();
        let normalBandId = self.normalBandId().map(|x| x.to_string());
        clz_Torappu_RoguelikeBandRefDataT {
            itemId,
            bandLevel,
            normalBandId,
        }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeBandRefData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn bandLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeBandRefData::VT_BANDLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn normalBandId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeBandRefData::VT_NORMALBANDID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeBandRefData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("bandLevel", Self::VT_BANDLEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "normalBandId",
                Self::VT_NORMALBANDID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeBandRefDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bandLevel: i32,
    pub normalBandId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeBandRefDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeBandRefDataArgs {
            itemId: None,
            bandLevel: 0,
            normalBandId: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeBandRefData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeBandRefData", 3)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        s.serialize_field("bandLevel", &self.bandLevel())?;
        if let Some(f) = self.normalBandId() {
            s.serialize_field("normalBandId", &f)?;
        } else {
            s.skip_field("normalBandId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeBandRefDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeBandRefDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeBandRefData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_bandLevel(&mut self, bandLevel: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeBandRefData::VT_BANDLEVEL, bandLevel, 0);
    }
    #[inline]
    pub fn add_normalBandId(&mut self, normalBandId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeBandRefData::VT_NORMALBANDID,
            normalBandId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeBandRefDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeBandRefDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeBandRefData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeBandRefData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeBandRefData");
        ds.field("itemId", &self.itemId());
        ds.field("bandLevel", &self.bandLevel());
        ds.field("normalBandId", &self.normalBandId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeBandRefDataT {
    pub itemId: Option<String>,
    pub bandLevel: i32,
    pub normalBandId: Option<String>,
}
impl Default for clz_Torappu_RoguelikeBandRefDataT {
    fn default() -> Self {
        Self {
            itemId: None,
            bandLevel: 0,
            normalBandId: None,
        }
    }
}
impl clz_Torappu_RoguelikeBandRefDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeBandRefData<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let bandLevel = self.bandLevel;
        let normalBandId = self.normalBandId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeBandRefData::create(
            _fbb,
            &clz_Torappu_RoguelikeBandRefDataArgs {
                itemId,
                bandLevel,
                normalBandId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeBandRefDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeBandRefData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeBandRefData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeBandRefData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeBandRefData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeBandRefData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeBandRefDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeBandRefData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeBandRefDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeBandRefDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeBandRefDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeBandRefData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeBandRefData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeBandRefData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBandRefData>>(
                    dict__string__clz_Torappu_RoguelikeBandRefData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeBandRefData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeBandRefData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeBandRefDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeBandRefData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeBandRefDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeBandRefDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeBandRefData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeBandRefData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeBandRefDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeBandRefDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeBandRefData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeBandRefData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeBandRefData>>(
                dict__string__clz_Torappu_RoguelikeBandRefData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeBandRefDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeBandRefDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeBandRefData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeBandRefData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeBandRefData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeBandRefData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeBandRefDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeBandRefDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeBandRefDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeBandRefDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeBandRefData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeBandRefData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeBandRefDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeEndingDetailTextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeEndingDetailText<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeEndingDetailText<'a> {
    type Inner = clz_Torappu_RoguelikeEndingDetailText<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeEndingDetailText<'a> {
    pub const VT_TEXTID: flatbuffers::VOffsetT = 4;
    pub const VT_TEXT: flatbuffers::VOffsetT = 6;
    pub const VT_EVENTTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_SPZONEEVTTYPE: flatbuffers::VOffsetT = 10;
    pub const VT_SHOWTYPE: flatbuffers::VOffsetT = 12;
    pub const VT_CHOICESCENEID: flatbuffers::VOffsetT = 14;
    pub const VT_PARAMLIST: flatbuffers::VOffsetT = 16;
    pub const VT_OTHERPARA1: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeEndingDetailText { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeEndingDetailTextArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeEndingDetailText<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeEndingDetailTextBuilder::new(_fbb);
        if let Some(x) = args.otherPara1 {
            builder.add_otherPara1(x);
        }
        if let Some(x) = args.paramList {
            builder.add_paramList(x);
        }
        if let Some(x) = args.choiceSceneId {
            builder.add_choiceSceneId(x);
        }
        builder.add_showType(args.showType);
        if let Some(x) = args.spZoneEvtType {
            builder.add_spZoneEvtType(x);
        }
        builder.add_eventType(args.eventType);
        if let Some(x) = args.text {
            builder.add_text(x);
        }
        if let Some(x) = args.textId {
            builder.add_textId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeEndingDetailTextT {
        let textId = self.textId().map(|x| x.to_string());
        let text = self.text().map(|x| x.to_string());
        let eventType = self.eventType();
        let spZoneEvtType = self.spZoneEvtType().map(|x| x.to_string());
        let showType = self.showType();
        let choiceSceneId = self.choiceSceneId().map(|x| x.to_string());
        let paramList = self
            .paramList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let otherPara1 = self.otherPara1().map(|x| x.to_string());
        clz_Torappu_RoguelikeEndingDetailTextT {
            textId,
            text,
            eventType,
            spZoneEvtType,
            showType,
            choiceSceneId,
            paramList,
            otherPara1,
        }
    }

    #[inline]
    pub fn textId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeEndingDetailText::VT_TEXTID,
                None,
            )
        }
    }
    #[inline]
    pub fn text(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeEndingDetailText::VT_TEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn eventType(&self) -> enum__Torappu_RoguelikeEventType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeEventType>(
                    clz_Torappu_RoguelikeEndingDetailText::VT_EVENTTYPE,
                    Some(enum__Torappu_RoguelikeEventType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn spZoneEvtType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeEndingDetailText::VT_SPZONEEVTTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn showType(&self) -> enum__Torappu_RoguelikeEndingDetailText_Type {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeEndingDetailText_Type>(
                    clz_Torappu_RoguelikeEndingDetailText::VT_SHOWTYPE,
                    Some(enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_CHOICE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn choiceSceneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeEndingDetailText::VT_CHOICESCENEID,
                None,
            )
        }
    }
    #[inline]
    pub fn paramList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RoguelikeEndingDetailText::VT_PARAMLIST, None)
        }
    }
    #[inline]
    pub fn otherPara1(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeEndingDetailText::VT_OTHERPARA1,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeEndingDetailText<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("textId", Self::VT_TEXTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
            .visit_field::<enum__Torappu_RoguelikeEventType>(
                "eventType",
                Self::VT_EVENTTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "spZoneEvtType",
                Self::VT_SPZONEEVTTYPE,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeEndingDetailText_Type>(
                "showType",
                Self::VT_SHOWTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "choiceSceneId",
                Self::VT_CHOICESCENEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("paramList", Self::VT_PARAMLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "otherPara1",
                Self::VT_OTHERPARA1,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeEndingDetailTextArgs<'a> {
    pub textId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eventType: enum__Torappu_RoguelikeEventType,
    pub spZoneEvtType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub showType: enum__Torappu_RoguelikeEndingDetailText_Type,
    pub choiceSceneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub paramList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub otherPara1: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeEndingDetailTextArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeEndingDetailTextArgs {
            textId: None,
            text: None,
            eventType: enum__Torappu_RoguelikeEventType::NONE,
            spZoneEvtType: None,
            showType: enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_CHOICE,
            choiceSceneId: None,
            paramList: None,
            otherPara1: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeEndingDetailText<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeEndingDetailText", 8)?;
        if let Some(f) = self.textId() {
            s.serialize_field("textId", &f)?;
        } else {
            s.skip_field("textId")?;
        }
        if let Some(f) = self.text() {
            s.serialize_field("text", &f)?;
        } else {
            s.skip_field("text")?;
        }
        s.serialize_field("eventType", &self.eventType())?;
        if let Some(f) = self.spZoneEvtType() {
            s.serialize_field("spZoneEvtType", &f)?;
        } else {
            s.skip_field("spZoneEvtType")?;
        }
        s.serialize_field("showType", &self.showType())?;
        if let Some(f) = self.choiceSceneId() {
            s.serialize_field("choiceSceneId", &f)?;
        } else {
            s.skip_field("choiceSceneId")?;
        }
        if let Some(f) = self.paramList() {
            s.serialize_field("paramList", &f)?;
        } else {
            s.skip_field("paramList")?;
        }
        if let Some(f) = self.otherPara1() {
            s.serialize_field("otherPara1", &f)?;
        } else {
            s.skip_field("otherPara1")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeEndingDetailTextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeEndingDetailTextBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_textId(&mut self, textId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeEndingDetailText::VT_TEXTID,
            textId,
        );
    }
    #[inline]
    pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeEndingDetailText::VT_TEXT,
            text,
        );
    }
    #[inline]
    pub fn add_eventType(&mut self, eventType: enum__Torappu_RoguelikeEventType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeEventType>(
            clz_Torappu_RoguelikeEndingDetailText::VT_EVENTTYPE,
            eventType,
            enum__Torappu_RoguelikeEventType::NONE,
        );
    }
    #[inline]
    pub fn add_spZoneEvtType(&mut self, spZoneEvtType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeEndingDetailText::VT_SPZONEEVTTYPE,
            spZoneEvtType,
        );
    }
    #[inline]
    pub fn add_showType(&mut self, showType: enum__Torappu_RoguelikeEndingDetailText_Type) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeEndingDetailText_Type>(
                clz_Torappu_RoguelikeEndingDetailText::VT_SHOWTYPE,
                showType,
                enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_CHOICE,
            );
    }
    #[inline]
    pub fn add_choiceSceneId(&mut self, choiceSceneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeEndingDetailText::VT_CHOICESCENEID,
            choiceSceneId,
        );
    }
    #[inline]
    pub fn add_paramList(
        &mut self,
        paramList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeEndingDetailText::VT_PARAMLIST,
            paramList,
        );
    }
    #[inline]
    pub fn add_otherPara1(&mut self, otherPara1: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeEndingDetailText::VT_OTHERPARA1,
            otherPara1,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeEndingDetailTextBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeEndingDetailTextBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeEndingDetailText<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeEndingDetailText<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeEndingDetailText");
        ds.field("textId", &self.textId());
        ds.field("text", &self.text());
        ds.field("eventType", &self.eventType());
        ds.field("spZoneEvtType", &self.spZoneEvtType());
        ds.field("showType", &self.showType());
        ds.field("choiceSceneId", &self.choiceSceneId());
        ds.field("paramList", &self.paramList());
        ds.field("otherPara1", &self.otherPara1());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeEndingDetailTextT {
    pub textId: Option<String>,
    pub text: Option<String>,
    pub eventType: enum__Torappu_RoguelikeEventType,
    pub spZoneEvtType: Option<String>,
    pub showType: enum__Torappu_RoguelikeEndingDetailText_Type,
    pub choiceSceneId: Option<String>,
    pub paramList: Option<Vec<String>>,
    pub otherPara1: Option<String>,
}
impl Default for clz_Torappu_RoguelikeEndingDetailTextT {
    fn default() -> Self {
        Self {
            textId: None,
            text: None,
            eventType: enum__Torappu_RoguelikeEventType::NONE,
            spZoneEvtType: None,
            showType: enum__Torappu_RoguelikeEndingDetailText_Type::SHOW_CHOICE,
            choiceSceneId: None,
            paramList: None,
            otherPara1: None,
        }
    }
}
impl clz_Torappu_RoguelikeEndingDetailTextT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeEndingDetailText<'b>> {
        let textId = self.textId.as_ref().map(|x| _fbb.create_string(x));
        let text = self.text.as_ref().map(|x| _fbb.create_string(x));
        let eventType = self.eventType;
        let spZoneEvtType = self.spZoneEvtType.as_ref().map(|x| _fbb.create_string(x));
        let showType = self.showType;
        let choiceSceneId = self.choiceSceneId.as_ref().map(|x| _fbb.create_string(x));
        let paramList = self.paramList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let otherPara1 = self.otherPara1.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeEndingDetailText::create(
            _fbb,
            &clz_Torappu_RoguelikeEndingDetailTextArgs {
                textId,
                text,
                eventType,
                spZoneEvtType,
                showType,
                choiceSceneId,
                paramList,
                otherPara1,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeEndingRelicDetailTextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeEndingRelicDetailText<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeEndingRelicDetailText<'a> {
    type Inner = clz_Torappu_RoguelikeEndingRelicDetailText<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeEndingRelicDetailText<'a> {
    pub const VT_RELICID: flatbuffers::VOffsetT = 4;
    pub const VT_SUMMARYEVENTTEXT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeEndingRelicDetailText { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeEndingRelicDetailTextArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeEndingRelicDetailText<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeEndingRelicDetailTextBuilder::new(_fbb);
        if let Some(x) = args.summaryEventText {
            builder.add_summaryEventText(x);
        }
        if let Some(x) = args.relicId {
            builder.add_relicId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeEndingRelicDetailTextT {
        let relicId = self.relicId().map(|x| x.to_string());
        let summaryEventText = self.summaryEventText().map(|x| x.to_string());
        clz_Torappu_RoguelikeEndingRelicDetailTextT {
            relicId,
            summaryEventText,
        }
    }

    #[inline]
    pub fn relicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeEndingRelicDetailText::VT_RELICID,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryEventText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeEndingRelicDetailText::VT_SUMMARYEVENTTEXT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeEndingRelicDetailText<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("relicId", Self::VT_RELICID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryEventText",
                Self::VT_SUMMARYEVENTTEXT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeEndingRelicDetailTextArgs<'a> {
    pub relicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryEventText: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeEndingRelicDetailTextArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeEndingRelicDetailTextArgs {
            relicId: None,
            summaryEventText: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeEndingRelicDetailText<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeEndingRelicDetailText", 2)?;
        if let Some(f) = self.relicId() {
            s.serialize_field("relicId", &f)?;
        } else {
            s.skip_field("relicId")?;
        }
        if let Some(f) = self.summaryEventText() {
            s.serialize_field("summaryEventText", &f)?;
        } else {
            s.skip_field("summaryEventText")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeEndingRelicDetailTextBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeEndingRelicDetailTextBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_relicId(&mut self, relicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeEndingRelicDetailText::VT_RELICID,
            relicId,
        );
    }
    #[inline]
    pub fn add_summaryEventText(&mut self, summaryEventText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeEndingRelicDetailText::VT_SUMMARYEVENTTEXT,
            summaryEventText,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeEndingRelicDetailTextBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeEndingRelicDetailTextBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeEndingRelicDetailText<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeEndingRelicDetailText<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeEndingRelicDetailText");
        ds.field("relicId", &self.relicId());
        ds.field("summaryEventText", &self.summaryEventText());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeEndingRelicDetailTextT {
    pub relicId: Option<String>,
    pub summaryEventText: Option<String>,
}
impl Default for clz_Torappu_RoguelikeEndingRelicDetailTextT {
    fn default() -> Self {
        Self {
            relicId: None,
            summaryEventText: None,
        }
    }
}
impl clz_Torappu_RoguelikeEndingRelicDetailTextT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeEndingRelicDetailText<'b>> {
        let relicId = self.relicId.as_ref().map(|x| _fbb.create_string(x));
        let summaryEventText = self
            .summaryEventText
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeEndingRelicDetailText::create(
            _fbb,
            &clz_Torappu_RoguelikeEndingRelicDetailTextArgs {
                relicId,
                summaryEventText,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameTreasureDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameTreasureData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameTreasureData<'a> {
    type Inner = clz_Torappu_RoguelikeGameTreasureData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameTreasureData<'a> {
    pub const VT_TREASUREID: flatbuffers::VOffsetT = 4;
    pub const VT_GROUPID: flatbuffers::VOffsetT = 6;
    pub const VT_SUBINDEX: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_USAGE: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameTreasureData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameTreasureDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameTreasureData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameTreasureDataBuilder::new(_fbb);
        if let Some(x) = args.usage {
            builder.add_usage(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_subIndex(args.subIndex);
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        if let Some(x) = args.treasureId {
            builder.add_treasureId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameTreasureDataT {
        let treasureId = self.treasureId().map(|x| x.to_string());
        let groupId = self.groupId().map(|x| x.to_string());
        let subIndex = self.subIndex();
        let name = self.name().map(|x| x.to_string());
        let usage = self.usage().map(|x| x.to_string());
        clz_Torappu_RoguelikeGameTreasureDataT {
            treasureId,
            groupId,
            subIndex,
            name,
            usage,
        }
    }

    #[inline]
    pub fn treasureId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameTreasureData::VT_TREASUREID,
                None,
            )
        }
    }
    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameTreasureData::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn subIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeGameTreasureData::VT_SUBINDEX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameTreasureData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn usage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameTreasureData::VT_USAGE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameTreasureData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "treasureId",
                Self::VT_TREASUREID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<i32>("subIndex", Self::VT_SUBINDEX, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("usage", Self::VT_USAGE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameTreasureDataArgs<'a> {
    pub treasureId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subIndex: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub usage: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeGameTreasureDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameTreasureDataArgs {
            treasureId: None,
            groupId: None,
            subIndex: 0,
            name: None,
            usage: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameTreasureData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameTreasureData", 5)?;
        if let Some(f) = self.treasureId() {
            s.serialize_field("treasureId", &f)?;
        } else {
            s.skip_field("treasureId")?;
        }
        if let Some(f) = self.groupId() {
            s.serialize_field("groupId", &f)?;
        } else {
            s.skip_field("groupId")?;
        }
        s.serialize_field("subIndex", &self.subIndex())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.usage() {
            s.serialize_field("usage", &f)?;
        } else {
            s.skip_field("usage")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameTreasureDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameTreasureDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_treasureId(&mut self, treasureId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameTreasureData::VT_TREASUREID,
            treasureId,
        );
    }
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameTreasureData::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_subIndex(&mut self, subIndex: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeGameTreasureData::VT_SUBINDEX,
            subIndex,
            0,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameTreasureData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_usage(&mut self, usage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameTreasureData::VT_USAGE,
            usage,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameTreasureDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameTreasureDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameTreasureData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameTreasureData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameTreasureData");
        ds.field("treasureId", &self.treasureId());
        ds.field("groupId", &self.groupId());
        ds.field("subIndex", &self.subIndex());
        ds.field("name", &self.name());
        ds.field("usage", &self.usage());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameTreasureDataT {
    pub treasureId: Option<String>,
    pub groupId: Option<String>,
    pub subIndex: i32,
    pub name: Option<String>,
    pub usage: Option<String>,
}
impl Default for clz_Torappu_RoguelikeGameTreasureDataT {
    fn default() -> Self {
        Self {
            treasureId: None,
            groupId: None,
            subIndex: 0,
            name: None,
            usage: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameTreasureDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameTreasureData<'b>> {
        let treasureId = self.treasureId.as_ref().map(|x| _fbb.create_string(x));
        let groupId = self.groupId.as_ref().map(|x| _fbb.create_string(x));
        let subIndex = self.subIndex;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let usage = self.usage.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeGameTreasureData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameTreasureDataArgs {
                treasureId,
                groupId,
                subIndex,
                name,
                usage,
            },
        )
    }
}
pub enum dict__string__list_clz_Torappu_RoguelikeGameTreasureDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_clz_Torappu_RoguelikeGameTreasureData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_clz_Torappu_RoguelikeGameTreasureData<'a> {
    type Inner = dict__string__list_clz_Torappu_RoguelikeGameTreasureData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__list_clz_Torappu_RoguelikeGameTreasureData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_clz_Torappu_RoguelikeGameTreasureData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_clz_Torappu_RoguelikeGameTreasureDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_RoguelikeGameTreasureData<'bldr>>
    {
        let mut builder =
            dict__string__list_clz_Torappu_RoguelikeGameTreasureDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__list_clz_Torappu_RoguelikeGameTreasureDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__string__list_clz_Torappu_RoguelikeGameTreasureDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__list_clz_Torappu_RoguelikeGameTreasureData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_clz_Torappu_RoguelikeGameTreasureData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameTreasureData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameTreasureData>,
                >,
            >>(
                dict__string__list_clz_Torappu_RoguelikeGameTreasureData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_clz_Torappu_RoguelikeGameTreasureData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameTreasureData>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_clz_Torappu_RoguelikeGameTreasureDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameTreasureData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__string__list_clz_Torappu_RoguelikeGameTreasureDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_clz_Torappu_RoguelikeGameTreasureDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__list_clz_Torappu_RoguelikeGameTreasureData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__list_clz_Torappu_RoguelikeGameTreasureData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__list_clz_Torappu_RoguelikeGameTreasureDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_clz_Torappu_RoguelikeGameTreasureDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_RoguelikeGameTreasureData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameTreasureData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_RoguelikeGameTreasureData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_clz_Torappu_RoguelikeGameTreasureDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_clz_Torappu_RoguelikeGameTreasureDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_RoguelikeGameTreasureData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__list_clz_Torappu_RoguelikeGameTreasureData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_clz_Torappu_RoguelikeGameTreasureData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_clz_Torappu_RoguelikeGameTreasureData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_clz_Torappu_RoguelikeGameTreasureDataT {
    pub key: String,
    pub value: Option<Vec<clz_Torappu_RoguelikeGameTreasureDataT>>,
}
impl Default for dict__string__list_clz_Torappu_RoguelikeGameTreasureDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_clz_Torappu_RoguelikeGameTreasureDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_RoguelikeGameTreasureData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_clz_Torappu_RoguelikeGameTreasureData::create(
            _fbb,
            &dict__string__list_clz_Torappu_RoguelikeGameTreasureDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeDifficultyUpgradeRelicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeDifficultyUpgradeRelicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeDifficultyUpgradeRelicData<'a> {
    type Inner = clz_Torappu_RoguelikeDifficultyUpgradeRelicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeDifficultyUpgradeRelicData<'a> {
    pub const VT_RELICID: flatbuffers::VOffsetT = 4;
    pub const VT_EQUIVALENTGRADE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeDifficultyUpgradeRelicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeDifficultyUpgradeRelicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDifficultyUpgradeRelicData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeDifficultyUpgradeRelicDataBuilder::new(_fbb);
        builder.add_equivalentGrade(args.equivalentGrade);
        if let Some(x) = args.relicId {
            builder.add_relicId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeDifficultyUpgradeRelicDataT {
        let relicId = self.relicId().map(|x| x.to_string());
        let equivalentGrade = self.equivalentGrade();
        clz_Torappu_RoguelikeDifficultyUpgradeRelicDataT {
            relicId,
            equivalentGrade,
        }
    }

    #[inline]
    pub fn relicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDifficultyUpgradeRelicData::VT_RELICID,
                None,
            )
        }
    }
    #[inline]
    pub fn equivalentGrade(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeDifficultyUpgradeRelicData::VT_EQUIVALENTGRADE,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeDifficultyUpgradeRelicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("relicId", Self::VT_RELICID, false)?
            .visit_field::<i32>("equivalentGrade", Self::VT_EQUIVALENTGRADE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeDifficultyUpgradeRelicDataArgs<'a> {
    pub relicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub equivalentGrade: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeDifficultyUpgradeRelicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeDifficultyUpgradeRelicDataArgs {
            relicId: None,
            equivalentGrade: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeDifficultyUpgradeRelicData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeDifficultyUpgradeRelicData", 2)?;
        if let Some(f) = self.relicId() {
            s.serialize_field("relicId", &f)?;
        } else {
            s.skip_field("relicId")?;
        }
        s.serialize_field("equivalentGrade", &self.equivalentGrade())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeDifficultyUpgradeRelicDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeDifficultyUpgradeRelicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_relicId(&mut self, relicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDifficultyUpgradeRelicData::VT_RELICID,
            relicId,
        );
    }
    #[inline]
    pub fn add_equivalentGrade(&mut self, equivalentGrade: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeDifficultyUpgradeRelicData::VT_EQUIVALENTGRADE,
            equivalentGrade,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeDifficultyUpgradeRelicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeDifficultyUpgradeRelicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDifficultyUpgradeRelicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeDifficultyUpgradeRelicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeDifficultyUpgradeRelicData");
        ds.field("relicId", &self.relicId());
        ds.field("equivalentGrade", &self.equivalentGrade());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeDifficultyUpgradeRelicDataT {
    pub relicId: Option<String>,
    pub equivalentGrade: i32,
}
impl Default for clz_Torappu_RoguelikeDifficultyUpgradeRelicDataT {
    fn default() -> Self {
        Self {
            relicId: None,
            equivalentGrade: 0,
        }
    }
}
impl clz_Torappu_RoguelikeDifficultyUpgradeRelicDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDifficultyUpgradeRelicData<'b>> {
        let relicId = self.relicId.as_ref().map(|x| _fbb.create_string(x));
        let equivalentGrade = self.equivalentGrade;
        clz_Torappu_RoguelikeDifficultyUpgradeRelicData::create(
            _fbb,
            &clz_Torappu_RoguelikeDifficultyUpgradeRelicDataArgs {
                relicId,
                equivalentGrade,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'a> {
    type Inner = clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'a> {
    pub const VT_RELICDATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataBuilder::new(_fbb);
        if let Some(x) = args.relicData {
            builder.add_relicData(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataT {
        let relicData = self
            .relicData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataT { relicData }
    }

    #[inline]
    pub fn relicData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDifficultyUpgradeRelicData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDifficultyUpgradeRelicData>,
                >,
            >>(
                clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData::VT_RELICDATA,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDifficultyUpgradeRelicData>,
                >,
            >>("relicData", Self::VT_RELICDATA, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataArgs<'a> {
    pub relicData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDifficultyUpgradeRelicData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataArgs { relicData: None }
    }
}

impl Serialize for clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData", 1)?;
        if let Some(f) = self.relicData() {
            s.serialize_field("relicData", &f)?;
        } else {
            s.skip_field("relicData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_relicData(
        &mut self,
        relicData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDifficultyUpgradeRelicData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData::VT_RELICDATA,
            relicData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData");
        ds.field("relicData", &self.relicData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataT {
    pub relicData: Option<Vec<clz_Torappu_RoguelikeDifficultyUpgradeRelicDataT>>,
}
impl Default for clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataT {
    fn default() -> Self {
        Self { relicData: None }
    }
}
impl clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'b>> {
        let relicData = self.relicData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData::create(
            _fbb,
            &clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataArgs { relicData },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'a>
{
    type Inner = dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData,
            >>(
                dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData>>(dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'b>,
    > {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikePredefinedStyleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikePredefinedStyleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikePredefinedStyleData<'a> {
    type Inner = clz_Torappu_RoguelikePredefinedStyleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikePredefinedStyleData<'a> {
    pub const VT_STYLEID: flatbuffers::VOffsetT = 4;
    pub const VT_STYLECONFIG: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikePredefinedStyleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikePredefinedStyleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedStyleData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikePredefinedStyleDataBuilder::new(_fbb);
        builder.add_styleConfig(args.styleConfig);
        if let Some(x) = args.styleId {
            builder.add_styleId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikePredefinedStyleDataT {
        let styleId = self.styleId().map(|x| x.to_string());
        let styleConfig = self.styleConfig();
        clz_Torappu_RoguelikePredefinedStyleDataT {
            styleId,
            styleConfig,
        }
    }

    #[inline]
    pub fn styleId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikePredefinedStyleData::VT_STYLEID,
                None,
            )
        }
    }
    #[inline]
    pub fn styleConfig(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikePredefinedStyleData::VT_STYLECONFIG,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikePredefinedStyleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("styleId", Self::VT_STYLEID, false)?
            .visit_field::<i32>("styleConfig", Self::VT_STYLECONFIG, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikePredefinedStyleDataArgs<'a> {
    pub styleId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub styleConfig: i32,
}
impl<'a> Default for clz_Torappu_RoguelikePredefinedStyleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikePredefinedStyleDataArgs {
            styleId: None,
            styleConfig: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikePredefinedStyleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikePredefinedStyleData", 2)?;
        if let Some(f) = self.styleId() {
            s.serialize_field("styleId", &f)?;
        } else {
            s.skip_field("styleId")?;
        }
        s.serialize_field("styleConfig", &self.styleConfig())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikePredefinedStyleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikePredefinedStyleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_styleId(&mut self, styleId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikePredefinedStyleData::VT_STYLEID,
            styleId,
        );
    }
    #[inline]
    pub fn add_styleConfig(&mut self, styleConfig: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikePredefinedStyleData::VT_STYLECONFIG,
            styleConfig,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikePredefinedStyleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikePredefinedStyleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedStyleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikePredefinedStyleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikePredefinedStyleData");
        ds.field("styleId", &self.styleId());
        ds.field("styleConfig", &self.styleConfig());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikePredefinedStyleDataT {
    pub styleId: Option<String>,
    pub styleConfig: i32,
}
impl Default for clz_Torappu_RoguelikePredefinedStyleDataT {
    fn default() -> Self {
        Self {
            styleId: None,
            styleConfig: 0,
        }
    }
}
impl clz_Torappu_RoguelikePredefinedStyleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedStyleData<'b>> {
        let styleId = self.styleId.as_ref().map(|x| _fbb.create_string(x));
        let styleConfig = self.styleConfig;
        clz_Torappu_RoguelikePredefinedStyleData::create(
            _fbb,
            &clz_Torappu_RoguelikePredefinedStyleDataArgs {
                styleId,
                styleConfig,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikePredefinedStyleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikePredefinedStyleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikePredefinedStyleData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikePredefinedStyleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikePredefinedStyleData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikePredefinedStyleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikePredefinedStyleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikePredefinedStyleData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikePredefinedStyleDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikePredefinedStyleDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikePredefinedStyleDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikePredefinedStyleData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikePredefinedStyleData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikePredefinedStyleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikePredefinedStyleData>>(
                    dict__string__clz_Torappu_RoguelikePredefinedStyleData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikePredefinedStyleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikePredefinedStyleData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikePredefinedStyleDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedStyleData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikePredefinedStyleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikePredefinedStyleDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikePredefinedStyleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikePredefinedStyleData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikePredefinedStyleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikePredefinedStyleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikePredefinedStyleData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedStyleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedStyleData>>(
                dict__string__clz_Torappu_RoguelikePredefinedStyleData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikePredefinedStyleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikePredefinedStyleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikePredefinedStyleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikePredefinedStyleData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikePredefinedStyleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikePredefinedStyleData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikePredefinedStyleDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikePredefinedStyleDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikePredefinedStyleDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikePredefinedStyleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikePredefinedStyleData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikePredefinedStyleData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikePredefinedStyleDataArgs { key, value },
        )
    }
}
pub enum dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_RoguelikeExpStyleConfigParam__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__enum__Torappu_RoguelikeExpStyleConfigParam__string<'a> {
    type Inner = dict__enum__Torappu_RoguelikeExpStyleConfigParam__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__enum__Torappu_RoguelikeExpStyleConfigParam__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_RoguelikeExpStyleConfigParam__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_RoguelikeExpStyleConfigParam__string<'bldr>>
    {
        let mut builder =
            dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringT {
        let key = self.key();
        let value = self.value().map(|x| x.to_string());
        dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_RoguelikeExpStyleConfigParam {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeExpStyleConfigParam>(
                    dict__enum__Torappu_RoguelikeExpStyleConfigParam__string::VT_KEY,
                    Some(enum__Torappu_RoguelikeExpStyleConfigParam::BATTLE_END_HP_LOSE_TEXT),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_RoguelikeExpStyleConfigParam__string,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_RoguelikeExpStyleConfigParam,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                dict__enum__Torappu_RoguelikeExpStyleConfigParam__string::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__enum__Torappu_RoguelikeExpStyleConfigParam__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeExpStyleConfigParam>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringArgs<'a> {
    pub key: enum__Torappu_RoguelikeExpStyleConfigParam,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringArgs {
            key: enum__Torappu_RoguelikeExpStyleConfigParam::BATTLE_END_HP_LOSE_TEXT,
            value: None,
        }
    }
}

impl Serialize for dict__enum__Torappu_RoguelikeExpStyleConfigParam__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__enum__Torappu_RoguelikeExpStyleConfigParam__string",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_RoguelikeExpStyleConfigParam) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeExpStyleConfigParam>(
                dict__enum__Torappu_RoguelikeExpStyleConfigParam__string::VT_KEY,
                key,
                enum__Torappu_RoguelikeExpStyleConfigParam::BATTLE_END_HP_LOSE_TEXT,
            );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__enum__Torappu_RoguelikeExpStyleConfigParam__string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_RoguelikeExpStyleConfigParam__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__enum__Torappu_RoguelikeExpStyleConfigParam__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__enum__Torappu_RoguelikeExpStyleConfigParam__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringT {
    pub key: enum__Torappu_RoguelikeExpStyleConfigParam,
    pub value: Option<String>,
}
impl Default for dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringT {
    fn default() -> Self {
        Self {
            key: enum__Torappu_RoguelikeExpStyleConfigParam::BATTLE_END_HP_LOSE_TEXT,
            value: None,
        }
    }
}
impl dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_RoguelikeExpStyleConfigParam__string<'b>> {
        let key = self.key;
        let value = self.value.as_ref().map(|x| _fbb.create_string(x));
        dict__enum__Torappu_RoguelikeExpStyleConfigParam__string::create(
            _fbb,
            &dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikePredefinedExpStyleConfigDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikePredefinedExpStyleConfigData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikePredefinedExpStyleConfigData<'a> {
    type Inner = clz_Torappu_RoguelikePredefinedExpStyleConfigData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikePredefinedExpStyleConfigData<'a> {
    pub const VT_PARAMDICT: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikePredefinedExpStyleConfigData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikePredefinedExpStyleConfigDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedExpStyleConfigData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikePredefinedExpStyleConfigDataBuilder::new(_fbb);
        if let Some(x) = args.paramDict {
            builder.add_paramDict(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikePredefinedExpStyleConfigDataT {
        let paramDict = self
            .paramDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikePredefinedExpStyleConfigDataT { paramDict }
    }

    #[inline]
    pub fn paramDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__enum__Torappu_RoguelikeExpStyleConfigParam__string<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_RoguelikeExpStyleConfigParam__string,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikePredefinedExpStyleConfigData::VT_PARAMDICT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikePredefinedExpStyleConfigData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_RoguelikeExpStyleConfigParam__string,
                    >,
                >,
            >>("paramDict", Self::VT_PARAMDICT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikePredefinedExpStyleConfigDataArgs<'a> {
    pub paramDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_RoguelikeExpStyleConfigParam__string<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikePredefinedExpStyleConfigDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikePredefinedExpStyleConfigDataArgs { paramDict: None }
    }
}

impl Serialize for clz_Torappu_RoguelikePredefinedExpStyleConfigData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikePredefinedExpStyleConfigData", 1)?;
        if let Some(f) = self.paramDict() {
            s.serialize_field("paramDict", &f)?;
        } else {
            s.skip_field("paramDict")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikePredefinedExpStyleConfigDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikePredefinedExpStyleConfigDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_paramDict(
        &mut self,
        paramDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_RoguelikeExpStyleConfigParam__string<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikePredefinedExpStyleConfigData::VT_PARAMDICT,
            paramDict,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikePredefinedExpStyleConfigDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikePredefinedExpStyleConfigDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedExpStyleConfigData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikePredefinedExpStyleConfigData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikePredefinedExpStyleConfigData");
        ds.field("paramDict", &self.paramDict());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikePredefinedExpStyleConfigDataT {
    pub paramDict: Option<Vec<dict__enum__Torappu_RoguelikeExpStyleConfigParam__stringT>>,
}
impl Default for clz_Torappu_RoguelikePredefinedExpStyleConfigDataT {
    fn default() -> Self {
        Self { paramDict: None }
    }
}
impl clz_Torappu_RoguelikePredefinedExpStyleConfigDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedExpStyleConfigData<'b>> {
        let paramDict = self.paramDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikePredefinedExpStyleConfigData::create(
            _fbb,
            &clz_Torappu_RoguelikePredefinedExpStyleConfigDataArgs { paramDict },
        )
    }
}
pub enum clz_Torappu_RoguelikePredefinedConstStyleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikePredefinedConstStyleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikePredefinedConstStyleData<'a> {
    type Inner = clz_Torappu_RoguelikePredefinedConstStyleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikePredefinedConstStyleData<'a> {
    pub const VT_EXPSTYLECONFIG: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikePredefinedConstStyleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikePredefinedConstStyleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedConstStyleData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikePredefinedConstStyleDataBuilder::new(_fbb);
        if let Some(x) = args.expStyleConfig {
            builder.add_expStyleConfig(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikePredefinedConstStyleDataT {
        let expStyleConfig = self.expStyleConfig().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikePredefinedConstStyleDataT { expStyleConfig }
    }

    #[inline]
    pub fn expStyleConfig(&self) -> Option<clz_Torappu_RoguelikePredefinedExpStyleConfigData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikePredefinedExpStyleConfigData>>(clz_Torappu_RoguelikePredefinedConstStyleData::VT_EXPSTYLECONFIG, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikePredefinedConstStyleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikePredefinedExpStyleConfigData>>("expStyleConfig", Self::VT_EXPSTYLECONFIG, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikePredefinedConstStyleDataArgs<'a> {
    pub expStyleConfig:
        Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedExpStyleConfigData<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikePredefinedConstStyleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikePredefinedConstStyleDataArgs {
            expStyleConfig: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikePredefinedConstStyleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikePredefinedConstStyleData", 1)?;
        if let Some(f) = self.expStyleConfig() {
            s.serialize_field("expStyleConfig", &f)?;
        } else {
            s.skip_field("expStyleConfig")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikePredefinedConstStyleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikePredefinedConstStyleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_expStyleConfig(
        &mut self,
        expStyleConfig: flatbuffers::WIPOffset<
            clz_Torappu_RoguelikePredefinedExpStyleConfigData<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedExpStyleConfigData>>(clz_Torappu_RoguelikePredefinedConstStyleData::VT_EXPSTYLECONFIG, expStyleConfig);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikePredefinedConstStyleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikePredefinedConstStyleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedConstStyleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikePredefinedConstStyleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikePredefinedConstStyleData");
        ds.field("expStyleConfig", &self.expStyleConfig());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikePredefinedConstStyleDataT {
    pub expStyleConfig: Option<Box<clz_Torappu_RoguelikePredefinedExpStyleConfigDataT>>,
}
impl Default for clz_Torappu_RoguelikePredefinedConstStyleDataT {
    fn default() -> Self {
        Self {
            expStyleConfig: None,
        }
    }
}
impl clz_Torappu_RoguelikePredefinedConstStyleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedConstStyleData<'b>> {
        let expStyleConfig = self.expStyleConfig.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikePredefinedConstStyleData::create(
            _fbb,
            &clz_Torappu_RoguelikePredefinedConstStyleDataArgs { expStyleConfig },
        )
    }
}
pub enum clz_Torappu_RoguelikeGameExploreToolDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeGameExploreToolData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeGameExploreToolData<'a> {
    type Inner = clz_Torappu_RoguelikeGameExploreToolData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeGameExploreToolData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_TRAPID: flatbuffers::VOffsetT = 6;
    pub const VT_TRAPDESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeGameExploreToolData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeGameExploreToolDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameExploreToolData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeGameExploreToolDataBuilder::new(_fbb);
        if let Some(x) = args.trapDesc {
            builder.add_trapDesc(x);
        }
        if let Some(x) = args.trapId {
            builder.add_trapId(x);
        }
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeGameExploreToolDataT {
        let itemId = self.itemId().map(|x| x.to_string());
        let trapId = self.trapId().map(|x| x.to_string());
        let trapDesc = self.trapDesc().map(|x| x.to_string());
        clz_Torappu_RoguelikeGameExploreToolDataT {
            itemId,
            trapId,
            trapDesc,
        }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameExploreToolData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn trapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameExploreToolData::VT_TRAPID,
                None,
            )
        }
    }
    #[inline]
    pub fn trapDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeGameExploreToolData::VT_TRAPDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeGameExploreToolData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("trapId", Self::VT_TRAPID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "trapDesc",
                Self::VT_TRAPDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeGameExploreToolDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trapDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeGameExploreToolDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeGameExploreToolDataArgs {
            itemId: None,
            trapId: None,
            trapDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeGameExploreToolData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeGameExploreToolData", 3)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        if let Some(f) = self.trapId() {
            s.serialize_field("trapId", &f)?;
        } else {
            s.skip_field("trapId")?;
        }
        if let Some(f) = self.trapDesc() {
            s.serialize_field("trapDesc", &f)?;
        } else {
            s.skip_field("trapDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeGameExploreToolDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeGameExploreToolDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameExploreToolData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_trapId(&mut self, trapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameExploreToolData::VT_TRAPID,
            trapId,
        );
    }
    #[inline]
    pub fn add_trapDesc(&mut self, trapDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeGameExploreToolData::VT_TRAPDESC,
            trapDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeGameExploreToolDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeGameExploreToolDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameExploreToolData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeGameExploreToolData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeGameExploreToolData");
        ds.field("itemId", &self.itemId());
        ds.field("trapId", &self.trapId());
        ds.field("trapDesc", &self.trapDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeGameExploreToolDataT {
    pub itemId: Option<String>,
    pub trapId: Option<String>,
    pub trapDesc: Option<String>,
}
impl Default for clz_Torappu_RoguelikeGameExploreToolDataT {
    fn default() -> Self {
        Self {
            itemId: None,
            trapId: None,
            trapDesc: None,
        }
    }
}
impl clz_Torappu_RoguelikeGameExploreToolDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameExploreToolData<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let trapId = self.trapId.as_ref().map(|x| _fbb.create_string(x));
        let trapDesc = self.trapDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeGameExploreToolData::create(
            _fbb,
            &clz_Torappu_RoguelikeGameExploreToolDataArgs {
                itemId,
                trapId,
                trapDesc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeGameExploreToolDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeGameExploreToolData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeGameExploreToolData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeGameExploreToolData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeGameExploreToolData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeGameExploreToolData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeGameExploreToolDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameExploreToolData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeGameExploreToolDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeGameExploreToolDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeGameExploreToolDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeGameExploreToolData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeGameExploreToolData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeGameExploreToolData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameExploreToolData>>(
                    dict__string__clz_Torappu_RoguelikeGameExploreToolData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeGameExploreToolData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameExploreToolData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeGameExploreToolDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameExploreToolData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeGameExploreToolDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeGameExploreToolDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeGameExploreToolData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeGameExploreToolData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeGameExploreToolDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeGameExploreToolDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeGameExploreToolData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameExploreToolData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameExploreToolData>>(
                dict__string__clz_Torappu_RoguelikeGameExploreToolData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeGameExploreToolDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeGameExploreToolDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameExploreToolData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeGameExploreToolData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeGameExploreToolData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeGameExploreToolData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeGameExploreToolDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeGameExploreToolDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeGameExploreToolDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeGameExploreToolDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeGameExploreToolData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeGameExploreToolData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeGameExploreToolDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeRollNodeGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeRollNodeGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeRollNodeGroupData<'a> {
    type Inner = clz_Torappu_RoguelikeRollNodeGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeRollNodeGroupData<'a> {
    pub const VT_NODETYPE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeRollNodeGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeRollNodeGroupDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeRollNodeGroupData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeRollNodeGroupDataBuilder::new(_fbb);
        builder.add_nodeType(args.nodeType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeRollNodeGroupDataT {
        let nodeType = self.nodeType();
        clz_Torappu_RoguelikeRollNodeGroupDataT { nodeType }
    }

    #[inline]
    pub fn nodeType(&self) -> enum__Torappu_RoguelikeEventType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeEventType>(
                    clz_Torappu_RoguelikeRollNodeGroupData::VT_NODETYPE,
                    Some(enum__Torappu_RoguelikeEventType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeRollNodeGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeEventType>("nodeType", Self::VT_NODETYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeRollNodeGroupDataArgs {
    pub nodeType: enum__Torappu_RoguelikeEventType,
}
impl<'a> Default for clz_Torappu_RoguelikeRollNodeGroupDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeRollNodeGroupDataArgs {
            nodeType: enum__Torappu_RoguelikeEventType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeRollNodeGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeRollNodeGroupData", 1)?;
        s.serialize_field("nodeType", &self.nodeType())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeRollNodeGroupDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeRollNodeGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeType(&mut self, nodeType: enum__Torappu_RoguelikeEventType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeEventType>(
            clz_Torappu_RoguelikeRollNodeGroupData::VT_NODETYPE,
            nodeType,
            enum__Torappu_RoguelikeEventType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeRollNodeGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeRollNodeGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeRollNodeGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeRollNodeGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeRollNodeGroupData");
        ds.field("nodeType", &self.nodeType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeRollNodeGroupDataT {
    pub nodeType: enum__Torappu_RoguelikeEventType,
}
impl Default for clz_Torappu_RoguelikeRollNodeGroupDataT {
    fn default() -> Self {
        Self {
            nodeType: enum__Torappu_RoguelikeEventType::NONE,
        }
    }
}
impl clz_Torappu_RoguelikeRollNodeGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeRollNodeGroupData<'b>> {
        let nodeType = self.nodeType;
        clz_Torappu_RoguelikeRollNodeGroupData::create(
            _fbb,
            &clz_Torappu_RoguelikeRollNodeGroupDataArgs { nodeType },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeRollNodeGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeRollNodeGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeRollNodeGroupData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeRollNodeGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeRollNodeGroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeRollNodeGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeRollNodeGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeRollNodeGroupData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeRollNodeGroupDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeRollNodeGroupDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeRollNodeGroupDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeRollNodeGroupData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeRollNodeGroupData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeRollNodeGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeRollNodeGroupData>>(
                    dict__string__clz_Torappu_RoguelikeRollNodeGroupData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeRollNodeGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeRollNodeGroupData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeRollNodeGroupDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeRollNodeGroupData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeRollNodeGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeRollNodeGroupDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeRollNodeGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeRollNodeGroupData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeRollNodeGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeRollNodeGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeRollNodeGroupData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeRollNodeGroupData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeRollNodeGroupData>>(
                dict__string__clz_Torappu_RoguelikeRollNodeGroupData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeRollNodeGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeRollNodeGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeRollNodeGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeRollNodeGroupData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeRollNodeGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeRollNodeGroupData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeRollNodeGroupDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeRollNodeGroupDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeRollNodeGroupDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeRollNodeGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeRollNodeGroupData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeRollNodeGroupData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeRollNodeGroupDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeRollNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeRollNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeRollNodeData<'a> {
    type Inner = clz_Torappu_RoguelikeRollNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeRollNodeData<'a> {
    pub const VT_ZONEID: flatbuffers::VOffsetT = 4;
    pub const VT_GROUPS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeRollNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeRollNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeRollNodeData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeRollNodeDataBuilder::new(_fbb);
        if let Some(x) = args.groups {
            builder.add_groups(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeRollNodeDataT {
        let zoneId = self.zoneId().map(|x| x.to_string());
        let groups = self
            .groups()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeRollNodeDataT { zoneId, groups }
    }

    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeRollNodeData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn groups(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeRollNodeGroupData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeRollNodeGroupData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeRollNodeData::VT_GROUPS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeRollNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeRollNodeGroupData,
                    >,
                >,
            >>("groups", Self::VT_GROUPS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeRollNodeDataArgs<'a> {
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub groups: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeRollNodeGroupData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeRollNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeRollNodeDataArgs {
            zoneId: None,
            groups: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeRollNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeRollNodeData", 2)?;
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.groups() {
            s.serialize_field("groups", &f)?;
        } else {
            s.skip_field("groups")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeRollNodeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeRollNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeRollNodeData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_groups(
        &mut self,
        groups: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeRollNodeGroupData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeRollNodeData::VT_GROUPS,
            groups,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeRollNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeRollNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeRollNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeRollNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeRollNodeData");
        ds.field("zoneId", &self.zoneId());
        ds.field("groups", &self.groups());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeRollNodeDataT {
    pub zoneId: Option<String>,
    pub groups: Option<Vec<dict__string__clz_Torappu_RoguelikeRollNodeGroupDataT>>,
}
impl Default for clz_Torappu_RoguelikeRollNodeDataT {
    fn default() -> Self {
        Self {
            zoneId: None,
            groups: None,
        }
    }
}
impl clz_Torappu_RoguelikeRollNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeRollNodeData<'b>> {
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let groups = self.groups.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeRollNodeData::create(
            _fbb,
            &clz_Torappu_RoguelikeRollNodeDataArgs { zoneId, groups },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeRollNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeRollNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeRollNodeData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeRollNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeRollNodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeRollNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeRollNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeRollNodeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeRollNodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeRollNodeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeRollNodeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeRollNodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeRollNodeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeRollNodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeRollNodeData>>(
                    dict__string__clz_Torappu_RoguelikeRollNodeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeRollNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeRollNodeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeRollNodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeRollNodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeRollNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeRollNodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeRollNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeRollNodeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeRollNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeRollNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeRollNodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeRollNodeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeRollNodeData>>(
                dict__string__clz_Torappu_RoguelikeRollNodeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeRollNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeRollNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeRollNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeRollNodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeRollNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeRollNodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeRollNodeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeRollNodeDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeRollNodeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeRollNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeRollNodeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeRollNodeData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeRollNodeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeActivityBasicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeActivityBasicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeActivityBasicData<'a> {
    type Inner = clz_Torappu_RoguelikeActivityBasicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeActivityBasicData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 8;
    pub const VT_ENDTIME: flatbuffers::VOffsetT = 10;
    pub const VT_ISPRESENTSEEDMODE: flatbuffers::VOffsetT = 12;
    pub const VT_ISUNLOCKBADGE: flatbuffers::VOffsetT = 14;
    pub const VT_VALIDMODE: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeActivityBasicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeActivityBasicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityBasicData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeActivityBasicDataBuilder::new(_fbb);
        builder.add_endTime(args.endTime);
        builder.add_startTime(args.startTime);
        builder.add_validMode(args.validMode);
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_isUnlockBadge(args.isUnlockBadge);
        builder.add_isPresentSeedMode(args.isPresentSeedMode);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeActivityBasicDataT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        let startTime = self.startTime();
        let endTime = self.endTime();
        let isPresentSeedMode = self.isPresentSeedMode();
        let isUnlockBadge = self.isUnlockBadge();
        let validMode = self.validMode();
        clz_Torappu_RoguelikeActivityBasicDataT {
            id,
            type_,
            startTime,
            endTime,
            isPresentSeedMode,
            isUnlockBadge,
            validMode,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeActivityBasicData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_RoguelikeActivityType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeActivityType>(
                    clz_Torappu_RoguelikeActivityBasicData::VT_TYPE_,
                    Some(enum__Torappu_RoguelikeActivityType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_RoguelikeActivityBasicData::VT_STARTTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn endTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_RoguelikeActivityBasicData::VT_ENDTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn isPresentSeedMode(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeActivityBasicData::VT_ISPRESENTSEEDMODE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isUnlockBadge(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeActivityBasicData::VT_ISUNLOCKBADGE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn validMode(&self) -> enum__Torappu_RoguelikeTopicMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTopicMode>(
                    clz_Torappu_RoguelikeActivityBasicData::VT_VALIDMODE,
                    Some(enum__Torappu_RoguelikeTopicMode::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeActivityBasicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_RoguelikeActivityType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<i64>("endTime", Self::VT_ENDTIME, false)?
            .visit_field::<bool>("isPresentSeedMode", Self::VT_ISPRESENTSEEDMODE, false)?
            .visit_field::<bool>("isUnlockBadge", Self::VT_ISUNLOCKBADGE, false)?
            .visit_field::<enum__Torappu_RoguelikeTopicMode>(
                "validMode",
                Self::VT_VALIDMODE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeActivityBasicDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_RoguelikeActivityType,
    pub startTime: i64,
    pub endTime: i64,
    pub isPresentSeedMode: bool,
    pub isUnlockBadge: bool,
    pub validMode: enum__Torappu_RoguelikeTopicMode,
}
impl<'a> Default for clz_Torappu_RoguelikeActivityBasicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeActivityBasicDataArgs {
            id: None,
            type_: enum__Torappu_RoguelikeActivityType::NONE,
            startTime: 0,
            endTime: 0,
            isPresentSeedMode: false,
            isUnlockBadge: false,
            validMode: enum__Torappu_RoguelikeTopicMode::NONE,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeActivityBasicData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeActivityBasicData", 7)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("startTime", &self.startTime())?;
        s.serialize_field("endTime", &self.endTime())?;
        s.serialize_field("isPresentSeedMode", &self.isPresentSeedMode())?;
        s.serialize_field("isUnlockBadge", &self.isUnlockBadge())?;
        s.serialize_field("validMode", &self.validMode())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeActivityBasicDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeActivityBasicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeActivityBasicData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_RoguelikeActivityType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeActivityType>(
            clz_Torappu_RoguelikeActivityBasicData::VT_TYPE_,
            type_,
            enum__Torappu_RoguelikeActivityType::NONE,
        );
    }
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeActivityBasicData::VT_STARTTIME,
            startTime,
            0,
        );
    }
    #[inline]
    pub fn add_endTime(&mut self, endTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RoguelikeActivityBasicData::VT_ENDTIME,
            endTime,
            0,
        );
    }
    #[inline]
    pub fn add_isPresentSeedMode(&mut self, isPresentSeedMode: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeActivityBasicData::VT_ISPRESENTSEEDMODE,
            isPresentSeedMode,
            false,
        );
    }
    #[inline]
    pub fn add_isUnlockBadge(&mut self, isUnlockBadge: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeActivityBasicData::VT_ISUNLOCKBADGE,
            isUnlockBadge,
            false,
        );
    }
    #[inline]
    pub fn add_validMode(&mut self, validMode: enum__Torappu_RoguelikeTopicMode) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeTopicMode>(
            clz_Torappu_RoguelikeActivityBasicData::VT_VALIDMODE,
            validMode,
            enum__Torappu_RoguelikeTopicMode::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeActivityBasicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeActivityBasicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityBasicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeActivityBasicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeActivityBasicData");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("startTime", &self.startTime());
        ds.field("endTime", &self.endTime());
        ds.field("isPresentSeedMode", &self.isPresentSeedMode());
        ds.field("isUnlockBadge", &self.isUnlockBadge());
        ds.field("validMode", &self.validMode());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeActivityBasicDataT {
    pub id: Option<String>,
    pub type_: enum__Torappu_RoguelikeActivityType,
    pub startTime: i64,
    pub endTime: i64,
    pub isPresentSeedMode: bool,
    pub isUnlockBadge: bool,
    pub validMode: enum__Torappu_RoguelikeTopicMode,
}
impl Default for clz_Torappu_RoguelikeActivityBasicDataT {
    fn default() -> Self {
        Self {
            id: None,
            type_: enum__Torappu_RoguelikeActivityType::NONE,
            startTime: 0,
            endTime: 0,
            isPresentSeedMode: false,
            isUnlockBadge: false,
            validMode: enum__Torappu_RoguelikeTopicMode::NONE,
        }
    }
}
impl clz_Torappu_RoguelikeActivityBasicDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityBasicData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let startTime = self.startTime;
        let endTime = self.endTime;
        let isPresentSeedMode = self.isPresentSeedMode;
        let isUnlockBadge = self.isUnlockBadge;
        let validMode = self.validMode;
        clz_Torappu_RoguelikeActivityBasicData::create(
            _fbb,
            &clz_Torappu_RoguelikeActivityBasicDataArgs {
                id,
                type_,
                startTime,
                endTime,
                isPresentSeedMode,
                isUnlockBadge,
                validMode,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeActivityBasicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeActivityBasicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeActivityBasicData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeActivityBasicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeActivityBasicData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeActivityBasicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeActivityBasicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeActivityBasicData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeActivityBasicDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeActivityBasicDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeActivityBasicDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeActivityBasicData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeActivityBasicData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeActivityBasicData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeActivityBasicData>>(
                    dict__string__clz_Torappu_RoguelikeActivityBasicData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeActivityBasicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeActivityBasicData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeActivityBasicDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityBasicData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeActivityBasicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeActivityBasicDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeActivityBasicData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeActivityBasicData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeActivityBasicDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeActivityBasicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeActivityBasicData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityBasicData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityBasicData>>(
                dict__string__clz_Torappu_RoguelikeActivityBasicData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeActivityBasicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeActivityBasicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeActivityBasicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeActivityBasicData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeActivityBasicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeActivityBasicData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeActivityBasicDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeActivityBasicDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeActivityBasicDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeActivityBasicDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeActivityBasicData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeActivityBasicData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeActivityBasicDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData<'a>
{
    type Inner = clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData<'a> {
    pub const VT_SEED: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_DESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData<'bldr>,
    > {
        let mut builder =
            clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataBuilder::new(
                _fbb,
            );
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.seed {
            builder.add_seed(x);
        }
        builder.finish()
    }

    pub fn unpack(
        &self,
    ) -> clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataT {
        let seed = self.seed().map(|x| x.to_string());
        let sortId = self.sortId();
        let desc = self.desc().map(|x| x.to_string());
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataT {
            seed,
            sortId,
            desc,
        }
    }

    #[inline]
    pub fn seed(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData::VT_SEED, None)
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<i32>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData::VT_SORTID, Some(0)).unwrap()
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData::VT_DESC, None)
        }
    }
}

impl flatbuffers::Verifiable
    for clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("seed", Self::VT_SEED, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataArgs<'a> {
    pub seed: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default
    for clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataArgs<'a>
{
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataArgs {
            seed: None,
            sortId: 0,
            desc: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData",
            3,
        )?;
        if let Some(f) = self.seed() {
            s.serialize_field("seed", &f)?;
        } else {
            s.skip_field("seed")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_seed(&mut self, seed: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData::VT_SEED,
            seed,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataBuilder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData",
        );
        ds.field("seed", &self.seed());
        ds.field("sortId", &self.sortId());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataT {
    pub seed: Option<String>,
    pub sortId: i32,
    pub desc: Option<String>,
}
impl Default for clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataT {
    fn default() -> Self {
        Self {
            seed: None,
            sortId: 0,
            desc: None,
        }
    }
}
impl clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData<'b>,
    > {
        let seed = self.seed.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData::create(
            _fbb,
            &clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataArgs {
                seed,
                sortId,
                desc,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData<'a>
{
    type Inner = clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData<'a> {
    pub const VT_SEEDMODEINTRO: flatbuffers::VOffsetT = 4;
    pub const VT_EMPTYTEXTHINT: flatbuffers::VOffsetT = 6;
    pub const VT_ERRORTEXTHINT: flatbuffers::VOffsetT = 8;
    pub const VT_LEGITIMATETEXTHINT: flatbuffers::VOffsetT = 10;
    pub const VT_SEEDMODECONFIRMREPLACEMENT: flatbuffers::VOffsetT = 12;
    pub const VT_DIFFICULTYLEVELTEXTHINT: flatbuffers::VOffsetT = 14;
    pub const VT_LOCKEDDIFFICULTYLEVELTEXTHINT: flatbuffers::VOffsetT = 16;
    pub const VT_SETDIFFICULTYLEVELTEXTHINT: flatbuffers::VOffsetT = 18;
    pub const VT_NOTENABLEDTEXTHINT: flatbuffers::VOffsetT = 20;
    pub const VT_ENABLEDTEXTHINT: flatbuffers::VOffsetT = 22;
    pub const VT_USESUCCEEDEDTEXTHINT: flatbuffers::VOffsetT = 24;
    pub const VT_OFFICIALUSESUCCEEDEDTEXTHINT: flatbuffers::VOffsetT = 26;
    pub const VT_SEEDMODELOCKEDTEXTHINT: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData<'bldr>,
    > {
        let mut builder = clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataBuilder::new(_fbb);
        if let Some(x) = args.seedModeLockedTextHint {
            builder.add_seedModeLockedTextHint(x);
        }
        if let Some(x) = args.officialUseSucceededTextHint {
            builder.add_officialUseSucceededTextHint(x);
        }
        if let Some(x) = args.useSucceededTextHint {
            builder.add_useSucceededTextHint(x);
        }
        if let Some(x) = args.enabledTextHint {
            builder.add_enabledTextHint(x);
        }
        if let Some(x) = args.notEnabledTextHint {
            builder.add_notEnabledTextHint(x);
        }
        if let Some(x) = args.setDifficultyLevelTextHint {
            builder.add_setDifficultyLevelTextHint(x);
        }
        if let Some(x) = args.lockedDifficultyLevelTextHint {
            builder.add_lockedDifficultyLevelTextHint(x);
        }
        if let Some(x) = args.difficultyLevelTextHint {
            builder.add_difficultyLevelTextHint(x);
        }
        if let Some(x) = args.seedModeConfirmReplacement {
            builder.add_seedModeConfirmReplacement(x);
        }
        if let Some(x) = args.legitimateTextHint {
            builder.add_legitimateTextHint(x);
        }
        if let Some(x) = args.errorTextHint {
            builder.add_errorTextHint(x);
        }
        if let Some(x) = args.emptyTextHint {
            builder.add_emptyTextHint(x);
        }
        if let Some(x) = args.seedModeIntro {
            builder.add_seedModeIntro(x);
        }
        builder.finish()
    }

    pub fn unpack(
        &self,
    ) -> clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataT {
        let seedModeIntro = self.seedModeIntro().map(|x| x.to_string());
        let emptyTextHint = self.emptyTextHint().map(|x| x.to_string());
        let errorTextHint = self.errorTextHint().map(|x| x.to_string());
        let legitimateTextHint = self.legitimateTextHint().map(|x| x.to_string());
        let seedModeConfirmReplacement = self.seedModeConfirmReplacement().map(|x| x.to_string());
        let difficultyLevelTextHint = self.difficultyLevelTextHint().map(|x| x.to_string());
        let lockedDifficultyLevelTextHint =
            self.lockedDifficultyLevelTextHint().map(|x| x.to_string());
        let setDifficultyLevelTextHint = self.setDifficultyLevelTextHint().map(|x| x.to_string());
        let notEnabledTextHint = self.notEnabledTextHint().map(|x| x.to_string());
        let enabledTextHint = self.enabledTextHint().map(|x| x.to_string());
        let useSucceededTextHint = self.useSucceededTextHint().map(|x| x.to_string());
        let officialUseSucceededTextHint =
            self.officialUseSucceededTextHint().map(|x| x.to_string());
        let seedModeLockedTextHint = self.seedModeLockedTextHint().map(|x| x.to_string());
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataT {
            seedModeIntro,
            emptyTextHint,
            errorTextHint,
            legitimateTextHint,
            seedModeConfirmReplacement,
            difficultyLevelTextHint,
            lockedDifficultyLevelTextHint,
            setDifficultyLevelTextHint,
            notEnabledTextHint,
            enabledTextHint,
            useSucceededTextHint,
            officialUseSucceededTextHint,
            seedModeLockedTextHint,
        }
    }

    #[inline]
    pub fn seedModeIntro(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_SEEDMODEINTRO, None)
        }
    }
    #[inline]
    pub fn emptyTextHint(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_EMPTYTEXTHINT, None)
        }
    }
    #[inline]
    pub fn errorTextHint(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_ERRORTEXTHINT, None)
        }
    }
    #[inline]
    pub fn legitimateTextHint(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_LEGITIMATETEXTHINT, None)
        }
    }
    #[inline]
    pub fn seedModeConfirmReplacement(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_SEEDMODECONFIRMREPLACEMENT, None)
        }
    }
    #[inline]
    pub fn difficultyLevelTextHint(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_DIFFICULTYLEVELTEXTHINT, None)
        }
    }
    #[inline]
    pub fn lockedDifficultyLevelTextHint(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_LOCKEDDIFFICULTYLEVELTEXTHINT, None)
        }
    }
    #[inline]
    pub fn setDifficultyLevelTextHint(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_SETDIFFICULTYLEVELTEXTHINT, None)
        }
    }
    #[inline]
    pub fn notEnabledTextHint(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_NOTENABLEDTEXTHINT, None)
        }
    }
    #[inline]
    pub fn enabledTextHint(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_ENABLEDTEXTHINT, None)
        }
    }
    #[inline]
    pub fn useSucceededTextHint(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_USESUCCEEDEDTEXTHINT, None)
        }
    }
    #[inline]
    pub fn officialUseSucceededTextHint(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_OFFICIALUSESUCCEEDEDTEXTHINT, None)
        }
    }
    #[inline]
    pub fn seedModeLockedTextHint(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_SEEDMODELOCKEDTEXTHINT, None)
        }
    }
}

impl flatbuffers::Verifiable
    for clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "seedModeIntro",
                Self::VT_SEEDMODEINTRO,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "emptyTextHint",
                Self::VT_EMPTYTEXTHINT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "errorTextHint",
                Self::VT_ERRORTEXTHINT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "legitimateTextHint",
                Self::VT_LEGITIMATETEXTHINT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "seedModeConfirmReplacement",
                Self::VT_SEEDMODECONFIRMREPLACEMENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "difficultyLevelTextHint",
                Self::VT_DIFFICULTYLEVELTEXTHINT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "lockedDifficultyLevelTextHint",
                Self::VT_LOCKEDDIFFICULTYLEVELTEXTHINT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "setDifficultyLevelTextHint",
                Self::VT_SETDIFFICULTYLEVELTEXTHINT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "notEnabledTextHint",
                Self::VT_NOTENABLEDTEXTHINT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enabledTextHint",
                Self::VT_ENABLEDTEXTHINT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "useSucceededTextHint",
                Self::VT_USESUCCEEDEDTEXTHINT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "officialUseSucceededTextHint",
                Self::VT_OFFICIALUSESUCCEEDEDTEXTHINT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "seedModeLockedTextHint",
                Self::VT_SEEDMODELOCKEDTEXTHINT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataArgs<'a> {
    pub seedModeIntro: Option<flatbuffers::WIPOffset<&'a str>>,
    pub emptyTextHint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub errorTextHint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub legitimateTextHint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub seedModeConfirmReplacement: Option<flatbuffers::WIPOffset<&'a str>>,
    pub difficultyLevelTextHint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lockedDifficultyLevelTextHint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub setDifficultyLevelTextHint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub notEnabledTextHint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enabledTextHint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub useSucceededTextHint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub officialUseSucceededTextHint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub seedModeLockedTextHint: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default
    for clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataArgs<'a>
{
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataArgs {
            seedModeIntro: None,
            emptyTextHint: None,
            errorTextHint: None,
            legitimateTextHint: None,
            seedModeConfirmReplacement: None,
            difficultyLevelTextHint: None,
            lockedDifficultyLevelTextHint: None,
            setDifficultyLevelTextHint: None,
            notEnabledTextHint: None,
            enabledTextHint: None,
            useSucceededTextHint: None,
            officialUseSucceededTextHint: None,
            seedModeLockedTextHint: None,
        }
    }
}

impl Serialize
    for clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData<'_>
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData",
            13,
        )?;
        if let Some(f) = self.seedModeIntro() {
            s.serialize_field("seedModeIntro", &f)?;
        } else {
            s.skip_field("seedModeIntro")?;
        }
        if let Some(f) = self.emptyTextHint() {
            s.serialize_field("emptyTextHint", &f)?;
        } else {
            s.skip_field("emptyTextHint")?;
        }
        if let Some(f) = self.errorTextHint() {
            s.serialize_field("errorTextHint", &f)?;
        } else {
            s.skip_field("errorTextHint")?;
        }
        if let Some(f) = self.legitimateTextHint() {
            s.serialize_field("legitimateTextHint", &f)?;
        } else {
            s.skip_field("legitimateTextHint")?;
        }
        if let Some(f) = self.seedModeConfirmReplacement() {
            s.serialize_field("seedModeConfirmReplacement", &f)?;
        } else {
            s.skip_field("seedModeConfirmReplacement")?;
        }
        if let Some(f) = self.difficultyLevelTextHint() {
            s.serialize_field("difficultyLevelTextHint", &f)?;
        } else {
            s.skip_field("difficultyLevelTextHint")?;
        }
        if let Some(f) = self.lockedDifficultyLevelTextHint() {
            s.serialize_field("lockedDifficultyLevelTextHint", &f)?;
        } else {
            s.skip_field("lockedDifficultyLevelTextHint")?;
        }
        if let Some(f) = self.setDifficultyLevelTextHint() {
            s.serialize_field("setDifficultyLevelTextHint", &f)?;
        } else {
            s.skip_field("setDifficultyLevelTextHint")?;
        }
        if let Some(f) = self.notEnabledTextHint() {
            s.serialize_field("notEnabledTextHint", &f)?;
        } else {
            s.skip_field("notEnabledTextHint")?;
        }
        if let Some(f) = self.enabledTextHint() {
            s.serialize_field("enabledTextHint", &f)?;
        } else {
            s.skip_field("enabledTextHint")?;
        }
        if let Some(f) = self.useSucceededTextHint() {
            s.serialize_field("useSucceededTextHint", &f)?;
        } else {
            s.skip_field("useSucceededTextHint")?;
        }
        if let Some(f) = self.officialUseSucceededTextHint() {
            s.serialize_field("officialUseSucceededTextHint", &f)?;
        } else {
            s.skip_field("officialUseSucceededTextHint")?;
        }
        if let Some(f) = self.seedModeLockedTextHint() {
            s.serialize_field("seedModeLockedTextHint", &f)?;
        } else {
            s.skip_field("seedModeLockedTextHint")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_seedModeIntro(&mut self, seedModeIntro: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_SEEDMODEINTRO, seedModeIntro);
    }
    #[inline]
    pub fn add_emptyTextHint(&mut self, emptyTextHint: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_EMPTYTEXTHINT, emptyTextHint);
    }
    #[inline]
    pub fn add_errorTextHint(&mut self, errorTextHint: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_ERRORTEXTHINT, errorTextHint);
    }
    #[inline]
    pub fn add_legitimateTextHint(&mut self, legitimateTextHint: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_LEGITIMATETEXTHINT, legitimateTextHint);
    }
    #[inline]
    pub fn add_seedModeConfirmReplacement(
        &mut self,
        seedModeConfirmReplacement: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_SEEDMODECONFIRMREPLACEMENT, seedModeConfirmReplacement);
    }
    #[inline]
    pub fn add_difficultyLevelTextHint(
        &mut self,
        difficultyLevelTextHint: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_DIFFICULTYLEVELTEXTHINT, difficultyLevelTextHint);
    }
    #[inline]
    pub fn add_lockedDifficultyLevelTextHint(
        &mut self,
        lockedDifficultyLevelTextHint: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_LOCKEDDIFFICULTYLEVELTEXTHINT, lockedDifficultyLevelTextHint);
    }
    #[inline]
    pub fn add_setDifficultyLevelTextHint(
        &mut self,
        setDifficultyLevelTextHint: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_SETDIFFICULTYLEVELTEXTHINT, setDifficultyLevelTextHint);
    }
    #[inline]
    pub fn add_notEnabledTextHint(&mut self, notEnabledTextHint: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_NOTENABLEDTEXTHINT, notEnabledTextHint);
    }
    #[inline]
    pub fn add_enabledTextHint(&mut self, enabledTextHint: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_ENABLEDTEXTHINT, enabledTextHint);
    }
    #[inline]
    pub fn add_useSucceededTextHint(
        &mut self,
        useSucceededTextHint: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_USESUCCEEDEDTEXTHINT, useSucceededTextHint);
    }
    #[inline]
    pub fn add_officialUseSucceededTextHint(
        &mut self,
        officialUseSucceededTextHint: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_OFFICIALUSESUCCEEDEDTEXTHINT, officialUseSucceededTextHint);
    }
    #[inline]
    pub fn add_seedModeLockedTextHint(
        &mut self,
        seedModeLockedTextHint: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::VT_SEEDMODELOCKEDTEXTHINT, seedModeLockedTextHint);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataBuilder<
        'a,
        'b,
        A,
    > {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData",
        );
        ds.field("seedModeIntro", &self.seedModeIntro());
        ds.field("emptyTextHint", &self.emptyTextHint());
        ds.field("errorTextHint", &self.errorTextHint());
        ds.field("legitimateTextHint", &self.legitimateTextHint());
        ds.field(
            "seedModeConfirmReplacement",
            &self.seedModeConfirmReplacement(),
        );
        ds.field("difficultyLevelTextHint", &self.difficultyLevelTextHint());
        ds.field(
            "lockedDifficultyLevelTextHint",
            &self.lockedDifficultyLevelTextHint(),
        );
        ds.field(
            "setDifficultyLevelTextHint",
            &self.setDifficultyLevelTextHint(),
        );
        ds.field("notEnabledTextHint", &self.notEnabledTextHint());
        ds.field("enabledTextHint", &self.enabledTextHint());
        ds.field("useSucceededTextHint", &self.useSucceededTextHint());
        ds.field(
            "officialUseSucceededTextHint",
            &self.officialUseSucceededTextHint(),
        );
        ds.field("seedModeLockedTextHint", &self.seedModeLockedTextHint());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataT {
    pub seedModeIntro: Option<String>,
    pub emptyTextHint: Option<String>,
    pub errorTextHint: Option<String>,
    pub legitimateTextHint: Option<String>,
    pub seedModeConfirmReplacement: Option<String>,
    pub difficultyLevelTextHint: Option<String>,
    pub lockedDifficultyLevelTextHint: Option<String>,
    pub setDifficultyLevelTextHint: Option<String>,
    pub notEnabledTextHint: Option<String>,
    pub enabledTextHint: Option<String>,
    pub useSucceededTextHint: Option<String>,
    pub officialUseSucceededTextHint: Option<String>,
    pub seedModeLockedTextHint: Option<String>,
}
impl Default for clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataT {
    fn default() -> Self {
        Self {
            seedModeIntro: None,
            emptyTextHint: None,
            errorTextHint: None,
            legitimateTextHint: None,
            seedModeConfirmReplacement: None,
            difficultyLevelTextHint: None,
            lockedDifficultyLevelTextHint: None,
            setDifficultyLevelTextHint: None,
            notEnabledTextHint: None,
            enabledTextHint: None,
            useSucceededTextHint: None,
            officialUseSucceededTextHint: None,
            seedModeLockedTextHint: None,
        }
    }
}
impl clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData<'b>,
    > {
        let seedModeIntro = self.seedModeIntro.as_ref().map(|x| _fbb.create_string(x));
        let emptyTextHint = self.emptyTextHint.as_ref().map(|x| _fbb.create_string(x));
        let errorTextHint = self.errorTextHint.as_ref().map(|x| _fbb.create_string(x));
        let legitimateTextHint = self
            .legitimateTextHint
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let seedModeConfirmReplacement = self
            .seedModeConfirmReplacement
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let difficultyLevelTextHint = self
            .difficultyLevelTextHint
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let lockedDifficultyLevelTextHint = self
            .lockedDifficultyLevelTextHint
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let setDifficultyLevelTextHint = self
            .setDifficultyLevelTextHint
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let notEnabledTextHint = self
            .notEnabledTextHint
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let enabledTextHint = self.enabledTextHint.as_ref().map(|x| _fbb.create_string(x));
        let useSucceededTextHint = self
            .useSucceededTextHint
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let officialUseSucceededTextHint = self
            .officialUseSucceededTextHint
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let seedModeLockedTextHint = self
            .seedModeLockedTextHint
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData::create(
            _fbb,
            &clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataArgs {
                seedModeIntro,
                emptyTextHint,
                errorTextHint,
                legitimateTextHint,
                seedModeConfirmReplacement,
                difficultyLevelTextHint,
                lockedDifficultyLevelTextHint,
                setDifficultyLevelTextHint,
                notEnabledTextHint,
                enabledTextHint,
                useSucceededTextHint,
                officialUseSucceededTextHint,
                seedModeLockedTextHint,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeActivitySeedModeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeActivitySeedModeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeActivitySeedModeData<'a> {
    type Inner = clz_Torappu_RoguelikeActivitySeedModeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeActivitySeedModeData<'a> {
    pub const VT_OFFICIALSEEDDATALIST: flatbuffers::VOffsetT = 4;
    pub const VT_CONSTDATA: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeActivitySeedModeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeActivitySeedModeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivitySeedModeData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeActivitySeedModeDataBuilder::new(_fbb);
        if let Some(x) = args.constData {
            builder.add_constData(x);
        }
        if let Some(x) = args.officialSeedDataList {
            builder.add_officialSeedDataList(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeActivitySeedModeDataT {
        let officialSeedDataList = self
            .officialSeedDataList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let constData = self.constData().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeActivitySeedModeDataT {
            officialSeedDataList,
            constData,
        }
    }

    #[inline]
    pub fn officialSeedDataList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeActivitySeedModeData::VT_OFFICIALSEEDDATALIST,
                None,
            )
        }
    }
    #[inline]
    pub fn constData(
        &self,
    ) -> Option<clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData<'a>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData,
            >>(
                clz_Torappu_RoguelikeActivitySeedModeData::VT_CONSTDATA,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeActivitySeedModeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData,
                    >,
                >,
            >>("officialSeedDataList", Self::VT_OFFICIALSEEDDATALIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData,
            >>("constData", Self::VT_CONSTDATA, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeActivitySeedModeDataArgs<'a> {
    pub officialSeedDataList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData<'a>,
                >,
            >,
        >,
    >,
    pub constData: Option<
        flatbuffers::WIPOffset<
            clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData<'a>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeActivitySeedModeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeActivitySeedModeDataArgs {
            officialSeedDataList: None,
            constData: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeActivitySeedModeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeActivitySeedModeData", 2)?;
        if let Some(f) = self.officialSeedDataList() {
            s.serialize_field("officialSeedDataList", &f)?;
        } else {
            s.skip_field("officialSeedDataList")?;
        }
        if let Some(f) = self.constData() {
            s.serialize_field("constData", &f)?;
        } else {
            s.skip_field("constData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeActivitySeedModeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeActivitySeedModeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_officialSeedDataList(
        &mut self,
        officialSeedDataList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeActivitySeedModeData::VT_OFFICIALSEEDDATALIST,
            officialSeedDataList,
        );
    }
    #[inline]
    pub fn add_constData(
        &mut self,
        constData: flatbuffers::WIPOffset<
            clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<
            clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstData,
        >>(
            clz_Torappu_RoguelikeActivitySeedModeData::VT_CONSTDATA,
            constData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeActivitySeedModeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeActivitySeedModeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivitySeedModeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeActivitySeedModeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeActivitySeedModeData");
        ds.field("officialSeedDataList", &self.officialSeedDataList());
        ds.field("constData", &self.constData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeActivitySeedModeDataT {
    pub officialSeedDataList:
        Option<Vec<clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivityOfficialSeedDataT>>,
    pub constData:
        Option<Box<clz_Torappu_RoguelikeActivitySeedModeData_RoguelikeActivitySeedModeConstDataT>>,
}
impl Default for clz_Torappu_RoguelikeActivitySeedModeDataT {
    fn default() -> Self {
        Self {
            officialSeedDataList: None,
            constData: None,
        }
    }
}
impl clz_Torappu_RoguelikeActivitySeedModeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivitySeedModeData<'b>> {
        let officialSeedDataList = self.officialSeedDataList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let constData = self.constData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeActivitySeedModeData::create(
            _fbb,
            &clz_Torappu_RoguelikeActivitySeedModeDataArgs {
                officialSeedDataList,
                constData,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeActivitySeedModeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeActivitySeedModeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeActivitySeedModeData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeActivitySeedModeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeActivitySeedModeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeActivitySeedModeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeActivitySeedModeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeActivitySeedModeData<'bldr>>
    {
        let mut builder = dict__string__clz_Torappu_RoguelikeActivitySeedModeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeActivitySeedModeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeActivitySeedModeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeActivitySeedModeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeActivitySeedModeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeActivitySeedModeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeActivitySeedModeData>>(
                    dict__string__clz_Torappu_RoguelikeActivitySeedModeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeActivitySeedModeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeActivitySeedModeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeActivitySeedModeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivitySeedModeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeActivitySeedModeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeActivitySeedModeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeActivitySeedModeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeActivitySeedModeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeActivitySeedModeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeActivitySeedModeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeActivitySeedModeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivitySeedModeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivitySeedModeData>>(
                dict__string__clz_Torappu_RoguelikeActivitySeedModeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeActivitySeedModeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeActivitySeedModeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeActivitySeedModeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeActivitySeedModeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeActivitySeedModeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeActivitySeedModeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeActivitySeedModeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeActivitySeedModeDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeActivitySeedModeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeActivitySeedModeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeActivitySeedModeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeActivitySeedModeData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeActivitySeedModeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeActivityTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeActivityTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeActivityTable<'a> {
    type Inner = clz_Torappu_RoguelikeActivityTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeActivityTable<'a> {
    pub const VT_SEED_MODE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeActivityTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeActivityTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityTable<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeActivityTableBuilder::new(_fbb);
        if let Some(x) = args.SEED_MODE {
            builder.add_SEED_MODE(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeActivityTableT {
        let SEED_MODE = self
            .SEED_MODE()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeActivityTableT { SEED_MODE }
    }

    #[inline]
    pub fn SEED_MODE(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeActivitySeedModeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeActivitySeedModeData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeActivityTable::VT_SEED_MODE, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeActivityTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeActivitySeedModeData,
                    >,
                >,
            >>("SEED_MODE", Self::VT_SEED_MODE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeActivityTableArgs<'a> {
    pub SEED_MODE: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeActivitySeedModeData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeActivityTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeActivityTableArgs { SEED_MODE: None }
    }
}

impl Serialize for clz_Torappu_RoguelikeActivityTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeActivityTable", 1)?;
        if let Some(f) = self.SEED_MODE() {
            s.serialize_field("SEED_MODE", &f)?;
        } else {
            s.skip_field("SEED_MODE")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeActivityTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeActivityTableBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_SEED_MODE(
        &mut self,
        SEED_MODE: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeActivitySeedModeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeActivityTable::VT_SEED_MODE,
            SEED_MODE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeActivityTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeActivityTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeActivityTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeActivityTable");
        ds.field("SEED_MODE", &self.SEED_MODE());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeActivityTableT {
    pub SEED_MODE: Option<Vec<dict__string__clz_Torappu_RoguelikeActivitySeedModeDataT>>,
}
impl Default for clz_Torappu_RoguelikeActivityTableT {
    fn default() -> Self {
        Self { SEED_MODE: None }
    }
}
impl clz_Torappu_RoguelikeActivityTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityTable<'b>> {
        let SEED_MODE = self.SEED_MODE.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeActivityTable::create(
            _fbb,
            &clz_Torappu_RoguelikeActivityTableArgs { SEED_MODE },
        )
    }
}
pub enum clz_Torappu_RoguelikeActivityDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeActivityData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeActivityData<'a> {
    type Inner = clz_Torappu_RoguelikeActivityData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeActivityData<'a> {
    pub const VT_BASICDATAS: flatbuffers::VOffsetT = 4;
    pub const VT_ACTIVITYTABLE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeActivityData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeActivityDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeActivityDataBuilder::new(_fbb);
        if let Some(x) = args.activityTable {
            builder.add_activityTable(x);
        }
        if let Some(x) = args.basicDatas {
            builder.add_basicDatas(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeActivityDataT {
        let basicDatas = self
            .basicDatas()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let activityTable = self.activityTable().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeActivityDataT {
            basicDatas,
            activityTable,
        }
    }

    #[inline]
    pub fn basicDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeActivityBasicData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeActivityBasicData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeActivityData::VT_BASICDATAS, None)
        }
    }
    #[inline]
    pub fn activityTable(&self) -> Option<clz_Torappu_RoguelikeActivityTable<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeActivityTable>>(
                    clz_Torappu_RoguelikeActivityData::VT_ACTIVITYTABLE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeActivityData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeActivityBasicData,
                    >,
                >,
            >>("basicDatas", Self::VT_BASICDATAS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeActivityTable>>(
                "activityTable",
                Self::VT_ACTIVITYTABLE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeActivityDataArgs<'a> {
    pub basicDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeActivityBasicData<'a>,
                >,
            >,
        >,
    >,
    pub activityTable: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityTable<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeActivityDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeActivityDataArgs {
            basicDatas: None,
            activityTable: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeActivityData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeActivityData", 2)?;
        if let Some(f) = self.basicDatas() {
            s.serialize_field("basicDatas", &f)?;
        } else {
            s.skip_field("basicDatas")?;
        }
        if let Some(f) = self.activityTable() {
            s.serialize_field("activityTable", &f)?;
        } else {
            s.skip_field("activityTable")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeActivityDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeActivityDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_basicDatas(
        &mut self,
        basicDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeActivityBasicData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeActivityData::VT_BASICDATAS,
            basicDatas,
        );
    }
    #[inline]
    pub fn add_activityTable(
        &mut self,
        activityTable: flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityTable<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityTable>>(
                clz_Torappu_RoguelikeActivityData::VT_ACTIVITYTABLE,
                activityTable,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeActivityDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeActivityDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeActivityData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeActivityData");
        ds.field("basicDatas", &self.basicDatas());
        ds.field("activityTable", &self.activityTable());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeActivityDataT {
    pub basicDatas: Option<Vec<dict__string__clz_Torappu_RoguelikeActivityBasicDataT>>,
    pub activityTable: Option<Box<clz_Torappu_RoguelikeActivityTableT>>,
}
impl Default for clz_Torappu_RoguelikeActivityDataT {
    fn default() -> Self {
        Self {
            basicDatas: None,
            activityTable: None,
        }
    }
}
impl clz_Torappu_RoguelikeActivityDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityData<'b>> {
        let basicDatas = self.basicDatas.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let activityTable = self.activityTable.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeActivityData::create(
            _fbb,
            &clz_Torappu_RoguelikeActivityDataArgs {
                basicDatas,
                activityTable,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicDetailOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicDetail<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicDetail<'a> {
    type Inner = clz_Torappu_RoguelikeTopicDetail<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicDetail<'a> {
    pub const VT_UPDATES: flatbuffers::VOffsetT = 4;
    pub const VT_ENROLLS: flatbuffers::VOffsetT = 6;
    pub const VT_MILESTONES: flatbuffers::VOffsetT = 8;
    pub const VT_MILESTONEUPDATES: flatbuffers::VOffsetT = 10;
    pub const VT_GRANDPRIZES: flatbuffers::VOffsetT = 12;
    pub const VT_MONTHMISSION: flatbuffers::VOffsetT = 14;
    pub const VT_MONTHSQUAD: flatbuffers::VOffsetT = 16;
    pub const VT_CHALLENGES: flatbuffers::VOffsetT = 18;
    pub const VT_DIFFICULTIES: flatbuffers::VOffsetT = 20;
    pub const VT_BANKREWARDS: flatbuffers::VOffsetT = 22;
    pub const VT_ARCHIVECOMP: flatbuffers::VOffsetT = 24;
    pub const VT_ARCHIVEUNLOCKCOND: flatbuffers::VOffsetT = 26;
    pub const VT_DETAILCONST: flatbuffers::VOffsetT = 28;
    pub const VT_INIT: flatbuffers::VOffsetT = 30;
    pub const VT_STAGES: flatbuffers::VOffsetT = 32;
    pub const VT_ZONES: flatbuffers::VOffsetT = 34;
    pub const VT_VARIATION: flatbuffers::VOffsetT = 36;
    pub const VT_TRAPS: flatbuffers::VOffsetT = 38;
    pub const VT_RECRUITTICKETS: flatbuffers::VOffsetT = 40;
    pub const VT_UPGRADETICKETS: flatbuffers::VOffsetT = 42;
    pub const VT_CUSTOMTICKETS: flatbuffers::VOffsetT = 44;
    pub const VT_STASHABLETICKETS: flatbuffers::VOffsetT = 46;
    pub const VT_RELICS: flatbuffers::VOffsetT = 48;
    pub const VT_RELICPARAMS: flatbuffers::VOffsetT = 50;
    pub const VT_RECRUITGRPS: flatbuffers::VOffsetT = 52;
    pub const VT_CHOICES: flatbuffers::VOffsetT = 54;
    pub const VT_CHOICESCENES: flatbuffers::VOffsetT = 56;
    pub const VT_NODETYPEDATA: flatbuffers::VOffsetT = 58;
    pub const VT_SUBTYPEDATA: flatbuffers::VOffsetT = 60;
    pub const VT_VARIATIONDATA: flatbuffers::VOffsetT = 62;
    pub const VT_FUSIONDATA: flatbuffers::VOffsetT = 64;
    pub const VT_CHARBUFFDATA: flatbuffers::VOffsetT = 66;
    pub const VT_SQUADBUFFDATA: flatbuffers::VOffsetT = 68;
    pub const VT_TASKDATA: flatbuffers::VOffsetT = 70;
    pub const VT_GAMECONST: flatbuffers::VOffsetT = 72;
    pub const VT_SHOPDIALOGDATA: flatbuffers::VOffsetT = 74;
    pub const VT_CAPSULEDICT: flatbuffers::VOffsetT = 76;
    pub const VT_ENDINGS: flatbuffers::VOffsetT = 78;
    pub const VT_FAILENDINGS: flatbuffers::VOffsetT = 80;
    pub const VT_BATTLESUMMERYDESCRIPTIONS: flatbuffers::VOffsetT = 82;
    pub const VT_BATTLELOADINGTIPS: flatbuffers::VOffsetT = 84;
    pub const VT_ITEMS: flatbuffers::VOffsetT = 86;
    pub const VT_BANDREF: flatbuffers::VOffsetT = 88;
    pub const VT_ENDINGDETAILLIST: flatbuffers::VOffsetT = 90;
    pub const VT_ENDINGRELICDETAILLIST: flatbuffers::VOffsetT = 92;
    pub const VT_TREASURES: flatbuffers::VOffsetT = 94;
    pub const VT_DIFFICULTYUPGRADERELICGROUPS: flatbuffers::VOffsetT = 96;
    pub const VT_STYLES: flatbuffers::VOffsetT = 98;
    pub const VT_STYLECONFIG: flatbuffers::VOffsetT = 100;
    pub const VT_EXPLORETOOLS: flatbuffers::VOffsetT = 102;
    pub const VT_ROLLNODEDATA: flatbuffers::VOffsetT = 104;
    pub const VT_ACTIVITY: flatbuffers::VOffsetT = 106;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicDetail { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicDetailArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetail<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicDetailBuilder::new(_fbb);
        if let Some(x) = args.activity {
            builder.add_activity(x);
        }
        if let Some(x) = args.rollNodeData {
            builder.add_rollNodeData(x);
        }
        if let Some(x) = args.exploreTools {
            builder.add_exploreTools(x);
        }
        if let Some(x) = args.styleConfig {
            builder.add_styleConfig(x);
        }
        if let Some(x) = args.styles {
            builder.add_styles(x);
        }
        if let Some(x) = args.difficultyUpgradeRelicGroups {
            builder.add_difficultyUpgradeRelicGroups(x);
        }
        if let Some(x) = args.treasures {
            builder.add_treasures(x);
        }
        if let Some(x) = args.endingRelicDetailList {
            builder.add_endingRelicDetailList(x);
        }
        if let Some(x) = args.endingDetailList {
            builder.add_endingDetailList(x);
        }
        if let Some(x) = args.bandRef {
            builder.add_bandRef(x);
        }
        if let Some(x) = args.items {
            builder.add_items(x);
        }
        if let Some(x) = args.battleLoadingTips {
            builder.add_battleLoadingTips(x);
        }
        if let Some(x) = args.battleSummeryDescriptions {
            builder.add_battleSummeryDescriptions(x);
        }
        if let Some(x) = args.failEndings {
            builder.add_failEndings(x);
        }
        if let Some(x) = args.endings {
            builder.add_endings(x);
        }
        if let Some(x) = args.capsuleDict {
            builder.add_capsuleDict(x);
        }
        if let Some(x) = args.shopDialogData {
            builder.add_shopDialogData(x);
        }
        if let Some(x) = args.gameConst {
            builder.add_gameConst(x);
        }
        if let Some(x) = args.taskData {
            builder.add_taskData(x);
        }
        if let Some(x) = args.squadBuffData {
            builder.add_squadBuffData(x);
        }
        if let Some(x) = args.charBuffData {
            builder.add_charBuffData(x);
        }
        if let Some(x) = args.fusionData {
            builder.add_fusionData(x);
        }
        if let Some(x) = args.variationData {
            builder.add_variationData(x);
        }
        if let Some(x) = args.subTypeData {
            builder.add_subTypeData(x);
        }
        if let Some(x) = args.nodeTypeData {
            builder.add_nodeTypeData(x);
        }
        if let Some(x) = args.choiceScenes {
            builder.add_choiceScenes(x);
        }
        if let Some(x) = args.choices {
            builder.add_choices(x);
        }
        if let Some(x) = args.recruitGrps {
            builder.add_recruitGrps(x);
        }
        if let Some(x) = args.relicParams {
            builder.add_relicParams(x);
        }
        if let Some(x) = args.relics {
            builder.add_relics(x);
        }
        if let Some(x) = args.stashableTickets {
            builder.add_stashableTickets(x);
        }
        if let Some(x) = args.customTickets {
            builder.add_customTickets(x);
        }
        if let Some(x) = args.upgradeTickets {
            builder.add_upgradeTickets(x);
        }
        if let Some(x) = args.recruitTickets {
            builder.add_recruitTickets(x);
        }
        if let Some(x) = args.traps {
            builder.add_traps(x);
        }
        if let Some(x) = args.variation {
            builder.add_variation(x);
        }
        if let Some(x) = args.zones {
            builder.add_zones(x);
        }
        if let Some(x) = args.stages {
            builder.add_stages(x);
        }
        if let Some(x) = args.init {
            builder.add_init(x);
        }
        if let Some(x) = args.detailConst {
            builder.add_detailConst(x);
        }
        if let Some(x) = args.archiveUnlockCond {
            builder.add_archiveUnlockCond(x);
        }
        if let Some(x) = args.archiveComp {
            builder.add_archiveComp(x);
        }
        if let Some(x) = args.bankRewards {
            builder.add_bankRewards(x);
        }
        if let Some(x) = args.difficulties {
            builder.add_difficulties(x);
        }
        if let Some(x) = args.challenges {
            builder.add_challenges(x);
        }
        if let Some(x) = args.monthSquad {
            builder.add_monthSquad(x);
        }
        if let Some(x) = args.monthMission {
            builder.add_monthMission(x);
        }
        if let Some(x) = args.grandPrizes {
            builder.add_grandPrizes(x);
        }
        if let Some(x) = args.milestoneUpdates {
            builder.add_milestoneUpdates(x);
        }
        if let Some(x) = args.milestones {
            builder.add_milestones(x);
        }
        if let Some(x) = args.enrolls {
            builder.add_enrolls(x);
        }
        if let Some(x) = args.updates {
            builder.add_updates(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicDetailT {
        let updates = self
            .updates()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let enrolls = self
            .enrolls()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let milestones = self
            .milestones()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let milestoneUpdates = self
            .milestoneUpdates()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let grandPrizes = self
            .grandPrizes()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let monthMission = self
            .monthMission()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let monthSquad = self
            .monthSquad()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let challenges = self
            .challenges()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let difficulties = self
            .difficulties()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let bankRewards = self
            .bankRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let archiveComp = self.archiveComp().map(|x| Box::new(x.unpack()));
        let archiveUnlockCond = self.archiveUnlockCond().map(|x| Box::new(x.unpack()));
        let detailConst = self.detailConst().map(|x| Box::new(x.unpack()));
        let init = self.init().map(|x| x.iter().map(|t| t.unpack()).collect());
        let stages = self
            .stages()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let zones = self.zones().map(|x| x.iter().map(|t| t.unpack()).collect());
        let variation = self
            .variation()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let traps = self.traps().map(|x| x.iter().map(|t| t.unpack()).collect());
        let recruitTickets = self
            .recruitTickets()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let upgradeTickets = self
            .upgradeTickets()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let customTickets = self
            .customTickets()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let stashableTickets = self
            .stashableTickets()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let relics = self
            .relics()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let relicParams = self
            .relicParams()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let recruitGrps = self
            .recruitGrps()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let choices = self
            .choices()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let choiceScenes = self
            .choiceScenes()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let nodeTypeData = self
            .nodeTypeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let subTypeData = self
            .subTypeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let variationData = self
            .variationData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let fusionData = self
            .fusionData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let charBuffData = self
            .charBuffData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let squadBuffData = self
            .squadBuffData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let taskData = self
            .taskData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let gameConst = self.gameConst().map(|x| Box::new(x.unpack()));
        let shopDialogData = self.shopDialogData().map(|x| Box::new(x.unpack()));
        let capsuleDict = self
            .capsuleDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let endings = self
            .endings()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let failEndings = self
            .failEndings()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let battleSummeryDescriptions = self
            .battleSummeryDescriptions()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let battleLoadingTips = self
            .battleLoadingTips()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let items = self.items().map(|x| x.iter().map(|t| t.unpack()).collect());
        let bandRef = self
            .bandRef()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let endingDetailList = self
            .endingDetailList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let endingRelicDetailList = self
            .endingRelicDetailList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let treasures = self
            .treasures()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let difficultyUpgradeRelicGroups = self
            .difficultyUpgradeRelicGroups()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let styles = self
            .styles()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let styleConfig = self.styleConfig().map(|x| Box::new(x.unpack()));
        let exploreTools = self
            .exploreTools()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let rollNodeData = self
            .rollNodeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let activity = self.activity().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeTopicDetailT {
            updates,
            enrolls,
            milestones,
            milestoneUpdates,
            grandPrizes,
            monthMission,
            monthSquad,
            challenges,
            difficulties,
            bankRewards,
            archiveComp,
            archiveUnlockCond,
            detailConst,
            init,
            stages,
            zones,
            variation,
            traps,
            recruitTickets,
            upgradeTickets,
            customTickets,
            stashableTickets,
            relics,
            relicParams,
            recruitGrps,
            choices,
            choiceScenes,
            nodeTypeData,
            subTypeData,
            variationData,
            fusionData,
            charBuffData,
            squadBuffData,
            taskData,
            gameConst,
            shopDialogData,
            capsuleDict,
            endings,
            failEndings,
            battleSummeryDescriptions,
            battleLoadingTips,
            items,
            bandRef,
            endingDetailList,
            endingRelicDetailList,
            treasures,
            difficultyUpgradeRelicGroups,
            styles,
            styleConfig,
            exploreTools,
            rollNodeData,
            activity,
        }
    }

    #[inline]
    pub fn updates(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicUpdate<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicUpdate>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_UPDATES, None)
        }
    }
    #[inline]
    pub fn enrolls(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicEnroll<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicEnroll>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_ENROLLS, None)
        }
    }
    #[inline]
    pub fn milestones(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBP<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBP>>,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_MILESTONES, None)
        }
    }
    #[inline]
    pub fn milestoneUpdates(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMilestoneUpdateData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMilestoneUpdateData>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_MILESTONEUPDATES, None)
        }
    }
    #[inline]
    pub fn grandPrizes(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBPGrandPrize<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBPGrandPrize>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_GRANDPRIZES, None)
        }
    }
    #[inline]
    pub fn monthMission(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMonthMission<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMonthMission>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_MONTHMISSION, None)
        }
    }
    #[inline]
    pub fn monthSquad(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicMonthSquad<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeTopicMonthSquad,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_MONTHSQUAD, None)
        }
    }
    #[inline]
    pub fn challenges(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicChallenge<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicChallenge>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_CHALLENGES, None)
        }
    }
    #[inline]
    pub fn difficulties(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDifficulty<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDifficulty>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_DIFFICULTIES, None)
        }
    }
    #[inline]
    pub fn bankRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBankReward<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBankReward>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_BANKREWARDS, None)
        }
    }
    #[inline]
    pub fn archiveComp(&self) -> Option<clz_Torappu_RoguelikeArchiveComponentData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeArchiveComponentData>>(
                    clz_Torappu_RoguelikeTopicDetail::VT_ARCHIVECOMP,
                    None,
                )
        }
    }
    #[inline]
    pub fn archiveUnlockCond(&self) -> Option<clz_Torappu_RoguelikeArchiveUnlockCondData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeArchiveUnlockCondData>>(
                    clz_Torappu_RoguelikeTopicDetail::VT_ARCHIVEUNLOCKCOND,
                    None,
                )
        }
    }
    #[inline]
    pub fn detailConst(&self) -> Option<clz_Torappu_RoguelikeTopicDetailConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDetailConst>>(
                    clz_Torappu_RoguelikeTopicDetail::VT_DETAILCONST,
                    None,
                )
        }
    }
    #[inline]
    pub fn init(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameInitData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameInitData>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_INIT, None)
        }
    }
    #[inline]
    pub fn stages(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameStageData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameStageData>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_STAGES, None)
        }
    }
    #[inline]
    pub fn zones(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameZoneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameZoneData>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_ZONES, None)
        }
    }
    #[inline]
    pub fn variation(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeZoneVariationData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeZoneVariationData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_VARIATION, None)
        }
    }
    #[inline]
    pub fn traps(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameTrapData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameTrapData>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_TRAPS, None)
        }
    }
    #[inline]
    pub fn recruitTickets(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeGameRecruitTicketData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameRecruitTicketData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_RECRUITTICKETS, None)
        }
    }
    #[inline]
    pub fn upgradeTickets(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_UPGRADETICKETS, None)
        }
    }
    #[inline]
    pub fn customTickets(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeGameCustomTicketData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameCustomTicketData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_CUSTOMTICKETS, None)
        }
    }
    #[inline]
    pub fn stashableTickets(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeGameStashableTicketData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameStashableTicketData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_STASHABLETICKETS, None)
        }
    }
    #[inline]
    pub fn relics(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameRelicData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameRelicData>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_RELICS, None)
        }
    }
    #[inline]
    pub fn relicParams(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameRelicParamData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameRelicParamData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_RELICPARAMS, None)
        }
    }
    #[inline]
    pub fn recruitGrps(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameRecruitGrpData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameRecruitGrpData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_RECRUITGRPS, None)
        }
    }
    #[inline]
    pub fn choices(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameChoiceData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameChoiceData>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_CHOICES, None)
        }
    }
    #[inline]
    pub fn choiceScenes(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeGameChoiceSceneData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameChoiceSceneData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_CHOICESCENES, None)
        }
    }
    #[inline]
    pub fn nodeTypeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData>>>>(clz_Torappu_RoguelikeTopicDetail::VT_NODETYPEDATA, None)
        }
    }
    #[inline]
    pub fn subTypeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameNodeSubTypeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameNodeSubTypeData>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_SUBTYPEDATA, None)
        }
    }
    #[inline]
    pub fn variationData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameVariationData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameVariationData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_VARIATIONDATA, None)
        }
    }
    #[inline]
    pub fn fusionData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameFusionData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameFusionData>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_FUSIONDATA, None)
        }
    }
    #[inline]
    pub fn charBuffData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameCharBuffData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameCharBuffData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_CHARBUFFDATA, None)
        }
    }
    #[inline]
    pub fn squadBuffData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameSquadBuffData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameSquadBuffData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_SQUADBUFFDATA, None)
        }
    }
    #[inline]
    pub fn taskData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTaskData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTaskData>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_TASKDATA, None)
        }
    }
    #[inline]
    pub fn gameConst(&self) -> Option<clz_Torappu_RoguelikeGameConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameConst>>(
                    clz_Torappu_RoguelikeTopicDetail::VT_GAMECONST,
                    None,
                )
        }
    }
    #[inline]
    pub fn shopDialogData(&self) -> Option<clz_Torappu_RoguelikeGameShopDialogData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameShopDialogData>>(
                    clz_Torappu_RoguelikeTopicDetail::VT_SHOPDIALOGDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn capsuleDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicCapsule<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicCapsule>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_CAPSULEDICT, None)
        }
    }
    #[inline]
    pub fn endings(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameEndingData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameEndingData>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_ENDINGS, None)
        }
    }
    #[inline]
    pub fn failEndings(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameFailEndingData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameFailEndingData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_FAILENDINGS, None)
        }
    }
    #[inline]
    pub fn battleSummeryDescriptions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData<'a>>>>{
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData>>>>(clz_Torappu_RoguelikeTopicDetail::VT_BATTLESUMMERYDESCRIPTIONS, None)
        }
    }
    #[inline]
    pub fn battleLoadingTips(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData>>,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_BATTLELOADINGTIPS, None)
        }
    }
    #[inline]
    pub fn items(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameItemData>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_ITEMS, None)
        }
    }
    #[inline]
    pub fn bandRef(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeBandRefData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeBandRefData>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_BANDREF, None)
        }
    }
    #[inline]
    pub fn endingDetailList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeEndingDetailText<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeEndingDetailText>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_ENDINGDETAILLIST, None)
        }
    }
    #[inline]
    pub fn endingRelicDetailList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeEndingRelicDetailText<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeEndingRelicDetailText>,
                >,
            >>(
                clz_Torappu_RoguelikeTopicDetail::VT_ENDINGRELICDETAILLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn treasures(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__list_clz_Torappu_RoguelikeGameTreasureData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_clz_Torappu_RoguelikeGameTreasureData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_TREASURES, None)
        }
    }
    #[inline]
    pub fn difficultyUpgradeRelicGroups(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeTopicDetail::VT_DIFFICULTYUPGRADERELICGROUPS,
                None,
            )
        }
    }
    #[inline]
    pub fn styles(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikePredefinedStyleData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikePredefinedStyleData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_STYLES, None)
        }
    }
    #[inline]
    pub fn styleConfig(&self) -> Option<clz_Torappu_RoguelikePredefinedConstStyleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikePredefinedConstStyleData>>(
                    clz_Torappu_RoguelikeTopicDetail::VT_STYLECONFIG,
                    None,
                )
        }
    }
    #[inline]
    pub fn exploreTools(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeGameExploreToolData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeGameExploreToolData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_EXPLORETOOLS, None)
        }
    }
    #[inline]
    pub fn rollNodeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeRollNodeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeRollNodeData>,
                >,
            >>(clz_Torappu_RoguelikeTopicDetail::VT_ROLLNODEDATA, None)
        }
    }
    #[inline]
    pub fn activity(&self) -> Option<clz_Torappu_RoguelikeActivityData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeActivityData>>(
                    clz_Torappu_RoguelikeTopicDetail::VT_ACTIVITY,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicDetail<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicUpdate>>>>("updates", Self::VT_UPDATES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicEnroll>>>>("enrolls", Self::VT_ENROLLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBP>>>>("milestones", Self::VT_MILESTONES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMilestoneUpdateData>>>>("milestoneUpdates", Self::VT_MILESTONEUPDATES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBPGrandPrize>>>>("grandPrizes", Self::VT_GRANDPRIZES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMonthMission>>>>("monthMission", Self::VT_MONTHMISSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicMonthSquad>>>>("monthSquad", Self::VT_MONTHSQUAD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicChallenge>>>>("challenges", Self::VT_CHALLENGES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDifficulty>>>>("difficulties", Self::VT_DIFFICULTIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBankReward>>>>("bankRewards", Self::VT_BANKREWARDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeArchiveComponentData>>("archiveComp", Self::VT_ARCHIVECOMP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeArchiveUnlockCondData>>("archiveUnlockCond", Self::VT_ARCHIVEUNLOCKCOND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDetailConst>>("detailConst", Self::VT_DETAILCONST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameInitData>>>>("init", Self::VT_INIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameStageData>>>>("stages", Self::VT_STAGES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameZoneData>>>>("zones", Self::VT_ZONES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeZoneVariationData>>>>("variation", Self::VT_VARIATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameTrapData>>>>("traps", Self::VT_TRAPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameRecruitTicketData>>>>("recruitTickets", Self::VT_RECRUITTICKETS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData>>>>("upgradeTickets", Self::VT_UPGRADETICKETS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameCustomTicketData>>>>("customTickets", Self::VT_CUSTOMTICKETS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameStashableTicketData>>>>("stashableTickets", Self::VT_STASHABLETICKETS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameRelicData>>>>("relics", Self::VT_RELICS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameRelicParamData>>>>("relicParams", Self::VT_RELICPARAMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameRecruitGrpData>>>>("recruitGrps", Self::VT_RECRUITGRPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameChoiceData>>>>("choices", Self::VT_CHOICES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameChoiceSceneData>>>>("choiceScenes", Self::VT_CHOICESCENES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData>>>>("nodeTypeData", Self::VT_NODETYPEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameNodeSubTypeData>>>>("subTypeData", Self::VT_SUBTYPEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameVariationData>>>>("variationData", Self::VT_VARIATIONDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameFusionData>>>>("fusionData", Self::VT_FUSIONDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameCharBuffData>>>>("charBuffData", Self::VT_CHARBUFFDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameSquadBuffData>>>>("squadBuffData", Self::VT_SQUADBUFFDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTaskData>>>>("taskData", Self::VT_TASKDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameConst>>("gameConst", Self::VT_GAMECONST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameShopDialogData>>("shopDialogData", Self::VT_SHOPDIALOGDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicCapsule>>>>("capsuleDict", Self::VT_CAPSULEDICT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameEndingData>>>>("endings", Self::VT_ENDINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameFailEndingData>>>>("failEndings", Self::VT_FAILENDINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData>>>>("battleSummeryDescriptions", Self::VT_BATTLESUMMERYDESCRIPTIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_TipData>>>>("battleLoadingTips", Self::VT_BATTLELOADINGTIPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameItemData>>>>("items", Self::VT_ITEMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeBandRefData>>>>("bandRef", Self::VT_BANDREF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeEndingDetailText>>>>("endingDetailList", Self::VT_ENDINGDETAILLIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeEndingRelicDetailText>>>>("endingRelicDetailList", Self::VT_ENDINGRELICDETAILLIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_RoguelikeGameTreasureData>>>>("treasures", Self::VT_TREASURES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData>>>>("difficultyUpgradeRelicGroups", Self::VT_DIFFICULTYUPGRADERELICGROUPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikePredefinedStyleData>>>>("styles", Self::VT_STYLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikePredefinedConstStyleData>>("styleConfig", Self::VT_STYLECONFIG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameExploreToolData>>>>("exploreTools", Self::VT_EXPLORETOOLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeRollNodeData>>>>("rollNodeData", Self::VT_ROLLNODEDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeActivityData>>("activity", Self::VT_ACTIVITY, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicDetailArgs<'a> {
    pub updates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicUpdate<'a>>>>>,
    pub enrolls: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicEnroll<'a>>>>>,
    pub milestones: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBP<'a>>>>>,
    pub milestoneUpdates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMilestoneUpdateData<'a>>>>>,
    pub grandPrizes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBPGrandPrize<'a>>>>>,
    pub monthMission: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMonthMission<'a>>>>>,
    pub monthSquad: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicMonthSquad<'a>>>>>,
    pub challenges: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicChallenge<'a>>>>>,
    pub difficulties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDifficulty<'a>>>>>,
    pub bankRewards: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBankReward<'a>>>>>,
    pub archiveComp: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveComponentData<'a>>>,
    pub archiveUnlockCond: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveUnlockCondData<'a>>>,
    pub detailConst: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst<'a>>>,
    pub init: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameInitData<'a>>>>>,
    pub stages: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameStageData<'a>>>>>,
    pub zones: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameZoneData<'a>>>>>,
    pub variation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeZoneVariationData<'a>>>>>,
    pub traps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameTrapData<'a>>>>>,
    pub recruitTickets: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameRecruitTicketData<'a>>>>>,
    pub upgradeTickets: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData<'a>>>>>,
    pub customTickets: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameCustomTicketData<'a>>>>>,
    pub stashableTickets: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameStashableTicketData<'a>>>>>,
    pub relics: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameRelicData<'a>>>>>,
    pub relicParams: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameRelicParamData<'a>>>>>,
    pub recruitGrps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameRecruitGrpData<'a>>>>>,
    pub choices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameChoiceData<'a>>>>>,
    pub choiceScenes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameChoiceSceneData<'a>>>>>,
    pub nodeTypeData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData<'a>>>>>,
    pub subTypeData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameNodeSubTypeData<'a>>>>>,
    pub variationData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameVariationData<'a>>>>>,
    pub fusionData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameFusionData<'a>>>>>,
    pub charBuffData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameCharBuffData<'a>>>>>,
    pub squadBuffData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameSquadBuffData<'a>>>>>,
    pub taskData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTaskData<'a>>>>>,
    pub gameConst: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameConst<'a>>>,
    pub shopDialogData: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogData<'a>>>,
    pub capsuleDict: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicCapsule<'a>>>>>,
    pub endings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameEndingData<'a>>>>>,
    pub failEndings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameFailEndingData<'a>>>>>,
    pub battleSummeryDescriptions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData<'a>>>>>,
    pub battleLoadingTips: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'a>>>>>,
    pub items: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameItemData<'a>>>>>,
    pub bandRef: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeBandRefData<'a>>>>>,
    pub endingDetailList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeEndingDetailText<'a>>>>>,
    pub endingRelicDetailList: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeEndingRelicDetailText<'a>>>>>,
    pub treasures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_RoguelikeGameTreasureData<'a>>>>>,
    pub difficultyUpgradeRelicGroups: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'a>>>>>,
    pub styles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikePredefinedStyleData<'a>>>>>,
    pub styleConfig: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedConstStyleData<'a>>>,
    pub exploreTools: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameExploreToolData<'a>>>>>,
    pub rollNodeData: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeRollNodeData<'a>>>>>,
    pub activity: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityData<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicDetailArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicDetailArgs {
            updates: None,
            enrolls: None,
            milestones: None,
            milestoneUpdates: None,
            grandPrizes: None,
            monthMission: None,
            monthSquad: None,
            challenges: None,
            difficulties: None,
            bankRewards: None,
            archiveComp: None,
            archiveUnlockCond: None,
            detailConst: None,
            init: None,
            stages: None,
            zones: None,
            variation: None,
            traps: None,
            recruitTickets: None,
            upgradeTickets: None,
            customTickets: None,
            stashableTickets: None,
            relics: None,
            relicParams: None,
            recruitGrps: None,
            choices: None,
            choiceScenes: None,
            nodeTypeData: None,
            subTypeData: None,
            variationData: None,
            fusionData: None,
            charBuffData: None,
            squadBuffData: None,
            taskData: None,
            gameConst: None,
            shopDialogData: None,
            capsuleDict: None,
            endings: None,
            failEndings: None,
            battleSummeryDescriptions: None,
            battleLoadingTips: None,
            items: None,
            bandRef: None,
            endingDetailList: None,
            endingRelicDetailList: None,
            treasures: None,
            difficultyUpgradeRelicGroups: None,
            styles: None,
            styleConfig: None,
            exploreTools: None,
            rollNodeData: None,
            activity: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicDetail<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicDetail", 52)?;
        if let Some(f) = self.updates() {
            s.serialize_field("updates", &f)?;
        } else {
            s.skip_field("updates")?;
        }
        if let Some(f) = self.enrolls() {
            s.serialize_field("enrolls", &f)?;
        } else {
            s.skip_field("enrolls")?;
        }
        if let Some(f) = self.milestones() {
            s.serialize_field("milestones", &f)?;
        } else {
            s.skip_field("milestones")?;
        }
        if let Some(f) = self.milestoneUpdates() {
            s.serialize_field("milestoneUpdates", &f)?;
        } else {
            s.skip_field("milestoneUpdates")?;
        }
        if let Some(f) = self.grandPrizes() {
            s.serialize_field("grandPrizes", &f)?;
        } else {
            s.skip_field("grandPrizes")?;
        }
        if let Some(f) = self.monthMission() {
            s.serialize_field("monthMission", &f)?;
        } else {
            s.skip_field("monthMission")?;
        }
        if let Some(f) = self.monthSquad() {
            s.serialize_field("monthSquad", &f)?;
        } else {
            s.skip_field("monthSquad")?;
        }
        if let Some(f) = self.challenges() {
            s.serialize_field("challenges", &f)?;
        } else {
            s.skip_field("challenges")?;
        }
        if let Some(f) = self.difficulties() {
            s.serialize_field("difficulties", &f)?;
        } else {
            s.skip_field("difficulties")?;
        }
        if let Some(f) = self.bankRewards() {
            s.serialize_field("bankRewards", &f)?;
        } else {
            s.skip_field("bankRewards")?;
        }
        if let Some(f) = self.archiveComp() {
            s.serialize_field("archiveComp", &f)?;
        } else {
            s.skip_field("archiveComp")?;
        }
        if let Some(f) = self.archiveUnlockCond() {
            s.serialize_field("archiveUnlockCond", &f)?;
        } else {
            s.skip_field("archiveUnlockCond")?;
        }
        if let Some(f) = self.detailConst() {
            s.serialize_field("detailConst", &f)?;
        } else {
            s.skip_field("detailConst")?;
        }
        if let Some(f) = self.init() {
            s.serialize_field("init", &f)?;
        } else {
            s.skip_field("init")?;
        }
        if let Some(f) = self.stages() {
            s.serialize_field("stages", &f)?;
        } else {
            s.skip_field("stages")?;
        }
        if let Some(f) = self.zones() {
            s.serialize_field("zones", &f)?;
        } else {
            s.skip_field("zones")?;
        }
        if let Some(f) = self.variation() {
            s.serialize_field("variation", &f)?;
        } else {
            s.skip_field("variation")?;
        }
        if let Some(f) = self.traps() {
            s.serialize_field("traps", &f)?;
        } else {
            s.skip_field("traps")?;
        }
        if let Some(f) = self.recruitTickets() {
            s.serialize_field("recruitTickets", &f)?;
        } else {
            s.skip_field("recruitTickets")?;
        }
        if let Some(f) = self.upgradeTickets() {
            s.serialize_field("upgradeTickets", &f)?;
        } else {
            s.skip_field("upgradeTickets")?;
        }
        if let Some(f) = self.customTickets() {
            s.serialize_field("customTickets", &f)?;
        } else {
            s.skip_field("customTickets")?;
        }
        if let Some(f) = self.stashableTickets() {
            s.serialize_field("stashableTickets", &f)?;
        } else {
            s.skip_field("stashableTickets")?;
        }
        if let Some(f) = self.relics() {
            s.serialize_field("relics", &f)?;
        } else {
            s.skip_field("relics")?;
        }
        if let Some(f) = self.relicParams() {
            s.serialize_field("relicParams", &f)?;
        } else {
            s.skip_field("relicParams")?;
        }
        if let Some(f) = self.recruitGrps() {
            s.serialize_field("recruitGrps", &f)?;
        } else {
            s.skip_field("recruitGrps")?;
        }
        if let Some(f) = self.choices() {
            s.serialize_field("choices", &f)?;
        } else {
            s.skip_field("choices")?;
        }
        if let Some(f) = self.choiceScenes() {
            s.serialize_field("choiceScenes", &f)?;
        } else {
            s.skip_field("choiceScenes")?;
        }
        if let Some(f) = self.nodeTypeData() {
            s.serialize_field("nodeTypeData", &f)?;
        } else {
            s.skip_field("nodeTypeData")?;
        }
        if let Some(f) = self.subTypeData() {
            s.serialize_field("subTypeData", &f)?;
        } else {
            s.skip_field("subTypeData")?;
        }
        if let Some(f) = self.variationData() {
            s.serialize_field("variationData", &f)?;
        } else {
            s.skip_field("variationData")?;
        }
        if let Some(f) = self.fusionData() {
            s.serialize_field("fusionData", &f)?;
        } else {
            s.skip_field("fusionData")?;
        }
        if let Some(f) = self.charBuffData() {
            s.serialize_field("charBuffData", &f)?;
        } else {
            s.skip_field("charBuffData")?;
        }
        if let Some(f) = self.squadBuffData() {
            s.serialize_field("squadBuffData", &f)?;
        } else {
            s.skip_field("squadBuffData")?;
        }
        if let Some(f) = self.taskData() {
            s.serialize_field("taskData", &f)?;
        } else {
            s.skip_field("taskData")?;
        }
        if let Some(f) = self.gameConst() {
            s.serialize_field("gameConst", &f)?;
        } else {
            s.skip_field("gameConst")?;
        }
        if let Some(f) = self.shopDialogData() {
            s.serialize_field("shopDialogData", &f)?;
        } else {
            s.skip_field("shopDialogData")?;
        }
        if let Some(f) = self.capsuleDict() {
            s.serialize_field("capsuleDict", &f)?;
        } else {
            s.skip_field("capsuleDict")?;
        }
        if let Some(f) = self.endings() {
            s.serialize_field("endings", &f)?;
        } else {
            s.skip_field("endings")?;
        }
        if let Some(f) = self.failEndings() {
            s.serialize_field("failEndings", &f)?;
        } else {
            s.skip_field("failEndings")?;
        }
        if let Some(f) = self.battleSummeryDescriptions() {
            s.serialize_field("battleSummeryDescriptions", &f)?;
        } else {
            s.skip_field("battleSummeryDescriptions")?;
        }
        if let Some(f) = self.battleLoadingTips() {
            s.serialize_field("battleLoadingTips", &f)?;
        } else {
            s.skip_field("battleLoadingTips")?;
        }
        if let Some(f) = self.items() {
            s.serialize_field("items", &f)?;
        } else {
            s.skip_field("items")?;
        }
        if let Some(f) = self.bandRef() {
            s.serialize_field("bandRef", &f)?;
        } else {
            s.skip_field("bandRef")?;
        }
        if let Some(f) = self.endingDetailList() {
            s.serialize_field("endingDetailList", &f)?;
        } else {
            s.skip_field("endingDetailList")?;
        }
        if let Some(f) = self.endingRelicDetailList() {
            s.serialize_field("endingRelicDetailList", &f)?;
        } else {
            s.skip_field("endingRelicDetailList")?;
        }
        if let Some(f) = self.treasures() {
            s.serialize_field("treasures", &f)?;
        } else {
            s.skip_field("treasures")?;
        }
        if let Some(f) = self.difficultyUpgradeRelicGroups() {
            s.serialize_field("difficultyUpgradeRelicGroups", &f)?;
        } else {
            s.skip_field("difficultyUpgradeRelicGroups")?;
        }
        if let Some(f) = self.styles() {
            s.serialize_field("styles", &f)?;
        } else {
            s.skip_field("styles")?;
        }
        if let Some(f) = self.styleConfig() {
            s.serialize_field("styleConfig", &f)?;
        } else {
            s.skip_field("styleConfig")?;
        }
        if let Some(f) = self.exploreTools() {
            s.serialize_field("exploreTools", &f)?;
        } else {
            s.skip_field("exploreTools")?;
        }
        if let Some(f) = self.rollNodeData() {
            s.serialize_field("rollNodeData", &f)?;
        } else {
            s.skip_field("rollNodeData")?;
        }
        if let Some(f) = self.activity() {
            s.serialize_field("activity", &f)?;
        } else {
            s.skip_field("activity")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicDetailBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicDetailBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_updates(
        &mut self,
        updates: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicUpdate<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_UPDATES,
            updates,
        );
    }
    #[inline]
    pub fn add_enrolls(
        &mut self,
        enrolls: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicEnroll<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_ENROLLS,
            enrolls,
        );
    }
    #[inline]
    pub fn add_milestones(
        &mut self,
        milestones: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBP<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_MILESTONES,
            milestones,
        );
    }
    #[inline]
    pub fn add_milestoneUpdates(
        &mut self,
        milestoneUpdates: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMilestoneUpdateData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_MILESTONEUPDATES,
            milestoneUpdates,
        );
    }
    #[inline]
    pub fn add_grandPrizes(
        &mut self,
        grandPrizes: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBPGrandPrize<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_GRANDPRIZES,
            grandPrizes,
        );
    }
    #[inline]
    pub fn add_monthMission(
        &mut self,
        monthMission: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicMonthMission<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_MONTHMISSION,
            monthMission,
        );
    }
    #[inline]
    pub fn add_monthSquad(
        &mut self,
        monthSquad: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeTopicMonthSquad<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_MONTHSQUAD,
            monthSquad,
        );
    }
    #[inline]
    pub fn add_challenges(
        &mut self,
        challenges: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicChallenge<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_CHALLENGES,
            challenges,
        );
    }
    #[inline]
    pub fn add_difficulties(
        &mut self,
        difficulties: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDifficulty<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_DIFFICULTIES,
            difficulties,
        );
    }
    #[inline]
    pub fn add_bankRewards(
        &mut self,
        bankRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicBankReward<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_BANKREWARDS,
            bankRewards,
        );
    }
    #[inline]
    pub fn add_archiveComp(
        &mut self,
        archiveComp: flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveComponentData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveComponentData>>(
                clz_Torappu_RoguelikeTopicDetail::VT_ARCHIVECOMP,
                archiveComp,
            );
    }
    #[inline]
    pub fn add_archiveUnlockCond(
        &mut self,
        archiveUnlockCond: flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveUnlockCondData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeArchiveUnlockCondData>>(
                clz_Torappu_RoguelikeTopicDetail::VT_ARCHIVEUNLOCKCOND,
                archiveUnlockCond,
            );
    }
    #[inline]
    pub fn add_detailConst(
        &mut self,
        detailConst: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetailConst>>(
                clz_Torappu_RoguelikeTopicDetail::VT_DETAILCONST,
                detailConst,
            );
    }
    #[inline]
    pub fn add_init(
        &mut self,
        init: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameInitData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_INIT,
            init,
        );
    }
    #[inline]
    pub fn add_stages(
        &mut self,
        stages: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameStageData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_STAGES,
            stages,
        );
    }
    #[inline]
    pub fn add_zones(
        &mut self,
        zones: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameZoneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_ZONES,
            zones,
        );
    }
    #[inline]
    pub fn add_variation(
        &mut self,
        variation: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeZoneVariationData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_VARIATION,
            variation,
        );
    }
    #[inline]
    pub fn add_traps(
        &mut self,
        traps: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameTrapData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_TRAPS,
            traps,
        );
    }
    #[inline]
    pub fn add_recruitTickets(
        &mut self,
        recruitTickets: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameRecruitTicketData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_RECRUITTICKETS,
            recruitTickets,
        );
    }
    #[inline]
    pub fn add_upgradeTickets(
        &mut self,
        upgradeTickets: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameUpgradeTicketData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_UPGRADETICKETS,
            upgradeTickets,
        );
    }
    #[inline]
    pub fn add_customTickets(
        &mut self,
        customTickets: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameCustomTicketData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_CUSTOMTICKETS,
            customTickets,
        );
    }
    #[inline]
    pub fn add_stashableTickets(
        &mut self,
        stashableTickets: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameStashableTicketData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_STASHABLETICKETS,
            stashableTickets,
        );
    }
    #[inline]
    pub fn add_relics(
        &mut self,
        relics: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameRelicData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_RELICS,
            relics,
        );
    }
    #[inline]
    pub fn add_relicParams(
        &mut self,
        relicParams: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameRelicParamData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_RELICPARAMS,
            relicParams,
        );
    }
    #[inline]
    pub fn add_recruitGrps(
        &mut self,
        recruitGrps: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameRecruitGrpData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_RECRUITGRPS,
            recruitGrps,
        );
    }
    #[inline]
    pub fn add_choices(
        &mut self,
        choices: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameChoiceData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_CHOICES,
            choices,
        );
    }
    #[inline]
    pub fn add_choiceScenes(
        &mut self,
        choiceScenes: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameChoiceSceneData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_CHOICESCENES,
            choiceScenes,
        );
    }
    #[inline]
    pub fn add_nodeTypeData(
        &mut self,
        nodeTypeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeData<
                        'b,
                    >,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_NODETYPEDATA,
            nodeTypeData,
        );
    }
    #[inline]
    pub fn add_subTypeData(
        &mut self,
        subTypeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameNodeSubTypeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_SUBTYPEDATA,
            subTypeData,
        );
    }
    #[inline]
    pub fn add_variationData(
        &mut self,
        variationData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameVariationData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_VARIATIONDATA,
            variationData,
        );
    }
    #[inline]
    pub fn add_fusionData(
        &mut self,
        fusionData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameFusionData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_FUSIONDATA,
            fusionData,
        );
    }
    #[inline]
    pub fn add_charBuffData(
        &mut self,
        charBuffData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameCharBuffData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_CHARBUFFDATA,
            charBuffData,
        );
    }
    #[inline]
    pub fn add_squadBuffData(
        &mut self,
        squadBuffData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameSquadBuffData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_SQUADBUFFDATA,
            squadBuffData,
        );
    }
    #[inline]
    pub fn add_taskData(
        &mut self,
        taskData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTaskData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_TASKDATA,
            taskData,
        );
    }
    #[inline]
    pub fn add_gameConst(
        &mut self,
        gameConst: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameConst>>(
                clz_Torappu_RoguelikeTopicDetail::VT_GAMECONST,
                gameConst,
            );
    }
    #[inline]
    pub fn add_shopDialogData(
        &mut self,
        shopDialogData: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogData>>(
                clz_Torappu_RoguelikeTopicDetail::VT_SHOPDIALOGDATA,
                shopDialogData,
            );
    }
    #[inline]
    pub fn add_capsuleDict(
        &mut self,
        capsuleDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicCapsule<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_CAPSULEDICT,
            capsuleDict,
        );
    }
    #[inline]
    pub fn add_endings(
        &mut self,
        endings: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameEndingData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_ENDINGS,
            endings,
        );
    }
    #[inline]
    pub fn add_failEndings(
        &mut self,
        failEndings: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameFailEndingData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_FAILENDINGS,
            failEndings,
        );
    }
    #[inline]
    pub fn add_battleSummeryDescriptions(
        &mut self,
        battleSummeryDescriptions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionData<'b >>>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_BATTLESUMMERYDESCRIPTIONS,
            battleSummeryDescriptions,
        );
    }
    #[inline]
    pub fn add_battleLoadingTips(
        &mut self,
        battleLoadingTips: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_BATTLELOADINGTIPS,
            battleLoadingTips,
        );
    }
    #[inline]
    pub fn add_items(
        &mut self,
        items: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeGameItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_ITEMS,
            items,
        );
    }
    #[inline]
    pub fn add_bandRef(
        &mut self,
        bandRef: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeBandRefData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_BANDREF,
            bandRef,
        );
    }
    #[inline]
    pub fn add_endingDetailList(
        &mut self,
        endingDetailList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeEndingDetailText<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_ENDINGDETAILLIST,
            endingDetailList,
        );
    }
    #[inline]
    pub fn add_endingRelicDetailList(
        &mut self,
        endingRelicDetailList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeEndingRelicDetailText<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_ENDINGRELICDETAILLIST,
            endingRelicDetailList,
        );
    }
    #[inline]
    pub fn add_treasures(
        &mut self,
        treasures: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_RoguelikeGameTreasureData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_TREASURES,
            treasures,
        );
    }
    #[inline]
    pub fn add_difficultyUpgradeRelicGroups(
        &mut self,
        difficultyUpgradeRelicGroups: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_DIFFICULTYUPGRADERELICGROUPS,
            difficultyUpgradeRelicGroups,
        );
    }
    #[inline]
    pub fn add_styles(
        &mut self,
        styles: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikePredefinedStyleData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_STYLES,
            styles,
        );
    }
    #[inline]
    pub fn add_styleConfig(
        &mut self,
        styleConfig: flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedConstStyleData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikePredefinedConstStyleData>>(clz_Torappu_RoguelikeTopicDetail::VT_STYLECONFIG, styleConfig);
    }
    #[inline]
    pub fn add_exploreTools(
        &mut self,
        exploreTools: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeGameExploreToolData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_EXPLORETOOLS,
            exploreTools,
        );
    }
    #[inline]
    pub fn add_rollNodeData(
        &mut self,
        rollNodeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeRollNodeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDetail::VT_ROLLNODEDATA,
            rollNodeData,
        );
    }
    #[inline]
    pub fn add_activity(
        &mut self,
        activity: flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeActivityData>>(
                clz_Torappu_RoguelikeTopicDetail::VT_ACTIVITY,
                activity,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicDetailBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicDetailBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetail<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicDetail<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicDetail");
        ds.field("updates", &self.updates());
        ds.field("enrolls", &self.enrolls());
        ds.field("milestones", &self.milestones());
        ds.field("milestoneUpdates", &self.milestoneUpdates());
        ds.field("grandPrizes", &self.grandPrizes());
        ds.field("monthMission", &self.monthMission());
        ds.field("monthSquad", &self.monthSquad());
        ds.field("challenges", &self.challenges());
        ds.field("difficulties", &self.difficulties());
        ds.field("bankRewards", &self.bankRewards());
        ds.field("archiveComp", &self.archiveComp());
        ds.field("archiveUnlockCond", &self.archiveUnlockCond());
        ds.field("detailConst", &self.detailConst());
        ds.field("init", &self.init());
        ds.field("stages", &self.stages());
        ds.field("zones", &self.zones());
        ds.field("variation", &self.variation());
        ds.field("traps", &self.traps());
        ds.field("recruitTickets", &self.recruitTickets());
        ds.field("upgradeTickets", &self.upgradeTickets());
        ds.field("customTickets", &self.customTickets());
        ds.field("stashableTickets", &self.stashableTickets());
        ds.field("relics", &self.relics());
        ds.field("relicParams", &self.relicParams());
        ds.field("recruitGrps", &self.recruitGrps());
        ds.field("choices", &self.choices());
        ds.field("choiceScenes", &self.choiceScenes());
        ds.field("nodeTypeData", &self.nodeTypeData());
        ds.field("subTypeData", &self.subTypeData());
        ds.field("variationData", &self.variationData());
        ds.field("fusionData", &self.fusionData());
        ds.field("charBuffData", &self.charBuffData());
        ds.field("squadBuffData", &self.squadBuffData());
        ds.field("taskData", &self.taskData());
        ds.field("gameConst", &self.gameConst());
        ds.field("shopDialogData", &self.shopDialogData());
        ds.field("capsuleDict", &self.capsuleDict());
        ds.field("endings", &self.endings());
        ds.field("failEndings", &self.failEndings());
        ds.field(
            "battleSummeryDescriptions",
            &self.battleSummeryDescriptions(),
        );
        ds.field("battleLoadingTips", &self.battleLoadingTips());
        ds.field("items", &self.items());
        ds.field("bandRef", &self.bandRef());
        ds.field("endingDetailList", &self.endingDetailList());
        ds.field("endingRelicDetailList", &self.endingRelicDetailList());
        ds.field("treasures", &self.treasures());
        ds.field(
            "difficultyUpgradeRelicGroups",
            &self.difficultyUpgradeRelicGroups(),
        );
        ds.field("styles", &self.styles());
        ds.field("styleConfig", &self.styleConfig());
        ds.field("exploreTools", &self.exploreTools());
        ds.field("rollNodeData", &self.rollNodeData());
        ds.field("activity", &self.activity());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicDetailT {
  pub updates: Option<Vec<clz_Torappu_RoguelikeTopicUpdateT>>,
  pub enrolls: Option<Vec<dict__string__clz_Torappu_RoguelikeTopicEnrollT>>,
  pub milestones: Option<Vec<clz_Torappu_RoguelikeTopicBPT>>,
  pub milestoneUpdates: Option<Vec<clz_Torappu_RoguelikeTopicMilestoneUpdateDataT>>,
  pub grandPrizes: Option<Vec<clz_Torappu_RoguelikeTopicBPGrandPrizeT>>,
  pub monthMission: Option<Vec<clz_Torappu_RoguelikeTopicMonthMissionT>>,
  pub monthSquad: Option<Vec<dict__string__clz_Torappu_RoguelikeTopicMonthSquadT>>,
  pub challenges: Option<Vec<dict__string__clz_Torappu_RoguelikeTopicChallengeT>>,
  pub difficulties: Option<Vec<clz_Torappu_RoguelikeTopicDifficultyT>>,
  pub bankRewards: Option<Vec<clz_Torappu_RoguelikeTopicBankRewardT>>,
  pub archiveComp: Option<Box<clz_Torappu_RoguelikeArchiveComponentDataT>>,
  pub archiveUnlockCond: Option<Box<clz_Torappu_RoguelikeArchiveUnlockCondDataT>>,
  pub detailConst: Option<Box<clz_Torappu_RoguelikeTopicDetailConstT>>,
  pub init: Option<Vec<clz_Torappu_RoguelikeGameInitDataT>>,
  pub stages: Option<Vec<dict__string__clz_Torappu_RoguelikeGameStageDataT>>,
  pub zones: Option<Vec<dict__string__clz_Torappu_RoguelikeGameZoneDataT>>,
  pub variation: Option<Vec<dict__string__clz_Torappu_RoguelikeZoneVariationDataT>>,
  pub traps: Option<Vec<dict__string__clz_Torappu_RoguelikeGameTrapDataT>>,
  pub recruitTickets: Option<Vec<dict__string__clz_Torappu_RoguelikeGameRecruitTicketDataT>>,
  pub upgradeTickets: Option<Vec<dict__string__clz_Torappu_RoguelikeGameUpgradeTicketDataT>>,
  pub customTickets: Option<Vec<dict__string__clz_Torappu_RoguelikeGameCustomTicketDataT>>,
  pub stashableTickets: Option<Vec<dict__string__clz_Torappu_RoguelikeGameStashableTicketDataT>>,
  pub relics: Option<Vec<dict__string__clz_Torappu_RoguelikeGameRelicDataT>>,
  pub relicParams: Option<Vec<dict__string__clz_Torappu_RoguelikeGameRelicParamDataT>>,
  pub recruitGrps: Option<Vec<dict__string__clz_Torappu_RoguelikeGameRecruitGrpDataT>>,
  pub choices: Option<Vec<dict__string__clz_Torappu_RoguelikeGameChoiceDataT>>,
  pub choiceScenes: Option<Vec<dict__string__clz_Torappu_RoguelikeGameChoiceSceneDataT>>,
  pub nodeTypeData: Option<Vec<dict__enum__Torappu_RoguelikeEventType__clz_Torappu_RoguelikeGameNodeTypeDataT>>,
  pub subTypeData: Option<Vec<clz_Torappu_RoguelikeGameNodeSubTypeDataT>>,
  pub variationData: Option<Vec<dict__string__clz_Torappu_RoguelikeGameVariationDataT>>,
  pub fusionData: Option<Vec<dict__string__clz_Torappu_RoguelikeGameFusionDataT>>,
  pub charBuffData: Option<Vec<dict__string__clz_Torappu_RoguelikeGameCharBuffDataT>>,
  pub squadBuffData: Option<Vec<dict__string__clz_Torappu_RoguelikeGameSquadBuffDataT>>,
  pub taskData: Option<Vec<dict__string__clz_Torappu_RoguelikeTaskDataT>>,
  pub gameConst: Option<Box<clz_Torappu_RoguelikeGameConstT>>,
  pub shopDialogData: Option<Box<clz_Torappu_RoguelikeGameShopDialogDataT>>,
  pub capsuleDict: Option<Vec<dict__string__clz_Torappu_RoguelikeTopicCapsuleT>>,
  pub endings: Option<Vec<dict__string__clz_Torappu_RoguelikeGameEndingDataT>>,
  pub failEndings: Option<Vec<dict__string__clz_Torappu_RoguelikeGameFailEndingDataT>>,
  pub battleSummeryDescriptions: Option<Vec<dict__enum__Torappu_RoguelikeTopicMode__clz_Torappu_RoguelikeBattleSummeryDescriptionDataT>>,
  pub battleLoadingTips: Option<Vec<clz_Torappu_TipDataT>>,
  pub items: Option<Vec<dict__string__clz_Torappu_RoguelikeGameItemDataT>>,
  pub bandRef: Option<Vec<dict__string__clz_Torappu_RoguelikeBandRefDataT>>,
  pub endingDetailList: Option<Vec<clz_Torappu_RoguelikeEndingDetailTextT>>,
  pub endingRelicDetailList: Option<Vec<clz_Torappu_RoguelikeEndingRelicDetailTextT>>,
  pub treasures: Option<Vec<dict__string__list_clz_Torappu_RoguelikeGameTreasureDataT>>,
  pub difficultyUpgradeRelicGroups: Option<Vec<dict__string__clz_Torappu_RoguelikeDifficultyUpgradeRelicGroupDataT>>,
  pub styles: Option<Vec<dict__string__clz_Torappu_RoguelikePredefinedStyleDataT>>,
  pub styleConfig: Option<Box<clz_Torappu_RoguelikePredefinedConstStyleDataT>>,
  pub exploreTools: Option<Vec<dict__string__clz_Torappu_RoguelikeGameExploreToolDataT>>,
  pub rollNodeData: Option<Vec<dict__string__clz_Torappu_RoguelikeRollNodeDataT>>,
  pub activity: Option<Box<clz_Torappu_RoguelikeActivityDataT>>,
}
impl Default for clz_Torappu_RoguelikeTopicDetailT {
    fn default() -> Self {
        Self {
            updates: None,
            enrolls: None,
            milestones: None,
            milestoneUpdates: None,
            grandPrizes: None,
            monthMission: None,
            monthSquad: None,
            challenges: None,
            difficulties: None,
            bankRewards: None,
            archiveComp: None,
            archiveUnlockCond: None,
            detailConst: None,
            init: None,
            stages: None,
            zones: None,
            variation: None,
            traps: None,
            recruitTickets: None,
            upgradeTickets: None,
            customTickets: None,
            stashableTickets: None,
            relics: None,
            relicParams: None,
            recruitGrps: None,
            choices: None,
            choiceScenes: None,
            nodeTypeData: None,
            subTypeData: None,
            variationData: None,
            fusionData: None,
            charBuffData: None,
            squadBuffData: None,
            taskData: None,
            gameConst: None,
            shopDialogData: None,
            capsuleDict: None,
            endings: None,
            failEndings: None,
            battleSummeryDescriptions: None,
            battleLoadingTips: None,
            items: None,
            bandRef: None,
            endingDetailList: None,
            endingRelicDetailList: None,
            treasures: None,
            difficultyUpgradeRelicGroups: None,
            styles: None,
            styleConfig: None,
            exploreTools: None,
            rollNodeData: None,
            activity: None,
        }
    }
}
impl clz_Torappu_RoguelikeTopicDetailT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetail<'b>> {
        let updates = self.updates.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let enrolls = self.enrolls.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let milestones = self.milestones.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let milestoneUpdates = self.milestoneUpdates.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let grandPrizes = self.grandPrizes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let monthMission = self.monthMission.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let monthSquad = self.monthSquad.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let challenges = self.challenges.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let difficulties = self.difficulties.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let bankRewards = self.bankRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let archiveComp = self.archiveComp.as_ref().map(|x| x.pack(_fbb));
        let archiveUnlockCond = self.archiveUnlockCond.as_ref().map(|x| x.pack(_fbb));
        let detailConst = self.detailConst.as_ref().map(|x| x.pack(_fbb));
        let init = self.init.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let stages = self.stages.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let zones = self.zones.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let variation = self.variation.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let traps = self.traps.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let recruitTickets = self.recruitTickets.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let upgradeTickets = self.upgradeTickets.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let customTickets = self.customTickets.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let stashableTickets = self.stashableTickets.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let relics = self.relics.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let relicParams = self.relicParams.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let recruitGrps = self.recruitGrps.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let choices = self.choices.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let choiceScenes = self.choiceScenes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let nodeTypeData = self.nodeTypeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let subTypeData = self.subTypeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let variationData = self.variationData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let fusionData = self.fusionData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let charBuffData = self.charBuffData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let squadBuffData = self.squadBuffData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let taskData = self.taskData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let gameConst = self.gameConst.as_ref().map(|x| x.pack(_fbb));
        let shopDialogData = self.shopDialogData.as_ref().map(|x| x.pack(_fbb));
        let capsuleDict = self.capsuleDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let endings = self.endings.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let failEndings = self.failEndings.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let battleSummeryDescriptions = self.battleSummeryDescriptions.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let battleLoadingTips = self.battleLoadingTips.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let items = self.items.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let bandRef = self.bandRef.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let endingDetailList = self.endingDetailList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let endingRelicDetailList = self.endingRelicDetailList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let treasures = self.treasures.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let difficultyUpgradeRelicGroups = self.difficultyUpgradeRelicGroups.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let styles = self.styles.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let styleConfig = self.styleConfig.as_ref().map(|x| x.pack(_fbb));
        let exploreTools = self.exploreTools.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let rollNodeData = self.rollNodeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let activity = self.activity.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeTopicDetail::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicDetailArgs {
                updates,
                enrolls,
                milestones,
                milestoneUpdates,
                grandPrizes,
                monthMission,
                monthSquad,
                challenges,
                difficulties,
                bankRewards,
                archiveComp,
                archiveUnlockCond,
                detailConst,
                init,
                stages,
                zones,
                variation,
                traps,
                recruitTickets,
                upgradeTickets,
                customTickets,
                stashableTickets,
                relics,
                relicParams,
                recruitGrps,
                choices,
                choiceScenes,
                nodeTypeData,
                subTypeData,
                variationData,
                fusionData,
                charBuffData,
                squadBuffData,
                taskData,
                gameConst,
                shopDialogData,
                capsuleDict,
                endings,
                failEndings,
                battleSummeryDescriptions,
                battleLoadingTips,
                items,
                bandRef,
                endingDetailList,
                endingRelicDetailList,
                treasures,
                difficultyUpgradeRelicGroups,
                styles,
                styleConfig,
                exploreTools,
                rollNodeData,
                activity,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeTopicDetailOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeTopicDetail<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeTopicDetail<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeTopicDetail<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeTopicDetail<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeTopicDetail { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeTopicDetailArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicDetail<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeTopicDetailBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeTopicDetailT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeTopicDetailT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeTopicDetail::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeTopicDetail,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeTopicDetail<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDetail>>(
                    dict__string__clz_Torappu_RoguelikeTopicDetail::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeTopicDetail<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDetail>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeTopicDetailArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetail<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeTopicDetailArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeTopicDetailArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeTopicDetail<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeTopicDetail", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeTopicDetailBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeTopicDetailBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeTopicDetail::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetail<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDetail>>(
                dict__string__clz_Torappu_RoguelikeTopicDetail::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeTopicDetailBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeTopicDetailBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicDetail<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeTopicDetail::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeTopicDetail<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeTopicDetail");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeTopicDetailT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeTopicDetailT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeTopicDetailT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeTopicDetailT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicDetail<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeTopicDetail::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeTopicDetailArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeSanRangeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeSanRangeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeSanRangeData<'a> {
    type Inner = clz_Torappu_RoguelikeSanRangeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeSanRangeData<'a> {
    pub const VT_SANMAX: flatbuffers::VOffsetT = 4;
    pub const VT_DICEGROUPID: flatbuffers::VOffsetT = 6;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
    pub const VT_SANDUNGEONEFFECT: flatbuffers::VOffsetT = 10;
    pub const VT_SANEFFECTRANK: flatbuffers::VOffsetT = 12;
    pub const VT_SANENDINGDESC: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeSanRangeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeSanRangeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSanRangeData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeSanRangeDataBuilder::new(_fbb);
        if let Some(x) = args.sanEndingDesc {
            builder.add_sanEndingDesc(x);
        }
        builder.add_sanEffectRank(args.sanEffectRank);
        builder.add_sanDungeonEffect(args.sanDungeonEffect);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.diceGroupId {
            builder.add_diceGroupId(x);
        }
        builder.add_sanMax(args.sanMax);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeSanRangeDataT {
        let sanMax = self.sanMax();
        let diceGroupId = self.diceGroupId().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let sanDungeonEffect = self.sanDungeonEffect();
        let sanEffectRank = self.sanEffectRank();
        let sanEndingDesc = self.sanEndingDesc().map(|x| x.to_string());
        clz_Torappu_RoguelikeSanRangeDataT {
            sanMax,
            diceGroupId,
            description,
            sanDungeonEffect,
            sanEffectRank,
            sanEndingDesc,
        }
    }

    #[inline]
    pub fn sanMax(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeSanRangeData::VT_SANMAX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn diceGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeSanRangeData::VT_DICEGROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeSanRangeData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn sanDungeonEffect(&self) -> enum__Torappu_SanEffectRank {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SanEffectRank>(
                    clz_Torappu_RoguelikeSanRangeData::VT_SANDUNGEONEFFECT,
                    Some(enum__Torappu_SanEffectRank::SAN_EFFECT_0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sanEffectRank(&self) -> enum__Torappu_SanEffectRank {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SanEffectRank>(
                    clz_Torappu_RoguelikeSanRangeData::VT_SANEFFECTRANK,
                    Some(enum__Torappu_SanEffectRank::SAN_EFFECT_0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sanEndingDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeSanRangeData::VT_SANENDINGDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeSanRangeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("sanMax", Self::VT_SANMAX, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "diceGroupId",
                Self::VT_DICEGROUPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<enum__Torappu_SanEffectRank>(
                "sanDungeonEffect",
                Self::VT_SANDUNGEONEFFECT,
                false,
            )?
            .visit_field::<enum__Torappu_SanEffectRank>(
                "sanEffectRank",
                Self::VT_SANEFFECTRANK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "sanEndingDesc",
                Self::VT_SANENDINGDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeSanRangeDataArgs<'a> {
    pub sanMax: i32,
    pub diceGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sanDungeonEffect: enum__Torappu_SanEffectRank,
    pub sanEffectRank: enum__Torappu_SanEffectRank,
    pub sanEndingDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeSanRangeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeSanRangeDataArgs {
            sanMax: 0,
            diceGroupId: None,
            description: None,
            sanDungeonEffect: enum__Torappu_SanEffectRank::SAN_EFFECT_0,
            sanEffectRank: enum__Torappu_SanEffectRank::SAN_EFFECT_0,
            sanEndingDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeSanRangeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeSanRangeData", 6)?;
        s.serialize_field("sanMax", &self.sanMax())?;
        if let Some(f) = self.diceGroupId() {
            s.serialize_field("diceGroupId", &f)?;
        } else {
            s.skip_field("diceGroupId")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        s.serialize_field("sanDungeonEffect", &self.sanDungeonEffect())?;
        s.serialize_field("sanEffectRank", &self.sanEffectRank())?;
        if let Some(f) = self.sanEndingDesc() {
            s.serialize_field("sanEndingDesc", &f)?;
        } else {
            s.skip_field("sanEndingDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeSanRangeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeSanRangeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_sanMax(&mut self, sanMax: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeSanRangeData::VT_SANMAX, sanMax, 0);
    }
    #[inline]
    pub fn add_diceGroupId(&mut self, diceGroupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSanRangeData::VT_DICEGROUPID,
            diceGroupId,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSanRangeData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_sanDungeonEffect(&mut self, sanDungeonEffect: enum__Torappu_SanEffectRank) {
        self.fbb_.push_slot::<enum__Torappu_SanEffectRank>(
            clz_Torappu_RoguelikeSanRangeData::VT_SANDUNGEONEFFECT,
            sanDungeonEffect,
            enum__Torappu_SanEffectRank::SAN_EFFECT_0,
        );
    }
    #[inline]
    pub fn add_sanEffectRank(&mut self, sanEffectRank: enum__Torappu_SanEffectRank) {
        self.fbb_.push_slot::<enum__Torappu_SanEffectRank>(
            clz_Torappu_RoguelikeSanRangeData::VT_SANEFFECTRANK,
            sanEffectRank,
            enum__Torappu_SanEffectRank::SAN_EFFECT_0,
        );
    }
    #[inline]
    pub fn add_sanEndingDesc(&mut self, sanEndingDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSanRangeData::VT_SANENDINGDESC,
            sanEndingDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeSanRangeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeSanRangeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSanRangeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeSanRangeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeSanRangeData");
        ds.field("sanMax", &self.sanMax());
        ds.field("diceGroupId", &self.diceGroupId());
        ds.field("description", &self.description());
        ds.field("sanDungeonEffect", &self.sanDungeonEffect());
        ds.field("sanEffectRank", &self.sanEffectRank());
        ds.field("sanEndingDesc", &self.sanEndingDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeSanRangeDataT {
    pub sanMax: i32,
    pub diceGroupId: Option<String>,
    pub description: Option<String>,
    pub sanDungeonEffect: enum__Torappu_SanEffectRank,
    pub sanEffectRank: enum__Torappu_SanEffectRank,
    pub sanEndingDesc: Option<String>,
}
impl Default for clz_Torappu_RoguelikeSanRangeDataT {
    fn default() -> Self {
        Self {
            sanMax: 0,
            diceGroupId: None,
            description: None,
            sanDungeonEffect: enum__Torappu_SanEffectRank::SAN_EFFECT_0,
            sanEffectRank: enum__Torappu_SanEffectRank::SAN_EFFECT_0,
            sanEndingDesc: None,
        }
    }
}
impl clz_Torappu_RoguelikeSanRangeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSanRangeData<'b>> {
        let sanMax = self.sanMax;
        let diceGroupId = self.diceGroupId.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let sanDungeonEffect = self.sanDungeonEffect;
        let sanEffectRank = self.sanEffectRank;
        let sanEndingDesc = self.sanEndingDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeSanRangeData::create(
            _fbb,
            &clz_Torappu_RoguelikeSanRangeDataArgs {
                sanMax,
                diceGroupId,
                description,
                sanDungeonEffect,
                sanEffectRank,
                sanEndingDesc,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeSanCheckConstsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeSanCheckConsts<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeSanCheckConsts<'a> {
    type Inner = clz_Torappu_RoguelikeSanCheckConsts<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeSanCheckConsts<'a> {
    pub const VT_SANDECREASETOAST: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeSanCheckConsts { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeSanCheckConstsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSanCheckConsts<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeSanCheckConstsBuilder::new(_fbb);
        if let Some(x) = args.sanDecreaseToast {
            builder.add_sanDecreaseToast(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeSanCheckConstsT {
        let sanDecreaseToast = self.sanDecreaseToast().map(|x| x.to_string());
        clz_Torappu_RoguelikeSanCheckConstsT { sanDecreaseToast }
    }

    #[inline]
    pub fn sanDecreaseToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeSanCheckConsts::VT_SANDECREASETOAST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeSanCheckConsts<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "sanDecreaseToast",
                Self::VT_SANDECREASETOAST,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeSanCheckConstsArgs<'a> {
    pub sanDecreaseToast: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeSanCheckConstsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeSanCheckConstsArgs {
            sanDecreaseToast: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeSanCheckConsts<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeSanCheckConsts", 1)?;
        if let Some(f) = self.sanDecreaseToast() {
            s.serialize_field("sanDecreaseToast", &f)?;
        } else {
            s.skip_field("sanDecreaseToast")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeSanCheckConstsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeSanCheckConstsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_sanDecreaseToast(&mut self, sanDecreaseToast: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSanCheckConsts::VT_SANDECREASETOAST,
            sanDecreaseToast,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeSanCheckConstsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeSanCheckConstsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSanCheckConsts<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeSanCheckConsts<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeSanCheckConsts");
        ds.field("sanDecreaseToast", &self.sanDecreaseToast());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeSanCheckConstsT {
    pub sanDecreaseToast: Option<String>,
}
impl Default for clz_Torappu_RoguelikeSanCheckConstsT {
    fn default() -> Self {
        Self {
            sanDecreaseToast: None,
        }
    }
}
impl clz_Torappu_RoguelikeSanCheckConstsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSanCheckConsts<'b>> {
        let sanDecreaseToast = self
            .sanDecreaseToast
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeSanCheckConsts::create(
            _fbb,
            &clz_Torappu_RoguelikeSanCheckConstsArgs { sanDecreaseToast },
        )
    }
}
pub enum clz_Torappu_RoguelikeSanCheckModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeSanCheckModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeSanCheckModuleData<'a> {
    type Inner = clz_Torappu_RoguelikeSanCheckModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeSanCheckModuleData<'a> {
    pub const VT_SANRANGES: flatbuffers::VOffsetT = 4;
    pub const VT_MODULECONSTS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeSanCheckModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeSanCheckModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSanCheckModuleData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeSanCheckModuleDataBuilder::new(_fbb);
        if let Some(x) = args.moduleConsts {
            builder.add_moduleConsts(x);
        }
        if let Some(x) = args.sanRanges {
            builder.add_sanRanges(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeSanCheckModuleDataT {
        let sanRanges = self
            .sanRanges()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let moduleConsts = self.moduleConsts().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeSanCheckModuleDataT {
            sanRanges,
            moduleConsts,
        }
    }

    #[inline]
    pub fn sanRanges(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSanRangeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSanRangeData>,
                >,
            >>(clz_Torappu_RoguelikeSanCheckModuleData::VT_SANRANGES, None)
        }
    }
    #[inline]
    pub fn moduleConsts(&self) -> Option<clz_Torappu_RoguelikeSanCheckConsts<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSanCheckConsts>>(
                    clz_Torappu_RoguelikeSanCheckModuleData::VT_MODULECONSTS,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeSanCheckModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSanRangeData>,
                >,
            >>("sanRanges", Self::VT_SANRANGES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSanCheckConsts>>(
                "moduleConsts",
                Self::VT_MODULECONSTS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeSanCheckModuleDataArgs<'a> {
    pub sanRanges: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSanRangeData<'a>>,
            >,
        >,
    >,
    pub moduleConsts: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeSanCheckConsts<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeSanCheckModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeSanCheckModuleDataArgs {
            sanRanges: None,
            moduleConsts: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeSanCheckModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeSanCheckModuleData", 2)?;
        if let Some(f) = self.sanRanges() {
            s.serialize_field("sanRanges", &f)?;
        } else {
            s.skip_field("sanRanges")?;
        }
        if let Some(f) = self.moduleConsts() {
            s.serialize_field("moduleConsts", &f)?;
        } else {
            s.skip_field("moduleConsts")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeSanCheckModuleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeSanCheckModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_sanRanges(
        &mut self,
        sanRanges: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSanRangeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSanCheckModuleData::VT_SANRANGES,
            sanRanges,
        );
    }
    #[inline]
    pub fn add_moduleConsts(
        &mut self,
        moduleConsts: flatbuffers::WIPOffset<clz_Torappu_RoguelikeSanCheckConsts<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeSanCheckConsts>>(
                clz_Torappu_RoguelikeSanCheckModuleData::VT_MODULECONSTS,
                moduleConsts,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeSanCheckModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeSanCheckModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSanCheckModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeSanCheckModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeSanCheckModuleData");
        ds.field("sanRanges", &self.sanRanges());
        ds.field("moduleConsts", &self.moduleConsts());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeSanCheckModuleDataT {
    pub sanRanges: Option<Vec<clz_Torappu_RoguelikeSanRangeDataT>>,
    pub moduleConsts: Option<Box<clz_Torappu_RoguelikeSanCheckConstsT>>,
}
impl Default for clz_Torappu_RoguelikeSanCheckModuleDataT {
    fn default() -> Self {
        Self {
            sanRanges: None,
            moduleConsts: None,
        }
    }
}
impl clz_Torappu_RoguelikeSanCheckModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSanCheckModuleData<'b>> {
        let sanRanges = self.sanRanges.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let moduleConsts = self.moduleConsts.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeSanCheckModuleData::create(
            _fbb,
            &clz_Torappu_RoguelikeSanCheckModuleDataArgs {
                sanRanges,
                moduleConsts,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeDiceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeDiceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeDiceData<'a> {
    type Inner = clz_Torappu_RoguelikeDiceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeDiceData<'a> {
    pub const VT_DICEID: flatbuffers::VOffsetT = 4;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
    pub const VT_ISUPGRADEDICE: flatbuffers::VOffsetT = 8;
    pub const VT_UPGRADEDICEID: flatbuffers::VOffsetT = 10;
    pub const VT_DICEFACECOUNT: flatbuffers::VOffsetT = 12;
    pub const VT_BATTLEDICEID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeDiceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeDiceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeDiceDataBuilder::new(_fbb);
        if let Some(x) = args.battleDiceId {
            builder.add_battleDiceId(x);
        }
        builder.add_diceFaceCount(args.diceFaceCount);
        if let Some(x) = args.upgradeDiceId {
            builder.add_upgradeDiceId(x);
        }
        builder.add_isUpgradeDice(args.isUpgradeDice);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.diceId {
            builder.add_diceId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeDiceDataT {
        let diceId = self.diceId().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let isUpgradeDice = self.isUpgradeDice();
        let upgradeDiceId = self.upgradeDiceId().map(|x| x.to_string());
        let diceFaceCount = self.diceFaceCount();
        let battleDiceId = self.battleDiceId().map(|x| x.to_string());
        clz_Torappu_RoguelikeDiceDataT {
            diceId,
            description,
            isUpgradeDice,
            upgradeDiceId,
            diceFaceCount,
            battleDiceId,
        }
    }

    #[inline]
    pub fn diceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDiceData::VT_DICEID,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDiceData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn isUpgradeDice(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeDiceData::VT_ISUPGRADEDICE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn upgradeDiceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDiceData::VT_UPGRADEDICEID,
                None,
            )
        }
    }
    #[inline]
    pub fn diceFaceCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeDiceData::VT_DICEFACECOUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn battleDiceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDiceData::VT_BATTLEDICEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeDiceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("diceId", Self::VT_DICEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<i32>("isUpgradeDice", Self::VT_ISUPGRADEDICE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "upgradeDiceId",
                Self::VT_UPGRADEDICEID,
                false,
            )?
            .visit_field::<i32>("diceFaceCount", Self::VT_DICEFACECOUNT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleDiceId",
                Self::VT_BATTLEDICEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeDiceDataArgs<'a> {
    pub diceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isUpgradeDice: i32,
    pub upgradeDiceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub diceFaceCount: i32,
    pub battleDiceId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeDiceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeDiceDataArgs {
            diceId: None,
            description: None,
            isUpgradeDice: 0,
            upgradeDiceId: None,
            diceFaceCount: 0,
            battleDiceId: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeDiceData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeDiceData", 6)?;
        if let Some(f) = self.diceId() {
            s.serialize_field("diceId", &f)?;
        } else {
            s.skip_field("diceId")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        s.serialize_field("isUpgradeDice", &self.isUpgradeDice())?;
        if let Some(f) = self.upgradeDiceId() {
            s.serialize_field("upgradeDiceId", &f)?;
        } else {
            s.skip_field("upgradeDiceId")?;
        }
        s.serialize_field("diceFaceCount", &self.diceFaceCount())?;
        if let Some(f) = self.battleDiceId() {
            s.serialize_field("battleDiceId", &f)?;
        } else {
            s.skip_field("battleDiceId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeDiceDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RoguelikeDiceDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_diceId(&mut self, diceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceData::VT_DICEID,
            diceId,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_isUpgradeDice(&mut self, isUpgradeDice: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeDiceData::VT_ISUPGRADEDICE,
            isUpgradeDice,
            0,
        );
    }
    #[inline]
    pub fn add_upgradeDiceId(&mut self, upgradeDiceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceData::VT_UPGRADEDICEID,
            upgradeDiceId,
        );
    }
    #[inline]
    pub fn add_diceFaceCount(&mut self, diceFaceCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeDiceData::VT_DICEFACECOUNT,
            diceFaceCount,
            0,
        );
    }
    #[inline]
    pub fn add_battleDiceId(&mut self, battleDiceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceData::VT_BATTLEDICEID,
            battleDiceId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeDiceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeDiceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeDiceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeDiceData");
        ds.field("diceId", &self.diceId());
        ds.field("description", &self.description());
        ds.field("isUpgradeDice", &self.isUpgradeDice());
        ds.field("upgradeDiceId", &self.upgradeDiceId());
        ds.field("diceFaceCount", &self.diceFaceCount());
        ds.field("battleDiceId", &self.battleDiceId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeDiceDataT {
    pub diceId: Option<String>,
    pub description: Option<String>,
    pub isUpgradeDice: i32,
    pub upgradeDiceId: Option<String>,
    pub diceFaceCount: i32,
    pub battleDiceId: Option<String>,
}
impl Default for clz_Torappu_RoguelikeDiceDataT {
    fn default() -> Self {
        Self {
            diceId: None,
            description: None,
            isUpgradeDice: 0,
            upgradeDiceId: None,
            diceFaceCount: 0,
            battleDiceId: None,
        }
    }
}
impl clz_Torappu_RoguelikeDiceDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceData<'b>> {
        let diceId = self.diceId.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let isUpgradeDice = self.isUpgradeDice;
        let upgradeDiceId = self.upgradeDiceId.as_ref().map(|x| _fbb.create_string(x));
        let diceFaceCount = self.diceFaceCount;
        let battleDiceId = self.battleDiceId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeDiceData::create(
            _fbb,
            &clz_Torappu_RoguelikeDiceDataArgs {
                diceId,
                description,
                isUpgradeDice,
                upgradeDiceId,
                diceFaceCount,
                battleDiceId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeDiceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeDiceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeDiceData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeDiceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeDiceData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeDiceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeDiceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeDiceData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeDiceDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeDiceDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeDiceDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeDiceData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_RoguelikeDiceData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeDiceData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDiceData>>(
                    dict__string__clz_Torappu_RoguelikeDiceData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeDiceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDiceData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeDiceDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeDiceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeDiceDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeDiceData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeDiceData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeDiceDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeDiceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeDiceData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceData>>(
                dict__string__clz_Torappu_RoguelikeDiceData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeDiceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeDiceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeDiceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeDiceData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeDiceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeDiceData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeDiceDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeDiceDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeDiceDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeDiceDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeDiceData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeDiceData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeDiceDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeDiceRuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeDiceRuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeDiceRuleData<'a> {
    type Inner = clz_Torappu_RoguelikeDiceRuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeDiceRuleData<'a> {
    pub const VT_DICEPOINTMAX: flatbuffers::VOffsetT = 4;
    pub const VT_DICERESULTCLASS: flatbuffers::VOffsetT = 6;
    pub const VT_DICEGROUPID: flatbuffers::VOffsetT = 8;
    pub const VT_DICEEVENTID: flatbuffers::VOffsetT = 10;
    pub const VT_RESULTDESC: flatbuffers::VOffsetT = 12;
    pub const VT_SHOWTYPE: flatbuffers::VOffsetT = 14;
    pub const VT_CANREROLL: flatbuffers::VOffsetT = 16;
    pub const VT_DICEENDINGSCENE: flatbuffers::VOffsetT = 18;
    pub const VT_DICEENDINGDESC: flatbuffers::VOffsetT = 20;
    pub const VT_SOUND: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeDiceRuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeDiceRuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceRuleData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeDiceRuleDataBuilder::new(_fbb);
        if let Some(x) = args.sound {
            builder.add_sound(x);
        }
        if let Some(x) = args.diceEndingDesc {
            builder.add_diceEndingDesc(x);
        }
        if let Some(x) = args.diceEndingScene {
            builder.add_diceEndingScene(x);
        }
        builder.add_showType(args.showType);
        if let Some(x) = args.resultDesc {
            builder.add_resultDesc(x);
        }
        if let Some(x) = args.diceEventId {
            builder.add_diceEventId(x);
        }
        if let Some(x) = args.diceGroupId {
            builder.add_diceGroupId(x);
        }
        builder.add_diceResultClass(args.diceResultClass);
        builder.add_dicePointMax(args.dicePointMax);
        builder.add_canReroll(args.canReroll);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeDiceRuleDataT {
        let dicePointMax = self.dicePointMax();
        let diceResultClass = self.diceResultClass();
        let diceGroupId = self.diceGroupId().map(|x| x.to_string());
        let diceEventId = self.diceEventId().map(|x| x.to_string());
        let resultDesc = self.resultDesc().map(|x| x.to_string());
        let showType = self.showType();
        let canReroll = self.canReroll();
        let diceEndingScene = self.diceEndingScene().map(|x| x.to_string());
        let diceEndingDesc = self.diceEndingDesc().map(|x| x.to_string());
        let sound = self.sound().map(|x| x.to_string());
        clz_Torappu_RoguelikeDiceRuleDataT {
            dicePointMax,
            diceResultClass,
            diceGroupId,
            diceEventId,
            resultDesc,
            showType,
            canReroll,
            diceEndingScene,
            diceEndingDesc,
            sound,
        }
    }

    #[inline]
    pub fn dicePointMax(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeDiceRuleData::VT_DICEPOINTMAX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn diceResultClass(&self) -> enum__Torappu_DiceResultClass {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_DiceResultClass>(
                    clz_Torappu_RoguelikeDiceRuleData::VT_DICERESULTCLASS,
                    Some(enum__Torappu_DiceResultClass::VERYBAD),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn diceGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDiceRuleData::VT_DICEGROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn diceEventId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDiceRuleData::VT_DICEEVENTID,
                None,
            )
        }
    }
    #[inline]
    pub fn resultDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDiceRuleData::VT_RESULTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn showType(&self) -> enum__Torappu_DiceResultShowType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_DiceResultShowType>(
                    clz_Torappu_RoguelikeDiceRuleData::VT_SHOWTYPE,
                    Some(enum__Torappu_DiceResultShowType::RAW_TEXT),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn canReroll(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_RoguelikeDiceRuleData::VT_CANREROLL, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn diceEndingScene(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDiceRuleData::VT_DICEENDINGSCENE,
                None,
            )
        }
    }
    #[inline]
    pub fn diceEndingDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDiceRuleData::VT_DICEENDINGDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn sound(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDiceRuleData::VT_SOUND,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeDiceRuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("dicePointMax", Self::VT_DICEPOINTMAX, false)?
            .visit_field::<enum__Torappu_DiceResultClass>(
                "diceResultClass",
                Self::VT_DICERESULTCLASS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "diceGroupId",
                Self::VT_DICEGROUPID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "diceEventId",
                Self::VT_DICEEVENTID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "resultDesc",
                Self::VT_RESULTDESC,
                false,
            )?
            .visit_field::<enum__Torappu_DiceResultShowType>("showType", Self::VT_SHOWTYPE, false)?
            .visit_field::<bool>("canReroll", Self::VT_CANREROLL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "diceEndingScene",
                Self::VT_DICEENDINGSCENE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "diceEndingDesc",
                Self::VT_DICEENDINGDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sound", Self::VT_SOUND, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeDiceRuleDataArgs<'a> {
    pub dicePointMax: i32,
    pub diceResultClass: enum__Torappu_DiceResultClass,
    pub diceGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub diceEventId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub resultDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub showType: enum__Torappu_DiceResultShowType,
    pub canReroll: bool,
    pub diceEndingScene: Option<flatbuffers::WIPOffset<&'a str>>,
    pub diceEndingDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sound: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeDiceRuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeDiceRuleDataArgs {
            dicePointMax: 0,
            diceResultClass: enum__Torappu_DiceResultClass::VERYBAD,
            diceGroupId: None,
            diceEventId: None,
            resultDesc: None,
            showType: enum__Torappu_DiceResultShowType::RAW_TEXT,
            canReroll: false,
            diceEndingScene: None,
            diceEndingDesc: None,
            sound: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeDiceRuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeDiceRuleData", 10)?;
        s.serialize_field("dicePointMax", &self.dicePointMax())?;
        s.serialize_field("diceResultClass", &self.diceResultClass())?;
        if let Some(f) = self.diceGroupId() {
            s.serialize_field("diceGroupId", &f)?;
        } else {
            s.skip_field("diceGroupId")?;
        }
        if let Some(f) = self.diceEventId() {
            s.serialize_field("diceEventId", &f)?;
        } else {
            s.skip_field("diceEventId")?;
        }
        if let Some(f) = self.resultDesc() {
            s.serialize_field("resultDesc", &f)?;
        } else {
            s.skip_field("resultDesc")?;
        }
        s.serialize_field("showType", &self.showType())?;
        s.serialize_field("canReroll", &self.canReroll())?;
        if let Some(f) = self.diceEndingScene() {
            s.serialize_field("diceEndingScene", &f)?;
        } else {
            s.skip_field("diceEndingScene")?;
        }
        if let Some(f) = self.diceEndingDesc() {
            s.serialize_field("diceEndingDesc", &f)?;
        } else {
            s.skip_field("diceEndingDesc")?;
        }
        if let Some(f) = self.sound() {
            s.serialize_field("sound", &f)?;
        } else {
            s.skip_field("sound")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeDiceRuleDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeDiceRuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_dicePointMax(&mut self, dicePointMax: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeDiceRuleData::VT_DICEPOINTMAX,
            dicePointMax,
            0,
        );
    }
    #[inline]
    pub fn add_diceResultClass(&mut self, diceResultClass: enum__Torappu_DiceResultClass) {
        self.fbb_.push_slot::<enum__Torappu_DiceResultClass>(
            clz_Torappu_RoguelikeDiceRuleData::VT_DICERESULTCLASS,
            diceResultClass,
            enum__Torappu_DiceResultClass::VERYBAD,
        );
    }
    #[inline]
    pub fn add_diceGroupId(&mut self, diceGroupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceRuleData::VT_DICEGROUPID,
            diceGroupId,
        );
    }
    #[inline]
    pub fn add_diceEventId(&mut self, diceEventId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceRuleData::VT_DICEEVENTID,
            diceEventId,
        );
    }
    #[inline]
    pub fn add_resultDesc(&mut self, resultDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceRuleData::VT_RESULTDESC,
            resultDesc,
        );
    }
    #[inline]
    pub fn add_showType(&mut self, showType: enum__Torappu_DiceResultShowType) {
        self.fbb_.push_slot::<enum__Torappu_DiceResultShowType>(
            clz_Torappu_RoguelikeDiceRuleData::VT_SHOWTYPE,
            showType,
            enum__Torappu_DiceResultShowType::RAW_TEXT,
        );
    }
    #[inline]
    pub fn add_canReroll(&mut self, canReroll: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeDiceRuleData::VT_CANREROLL,
            canReroll,
            false,
        );
    }
    #[inline]
    pub fn add_diceEndingScene(&mut self, diceEndingScene: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceRuleData::VT_DICEENDINGSCENE,
            diceEndingScene,
        );
    }
    #[inline]
    pub fn add_diceEndingDesc(&mut self, diceEndingDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceRuleData::VT_DICEENDINGDESC,
            diceEndingDesc,
        );
    }
    #[inline]
    pub fn add_sound(&mut self, sound: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceRuleData::VT_SOUND,
            sound,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeDiceRuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeDiceRuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceRuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeDiceRuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeDiceRuleData");
        ds.field("dicePointMax", &self.dicePointMax());
        ds.field("diceResultClass", &self.diceResultClass());
        ds.field("diceGroupId", &self.diceGroupId());
        ds.field("diceEventId", &self.diceEventId());
        ds.field("resultDesc", &self.resultDesc());
        ds.field("showType", &self.showType());
        ds.field("canReroll", &self.canReroll());
        ds.field("diceEndingScene", &self.diceEndingScene());
        ds.field("diceEndingDesc", &self.diceEndingDesc());
        ds.field("sound", &self.sound());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeDiceRuleDataT {
    pub dicePointMax: i32,
    pub diceResultClass: enum__Torappu_DiceResultClass,
    pub diceGroupId: Option<String>,
    pub diceEventId: Option<String>,
    pub resultDesc: Option<String>,
    pub showType: enum__Torappu_DiceResultShowType,
    pub canReroll: bool,
    pub diceEndingScene: Option<String>,
    pub diceEndingDesc: Option<String>,
    pub sound: Option<String>,
}
impl Default for clz_Torappu_RoguelikeDiceRuleDataT {
    fn default() -> Self {
        Self {
            dicePointMax: 0,
            diceResultClass: enum__Torappu_DiceResultClass::VERYBAD,
            diceGroupId: None,
            diceEventId: None,
            resultDesc: None,
            showType: enum__Torappu_DiceResultShowType::RAW_TEXT,
            canReroll: false,
            diceEndingScene: None,
            diceEndingDesc: None,
            sound: None,
        }
    }
}
impl clz_Torappu_RoguelikeDiceRuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceRuleData<'b>> {
        let dicePointMax = self.dicePointMax;
        let diceResultClass = self.diceResultClass;
        let diceGroupId = self.diceGroupId.as_ref().map(|x| _fbb.create_string(x));
        let diceEventId = self.diceEventId.as_ref().map(|x| _fbb.create_string(x));
        let resultDesc = self.resultDesc.as_ref().map(|x| _fbb.create_string(x));
        let showType = self.showType;
        let canReroll = self.canReroll;
        let diceEndingScene = self.diceEndingScene.as_ref().map(|x| _fbb.create_string(x));
        let diceEndingDesc = self.diceEndingDesc.as_ref().map(|x| _fbb.create_string(x));
        let sound = self.sound.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeDiceRuleData::create(
            _fbb,
            &clz_Torappu_RoguelikeDiceRuleDataArgs {
                dicePointMax,
                diceResultClass,
                diceGroupId,
                diceEventId,
                resultDesc,
                showType,
                canReroll,
                diceEndingScene,
                diceEndingDesc,
                sound,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeDiceRuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeDiceRuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeDiceRuleData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeDiceRuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeDiceRuleData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeDiceRuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeDiceRuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeDiceRuleData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeDiceRuleDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeDiceRuleDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeDiceRuleDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeDiceRuleData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeDiceRuleData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeDiceRuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDiceRuleData>>(
                    dict__string__clz_Torappu_RoguelikeDiceRuleData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeDiceRuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDiceRuleData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeDiceRuleDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceRuleData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeDiceRuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeDiceRuleDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeDiceRuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeDiceRuleData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeDiceRuleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeDiceRuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeDiceRuleData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceRuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceRuleData>>(
                dict__string__clz_Torappu_RoguelikeDiceRuleData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeDiceRuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeDiceRuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeDiceRuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeDiceRuleData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeDiceRuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeDiceRuleData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeDiceRuleDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeDiceRuleDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeDiceRuleDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeDiceRuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeDiceRuleData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeDiceRuleData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeDiceRuleDataArgs { key, value },
        )
    }
}
pub enum dict__string__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__string<'a> {
    type Inner = dict__string__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__string<'bldr>> {
        let mut builder = dict__string__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__stringT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.to_string());
        dict__string__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__string__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__stringT {
    pub key: String,
    pub value: Option<String>,
}
impl Default for dict__string__stringT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__string<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| _fbb.create_string(x));
        dict__string__string::create(_fbb, &dict__string__stringArgs { key, value })
    }
}
pub enum clz_Torappu_RoguelikeDiceRuleGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeDiceRuleGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeDiceRuleGroupData<'a> {
    type Inner = clz_Torappu_RoguelikeDiceRuleGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeDiceRuleGroupData<'a> {
    pub const VT_RULEGROUPID: flatbuffers::VOffsetT = 4;
    pub const VT_MINGOODNUM: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeDiceRuleGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeDiceRuleGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceRuleGroupData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeDiceRuleGroupDataBuilder::new(_fbb);
        builder.add_minGoodNum(args.minGoodNum);
        if let Some(x) = args.ruleGroupId {
            builder.add_ruleGroupId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeDiceRuleGroupDataT {
        let ruleGroupId = self.ruleGroupId().map(|x| x.to_string());
        let minGoodNum = self.minGoodNum();
        clz_Torappu_RoguelikeDiceRuleGroupDataT {
            ruleGroupId,
            minGoodNum,
        }
    }

    #[inline]
    pub fn ruleGroupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDiceRuleGroupData::VT_RULEGROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn minGoodNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeDiceRuleGroupData::VT_MINGOODNUM,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeDiceRuleGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "ruleGroupId",
                Self::VT_RULEGROUPID,
                false,
            )?
            .visit_field::<i32>("minGoodNum", Self::VT_MINGOODNUM, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeDiceRuleGroupDataArgs<'a> {
    pub ruleGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub minGoodNum: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeDiceRuleGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeDiceRuleGroupDataArgs {
            ruleGroupId: None,
            minGoodNum: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeDiceRuleGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeDiceRuleGroupData", 2)?;
        if let Some(f) = self.ruleGroupId() {
            s.serialize_field("ruleGroupId", &f)?;
        } else {
            s.skip_field("ruleGroupId")?;
        }
        s.serialize_field("minGoodNum", &self.minGoodNum())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeDiceRuleGroupDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeDiceRuleGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_ruleGroupId(&mut self, ruleGroupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceRuleGroupData::VT_RULEGROUPID,
            ruleGroupId,
        );
    }
    #[inline]
    pub fn add_minGoodNum(&mut self, minGoodNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeDiceRuleGroupData::VT_MINGOODNUM,
            minGoodNum,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeDiceRuleGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeDiceRuleGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceRuleGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeDiceRuleGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeDiceRuleGroupData");
        ds.field("ruleGroupId", &self.ruleGroupId());
        ds.field("minGoodNum", &self.minGoodNum());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeDiceRuleGroupDataT {
    pub ruleGroupId: Option<String>,
    pub minGoodNum: i32,
}
impl Default for clz_Torappu_RoguelikeDiceRuleGroupDataT {
    fn default() -> Self {
        Self {
            ruleGroupId: None,
            minGoodNum: 0,
        }
    }
}
impl clz_Torappu_RoguelikeDiceRuleGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceRuleGroupData<'b>> {
        let ruleGroupId = self.ruleGroupId.as_ref().map(|x| _fbb.create_string(x));
        let minGoodNum = self.minGoodNum;
        clz_Torappu_RoguelikeDiceRuleGroupData::create(
            _fbb,
            &clz_Torappu_RoguelikeDiceRuleGroupDataArgs {
                ruleGroupId,
                minGoodNum,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeDiceRuleGroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeDiceRuleGroupData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeDiceRuleGroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeDiceRuleGroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeDiceRuleGroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeDiceRuleGroupData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeDiceRuleGroupData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeDiceRuleGroupData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeDiceRuleGroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDiceRuleGroupData>>(
                    dict__string__clz_Torappu_RoguelikeDiceRuleGroupData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeDiceRuleGroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDiceRuleGroupData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceRuleGroupData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeDiceRuleGroupData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeDiceRuleGroupData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeDiceRuleGroupData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceRuleGroupData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceRuleGroupData>>(
                dict__string__clz_Torappu_RoguelikeDiceRuleGroupData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeDiceRuleGroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeDiceRuleGroupData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeDiceRuleGroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeDiceRuleGroupData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeDiceRuleGroupDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeDiceRuleGroupData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeDiceRuleGroupData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeDicePredefineDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeDicePredefineData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeDicePredefineData<'a> {
    type Inner = clz_Torappu_RoguelikeDicePredefineData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeDicePredefineData<'a> {
    pub const VT_MODEID: flatbuffers::VOffsetT = 4;
    pub const VT_MODEGRADE: flatbuffers::VOffsetT = 6;
    pub const VT_PREDEFINEDID: flatbuffers::VOffsetT = 8;
    pub const VT_INITIALDICECOUNT: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeDicePredefineData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeDicePredefineDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDicePredefineData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeDicePredefineDataBuilder::new(_fbb);
        builder.add_initialDiceCount(args.initialDiceCount);
        if let Some(x) = args.predefinedId {
            builder.add_predefinedId(x);
        }
        builder.add_modeGrade(args.modeGrade);
        builder.add_modeId(args.modeId);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeDicePredefineDataT {
        let modeId = self.modeId();
        let modeGrade = self.modeGrade();
        let predefinedId = self.predefinedId().map(|x| x.to_string());
        let initialDiceCount = self.initialDiceCount();
        clz_Torappu_RoguelikeDicePredefineDataT {
            modeId,
            modeGrade,
            predefinedId,
            initialDiceCount,
        }
    }

    #[inline]
    pub fn modeId(&self) -> enum__Torappu_RoguelikeTopicMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTopicMode>(
                    clz_Torappu_RoguelikeDicePredefineData::VT_MODEID,
                    Some(enum__Torappu_RoguelikeTopicMode::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn modeGrade(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeDicePredefineData::VT_MODEGRADE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn predefinedId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDicePredefineData::VT_PREDEFINEDID,
                None,
            )
        }
    }
    #[inline]
    pub fn initialDiceCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeDicePredefineData::VT_INITIALDICECOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeDicePredefineData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeTopicMode>("modeId", Self::VT_MODEID, false)?
            .visit_field::<i32>("modeGrade", Self::VT_MODEGRADE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "predefinedId",
                Self::VT_PREDEFINEDID,
                false,
            )?
            .visit_field::<i32>("initialDiceCount", Self::VT_INITIALDICECOUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeDicePredefineDataArgs<'a> {
    pub modeId: enum__Torappu_RoguelikeTopicMode,
    pub modeGrade: i32,
    pub predefinedId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub initialDiceCount: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeDicePredefineDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeDicePredefineDataArgs {
            modeId: enum__Torappu_RoguelikeTopicMode::NONE,
            modeGrade: 0,
            predefinedId: None,
            initialDiceCount: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeDicePredefineData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeDicePredefineData", 4)?;
        s.serialize_field("modeId", &self.modeId())?;
        s.serialize_field("modeGrade", &self.modeGrade())?;
        if let Some(f) = self.predefinedId() {
            s.serialize_field("predefinedId", &f)?;
        } else {
            s.skip_field("predefinedId")?;
        }
        s.serialize_field("initialDiceCount", &self.initialDiceCount())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeDicePredefineDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeDicePredefineDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_modeId(&mut self, modeId: enum__Torappu_RoguelikeTopicMode) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeTopicMode>(
            clz_Torappu_RoguelikeDicePredefineData::VT_MODEID,
            modeId,
            enum__Torappu_RoguelikeTopicMode::NONE,
        );
    }
    #[inline]
    pub fn add_modeGrade(&mut self, modeGrade: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeDicePredefineData::VT_MODEGRADE,
            modeGrade,
            0,
        );
    }
    #[inline]
    pub fn add_predefinedId(&mut self, predefinedId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDicePredefineData::VT_PREDEFINEDID,
            predefinedId,
        );
    }
    #[inline]
    pub fn add_initialDiceCount(&mut self, initialDiceCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeDicePredefineData::VT_INITIALDICECOUNT,
            initialDiceCount,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeDicePredefineDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeDicePredefineDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDicePredefineData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeDicePredefineData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeDicePredefineData");
        ds.field("modeId", &self.modeId());
        ds.field("modeGrade", &self.modeGrade());
        ds.field("predefinedId", &self.predefinedId());
        ds.field("initialDiceCount", &self.initialDiceCount());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeDicePredefineDataT {
    pub modeId: enum__Torappu_RoguelikeTopicMode,
    pub modeGrade: i32,
    pub predefinedId: Option<String>,
    pub initialDiceCount: i32,
}
impl Default for clz_Torappu_RoguelikeDicePredefineDataT {
    fn default() -> Self {
        Self {
            modeId: enum__Torappu_RoguelikeTopicMode::NONE,
            modeGrade: 0,
            predefinedId: None,
            initialDiceCount: 0,
        }
    }
}
impl clz_Torappu_RoguelikeDicePredefineDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDicePredefineData<'b>> {
        let modeId = self.modeId;
        let modeGrade = self.modeGrade;
        let predefinedId = self.predefinedId.as_ref().map(|x| _fbb.create_string(x));
        let initialDiceCount = self.initialDiceCount;
        clz_Torappu_RoguelikeDicePredefineData::create(
            _fbb,
            &clz_Torappu_RoguelikeDicePredefineDataArgs {
                modeId,
                modeGrade,
                predefinedId,
                initialDiceCount,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeDiceModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeDiceModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeDiceModuleData<'a> {
    type Inner = clz_Torappu_RoguelikeDiceModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeDiceModuleData<'a> {
    pub const VT_DICE: flatbuffers::VOffsetT = 4;
    pub const VT_DICEEVENTS: flatbuffers::VOffsetT = 6;
    pub const VT_DICECHOICES: flatbuffers::VOffsetT = 8;
    pub const VT_DICERULEGROUPS: flatbuffers::VOffsetT = 10;
    pub const VT_DICEPREDEFINES: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeDiceModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeDiceModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceModuleData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeDiceModuleDataBuilder::new(_fbb);
        if let Some(x) = args.dicePredefines {
            builder.add_dicePredefines(x);
        }
        if let Some(x) = args.diceRuleGroups {
            builder.add_diceRuleGroups(x);
        }
        if let Some(x) = args.diceChoices {
            builder.add_diceChoices(x);
        }
        if let Some(x) = args.diceEvents {
            builder.add_diceEvents(x);
        }
        if let Some(x) = args.dice {
            builder.add_dice(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeDiceModuleDataT {
        let dice = self.dice().map(|x| x.iter().map(|t| t.unpack()).collect());
        let diceEvents = self
            .diceEvents()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let diceChoices = self
            .diceChoices()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let diceRuleGroups = self
            .diceRuleGroups()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let dicePredefines = self
            .dicePredefines()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeDiceModuleDataT {
            dice,
            diceEvents,
            diceChoices,
            diceRuleGroups,
            dicePredefines,
        }
    }

    #[inline]
    pub fn dice(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDiceData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDiceData>,
                >,
            >>(clz_Torappu_RoguelikeDiceModuleData::VT_DICE, None)
        }
    }
    #[inline]
    pub fn diceEvents(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDiceRuleData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDiceRuleData>,
                >,
            >>(clz_Torappu_RoguelikeDiceModuleData::VT_DICEEVENTS, None)
        }
    }
    #[inline]
    pub fn diceChoices(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_RoguelikeDiceModuleData::VT_DICECHOICES, None)
        }
    }
    #[inline]
    pub fn diceRuleGroups(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDiceRuleGroupData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeDiceRuleGroupData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeDiceModuleData::VT_DICERULEGROUPS, None)
        }
    }
    #[inline]
    pub fn dicePredefines(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDicePredefineData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDicePredefineData>,
                >,
            >>(clz_Torappu_RoguelikeDiceModuleData::VT_DICEPREDEFINES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeDiceModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDiceData>,
                >,
            >>("dice", Self::VT_DICE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDiceRuleData>,
                >,
            >>("diceEvents", Self::VT_DICEEVENTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>("diceChoices", Self::VT_DICECHOICES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeDiceRuleGroupData,
                    >,
                >,
            >>("diceRuleGroups", Self::VT_DICERULEGROUPS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDicePredefineData>,
                >,
            >>("dicePredefines", Self::VT_DICEPREDEFINES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeDiceModuleDataArgs<'a> {
    pub dice: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDiceData<'a>>,
            >,
        >,
    >,
    pub diceEvents: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDiceRuleData<'a>>,
            >,
        >,
    >,
    pub diceChoices: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
    pub diceRuleGroups: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeDiceRuleGroupData<'a>,
                >,
            >,
        >,
    >,
    pub dicePredefines: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDicePredefineData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeDiceModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeDiceModuleDataArgs {
            dice: None,
            diceEvents: None,
            diceChoices: None,
            diceRuleGroups: None,
            dicePredefines: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeDiceModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeDiceModuleData", 5)?;
        if let Some(f) = self.dice() {
            s.serialize_field("dice", &f)?;
        } else {
            s.skip_field("dice")?;
        }
        if let Some(f) = self.diceEvents() {
            s.serialize_field("diceEvents", &f)?;
        } else {
            s.skip_field("diceEvents")?;
        }
        if let Some(f) = self.diceChoices() {
            s.serialize_field("diceChoices", &f)?;
        } else {
            s.skip_field("diceChoices")?;
        }
        if let Some(f) = self.diceRuleGroups() {
            s.serialize_field("diceRuleGroups", &f)?;
        } else {
            s.skip_field("diceRuleGroups")?;
        }
        if let Some(f) = self.dicePredefines() {
            s.serialize_field("dicePredefines", &f)?;
        } else {
            s.skip_field("dicePredefines")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeDiceModuleDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeDiceModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_dice(
        &mut self,
        dice: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDiceData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceModuleData::VT_DICE,
            dice,
        );
    }
    #[inline]
    pub fn add_diceEvents(
        &mut self,
        diceEvents: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDiceRuleData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceModuleData::VT_DICEEVENTS,
            diceEvents,
        );
    }
    #[inline]
    pub fn add_diceChoices(
        &mut self,
        diceChoices: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceModuleData::VT_DICECHOICES,
            diceChoices,
        );
    }
    #[inline]
    pub fn add_diceRuleGroups(
        &mut self,
        diceRuleGroups: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeDiceRuleGroupData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceModuleData::VT_DICERULEGROUPS,
            diceRuleGroups,
        );
    }
    #[inline]
    pub fn add_dicePredefines(
        &mut self,
        dicePredefines: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDicePredefineData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDiceModuleData::VT_DICEPREDEFINES,
            dicePredefines,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeDiceModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeDiceModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeDiceModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeDiceModuleData");
        ds.field("dice", &self.dice());
        ds.field("diceEvents", &self.diceEvents());
        ds.field("diceChoices", &self.diceChoices());
        ds.field("diceRuleGroups", &self.diceRuleGroups());
        ds.field("dicePredefines", &self.dicePredefines());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeDiceModuleDataT {
    pub dice: Option<Vec<dict__string__clz_Torappu_RoguelikeDiceDataT>>,
    pub diceEvents: Option<Vec<dict__string__clz_Torappu_RoguelikeDiceRuleDataT>>,
    pub diceChoices: Option<Vec<dict__string__stringT>>,
    pub diceRuleGroups: Option<Vec<dict__string__clz_Torappu_RoguelikeDiceRuleGroupDataT>>,
    pub dicePredefines: Option<Vec<clz_Torappu_RoguelikeDicePredefineDataT>>,
}
impl Default for clz_Torappu_RoguelikeDiceModuleDataT {
    fn default() -> Self {
        Self {
            dice: None,
            diceEvents: None,
            diceChoices: None,
            diceRuleGroups: None,
            dicePredefines: None,
        }
    }
}
impl clz_Torappu_RoguelikeDiceModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceModuleData<'b>> {
        let dice = self.dice.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let diceEvents = self.diceEvents.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let diceChoices = self.diceChoices.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let diceRuleGroups = self.diceRuleGroups.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let dicePredefines = self.dicePredefines.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeDiceModuleData::create(
            _fbb,
            &clz_Torappu_RoguelikeDiceModuleDataArgs {
                dice,
                diceEvents,
                diceChoices,
                diceRuleGroups,
                dicePredefines,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeChaosDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeChaosData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeChaosData<'a> {
    type Inner = clz_Torappu_RoguelikeChaosData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeChaosData<'a> {
    pub const VT_CHAOSID: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;
    pub const VT_NEXTCHAOSID: flatbuffers::VOffsetT = 8;
    pub const VT_PREVCHAOSID: flatbuffers::VOffsetT = 10;
    pub const VT_ICONID: flatbuffers::VOffsetT = 12;
    pub const VT_NAME: flatbuffers::VOffsetT = 14;
    pub const VT_FUNCTIONDESC: flatbuffers::VOffsetT = 16;
    pub const VT_DESC: flatbuffers::VOffsetT = 18;
    pub const VT_SOUND: flatbuffers::VOffsetT = 20;
    pub const VT_SORTID: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeChaosData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeChaosDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeChaosDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.sound {
            builder.add_sound(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.functionDesc {
            builder.add_functionDesc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.prevChaosId {
            builder.add_prevChaosId(x);
        }
        if let Some(x) = args.nextChaosId {
            builder.add_nextChaosId(x);
        }
        builder.add_level(args.level);
        if let Some(x) = args.chaosId {
            builder.add_chaosId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeChaosDataT {
        let chaosId = self.chaosId().map(|x| x.to_string());
        let level = self.level();
        let nextChaosId = self.nextChaosId().map(|x| x.to_string());
        let prevChaosId = self.prevChaosId().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let functionDesc = self.functionDesc().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let sound = self.sound().map(|x| x.to_string());
        let sortId = self.sortId();
        clz_Torappu_RoguelikeChaosDataT {
            chaosId,
            level,
            nextChaosId,
            prevChaosId,
            iconId,
            name,
            functionDesc,
            desc,
            sound,
            sortId,
        }
    }

    #[inline]
    pub fn chaosId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeChaosData::VT_CHAOSID,
                None,
            )
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeChaosData::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn nextChaosId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeChaosData::VT_NEXTCHAOSID,
                None,
            )
        }
    }
    #[inline]
    pub fn prevChaosId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeChaosData::VT_PREVCHAOSID,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeChaosData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeChaosData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn functionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeChaosData::VT_FUNCTIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeChaosData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn sound(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeChaosData::VT_SOUND,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeChaosData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeChaosData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("chaosId", Self::VT_CHAOSID, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nextChaosId",
                Self::VT_NEXTCHAOSID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "prevChaosId",
                Self::VT_PREVCHAOSID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "functionDesc",
                Self::VT_FUNCTIONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sound", Self::VT_SOUND, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeChaosDataArgs<'a> {
    pub chaosId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub level: i32,
    pub nextChaosId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub prevChaosId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub functionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sound: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeChaosDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeChaosDataArgs {
            chaosId: None,
            level: 0,
            nextChaosId: None,
            prevChaosId: None,
            iconId: None,
            name: None,
            functionDesc: None,
            desc: None,
            sound: None,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeChaosData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeChaosData", 10)?;
        if let Some(f) = self.chaosId() {
            s.serialize_field("chaosId", &f)?;
        } else {
            s.skip_field("chaosId")?;
        }
        s.serialize_field("level", &self.level())?;
        if let Some(f) = self.nextChaosId() {
            s.serialize_field("nextChaosId", &f)?;
        } else {
            s.skip_field("nextChaosId")?;
        }
        if let Some(f) = self.prevChaosId() {
            s.serialize_field("prevChaosId", &f)?;
        } else {
            s.skip_field("prevChaosId")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.functionDesc() {
            s.serialize_field("functionDesc", &f)?;
        } else {
            s.skip_field("functionDesc")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.sound() {
            s.serialize_field("sound", &f)?;
        } else {
            s.skip_field("sound")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeChaosDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RoguelikeChaosDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_chaosId(&mut self, chaosId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChaosData::VT_CHAOSID,
            chaosId,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeChaosData::VT_LEVEL, level, 0);
    }
    #[inline]
    pub fn add_nextChaosId(&mut self, nextChaosId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChaosData::VT_NEXTCHAOSID,
            nextChaosId,
        );
    }
    #[inline]
    pub fn add_prevChaosId(&mut self, prevChaosId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChaosData::VT_PREVCHAOSID,
            prevChaosId,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChaosData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChaosData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_functionDesc(&mut self, functionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChaosData::VT_FUNCTIONDESC,
            functionDesc,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChaosData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_sound(&mut self, sound: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChaosData::VT_SOUND,
            sound,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeChaosData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeChaosDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeChaosDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeChaosData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeChaosData");
        ds.field("chaosId", &self.chaosId());
        ds.field("level", &self.level());
        ds.field("nextChaosId", &self.nextChaosId());
        ds.field("prevChaosId", &self.prevChaosId());
        ds.field("iconId", &self.iconId());
        ds.field("name", &self.name());
        ds.field("functionDesc", &self.functionDesc());
        ds.field("desc", &self.desc());
        ds.field("sound", &self.sound());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeChaosDataT {
    pub chaosId: Option<String>,
    pub level: i32,
    pub nextChaosId: Option<String>,
    pub prevChaosId: Option<String>,
    pub iconId: Option<String>,
    pub name: Option<String>,
    pub functionDesc: Option<String>,
    pub desc: Option<String>,
    pub sound: Option<String>,
    pub sortId: i32,
}
impl Default for clz_Torappu_RoguelikeChaosDataT {
    fn default() -> Self {
        Self {
            chaosId: None,
            level: 0,
            nextChaosId: None,
            prevChaosId: None,
            iconId: None,
            name: None,
            functionDesc: None,
            desc: None,
            sound: None,
            sortId: 0,
        }
    }
}
impl clz_Torappu_RoguelikeChaosDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosData<'b>> {
        let chaosId = self.chaosId.as_ref().map(|x| _fbb.create_string(x));
        let level = self.level;
        let nextChaosId = self.nextChaosId.as_ref().map(|x| _fbb.create_string(x));
        let prevChaosId = self.prevChaosId.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let functionDesc = self.functionDesc.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let sound = self.sound.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        clz_Torappu_RoguelikeChaosData::create(
            _fbb,
            &clz_Torappu_RoguelikeChaosDataArgs {
                chaosId,
                level,
                nextChaosId,
                prevChaosId,
                iconId,
                name,
                functionDesc,
                desc,
                sound,
                sortId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeChaosDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeChaosData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeChaosData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeChaosData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeChaosData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeChaosData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeChaosDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeChaosData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeChaosDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeChaosDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeChaosDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeChaosData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_RoguelikeChaosData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeChaosData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeChaosData>>(
                    dict__string__clz_Torappu_RoguelikeChaosData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeChaosData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeChaosData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeChaosDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeChaosDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeChaosDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeChaosData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeChaosData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeChaosDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeChaosDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeChaosData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosData>>(
                dict__string__clz_Torappu_RoguelikeChaosData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeChaosDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeChaosDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeChaosData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeChaosData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeChaosData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeChaosData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeChaosDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeChaosDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeChaosDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeChaosDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeChaosData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeChaosData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeChaosDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeChaosRangeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeChaosRangeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeChaosRangeData<'a> {
    type Inner = clz_Torappu_RoguelikeChaosRangeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeChaosRangeData<'a> {
    pub const VT_CHAOSMAX: flatbuffers::VOffsetT = 4;
    pub const VT_CHAOSDUNGEONEFFECT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeChaosRangeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeChaosRangeDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosRangeData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeChaosRangeDataBuilder::new(_fbb);
        builder.add_chaosDungeonEffect(args.chaosDungeonEffect);
        builder.add_chaosMax(args.chaosMax);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeChaosRangeDataT {
        let chaosMax = self.chaosMax();
        let chaosDungeonEffect = self.chaosDungeonEffect();
        clz_Torappu_RoguelikeChaosRangeDataT {
            chaosMax,
            chaosDungeonEffect,
        }
    }

    #[inline]
    pub fn chaosMax(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeChaosRangeData::VT_CHAOSMAX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn chaosDungeonEffect(&self) -> enum__Torappu_ChaosEffectRank {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ChaosEffectRank>(
                    clz_Torappu_RoguelikeChaosRangeData::VT_CHAOSDUNGEONEFFECT,
                    Some(enum__Torappu_ChaosEffectRank::CHAOS_EFFECT_0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeChaosRangeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("chaosMax", Self::VT_CHAOSMAX, false)?
            .visit_field::<enum__Torappu_ChaosEffectRank>(
                "chaosDungeonEffect",
                Self::VT_CHAOSDUNGEONEFFECT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeChaosRangeDataArgs {
    pub chaosMax: i32,
    pub chaosDungeonEffect: enum__Torappu_ChaosEffectRank,
}
impl<'a> Default for clz_Torappu_RoguelikeChaosRangeDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeChaosRangeDataArgs {
            chaosMax: 0,
            chaosDungeonEffect: enum__Torappu_ChaosEffectRank::CHAOS_EFFECT_0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeChaosRangeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeChaosRangeData", 2)?;
        s.serialize_field("chaosMax", &self.chaosMax())?;
        s.serialize_field("chaosDungeonEffect", &self.chaosDungeonEffect())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeChaosRangeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeChaosRangeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_chaosMax(&mut self, chaosMax: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeChaosRangeData::VT_CHAOSMAX,
            chaosMax,
            0,
        );
    }
    #[inline]
    pub fn add_chaosDungeonEffect(&mut self, chaosDungeonEffect: enum__Torappu_ChaosEffectRank) {
        self.fbb_.push_slot::<enum__Torappu_ChaosEffectRank>(
            clz_Torappu_RoguelikeChaosRangeData::VT_CHAOSDUNGEONEFFECT,
            chaosDungeonEffect,
            enum__Torappu_ChaosEffectRank::CHAOS_EFFECT_0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeChaosRangeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeChaosRangeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosRangeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeChaosRangeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeChaosRangeData");
        ds.field("chaosMax", &self.chaosMax());
        ds.field("chaosDungeonEffect", &self.chaosDungeonEffect());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeChaosRangeDataT {
    pub chaosMax: i32,
    pub chaosDungeonEffect: enum__Torappu_ChaosEffectRank,
}
impl Default for clz_Torappu_RoguelikeChaosRangeDataT {
    fn default() -> Self {
        Self {
            chaosMax: 0,
            chaosDungeonEffect: enum__Torappu_ChaosEffectRank::CHAOS_EFFECT_0,
        }
    }
}
impl clz_Torappu_RoguelikeChaosRangeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosRangeData<'b>> {
        let chaosMax = self.chaosMax;
        let chaosDungeonEffect = self.chaosDungeonEffect;
        clz_Torappu_RoguelikeChaosRangeData::create(
            _fbb,
            &clz_Torappu_RoguelikeChaosRangeDataArgs {
                chaosMax,
                chaosDungeonEffect,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeChaosPredefineLevelInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a> {
    type Inner = clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a> {
    pub const VT_CHAOSLEVELBEGINNUM: flatbuffers::VOffsetT = 4;
    pub const VT_CHAOSLEVELENDNUM: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeChaosPredefineLevelInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeChaosPredefineLevelInfoArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosPredefineLevelInfo<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeChaosPredefineLevelInfoBuilder::new(_fbb);
        builder.add_chaosLevelEndNum(args.chaosLevelEndNum);
        builder.add_chaosLevelBeginNum(args.chaosLevelBeginNum);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeChaosPredefineLevelInfoT {
        let chaosLevelBeginNum = self.chaosLevelBeginNum();
        let chaosLevelEndNum = self.chaosLevelEndNum();
        clz_Torappu_RoguelikeChaosPredefineLevelInfoT {
            chaosLevelBeginNum,
            chaosLevelEndNum,
        }
    }

    #[inline]
    pub fn chaosLevelBeginNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeChaosPredefineLevelInfo::VT_CHAOSLEVELBEGINNUM,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn chaosLevelEndNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeChaosPredefineLevelInfo::VT_CHAOSLEVELENDNUM,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeChaosPredefineLevelInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("chaosLevelBeginNum", Self::VT_CHAOSLEVELBEGINNUM, false)?
            .visit_field::<i32>("chaosLevelEndNum", Self::VT_CHAOSLEVELENDNUM, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeChaosPredefineLevelInfoArgs {
    pub chaosLevelBeginNum: i32,
    pub chaosLevelEndNum: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeChaosPredefineLevelInfoArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeChaosPredefineLevelInfoArgs {
            chaosLevelBeginNum: 0,
            chaosLevelEndNum: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeChaosPredefineLevelInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeChaosPredefineLevelInfo", 2)?;
        s.serialize_field("chaosLevelBeginNum", &self.chaosLevelBeginNum())?;
        s.serialize_field("chaosLevelEndNum", &self.chaosLevelEndNum())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeChaosPredefineLevelInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeChaosPredefineLevelInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_chaosLevelBeginNum(&mut self, chaosLevelBeginNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeChaosPredefineLevelInfo::VT_CHAOSLEVELBEGINNUM,
            chaosLevelBeginNum,
            0,
        );
    }
    #[inline]
    pub fn add_chaosLevelEndNum(&mut self, chaosLevelEndNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeChaosPredefineLevelInfo::VT_CHAOSLEVELENDNUM,
            chaosLevelEndNum,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeChaosPredefineLevelInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeChaosPredefineLevelInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeChaosPredefineLevelInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeChaosPredefineLevelInfo");
        ds.field("chaosLevelBeginNum", &self.chaosLevelBeginNum());
        ds.field("chaosLevelEndNum", &self.chaosLevelEndNum());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeChaosPredefineLevelInfoT {
    pub chaosLevelBeginNum: i32,
    pub chaosLevelEndNum: i32,
}
impl Default for clz_Torappu_RoguelikeChaosPredefineLevelInfoT {
    fn default() -> Self {
        Self {
            chaosLevelBeginNum: 0,
            chaosLevelEndNum: 0,
        }
    }
}
impl clz_Torappu_RoguelikeChaosPredefineLevelInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosPredefineLevelInfo<'b>> {
        let chaosLevelBeginNum = self.chaosLevelBeginNum;
        let chaosLevelEndNum = self.chaosLevelEndNum;
        clz_Torappu_RoguelikeChaosPredefineLevelInfo::create(
            _fbb,
            &clz_Torappu_RoguelikeChaosPredefineLevelInfoArgs {
                chaosLevelBeginNum,
                chaosLevelEndNum,
            },
        )
    }
}
pub enum dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a> {
    type Inner = dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'bldr>>
    {
        let mut builder = dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoT {
        let key = self.key();
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeChaosPredefineLevelInfo>>(
                    dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<i32>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeChaosPredefineLevelInfo>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoArgs<'a> {
    pub key: i32,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a>>>,
}
impl<'a> Default for dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoArgs {
            key: 0,
            value: None,
        }
    }
}

impl Serialize for dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosPredefineLevelInfo<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosPredefineLevelInfo>>(dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoT {
    pub key: i32,
    pub value: Option<Box<clz_Torappu_RoguelikeChaosPredefineLevelInfoT>>,
}
impl Default for dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoT {
    fn default() -> Self {
        Self {
            key: 0,
            value: None,
        }
    }
}
impl dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'b>> {
        let key = self.key;
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo::create(
            _fbb,
            &dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoArgs { key, value },
        )
    }
}
pub enum dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a>
{
    type Inner = dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoArgs<
            'args,
        >,
    ) -> flatbuffers::WIPOffset<
        dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'bldr>,
    > {
        let mut builder =
            dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoBuilder::new(
                _fbb,
            );
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(
        &self,
    ) -> dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo::VT_KEY, None).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo>>>>(dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo,
                    >,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default
    for dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoBuilder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo",
        );
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoT {
    pub key: String,
    pub value: Option<Vec<dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoT>>,
}
impl Default for dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'b>,
    > {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo::create(
            _fbb,
            &dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoArgs {
                key,
                value,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeChaosModuleConstsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeChaosModuleConsts<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeChaosModuleConsts<'a> {
    type Inner = clz_Torappu_RoguelikeChaosModuleConsts<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeChaosModuleConsts<'a> {
    pub const VT_MAXCHAOSLEVEL: flatbuffers::VOffsetT = 4;
    pub const VT_MAXCHAOSSLOT: flatbuffers::VOffsetT = 6;
    pub const VT_CHAOSNOTMAXDESCRIPTION: flatbuffers::VOffsetT = 8;
    pub const VT_CHAOSMAXDESCRIPTION: flatbuffers::VOffsetT = 10;
    pub const VT_CHAOSPREDICTDESCRIPTION: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeChaosModuleConsts { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeChaosModuleConstsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosModuleConsts<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeChaosModuleConstsBuilder::new(_fbb);
        if let Some(x) = args.chaosPredictDescription {
            builder.add_chaosPredictDescription(x);
        }
        if let Some(x) = args.chaosMaxDescription {
            builder.add_chaosMaxDescription(x);
        }
        if let Some(x) = args.chaosNotMaxDescription {
            builder.add_chaosNotMaxDescription(x);
        }
        builder.add_maxChaosSlot(args.maxChaosSlot);
        builder.add_maxChaosLevel(args.maxChaosLevel);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeChaosModuleConstsT {
        let maxChaosLevel = self.maxChaosLevel();
        let maxChaosSlot = self.maxChaosSlot();
        let chaosNotMaxDescription = self.chaosNotMaxDescription().map(|x| x.to_string());
        let chaosMaxDescription = self.chaosMaxDescription().map(|x| x.to_string());
        let chaosPredictDescription = self.chaosPredictDescription().map(|x| x.to_string());
        clz_Torappu_RoguelikeChaosModuleConstsT {
            maxChaosLevel,
            maxChaosSlot,
            chaosNotMaxDescription,
            chaosMaxDescription,
            chaosPredictDescription,
        }
    }

    #[inline]
    pub fn maxChaosLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeChaosModuleConsts::VT_MAXCHAOSLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxChaosSlot(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeChaosModuleConsts::VT_MAXCHAOSSLOT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn chaosNotMaxDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeChaosModuleConsts::VT_CHAOSNOTMAXDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn chaosMaxDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeChaosModuleConsts::VT_CHAOSMAXDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn chaosPredictDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeChaosModuleConsts::VT_CHAOSPREDICTDESCRIPTION,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeChaosModuleConsts<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("maxChaosLevel", Self::VT_MAXCHAOSLEVEL, false)?
            .visit_field::<i32>("maxChaosSlot", Self::VT_MAXCHAOSSLOT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "chaosNotMaxDescription",
                Self::VT_CHAOSNOTMAXDESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "chaosMaxDescription",
                Self::VT_CHAOSMAXDESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "chaosPredictDescription",
                Self::VT_CHAOSPREDICTDESCRIPTION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeChaosModuleConstsArgs<'a> {
    pub maxChaosLevel: i32,
    pub maxChaosSlot: i32,
    pub chaosNotMaxDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub chaosMaxDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub chaosPredictDescription: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeChaosModuleConstsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeChaosModuleConstsArgs {
            maxChaosLevel: 0,
            maxChaosSlot: 0,
            chaosNotMaxDescription: None,
            chaosMaxDescription: None,
            chaosPredictDescription: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeChaosModuleConsts<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeChaosModuleConsts", 5)?;
        s.serialize_field("maxChaosLevel", &self.maxChaosLevel())?;
        s.serialize_field("maxChaosSlot", &self.maxChaosSlot())?;
        if let Some(f) = self.chaosNotMaxDescription() {
            s.serialize_field("chaosNotMaxDescription", &f)?;
        } else {
            s.skip_field("chaosNotMaxDescription")?;
        }
        if let Some(f) = self.chaosMaxDescription() {
            s.serialize_field("chaosMaxDescription", &f)?;
        } else {
            s.skip_field("chaosMaxDescription")?;
        }
        if let Some(f) = self.chaosPredictDescription() {
            s.serialize_field("chaosPredictDescription", &f)?;
        } else {
            s.skip_field("chaosPredictDescription")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeChaosModuleConstsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeChaosModuleConstsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_maxChaosLevel(&mut self, maxChaosLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeChaosModuleConsts::VT_MAXCHAOSLEVEL,
            maxChaosLevel,
            0,
        );
    }
    #[inline]
    pub fn add_maxChaosSlot(&mut self, maxChaosSlot: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeChaosModuleConsts::VT_MAXCHAOSSLOT,
            maxChaosSlot,
            0,
        );
    }
    #[inline]
    pub fn add_chaosNotMaxDescription(
        &mut self,
        chaosNotMaxDescription: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChaosModuleConsts::VT_CHAOSNOTMAXDESCRIPTION,
            chaosNotMaxDescription,
        );
    }
    #[inline]
    pub fn add_chaosMaxDescription(
        &mut self,
        chaosMaxDescription: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChaosModuleConsts::VT_CHAOSMAXDESCRIPTION,
            chaosMaxDescription,
        );
    }
    #[inline]
    pub fn add_chaosPredictDescription(
        &mut self,
        chaosPredictDescription: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChaosModuleConsts::VT_CHAOSPREDICTDESCRIPTION,
            chaosPredictDescription,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeChaosModuleConstsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeChaosModuleConstsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosModuleConsts<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeChaosModuleConsts<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeChaosModuleConsts");
        ds.field("maxChaosLevel", &self.maxChaosLevel());
        ds.field("maxChaosSlot", &self.maxChaosSlot());
        ds.field("chaosNotMaxDescription", &self.chaosNotMaxDescription());
        ds.field("chaosMaxDescription", &self.chaosMaxDescription());
        ds.field("chaosPredictDescription", &self.chaosPredictDescription());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeChaosModuleConstsT {
    pub maxChaosLevel: i32,
    pub maxChaosSlot: i32,
    pub chaosNotMaxDescription: Option<String>,
    pub chaosMaxDescription: Option<String>,
    pub chaosPredictDescription: Option<String>,
}
impl Default for clz_Torappu_RoguelikeChaosModuleConstsT {
    fn default() -> Self {
        Self {
            maxChaosLevel: 0,
            maxChaosSlot: 0,
            chaosNotMaxDescription: None,
            chaosMaxDescription: None,
            chaosPredictDescription: None,
        }
    }
}
impl clz_Torappu_RoguelikeChaosModuleConstsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosModuleConsts<'b>> {
        let maxChaosLevel = self.maxChaosLevel;
        let maxChaosSlot = self.maxChaosSlot;
        let chaosNotMaxDescription = self
            .chaosNotMaxDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let chaosMaxDescription = self
            .chaosMaxDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let chaosPredictDescription = self
            .chaosPredictDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeChaosModuleConsts::create(
            _fbb,
            &clz_Torappu_RoguelikeChaosModuleConstsArgs {
                maxChaosLevel,
                maxChaosSlot,
                chaosNotMaxDescription,
                chaosMaxDescription,
                chaosPredictDescription,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeChaosModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeChaosModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeChaosModuleData<'a> {
    type Inner = clz_Torappu_RoguelikeChaosModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeChaosModuleData<'a> {
    pub const VT_CHAOSDATAS: flatbuffers::VOffsetT = 4;
    pub const VT_CHAOSRANGES: flatbuffers::VOffsetT = 6;
    pub const VT_LEVELINFODICT: flatbuffers::VOffsetT = 8;
    pub const VT_MODULECONSTS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeChaosModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeChaosModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosModuleData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeChaosModuleDataBuilder::new(_fbb);
        if let Some(x) = args.moduleConsts {
            builder.add_moduleConsts(x);
        }
        if let Some(x) = args.levelInfoDict {
            builder.add_levelInfoDict(x);
        }
        if let Some(x) = args.chaosRanges {
            builder.add_chaosRanges(x);
        }
        if let Some(x) = args.chaosDatas {
            builder.add_chaosDatas(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeChaosModuleDataT {
        let chaosDatas = self
            .chaosDatas()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let chaosRanges = self
            .chaosRanges()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let levelInfoDict = self
            .levelInfoDict()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let moduleConsts = self.moduleConsts().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeChaosModuleDataT {
            chaosDatas,
            chaosRanges,
            levelInfoDict,
            moduleConsts,
        }
    }

    #[inline]
    pub fn chaosDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeChaosData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeChaosData>,
                >,
            >>(clz_Torappu_RoguelikeChaosModuleData::VT_CHAOSDATAS, None)
        }
    }
    #[inline]
    pub fn chaosRanges(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeChaosRangeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeChaosRangeData>,
                >,
            >>(clz_Torappu_RoguelikeChaosModuleData::VT_CHAOSRANGES, None)
        }
    }
    #[inline]
    pub fn levelInfoDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo,
                    >,
                >,
            >>(clz_Torappu_RoguelikeChaosModuleData::VT_LEVELINFODICT, None)
        }
    }
    #[inline]
    pub fn moduleConsts(&self) -> Option<clz_Torappu_RoguelikeChaosModuleConsts<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeChaosModuleConsts>>(
                    clz_Torappu_RoguelikeChaosModuleData::VT_MODULECONSTS,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeChaosModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeChaosData>,
                >,
            >>("chaosDatas", Self::VT_CHAOSDATAS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeChaosRangeData>,
                >,
            >>("chaosRanges", Self::VT_CHAOSRANGES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo,
                    >,
                >,
            >>("levelInfoDict", Self::VT_LEVELINFODICT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeChaosModuleConsts>>(
                "moduleConsts",
                Self::VT_MODULECONSTS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeChaosModuleDataArgs<'a> {
    pub chaosDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeChaosData<'a>>,
            >,
        >,
    >,
    pub chaosRanges: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeChaosRangeData<'a>>,
            >,
        >,
    >,
    pub levelInfoDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'a>,
                >,
            >,
        >,
    >,
    pub moduleConsts: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosModuleConsts<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeChaosModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeChaosModuleDataArgs {
            chaosDatas: None,
            chaosRanges: None,
            levelInfoDict: None,
            moduleConsts: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeChaosModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeChaosModuleData", 4)?;
        if let Some(f) = self.chaosDatas() {
            s.serialize_field("chaosDatas", &f)?;
        } else {
            s.skip_field("chaosDatas")?;
        }
        if let Some(f) = self.chaosRanges() {
            s.serialize_field("chaosRanges", &f)?;
        } else {
            s.skip_field("chaosRanges")?;
        }
        if let Some(f) = self.levelInfoDict() {
            s.serialize_field("levelInfoDict", &f)?;
        } else {
            s.skip_field("levelInfoDict")?;
        }
        if let Some(f) = self.moduleConsts() {
            s.serialize_field("moduleConsts", &f)?;
        } else {
            s.skip_field("moduleConsts")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeChaosModuleDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeChaosModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_chaosDatas(
        &mut self,
        chaosDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeChaosData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChaosModuleData::VT_CHAOSDATAS,
            chaosDatas,
        );
    }
    #[inline]
    pub fn add_chaosRanges(
        &mut self,
        chaosRanges: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeChaosRangeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChaosModuleData::VT_CHAOSRANGES,
            chaosRanges,
        );
    }
    #[inline]
    pub fn add_levelInfoDict(
        &mut self,
        levelInfoDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfo<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeChaosModuleData::VT_LEVELINFODICT,
            levelInfoDict,
        );
    }
    #[inline]
    pub fn add_moduleConsts(
        &mut self,
        moduleConsts: flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosModuleConsts<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosModuleConsts>>(
                clz_Torappu_RoguelikeChaosModuleData::VT_MODULECONSTS,
                moduleConsts,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeChaosModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeChaosModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeChaosModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeChaosModuleData");
        ds.field("chaosDatas", &self.chaosDatas());
        ds.field("chaosRanges", &self.chaosRanges());
        ds.field("levelInfoDict", &self.levelInfoDict());
        ds.field("moduleConsts", &self.moduleConsts());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeChaosModuleDataT {
    pub chaosDatas: Option<Vec<dict__string__clz_Torappu_RoguelikeChaosDataT>>,
    pub chaosRanges: Option<Vec<clz_Torappu_RoguelikeChaosRangeDataT>>,
    pub levelInfoDict:
        Option<Vec<dict__string__list_dict__int__clz_Torappu_RoguelikeChaosPredefineLevelInfoT>>,
    pub moduleConsts: Option<Box<clz_Torappu_RoguelikeChaosModuleConstsT>>,
}
impl Default for clz_Torappu_RoguelikeChaosModuleDataT {
    fn default() -> Self {
        Self {
            chaosDatas: None,
            chaosRanges: None,
            levelInfoDict: None,
            moduleConsts: None,
        }
    }
}
impl clz_Torappu_RoguelikeChaosModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosModuleData<'b>> {
        let chaosDatas = self.chaosDatas.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let chaosRanges = self.chaosRanges.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let levelInfoDict = self.levelInfoDict.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let moduleConsts = self.moduleConsts.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeChaosModuleData::create(
            _fbb,
            &clz_Torappu_RoguelikeChaosModuleDataArgs {
                chaosDatas,
                chaosRanges,
                levelInfoDict,
                moduleConsts,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTotemLinkedNodeTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'a> {
    type Inner = clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'a> {
    pub const VT_EFFECTIVENODETYPES: flatbuffers::VOffsetT = 4;
    pub const VT_BLURNODETYPES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTotemLinkedNodeTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTotemLinkedNodeTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTotemLinkedNodeTypeDataBuilder::new(_fbb);
        if let Some(x) = args.blurNodeTypes {
            builder.add_blurNodeTypes(x);
        }
        if let Some(x) = args.effectiveNodeTypes {
            builder.add_effectiveNodeTypes(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTotemLinkedNodeTypeDataT {
        let effectiveNodeTypes = self.effectiveNodeTypes().map(|x| x.into_iter().collect());
        let blurNodeTypes = self.blurNodeTypes().map(|x| x.into_iter().collect());
        clz_Torappu_RoguelikeTotemLinkedNodeTypeDataT {
            effectiveNodeTypes,
            blurNodeTypes,
        }
    }

    #[inline]
    pub fn effectiveNodeTypes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_RoguelikeEventType>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_RoguelikeEventType>,
            >>(
                clz_Torappu_RoguelikeTotemLinkedNodeTypeData::VT_EFFECTIVENODETYPES,
                None,
            )
        }
    }
    #[inline]
    pub fn blurNodeTypes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_RoguelikeTotemBlurNodeType>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_RoguelikeTotemBlurNodeType>,
            >>(
                clz_Torappu_RoguelikeTotemLinkedNodeTypeData::VT_BLURNODETYPES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_RoguelikeEventType>>>("effectiveNodeTypes", Self::VT_EFFECTIVENODETYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_RoguelikeTotemBlurNodeType>>>("blurNodeTypes", Self::VT_BLURNODETYPES, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTotemLinkedNodeTypeDataArgs<'a> {
    pub effectiveNodeTypes:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_RoguelikeEventType>>>,
    pub blurNodeTypes: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_RoguelikeTotemBlurNodeType>>,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeTotemLinkedNodeTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTotemLinkedNodeTypeDataArgs {
            effectiveNodeTypes: None,
            blurNodeTypes: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeTotemLinkedNodeTypeData", 2)?;
        if let Some(f) = self.effectiveNodeTypes() {
            s.serialize_field("effectiveNodeTypes", &f)?;
        } else {
            s.skip_field("effectiveNodeTypes")?;
        }
        if let Some(f) = self.blurNodeTypes() {
            s.serialize_field("blurNodeTypes", &f)?;
        } else {
            s.skip_field("blurNodeTypes")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTotemLinkedNodeTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTotemLinkedNodeTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_effectiveNodeTypes(
        &mut self,
        effectiveNodeTypes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_RoguelikeEventType>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemLinkedNodeTypeData::VT_EFFECTIVENODETYPES,
            effectiveNodeTypes,
        );
    }
    #[inline]
    pub fn add_blurNodeTypes(
        &mut self,
        blurNodeTypes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_RoguelikeTotemBlurNodeType>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemLinkedNodeTypeData::VT_BLURNODETYPES,
            blurNodeTypes,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTotemLinkedNodeTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTotemLinkedNodeTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTotemLinkedNodeTypeData");
        ds.field("effectiveNodeTypes", &self.effectiveNodeTypes());
        ds.field("blurNodeTypes", &self.blurNodeTypes());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTotemLinkedNodeTypeDataT {
    pub effectiveNodeTypes: Option<Vec<enum__Torappu_RoguelikeEventType>>,
    pub blurNodeTypes: Option<Vec<enum__Torappu_RoguelikeTotemBlurNodeType>>,
}
impl Default for clz_Torappu_RoguelikeTotemLinkedNodeTypeDataT {
    fn default() -> Self {
        Self {
            effectiveNodeTypes: None,
            blurNodeTypes: None,
        }
    }
}
impl clz_Torappu_RoguelikeTotemLinkedNodeTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'b>> {
        let effectiveNodeTypes = self
            .effectiveNodeTypes
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let blurNodeTypes = self.blurNodeTypes.as_ref().map(|x| _fbb.create_vector(x));
        clz_Torappu_RoguelikeTotemLinkedNodeTypeData::create(
            _fbb,
            &clz_Torappu_RoguelikeTotemLinkedNodeTypeDataArgs {
                effectiveNodeTypes,
                blurNodeTypes,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTotemBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTotemBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTotemBuffData<'a> {
    type Inner = clz_Torappu_RoguelikeTotemBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTotemBuffData<'a> {
    pub const VT_TOTEMID: flatbuffers::VOffsetT = 4;
    pub const VT_COLOR: flatbuffers::VOffsetT = 6;
    pub const VT_POS: flatbuffers::VOffsetT = 8;
    pub const VT_RHYTHM: flatbuffers::VOffsetT = 10;
    pub const VT_NORMALDESC: flatbuffers::VOffsetT = 12;
    pub const VT_SYNERGYDESC: flatbuffers::VOffsetT = 14;
    pub const VT_ARCHIVEDESC: flatbuffers::VOffsetT = 16;
    pub const VT_COMBINEGROUPNAME: flatbuffers::VOffsetT = 18;
    pub const VT_BGICONID: flatbuffers::VOffsetT = 20;
    pub const VT_ISMANUAL: flatbuffers::VOffsetT = 22;
    pub const VT_LINKEDNODETYPEDATA: flatbuffers::VOffsetT = 24;
    pub const VT_DISTANCEMIN: flatbuffers::VOffsetT = 26;
    pub const VT_DISTANCEMAX: flatbuffers::VOffsetT = 28;
    pub const VT_VERTPASSABLE: flatbuffers::VOffsetT = 30;
    pub const VT_EXPANDLENGTH: flatbuffers::VOffsetT = 32;
    pub const VT_ONLYFORVERT: flatbuffers::VOffsetT = 34;
    pub const VT_PORTALLINKEDNODETYPEDATA: flatbuffers::VOffsetT = 36;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTotemBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTotemBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemBuffData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTotemBuffDataBuilder::new(_fbb);
        if let Some(x) = args.portalLinkedNodeTypeData {
            builder.add_portalLinkedNodeTypeData(x);
        }
        builder.add_expandLength(args.expandLength);
        builder.add_distanceMax(args.distanceMax);
        builder.add_distanceMin(args.distanceMin);
        if let Some(x) = args.linkedNodeTypeData {
            builder.add_linkedNodeTypeData(x);
        }
        if let Some(x) = args.bgIconId {
            builder.add_bgIconId(x);
        }
        if let Some(x) = args.combineGroupName {
            builder.add_combineGroupName(x);
        }
        if let Some(x) = args.archiveDesc {
            builder.add_archiveDesc(x);
        }
        if let Some(x) = args.synergyDesc {
            builder.add_synergyDesc(x);
        }
        if let Some(x) = args.normalDesc {
            builder.add_normalDesc(x);
        }
        if let Some(x) = args.rhythm {
            builder.add_rhythm(x);
        }
        builder.add_pos(args.pos);
        builder.add_color(args.color);
        if let Some(x) = args.totemId {
            builder.add_totemId(x);
        }
        builder.add_onlyForVert(args.onlyForVert);
        builder.add_vertPassable(args.vertPassable);
        builder.add_isManual(args.isManual);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTotemBuffDataT {
        let totemId = self.totemId().map(|x| x.to_string());
        let color = self.color();
        let pos = self.pos();
        let rhythm = self.rhythm().map(|x| x.to_string());
        let normalDesc = self.normalDesc().map(|x| x.to_string());
        let synergyDesc = self.synergyDesc().map(|x| x.to_string());
        let archiveDesc = self.archiveDesc().map(|x| x.to_string());
        let combineGroupName = self.combineGroupName().map(|x| x.to_string());
        let bgIconId = self.bgIconId().map(|x| x.to_string());
        let isManual = self.isManual();
        let linkedNodeTypeData = self.linkedNodeTypeData().map(|x| Box::new(x.unpack()));
        let distanceMin = self.distanceMin();
        let distanceMax = self.distanceMax();
        let vertPassable = self.vertPassable();
        let expandLength = self.expandLength();
        let onlyForVert = self.onlyForVert();
        let portalLinkedNodeTypeData = self
            .portalLinkedNodeTypeData()
            .map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeTotemBuffDataT {
            totemId,
            color,
            pos,
            rhythm,
            normalDesc,
            synergyDesc,
            archiveDesc,
            combineGroupName,
            bgIconId,
            isManual,
            linkedNodeTypeData,
            distanceMin,
            distanceMax,
            vertPassable,
            expandLength,
            onlyForVert,
            portalLinkedNodeTypeData,
        }
    }

    #[inline]
    pub fn totemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemBuffData::VT_TOTEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn color(&self) -> enum__Torappu_RoguelikeTotemColorType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTotemColorType>(
                    clz_Torappu_RoguelikeTotemBuffData::VT_COLOR,
                    Some(enum__Torappu_RoguelikeTotemColorType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn pos(&self) -> enum__Torappu_RoguelikeTotemPosType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTotemPosType>(
                    clz_Torappu_RoguelikeTotemBuffData::VT_POS,
                    Some(enum__Torappu_RoguelikeTotemPosType::LOCATION),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rhythm(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemBuffData::VT_RHYTHM,
                None,
            )
        }
    }
    #[inline]
    pub fn normalDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemBuffData::VT_NORMALDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn synergyDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemBuffData::VT_SYNERGYDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn archiveDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemBuffData::VT_ARCHIVEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn combineGroupName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemBuffData::VT_COMBINEGROUPNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn bgIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemBuffData::VT_BGICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn isManual(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_RoguelikeTotemBuffData::VT_ISMANUAL, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn linkedNodeTypeData(&self) -> Option<clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTotemLinkedNodeTypeData>>(
                    clz_Torappu_RoguelikeTotemBuffData::VT_LINKEDNODETYPEDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn distanceMin(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTotemBuffData::VT_DISTANCEMIN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn distanceMax(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTotemBuffData::VT_DISTANCEMAX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn vertPassable(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeTotemBuffData::VT_VERTPASSABLE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn expandLength(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTotemBuffData::VT_EXPANDLENGTH, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn onlyForVert(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeTotemBuffData::VT_ONLYFORVERT,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn portalLinkedNodeTypeData(
        &self,
    ) -> Option<clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTotemLinkedNodeTypeData>>(
                    clz_Torappu_RoguelikeTotemBuffData::VT_PORTALLINKEDNODETYPEDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTotemBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("totemId", Self::VT_TOTEMID, false)?
     .visit_field::<enum__Torappu_RoguelikeTotemColorType>("color", Self::VT_COLOR, false)?
     .visit_field::<enum__Torappu_RoguelikeTotemPosType>("pos", Self::VT_POS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rhythm", Self::VT_RHYTHM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("normalDesc", Self::VT_NORMALDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("synergyDesc", Self::VT_SYNERGYDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("archiveDesc", Self::VT_ARCHIVEDESC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("combineGroupName", Self::VT_COMBINEGROUPNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bgIconId", Self::VT_BGICONID, false)?
     .visit_field::<bool>("isManual", Self::VT_ISMANUAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTotemLinkedNodeTypeData>>("linkedNodeTypeData", Self::VT_LINKEDNODETYPEDATA, false)?
     .visit_field::<i32>("distanceMin", Self::VT_DISTANCEMIN, false)?
     .visit_field::<i32>("distanceMax", Self::VT_DISTANCEMAX, false)?
     .visit_field::<bool>("vertPassable", Self::VT_VERTPASSABLE, false)?
     .visit_field::<i32>("expandLength", Self::VT_EXPANDLENGTH, false)?
     .visit_field::<bool>("onlyForVert", Self::VT_ONLYFORVERT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTotemLinkedNodeTypeData>>("portalLinkedNodeTypeData", Self::VT_PORTALLINKEDNODETYPEDATA, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTotemBuffDataArgs<'a> {
    pub totemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub color: enum__Torappu_RoguelikeTotemColorType,
    pub pos: enum__Torappu_RoguelikeTotemPosType,
    pub rhythm: Option<flatbuffers::WIPOffset<&'a str>>,
    pub normalDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub synergyDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub archiveDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub combineGroupName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bgIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isManual: bool,
    pub linkedNodeTypeData:
        Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'a>>>,
    pub distanceMin: i32,
    pub distanceMax: i32,
    pub vertPassable: bool,
    pub expandLength: i32,
    pub onlyForVert: bool,
    pub portalLinkedNodeTypeData:
        Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTotemBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTotemBuffDataArgs {
            totemId: None,
            color: enum__Torappu_RoguelikeTotemColorType::NONE,
            pos: enum__Torappu_RoguelikeTotemPosType::LOCATION,
            rhythm: None,
            normalDesc: None,
            synergyDesc: None,
            archiveDesc: None,
            combineGroupName: None,
            bgIconId: None,
            isManual: false,
            linkedNodeTypeData: None,
            distanceMin: 0,
            distanceMax: 0,
            vertPassable: false,
            expandLength: 0,
            onlyForVert: false,
            portalLinkedNodeTypeData: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTotemBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTotemBuffData", 17)?;
        if let Some(f) = self.totemId() {
            s.serialize_field("totemId", &f)?;
        } else {
            s.skip_field("totemId")?;
        }
        s.serialize_field("color", &self.color())?;
        s.serialize_field("pos", &self.pos())?;
        if let Some(f) = self.rhythm() {
            s.serialize_field("rhythm", &f)?;
        } else {
            s.skip_field("rhythm")?;
        }
        if let Some(f) = self.normalDesc() {
            s.serialize_field("normalDesc", &f)?;
        } else {
            s.skip_field("normalDesc")?;
        }
        if let Some(f) = self.synergyDesc() {
            s.serialize_field("synergyDesc", &f)?;
        } else {
            s.skip_field("synergyDesc")?;
        }
        if let Some(f) = self.archiveDesc() {
            s.serialize_field("archiveDesc", &f)?;
        } else {
            s.skip_field("archiveDesc")?;
        }
        if let Some(f) = self.combineGroupName() {
            s.serialize_field("combineGroupName", &f)?;
        } else {
            s.skip_field("combineGroupName")?;
        }
        if let Some(f) = self.bgIconId() {
            s.serialize_field("bgIconId", &f)?;
        } else {
            s.skip_field("bgIconId")?;
        }
        s.serialize_field("isManual", &self.isManual())?;
        if let Some(f) = self.linkedNodeTypeData() {
            s.serialize_field("linkedNodeTypeData", &f)?;
        } else {
            s.skip_field("linkedNodeTypeData")?;
        }
        s.serialize_field("distanceMin", &self.distanceMin())?;
        s.serialize_field("distanceMax", &self.distanceMax())?;
        s.serialize_field("vertPassable", &self.vertPassable())?;
        s.serialize_field("expandLength", &self.expandLength())?;
        s.serialize_field("onlyForVert", &self.onlyForVert())?;
        if let Some(f) = self.portalLinkedNodeTypeData() {
            s.serialize_field("portalLinkedNodeTypeData", &f)?;
        } else {
            s.skip_field("portalLinkedNodeTypeData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTotemBuffDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTotemBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_totemId(&mut self, totemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemBuffData::VT_TOTEMID,
            totemId,
        );
    }
    #[inline]
    pub fn add_color(&mut self, color: enum__Torappu_RoguelikeTotemColorType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeTotemColorType>(
                clz_Torappu_RoguelikeTotemBuffData::VT_COLOR,
                color,
                enum__Torappu_RoguelikeTotemColorType::NONE,
            );
    }
    #[inline]
    pub fn add_pos(&mut self, pos: enum__Torappu_RoguelikeTotemPosType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeTotemPosType>(
            clz_Torappu_RoguelikeTotemBuffData::VT_POS,
            pos,
            enum__Torappu_RoguelikeTotemPosType::LOCATION,
        );
    }
    #[inline]
    pub fn add_rhythm(&mut self, rhythm: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemBuffData::VT_RHYTHM,
            rhythm,
        );
    }
    #[inline]
    pub fn add_normalDesc(&mut self, normalDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemBuffData::VT_NORMALDESC,
            normalDesc,
        );
    }
    #[inline]
    pub fn add_synergyDesc(&mut self, synergyDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemBuffData::VT_SYNERGYDESC,
            synergyDesc,
        );
    }
    #[inline]
    pub fn add_archiveDesc(&mut self, archiveDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemBuffData::VT_ARCHIVEDESC,
            archiveDesc,
        );
    }
    #[inline]
    pub fn add_combineGroupName(&mut self, combineGroupName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemBuffData::VT_COMBINEGROUPNAME,
            combineGroupName,
        );
    }
    #[inline]
    pub fn add_bgIconId(&mut self, bgIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemBuffData::VT_BGICONID,
            bgIconId,
        );
    }
    #[inline]
    pub fn add_isManual(&mut self, isManual: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeTotemBuffData::VT_ISMANUAL,
            isManual,
            false,
        );
    }
    #[inline]
    pub fn add_linkedNodeTypeData(
        &mut self,
        linkedNodeTypeData: flatbuffers::WIPOffset<
            clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemLinkedNodeTypeData>>(clz_Torappu_RoguelikeTotemBuffData::VT_LINKEDNODETYPEDATA, linkedNodeTypeData);
    }
    #[inline]
    pub fn add_distanceMin(&mut self, distanceMin: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTotemBuffData::VT_DISTANCEMIN,
            distanceMin,
            0,
        );
    }
    #[inline]
    pub fn add_distanceMax(&mut self, distanceMax: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTotemBuffData::VT_DISTANCEMAX,
            distanceMax,
            0,
        );
    }
    #[inline]
    pub fn add_vertPassable(&mut self, vertPassable: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeTotemBuffData::VT_VERTPASSABLE,
            vertPassable,
            false,
        );
    }
    #[inline]
    pub fn add_expandLength(&mut self, expandLength: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTotemBuffData::VT_EXPANDLENGTH,
            expandLength,
            0,
        );
    }
    #[inline]
    pub fn add_onlyForVert(&mut self, onlyForVert: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeTotemBuffData::VT_ONLYFORVERT,
            onlyForVert,
            false,
        );
    }
    #[inline]
    pub fn add_portalLinkedNodeTypeData(
        &mut self,
        portalLinkedNodeTypeData: flatbuffers::WIPOffset<
            clz_Torappu_RoguelikeTotemLinkedNodeTypeData<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemLinkedNodeTypeData>>(clz_Torappu_RoguelikeTotemBuffData::VT_PORTALLINKEDNODETYPEDATA, portalLinkedNodeTypeData);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTotemBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTotemBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTotemBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTotemBuffData");
        ds.field("totemId", &self.totemId());
        ds.field("color", &self.color());
        ds.field("pos", &self.pos());
        ds.field("rhythm", &self.rhythm());
        ds.field("normalDesc", &self.normalDesc());
        ds.field("synergyDesc", &self.synergyDesc());
        ds.field("archiveDesc", &self.archiveDesc());
        ds.field("combineGroupName", &self.combineGroupName());
        ds.field("bgIconId", &self.bgIconId());
        ds.field("isManual", &self.isManual());
        ds.field("linkedNodeTypeData", &self.linkedNodeTypeData());
        ds.field("distanceMin", &self.distanceMin());
        ds.field("distanceMax", &self.distanceMax());
        ds.field("vertPassable", &self.vertPassable());
        ds.field("expandLength", &self.expandLength());
        ds.field("onlyForVert", &self.onlyForVert());
        ds.field("portalLinkedNodeTypeData", &self.portalLinkedNodeTypeData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTotemBuffDataT {
    pub totemId: Option<String>,
    pub color: enum__Torappu_RoguelikeTotemColorType,
    pub pos: enum__Torappu_RoguelikeTotemPosType,
    pub rhythm: Option<String>,
    pub normalDesc: Option<String>,
    pub synergyDesc: Option<String>,
    pub archiveDesc: Option<String>,
    pub combineGroupName: Option<String>,
    pub bgIconId: Option<String>,
    pub isManual: bool,
    pub linkedNodeTypeData: Option<Box<clz_Torappu_RoguelikeTotemLinkedNodeTypeDataT>>,
    pub distanceMin: i32,
    pub distanceMax: i32,
    pub vertPassable: bool,
    pub expandLength: i32,
    pub onlyForVert: bool,
    pub portalLinkedNodeTypeData: Option<Box<clz_Torappu_RoguelikeTotemLinkedNodeTypeDataT>>,
}
impl Default for clz_Torappu_RoguelikeTotemBuffDataT {
    fn default() -> Self {
        Self {
            totemId: None,
            color: enum__Torappu_RoguelikeTotemColorType::NONE,
            pos: enum__Torappu_RoguelikeTotemPosType::LOCATION,
            rhythm: None,
            normalDesc: None,
            synergyDesc: None,
            archiveDesc: None,
            combineGroupName: None,
            bgIconId: None,
            isManual: false,
            linkedNodeTypeData: None,
            distanceMin: 0,
            distanceMax: 0,
            vertPassable: false,
            expandLength: 0,
            onlyForVert: false,
            portalLinkedNodeTypeData: None,
        }
    }
}
impl clz_Torappu_RoguelikeTotemBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemBuffData<'b>> {
        let totemId = self.totemId.as_ref().map(|x| _fbb.create_string(x));
        let color = self.color;
        let pos = self.pos;
        let rhythm = self.rhythm.as_ref().map(|x| _fbb.create_string(x));
        let normalDesc = self.normalDesc.as_ref().map(|x| _fbb.create_string(x));
        let synergyDesc = self.synergyDesc.as_ref().map(|x| _fbb.create_string(x));
        let archiveDesc = self.archiveDesc.as_ref().map(|x| _fbb.create_string(x));
        let combineGroupName = self
            .combineGroupName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let bgIconId = self.bgIconId.as_ref().map(|x| _fbb.create_string(x));
        let isManual = self.isManual;
        let linkedNodeTypeData = self.linkedNodeTypeData.as_ref().map(|x| x.pack(_fbb));
        let distanceMin = self.distanceMin;
        let distanceMax = self.distanceMax;
        let vertPassable = self.vertPassable;
        let expandLength = self.expandLength;
        let onlyForVert = self.onlyForVert;
        let portalLinkedNodeTypeData = self.portalLinkedNodeTypeData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeTotemBuffData::create(
            _fbb,
            &clz_Torappu_RoguelikeTotemBuffDataArgs {
                totemId,
                color,
                pos,
                rhythm,
                normalDesc,
                synergyDesc,
                archiveDesc,
                combineGroupName,
                bgIconId,
                isManual,
                linkedNodeTypeData,
                distanceMin,
                distanceMax,
                vertPassable,
                expandLength,
                onlyForVert,
                portalLinkedNodeTypeData,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeTotemBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeTotemBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeTotemBuffData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeTotemBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeTotemBuffData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeTotemBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeTotemBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTotemBuffData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeTotemBuffDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeTotemBuffDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeTotemBuffDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeTotemBuffData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeTotemBuffData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeTotemBuffData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTotemBuffData>>(
                    dict__string__clz_Torappu_RoguelikeTotemBuffData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeTotemBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTotemBuffData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeTotemBuffDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemBuffData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeTotemBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeTotemBuffDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeTotemBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeTotemBuffData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeTotemBuffDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeTotemBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeTotemBuffData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemBuffData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemBuffData>>(
                dict__string__clz_Torappu_RoguelikeTotemBuffData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeTotemBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeTotemBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTotemBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeTotemBuffData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeTotemBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeTotemBuffData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeTotemBuffDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeTotemBuffDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeTotemBuffDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeTotemBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTotemBuffData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeTotemBuffData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeTotemBuffDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeTotemSubBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTotemSubBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTotemSubBuffData<'a> {
    type Inner = clz_Torappu_RoguelikeTotemSubBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTotemSubBuffData<'a> {
    pub const VT_SUBBUFFID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DESC: flatbuffers::VOffsetT = 8;
    pub const VT_COMBINEDDESC: flatbuffers::VOffsetT = 10;
    pub const VT_INFO: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTotemSubBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTotemSubBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemSubBuffData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTotemSubBuffDataBuilder::new(_fbb);
        if let Some(x) = args.info {
            builder.add_info(x);
        }
        if let Some(x) = args.combinedDesc {
            builder.add_combinedDesc(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.subBuffId {
            builder.add_subBuffId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTotemSubBuffDataT {
        let subBuffId = self.subBuffId().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let combinedDesc = self.combinedDesc().map(|x| x.to_string());
        let info = self.info().map(|x| x.to_string());
        clz_Torappu_RoguelikeTotemSubBuffDataT {
            subBuffId,
            name,
            desc,
            combinedDesc,
            info,
        }
    }

    #[inline]
    pub fn subBuffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemSubBuffData::VT_SUBBUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemSubBuffData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemSubBuffData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn combinedDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemSubBuffData::VT_COMBINEDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn info(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemSubBuffData::VT_INFO,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTotemSubBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "subBuffId",
                Self::VT_SUBBUFFID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "combinedDesc",
                Self::VT_COMBINEDDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("info", Self::VT_INFO, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTotemSubBuffDataArgs<'a> {
    pub subBuffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub combinedDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub info: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTotemSubBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTotemSubBuffDataArgs {
            subBuffId: None,
            name: None,
            desc: None,
            combinedDesc: None,
            info: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTotemSubBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTotemSubBuffData", 5)?;
        if let Some(f) = self.subBuffId() {
            s.serialize_field("subBuffId", &f)?;
        } else {
            s.skip_field("subBuffId")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.combinedDesc() {
            s.serialize_field("combinedDesc", &f)?;
        } else {
            s.skip_field("combinedDesc")?;
        }
        if let Some(f) = self.info() {
            s.serialize_field("info", &f)?;
        } else {
            s.skip_field("info")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTotemSubBuffDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTotemSubBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_subBuffId(&mut self, subBuffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemSubBuffData::VT_SUBBUFFID,
            subBuffId,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemSubBuffData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemSubBuffData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_combinedDesc(&mut self, combinedDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemSubBuffData::VT_COMBINEDDESC,
            combinedDesc,
        );
    }
    #[inline]
    pub fn add_info(&mut self, info: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemSubBuffData::VT_INFO,
            info,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTotemSubBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTotemSubBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemSubBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTotemSubBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTotemSubBuffData");
        ds.field("subBuffId", &self.subBuffId());
        ds.field("name", &self.name());
        ds.field("desc", &self.desc());
        ds.field("combinedDesc", &self.combinedDesc());
        ds.field("info", &self.info());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTotemSubBuffDataT {
    pub subBuffId: Option<String>,
    pub name: Option<String>,
    pub desc: Option<String>,
    pub combinedDesc: Option<String>,
    pub info: Option<String>,
}
impl Default for clz_Torappu_RoguelikeTotemSubBuffDataT {
    fn default() -> Self {
        Self {
            subBuffId: None,
            name: None,
            desc: None,
            combinedDesc: None,
            info: None,
        }
    }
}
impl clz_Torappu_RoguelikeTotemSubBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemSubBuffData<'b>> {
        let subBuffId = self.subBuffId.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let combinedDesc = self.combinedDesc.as_ref().map(|x| _fbb.create_string(x));
        let info = self.info.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeTotemSubBuffData::create(
            _fbb,
            &clz_Torappu_RoguelikeTotemSubBuffDataArgs {
                subBuffId,
                name,
                desc,
                combinedDesc,
                info,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeTotemSubBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeTotemSubBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeTotemSubBuffData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeTotemSubBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeTotemSubBuffData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeTotemSubBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeTotemSubBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTotemSubBuffData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeTotemSubBuffDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeTotemSubBuffDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeTotemSubBuffDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeTotemSubBuffData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeTotemSubBuffData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeTotemSubBuffData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTotemSubBuffData>>(
                    dict__string__clz_Torappu_RoguelikeTotemSubBuffData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeTotemSubBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTotemSubBuffData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeTotemSubBuffDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemSubBuffData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeTotemSubBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeTotemSubBuffDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeTotemSubBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeTotemSubBuffData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeTotemSubBuffDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeTotemSubBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeTotemSubBuffData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemSubBuffData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemSubBuffData>>(
                dict__string__clz_Torappu_RoguelikeTotemSubBuffData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeTotemSubBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeTotemSubBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTotemSubBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeTotemSubBuffData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeTotemSubBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeTotemSubBuffData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeTotemSubBuffDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeTotemSubBuffDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeTotemSubBuffDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeTotemSubBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTotemSubBuffData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeTotemSubBuffData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeTotemSubBuffDataArgs { key, value },
        )
    }
}
pub enum dict__enum__Torappu_RoguelikeTotemColorType__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_RoguelikeTotemColorType__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__enum__Torappu_RoguelikeTotemColorType__string<'a> {
    type Inner = dict__enum__Torappu_RoguelikeTotemColorType__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__enum__Torappu_RoguelikeTotemColorType__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__enum__Torappu_RoguelikeTotemColorType__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__enum__Torappu_RoguelikeTotemColorType__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_RoguelikeTotemColorType__string<'bldr>> {
        let mut builder = dict__enum__Torappu_RoguelikeTotemColorType__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__enum__Torappu_RoguelikeTotemColorType__stringT {
        let key = self.key();
        let value = self.value().map(|x| x.to_string());
        dict__enum__Torappu_RoguelikeTotemColorType__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> enum__Torappu_RoguelikeTotemColorType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTotemColorType>(
                    dict__enum__Torappu_RoguelikeTotemColorType__string::VT_KEY,
                    Some(enum__Torappu_RoguelikeTotemColorType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__enum__Torappu_RoguelikeTotemColorType__string,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(
        &self,
        val: enum__Torappu_RoguelikeTotemColorType,
    ) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                dict__enum__Torappu_RoguelikeTotemColorType__string::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__enum__Torappu_RoguelikeTotemColorType__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeTotemColorType>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__enum__Torappu_RoguelikeTotemColorType__stringArgs<'a> {
    pub key: enum__Torappu_RoguelikeTotemColorType,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__enum__Torappu_RoguelikeTotemColorType__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__enum__Torappu_RoguelikeTotemColorType__stringArgs {
            key: enum__Torappu_RoguelikeTotemColorType::NONE,
            value: None,
        }
    }
}

impl Serialize for dict__enum__Torappu_RoguelikeTotemColorType__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__enum__Torappu_RoguelikeTotemColorType__string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__enum__Torappu_RoguelikeTotemColorType__stringBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__enum__Torappu_RoguelikeTotemColorType__stringBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: enum__Torappu_RoguelikeTotemColorType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeTotemColorType>(
                dict__enum__Torappu_RoguelikeTotemColorType__string::VT_KEY,
                key,
                enum__Torappu_RoguelikeTotemColorType::NONE,
            );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__enum__Torappu_RoguelikeTotemColorType__string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__enum__Torappu_RoguelikeTotemColorType__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__enum__Torappu_RoguelikeTotemColorType__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_RoguelikeTotemColorType__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__enum__Torappu_RoguelikeTotemColorType__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__enum__Torappu_RoguelikeTotemColorType__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__enum__Torappu_RoguelikeTotemColorType__stringT {
    pub key: enum__Torappu_RoguelikeTotemColorType,
    pub value: Option<String>,
}
impl Default for dict__enum__Torappu_RoguelikeTotemColorType__stringT {
    fn default() -> Self {
        Self {
            key: enum__Torappu_RoguelikeTotemColorType::NONE,
            value: None,
        }
    }
}
impl dict__enum__Torappu_RoguelikeTotemColorType__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__enum__Torappu_RoguelikeTotemColorType__string<'b>> {
        let key = self.key;
        let value = self.value.as_ref().map(|x| _fbb.create_string(x));
        dict__enum__Torappu_RoguelikeTotemColorType__string::create(
            _fbb,
            &dict__enum__Torappu_RoguelikeTotemColorType__stringArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeTotemModuleConstsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTotemModuleConsts<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTotemModuleConsts<'a> {
    type Inner = clz_Torappu_RoguelikeTotemModuleConsts<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTotemModuleConsts<'a> {
    pub const VT_TOTEMPREDICTDESCRIPTION: flatbuffers::VOffsetT = 4;
    pub const VT_COLORCOMBINEDESC: flatbuffers::VOffsetT = 6;
    pub const VT_BOSSCOMBINEDESC: flatbuffers::VOffsetT = 8;
    pub const VT_BATTLENOPREDICTDESCRIPTION: flatbuffers::VOffsetT = 10;
    pub const VT_SHOPNOGOODSDESCRIPTION: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTotemModuleConsts { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTotemModuleConstsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemModuleConsts<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTotemModuleConstsBuilder::new(_fbb);
        if let Some(x) = args.shopNoGoodsDescription {
            builder.add_shopNoGoodsDescription(x);
        }
        if let Some(x) = args.battleNoPredictDescription {
            builder.add_battleNoPredictDescription(x);
        }
        if let Some(x) = args.bossCombineDesc {
            builder.add_bossCombineDesc(x);
        }
        if let Some(x) = args.colorCombineDesc {
            builder.add_colorCombineDesc(x);
        }
        if let Some(x) = args.totemPredictDescription {
            builder.add_totemPredictDescription(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTotemModuleConstsT {
        let totemPredictDescription = self.totemPredictDescription().map(|x| x.to_string());
        let colorCombineDesc = self
            .colorCombineDesc()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let bossCombineDesc = self.bossCombineDesc().map(|x| x.to_string());
        let battleNoPredictDescription = self.battleNoPredictDescription().map(|x| x.to_string());
        let shopNoGoodsDescription = self.shopNoGoodsDescription().map(|x| x.to_string());
        clz_Torappu_RoguelikeTotemModuleConstsT {
            totemPredictDescription,
            colorCombineDesc,
            bossCombineDesc,
            battleNoPredictDescription,
            shopNoGoodsDescription,
        }
    }

    #[inline]
    pub fn totemPredictDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemModuleConsts::VT_TOTEMPREDICTDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn colorCombineDesc(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__enum__Torappu_RoguelikeTotemColorType__string<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_RoguelikeTotemColorType__string,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeTotemModuleConsts::VT_COLORCOMBINEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn bossCombineDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemModuleConsts::VT_BOSSCOMBINEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn battleNoPredictDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemModuleConsts::VT_BATTLENOPREDICTDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn shopNoGoodsDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTotemModuleConsts::VT_SHOPNOGOODSDESCRIPTION,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTotemModuleConsts<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "totemPredictDescription",
                Self::VT_TOTEMPREDICTDESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__enum__Torappu_RoguelikeTotemColorType__string,
                    >,
                >,
            >>("colorCombineDesc", Self::VT_COLORCOMBINEDESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bossCombineDesc",
                Self::VT_BOSSCOMBINEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "battleNoPredictDescription",
                Self::VT_BATTLENOPREDICTDESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "shopNoGoodsDescription",
                Self::VT_SHOPNOGOODSDESCRIPTION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTotemModuleConstsArgs<'a> {
    pub totemPredictDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub colorCombineDesc: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_RoguelikeTotemColorType__string<'a>,
                >,
            >,
        >,
    >,
    pub bossCombineDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub battleNoPredictDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub shopNoGoodsDescription: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTotemModuleConstsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTotemModuleConstsArgs {
            totemPredictDescription: None,
            colorCombineDesc: None,
            bossCombineDesc: None,
            battleNoPredictDescription: None,
            shopNoGoodsDescription: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTotemModuleConsts<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTotemModuleConsts", 5)?;
        if let Some(f) = self.totemPredictDescription() {
            s.serialize_field("totemPredictDescription", &f)?;
        } else {
            s.skip_field("totemPredictDescription")?;
        }
        if let Some(f) = self.colorCombineDesc() {
            s.serialize_field("colorCombineDesc", &f)?;
        } else {
            s.skip_field("colorCombineDesc")?;
        }
        if let Some(f) = self.bossCombineDesc() {
            s.serialize_field("bossCombineDesc", &f)?;
        } else {
            s.skip_field("bossCombineDesc")?;
        }
        if let Some(f) = self.battleNoPredictDescription() {
            s.serialize_field("battleNoPredictDescription", &f)?;
        } else {
            s.skip_field("battleNoPredictDescription")?;
        }
        if let Some(f) = self.shopNoGoodsDescription() {
            s.serialize_field("shopNoGoodsDescription", &f)?;
        } else {
            s.skip_field("shopNoGoodsDescription")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTotemModuleConstsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTotemModuleConstsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_totemPredictDescription(
        &mut self,
        totemPredictDescription: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemModuleConsts::VT_TOTEMPREDICTDESCRIPTION,
            totemPredictDescription,
        );
    }
    #[inline]
    pub fn add_colorCombineDesc(
        &mut self,
        colorCombineDesc: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__enum__Torappu_RoguelikeTotemColorType__string<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemModuleConsts::VT_COLORCOMBINEDESC,
            colorCombineDesc,
        );
    }
    #[inline]
    pub fn add_bossCombineDesc(&mut self, bossCombineDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemModuleConsts::VT_BOSSCOMBINEDESC,
            bossCombineDesc,
        );
    }
    #[inline]
    pub fn add_battleNoPredictDescription(
        &mut self,
        battleNoPredictDescription: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemModuleConsts::VT_BATTLENOPREDICTDESCRIPTION,
            battleNoPredictDescription,
        );
    }
    #[inline]
    pub fn add_shopNoGoodsDescription(
        &mut self,
        shopNoGoodsDescription: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemModuleConsts::VT_SHOPNOGOODSDESCRIPTION,
            shopNoGoodsDescription,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTotemModuleConstsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTotemModuleConstsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemModuleConsts<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTotemModuleConsts<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTotemModuleConsts");
        ds.field("totemPredictDescription", &self.totemPredictDescription());
        ds.field("colorCombineDesc", &self.colorCombineDesc());
        ds.field("bossCombineDesc", &self.bossCombineDesc());
        ds.field(
            "battleNoPredictDescription",
            &self.battleNoPredictDescription(),
        );
        ds.field("shopNoGoodsDescription", &self.shopNoGoodsDescription());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTotemModuleConstsT {
    pub totemPredictDescription: Option<String>,
    pub colorCombineDesc: Option<Vec<dict__enum__Torappu_RoguelikeTotemColorType__stringT>>,
    pub bossCombineDesc: Option<String>,
    pub battleNoPredictDescription: Option<String>,
    pub shopNoGoodsDescription: Option<String>,
}
impl Default for clz_Torappu_RoguelikeTotemModuleConstsT {
    fn default() -> Self {
        Self {
            totemPredictDescription: None,
            colorCombineDesc: None,
            bossCombineDesc: None,
            battleNoPredictDescription: None,
            shopNoGoodsDescription: None,
        }
    }
}
impl clz_Torappu_RoguelikeTotemModuleConstsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemModuleConsts<'b>> {
        let totemPredictDescription = self
            .totemPredictDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let colorCombineDesc = self.colorCombineDesc.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let bossCombineDesc = self.bossCombineDesc.as_ref().map(|x| _fbb.create_string(x));
        let battleNoPredictDescription = self
            .battleNoPredictDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let shopNoGoodsDescription = self
            .shopNoGoodsDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeTotemModuleConsts::create(
            _fbb,
            &clz_Torappu_RoguelikeTotemModuleConstsArgs {
                totemPredictDescription,
                colorCombineDesc,
                bossCombineDesc,
                battleNoPredictDescription,
                shopNoGoodsDescription,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTotemBuffModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTotemBuffModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTotemBuffModuleData<'a> {
    type Inner = clz_Torappu_RoguelikeTotemBuffModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTotemBuffModuleData<'a> {
    pub const VT_TOTEMBUFFDATAS: flatbuffers::VOffsetT = 4;
    pub const VT_SUBBUFFS: flatbuffers::VOffsetT = 6;
    pub const VT_MODULECONSTS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTotemBuffModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTotemBuffModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemBuffModuleData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTotemBuffModuleDataBuilder::new(_fbb);
        if let Some(x) = args.moduleConsts {
            builder.add_moduleConsts(x);
        }
        if let Some(x) = args.subBuffs {
            builder.add_subBuffs(x);
        }
        if let Some(x) = args.totemBuffDatas {
            builder.add_totemBuffDatas(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTotemBuffModuleDataT {
        let totemBuffDatas = self
            .totemBuffDatas()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let subBuffs = self
            .subBuffs()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let moduleConsts = self.moduleConsts().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeTotemBuffModuleDataT {
            totemBuffDatas,
            subBuffs,
            moduleConsts,
        }
    }

    #[inline]
    pub fn totemBuffDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTotemBuffData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTotemBuffData>,
                >,
            >>(
                clz_Torappu_RoguelikeTotemBuffModuleData::VT_TOTEMBUFFDATAS,
                None,
            )
        }
    }
    #[inline]
    pub fn subBuffs(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTotemSubBuffData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeTotemSubBuffData,
                    >,
                >,
            >>(clz_Torappu_RoguelikeTotemBuffModuleData::VT_SUBBUFFS, None)
        }
    }
    #[inline]
    pub fn moduleConsts(&self) -> Option<clz_Torappu_RoguelikeTotemModuleConsts<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTotemModuleConsts>>(
                    clz_Torappu_RoguelikeTotemBuffModuleData::VT_MODULECONSTS,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTotemBuffModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTotemBuffData>,
                >,
            >>("totemBuffDatas", Self::VT_TOTEMBUFFDATAS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeTotemSubBuffData,
                    >,
                >,
            >>("subBuffs", Self::VT_SUBBUFFS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTotemModuleConsts>>(
                "moduleConsts",
                Self::VT_MODULECONSTS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTotemBuffModuleDataArgs<'a> {
    pub totemBuffDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTotemBuffData<'a>>,
            >,
        >,
    >,
    pub subBuffs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeTotemSubBuffData<'a>,
                >,
            >,
        >,
    >,
    pub moduleConsts: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemModuleConsts<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTotemBuffModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTotemBuffModuleDataArgs {
            totemBuffDatas: None,
            subBuffs: None,
            moduleConsts: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTotemBuffModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTotemBuffModuleData", 3)?;
        if let Some(f) = self.totemBuffDatas() {
            s.serialize_field("totemBuffDatas", &f)?;
        } else {
            s.skip_field("totemBuffDatas")?;
        }
        if let Some(f) = self.subBuffs() {
            s.serialize_field("subBuffs", &f)?;
        } else {
            s.skip_field("subBuffs")?;
        }
        if let Some(f) = self.moduleConsts() {
            s.serialize_field("moduleConsts", &f)?;
        } else {
            s.skip_field("moduleConsts")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTotemBuffModuleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTotemBuffModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_totemBuffDatas(
        &mut self,
        totemBuffDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTotemBuffData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemBuffModuleData::VT_TOTEMBUFFDATAS,
            totemBuffDatas,
        );
    }
    #[inline]
    pub fn add_subBuffs(
        &mut self,
        subBuffs: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeTotemSubBuffData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTotemBuffModuleData::VT_SUBBUFFS,
            subBuffs,
        );
    }
    #[inline]
    pub fn add_moduleConsts(
        &mut self,
        moduleConsts: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemModuleConsts<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemModuleConsts>>(
                clz_Torappu_RoguelikeTotemBuffModuleData::VT_MODULECONSTS,
                moduleConsts,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTotemBuffModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTotemBuffModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemBuffModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTotemBuffModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTotemBuffModuleData");
        ds.field("totemBuffDatas", &self.totemBuffDatas());
        ds.field("subBuffs", &self.subBuffs());
        ds.field("moduleConsts", &self.moduleConsts());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTotemBuffModuleDataT {
    pub totemBuffDatas: Option<Vec<dict__string__clz_Torappu_RoguelikeTotemBuffDataT>>,
    pub subBuffs: Option<Vec<dict__string__clz_Torappu_RoguelikeTotemSubBuffDataT>>,
    pub moduleConsts: Option<Box<clz_Torappu_RoguelikeTotemModuleConstsT>>,
}
impl Default for clz_Torappu_RoguelikeTotemBuffModuleDataT {
    fn default() -> Self {
        Self {
            totemBuffDatas: None,
            subBuffs: None,
            moduleConsts: None,
        }
    }
}
impl clz_Torappu_RoguelikeTotemBuffModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemBuffModuleData<'b>> {
        let totemBuffDatas = self.totemBuffDatas.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let subBuffs = self.subBuffs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let moduleConsts = self.moduleConsts.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeTotemBuffModuleData::create(
            _fbb,
            &clz_Torappu_RoguelikeTotemBuffModuleDataArgs {
                totemBuffDatas,
                subBuffs,
                moduleConsts,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeVisionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeVisionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeVisionData<'a> {
    type Inner = clz_Torappu_RoguelikeVisionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeVisionData<'a> {
    pub const VT_SIGHTNUM: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;
    pub const VT_CANFORESEE: flatbuffers::VOffsetT = 8;
    pub const VT_DIVIDEDDIS: flatbuffers::VOffsetT = 10;
    pub const VT_STATUS: flatbuffers::VOffsetT = 12;
    pub const VT_CLR: flatbuffers::VOffsetT = 14;
    pub const VT_DESC1: flatbuffers::VOffsetT = 16;
    pub const VT_DESC2: flatbuffers::VOffsetT = 18;
    pub const VT_ICON: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeVisionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeVisionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeVisionDataBuilder::new(_fbb);
        if let Some(x) = args.icon {
            builder.add_icon(x);
        }
        if let Some(x) = args.desc2 {
            builder.add_desc2(x);
        }
        if let Some(x) = args.desc1 {
            builder.add_desc1(x);
        }
        if let Some(x) = args.clr {
            builder.add_clr(x);
        }
        if let Some(x) = args.status {
            builder.add_status(x);
        }
        builder.add_dividedDis(args.dividedDis);
        builder.add_level(args.level);
        builder.add_sightNum(args.sightNum);
        builder.add_canForesee(args.canForesee);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeVisionDataT {
        let sightNum = self.sightNum();
        let level = self.level();
        let canForesee = self.canForesee();
        let dividedDis = self.dividedDis();
        let status = self.status().map(|x| x.to_string());
        let clr = self.clr().map(|x| x.to_string());
        let desc1 = self.desc1().map(|x| x.to_string());
        let desc2 = self.desc2().map(|x| x.to_string());
        let icon = self.icon().map(|x| x.to_string());
        clz_Torappu_RoguelikeVisionDataT {
            sightNum,
            level,
            canForesee,
            dividedDis,
            status,
            clr,
            desc1,
            desc2,
            icon,
        }
    }

    #[inline]
    pub fn sightNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeVisionData::VT_SIGHTNUM, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeVisionData::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn canForesee(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_RoguelikeVisionData::VT_CANFORESEE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn dividedDis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeVisionData::VT_DIVIDEDDIS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn status(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeVisionData::VT_STATUS,
                None,
            )
        }
    }
    #[inline]
    pub fn clr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeVisionData::VT_CLR,
                None,
            )
        }
    }
    #[inline]
    pub fn desc1(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeVisionData::VT_DESC1,
                None,
            )
        }
    }
    #[inline]
    pub fn desc2(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeVisionData::VT_DESC2,
                None,
            )
        }
    }
    #[inline]
    pub fn icon(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeVisionData::VT_ICON,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeVisionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("sightNum", Self::VT_SIGHTNUM, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .visit_field::<bool>("canForesee", Self::VT_CANFORESEE, false)?
            .visit_field::<i32>("dividedDis", Self::VT_DIVIDEDDIS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("status", Self::VT_STATUS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("clr", Self::VT_CLR, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc1", Self::VT_DESC1, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc2", Self::VT_DESC2, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("icon", Self::VT_ICON, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeVisionDataArgs<'a> {
    pub sightNum: i32,
    pub level: i32,
    pub canForesee: bool,
    pub dividedDis: i32,
    pub status: Option<flatbuffers::WIPOffset<&'a str>>,
    pub clr: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub icon: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeVisionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeVisionDataArgs {
            sightNum: 0,
            level: 0,
            canForesee: false,
            dividedDis: 0,
            status: None,
            clr: None,
            desc1: None,
            desc2: None,
            icon: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeVisionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeVisionData", 9)?;
        s.serialize_field("sightNum", &self.sightNum())?;
        s.serialize_field("level", &self.level())?;
        s.serialize_field("canForesee", &self.canForesee())?;
        s.serialize_field("dividedDis", &self.dividedDis())?;
        if let Some(f) = self.status() {
            s.serialize_field("status", &f)?;
        } else {
            s.skip_field("status")?;
        }
        if let Some(f) = self.clr() {
            s.serialize_field("clr", &f)?;
        } else {
            s.skip_field("clr")?;
        }
        if let Some(f) = self.desc1() {
            s.serialize_field("desc1", &f)?;
        } else {
            s.skip_field("desc1")?;
        }
        if let Some(f) = self.desc2() {
            s.serialize_field("desc2", &f)?;
        } else {
            s.skip_field("desc2")?;
        }
        if let Some(f) = self.icon() {
            s.serialize_field("icon", &f)?;
        } else {
            s.skip_field("icon")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeVisionDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RoguelikeVisionDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_sightNum(&mut self, sightNum: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeVisionData::VT_SIGHTNUM, sightNum, 0);
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeVisionData::VT_LEVEL, level, 0);
    }
    #[inline]
    pub fn add_canForesee(&mut self, canForesee: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeVisionData::VT_CANFORESEE,
            canForesee,
            false,
        );
    }
    #[inline]
    pub fn add_dividedDis(&mut self, dividedDis: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeVisionData::VT_DIVIDEDDIS,
            dividedDis,
            0,
        );
    }
    #[inline]
    pub fn add_status(&mut self, status: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeVisionData::VT_STATUS,
            status,
        );
    }
    #[inline]
    pub fn add_clr(&mut self, clr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeVisionData::VT_CLR,
            clr,
        );
    }
    #[inline]
    pub fn add_desc1(&mut self, desc1: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeVisionData::VT_DESC1,
            desc1,
        );
    }
    #[inline]
    pub fn add_desc2(&mut self, desc2: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeVisionData::VT_DESC2,
            desc2,
        );
    }
    #[inline]
    pub fn add_icon(&mut self, icon: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeVisionData::VT_ICON,
            icon,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeVisionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeVisionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeVisionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeVisionData");
        ds.field("sightNum", &self.sightNum());
        ds.field("level", &self.level());
        ds.field("canForesee", &self.canForesee());
        ds.field("dividedDis", &self.dividedDis());
        ds.field("status", &self.status());
        ds.field("clr", &self.clr());
        ds.field("desc1", &self.desc1());
        ds.field("desc2", &self.desc2());
        ds.field("icon", &self.icon());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeVisionDataT {
    pub sightNum: i32,
    pub level: i32,
    pub canForesee: bool,
    pub dividedDis: i32,
    pub status: Option<String>,
    pub clr: Option<String>,
    pub desc1: Option<String>,
    pub desc2: Option<String>,
    pub icon: Option<String>,
}
impl Default for clz_Torappu_RoguelikeVisionDataT {
    fn default() -> Self {
        Self {
            sightNum: 0,
            level: 0,
            canForesee: false,
            dividedDis: 0,
            status: None,
            clr: None,
            desc1: None,
            desc2: None,
            icon: None,
        }
    }
}
impl clz_Torappu_RoguelikeVisionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionData<'b>> {
        let sightNum = self.sightNum;
        let level = self.level;
        let canForesee = self.canForesee;
        let dividedDis = self.dividedDis;
        let status = self.status.as_ref().map(|x| _fbb.create_string(x));
        let clr = self.clr.as_ref().map(|x| _fbb.create_string(x));
        let desc1 = self.desc1.as_ref().map(|x| _fbb.create_string(x));
        let desc2 = self.desc2.as_ref().map(|x| _fbb.create_string(x));
        let icon = self.icon.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeVisionData::create(
            _fbb,
            &clz_Torappu_RoguelikeVisionDataArgs {
                sightNum,
                level,
                canForesee,
                dividedDis,
                status,
                clr,
                desc1,
                desc2,
                icon,
            },
        )
    }
}
pub enum dict__int__clz_Torappu_RoguelikeVisionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__clz_Torappu_RoguelikeVisionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__int__clz_Torappu_RoguelikeVisionData<'a> {
    type Inner = dict__int__clz_Torappu_RoguelikeVisionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__int__clz_Torappu_RoguelikeVisionData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__clz_Torappu_RoguelikeVisionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__clz_Torappu_RoguelikeVisionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_RoguelikeVisionData<'bldr>> {
        let mut builder = dict__int__clz_Torappu_RoguelikeVisionDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__int__clz_Torappu_RoguelikeVisionDataT {
        let key = self.key();
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__int__clz_Torappu_RoguelikeVisionDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(dict__int__clz_Torappu_RoguelikeVisionData::VT_KEY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__int__clz_Torappu_RoguelikeVisionData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeVisionData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeVisionData>>(
                    dict__int__clz_Torappu_RoguelikeVisionData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__int__clz_Torappu_RoguelikeVisionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeVisionData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__int__clz_Torappu_RoguelikeVisionDataArgs<'a> {
    pub key: i32,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionData<'a>>>,
}
impl<'a> Default for dict__int__clz_Torappu_RoguelikeVisionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__clz_Torappu_RoguelikeVisionDataArgs {
            key: 0,
            value: None,
        }
    }
}

impl Serialize for dict__int__clz_Torappu_RoguelikeVisionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__int__clz_Torappu_RoguelikeVisionData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__int__clz_Torappu_RoguelikeVisionDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__clz_Torappu_RoguelikeVisionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_
            .push_slot::<i32>(dict__int__clz_Torappu_RoguelikeVisionData::VT_KEY, key, 0);
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionData>>(
                dict__int__clz_Torappu_RoguelikeVisionData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__clz_Torappu_RoguelikeVisionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__clz_Torappu_RoguelikeVisionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_RoguelikeVisionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__clz_Torappu_RoguelikeVisionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__clz_Torappu_RoguelikeVisionData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__int__clz_Torappu_RoguelikeVisionDataT {
    pub key: i32,
    pub value: Option<Box<clz_Torappu_RoguelikeVisionDataT>>,
}
impl Default for dict__int__clz_Torappu_RoguelikeVisionDataT {
    fn default() -> Self {
        Self {
            key: 0,
            value: None,
        }
    }
}
impl dict__int__clz_Torappu_RoguelikeVisionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_RoguelikeVisionData<'b>> {
        let key = self.key;
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__int__clz_Torappu_RoguelikeVisionData::create(
            _fbb,
            &dict__int__clz_Torappu_RoguelikeVisionDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'a> {
    type Inner = clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'bldr>>
    {
        let mut builder =
            clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigBuilder::new(_fbb);
        builder.add_type_(args.type_);
        builder.add_value(args.value);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigT {
        let value = self.value();
        let type_ = self.type_();
        clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigT { value, type_ }
    }

    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig::VT_VALUE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType>(
                    clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig::VT_TYPE_,
                    Some(enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType::LOWER),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .visit_field::<enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType>(
                "type_",
                Self::VT_TYPE_,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigArgs {
    pub value: i32,
    pub type_: enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType,
}
impl<'a> Default for clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigArgs {
            value: 0,
            type_: enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType::LOWER,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig",
            2,
        )?;
        s.serialize_field("value", &self.value())?;
        s.serialize_field("type_", &self.type_())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig::VT_VALUE,
            value,
            0,
        );
    }
    #[inline]
    pub fn add_type_(
        &mut self,
        type_: enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType>(
                clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig::VT_TYPE_,
                type_,
                enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType::LOWER,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig");
        ds.field("value", &self.value());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigT {
    pub value: i32,
    pub type_: enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType,
}
impl Default for clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigT {
    fn default() -> Self {
        Self {
            value: 0,
            type_: enum__Torappu_RoguelikeVisionModuleData_VisionChoiceCheckType::LOWER,
        }
    }
}
impl clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'b>> {
        let value = self.value;
        let type_ = self.type_;
        clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig::create(
            _fbb,
            &clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigArgs { value, type_ },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'a>
{
    type Inner = dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigArgs<
            'args,
        >,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigBuilder::new(
                _fbb,
            );
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(
        &self,
    ) -> dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig,
            >>(
                dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'a>>,
    >,
}
impl<'a> Default
    for dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig>>(dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigBuilder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f
            .debug_struct("dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'b>,
    > {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigArgs {
                key,
                value,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeVisionModuleConstsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeVisionModuleConsts<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeVisionModuleConsts<'a> {
    type Inner = clz_Torappu_RoguelikeVisionModuleConsts<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeVisionModuleConsts<'a> {
    pub const VT_MAXVISION: flatbuffers::VOffsetT = 4;
    pub const VT_TOTEMBOTTOMDESCRIPTION: flatbuffers::VOffsetT = 6;
    pub const VT_CHESTBOTTOMDESCRIPTION: flatbuffers::VOffsetT = 8;
    pub const VT_GOODSBOTTOMDESCRIPTION: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeVisionModuleConsts { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeVisionModuleConstsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleConsts<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeVisionModuleConstsBuilder::new(_fbb);
        if let Some(x) = args.goodsBottomDescription {
            builder.add_goodsBottomDescription(x);
        }
        if let Some(x) = args.chestBottomDescription {
            builder.add_chestBottomDescription(x);
        }
        if let Some(x) = args.totemBottomDescription {
            builder.add_totemBottomDescription(x);
        }
        builder.add_maxVision(args.maxVision);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeVisionModuleConstsT {
        let maxVision = self.maxVision();
        let totemBottomDescription = self.totemBottomDescription().map(|x| x.to_string());
        let chestBottomDescription = self.chestBottomDescription().map(|x| x.to_string());
        let goodsBottomDescription = self.goodsBottomDescription().map(|x| x.to_string());
        clz_Torappu_RoguelikeVisionModuleConstsT {
            maxVision,
            totemBottomDescription,
            chestBottomDescription,
            goodsBottomDescription,
        }
    }

    #[inline]
    pub fn maxVision(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeVisionModuleConsts::VT_MAXVISION,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn totemBottomDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeVisionModuleConsts::VT_TOTEMBOTTOMDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn chestBottomDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeVisionModuleConsts::VT_CHESTBOTTOMDESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn goodsBottomDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeVisionModuleConsts::VT_GOODSBOTTOMDESCRIPTION,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeVisionModuleConsts<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("maxVision", Self::VT_MAXVISION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "totemBottomDescription",
                Self::VT_TOTEMBOTTOMDESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "chestBottomDescription",
                Self::VT_CHESTBOTTOMDESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "goodsBottomDescription",
                Self::VT_GOODSBOTTOMDESCRIPTION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeVisionModuleConstsArgs<'a> {
    pub maxVision: i32,
    pub totemBottomDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub chestBottomDescription: Option<flatbuffers::WIPOffset<&'a str>>,
    pub goodsBottomDescription: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeVisionModuleConstsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeVisionModuleConstsArgs {
            maxVision: 0,
            totemBottomDescription: None,
            chestBottomDescription: None,
            goodsBottomDescription: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeVisionModuleConsts<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeVisionModuleConsts", 4)?;
        s.serialize_field("maxVision", &self.maxVision())?;
        if let Some(f) = self.totemBottomDescription() {
            s.serialize_field("totemBottomDescription", &f)?;
        } else {
            s.skip_field("totemBottomDescription")?;
        }
        if let Some(f) = self.chestBottomDescription() {
            s.serialize_field("chestBottomDescription", &f)?;
        } else {
            s.skip_field("chestBottomDescription")?;
        }
        if let Some(f) = self.goodsBottomDescription() {
            s.serialize_field("goodsBottomDescription", &f)?;
        } else {
            s.skip_field("goodsBottomDescription")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeVisionModuleConstsBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeVisionModuleConstsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_maxVision(&mut self, maxVision: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeVisionModuleConsts::VT_MAXVISION,
            maxVision,
            0,
        );
    }
    #[inline]
    pub fn add_totemBottomDescription(
        &mut self,
        totemBottomDescription: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeVisionModuleConsts::VT_TOTEMBOTTOMDESCRIPTION,
            totemBottomDescription,
        );
    }
    #[inline]
    pub fn add_chestBottomDescription(
        &mut self,
        chestBottomDescription: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeVisionModuleConsts::VT_CHESTBOTTOMDESCRIPTION,
            chestBottomDescription,
        );
    }
    #[inline]
    pub fn add_goodsBottomDescription(
        &mut self,
        goodsBottomDescription: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeVisionModuleConsts::VT_GOODSBOTTOMDESCRIPTION,
            goodsBottomDescription,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeVisionModuleConstsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeVisionModuleConstsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleConsts<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeVisionModuleConsts<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeVisionModuleConsts");
        ds.field("maxVision", &self.maxVision());
        ds.field("totemBottomDescription", &self.totemBottomDescription());
        ds.field("chestBottomDescription", &self.chestBottomDescription());
        ds.field("goodsBottomDescription", &self.goodsBottomDescription());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeVisionModuleConstsT {
    pub maxVision: i32,
    pub totemBottomDescription: Option<String>,
    pub chestBottomDescription: Option<String>,
    pub goodsBottomDescription: Option<String>,
}
impl Default for clz_Torappu_RoguelikeVisionModuleConstsT {
    fn default() -> Self {
        Self {
            maxVision: 0,
            totemBottomDescription: None,
            chestBottomDescription: None,
            goodsBottomDescription: None,
        }
    }
}
impl clz_Torappu_RoguelikeVisionModuleConstsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleConsts<'b>> {
        let maxVision = self.maxVision;
        let totemBottomDescription = self
            .totemBottomDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let chestBottomDescription = self
            .chestBottomDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let goodsBottomDescription = self
            .goodsBottomDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeVisionModuleConsts::create(
            _fbb,
            &clz_Torappu_RoguelikeVisionModuleConstsArgs {
                maxVision,
                totemBottomDescription,
                chestBottomDescription,
                goodsBottomDescription,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeVisionModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeVisionModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeVisionModuleData<'a> {
    type Inner = clz_Torappu_RoguelikeVisionModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeVisionModuleData<'a> {
    pub const VT_VISIONDATAS: flatbuffers::VOffsetT = 4;
    pub const VT_VISIONCHOICES: flatbuffers::VOffsetT = 6;
    pub const VT_MODULECONSTS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeVisionModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeVisionModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeVisionModuleDataBuilder::new(_fbb);
        if let Some(x) = args.moduleConsts {
            builder.add_moduleConsts(x);
        }
        if let Some(x) = args.visionChoices {
            builder.add_visionChoices(x);
        }
        if let Some(x) = args.visionDatas {
            builder.add_visionDatas(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeVisionModuleDataT {
        let visionDatas = self
            .visionDatas()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let visionChoices = self
            .visionChoices()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let moduleConsts = self.moduleConsts().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeVisionModuleDataT {
            visionDatas,
            visionChoices,
            moduleConsts,
        }
    }

    #[inline]
    pub fn visionDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__int__clz_Torappu_RoguelikeVisionData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__int__clz_Torappu_RoguelikeVisionData>,
                >,
            >>(clz_Torappu_RoguelikeVisionModuleData::VT_VISIONDATAS, None)
        }
    }
    #[inline]
    pub fn visionChoices(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeVisionModuleData::VT_VISIONCHOICES,
                None,
            )
        }
    }
    #[inline]
    pub fn moduleConsts(&self) -> Option<clz_Torappu_RoguelikeVisionModuleConsts<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeVisionModuleConsts>>(
                    clz_Torappu_RoguelikeVisionModuleData::VT_MODULECONSTS,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeVisionModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__int__clz_Torappu_RoguelikeVisionData>,
                >,
            >>("visionDatas", Self::VT_VISIONDATAS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig,
                    >,
                >,
            >>("visionChoices", Self::VT_VISIONCHOICES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeVisionModuleConsts>>(
                "moduleConsts",
                Self::VT_MODULECONSTS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeVisionModuleDataArgs<'a> {
    pub visionDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__int__clz_Torappu_RoguelikeVisionData<'a>>,
            >,
        >,
    >,
    pub visionChoices: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'a>,
                >,
            >,
        >,
    >,
    pub moduleConsts: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleConsts<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeVisionModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeVisionModuleDataArgs {
            visionDatas: None,
            visionChoices: None,
            moduleConsts: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeVisionModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeVisionModuleData", 3)?;
        if let Some(f) = self.visionDatas() {
            s.serialize_field("visionDatas", &f)?;
        } else {
            s.skip_field("visionDatas")?;
        }
        if let Some(f) = self.visionChoices() {
            s.serialize_field("visionChoices", &f)?;
        } else {
            s.skip_field("visionChoices")?;
        }
        if let Some(f) = self.moduleConsts() {
            s.serialize_field("moduleConsts", &f)?;
        } else {
            s.skip_field("moduleConsts")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeVisionModuleDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeVisionModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_visionDatas(
        &mut self,
        visionDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__int__clz_Torappu_RoguelikeVisionData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeVisionModuleData::VT_VISIONDATAS,
            visionDatas,
        );
    }
    #[inline]
    pub fn add_visionChoices(
        &mut self,
        visionChoices: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfig<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeVisionModuleData::VT_VISIONCHOICES,
            visionChoices,
        );
    }
    #[inline]
    pub fn add_moduleConsts(
        &mut self,
        moduleConsts: flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleConsts<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleConsts>>(
                clz_Torappu_RoguelikeVisionModuleData::VT_MODULECONSTS,
                moduleConsts,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeVisionModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeVisionModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeVisionModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeVisionModuleData");
        ds.field("visionDatas", &self.visionDatas());
        ds.field("visionChoices", &self.visionChoices());
        ds.field("moduleConsts", &self.moduleConsts());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeVisionModuleDataT {
    pub visionDatas: Option<Vec<dict__int__clz_Torappu_RoguelikeVisionDataT>>,
    pub visionChoices:
        Option<Vec<dict__string__clz_Torappu_RoguelikeVisionModuleData_VisionChoiceConfigT>>,
    pub moduleConsts: Option<Box<clz_Torappu_RoguelikeVisionModuleConstsT>>,
}
impl Default for clz_Torappu_RoguelikeVisionModuleDataT {
    fn default() -> Self {
        Self {
            visionDatas: None,
            visionChoices: None,
            moduleConsts: None,
        }
    }
}
impl clz_Torappu_RoguelikeVisionModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleData<'b>> {
        let visionDatas = self.visionDatas.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let visionChoices = self.visionChoices.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let moduleConsts = self.moduleConsts.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeVisionModuleData::create(
            _fbb,
            &clz_Torappu_RoguelikeVisionModuleDataArgs {
                visionDatas,
                visionChoices,
                moduleConsts,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeFragmentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeFragmentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeFragmentData<'a> {
    type Inner = clz_Torappu_RoguelikeFragmentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeFragmentData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_VALUE: flatbuffers::VOffsetT = 8;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeFragmentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeFragmentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeFragmentDataBuilder::new(_fbb);
        builder.add_weight(args.weight);
        builder.add_value(args.value);
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeFragmentDataT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        let value = self.value();
        let weight = self.weight();
        clz_Torappu_RoguelikeFragmentDataT {
            id,
            type_,
            value,
            weight,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeFragmentData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_RoguelikeFragmentType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeFragmentType>(
                    clz_Torappu_RoguelikeFragmentData::VT_TYPE_,
                    Some(enum__Torappu_RoguelikeFragmentType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeFragmentData::VT_VALUE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn weight(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeFragmentData::VT_WEIGHT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeFragmentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_RoguelikeFragmentType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .visit_field::<i32>("weight", Self::VT_WEIGHT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeFragmentDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_RoguelikeFragmentType,
    pub value: i32,
    pub weight: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeFragmentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeFragmentDataArgs {
            id: None,
            type_: enum__Torappu_RoguelikeFragmentType::NONE,
            value: 0,
            weight: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeFragmentData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeFragmentData", 4)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("value", &self.value())?;
        s.serialize_field("weight", &self.weight())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeFragmentDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeFragmentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_RoguelikeFragmentType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeFragmentType>(
            clz_Torappu_RoguelikeFragmentData::VT_TYPE_,
            type_,
            enum__Torappu_RoguelikeFragmentType::NONE,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeFragmentData::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn add_weight(&mut self, weight: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeFragmentData::VT_WEIGHT, weight, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeFragmentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeFragmentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeFragmentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeFragmentData");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("value", &self.value());
        ds.field("weight", &self.weight());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeFragmentDataT {
    pub id: Option<String>,
    pub type_: enum__Torappu_RoguelikeFragmentType,
    pub value: i32,
    pub weight: i32,
}
impl Default for clz_Torappu_RoguelikeFragmentDataT {
    fn default() -> Self {
        Self {
            id: None,
            type_: enum__Torappu_RoguelikeFragmentType::NONE,
            value: 0,
            weight: 0,
        }
    }
}
impl clz_Torappu_RoguelikeFragmentDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let value = self.value;
        let weight = self.weight;
        clz_Torappu_RoguelikeFragmentData::create(
            _fbb,
            &clz_Torappu_RoguelikeFragmentDataArgs {
                id,
                type_,
                value,
                weight,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeFragmentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeFragmentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeFragmentData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeFragmentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeFragmentData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeFragmentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeFragmentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeFragmentData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeFragmentDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeFragmentDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeFragmentDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeFragmentData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeFragmentData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeFragmentData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeFragmentData>>(
                    dict__string__clz_Torappu_RoguelikeFragmentData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeFragmentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeFragmentData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeFragmentDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeFragmentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeFragmentDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeFragmentData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeFragmentData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeFragmentDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeFragmentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeFragmentData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentData>>(
                dict__string__clz_Torappu_RoguelikeFragmentData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeFragmentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeFragmentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeFragmentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeFragmentData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeFragmentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeFragmentData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeFragmentDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeFragmentDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeFragmentDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeFragmentDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeFragmentData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeFragmentData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeFragmentDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeFragmentTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeFragmentTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeFragmentTypeData<'a> {
    type Inner = clz_Torappu_RoguelikeFragmentTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeFragmentTypeData<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_TYPENAME: flatbuffers::VOffsetT = 6;
    pub const VT_TYPEDESC: flatbuffers::VOffsetT = 8;
    pub const VT_TYPEICONID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeFragmentTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeFragmentTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentTypeData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeFragmentTypeDataBuilder::new(_fbb);
        if let Some(x) = args.typeIconId {
            builder.add_typeIconId(x);
        }
        if let Some(x) = args.typeDesc {
            builder.add_typeDesc(x);
        }
        if let Some(x) = args.typeName {
            builder.add_typeName(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeFragmentTypeDataT {
        let type_ = self.type_();
        let typeName = self.typeName().map(|x| x.to_string());
        let typeDesc = self.typeDesc().map(|x| x.to_string());
        let typeIconId = self.typeIconId().map(|x| x.to_string());
        clz_Torappu_RoguelikeFragmentTypeDataT {
            type_,
            typeName,
            typeDesc,
            typeIconId,
        }
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_RoguelikeFragmentType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeFragmentType>(
                    clz_Torappu_RoguelikeFragmentTypeData::VT_TYPE_,
                    Some(enum__Torappu_RoguelikeFragmentType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn typeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeFragmentTypeData::VT_TYPENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn typeDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeFragmentTypeData::VT_TYPEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn typeIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeFragmentTypeData::VT_TYPEICONID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeFragmentTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeFragmentType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "typeName",
                Self::VT_TYPENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "typeDesc",
                Self::VT_TYPEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "typeIconId",
                Self::VT_TYPEICONID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeFragmentTypeDataArgs<'a> {
    pub type_: enum__Torappu_RoguelikeFragmentType,
    pub typeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub typeDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub typeIconId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeFragmentTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeFragmentTypeDataArgs {
            type_: enum__Torappu_RoguelikeFragmentType::NONE,
            typeName: None,
            typeDesc: None,
            typeIconId: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeFragmentTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeFragmentTypeData", 4)?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.typeName() {
            s.serialize_field("typeName", &f)?;
        } else {
            s.skip_field("typeName")?;
        }
        if let Some(f) = self.typeDesc() {
            s.serialize_field("typeDesc", &f)?;
        } else {
            s.skip_field("typeDesc")?;
        }
        if let Some(f) = self.typeIconId() {
            s.serialize_field("typeIconId", &f)?;
        } else {
            s.skip_field("typeIconId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeFragmentTypeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeFragmentTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_RoguelikeFragmentType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeFragmentType>(
            clz_Torappu_RoguelikeFragmentTypeData::VT_TYPE_,
            type_,
            enum__Torappu_RoguelikeFragmentType::NONE,
        );
    }
    #[inline]
    pub fn add_typeName(&mut self, typeName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentTypeData::VT_TYPENAME,
            typeName,
        );
    }
    #[inline]
    pub fn add_typeDesc(&mut self, typeDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentTypeData::VT_TYPEDESC,
            typeDesc,
        );
    }
    #[inline]
    pub fn add_typeIconId(&mut self, typeIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentTypeData::VT_TYPEICONID,
            typeIconId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeFragmentTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeFragmentTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeFragmentTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeFragmentTypeData");
        ds.field("type_", &self.type_());
        ds.field("typeName", &self.typeName());
        ds.field("typeDesc", &self.typeDesc());
        ds.field("typeIconId", &self.typeIconId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeFragmentTypeDataT {
    pub type_: enum__Torappu_RoguelikeFragmentType,
    pub typeName: Option<String>,
    pub typeDesc: Option<String>,
    pub typeIconId: Option<String>,
}
impl Default for clz_Torappu_RoguelikeFragmentTypeDataT {
    fn default() -> Self {
        Self {
            type_: enum__Torappu_RoguelikeFragmentType::NONE,
            typeName: None,
            typeDesc: None,
            typeIconId: None,
        }
    }
}
impl clz_Torappu_RoguelikeFragmentTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentTypeData<'b>> {
        let type_ = self.type_;
        let typeName = self.typeName.as_ref().map(|x| _fbb.create_string(x));
        let typeDesc = self.typeDesc.as_ref().map(|x| _fbb.create_string(x));
        let typeIconId = self.typeIconId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeFragmentTypeData::create(
            _fbb,
            &clz_Torappu_RoguelikeFragmentTypeDataArgs {
                type_,
                typeName,
                typeDesc,
                typeIconId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeFragmentTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeFragmentTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeFragmentTypeData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeFragmentTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeFragmentTypeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeFragmentTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeFragmentTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeFragmentTypeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeFragmentTypeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeFragmentTypeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeFragmentTypeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeFragmentTypeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeFragmentTypeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeFragmentTypeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeFragmentTypeData>>(
                    dict__string__clz_Torappu_RoguelikeFragmentTypeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeFragmentTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeFragmentTypeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeFragmentTypeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentTypeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeFragmentTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeFragmentTypeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeFragmentTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeFragmentTypeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeFragmentTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeFragmentTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeFragmentTypeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentTypeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentTypeData>>(
                dict__string__clz_Torappu_RoguelikeFragmentTypeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeFragmentTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeFragmentTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeFragmentTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeFragmentTypeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeFragmentTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeFragmentTypeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeFragmentTypeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeFragmentTypeDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeFragmentTypeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeFragmentTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeFragmentTypeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeFragmentTypeData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeFragmentTypeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeFragmentModuleConstsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeFragmentModuleConsts<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeFragmentModuleConsts<'a> {
    type Inner = clz_Torappu_RoguelikeFragmentModuleConsts<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeFragmentModuleConsts<'a> {
    pub const VT_WEIGHTSTATUSSAFEDESC: flatbuffers::VOffsetT = 4;
    pub const VT_WEIGHTSTATUSLIMITDESC: flatbuffers::VOffsetT = 6;
    pub const VT_WEIGHTSTATUSOVERWEIGHTDESC: flatbuffers::VOffsetT = 8;
    pub const VT_CHARWEIGHTSLOT: flatbuffers::VOffsetT = 10;
    pub const VT_LIMITWEIGHTTHRESHOLDVALUE: flatbuffers::VOffsetT = 12;
    pub const VT_OVERWEIGHTTHRESHOLDVALUE: flatbuffers::VOffsetT = 14;
    pub const VT_MAXALCHEMYFIELD: flatbuffers::VOffsetT = 16;
    pub const VT_MAXALCHEMYCOUNT: flatbuffers::VOffsetT = 18;
    pub const VT_FRAGMENTBAGWEIGHTLIMITTIPS: flatbuffers::VOffsetT = 20;
    pub const VT_FRAGMENTBAGWEIGHTOVERWEIGHTTIPS: flatbuffers::VOffsetT = 22;
    pub const VT_WEIGHTUPGRADETOASTFORMAT: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeFragmentModuleConsts { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeFragmentModuleConstsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentModuleConsts<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeFragmentModuleConstsBuilder::new(_fbb);
        if let Some(x) = args.weightUpgradeToastFormat {
            builder.add_weightUpgradeToastFormat(x);
        }
        if let Some(x) = args.fragmentBagWeightOverWeightTips {
            builder.add_fragmentBagWeightOverWeightTips(x);
        }
        if let Some(x) = args.fragmentBagWeightLimitTips {
            builder.add_fragmentBagWeightLimitTips(x);
        }
        builder.add_maxAlchemyCount(args.maxAlchemyCount);
        builder.add_maxAlchemyField(args.maxAlchemyField);
        builder.add_overWeightThresholdValue(args.overWeightThresholdValue);
        builder.add_limitWeightThresholdValue(args.limitWeightThresholdValue);
        builder.add_charWeightSlot(args.charWeightSlot);
        if let Some(x) = args.weightStatusOverweightDesc {
            builder.add_weightStatusOverweightDesc(x);
        }
        if let Some(x) = args.weightStatusLimitDesc {
            builder.add_weightStatusLimitDesc(x);
        }
        if let Some(x) = args.weightStatusSafeDesc {
            builder.add_weightStatusSafeDesc(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeFragmentModuleConstsT {
        let weightStatusSafeDesc = self.weightStatusSafeDesc().map(|x| x.to_string());
        let weightStatusLimitDesc = self.weightStatusLimitDesc().map(|x| x.to_string());
        let weightStatusOverweightDesc = self.weightStatusOverweightDesc().map(|x| x.to_string());
        let charWeightSlot = self.charWeightSlot();
        let limitWeightThresholdValue = self.limitWeightThresholdValue();
        let overWeightThresholdValue = self.overWeightThresholdValue();
        let maxAlchemyField = self.maxAlchemyField();
        let maxAlchemyCount = self.maxAlchemyCount();
        let fragmentBagWeightLimitTips = self.fragmentBagWeightLimitTips().map(|x| x.to_string());
        let fragmentBagWeightOverWeightTips = self
            .fragmentBagWeightOverWeightTips()
            .map(|x| x.to_string());
        let weightUpgradeToastFormat = self.weightUpgradeToastFormat().map(|x| x.to_string());
        clz_Torappu_RoguelikeFragmentModuleConstsT {
            weightStatusSafeDesc,
            weightStatusLimitDesc,
            weightStatusOverweightDesc,
            charWeightSlot,
            limitWeightThresholdValue,
            overWeightThresholdValue,
            maxAlchemyField,
            maxAlchemyCount,
            fragmentBagWeightLimitTips,
            fragmentBagWeightOverWeightTips,
            weightUpgradeToastFormat,
        }
    }

    #[inline]
    pub fn weightStatusSafeDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeFragmentModuleConsts::VT_WEIGHTSTATUSSAFEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn weightStatusLimitDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeFragmentModuleConsts::VT_WEIGHTSTATUSLIMITDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn weightStatusOverweightDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeFragmentModuleConsts::VT_WEIGHTSTATUSOVERWEIGHTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn charWeightSlot(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeFragmentModuleConsts::VT_CHARWEIGHTSLOT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn limitWeightThresholdValue(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeFragmentModuleConsts::VT_LIMITWEIGHTTHRESHOLDVALUE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn overWeightThresholdValue(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeFragmentModuleConsts::VT_OVERWEIGHTTHRESHOLDVALUE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxAlchemyField(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeFragmentModuleConsts::VT_MAXALCHEMYFIELD,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxAlchemyCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeFragmentModuleConsts::VT_MAXALCHEMYCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fragmentBagWeightLimitTips(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeFragmentModuleConsts::VT_FRAGMENTBAGWEIGHTLIMITTIPS,
                None,
            )
        }
    }
    #[inline]
    pub fn fragmentBagWeightOverWeightTips(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeFragmentModuleConsts::VT_FRAGMENTBAGWEIGHTOVERWEIGHTTIPS,
                None,
            )
        }
    }
    #[inline]
    pub fn weightUpgradeToastFormat(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeFragmentModuleConsts::VT_WEIGHTUPGRADETOASTFORMAT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeFragmentModuleConsts<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weightStatusSafeDesc",
                Self::VT_WEIGHTSTATUSSAFEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weightStatusLimitDesc",
                Self::VT_WEIGHTSTATUSLIMITDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weightStatusOverweightDesc",
                Self::VT_WEIGHTSTATUSOVERWEIGHTDESC,
                false,
            )?
            .visit_field::<i32>("charWeightSlot", Self::VT_CHARWEIGHTSLOT, false)?
            .visit_field::<i32>(
                "limitWeightThresholdValue",
                Self::VT_LIMITWEIGHTTHRESHOLDVALUE,
                false,
            )?
            .visit_field::<i32>(
                "overWeightThresholdValue",
                Self::VT_OVERWEIGHTTHRESHOLDVALUE,
                false,
            )?
            .visit_field::<i32>("maxAlchemyField", Self::VT_MAXALCHEMYFIELD, false)?
            .visit_field::<i32>("maxAlchemyCount", Self::VT_MAXALCHEMYCOUNT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "fragmentBagWeightLimitTips",
                Self::VT_FRAGMENTBAGWEIGHTLIMITTIPS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "fragmentBagWeightOverWeightTips",
                Self::VT_FRAGMENTBAGWEIGHTOVERWEIGHTTIPS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weightUpgradeToastFormat",
                Self::VT_WEIGHTUPGRADETOASTFORMAT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeFragmentModuleConstsArgs<'a> {
    pub weightStatusSafeDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weightStatusLimitDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weightStatusOverweightDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub charWeightSlot: i32,
    pub limitWeightThresholdValue: i32,
    pub overWeightThresholdValue: i32,
    pub maxAlchemyField: i32,
    pub maxAlchemyCount: i32,
    pub fragmentBagWeightLimitTips: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fragmentBagWeightOverWeightTips: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weightUpgradeToastFormat: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeFragmentModuleConstsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeFragmentModuleConstsArgs {
            weightStatusSafeDesc: None,
            weightStatusLimitDesc: None,
            weightStatusOverweightDesc: None,
            charWeightSlot: 0,
            limitWeightThresholdValue: 0,
            overWeightThresholdValue: 0,
            maxAlchemyField: 0,
            maxAlchemyCount: 0,
            fragmentBagWeightLimitTips: None,
            fragmentBagWeightOverWeightTips: None,
            weightUpgradeToastFormat: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeFragmentModuleConsts<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeFragmentModuleConsts", 11)?;
        if let Some(f) = self.weightStatusSafeDesc() {
            s.serialize_field("weightStatusSafeDesc", &f)?;
        } else {
            s.skip_field("weightStatusSafeDesc")?;
        }
        if let Some(f) = self.weightStatusLimitDesc() {
            s.serialize_field("weightStatusLimitDesc", &f)?;
        } else {
            s.skip_field("weightStatusLimitDesc")?;
        }
        if let Some(f) = self.weightStatusOverweightDesc() {
            s.serialize_field("weightStatusOverweightDesc", &f)?;
        } else {
            s.skip_field("weightStatusOverweightDesc")?;
        }
        s.serialize_field("charWeightSlot", &self.charWeightSlot())?;
        s.serialize_field(
            "limitWeightThresholdValue",
            &self.limitWeightThresholdValue(),
        )?;
        s.serialize_field("overWeightThresholdValue", &self.overWeightThresholdValue())?;
        s.serialize_field("maxAlchemyField", &self.maxAlchemyField())?;
        s.serialize_field("maxAlchemyCount", &self.maxAlchemyCount())?;
        if let Some(f) = self.fragmentBagWeightLimitTips() {
            s.serialize_field("fragmentBagWeightLimitTips", &f)?;
        } else {
            s.skip_field("fragmentBagWeightLimitTips")?;
        }
        if let Some(f) = self.fragmentBagWeightOverWeightTips() {
            s.serialize_field("fragmentBagWeightOverWeightTips", &f)?;
        } else {
            s.skip_field("fragmentBagWeightOverWeightTips")?;
        }
        if let Some(f) = self.weightUpgradeToastFormat() {
            s.serialize_field("weightUpgradeToastFormat", &f)?;
        } else {
            s.skip_field("weightUpgradeToastFormat")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeFragmentModuleConstsBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeFragmentModuleConstsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_weightStatusSafeDesc(
        &mut self,
        weightStatusSafeDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentModuleConsts::VT_WEIGHTSTATUSSAFEDESC,
            weightStatusSafeDesc,
        );
    }
    #[inline]
    pub fn add_weightStatusLimitDesc(
        &mut self,
        weightStatusLimitDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentModuleConsts::VT_WEIGHTSTATUSLIMITDESC,
            weightStatusLimitDesc,
        );
    }
    #[inline]
    pub fn add_weightStatusOverweightDesc(
        &mut self,
        weightStatusOverweightDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentModuleConsts::VT_WEIGHTSTATUSOVERWEIGHTDESC,
            weightStatusOverweightDesc,
        );
    }
    #[inline]
    pub fn add_charWeightSlot(&mut self, charWeightSlot: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeFragmentModuleConsts::VT_CHARWEIGHTSLOT,
            charWeightSlot,
            0,
        );
    }
    #[inline]
    pub fn add_limitWeightThresholdValue(&mut self, limitWeightThresholdValue: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeFragmentModuleConsts::VT_LIMITWEIGHTTHRESHOLDVALUE,
            limitWeightThresholdValue,
            0,
        );
    }
    #[inline]
    pub fn add_overWeightThresholdValue(&mut self, overWeightThresholdValue: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeFragmentModuleConsts::VT_OVERWEIGHTTHRESHOLDVALUE,
            overWeightThresholdValue,
            0,
        );
    }
    #[inline]
    pub fn add_maxAlchemyField(&mut self, maxAlchemyField: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeFragmentModuleConsts::VT_MAXALCHEMYFIELD,
            maxAlchemyField,
            0,
        );
    }
    #[inline]
    pub fn add_maxAlchemyCount(&mut self, maxAlchemyCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeFragmentModuleConsts::VT_MAXALCHEMYCOUNT,
            maxAlchemyCount,
            0,
        );
    }
    #[inline]
    pub fn add_fragmentBagWeightLimitTips(
        &mut self,
        fragmentBagWeightLimitTips: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentModuleConsts::VT_FRAGMENTBAGWEIGHTLIMITTIPS,
            fragmentBagWeightLimitTips,
        );
    }
    #[inline]
    pub fn add_fragmentBagWeightOverWeightTips(
        &mut self,
        fragmentBagWeightOverWeightTips: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentModuleConsts::VT_FRAGMENTBAGWEIGHTOVERWEIGHTTIPS,
            fragmentBagWeightOverWeightTips,
        );
    }
    #[inline]
    pub fn add_weightUpgradeToastFormat(
        &mut self,
        weightUpgradeToastFormat: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentModuleConsts::VT_WEIGHTUPGRADETOASTFORMAT,
            weightUpgradeToastFormat,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeFragmentModuleConstsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeFragmentModuleConstsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentModuleConsts<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeFragmentModuleConsts<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeFragmentModuleConsts");
        ds.field("weightStatusSafeDesc", &self.weightStatusSafeDesc());
        ds.field("weightStatusLimitDesc", &self.weightStatusLimitDesc());
        ds.field(
            "weightStatusOverweightDesc",
            &self.weightStatusOverweightDesc(),
        );
        ds.field("charWeightSlot", &self.charWeightSlot());
        ds.field(
            "limitWeightThresholdValue",
            &self.limitWeightThresholdValue(),
        );
        ds.field("overWeightThresholdValue", &self.overWeightThresholdValue());
        ds.field("maxAlchemyField", &self.maxAlchemyField());
        ds.field("maxAlchemyCount", &self.maxAlchemyCount());
        ds.field(
            "fragmentBagWeightLimitTips",
            &self.fragmentBagWeightLimitTips(),
        );
        ds.field(
            "fragmentBagWeightOverWeightTips",
            &self.fragmentBagWeightOverWeightTips(),
        );
        ds.field("weightUpgradeToastFormat", &self.weightUpgradeToastFormat());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeFragmentModuleConstsT {
    pub weightStatusSafeDesc: Option<String>,
    pub weightStatusLimitDesc: Option<String>,
    pub weightStatusOverweightDesc: Option<String>,
    pub charWeightSlot: i32,
    pub limitWeightThresholdValue: i32,
    pub overWeightThresholdValue: i32,
    pub maxAlchemyField: i32,
    pub maxAlchemyCount: i32,
    pub fragmentBagWeightLimitTips: Option<String>,
    pub fragmentBagWeightOverWeightTips: Option<String>,
    pub weightUpgradeToastFormat: Option<String>,
}
impl Default for clz_Torappu_RoguelikeFragmentModuleConstsT {
    fn default() -> Self {
        Self {
            weightStatusSafeDesc: None,
            weightStatusLimitDesc: None,
            weightStatusOverweightDesc: None,
            charWeightSlot: 0,
            limitWeightThresholdValue: 0,
            overWeightThresholdValue: 0,
            maxAlchemyField: 0,
            maxAlchemyCount: 0,
            fragmentBagWeightLimitTips: None,
            fragmentBagWeightOverWeightTips: None,
            weightUpgradeToastFormat: None,
        }
    }
}
impl clz_Torappu_RoguelikeFragmentModuleConstsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentModuleConsts<'b>> {
        let weightStatusSafeDesc = self
            .weightStatusSafeDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let weightStatusLimitDesc = self
            .weightStatusLimitDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let weightStatusOverweightDesc = self
            .weightStatusOverweightDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let charWeightSlot = self.charWeightSlot;
        let limitWeightThresholdValue = self.limitWeightThresholdValue;
        let overWeightThresholdValue = self.overWeightThresholdValue;
        let maxAlchemyField = self.maxAlchemyField;
        let maxAlchemyCount = self.maxAlchemyCount;
        let fragmentBagWeightLimitTips = self
            .fragmentBagWeightLimitTips
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let fragmentBagWeightOverWeightTips = self
            .fragmentBagWeightOverWeightTips
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let weightUpgradeToastFormat = self
            .weightUpgradeToastFormat
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeFragmentModuleConsts::create(
            _fbb,
            &clz_Torappu_RoguelikeFragmentModuleConstsArgs {
                weightStatusSafeDesc,
                weightStatusLimitDesc,
                weightStatusOverweightDesc,
                charWeightSlot,
                limitWeightThresholdValue,
                overWeightThresholdValue,
                maxAlchemyField,
                maxAlchemyCount,
                fragmentBagWeightLimitTips,
                fragmentBagWeightOverWeightTips,
                weightUpgradeToastFormat,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeFragmentBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeFragmentBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeFragmentBuffData<'a> {
    type Inner = clz_Torappu_RoguelikeFragmentBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeFragmentBuffData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_MASKTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeFragmentBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeFragmentBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentBuffData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeFragmentBuffDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        builder.add_maskType(args.maskType);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeFragmentBuffDataT {
        let itemId = self.itemId().map(|x| x.to_string());
        let maskType = self.maskType();
        let desc = self.desc().map(|x| x.to_string());
        clz_Torappu_RoguelikeFragmentBuffDataT {
            itemId,
            maskType,
            desc,
        }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeFragmentBuffData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn maskType(&self) -> enum__Torappu_RoguelikeEventType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeEventType>(
                    clz_Torappu_RoguelikeFragmentBuffData::VT_MASKTYPE,
                    Some(enum__Torappu_RoguelikeEventType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeFragmentBuffData::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeFragmentBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<enum__Torappu_RoguelikeEventType>("maskType", Self::VT_MASKTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeFragmentBuffDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maskType: enum__Torappu_RoguelikeEventType,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeFragmentBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeFragmentBuffDataArgs {
            itemId: None,
            maskType: enum__Torappu_RoguelikeEventType::NONE,
            desc: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeFragmentBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeFragmentBuffData", 3)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        s.serialize_field("maskType", &self.maskType())?;
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeFragmentBuffDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeFragmentBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentBuffData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_maskType(&mut self, maskType: enum__Torappu_RoguelikeEventType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeEventType>(
            clz_Torappu_RoguelikeFragmentBuffData::VT_MASKTYPE,
            maskType,
            enum__Torappu_RoguelikeEventType::NONE,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentBuffData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeFragmentBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeFragmentBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeFragmentBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeFragmentBuffData");
        ds.field("itemId", &self.itemId());
        ds.field("maskType", &self.maskType());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeFragmentBuffDataT {
    pub itemId: Option<String>,
    pub maskType: enum__Torappu_RoguelikeEventType,
    pub desc: Option<String>,
}
impl Default for clz_Torappu_RoguelikeFragmentBuffDataT {
    fn default() -> Self {
        Self {
            itemId: None,
            maskType: enum__Torappu_RoguelikeEventType::NONE,
            desc: None,
        }
    }
}
impl clz_Torappu_RoguelikeFragmentBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentBuffData<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let maskType = self.maskType;
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeFragmentBuffData::create(
            _fbb,
            &clz_Torappu_RoguelikeFragmentBuffDataArgs {
                itemId,
                maskType,
                desc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeFragmentBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeFragmentBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeFragmentBuffData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeFragmentBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeFragmentBuffData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeFragmentBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeFragmentBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeFragmentBuffData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeFragmentBuffDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeFragmentBuffDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeFragmentBuffDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeFragmentBuffData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeFragmentBuffData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeFragmentBuffData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeFragmentBuffData>>(
                    dict__string__clz_Torappu_RoguelikeFragmentBuffData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeFragmentBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeFragmentBuffData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeFragmentBuffDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentBuffData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeFragmentBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeFragmentBuffDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeFragmentBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeFragmentBuffData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeFragmentBuffDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeFragmentBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeFragmentBuffData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentBuffData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentBuffData>>(
                dict__string__clz_Torappu_RoguelikeFragmentBuffData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeFragmentBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeFragmentBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeFragmentBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeFragmentBuffData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeFragmentBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeFragmentBuffData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeFragmentBuffDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeFragmentBuffDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeFragmentBuffDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeFragmentBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeFragmentBuffData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeFragmentBuffData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeFragmentBuffDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeAlchemyDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeAlchemyData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeAlchemyData<'a> {
    type Inner = clz_Torappu_RoguelikeAlchemyData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeAlchemyData<'a> {
    pub const VT_FRAGMENTTYPELIST: flatbuffers::VOffsetT = 4;
    pub const VT_FRAGMENTSQUARESUM: flatbuffers::VOffsetT = 6;
    pub const VT_POOLRARITY: flatbuffers::VOffsetT = 8;
    pub const VT_RELICPROP: flatbuffers::VOffsetT = 10;
    pub const VT_SHIELDPROP: flatbuffers::VOffsetT = 12;
    pub const VT_POPULATIONPROP: flatbuffers::VOffsetT = 14;
    pub const VT_OVERRIDECONDITIONBANDIDS: flatbuffers::VOffsetT = 16;
    pub const VT_OVERRIDERECIPEID: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeAlchemyData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeAlchemyDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeAlchemyData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeAlchemyDataBuilder::new(_fbb);
        if let Some(x) = args.overrideRecipeId {
            builder.add_overrideRecipeId(x);
        }
        if let Some(x) = args.overrideConditionBandIds {
            builder.add_overrideConditionBandIds(x);
        }
        builder.add_populationProp(args.populationProp);
        builder.add_shieldProp(args.shieldProp);
        builder.add_relicProp(args.relicProp);
        builder.add_poolRarity(args.poolRarity);
        builder.add_fragmentSquareSum(args.fragmentSquareSum);
        if let Some(x) = args.fragmentTypeList {
            builder.add_fragmentTypeList(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeAlchemyDataT {
        let fragmentTypeList = self.fragmentTypeList().map(|x| x.into_iter().collect());
        let fragmentSquareSum = self.fragmentSquareSum();
        let poolRarity = self.poolRarity();
        let relicProp = self.relicProp();
        let shieldProp = self.shieldProp();
        let populationProp = self.populationProp();
        let overrideConditionBandIds = self
            .overrideConditionBandIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let overrideRecipeId = self.overrideRecipeId().map(|x| x.to_string());
        clz_Torappu_RoguelikeAlchemyDataT {
            fragmentTypeList,
            fragmentSquareSum,
            poolRarity,
            relicProp,
            shieldProp,
            populationProp,
            overrideConditionBandIds,
            overrideRecipeId,
        }
    }

    #[inline]
    pub fn fragmentTypeList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_RoguelikeFragmentType>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_RoguelikeFragmentType>,
            >>(clz_Torappu_RoguelikeAlchemyData::VT_FRAGMENTTYPELIST, None)
        }
    }
    #[inline]
    pub fn fragmentSquareSum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeAlchemyData::VT_FRAGMENTSQUARESUM,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn poolRarity(&self) -> enum__Torappu_AlchemyPoolRarityType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_AlchemyPoolRarityType>(
                    clz_Torappu_RoguelikeAlchemyData::VT_POOLRARITY,
                    Some(enum__Torappu_AlchemyPoolRarityType::NORMAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn relicProp(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_RoguelikeAlchemyData::VT_RELICPROP, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn shieldProp(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_RoguelikeAlchemyData::VT_SHIELDPROP, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn populationProp(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_RoguelikeAlchemyData::VT_POPULATIONPROP,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn overrideConditionBandIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RoguelikeAlchemyData::VT_OVERRIDECONDITIONBANDIDS,
                None,
            )
        }
    }
    #[inline]
    pub fn overrideRecipeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeAlchemyData::VT_OVERRIDERECIPEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeAlchemyData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, enum__Torappu_RoguelikeFragmentType>,
            >>("fragmentTypeList", Self::VT_FRAGMENTTYPELIST, false)?
            .visit_field::<i32>("fragmentSquareSum", Self::VT_FRAGMENTSQUARESUM, false)?
            .visit_field::<enum__Torappu_AlchemyPoolRarityType>(
                "poolRarity",
                Self::VT_POOLRARITY,
                false,
            )?
            .visit_field::<f32>("relicProp", Self::VT_RELICPROP, false)?
            .visit_field::<f32>("shieldProp", Self::VT_SHIELDPROP, false)?
            .visit_field::<f32>("populationProp", Self::VT_POPULATIONPROP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "overrideConditionBandIds",
                Self::VT_OVERRIDECONDITIONBANDIDS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "overrideRecipeId",
                Self::VT_OVERRIDERECIPEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeAlchemyDataArgs<'a> {
    pub fragmentTypeList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_RoguelikeFragmentType>>,
    >,
    pub fragmentSquareSum: i32,
    pub poolRarity: enum__Torappu_AlchemyPoolRarityType,
    pub relicProp: f32,
    pub shieldProp: f32,
    pub populationProp: f32,
    pub overrideConditionBandIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub overrideRecipeId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeAlchemyDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeAlchemyDataArgs {
            fragmentTypeList: None,
            fragmentSquareSum: 0,
            poolRarity: enum__Torappu_AlchemyPoolRarityType::NORMAL,
            relicProp: 0.0,
            shieldProp: 0.0,
            populationProp: 0.0,
            overrideConditionBandIds: None,
            overrideRecipeId: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeAlchemyData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeAlchemyData", 8)?;
        if let Some(f) = self.fragmentTypeList() {
            s.serialize_field("fragmentTypeList", &f)?;
        } else {
            s.skip_field("fragmentTypeList")?;
        }
        s.serialize_field("fragmentSquareSum", &self.fragmentSquareSum())?;
        s.serialize_field("poolRarity", &self.poolRarity())?;
        s.serialize_field("relicProp", &self.relicProp())?;
        s.serialize_field("shieldProp", &self.shieldProp())?;
        s.serialize_field("populationProp", &self.populationProp())?;
        if let Some(f) = self.overrideConditionBandIds() {
            s.serialize_field("overrideConditionBandIds", &f)?;
        } else {
            s.skip_field("overrideConditionBandIds")?;
        }
        if let Some(f) = self.overrideRecipeId() {
            s.serialize_field("overrideRecipeId", &f)?;
        } else {
            s.skip_field("overrideRecipeId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeAlchemyDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeAlchemyDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_fragmentTypeList(
        &mut self,
        fragmentTypeList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_RoguelikeFragmentType>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeAlchemyData::VT_FRAGMENTTYPELIST,
            fragmentTypeList,
        );
    }
    #[inline]
    pub fn add_fragmentSquareSum(&mut self, fragmentSquareSum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeAlchemyData::VT_FRAGMENTSQUARESUM,
            fragmentSquareSum,
            0,
        );
    }
    #[inline]
    pub fn add_poolRarity(&mut self, poolRarity: enum__Torappu_AlchemyPoolRarityType) {
        self.fbb_.push_slot::<enum__Torappu_AlchemyPoolRarityType>(
            clz_Torappu_RoguelikeAlchemyData::VT_POOLRARITY,
            poolRarity,
            enum__Torappu_AlchemyPoolRarityType::NORMAL,
        );
    }
    #[inline]
    pub fn add_relicProp(&mut self, relicProp: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_RoguelikeAlchemyData::VT_RELICPROP,
            relicProp,
            0.0,
        );
    }
    #[inline]
    pub fn add_shieldProp(&mut self, shieldProp: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_RoguelikeAlchemyData::VT_SHIELDPROP,
            shieldProp,
            0.0,
        );
    }
    #[inline]
    pub fn add_populationProp(&mut self, populationProp: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_RoguelikeAlchemyData::VT_POPULATIONPROP,
            populationProp,
            0.0,
        );
    }
    #[inline]
    pub fn add_overrideConditionBandIds(
        &mut self,
        overrideConditionBandIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeAlchemyData::VT_OVERRIDECONDITIONBANDIDS,
            overrideConditionBandIds,
        );
    }
    #[inline]
    pub fn add_overrideRecipeId(&mut self, overrideRecipeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeAlchemyData::VT_OVERRIDERECIPEID,
            overrideRecipeId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeAlchemyDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeAlchemyDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeAlchemyData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeAlchemyData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeAlchemyData");
        ds.field("fragmentTypeList", &self.fragmentTypeList());
        ds.field("fragmentSquareSum", &self.fragmentSquareSum());
        ds.field("poolRarity", &self.poolRarity());
        ds.field("relicProp", &self.relicProp());
        ds.field("shieldProp", &self.shieldProp());
        ds.field("populationProp", &self.populationProp());
        ds.field("overrideConditionBandIds", &self.overrideConditionBandIds());
        ds.field("overrideRecipeId", &self.overrideRecipeId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeAlchemyDataT {
    pub fragmentTypeList: Option<Vec<enum__Torappu_RoguelikeFragmentType>>,
    pub fragmentSquareSum: i32,
    pub poolRarity: enum__Torappu_AlchemyPoolRarityType,
    pub relicProp: f32,
    pub shieldProp: f32,
    pub populationProp: f32,
    pub overrideConditionBandIds: Option<Vec<String>>,
    pub overrideRecipeId: Option<String>,
}
impl Default for clz_Torappu_RoguelikeAlchemyDataT {
    fn default() -> Self {
        Self {
            fragmentTypeList: None,
            fragmentSquareSum: 0,
            poolRarity: enum__Torappu_AlchemyPoolRarityType::NORMAL,
            relicProp: 0.0,
            shieldProp: 0.0,
            populationProp: 0.0,
            overrideConditionBandIds: None,
            overrideRecipeId: None,
        }
    }
}
impl clz_Torappu_RoguelikeAlchemyDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeAlchemyData<'b>> {
        let fragmentTypeList = self
            .fragmentTypeList
            .as_ref()
            .map(|x| _fbb.create_vector(x));
        let fragmentSquareSum = self.fragmentSquareSum;
        let poolRarity = self.poolRarity;
        let relicProp = self.relicProp;
        let shieldProp = self.shieldProp;
        let populationProp = self.populationProp;
        let overrideConditionBandIds = self.overrideConditionBandIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let overrideRecipeId = self
            .overrideRecipeId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeAlchemyData::create(
            _fbb,
            &clz_Torappu_RoguelikeAlchemyDataArgs {
                fragmentTypeList,
                fragmentSquareSum,
                poolRarity,
                relicProp,
                shieldProp,
                populationProp,
                overrideConditionBandIds,
                overrideRecipeId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeAlchemyDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeAlchemyData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeAlchemyData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeAlchemyData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeAlchemyData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeAlchemyData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeAlchemyDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeAlchemyData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeAlchemyDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeAlchemyDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeAlchemyDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeAlchemyData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeAlchemyData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeAlchemyData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeAlchemyData>>(
                    dict__string__clz_Torappu_RoguelikeAlchemyData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeAlchemyData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeAlchemyData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeAlchemyDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeAlchemyData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeAlchemyDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeAlchemyDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeAlchemyData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeAlchemyData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeAlchemyDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeAlchemyDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeAlchemyData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeAlchemyData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeAlchemyData>>(
                dict__string__clz_Torappu_RoguelikeAlchemyData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeAlchemyDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeAlchemyDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeAlchemyData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeAlchemyData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeAlchemyData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeAlchemyData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeAlchemyDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeAlchemyDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeAlchemyDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeAlchemyDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeAlchemyData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeAlchemyData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeAlchemyDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeAlchemyFormulationDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeAlchemyFormulationData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeAlchemyFormulationData<'a> {
    type Inner = clz_Torappu_RoguelikeAlchemyFormulationData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeAlchemyFormulationData<'a> {
    pub const VT_FRAGMENTIDS: flatbuffers::VOffsetT = 4;
    pub const VT_REWARDID: flatbuffers::VOffsetT = 6;
    pub const VT_REWARDCOUNT: flatbuffers::VOffsetT = 8;
    pub const VT_REWARDITEMTYPE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeAlchemyFormulationData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeAlchemyFormulationDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeAlchemyFormulationData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeAlchemyFormulationDataBuilder::new(_fbb);
        builder.add_rewardItemType(args.rewardItemType);
        builder.add_rewardCount(args.rewardCount);
        if let Some(x) = args.rewardId {
            builder.add_rewardId(x);
        }
        if let Some(x) = args.fragmentIds {
            builder.add_fragmentIds(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeAlchemyFormulationDataT {
        let fragmentIds = self
            .fragmentIds()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let rewardId = self.rewardId().map(|x| x.to_string());
        let rewardCount = self.rewardCount();
        let rewardItemType = self.rewardItemType();
        clz_Torappu_RoguelikeAlchemyFormulationDataT {
            fragmentIds,
            rewardId,
            rewardCount,
            rewardItemType,
        }
    }

    #[inline]
    pub fn fragmentIds(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RoguelikeAlchemyFormulationData::VT_FRAGMENTIDS,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeAlchemyFormulationData::VT_REWARDID,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeAlchemyFormulationData::VT_REWARDCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rewardItemType(&self) -> enum__Torappu_RoguelikeGameItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeGameItemType>(
                    clz_Torappu_RoguelikeAlchemyFormulationData::VT_REWARDITEMTYPE,
                    Some(enum__Torappu_RoguelikeGameItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeAlchemyFormulationData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("fragmentIds", Self::VT_FRAGMENTIDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "rewardId",
                Self::VT_REWARDID,
                false,
            )?
            .visit_field::<i32>("rewardCount", Self::VT_REWARDCOUNT, false)?
            .visit_field::<enum__Torappu_RoguelikeGameItemType>(
                "rewardItemType",
                Self::VT_REWARDITEMTYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeAlchemyFormulationDataArgs<'a> {
    pub fragmentIds: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub rewardId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewardCount: i32,
    pub rewardItemType: enum__Torappu_RoguelikeGameItemType,
}
impl<'a> Default for clz_Torappu_RoguelikeAlchemyFormulationDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeAlchemyFormulationDataArgs {
            fragmentIds: None,
            rewardId: None,
            rewardCount: 0,
            rewardItemType: enum__Torappu_RoguelikeGameItemType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeAlchemyFormulationData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeAlchemyFormulationData", 4)?;
        if let Some(f) = self.fragmentIds() {
            s.serialize_field("fragmentIds", &f)?;
        } else {
            s.skip_field("fragmentIds")?;
        }
        if let Some(f) = self.rewardId() {
            s.serialize_field("rewardId", &f)?;
        } else {
            s.skip_field("rewardId")?;
        }
        s.serialize_field("rewardCount", &self.rewardCount())?;
        s.serialize_field("rewardItemType", &self.rewardItemType())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeAlchemyFormulationDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeAlchemyFormulationDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_fragmentIds(
        &mut self,
        fragmentIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeAlchemyFormulationData::VT_FRAGMENTIDS,
            fragmentIds,
        );
    }
    #[inline]
    pub fn add_rewardId(&mut self, rewardId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeAlchemyFormulationData::VT_REWARDID,
            rewardId,
        );
    }
    #[inline]
    pub fn add_rewardCount(&mut self, rewardCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeAlchemyFormulationData::VT_REWARDCOUNT,
            rewardCount,
            0,
        );
    }
    #[inline]
    pub fn add_rewardItemType(&mut self, rewardItemType: enum__Torappu_RoguelikeGameItemType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeGameItemType>(
            clz_Torappu_RoguelikeAlchemyFormulationData::VT_REWARDITEMTYPE,
            rewardItemType,
            enum__Torappu_RoguelikeGameItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeAlchemyFormulationDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeAlchemyFormulationDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeAlchemyFormulationData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeAlchemyFormulationData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeAlchemyFormulationData");
        ds.field("fragmentIds", &self.fragmentIds());
        ds.field("rewardId", &self.rewardId());
        ds.field("rewardCount", &self.rewardCount());
        ds.field("rewardItemType", &self.rewardItemType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeAlchemyFormulationDataT {
    pub fragmentIds: Option<Vec<String>>,
    pub rewardId: Option<String>,
    pub rewardCount: i32,
    pub rewardItemType: enum__Torappu_RoguelikeGameItemType,
}
impl Default for clz_Torappu_RoguelikeAlchemyFormulationDataT {
    fn default() -> Self {
        Self {
            fragmentIds: None,
            rewardId: None,
            rewardCount: 0,
            rewardItemType: enum__Torappu_RoguelikeGameItemType::NONE,
        }
    }
}
impl clz_Torappu_RoguelikeAlchemyFormulationDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeAlchemyFormulationData<'b>> {
        let fragmentIds = self.fragmentIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let rewardId = self.rewardId.as_ref().map(|x| _fbb.create_string(x));
        let rewardCount = self.rewardCount;
        let rewardItemType = self.rewardItemType;
        clz_Torappu_RoguelikeAlchemyFormulationData::create(
            _fbb,
            &clz_Torappu_RoguelikeAlchemyFormulationDataArgs {
                fragmentIds,
                rewardId,
                rewardCount,
                rewardItemType,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeAlchemyFormulationData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeAlchemyFormulationData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeAlchemyFormulationData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeAlchemyFormulationData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeAlchemyFormulationData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeAlchemyFormulationData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeAlchemyFormulationData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeAlchemyFormulationData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeAlchemyFormulationData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeAlchemyFormulationData>>(
                    dict__string__clz_Torappu_RoguelikeAlchemyFormulationData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeAlchemyFormulationData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeAlchemyFormulationData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeAlchemyFormulationData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeAlchemyFormulationData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_RoguelikeAlchemyFormulationData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeAlchemyFormulationData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeAlchemyFormulationData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeAlchemyFormulationData>>(dict__string__clz_Torappu_RoguelikeAlchemyFormulationData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeAlchemyFormulationData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeAlchemyFormulationData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeAlchemyFormulationData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeAlchemyFormulationData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeAlchemyFormulationDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeAlchemyFormulationData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeAlchemyFormulationData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeFragmentLevelRelatedDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeFragmentLevelRelatedData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeFragmentLevelRelatedData<'a> {
    type Inner = clz_Torappu_RoguelikeFragmentLevelRelatedData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeFragmentLevelRelatedData<'a> {
    pub const VT_WEIGHTUP: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeFragmentLevelRelatedData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeFragmentLevelRelatedDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentLevelRelatedData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeFragmentLevelRelatedDataBuilder::new(_fbb);
        builder.add_weightUp(args.weightUp);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeFragmentLevelRelatedDataT {
        let weightUp = self.weightUp();
        clz_Torappu_RoguelikeFragmentLevelRelatedDataT { weightUp }
    }

    #[inline]
    pub fn weightUp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeFragmentLevelRelatedData::VT_WEIGHTUP,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeFragmentLevelRelatedData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("weightUp", Self::VT_WEIGHTUP, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeFragmentLevelRelatedDataArgs {
    pub weightUp: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeFragmentLevelRelatedDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeFragmentLevelRelatedDataArgs { weightUp: 0 }
    }
}

impl Serialize for clz_Torappu_RoguelikeFragmentLevelRelatedData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeFragmentLevelRelatedData", 1)?;
        s.serialize_field("weightUp", &self.weightUp())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeFragmentLevelRelatedDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeFragmentLevelRelatedDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_weightUp(&mut self, weightUp: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeFragmentLevelRelatedData::VT_WEIGHTUP,
            weightUp,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeFragmentLevelRelatedDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeFragmentLevelRelatedDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentLevelRelatedData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeFragmentLevelRelatedData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeFragmentLevelRelatedData");
        ds.field("weightUp", &self.weightUp());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeFragmentLevelRelatedDataT {
    pub weightUp: i32,
}
impl Default for clz_Torappu_RoguelikeFragmentLevelRelatedDataT {
    fn default() -> Self {
        Self { weightUp: 0 }
    }
}
impl clz_Torappu_RoguelikeFragmentLevelRelatedDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentLevelRelatedData<'b>> {
        let weightUp = self.weightUp;
        clz_Torappu_RoguelikeFragmentLevelRelatedData::create(
            _fbb,
            &clz_Torappu_RoguelikeFragmentLevelRelatedDataArgs { weightUp },
        )
    }
}
pub enum dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData<'a> {
    type Inner = dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData<'bldr>>
    {
        let mut builder =
            dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataT {
        let key = self.key();
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeFragmentLevelRelatedData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeFragmentLevelRelatedData>>(
                    dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<i32>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeFragmentLevelRelatedData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataArgs<'a> {
    pub key: i32,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentLevelRelatedData<'a>>>,
}
impl<'a> Default for dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataArgs {
            key: 0,
            value: None,
        }
    }
}

impl Serialize for dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentLevelRelatedData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentLevelRelatedData>>(dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataT {
    pub key: i32,
    pub value: Option<Box<clz_Torappu_RoguelikeFragmentLevelRelatedDataT>>,
}
impl Default for dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataT {
    fn default() -> Self {
        Self {
            key: 0,
            value: None,
        }
    }
}
impl dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData<'b>> {
        let key = self.key;
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData::create(
            _fbb,
            &dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeFragmentModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeFragmentModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeFragmentModuleData<'a> {
    type Inner = clz_Torappu_RoguelikeFragmentModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeFragmentModuleData<'a> {
    pub const VT_FRAGMENTDATA: flatbuffers::VOffsetT = 4;
    pub const VT_FRAGMENTTYPEDATA: flatbuffers::VOffsetT = 6;
    pub const VT_MODULECONSTS: flatbuffers::VOffsetT = 8;
    pub const VT_FRAGMENTBUFFDATA: flatbuffers::VOffsetT = 10;
    pub const VT_ALCHEMYDATA: flatbuffers::VOffsetT = 12;
    pub const VT_ALCHEMYFORMULADATA: flatbuffers::VOffsetT = 14;
    pub const VT_FRAGMENTLEVELDATA: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeFragmentModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeFragmentModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentModuleData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeFragmentModuleDataBuilder::new(_fbb);
        if let Some(x) = args.fragmentLevelData {
            builder.add_fragmentLevelData(x);
        }
        if let Some(x) = args.alchemyFormulaData {
            builder.add_alchemyFormulaData(x);
        }
        if let Some(x) = args.alchemyData {
            builder.add_alchemyData(x);
        }
        if let Some(x) = args.fragmentBuffData {
            builder.add_fragmentBuffData(x);
        }
        if let Some(x) = args.moduleConsts {
            builder.add_moduleConsts(x);
        }
        if let Some(x) = args.fragmentTypeData {
            builder.add_fragmentTypeData(x);
        }
        if let Some(x) = args.fragmentData {
            builder.add_fragmentData(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeFragmentModuleDataT {
        let fragmentData = self
            .fragmentData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let fragmentTypeData = self
            .fragmentTypeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let moduleConsts = self.moduleConsts().map(|x| Box::new(x.unpack()));
        let fragmentBuffData = self
            .fragmentBuffData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let alchemyData = self
            .alchemyData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let alchemyFormulaData = self
            .alchemyFormulaData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let fragmentLevelData = self
            .fragmentLevelData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeFragmentModuleDataT {
            fragmentData,
            fragmentTypeData,
            moduleConsts,
            fragmentBuffData,
            alchemyData,
            alchemyFormulaData,
            fragmentLevelData,
        }
    }

    #[inline]
    pub fn fragmentData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeFragmentData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeFragmentData>,
                >,
            >>(
                clz_Torappu_RoguelikeFragmentModuleData::VT_FRAGMENTDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn fragmentTypeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeFragmentTypeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeFragmentTypeData,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeFragmentModuleData::VT_FRAGMENTTYPEDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn moduleConsts(&self) -> Option<clz_Torappu_RoguelikeFragmentModuleConsts<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeFragmentModuleConsts>>(
                    clz_Torappu_RoguelikeFragmentModuleData::VT_MODULECONSTS,
                    None,
                )
        }
    }
    #[inline]
    pub fn fragmentBuffData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeFragmentBuffData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeFragmentBuffData,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeFragmentModuleData::VT_FRAGMENTBUFFDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn alchemyData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeAlchemyData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeAlchemyData>,
                >,
            >>(
                clz_Torappu_RoguelikeFragmentModuleData::VT_ALCHEMYDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn alchemyFormulaData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeAlchemyFormulationData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeAlchemyFormulationData,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeFragmentModuleData::VT_ALCHEMYFORMULADATA,
                None,
            )
        }
    }
    #[inline]
    pub fn fragmentLevelData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeFragmentModuleData::VT_FRAGMENTLEVELDATA,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeFragmentModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeFragmentData>,
                >,
            >>("fragmentData", Self::VT_FRAGMENTDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeFragmentTypeData,
                    >,
                >,
            >>("fragmentTypeData", Self::VT_FRAGMENTTYPEDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeFragmentModuleConsts>>(
                "moduleConsts",
                Self::VT_MODULECONSTS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeFragmentBuffData,
                    >,
                >,
            >>("fragmentBuffData", Self::VT_FRAGMENTBUFFDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeAlchemyData>,
                >,
            >>("alchemyData", Self::VT_ALCHEMYDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeAlchemyFormulationData,
                    >,
                >,
            >>("alchemyFormulaData", Self::VT_ALCHEMYFORMULADATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData,
                    >,
                >,
            >>("fragmentLevelData", Self::VT_FRAGMENTLEVELDATA, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeFragmentModuleDataArgs<'a> {
    pub fragmentData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeFragmentData<'a>>,
            >,
        >,
    >,
    pub fragmentTypeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeFragmentTypeData<'a>,
                >,
            >,
        >,
    >,
    pub moduleConsts: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentModuleConsts<'a>>>,
    pub fragmentBuffData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeFragmentBuffData<'a>,
                >,
            >,
        >,
    >,
    pub alchemyData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeAlchemyData<'a>>,
            >,
        >,
    >,
    pub alchemyFormulaData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeAlchemyFormulationData<'a>,
                >,
            >,
        >,
    >,
    pub fragmentLevelData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeFragmentModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeFragmentModuleDataArgs {
            fragmentData: None,
            fragmentTypeData: None,
            moduleConsts: None,
            fragmentBuffData: None,
            alchemyData: None,
            alchemyFormulaData: None,
            fragmentLevelData: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeFragmentModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeFragmentModuleData", 7)?;
        if let Some(f) = self.fragmentData() {
            s.serialize_field("fragmentData", &f)?;
        } else {
            s.skip_field("fragmentData")?;
        }
        if let Some(f) = self.fragmentTypeData() {
            s.serialize_field("fragmentTypeData", &f)?;
        } else {
            s.skip_field("fragmentTypeData")?;
        }
        if let Some(f) = self.moduleConsts() {
            s.serialize_field("moduleConsts", &f)?;
        } else {
            s.skip_field("moduleConsts")?;
        }
        if let Some(f) = self.fragmentBuffData() {
            s.serialize_field("fragmentBuffData", &f)?;
        } else {
            s.skip_field("fragmentBuffData")?;
        }
        if let Some(f) = self.alchemyData() {
            s.serialize_field("alchemyData", &f)?;
        } else {
            s.skip_field("alchemyData")?;
        }
        if let Some(f) = self.alchemyFormulaData() {
            s.serialize_field("alchemyFormulaData", &f)?;
        } else {
            s.skip_field("alchemyFormulaData")?;
        }
        if let Some(f) = self.fragmentLevelData() {
            s.serialize_field("fragmentLevelData", &f)?;
        } else {
            s.skip_field("fragmentLevelData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeFragmentModuleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeFragmentModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_fragmentData(
        &mut self,
        fragmentData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeFragmentData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentModuleData::VT_FRAGMENTDATA,
            fragmentData,
        );
    }
    #[inline]
    pub fn add_fragmentTypeData(
        &mut self,
        fragmentTypeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeFragmentTypeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentModuleData::VT_FRAGMENTTYPEDATA,
            fragmentTypeData,
        );
    }
    #[inline]
    pub fn add_moduleConsts(
        &mut self,
        moduleConsts: flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentModuleConsts<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentModuleConsts>>(
                clz_Torappu_RoguelikeFragmentModuleData::VT_MODULECONSTS,
                moduleConsts,
            );
    }
    #[inline]
    pub fn add_fragmentBuffData(
        &mut self,
        fragmentBuffData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeFragmentBuffData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentModuleData::VT_FRAGMENTBUFFDATA,
            fragmentBuffData,
        );
    }
    #[inline]
    pub fn add_alchemyData(
        &mut self,
        alchemyData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeAlchemyData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentModuleData::VT_ALCHEMYDATA,
            alchemyData,
        );
    }
    #[inline]
    pub fn add_alchemyFormulaData(
        &mut self,
        alchemyFormulaData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeAlchemyFormulationData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentModuleData::VT_ALCHEMYFORMULADATA,
            alchemyFormulaData,
        );
    }
    #[inline]
    pub fn add_fragmentLevelData(
        &mut self,
        fragmentLevelData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeFragmentModuleData::VT_FRAGMENTLEVELDATA,
            fragmentLevelData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeFragmentModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeFragmentModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeFragmentModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeFragmentModuleData");
        ds.field("fragmentData", &self.fragmentData());
        ds.field("fragmentTypeData", &self.fragmentTypeData());
        ds.field("moduleConsts", &self.moduleConsts());
        ds.field("fragmentBuffData", &self.fragmentBuffData());
        ds.field("alchemyData", &self.alchemyData());
        ds.field("alchemyFormulaData", &self.alchemyFormulaData());
        ds.field("fragmentLevelData", &self.fragmentLevelData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeFragmentModuleDataT {
    pub fragmentData: Option<Vec<dict__string__clz_Torappu_RoguelikeFragmentDataT>>,
    pub fragmentTypeData: Option<Vec<dict__string__clz_Torappu_RoguelikeFragmentTypeDataT>>,
    pub moduleConsts: Option<Box<clz_Torappu_RoguelikeFragmentModuleConstsT>>,
    pub fragmentBuffData: Option<Vec<dict__string__clz_Torappu_RoguelikeFragmentBuffDataT>>,
    pub alchemyData: Option<Vec<dict__string__clz_Torappu_RoguelikeAlchemyDataT>>,
    pub alchemyFormulaData: Option<Vec<dict__string__clz_Torappu_RoguelikeAlchemyFormulationDataT>>,
    pub fragmentLevelData: Option<Vec<dict__int__clz_Torappu_RoguelikeFragmentLevelRelatedDataT>>,
}
impl Default for clz_Torappu_RoguelikeFragmentModuleDataT {
    fn default() -> Self {
        Self {
            fragmentData: None,
            fragmentTypeData: None,
            moduleConsts: None,
            fragmentBuffData: None,
            alchemyData: None,
            alchemyFormulaData: None,
            fragmentLevelData: None,
        }
    }
}
impl clz_Torappu_RoguelikeFragmentModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentModuleData<'b>> {
        let fragmentData = self.fragmentData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let fragmentTypeData = self.fragmentTypeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let moduleConsts = self.moduleConsts.as_ref().map(|x| x.pack(_fbb));
        let fragmentBuffData = self.fragmentBuffData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let alchemyData = self.alchemyData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let alchemyFormulaData = self.alchemyFormulaData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let fragmentLevelData = self.fragmentLevelData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeFragmentModuleData::create(
            _fbb,
            &clz_Torappu_RoguelikeFragmentModuleDataArgs {
                fragmentData,
                fragmentTypeData,
                moduleConsts,
                fragmentBuffData,
                alchemyData,
                alchemyFormulaData,
                fragmentLevelData,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeDisasterDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeDisasterData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeDisasterData<'a> {
    type Inner = clz_Torappu_RoguelikeDisasterData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeDisasterData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_ICONID: flatbuffers::VOffsetT = 6;
    pub const VT_TOASTICONID: flatbuffers::VOffsetT = 8;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 10;
    pub const VT_NAME: flatbuffers::VOffsetT = 12;
    pub const VT_LEVELNAME: flatbuffers::VOffsetT = 14;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 16;
    pub const VT_FUNCTIONDESC: flatbuffers::VOffsetT = 18;
    pub const VT_DESC: flatbuffers::VOffsetT = 20;
    pub const VT_SOUND: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeDisasterData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeDisasterDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDisasterData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeDisasterDataBuilder::new(_fbb);
        if let Some(x) = args.sound {
            builder.add_sound(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.functionDesc {
            builder.add_functionDesc(x);
        }
        if let Some(x) = args.type_ {
            builder.add_type_(x);
        }
        if let Some(x) = args.levelName {
            builder.add_levelName(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_level(args.level);
        if let Some(x) = args.toastIconId {
            builder.add_toastIconId(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeDisasterDataT {
        let id = self.id().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        let toastIconId = self.toastIconId().map(|x| x.to_string());
        let level = self.level();
        let name = self.name().map(|x| x.to_string());
        let levelName = self.levelName().map(|x| x.to_string());
        let type_ = self.type_().map(|x| x.to_string());
        let functionDesc = self.functionDesc().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let sound = self.sound().map(|x| x.to_string());
        clz_Torappu_RoguelikeDisasterDataT {
            id,
            iconId,
            toastIconId,
            level,
            name,
            levelName,
            type_,
            functionDesc,
            desc,
            sound,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDisasterData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDisasterData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn toastIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDisasterData::VT_TOASTICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeDisasterData::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDisasterData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn levelName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDisasterData::VT_LEVELNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDisasterData::VT_TYPE_,
                None,
            )
        }
    }
    #[inline]
    pub fn functionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDisasterData::VT_FUNCTIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDisasterData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn sound(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeDisasterData::VT_SOUND,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeDisasterData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "toastIconId",
                Self::VT_TOASTICONID,
                false,
            )?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "levelName",
                Self::VT_LEVELNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "functionDesc",
                Self::VT_FUNCTIONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sound", Self::VT_SOUND, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeDisasterDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub toastIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub level: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub levelName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub functionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sound: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeDisasterDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeDisasterDataArgs {
            id: None,
            iconId: None,
            toastIconId: None,
            level: 0,
            name: None,
            levelName: None,
            type_: None,
            functionDesc: None,
            desc: None,
            sound: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeDisasterData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeDisasterData", 10)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.toastIconId() {
            s.serialize_field("toastIconId", &f)?;
        } else {
            s.skip_field("toastIconId")?;
        }
        s.serialize_field("level", &self.level())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.levelName() {
            s.serialize_field("levelName", &f)?;
        } else {
            s.skip_field("levelName")?;
        }
        if let Some(f) = self.type_() {
            s.serialize_field("type_", &f)?;
        } else {
            s.skip_field("type_")?;
        }
        if let Some(f) = self.functionDesc() {
            s.serialize_field("functionDesc", &f)?;
        } else {
            s.skip_field("functionDesc")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.sound() {
            s.serialize_field("sound", &f)?;
        } else {
            s.skip_field("sound")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeDisasterDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeDisasterDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDisasterData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDisasterData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_toastIconId(&mut self, toastIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDisasterData::VT_TOASTICONID,
            toastIconId,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeDisasterData::VT_LEVEL, level, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDisasterData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_levelName(&mut self, levelName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDisasterData::VT_LEVELNAME,
            levelName,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDisasterData::VT_TYPE_,
            type_,
        );
    }
    #[inline]
    pub fn add_functionDesc(&mut self, functionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDisasterData::VT_FUNCTIONDESC,
            functionDesc,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDisasterData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_sound(&mut self, sound: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDisasterData::VT_SOUND,
            sound,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeDisasterDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeDisasterDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDisasterData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeDisasterData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeDisasterData");
        ds.field("id", &self.id());
        ds.field("iconId", &self.iconId());
        ds.field("toastIconId", &self.toastIconId());
        ds.field("level", &self.level());
        ds.field("name", &self.name());
        ds.field("levelName", &self.levelName());
        ds.field("type_", &self.type_());
        ds.field("functionDesc", &self.functionDesc());
        ds.field("desc", &self.desc());
        ds.field("sound", &self.sound());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeDisasterDataT {
    pub id: Option<String>,
    pub iconId: Option<String>,
    pub toastIconId: Option<String>,
    pub level: i32,
    pub name: Option<String>,
    pub levelName: Option<String>,
    pub type_: Option<String>,
    pub functionDesc: Option<String>,
    pub desc: Option<String>,
    pub sound: Option<String>,
}
impl Default for clz_Torappu_RoguelikeDisasterDataT {
    fn default() -> Self {
        Self {
            id: None,
            iconId: None,
            toastIconId: None,
            level: 0,
            name: None,
            levelName: None,
            type_: None,
            functionDesc: None,
            desc: None,
            sound: None,
        }
    }
}
impl clz_Torappu_RoguelikeDisasterDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDisasterData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let toastIconId = self.toastIconId.as_ref().map(|x| _fbb.create_string(x));
        let level = self.level;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let levelName = self.levelName.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_.as_ref().map(|x| _fbb.create_string(x));
        let functionDesc = self.functionDesc.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let sound = self.sound.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeDisasterData::create(
            _fbb,
            &clz_Torappu_RoguelikeDisasterDataArgs {
                id,
                iconId,
                toastIconId,
                level,
                name,
                levelName,
                type_,
                functionDesc,
                desc,
                sound,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeDisasterDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeDisasterData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeDisasterData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeDisasterData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeDisasterData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeDisasterData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeDisasterDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeDisasterData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeDisasterDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeDisasterDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeDisasterDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeDisasterData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeDisasterData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeDisasterData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDisasterData>>(
                    dict__string__clz_Torappu_RoguelikeDisasterData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeDisasterData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDisasterData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeDisasterDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeDisasterData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeDisasterDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeDisasterDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeDisasterData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeDisasterData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeDisasterDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeDisasterDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeDisasterData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeDisasterData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeDisasterData>>(
                dict__string__clz_Torappu_RoguelikeDisasterData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeDisasterDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeDisasterDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeDisasterData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeDisasterData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeDisasterData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeDisasterData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeDisasterDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeDisasterDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeDisasterDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeDisasterDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeDisasterData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeDisasterData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeDisasterDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeDisasterModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeDisasterModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeDisasterModuleData<'a> {
    type Inner = clz_Torappu_RoguelikeDisasterModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeDisasterModuleData<'a> {
    pub const VT_DISASTERDATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeDisasterModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeDisasterModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDisasterModuleData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeDisasterModuleDataBuilder::new(_fbb);
        if let Some(x) = args.disasterData {
            builder.add_disasterData(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeDisasterModuleDataT {
        let disasterData = self
            .disasterData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeDisasterModuleDataT { disasterData }
    }

    #[inline]
    pub fn disasterData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDisasterData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDisasterData>,
                >,
            >>(
                clz_Torappu_RoguelikeDisasterModuleData::VT_DISASTERDATA,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeDisasterModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDisasterData>,
                >,
            >>("disasterData", Self::VT_DISASTERDATA, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeDisasterModuleDataArgs<'a> {
    pub disasterData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDisasterData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeDisasterModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeDisasterModuleDataArgs { disasterData: None }
    }
}

impl Serialize for clz_Torappu_RoguelikeDisasterModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeDisasterModuleData", 1)?;
        if let Some(f) = self.disasterData() {
            s.serialize_field("disasterData", &f)?;
        } else {
            s.skip_field("disasterData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeDisasterModuleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeDisasterModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_disasterData(
        &mut self,
        disasterData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeDisasterData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeDisasterModuleData::VT_DISASTERDATA,
            disasterData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeDisasterModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeDisasterModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDisasterModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeDisasterModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeDisasterModuleData");
        ds.field("disasterData", &self.disasterData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeDisasterModuleDataT {
    pub disasterData: Option<Vec<dict__string__clz_Torappu_RoguelikeDisasterDataT>>,
}
impl Default for clz_Torappu_RoguelikeDisasterModuleDataT {
    fn default() -> Self {
        Self { disasterData: None }
    }
}
impl clz_Torappu_RoguelikeDisasterModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeDisasterModuleData<'b>> {
        let disasterData = self.disasterData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeDisasterModuleData::create(
            _fbb,
            &clz_Torappu_RoguelikeDisasterModuleDataArgs { disasterData },
        )
    }
}
pub enum clz_Torappu_RoguelikePermNodeUpgradeItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikePermNodeUpgradeItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikePermNodeUpgradeItemData<'a> {
    type Inner = clz_Torappu_RoguelikePermNodeUpgradeItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikePermNodeUpgradeItemData<'a> {
    pub const VT_UPGRADEID: flatbuffers::VOffsetT = 4;
    pub const VT_NODETYPE: flatbuffers::VOffsetT = 6;
    pub const VT_NODELEVEL: flatbuffers::VOffsetT = 8;
    pub const VT_COSTITEMID: flatbuffers::VOffsetT = 10;
    pub const VT_COSTITEMCOUNT: flatbuffers::VOffsetT = 12;
    pub const VT_DESC: flatbuffers::VOffsetT = 14;
    pub const VT_NODENAME: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikePermNodeUpgradeItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikePermNodeUpgradeItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikePermNodeUpgradeItemData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikePermNodeUpgradeItemDataBuilder::new(_fbb);
        if let Some(x) = args.nodeName {
            builder.add_nodeName(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        builder.add_costItemCount(args.costItemCount);
        if let Some(x) = args.costItemId {
            builder.add_costItemId(x);
        }
        builder.add_nodeLevel(args.nodeLevel);
        builder.add_nodeType(args.nodeType);
        if let Some(x) = args.upgradeId {
            builder.add_upgradeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikePermNodeUpgradeItemDataT {
        let upgradeId = self.upgradeId().map(|x| x.to_string());
        let nodeType = self.nodeType();
        let nodeLevel = self.nodeLevel();
        let costItemId = self.costItemId().map(|x| x.to_string());
        let costItemCount = self.costItemCount();
        let desc = self.desc().map(|x| x.to_string());
        let nodeName = self.nodeName().map(|x| x.to_string());
        clz_Torappu_RoguelikePermNodeUpgradeItemDataT {
            upgradeId,
            nodeType,
            nodeLevel,
            costItemId,
            costItemCount,
            desc,
            nodeName,
        }
    }

    #[inline]
    pub fn upgradeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikePermNodeUpgradeItemData::VT_UPGRADEID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeType(&self) -> enum__Torappu_RoguelikeEventType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeEventType>(
                    clz_Torappu_RoguelikePermNodeUpgradeItemData::VT_NODETYPE,
                    Some(enum__Torappu_RoguelikeEventType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn nodeLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikePermNodeUpgradeItemData::VT_NODELEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn costItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikePermNodeUpgradeItemData::VT_COSTITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn costItemCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikePermNodeUpgradeItemData::VT_COSTITEMCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikePermNodeUpgradeItemData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikePermNodeUpgradeItemData::VT_NODENAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikePermNodeUpgradeItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "upgradeId",
                Self::VT_UPGRADEID,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeEventType>("nodeType", Self::VT_NODETYPE, false)?
            .visit_field::<i32>("nodeLevel", Self::VT_NODELEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "costItemId",
                Self::VT_COSTITEMID,
                false,
            )?
            .visit_field::<i32>("costItemCount", Self::VT_COSTITEMCOUNT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nodeName",
                Self::VT_NODENAME,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikePermNodeUpgradeItemDataArgs<'a> {
    pub upgradeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeType: enum__Torappu_RoguelikeEventType,
    pub nodeLevel: i32,
    pub costItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub costItemCount: i32,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeName: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikePermNodeUpgradeItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikePermNodeUpgradeItemDataArgs {
            upgradeId: None,
            nodeType: enum__Torappu_RoguelikeEventType::NONE,
            nodeLevel: 0,
            costItemId: None,
            costItemCount: 0,
            desc: None,
            nodeName: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikePermNodeUpgradeItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikePermNodeUpgradeItemData", 7)?;
        if let Some(f) = self.upgradeId() {
            s.serialize_field("upgradeId", &f)?;
        } else {
            s.skip_field("upgradeId")?;
        }
        s.serialize_field("nodeType", &self.nodeType())?;
        s.serialize_field("nodeLevel", &self.nodeLevel())?;
        if let Some(f) = self.costItemId() {
            s.serialize_field("costItemId", &f)?;
        } else {
            s.skip_field("costItemId")?;
        }
        s.serialize_field("costItemCount", &self.costItemCount())?;
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.nodeName() {
            s.serialize_field("nodeName", &f)?;
        } else {
            s.skip_field("nodeName")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikePermNodeUpgradeItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikePermNodeUpgradeItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_upgradeId(&mut self, upgradeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikePermNodeUpgradeItemData::VT_UPGRADEID,
            upgradeId,
        );
    }
    #[inline]
    pub fn add_nodeType(&mut self, nodeType: enum__Torappu_RoguelikeEventType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeEventType>(
            clz_Torappu_RoguelikePermNodeUpgradeItemData::VT_NODETYPE,
            nodeType,
            enum__Torappu_RoguelikeEventType::NONE,
        );
    }
    #[inline]
    pub fn add_nodeLevel(&mut self, nodeLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikePermNodeUpgradeItemData::VT_NODELEVEL,
            nodeLevel,
            0,
        );
    }
    #[inline]
    pub fn add_costItemId(&mut self, costItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikePermNodeUpgradeItemData::VT_COSTITEMID,
            costItemId,
        );
    }
    #[inline]
    pub fn add_costItemCount(&mut self, costItemCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikePermNodeUpgradeItemData::VT_COSTITEMCOUNT,
            costItemCount,
            0,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikePermNodeUpgradeItemData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_nodeName(&mut self, nodeName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikePermNodeUpgradeItemData::VT_NODENAME,
            nodeName,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikePermNodeUpgradeItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikePermNodeUpgradeItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikePermNodeUpgradeItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikePermNodeUpgradeItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikePermNodeUpgradeItemData");
        ds.field("upgradeId", &self.upgradeId());
        ds.field("nodeType", &self.nodeType());
        ds.field("nodeLevel", &self.nodeLevel());
        ds.field("costItemId", &self.costItemId());
        ds.field("costItemCount", &self.costItemCount());
        ds.field("desc", &self.desc());
        ds.field("nodeName", &self.nodeName());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikePermNodeUpgradeItemDataT {
    pub upgradeId: Option<String>,
    pub nodeType: enum__Torappu_RoguelikeEventType,
    pub nodeLevel: i32,
    pub costItemId: Option<String>,
    pub costItemCount: i32,
    pub desc: Option<String>,
    pub nodeName: Option<String>,
}
impl Default for clz_Torappu_RoguelikePermNodeUpgradeItemDataT {
    fn default() -> Self {
        Self {
            upgradeId: None,
            nodeType: enum__Torappu_RoguelikeEventType::NONE,
            nodeLevel: 0,
            costItemId: None,
            costItemCount: 0,
            desc: None,
            nodeName: None,
        }
    }
}
impl clz_Torappu_RoguelikePermNodeUpgradeItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikePermNodeUpgradeItemData<'b>> {
        let upgradeId = self.upgradeId.as_ref().map(|x| _fbb.create_string(x));
        let nodeType = self.nodeType;
        let nodeLevel = self.nodeLevel;
        let costItemId = self.costItemId.as_ref().map(|x| _fbb.create_string(x));
        let costItemCount = self.costItemCount;
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let nodeName = self.nodeName.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikePermNodeUpgradeItemData::create(
            _fbb,
            &clz_Torappu_RoguelikePermNodeUpgradeItemDataArgs {
                upgradeId,
                nodeType,
                nodeLevel,
                costItemId,
                costItemCount,
                desc,
                nodeName,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTempNodeUpgradeItemDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTempNodeUpgradeItemData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTempNodeUpgradeItemData<'a> {
    type Inner = clz_Torappu_RoguelikeTempNodeUpgradeItemData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTempNodeUpgradeItemData<'a> {
    pub const VT_UPGRADEID: flatbuffers::VOffsetT = 4;
    pub const VT_NODETYPE: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;
    pub const VT_COSTITEMID: flatbuffers::VOffsetT = 10;
    pub const VT_COSTITEMCOUNT: flatbuffers::VOffsetT = 12;
    pub const VT_DESC: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTempNodeUpgradeItemData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTempNodeUpgradeItemDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTempNodeUpgradeItemData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTempNodeUpgradeItemDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        builder.add_costItemCount(args.costItemCount);
        if let Some(x) = args.costItemId {
            builder.add_costItemId(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_nodeType(args.nodeType);
        if let Some(x) = args.upgradeId {
            builder.add_upgradeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTempNodeUpgradeItemDataT {
        let upgradeId = self.upgradeId().map(|x| x.to_string());
        let nodeType = self.nodeType();
        let sortId = self.sortId();
        let costItemId = self.costItemId().map(|x| x.to_string());
        let costItemCount = self.costItemCount();
        let desc = self.desc().map(|x| x.to_string());
        clz_Torappu_RoguelikeTempNodeUpgradeItemDataT {
            upgradeId,
            nodeType,
            sortId,
            costItemId,
            costItemCount,
            desc,
        }
    }

    #[inline]
    pub fn upgradeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTempNodeUpgradeItemData::VT_UPGRADEID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeType(&self) -> enum__Torappu_RoguelikeEventType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeEventType>(
                    clz_Torappu_RoguelikeTempNodeUpgradeItemData::VT_NODETYPE,
                    Some(enum__Torappu_RoguelikeEventType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTempNodeUpgradeItemData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn costItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTempNodeUpgradeItemData::VT_COSTITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn costItemCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTempNodeUpgradeItemData::VT_COSTITEMCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTempNodeUpgradeItemData::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTempNodeUpgradeItemData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "upgradeId",
                Self::VT_UPGRADEID,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeEventType>("nodeType", Self::VT_NODETYPE, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "costItemId",
                Self::VT_COSTITEMID,
                false,
            )?
            .visit_field::<i32>("costItemCount", Self::VT_COSTITEMCOUNT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTempNodeUpgradeItemDataArgs<'a> {
    pub upgradeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeType: enum__Torappu_RoguelikeEventType,
    pub sortId: i32,
    pub costItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub costItemCount: i32,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTempNodeUpgradeItemDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTempNodeUpgradeItemDataArgs {
            upgradeId: None,
            nodeType: enum__Torappu_RoguelikeEventType::NONE,
            sortId: 0,
            costItemId: None,
            costItemCount: 0,
            desc: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTempNodeUpgradeItemData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeTempNodeUpgradeItemData", 6)?;
        if let Some(f) = self.upgradeId() {
            s.serialize_field("upgradeId", &f)?;
        } else {
            s.skip_field("upgradeId")?;
        }
        s.serialize_field("nodeType", &self.nodeType())?;
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.costItemId() {
            s.serialize_field("costItemId", &f)?;
        } else {
            s.skip_field("costItemId")?;
        }
        s.serialize_field("costItemCount", &self.costItemCount())?;
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTempNodeUpgradeItemDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTempNodeUpgradeItemDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_upgradeId(&mut self, upgradeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTempNodeUpgradeItemData::VT_UPGRADEID,
            upgradeId,
        );
    }
    #[inline]
    pub fn add_nodeType(&mut self, nodeType: enum__Torappu_RoguelikeEventType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeEventType>(
            clz_Torappu_RoguelikeTempNodeUpgradeItemData::VT_NODETYPE,
            nodeType,
            enum__Torappu_RoguelikeEventType::NONE,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTempNodeUpgradeItemData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_costItemId(&mut self, costItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTempNodeUpgradeItemData::VT_COSTITEMID,
            costItemId,
        );
    }
    #[inline]
    pub fn add_costItemCount(&mut self, costItemCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTempNodeUpgradeItemData::VT_COSTITEMCOUNT,
            costItemCount,
            0,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTempNodeUpgradeItemData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTempNodeUpgradeItemDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTempNodeUpgradeItemDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTempNodeUpgradeItemData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTempNodeUpgradeItemData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTempNodeUpgradeItemData");
        ds.field("upgradeId", &self.upgradeId());
        ds.field("nodeType", &self.nodeType());
        ds.field("sortId", &self.sortId());
        ds.field("costItemId", &self.costItemId());
        ds.field("costItemCount", &self.costItemCount());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTempNodeUpgradeItemDataT {
    pub upgradeId: Option<String>,
    pub nodeType: enum__Torappu_RoguelikeEventType,
    pub sortId: i32,
    pub costItemId: Option<String>,
    pub costItemCount: i32,
    pub desc: Option<String>,
}
impl Default for clz_Torappu_RoguelikeTempNodeUpgradeItemDataT {
    fn default() -> Self {
        Self {
            upgradeId: None,
            nodeType: enum__Torappu_RoguelikeEventType::NONE,
            sortId: 0,
            costItemId: None,
            costItemCount: 0,
            desc: None,
        }
    }
}
impl clz_Torappu_RoguelikeTempNodeUpgradeItemDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTempNodeUpgradeItemData<'b>> {
        let upgradeId = self.upgradeId.as_ref().map(|x| _fbb.create_string(x));
        let nodeType = self.nodeType;
        let sortId = self.sortId;
        let costItemId = self.costItemId.as_ref().map(|x| _fbb.create_string(x));
        let costItemCount = self.costItemCount;
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeTempNodeUpgradeItemData::create(
            _fbb,
            &clz_Torappu_RoguelikeTempNodeUpgradeItemDataArgs {
                upgradeId,
                nodeType,
                sortId,
                costItemId,
                costItemCount,
                desc,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeNodeUpgradeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeNodeUpgradeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeNodeUpgradeData<'a> {
    type Inner = clz_Torappu_RoguelikeNodeUpgradeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeNodeUpgradeData<'a> {
    pub const VT_NODETYPE: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_PERMITEMLIST: flatbuffers::VOffsetT = 8;
    pub const VT_TEMPITEMLIST: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeNodeUpgradeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeNodeUpgradeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeNodeUpgradeData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeNodeUpgradeDataBuilder::new(_fbb);
        if let Some(x) = args.tempItemList {
            builder.add_tempItemList(x);
        }
        if let Some(x) = args.permItemList {
            builder.add_permItemList(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_nodeType(args.nodeType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeNodeUpgradeDataT {
        let nodeType = self.nodeType();
        let sortId = self.sortId();
        let permItemList = self
            .permItemList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let tempItemList = self
            .tempItemList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeNodeUpgradeDataT {
            nodeType,
            sortId,
            permItemList,
            tempItemList,
        }
    }

    #[inline]
    pub fn nodeType(&self) -> enum__Torappu_RoguelikeEventType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeEventType>(
                    clz_Torappu_RoguelikeNodeUpgradeData::VT_NODETYPE,
                    Some(enum__Torappu_RoguelikeEventType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeNodeUpgradeData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn permItemList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikePermNodeUpgradeItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikePermNodeUpgradeItemData>,
                >,
            >>(clz_Torappu_RoguelikeNodeUpgradeData::VT_PERMITEMLIST, None)
        }
    }
    #[inline]
    pub fn tempItemList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTempNodeUpgradeItemData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTempNodeUpgradeItemData>,
                >,
            >>(clz_Torappu_RoguelikeNodeUpgradeData::VT_TEMPITEMLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeNodeUpgradeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeEventType>("nodeType", Self::VT_NODETYPE, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikePermNodeUpgradeItemData>,
                >,
            >>("permItemList", Self::VT_PERMITEMLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTempNodeUpgradeItemData>,
                >,
            >>("tempItemList", Self::VT_TEMPITEMLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeNodeUpgradeDataArgs<'a> {
    pub nodeType: enum__Torappu_RoguelikeEventType,
    pub sortId: i32,
    pub permItemList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikePermNodeUpgradeItemData<'a>>,
            >,
        >,
    >,
    pub tempItemList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTempNodeUpgradeItemData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeNodeUpgradeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeNodeUpgradeDataArgs {
            nodeType: enum__Torappu_RoguelikeEventType::NONE,
            sortId: 0,
            permItemList: None,
            tempItemList: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeNodeUpgradeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeNodeUpgradeData", 4)?;
        s.serialize_field("nodeType", &self.nodeType())?;
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.permItemList() {
            s.serialize_field("permItemList", &f)?;
        } else {
            s.skip_field("permItemList")?;
        }
        if let Some(f) = self.tempItemList() {
            s.serialize_field("tempItemList", &f)?;
        } else {
            s.skip_field("tempItemList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeNodeUpgradeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeNodeUpgradeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeType(&mut self, nodeType: enum__Torappu_RoguelikeEventType) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeEventType>(
            clz_Torappu_RoguelikeNodeUpgradeData::VT_NODETYPE,
            nodeType,
            enum__Torappu_RoguelikeEventType::NONE,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeNodeUpgradeData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_permItemList(
        &mut self,
        permItemList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikePermNodeUpgradeItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeNodeUpgradeData::VT_PERMITEMLIST,
            permItemList,
        );
    }
    #[inline]
    pub fn add_tempItemList(
        &mut self,
        tempItemList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTempNodeUpgradeItemData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeNodeUpgradeData::VT_TEMPITEMLIST,
            tempItemList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeNodeUpgradeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeNodeUpgradeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeNodeUpgradeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeNodeUpgradeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeNodeUpgradeData");
        ds.field("nodeType", &self.nodeType());
        ds.field("sortId", &self.sortId());
        ds.field("permItemList", &self.permItemList());
        ds.field("tempItemList", &self.tempItemList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeNodeUpgradeDataT {
    pub nodeType: enum__Torappu_RoguelikeEventType,
    pub sortId: i32,
    pub permItemList: Option<Vec<clz_Torappu_RoguelikePermNodeUpgradeItemDataT>>,
    pub tempItemList: Option<Vec<clz_Torappu_RoguelikeTempNodeUpgradeItemDataT>>,
}
impl Default for clz_Torappu_RoguelikeNodeUpgradeDataT {
    fn default() -> Self {
        Self {
            nodeType: enum__Torappu_RoguelikeEventType::NONE,
            sortId: 0,
            permItemList: None,
            tempItemList: None,
        }
    }
}
impl clz_Torappu_RoguelikeNodeUpgradeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeNodeUpgradeData<'b>> {
        let nodeType = self.nodeType;
        let sortId = self.sortId;
        let permItemList = self.permItemList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let tempItemList = self.tempItemList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeNodeUpgradeData::create(
            _fbb,
            &clz_Torappu_RoguelikeNodeUpgradeDataArgs {
                nodeType,
                sortId,
                permItemList,
                tempItemList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeNodeUpgradeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeNodeUpgradeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeNodeUpgradeData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeNodeUpgradeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeNodeUpgradeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeNodeUpgradeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeNodeUpgradeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeNodeUpgradeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeNodeUpgradeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeNodeUpgradeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeNodeUpgradeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeNodeUpgradeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeNodeUpgradeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeNodeUpgradeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeNodeUpgradeData>>(
                    dict__string__clz_Torappu_RoguelikeNodeUpgradeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeNodeUpgradeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeNodeUpgradeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeNodeUpgradeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeNodeUpgradeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeNodeUpgradeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeNodeUpgradeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeNodeUpgradeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeNodeUpgradeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeNodeUpgradeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeNodeUpgradeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeNodeUpgradeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeNodeUpgradeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeNodeUpgradeData>>(
                dict__string__clz_Torappu_RoguelikeNodeUpgradeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeNodeUpgradeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeNodeUpgradeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeNodeUpgradeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeNodeUpgradeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeNodeUpgradeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeNodeUpgradeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeNodeUpgradeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeNodeUpgradeDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeNodeUpgradeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeNodeUpgradeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeNodeUpgradeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeNodeUpgradeData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeNodeUpgradeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeNodeUpgradeModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeNodeUpgradeModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeNodeUpgradeModuleData<'a> {
    type Inner = clz_Torappu_RoguelikeNodeUpgradeModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeNodeUpgradeModuleData<'a> {
    pub const VT_NODEUPGRADEDATAMAP: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeNodeUpgradeModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeNodeUpgradeModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeNodeUpgradeModuleData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeNodeUpgradeModuleDataBuilder::new(_fbb);
        if let Some(x) = args.nodeUpgradeDataMap {
            builder.add_nodeUpgradeDataMap(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeNodeUpgradeModuleDataT {
        let nodeUpgradeDataMap = self
            .nodeUpgradeDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeNodeUpgradeModuleDataT { nodeUpgradeDataMap }
    }

    #[inline]
    pub fn nodeUpgradeDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeNodeUpgradeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeNodeUpgradeData,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeNodeUpgradeModuleData::VT_NODEUPGRADEDATAMAP,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeNodeUpgradeModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeNodeUpgradeData,
                    >,
                >,
            >>("nodeUpgradeDataMap", Self::VT_NODEUPGRADEDATAMAP, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeNodeUpgradeModuleDataArgs<'a> {
    pub nodeUpgradeDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeNodeUpgradeData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeNodeUpgradeModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeNodeUpgradeModuleDataArgs {
            nodeUpgradeDataMap: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeNodeUpgradeModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeNodeUpgradeModuleData", 1)?;
        if let Some(f) = self.nodeUpgradeDataMap() {
            s.serialize_field("nodeUpgradeDataMap", &f)?;
        } else {
            s.skip_field("nodeUpgradeDataMap")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeNodeUpgradeModuleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeNodeUpgradeModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeUpgradeDataMap(
        &mut self,
        nodeUpgradeDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeNodeUpgradeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeNodeUpgradeModuleData::VT_NODEUPGRADEDATAMAP,
            nodeUpgradeDataMap,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeNodeUpgradeModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeNodeUpgradeModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeNodeUpgradeModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeNodeUpgradeModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeNodeUpgradeModuleData");
        ds.field("nodeUpgradeDataMap", &self.nodeUpgradeDataMap());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeNodeUpgradeModuleDataT {
    pub nodeUpgradeDataMap: Option<Vec<dict__string__clz_Torappu_RoguelikeNodeUpgradeDataT>>,
}
impl Default for clz_Torappu_RoguelikeNodeUpgradeModuleDataT {
    fn default() -> Self {
        Self {
            nodeUpgradeDataMap: None,
        }
    }
}
impl clz_Torappu_RoguelikeNodeUpgradeModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeNodeUpgradeModuleData<'b>> {
        let nodeUpgradeDataMap = self.nodeUpgradeDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeNodeUpgradeModuleData::create(
            _fbb,
            &clz_Torappu_RoguelikeNodeUpgradeModuleDataArgs { nodeUpgradeDataMap },
        )
    }
}
pub enum clz_Torappu_RoguelikeCopperDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeCopperData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeCopperData<'a> {
    type Inner = clz_Torappu_RoguelikeCopperData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeCopperData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_GROUPID: flatbuffers::VOffsetT = 6;
    pub const VT_GILDTYPEID: flatbuffers::VOffsetT = 8;
    pub const VT_LUCKYLEVEL: flatbuffers::VOffsetT = 10;
    pub const VT_BUFFTYPE: flatbuffers::VOffsetT = 12;
    pub const VT_LAYERCNTDESC: flatbuffers::VOffsetT = 14;
    pub const VT_POEMLIST: flatbuffers::VOffsetT = 16;
    pub const VT_ALWAYSSHOWCOUNTDOWN: flatbuffers::VOffsetT = 18;
    pub const VT_BUFFITEMIDLIST: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeCopperData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeCopperDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeCopperDataBuilder::new(_fbb);
        if let Some(x) = args.buffItemIdList {
            builder.add_buffItemIdList(x);
        }
        if let Some(x) = args.poemList {
            builder.add_poemList(x);
        }
        if let Some(x) = args.layerCntDesc {
            builder.add_layerCntDesc(x);
        }
        builder.add_buffType(args.buffType);
        builder.add_luckyLevel(args.luckyLevel);
        if let Some(x) = args.gildTypeId {
            builder.add_gildTypeId(x);
        }
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_alwaysShowCountDown(args.alwaysShowCountDown);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeCopperDataT {
        let id = self.id().map(|x| x.to_string());
        let groupId = self.groupId().map(|x| x.to_string());
        let gildTypeId = self.gildTypeId().map(|x| x.to_string());
        let luckyLevel = self.luckyLevel();
        let buffType = self.buffType();
        let layerCntDesc = self.layerCntDesc().map(|x| x.to_string());
        let poemList = self
            .poemList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let alwaysShowCountDown = self.alwaysShowCountDown();
        let buffItemIdList = self
            .buffItemIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_RoguelikeCopperDataT {
            id,
            groupId,
            gildTypeId,
            luckyLevel,
            buffType,
            layerCntDesc,
            poemList,
            alwaysShowCountDown,
            buffItemIdList,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCopperData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCopperData::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn gildTypeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCopperData::VT_GILDTYPEID,
                None,
            )
        }
    }
    #[inline]
    pub fn luckyLevel(&self) -> enum__Torappu_RoguelikeCopperLuckyLevel {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeCopperLuckyLevel>(
                    clz_Torappu_RoguelikeCopperData::VT_LUCKYLEVEL,
                    Some(enum__Torappu_RoguelikeCopperLuckyLevel::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buffType(&self) -> enum__Torappu_RoguelikeCopperBuffType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeCopperBuffType>(
                    clz_Torappu_RoguelikeCopperData::VT_BUFFTYPE,
                    Some(enum__Torappu_RoguelikeCopperBuffType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn layerCntDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCopperData::VT_LAYERCNTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn poemList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RoguelikeCopperData::VT_POEMLIST, None)
        }
    }
    #[inline]
    pub fn alwaysShowCountDown(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeCopperData::VT_ALWAYSSHOWCOUNTDOWN,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buffItemIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RoguelikeCopperData::VT_BUFFITEMIDLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeCopperData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "gildTypeId",
                Self::VT_GILDTYPEID,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeCopperLuckyLevel>(
                "luckyLevel",
                Self::VT_LUCKYLEVEL,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeCopperBuffType>(
                "buffType",
                Self::VT_BUFFTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "layerCntDesc",
                Self::VT_LAYERCNTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("poemList", Self::VT_POEMLIST, false)?
            .visit_field::<bool>("alwaysShowCountDown", Self::VT_ALWAYSSHOWCOUNTDOWN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("buffItemIdList", Self::VT_BUFFITEMIDLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeCopperDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gildTypeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub luckyLevel: enum__Torappu_RoguelikeCopperLuckyLevel,
    pub buffType: enum__Torappu_RoguelikeCopperBuffType,
    pub layerCntDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub poemList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub alwaysShowCountDown: bool,
    pub buffItemIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeCopperDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeCopperDataArgs {
            id: None,
            groupId: None,
            gildTypeId: None,
            luckyLevel: enum__Torappu_RoguelikeCopperLuckyLevel::NONE,
            buffType: enum__Torappu_RoguelikeCopperBuffType::NONE,
            layerCntDesc: None,
            poemList: None,
            alwaysShowCountDown: false,
            buffItemIdList: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeCopperData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeCopperData", 9)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.groupId() {
            s.serialize_field("groupId", &f)?;
        } else {
            s.skip_field("groupId")?;
        }
        if let Some(f) = self.gildTypeId() {
            s.serialize_field("gildTypeId", &f)?;
        } else {
            s.skip_field("gildTypeId")?;
        }
        s.serialize_field("luckyLevel", &self.luckyLevel())?;
        s.serialize_field("buffType", &self.buffType())?;
        if let Some(f) = self.layerCntDesc() {
            s.serialize_field("layerCntDesc", &f)?;
        } else {
            s.skip_field("layerCntDesc")?;
        }
        if let Some(f) = self.poemList() {
            s.serialize_field("poemList", &f)?;
        } else {
            s.skip_field("poemList")?;
        }
        s.serialize_field("alwaysShowCountDown", &self.alwaysShowCountDown())?;
        if let Some(f) = self.buffItemIdList() {
            s.serialize_field("buffItemIdList", &f)?;
        } else {
            s.skip_field("buffItemIdList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeCopperDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RoguelikeCopperDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCopperData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCopperData::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_gildTypeId(&mut self, gildTypeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCopperData::VT_GILDTYPEID,
            gildTypeId,
        );
    }
    #[inline]
    pub fn add_luckyLevel(&mut self, luckyLevel: enum__Torappu_RoguelikeCopperLuckyLevel) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeCopperLuckyLevel>(
                clz_Torappu_RoguelikeCopperData::VT_LUCKYLEVEL,
                luckyLevel,
                enum__Torappu_RoguelikeCopperLuckyLevel::NONE,
            );
    }
    #[inline]
    pub fn add_buffType(&mut self, buffType: enum__Torappu_RoguelikeCopperBuffType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeCopperBuffType>(
                clz_Torappu_RoguelikeCopperData::VT_BUFFTYPE,
                buffType,
                enum__Torappu_RoguelikeCopperBuffType::NONE,
            );
    }
    #[inline]
    pub fn add_layerCntDesc(&mut self, layerCntDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCopperData::VT_LAYERCNTDESC,
            layerCntDesc,
        );
    }
    #[inline]
    pub fn add_poemList(
        &mut self,
        poemList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCopperData::VT_POEMLIST,
            poemList,
        );
    }
    #[inline]
    pub fn add_alwaysShowCountDown(&mut self, alwaysShowCountDown: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeCopperData::VT_ALWAYSSHOWCOUNTDOWN,
            alwaysShowCountDown,
            false,
        );
    }
    #[inline]
    pub fn add_buffItemIdList(
        &mut self,
        buffItemIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCopperData::VT_BUFFITEMIDLIST,
            buffItemIdList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeCopperDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeCopperDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeCopperData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeCopperData");
        ds.field("id", &self.id());
        ds.field("groupId", &self.groupId());
        ds.field("gildTypeId", &self.gildTypeId());
        ds.field("luckyLevel", &self.luckyLevel());
        ds.field("buffType", &self.buffType());
        ds.field("layerCntDesc", &self.layerCntDesc());
        ds.field("poemList", &self.poemList());
        ds.field("alwaysShowCountDown", &self.alwaysShowCountDown());
        ds.field("buffItemIdList", &self.buffItemIdList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeCopperDataT {
    pub id: Option<String>,
    pub groupId: Option<String>,
    pub gildTypeId: Option<String>,
    pub luckyLevel: enum__Torappu_RoguelikeCopperLuckyLevel,
    pub buffType: enum__Torappu_RoguelikeCopperBuffType,
    pub layerCntDesc: Option<String>,
    pub poemList: Option<Vec<String>>,
    pub alwaysShowCountDown: bool,
    pub buffItemIdList: Option<Vec<String>>,
}
impl Default for clz_Torappu_RoguelikeCopperDataT {
    fn default() -> Self {
        Self {
            id: None,
            groupId: None,
            gildTypeId: None,
            luckyLevel: enum__Torappu_RoguelikeCopperLuckyLevel::NONE,
            buffType: enum__Torappu_RoguelikeCopperBuffType::NONE,
            layerCntDesc: None,
            poemList: None,
            alwaysShowCountDown: false,
            buffItemIdList: None,
        }
    }
}
impl clz_Torappu_RoguelikeCopperDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let groupId = self.groupId.as_ref().map(|x| _fbb.create_string(x));
        let gildTypeId = self.gildTypeId.as_ref().map(|x| _fbb.create_string(x));
        let luckyLevel = self.luckyLevel;
        let buffType = self.buffType;
        let layerCntDesc = self.layerCntDesc.as_ref().map(|x| _fbb.create_string(x));
        let poemList = self.poemList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let alwaysShowCountDown = self.alwaysShowCountDown;
        let buffItemIdList = self.buffItemIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeCopperData::create(
            _fbb,
            &clz_Torappu_RoguelikeCopperDataArgs {
                id,
                groupId,
                gildTypeId,
                luckyLevel,
                buffType,
                layerCntDesc,
                poemList,
                alwaysShowCountDown,
                buffItemIdList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeCopperDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeCopperData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeCopperData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeCopperData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeCopperData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeCopperData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeCopperDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeCopperData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeCopperDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeCopperDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeCopperDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeCopperData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_RoguelikeCopperData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeCopperData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCopperData>>(
                    dict__string__clz_Torappu_RoguelikeCopperData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeCopperData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCopperData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeCopperDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeCopperDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeCopperDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeCopperData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeCopperData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeCopperDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeCopperDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeCopperData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperData>>(
                dict__string__clz_Torappu_RoguelikeCopperData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeCopperDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeCopperDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeCopperData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeCopperData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeCopperData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeCopperData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeCopperDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeCopperDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeCopperDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeCopperDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeCopperData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeCopperData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeCopperDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeCopperDivineDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeCopperDivineData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeCopperDivineData<'a> {
    type Inner = clz_Torappu_RoguelikeCopperDivineData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeCopperDivineData<'a> {
    pub const VT_EVENTID: flatbuffers::VOffsetT = 4;
    pub const VT_GROUPID: flatbuffers::VOffsetT = 6;
    pub const VT_SHOWDESC: flatbuffers::VOffsetT = 8;
    pub const VT_DIVINETYPE: flatbuffers::VOffsetT = 10;
    pub const VT_RESULTTYPE: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeCopperDivineData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeCopperDivineDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperDivineData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeCopperDivineDataBuilder::new(_fbb);
        builder.add_resultType(args.resultType);
        builder.add_divineType(args.divineType);
        if let Some(x) = args.showDesc {
            builder.add_showDesc(x);
        }
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        if let Some(x) = args.eventId {
            builder.add_eventId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeCopperDivineDataT {
        let eventId = self.eventId().map(|x| x.to_string());
        let groupId = self.groupId().map(|x| x.to_string());
        let showDesc = self.showDesc().map(|x| x.to_string());
        let divineType = self.divineType();
        let resultType = self.resultType();
        clz_Torappu_RoguelikeCopperDivineDataT {
            eventId,
            groupId,
            showDesc,
            divineType,
            resultType,
        }
    }

    #[inline]
    pub fn eventId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCopperDivineData::VT_EVENTID,
                None,
            )
        }
    }
    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCopperDivineData::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn showDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCopperDivineData::VT_SHOWDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn divineType(&self) -> enum__Torappu_RoguelikeCopperDivineType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeCopperDivineType>(
                    clz_Torappu_RoguelikeCopperDivineData::VT_DIVINETYPE,
                    Some(enum__Torappu_RoguelikeCopperDivineType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn resultType(&self) -> enum__Torappu_RoguelikeCopperDivineResultType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeCopperDivineResultType>(
                    clz_Torappu_RoguelikeCopperDivineData::VT_RESULTTYPE,
                    Some(enum__Torappu_RoguelikeCopperDivineResultType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeCopperDivineData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eventId", Self::VT_EVENTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "showDesc",
                Self::VT_SHOWDESC,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeCopperDivineType>(
                "divineType",
                Self::VT_DIVINETYPE,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeCopperDivineResultType>(
                "resultType",
                Self::VT_RESULTTYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeCopperDivineDataArgs<'a> {
    pub eventId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub showDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub divineType: enum__Torappu_RoguelikeCopperDivineType,
    pub resultType: enum__Torappu_RoguelikeCopperDivineResultType,
}
impl<'a> Default for clz_Torappu_RoguelikeCopperDivineDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeCopperDivineDataArgs {
            eventId: None,
            groupId: None,
            showDesc: None,
            divineType: enum__Torappu_RoguelikeCopperDivineType::NONE,
            resultType: enum__Torappu_RoguelikeCopperDivineResultType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeCopperDivineData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeCopperDivineData", 5)?;
        if let Some(f) = self.eventId() {
            s.serialize_field("eventId", &f)?;
        } else {
            s.skip_field("eventId")?;
        }
        if let Some(f) = self.groupId() {
            s.serialize_field("groupId", &f)?;
        } else {
            s.skip_field("groupId")?;
        }
        if let Some(f) = self.showDesc() {
            s.serialize_field("showDesc", &f)?;
        } else {
            s.skip_field("showDesc")?;
        }
        s.serialize_field("divineType", &self.divineType())?;
        s.serialize_field("resultType", &self.resultType())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeCopperDivineDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeCopperDivineDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_eventId(&mut self, eventId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCopperDivineData::VT_EVENTID,
            eventId,
        );
    }
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCopperDivineData::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_showDesc(&mut self, showDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCopperDivineData::VT_SHOWDESC,
            showDesc,
        );
    }
    #[inline]
    pub fn add_divineType(&mut self, divineType: enum__Torappu_RoguelikeCopperDivineType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeCopperDivineType>(
                clz_Torappu_RoguelikeCopperDivineData::VT_DIVINETYPE,
                divineType,
                enum__Torappu_RoguelikeCopperDivineType::NONE,
            );
    }
    #[inline]
    pub fn add_resultType(&mut self, resultType: enum__Torappu_RoguelikeCopperDivineResultType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeCopperDivineResultType>(
                clz_Torappu_RoguelikeCopperDivineData::VT_RESULTTYPE,
                resultType,
                enum__Torappu_RoguelikeCopperDivineResultType::NONE,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeCopperDivineDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeCopperDivineDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperDivineData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeCopperDivineData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeCopperDivineData");
        ds.field("eventId", &self.eventId());
        ds.field("groupId", &self.groupId());
        ds.field("showDesc", &self.showDesc());
        ds.field("divineType", &self.divineType());
        ds.field("resultType", &self.resultType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeCopperDivineDataT {
    pub eventId: Option<String>,
    pub groupId: Option<String>,
    pub showDesc: Option<String>,
    pub divineType: enum__Torappu_RoguelikeCopperDivineType,
    pub resultType: enum__Torappu_RoguelikeCopperDivineResultType,
}
impl Default for clz_Torappu_RoguelikeCopperDivineDataT {
    fn default() -> Self {
        Self {
            eventId: None,
            groupId: None,
            showDesc: None,
            divineType: enum__Torappu_RoguelikeCopperDivineType::NONE,
            resultType: enum__Torappu_RoguelikeCopperDivineResultType::NONE,
        }
    }
}
impl clz_Torappu_RoguelikeCopperDivineDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperDivineData<'b>> {
        let eventId = self.eventId.as_ref().map(|x| _fbb.create_string(x));
        let groupId = self.groupId.as_ref().map(|x| _fbb.create_string(x));
        let showDesc = self.showDesc.as_ref().map(|x| _fbb.create_string(x));
        let divineType = self.divineType;
        let resultType = self.resultType;
        clz_Torappu_RoguelikeCopperDivineData::create(
            _fbb,
            &clz_Torappu_RoguelikeCopperDivineDataArgs {
                eventId,
                groupId,
                showDesc,
                divineType,
                resultType,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeCopperDivineDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeCopperDivineData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeCopperDivineData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeCopperDivineData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeCopperDivineData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeCopperDivineData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeCopperDivineDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeCopperDivineData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeCopperDivineDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeCopperDivineDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeCopperDivineDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeCopperDivineData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeCopperDivineData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeCopperDivineData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCopperDivineData>>(
                    dict__string__clz_Torappu_RoguelikeCopperDivineData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeCopperDivineData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCopperDivineData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeCopperDivineDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperDivineData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeCopperDivineDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeCopperDivineDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeCopperDivineData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeCopperDivineData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeCopperDivineDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeCopperDivineDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeCopperDivineData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperDivineData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperDivineData>>(
                dict__string__clz_Torappu_RoguelikeCopperDivineData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeCopperDivineDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeCopperDivineDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeCopperDivineData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeCopperDivineData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeCopperDivineData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeCopperDivineData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeCopperDivineDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeCopperDivineDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeCopperDivineDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeCopperDivineDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeCopperDivineData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeCopperDivineData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeCopperDivineDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeCopperModuleConstsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeCopperModuleConsts<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeCopperModuleConsts<'a> {
    type Inner = clz_Torappu_RoguelikeCopperModuleConsts<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeCopperModuleConsts<'a> {
    pub const VT_COPPERDRAWMAXNUM: flatbuffers::VOffsetT = 4;
    pub const VT_COPPERDRAWMINNUM: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeCopperModuleConsts { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeCopperModuleConstsArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperModuleConsts<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeCopperModuleConstsBuilder::new(_fbb);
        builder.add_copperDrawMinNum(args.copperDrawMinNum);
        builder.add_copperDrawMaxNum(args.copperDrawMaxNum);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeCopperModuleConstsT {
        let copperDrawMaxNum = self.copperDrawMaxNum();
        let copperDrawMinNum = self.copperDrawMinNum();
        clz_Torappu_RoguelikeCopperModuleConstsT {
            copperDrawMaxNum,
            copperDrawMinNum,
        }
    }

    #[inline]
    pub fn copperDrawMaxNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeCopperModuleConsts::VT_COPPERDRAWMAXNUM,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn copperDrawMinNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeCopperModuleConsts::VT_COPPERDRAWMINNUM,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeCopperModuleConsts<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("copperDrawMaxNum", Self::VT_COPPERDRAWMAXNUM, false)?
            .visit_field::<i32>("copperDrawMinNum", Self::VT_COPPERDRAWMINNUM, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeCopperModuleConstsArgs {
    pub copperDrawMaxNum: i32,
    pub copperDrawMinNum: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeCopperModuleConstsArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeCopperModuleConstsArgs {
            copperDrawMaxNum: 0,
            copperDrawMinNum: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeCopperModuleConsts<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeCopperModuleConsts", 2)?;
        s.serialize_field("copperDrawMaxNum", &self.copperDrawMaxNum())?;
        s.serialize_field("copperDrawMinNum", &self.copperDrawMinNum())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeCopperModuleConstsBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeCopperModuleConstsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_copperDrawMaxNum(&mut self, copperDrawMaxNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeCopperModuleConsts::VT_COPPERDRAWMAXNUM,
            copperDrawMaxNum,
            0,
        );
    }
    #[inline]
    pub fn add_copperDrawMinNum(&mut self, copperDrawMinNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeCopperModuleConsts::VT_COPPERDRAWMINNUM,
            copperDrawMinNum,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeCopperModuleConstsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeCopperModuleConstsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperModuleConsts<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeCopperModuleConsts<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeCopperModuleConsts");
        ds.field("copperDrawMaxNum", &self.copperDrawMaxNum());
        ds.field("copperDrawMinNum", &self.copperDrawMinNum());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeCopperModuleConstsT {
    pub copperDrawMaxNum: i32,
    pub copperDrawMinNum: i32,
}
impl Default for clz_Torappu_RoguelikeCopperModuleConstsT {
    fn default() -> Self {
        Self {
            copperDrawMaxNum: 0,
            copperDrawMinNum: 0,
        }
    }
}
impl clz_Torappu_RoguelikeCopperModuleConstsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperModuleConsts<'b>> {
        let copperDrawMaxNum = self.copperDrawMaxNum;
        let copperDrawMinNum = self.copperDrawMinNum;
        clz_Torappu_RoguelikeCopperModuleConsts::create(
            _fbb,
            &clz_Torappu_RoguelikeCopperModuleConstsArgs {
                copperDrawMaxNum,
                copperDrawMinNum,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeCopperModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeCopperModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeCopperModuleData<'a> {
    type Inner = clz_Torappu_RoguelikeCopperModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeCopperModuleData<'a> {
    pub const VT_COPPERDATA: flatbuffers::VOffsetT = 4;
    pub const VT_COPPERDIVINEDATA: flatbuffers::VOffsetT = 6;
    pub const VT_CHANGECOPPERMAP: flatbuffers::VOffsetT = 8;
    pub const VT_MODULECONSTS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeCopperModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeCopperModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperModuleData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeCopperModuleDataBuilder::new(_fbb);
        if let Some(x) = args.moduleConsts {
            builder.add_moduleConsts(x);
        }
        if let Some(x) = args.changeCopperMap {
            builder.add_changeCopperMap(x);
        }
        if let Some(x) = args.copperDivineData {
            builder.add_copperDivineData(x);
        }
        if let Some(x) = args.copperData {
            builder.add_copperData(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeCopperModuleDataT {
        let copperData = self
            .copperData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let copperDivineData = self
            .copperDivineData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let changeCopperMap = self
            .changeCopperMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let moduleConsts = self.moduleConsts().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeCopperModuleDataT {
            copperData,
            copperDivineData,
            changeCopperMap,
            moduleConsts,
        }
    }

    #[inline]
    pub fn copperData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeCopperData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeCopperData>,
                >,
            >>(clz_Torappu_RoguelikeCopperModuleData::VT_COPPERDATA, None)
        }
    }
    #[inline]
    pub fn copperDivineData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeCopperDivineData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeCopperDivineData,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeCopperModuleData::VT_COPPERDIVINEDATA,
                None,
            )
        }
    }
    #[inline]
    pub fn changeCopperMap(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(
                clz_Torappu_RoguelikeCopperModuleData::VT_CHANGECOPPERMAP,
                None,
            )
        }
    }
    #[inline]
    pub fn moduleConsts(&self) -> Option<clz_Torappu_RoguelikeCopperModuleConsts<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCopperModuleConsts>>(
                    clz_Torappu_RoguelikeCopperModuleData::VT_MODULECONSTS,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeCopperModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeCopperData>,
                >,
            >>("copperData", Self::VT_COPPERDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeCopperDivineData,
                    >,
                >,
            >>("copperDivineData", Self::VT_COPPERDIVINEDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>("changeCopperMap", Self::VT_CHANGECOPPERMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCopperModuleConsts>>(
                "moduleConsts",
                Self::VT_MODULECONSTS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeCopperModuleDataArgs<'a> {
    pub copperData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeCopperData<'a>>,
            >,
        >,
    >,
    pub copperDivineData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeCopperDivineData<'a>,
                >,
            >,
        >,
    >,
    pub changeCopperMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
    pub moduleConsts: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperModuleConsts<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeCopperModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeCopperModuleDataArgs {
            copperData: None,
            copperDivineData: None,
            changeCopperMap: None,
            moduleConsts: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeCopperModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeCopperModuleData", 4)?;
        if let Some(f) = self.copperData() {
            s.serialize_field("copperData", &f)?;
        } else {
            s.skip_field("copperData")?;
        }
        if let Some(f) = self.copperDivineData() {
            s.serialize_field("copperDivineData", &f)?;
        } else {
            s.skip_field("copperDivineData")?;
        }
        if let Some(f) = self.changeCopperMap() {
            s.serialize_field("changeCopperMap", &f)?;
        } else {
            s.skip_field("changeCopperMap")?;
        }
        if let Some(f) = self.moduleConsts() {
            s.serialize_field("moduleConsts", &f)?;
        } else {
            s.skip_field("moduleConsts")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeCopperModuleDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeCopperModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_copperData(
        &mut self,
        copperData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeCopperData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCopperModuleData::VT_COPPERDATA,
            copperData,
        );
    }
    #[inline]
    pub fn add_copperDivineData(
        &mut self,
        copperDivineData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeCopperDivineData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCopperModuleData::VT_COPPERDIVINEDATA,
            copperDivineData,
        );
    }
    #[inline]
    pub fn add_changeCopperMap(
        &mut self,
        changeCopperMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCopperModuleData::VT_CHANGECOPPERMAP,
            changeCopperMap,
        );
    }
    #[inline]
    pub fn add_moduleConsts(
        &mut self,
        moduleConsts: flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperModuleConsts<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperModuleConsts>>(
                clz_Torappu_RoguelikeCopperModuleData::VT_MODULECONSTS,
                moduleConsts,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeCopperModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeCopperModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeCopperModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeCopperModuleData");
        ds.field("copperData", &self.copperData());
        ds.field("copperDivineData", &self.copperDivineData());
        ds.field("changeCopperMap", &self.changeCopperMap());
        ds.field("moduleConsts", &self.moduleConsts());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeCopperModuleDataT {
    pub copperData: Option<Vec<dict__string__clz_Torappu_RoguelikeCopperDataT>>,
    pub copperDivineData: Option<Vec<dict__string__clz_Torappu_RoguelikeCopperDivineDataT>>,
    pub changeCopperMap: Option<Vec<dict__string__stringT>>,
    pub moduleConsts: Option<Box<clz_Torappu_RoguelikeCopperModuleConstsT>>,
}
impl Default for clz_Torappu_RoguelikeCopperModuleDataT {
    fn default() -> Self {
        Self {
            copperData: None,
            copperDivineData: None,
            changeCopperMap: None,
            moduleConsts: None,
        }
    }
}
impl clz_Torappu_RoguelikeCopperModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperModuleData<'b>> {
        let copperData = self.copperData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let copperDivineData = self.copperDivineData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let changeCopperMap = self.changeCopperMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let moduleConsts = self.moduleConsts.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeCopperModuleData::create(
            _fbb,
            &clz_Torappu_RoguelikeCopperModuleDataArgs {
                copperData,
                copperDivineData,
                changeCopperMap,
                moduleConsts,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeWrathDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeWrathData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeWrathData<'a> {
    type Inner = clz_Torappu_RoguelikeWrathData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeWrathData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_GROUP: flatbuffers::VOffsetT = 6;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_LEVELNAME: flatbuffers::VOffsetT = 12;
    pub const VT_FUNCTIONDESC: flatbuffers::VOffsetT = 14;
    pub const VT_DESC: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeWrathData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeWrathDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeWrathDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.functionDesc {
            builder.add_functionDesc(x);
        }
        if let Some(x) = args.levelName {
            builder.add_levelName(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_level(args.level);
        if let Some(x) = args.group {
            builder.add_group(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeWrathDataT {
        let id = self.id().map(|x| x.to_string());
        let group = self.group().map(|x| x.to_string());
        let level = self.level();
        let name = self.name().map(|x| x.to_string());
        let levelName = self.levelName().map(|x| x.to_string());
        let functionDesc = self.functionDesc().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        clz_Torappu_RoguelikeWrathDataT {
            id,
            group,
            level,
            name,
            levelName,
            functionDesc,
            desc,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeWrathData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn group(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeWrathData::VT_GROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeWrathData::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeWrathData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn levelName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeWrathData::VT_LEVELNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn functionDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeWrathData::VT_FUNCTIONDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeWrathData::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeWrathData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("group", Self::VT_GROUP, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "levelName",
                Self::VT_LEVELNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "functionDesc",
                Self::VT_FUNCTIONDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeWrathDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub group: Option<flatbuffers::WIPOffset<&'a str>>,
    pub level: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub levelName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub functionDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeWrathDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeWrathDataArgs {
            id: None,
            group: None,
            level: 0,
            name: None,
            levelName: None,
            functionDesc: None,
            desc: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeWrathData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeWrathData", 7)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.group() {
            s.serialize_field("group", &f)?;
        } else {
            s.skip_field("group")?;
        }
        s.serialize_field("level", &self.level())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.levelName() {
            s.serialize_field("levelName", &f)?;
        } else {
            s.skip_field("levelName")?;
        }
        if let Some(f) = self.functionDesc() {
            s.serialize_field("functionDesc", &f)?;
        } else {
            s.skip_field("functionDesc")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeWrathDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RoguelikeWrathDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeWrathData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_group(&mut self, group: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeWrathData::VT_GROUP,
            group,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeWrathData::VT_LEVEL, level, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeWrathData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_levelName(&mut self, levelName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeWrathData::VT_LEVELNAME,
            levelName,
        );
    }
    #[inline]
    pub fn add_functionDesc(&mut self, functionDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeWrathData::VT_FUNCTIONDESC,
            functionDesc,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeWrathData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeWrathDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeWrathDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeWrathData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeWrathData");
        ds.field("id", &self.id());
        ds.field("group", &self.group());
        ds.field("level", &self.level());
        ds.field("name", &self.name());
        ds.field("levelName", &self.levelName());
        ds.field("functionDesc", &self.functionDesc());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeWrathDataT {
    pub id: Option<String>,
    pub group: Option<String>,
    pub level: i32,
    pub name: Option<String>,
    pub levelName: Option<String>,
    pub functionDesc: Option<String>,
    pub desc: Option<String>,
}
impl Default for clz_Torappu_RoguelikeWrathDataT {
    fn default() -> Self {
        Self {
            id: None,
            group: None,
            level: 0,
            name: None,
            levelName: None,
            functionDesc: None,
            desc: None,
        }
    }
}
impl clz_Torappu_RoguelikeWrathDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let group = self.group.as_ref().map(|x| _fbb.create_string(x));
        let level = self.level;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let levelName = self.levelName.as_ref().map(|x| _fbb.create_string(x));
        let functionDesc = self.functionDesc.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeWrathData::create(
            _fbb,
            &clz_Torappu_RoguelikeWrathDataArgs {
                id,
                group,
                level,
                name,
                levelName,
                functionDesc,
                desc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeWrathDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeWrathData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeWrathData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeWrathData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeWrathData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeWrathData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeWrathDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeWrathData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeWrathDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeWrathDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeWrathDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeWrathData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_RoguelikeWrathData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeWrathData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeWrathData>>(
                    dict__string__clz_Torappu_RoguelikeWrathData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeWrathData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeWrathData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeWrathDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeWrathDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeWrathDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeWrathData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeWrathData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeWrathDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeWrathDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeWrathData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathData>>(
                dict__string__clz_Torappu_RoguelikeWrathData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeWrathDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeWrathDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeWrathData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeWrathData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeWrathData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeWrathData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeWrathDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeWrathDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeWrathDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeWrathDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeWrathData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeWrathData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeWrathDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeWrathModuleConstsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeWrathModuleConsts<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeWrathModuleConsts<'a> {
    type Inner = clz_Torappu_RoguelikeWrathModuleConsts<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeWrathModuleConsts<'a> {
    pub const VT_GETWRATHTRANSITION: flatbuffers::VOffsetT = 4;
    pub const VT_GETWRATHTOAST: flatbuffers::VOffsetT = 6;
    pub const VT_HIDDENWRATHTYPE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeWrathModuleConsts { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeWrathModuleConstsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathModuleConsts<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeWrathModuleConstsBuilder::new(_fbb);
        if let Some(x) = args.hiddenWrathType {
            builder.add_hiddenWrathType(x);
        }
        if let Some(x) = args.getWrathToast {
            builder.add_getWrathToast(x);
        }
        if let Some(x) = args.getWrathTransition {
            builder.add_getWrathTransition(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeWrathModuleConstsT {
        let getWrathTransition = self.getWrathTransition().map(|x| x.to_string());
        let getWrathToast = self.getWrathToast().map(|x| x.to_string());
        let hiddenWrathType = self.hiddenWrathType().map(|x| x.to_string());
        clz_Torappu_RoguelikeWrathModuleConstsT {
            getWrathTransition,
            getWrathToast,
            hiddenWrathType,
        }
    }

    #[inline]
    pub fn getWrathTransition(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeWrathModuleConsts::VT_GETWRATHTRANSITION,
                None,
            )
        }
    }
    #[inline]
    pub fn getWrathToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeWrathModuleConsts::VT_GETWRATHTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn hiddenWrathType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeWrathModuleConsts::VT_HIDDENWRATHTYPE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeWrathModuleConsts<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "getWrathTransition",
                Self::VT_GETWRATHTRANSITION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "getWrathToast",
                Self::VT_GETWRATHTOAST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "hiddenWrathType",
                Self::VT_HIDDENWRATHTYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeWrathModuleConstsArgs<'a> {
    pub getWrathTransition: Option<flatbuffers::WIPOffset<&'a str>>,
    pub getWrathToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hiddenWrathType: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeWrathModuleConstsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeWrathModuleConstsArgs {
            getWrathTransition: None,
            getWrathToast: None,
            hiddenWrathType: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeWrathModuleConsts<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeWrathModuleConsts", 3)?;
        if let Some(f) = self.getWrathTransition() {
            s.serialize_field("getWrathTransition", &f)?;
        } else {
            s.skip_field("getWrathTransition")?;
        }
        if let Some(f) = self.getWrathToast() {
            s.serialize_field("getWrathToast", &f)?;
        } else {
            s.skip_field("getWrathToast")?;
        }
        if let Some(f) = self.hiddenWrathType() {
            s.serialize_field("hiddenWrathType", &f)?;
        } else {
            s.skip_field("hiddenWrathType")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeWrathModuleConstsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeWrathModuleConstsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_getWrathTransition(&mut self, getWrathTransition: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeWrathModuleConsts::VT_GETWRATHTRANSITION,
            getWrathTransition,
        );
    }
    #[inline]
    pub fn add_getWrathToast(&mut self, getWrathToast: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeWrathModuleConsts::VT_GETWRATHTOAST,
            getWrathToast,
        );
    }
    #[inline]
    pub fn add_hiddenWrathType(&mut self, hiddenWrathType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeWrathModuleConsts::VT_HIDDENWRATHTYPE,
            hiddenWrathType,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeWrathModuleConstsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeWrathModuleConstsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathModuleConsts<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeWrathModuleConsts<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeWrathModuleConsts");
        ds.field("getWrathTransition", &self.getWrathTransition());
        ds.field("getWrathToast", &self.getWrathToast());
        ds.field("hiddenWrathType", &self.hiddenWrathType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeWrathModuleConstsT {
    pub getWrathTransition: Option<String>,
    pub getWrathToast: Option<String>,
    pub hiddenWrathType: Option<String>,
}
impl Default for clz_Torappu_RoguelikeWrathModuleConstsT {
    fn default() -> Self {
        Self {
            getWrathTransition: None,
            getWrathToast: None,
            hiddenWrathType: None,
        }
    }
}
impl clz_Torappu_RoguelikeWrathModuleConstsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathModuleConsts<'b>> {
        let getWrathTransition = self
            .getWrathTransition
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let getWrathToast = self.getWrathToast.as_ref().map(|x| _fbb.create_string(x));
        let hiddenWrathType = self.hiddenWrathType.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeWrathModuleConsts::create(
            _fbb,
            &clz_Torappu_RoguelikeWrathModuleConstsArgs {
                getWrathTransition,
                getWrathToast,
                hiddenWrathType,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeWrathModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeWrathModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeWrathModuleData<'a> {
    type Inner = clz_Torappu_RoguelikeWrathModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeWrathModuleData<'a> {
    pub const VT_WRATHDATA: flatbuffers::VOffsetT = 4;
    pub const VT_MODULECONSTS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeWrathModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeWrathModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathModuleData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeWrathModuleDataBuilder::new(_fbb);
        if let Some(x) = args.moduleConsts {
            builder.add_moduleConsts(x);
        }
        if let Some(x) = args.wrathData {
            builder.add_wrathData(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeWrathModuleDataT {
        let wrathData = self
            .wrathData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let moduleConsts = self.moduleConsts().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeWrathModuleDataT {
            wrathData,
            moduleConsts,
        }
    }

    #[inline]
    pub fn wrathData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeWrathData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeWrathData>,
                >,
            >>(clz_Torappu_RoguelikeWrathModuleData::VT_WRATHDATA, None)
        }
    }
    #[inline]
    pub fn moduleConsts(&self) -> Option<clz_Torappu_RoguelikeWrathModuleConsts<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeWrathModuleConsts>>(
                    clz_Torappu_RoguelikeWrathModuleData::VT_MODULECONSTS,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeWrathModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeWrathData>,
                >,
            >>("wrathData", Self::VT_WRATHDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeWrathModuleConsts>>(
                "moduleConsts",
                Self::VT_MODULECONSTS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeWrathModuleDataArgs<'a> {
    pub wrathData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeWrathData<'a>>,
            >,
        >,
    >,
    pub moduleConsts: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathModuleConsts<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeWrathModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeWrathModuleDataArgs {
            wrathData: None,
            moduleConsts: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeWrathModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeWrathModuleData", 2)?;
        if let Some(f) = self.wrathData() {
            s.serialize_field("wrathData", &f)?;
        } else {
            s.skip_field("wrathData")?;
        }
        if let Some(f) = self.moduleConsts() {
            s.serialize_field("moduleConsts", &f)?;
        } else {
            s.skip_field("moduleConsts")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeWrathModuleDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeWrathModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_wrathData(
        &mut self,
        wrathData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeWrathData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeWrathModuleData::VT_WRATHDATA,
            wrathData,
        );
    }
    #[inline]
    pub fn add_moduleConsts(
        &mut self,
        moduleConsts: flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathModuleConsts<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathModuleConsts>>(
                clz_Torappu_RoguelikeWrathModuleData::VT_MODULECONSTS,
                moduleConsts,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeWrathModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeWrathModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeWrathModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeWrathModuleData");
        ds.field("wrathData", &self.wrathData());
        ds.field("moduleConsts", &self.moduleConsts());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeWrathModuleDataT {
    pub wrathData: Option<Vec<dict__string__clz_Torappu_RoguelikeWrathDataT>>,
    pub moduleConsts: Option<Box<clz_Torappu_RoguelikeWrathModuleConstsT>>,
}
impl Default for clz_Torappu_RoguelikeWrathModuleDataT {
    fn default() -> Self {
        Self {
            wrathData: None,
            moduleConsts: None,
        }
    }
}
impl clz_Torappu_RoguelikeWrathModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathModuleData<'b>> {
        let wrathData = self.wrathData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let moduleConsts = self.moduleConsts.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeWrathModuleData::create(
            _fbb,
            &clz_Torappu_RoguelikeWrathModuleDataArgs {
                wrathData,
                moduleConsts,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeCandleModuleConstsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeCandleModuleConsts<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeCandleModuleConsts<'a> {
    type Inner = clz_Torappu_RoguelikeCandleModuleConsts<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeCandleModuleConsts<'a> {
    pub const VT_CANDLEHOLDERBUFFID: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeCandleModuleConsts { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeCandleModuleConstsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCandleModuleConsts<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeCandleModuleConstsBuilder::new(_fbb);
        if let Some(x) = args.candleHolderBuffId {
            builder.add_candleHolderBuffId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeCandleModuleConstsT {
        let candleHolderBuffId = self.candleHolderBuffId().map(|x| x.to_string());
        clz_Torappu_RoguelikeCandleModuleConstsT { candleHolderBuffId }
    }

    #[inline]
    pub fn candleHolderBuffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCandleModuleConsts::VT_CANDLEHOLDERBUFFID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeCandleModuleConsts<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "candleHolderBuffId",
                Self::VT_CANDLEHOLDERBUFFID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeCandleModuleConstsArgs<'a> {
    pub candleHolderBuffId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeCandleModuleConstsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeCandleModuleConstsArgs {
            candleHolderBuffId: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeCandleModuleConsts<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeCandleModuleConsts", 1)?;
        if let Some(f) = self.candleHolderBuffId() {
            s.serialize_field("candleHolderBuffId", &f)?;
        } else {
            s.skip_field("candleHolderBuffId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeCandleModuleConstsBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeCandleModuleConstsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_candleHolderBuffId(&mut self, candleHolderBuffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCandleModuleConsts::VT_CANDLEHOLDERBUFFID,
            candleHolderBuffId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeCandleModuleConstsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeCandleModuleConstsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCandleModuleConsts<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeCandleModuleConsts<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeCandleModuleConsts");
        ds.field("candleHolderBuffId", &self.candleHolderBuffId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeCandleModuleConstsT {
    pub candleHolderBuffId: Option<String>,
}
impl Default for clz_Torappu_RoguelikeCandleModuleConstsT {
    fn default() -> Self {
        Self {
            candleHolderBuffId: None,
        }
    }
}
impl clz_Torappu_RoguelikeCandleModuleConstsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCandleModuleConsts<'b>> {
        let candleHolderBuffId = self
            .candleHolderBuffId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeCandleModuleConsts::create(
            _fbb,
            &clz_Torappu_RoguelikeCandleModuleConstsArgs { candleHolderBuffId },
        )
    }
}
pub enum clz_Torappu_RoguelikeCandleModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeCandleModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeCandleModuleData<'a> {
    type Inner = clz_Torappu_RoguelikeCandleModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeCandleModuleData<'a> {
    pub const VT_CANDLETICKETIDLIST: flatbuffers::VOffsetT = 4;
    pub const VT_MODULECONSTS: flatbuffers::VOffsetT = 6;
    pub const VT_CANDLEBATTLESTAGEIDLIST: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeCandleModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeCandleModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCandleModuleData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeCandleModuleDataBuilder::new(_fbb);
        if let Some(x) = args.candleBattleStageIdList {
            builder.add_candleBattleStageIdList(x);
        }
        if let Some(x) = args.moduleConsts {
            builder.add_moduleConsts(x);
        }
        if let Some(x) = args.candleTicketIdList {
            builder.add_candleTicketIdList(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeCandleModuleDataT {
        let candleTicketIdList = self
            .candleTicketIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let moduleConsts = self.moduleConsts().map(|x| Box::new(x.unpack()));
        let candleBattleStageIdList = self
            .candleBattleStageIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_RoguelikeCandleModuleDataT {
            candleTicketIdList,
            moduleConsts,
            candleBattleStageIdList,
        }
    }

    #[inline]
    pub fn candleTicketIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RoguelikeCandleModuleData::VT_CANDLETICKETIDLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn moduleConsts(&self) -> Option<clz_Torappu_RoguelikeCandleModuleConsts<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCandleModuleConsts>>(
                    clz_Torappu_RoguelikeCandleModuleData::VT_MODULECONSTS,
                    None,
                )
        }
    }
    #[inline]
    pub fn candleBattleStageIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RoguelikeCandleModuleData::VT_CANDLEBATTLESTAGEIDLIST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeCandleModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("candleTicketIdList", Self::VT_CANDLETICKETIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCandleModuleConsts>>(
                "moduleConsts",
                Self::VT_MODULECONSTS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "candleBattleStageIdList",
                Self::VT_CANDLEBATTLESTAGEIDLIST,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeCandleModuleDataArgs<'a> {
    pub candleTicketIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub moduleConsts: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCandleModuleConsts<'a>>>,
    pub candleBattleStageIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeCandleModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeCandleModuleDataArgs {
            candleTicketIdList: None,
            moduleConsts: None,
            candleBattleStageIdList: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeCandleModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeCandleModuleData", 3)?;
        if let Some(f) = self.candleTicketIdList() {
            s.serialize_field("candleTicketIdList", &f)?;
        } else {
            s.skip_field("candleTicketIdList")?;
        }
        if let Some(f) = self.moduleConsts() {
            s.serialize_field("moduleConsts", &f)?;
        } else {
            s.skip_field("moduleConsts")?;
        }
        if let Some(f) = self.candleBattleStageIdList() {
            s.serialize_field("candleBattleStageIdList", &f)?;
        } else {
            s.skip_field("candleBattleStageIdList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeCandleModuleDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeCandleModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_candleTicketIdList(
        &mut self,
        candleTicketIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCandleModuleData::VT_CANDLETICKETIDLIST,
            candleTicketIdList,
        );
    }
    #[inline]
    pub fn add_moduleConsts(
        &mut self,
        moduleConsts: flatbuffers::WIPOffset<clz_Torappu_RoguelikeCandleModuleConsts<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCandleModuleConsts>>(
                clz_Torappu_RoguelikeCandleModuleData::VT_MODULECONSTS,
                moduleConsts,
            );
    }
    #[inline]
    pub fn add_candleBattleStageIdList(
        &mut self,
        candleBattleStageIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCandleModuleData::VT_CANDLEBATTLESTAGEIDLIST,
            candleBattleStageIdList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeCandleModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeCandleModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCandleModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeCandleModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeCandleModuleData");
        ds.field("candleTicketIdList", &self.candleTicketIdList());
        ds.field("moduleConsts", &self.moduleConsts());
        ds.field("candleBattleStageIdList", &self.candleBattleStageIdList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeCandleModuleDataT {
    pub candleTicketIdList: Option<Vec<String>>,
    pub moduleConsts: Option<Box<clz_Torappu_RoguelikeCandleModuleConstsT>>,
    pub candleBattleStageIdList: Option<Vec<String>>,
}
impl Default for clz_Torappu_RoguelikeCandleModuleDataT {
    fn default() -> Self {
        Self {
            candleTicketIdList: None,
            moduleConsts: None,
            candleBattleStageIdList: None,
        }
    }
}
impl clz_Torappu_RoguelikeCandleModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCandleModuleData<'b>> {
        let candleTicketIdList = self.candleTicketIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let moduleConsts = self.moduleConsts.as_ref().map(|x| x.pack(_fbb));
        let candleBattleStageIdList = self.candleBattleStageIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeCandleModuleData::create(
            _fbb,
            &clz_Torappu_RoguelikeCandleModuleDataArgs {
                candleTicketIdList,
                moduleConsts,
                candleBattleStageIdList,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeSkyNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeSkyNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeSkyNodeData<'a> {
    type Inner = clz_Torappu_RoguelikeSkyNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeSkyNodeData<'a> {
    pub const VT_EVTTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_ICONID: flatbuffers::VOffsetT = 8;
    pub const VT_EFFID: flatbuffers::VOffsetT = 10;
    pub const VT_DESC: flatbuffers::VOffsetT = 12;
    pub const VT_NAMEBKGCLR: flatbuffers::VOffsetT = 14;
    pub const VT_SELECTCLR: flatbuffers::VOffsetT = 16;
    pub const VT_ISREPEATEDLY: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeSkyNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeSkyNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyNodeData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeSkyNodeDataBuilder::new(_fbb);
        if let Some(x) = args.selectClr {
            builder.add_selectClr(x);
        }
        if let Some(x) = args.nameBkgClr {
            builder.add_nameBkgClr(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.effId {
            builder.add_effId(x);
        }
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_evtType(args.evtType);
        builder.add_isRepeatedly(args.isRepeatedly);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeSkyNodeDataT {
        let evtType = self.evtType();
        let name = self.name().map(|x| x.to_string());
        let iconId = self.iconId().map(|x| x.to_string());
        let effId = self.effId().map(|x| x.to_string());
        let desc = self.desc().map(|x| x.to_string());
        let nameBkgClr = self.nameBkgClr().map(|x| x.to_string());
        let selectClr = self.selectClr().map(|x| x.to_string());
        let isRepeatedly = self.isRepeatedly();
        clz_Torappu_RoguelikeSkyNodeDataT {
            evtType,
            name,
            iconId,
            effId,
            desc,
            nameBkgClr,
            selectClr,
            isRepeatedly,
        }
    }

    #[inline]
    pub fn evtType(&self) -> enum__Torappu_RoguelikeSkyZoneNodeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeSkyZoneNodeType>(
                    clz_Torappu_RoguelikeSkyNodeData::VT_EVTTYPE,
                    Some(enum__Torappu_RoguelikeSkyZoneNodeType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeSkyNodeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeSkyNodeData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn effId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeSkyNodeData::VT_EFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeSkyNodeData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn nameBkgClr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeSkyNodeData::VT_NAMEBKGCLR,
                None,
            )
        }
    }
    #[inline]
    pub fn selectClr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeSkyNodeData::VT_SELECTCLR,
                None,
            )
        }
    }
    #[inline]
    pub fn isRepeatedly(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RoguelikeSkyNodeData::VT_ISREPEATEDLY,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeSkyNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeSkyZoneNodeType>(
                "evtType",
                Self::VT_EVTTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("effId", Self::VT_EFFID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nameBkgClr",
                Self::VT_NAMEBKGCLR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "selectClr",
                Self::VT_SELECTCLR,
                false,
            )?
            .visit_field::<bool>("isRepeatedly", Self::VT_ISREPEATEDLY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeSkyNodeDataArgs<'a> {
    pub evtType: enum__Torappu_RoguelikeSkyZoneNodeType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub effId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nameBkgClr: Option<flatbuffers::WIPOffset<&'a str>>,
    pub selectClr: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isRepeatedly: bool,
}
impl<'a> Default for clz_Torappu_RoguelikeSkyNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeSkyNodeDataArgs {
            evtType: enum__Torappu_RoguelikeSkyZoneNodeType::NONE,
            name: None,
            iconId: None,
            effId: None,
            desc: None,
            nameBkgClr: None,
            selectClr: None,
            isRepeatedly: false,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeSkyNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeSkyNodeData", 8)?;
        s.serialize_field("evtType", &self.evtType())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.iconId() {
            s.serialize_field("iconId", &f)?;
        } else {
            s.skip_field("iconId")?;
        }
        if let Some(f) = self.effId() {
            s.serialize_field("effId", &f)?;
        } else {
            s.skip_field("effId")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        if let Some(f) = self.nameBkgClr() {
            s.serialize_field("nameBkgClr", &f)?;
        } else {
            s.skip_field("nameBkgClr")?;
        }
        if let Some(f) = self.selectClr() {
            s.serialize_field("selectClr", &f)?;
        } else {
            s.skip_field("selectClr")?;
        }
        s.serialize_field("isRepeatedly", &self.isRepeatedly())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeSkyNodeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeSkyNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_evtType(&mut self, evtType: enum__Torappu_RoguelikeSkyZoneNodeType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeSkyZoneNodeType>(
                clz_Torappu_RoguelikeSkyNodeData::VT_EVTTYPE,
                evtType,
                enum__Torappu_RoguelikeSkyZoneNodeType::NONE,
            );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSkyNodeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSkyNodeData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_effId(&mut self, effId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSkyNodeData::VT_EFFID,
            effId,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSkyNodeData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_nameBkgClr(&mut self, nameBkgClr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSkyNodeData::VT_NAMEBKGCLR,
            nameBkgClr,
        );
    }
    #[inline]
    pub fn add_selectClr(&mut self, selectClr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSkyNodeData::VT_SELECTCLR,
            selectClr,
        );
    }
    #[inline]
    pub fn add_isRepeatedly(&mut self, isRepeatedly: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RoguelikeSkyNodeData::VT_ISREPEATEDLY,
            isRepeatedly,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeSkyNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeSkyNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeSkyNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeSkyNodeData");
        ds.field("evtType", &self.evtType());
        ds.field("name", &self.name());
        ds.field("iconId", &self.iconId());
        ds.field("effId", &self.effId());
        ds.field("desc", &self.desc());
        ds.field("nameBkgClr", &self.nameBkgClr());
        ds.field("selectClr", &self.selectClr());
        ds.field("isRepeatedly", &self.isRepeatedly());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeSkyNodeDataT {
    pub evtType: enum__Torappu_RoguelikeSkyZoneNodeType,
    pub name: Option<String>,
    pub iconId: Option<String>,
    pub effId: Option<String>,
    pub desc: Option<String>,
    pub nameBkgClr: Option<String>,
    pub selectClr: Option<String>,
    pub isRepeatedly: bool,
}
impl Default for clz_Torappu_RoguelikeSkyNodeDataT {
    fn default() -> Self {
        Self {
            evtType: enum__Torappu_RoguelikeSkyZoneNodeType::NONE,
            name: None,
            iconId: None,
            effId: None,
            desc: None,
            nameBkgClr: None,
            selectClr: None,
            isRepeatedly: false,
        }
    }
}
impl clz_Torappu_RoguelikeSkyNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyNodeData<'b>> {
        let evtType = self.evtType;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let iconId = self.iconId.as_ref().map(|x| _fbb.create_string(x));
        let effId = self.effId.as_ref().map(|x| _fbb.create_string(x));
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        let nameBkgClr = self.nameBkgClr.as_ref().map(|x| _fbb.create_string(x));
        let selectClr = self.selectClr.as_ref().map(|x| _fbb.create_string(x));
        let isRepeatedly = self.isRepeatedly;
        clz_Torappu_RoguelikeSkyNodeData::create(
            _fbb,
            &clz_Torappu_RoguelikeSkyNodeDataArgs {
                evtType,
                name,
                iconId,
                effId,
                desc,
                nameBkgClr,
                selectClr,
                isRepeatedly,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeSkyNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeSkyNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeSkyNodeData<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeSkyNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeSkyNodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeSkyNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeSkyNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeSkyNodeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeSkyNodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeSkyNodeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeSkyNodeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeSkyNodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeSkyNodeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeSkyNodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSkyNodeData>>(
                    dict__string__clz_Torappu_RoguelikeSkyNodeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeSkyNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSkyNodeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeSkyNodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyNodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeSkyNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeSkyNodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeSkyNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeSkyNodeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeSkyNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeSkyNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeSkyNodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyNodeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyNodeData>>(
                dict__string__clz_Torappu_RoguelikeSkyNodeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeSkyNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeSkyNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeSkyNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeSkyNodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeSkyNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeSkyNodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeSkyNodeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeSkyNodeDataT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeSkyNodeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeSkyNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeSkyNodeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeSkyNodeData::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeSkyNodeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeSkyNodeSubTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeSkyNodeSubTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeSkyNodeSubTypeData<'a> {
    type Inner = clz_Torappu_RoguelikeSkyNodeSubTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeSkyNodeSubTypeData<'a> {
    pub const VT_EVTTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_SUBTYPEID: flatbuffers::VOffsetT = 6;
    pub const VT_DESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeSkyNodeSubTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeSkyNodeSubTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyNodeSubTypeData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeSkyNodeSubTypeDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        builder.add_subTypeId(args.subTypeId);
        builder.add_evtType(args.evtType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeSkyNodeSubTypeDataT {
        let evtType = self.evtType();
        let subTypeId = self.subTypeId();
        let desc = self.desc().map(|x| x.to_string());
        clz_Torappu_RoguelikeSkyNodeSubTypeDataT {
            evtType,
            subTypeId,
            desc,
        }
    }

    #[inline]
    pub fn evtType(&self) -> enum__Torappu_RoguelikeSkyZoneNodeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeSkyZoneNodeType>(
                    clz_Torappu_RoguelikeSkyNodeSubTypeData::VT_EVTTYPE,
                    Some(enum__Torappu_RoguelikeSkyZoneNodeType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn subTypeId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeSkyNodeSubTypeData::VT_SUBTYPEID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeSkyNodeSubTypeData::VT_DESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeSkyNodeSubTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeSkyZoneNodeType>(
                "evtType",
                Self::VT_EVTTYPE,
                false,
            )?
            .visit_field::<i32>("subTypeId", Self::VT_SUBTYPEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeSkyNodeSubTypeDataArgs<'a> {
    pub evtType: enum__Torappu_RoguelikeSkyZoneNodeType,
    pub subTypeId: i32,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeSkyNodeSubTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeSkyNodeSubTypeDataArgs {
            evtType: enum__Torappu_RoguelikeSkyZoneNodeType::NONE,
            subTypeId: 0,
            desc: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeSkyNodeSubTypeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeSkyNodeSubTypeData", 3)?;
        s.serialize_field("evtType", &self.evtType())?;
        s.serialize_field("subTypeId", &self.subTypeId())?;
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeSkyNodeSubTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeSkyNodeSubTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_evtType(&mut self, evtType: enum__Torappu_RoguelikeSkyZoneNodeType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeSkyZoneNodeType>(
                clz_Torappu_RoguelikeSkyNodeSubTypeData::VT_EVTTYPE,
                evtType,
                enum__Torappu_RoguelikeSkyZoneNodeType::NONE,
            );
    }
    #[inline]
    pub fn add_subTypeId(&mut self, subTypeId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeSkyNodeSubTypeData::VT_SUBTYPEID,
            subTypeId,
            0,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSkyNodeSubTypeData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeSkyNodeSubTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeSkyNodeSubTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyNodeSubTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeSkyNodeSubTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeSkyNodeSubTypeData");
        ds.field("evtType", &self.evtType());
        ds.field("subTypeId", &self.subTypeId());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeSkyNodeSubTypeDataT {
    pub evtType: enum__Torappu_RoguelikeSkyZoneNodeType,
    pub subTypeId: i32,
    pub desc: Option<String>,
}
impl Default for clz_Torappu_RoguelikeSkyNodeSubTypeDataT {
    fn default() -> Self {
        Self {
            evtType: enum__Torappu_RoguelikeSkyZoneNodeType::NONE,
            subTypeId: 0,
            desc: None,
        }
    }
}
impl clz_Torappu_RoguelikeSkyNodeSubTypeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyNodeSubTypeData<'b>> {
        let evtType = self.evtType;
        let subTypeId = self.subTypeId;
        let desc = self.desc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeSkyNodeSubTypeData::create(
            _fbb,
            &clz_Torappu_RoguelikeSkyNodeSubTypeDataArgs {
                evtType,
                subTypeId,
                desc,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeSkyModuleConstsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeSkyModuleConsts<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeSkyModuleConsts<'a> {
    type Inner = clz_Torappu_RoguelikeSkyModuleConsts<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeSkyModuleConsts<'a> {
    pub const VT_SKYAPITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_SKYMAXCOLUMNS: flatbuffers::VOffsetT = 6;
    pub const VT_SKYSACRIFICECHOICEDYNAMICKEY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeSkyModuleConsts { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeSkyModuleConstsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyModuleConsts<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeSkyModuleConstsBuilder::new(_fbb);
        if let Some(x) = args.skySacrificeChoiceDynamicKey {
            builder.add_skySacrificeChoiceDynamicKey(x);
        }
        builder.add_skyMaxColumns(args.skyMaxColumns);
        if let Some(x) = args.skyApItemId {
            builder.add_skyApItemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeSkyModuleConstsT {
        let skyApItemId = self.skyApItemId().map(|x| x.to_string());
        let skyMaxColumns = self.skyMaxColumns();
        let skySacrificeChoiceDynamicKey =
            self.skySacrificeChoiceDynamicKey().map(|x| x.to_string());
        clz_Torappu_RoguelikeSkyModuleConstsT {
            skyApItemId,
            skyMaxColumns,
            skySacrificeChoiceDynamicKey,
        }
    }

    #[inline]
    pub fn skyApItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeSkyModuleConsts::VT_SKYAPITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn skyMaxColumns(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeSkyModuleConsts::VT_SKYMAXCOLUMNS,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn skySacrificeChoiceDynamicKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeSkyModuleConsts::VT_SKYSACRIFICECHOICEDYNAMICKEY,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeSkyModuleConsts<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "skyApItemId",
                Self::VT_SKYAPITEMID,
                false,
            )?
            .visit_field::<i32>("skyMaxColumns", Self::VT_SKYMAXCOLUMNS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "skySacrificeChoiceDynamicKey",
                Self::VT_SKYSACRIFICECHOICEDYNAMICKEY,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeSkyModuleConstsArgs<'a> {
    pub skyApItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub skyMaxColumns: i32,
    pub skySacrificeChoiceDynamicKey: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeSkyModuleConstsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeSkyModuleConstsArgs {
            skyApItemId: None,
            skyMaxColumns: 0,
            skySacrificeChoiceDynamicKey: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeSkyModuleConsts<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeSkyModuleConsts", 3)?;
        if let Some(f) = self.skyApItemId() {
            s.serialize_field("skyApItemId", &f)?;
        } else {
            s.skip_field("skyApItemId")?;
        }
        s.serialize_field("skyMaxColumns", &self.skyMaxColumns())?;
        if let Some(f) = self.skySacrificeChoiceDynamicKey() {
            s.serialize_field("skySacrificeChoiceDynamicKey", &f)?;
        } else {
            s.skip_field("skySacrificeChoiceDynamicKey")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeSkyModuleConstsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeSkyModuleConstsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_skyApItemId(&mut self, skyApItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSkyModuleConsts::VT_SKYAPITEMID,
            skyApItemId,
        );
    }
    #[inline]
    pub fn add_skyMaxColumns(&mut self, skyMaxColumns: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeSkyModuleConsts::VT_SKYMAXCOLUMNS,
            skyMaxColumns,
            0,
        );
    }
    #[inline]
    pub fn add_skySacrificeChoiceDynamicKey(
        &mut self,
        skySacrificeChoiceDynamicKey: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSkyModuleConsts::VT_SKYSACRIFICECHOICEDYNAMICKEY,
            skySacrificeChoiceDynamicKey,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeSkyModuleConstsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeSkyModuleConstsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyModuleConsts<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeSkyModuleConsts<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeSkyModuleConsts");
        ds.field("skyApItemId", &self.skyApItemId());
        ds.field("skyMaxColumns", &self.skyMaxColumns());
        ds.field(
            "skySacrificeChoiceDynamicKey",
            &self.skySacrificeChoiceDynamicKey(),
        );
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeSkyModuleConstsT {
    pub skyApItemId: Option<String>,
    pub skyMaxColumns: i32,
    pub skySacrificeChoiceDynamicKey: Option<String>,
}
impl Default for clz_Torappu_RoguelikeSkyModuleConstsT {
    fn default() -> Self {
        Self {
            skyApItemId: None,
            skyMaxColumns: 0,
            skySacrificeChoiceDynamicKey: None,
        }
    }
}
impl clz_Torappu_RoguelikeSkyModuleConstsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyModuleConsts<'b>> {
        let skyApItemId = self.skyApItemId.as_ref().map(|x| _fbb.create_string(x));
        let skyMaxColumns = self.skyMaxColumns;
        let skySacrificeChoiceDynamicKey = self
            .skySacrificeChoiceDynamicKey
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeSkyModuleConsts::create(
            _fbb,
            &clz_Torappu_RoguelikeSkyModuleConstsArgs {
                skyApItemId,
                skyMaxColumns,
                skySacrificeChoiceDynamicKey,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeSkyModuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeSkyModuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeSkyModuleData<'a> {
    type Inner = clz_Torappu_RoguelikeSkyModuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeSkyModuleData<'a> {
    pub const VT_NODEDATA: flatbuffers::VOffsetT = 4;
    pub const VT_SUBTYPEDATA: flatbuffers::VOffsetT = 6;
    pub const VT_MODULECONSTS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeSkyModuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeSkyModuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyModuleData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeSkyModuleDataBuilder::new(_fbb);
        if let Some(x) = args.moduleConsts {
            builder.add_moduleConsts(x);
        }
        if let Some(x) = args.subTypeData {
            builder.add_subTypeData(x);
        }
        if let Some(x) = args.nodeData {
            builder.add_nodeData(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeSkyModuleDataT {
        let nodeData = self
            .nodeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let subTypeData = self
            .subTypeData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let moduleConsts = self.moduleConsts().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeSkyModuleDataT {
            nodeData,
            subTypeData,
            moduleConsts,
        }
    }

    #[inline]
    pub fn nodeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeSkyNodeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeSkyNodeData>,
                >,
            >>(clz_Torappu_RoguelikeSkyModuleData::VT_NODEDATA, None)
        }
    }
    #[inline]
    pub fn subTypeData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSkyNodeSubTypeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSkyNodeSubTypeData>,
                >,
            >>(clz_Torappu_RoguelikeSkyModuleData::VT_SUBTYPEDATA, None)
        }
    }
    #[inline]
    pub fn moduleConsts(&self) -> Option<clz_Torappu_RoguelikeSkyModuleConsts<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSkyModuleConsts>>(
                    clz_Torappu_RoguelikeSkyModuleData::VT_MODULECONSTS,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeSkyModuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeSkyNodeData>,
                >,
            >>("nodeData", Self::VT_NODEDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSkyNodeSubTypeData>,
                >,
            >>("subTypeData", Self::VT_SUBTYPEDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSkyModuleConsts>>(
                "moduleConsts",
                Self::VT_MODULECONSTS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeSkyModuleDataArgs<'a> {
    pub nodeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeSkyNodeData<'a>>,
            >,
        >,
    >,
    pub subTypeData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSkyNodeSubTypeData<'a>>,
            >,
        >,
    >,
    pub moduleConsts: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyModuleConsts<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeSkyModuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeSkyModuleDataArgs {
            nodeData: None,
            subTypeData: None,
            moduleConsts: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeSkyModuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeSkyModuleData", 3)?;
        if let Some(f) = self.nodeData() {
            s.serialize_field("nodeData", &f)?;
        } else {
            s.skip_field("nodeData")?;
        }
        if let Some(f) = self.subTypeData() {
            s.serialize_field("subTypeData", &f)?;
        } else {
            s.skip_field("subTypeData")?;
        }
        if let Some(f) = self.moduleConsts() {
            s.serialize_field("moduleConsts", &f)?;
        } else {
            s.skip_field("moduleConsts")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeSkyModuleDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeSkyModuleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeData(
        &mut self,
        nodeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeSkyNodeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSkyModuleData::VT_NODEDATA,
            nodeData,
        );
    }
    #[inline]
    pub fn add_subTypeData(
        &mut self,
        subTypeData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSkyNodeSubTypeData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeSkyModuleData::VT_SUBTYPEDATA,
            subTypeData,
        );
    }
    #[inline]
    pub fn add_moduleConsts(
        &mut self,
        moduleConsts: flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyModuleConsts<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyModuleConsts>>(
                clz_Torappu_RoguelikeSkyModuleData::VT_MODULECONSTS,
                moduleConsts,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeSkyModuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeSkyModuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyModuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeSkyModuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeSkyModuleData");
        ds.field("nodeData", &self.nodeData());
        ds.field("subTypeData", &self.subTypeData());
        ds.field("moduleConsts", &self.moduleConsts());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeSkyModuleDataT {
    pub nodeData: Option<Vec<dict__string__clz_Torappu_RoguelikeSkyNodeDataT>>,
    pub subTypeData: Option<Vec<clz_Torappu_RoguelikeSkyNodeSubTypeDataT>>,
    pub moduleConsts: Option<Box<clz_Torappu_RoguelikeSkyModuleConstsT>>,
}
impl Default for clz_Torappu_RoguelikeSkyModuleDataT {
    fn default() -> Self {
        Self {
            nodeData: None,
            subTypeData: None,
            moduleConsts: None,
        }
    }
}
impl clz_Torappu_RoguelikeSkyModuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyModuleData<'b>> {
        let nodeData = self.nodeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let subTypeData = self.subTypeData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let moduleConsts = self.moduleConsts.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeSkyModuleData::create(
            _fbb,
            &clz_Torappu_RoguelikeSkyModuleDataArgs {
                nodeData,
                subTypeData,
                moduleConsts,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeModuleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeModule<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeModule<'a> {
    type Inner = clz_Torappu_RoguelikeModule<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeModule<'a> {
    pub const VT_MODULETYPES: flatbuffers::VOffsetT = 4;
    pub const VT_SANCHECK: flatbuffers::VOffsetT = 6;
    pub const VT_DICE: flatbuffers::VOffsetT = 8;
    pub const VT_CHAOS: flatbuffers::VOffsetT = 10;
    pub const VT_TOTEMBUFF: flatbuffers::VOffsetT = 12;
    pub const VT_VISION: flatbuffers::VOffsetT = 14;
    pub const VT_FRAGMENT: flatbuffers::VOffsetT = 16;
    pub const VT_DISASTER: flatbuffers::VOffsetT = 18;
    pub const VT_NODEUPGRADE: flatbuffers::VOffsetT = 20;
    pub const VT_COPPER: flatbuffers::VOffsetT = 22;
    pub const VT_WRATH: flatbuffers::VOffsetT = 24;
    pub const VT_CANDLE: flatbuffers::VOffsetT = 26;
    pub const VT_SKY: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeModule { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeModuleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeModule<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeModuleBuilder::new(_fbb);
        if let Some(x) = args.sky {
            builder.add_sky(x);
        }
        if let Some(x) = args.candle {
            builder.add_candle(x);
        }
        if let Some(x) = args.wrath {
            builder.add_wrath(x);
        }
        if let Some(x) = args.copper {
            builder.add_copper(x);
        }
        if let Some(x) = args.nodeUpgrade {
            builder.add_nodeUpgrade(x);
        }
        if let Some(x) = args.disaster {
            builder.add_disaster(x);
        }
        if let Some(x) = args.fragment {
            builder.add_fragment(x);
        }
        if let Some(x) = args.vision {
            builder.add_vision(x);
        }
        if let Some(x) = args.totemBuff {
            builder.add_totemBuff(x);
        }
        if let Some(x) = args.chaos {
            builder.add_chaos(x);
        }
        if let Some(x) = args.dice {
            builder.add_dice(x);
        }
        if let Some(x) = args.sanCheck {
            builder.add_sanCheck(x);
        }
        if let Some(x) = args.moduleTypes {
            builder.add_moduleTypes(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeModuleT {
        let moduleTypes = self.moduleTypes().map(|x| x.into_iter().collect());
        let sanCheck = self.sanCheck().map(|x| Box::new(x.unpack()));
        let dice = self.dice().map(|x| Box::new(x.unpack()));
        let chaos = self.chaos().map(|x| Box::new(x.unpack()));
        let totemBuff = self.totemBuff().map(|x| Box::new(x.unpack()));
        let vision = self.vision().map(|x| Box::new(x.unpack()));
        let fragment = self.fragment().map(|x| Box::new(x.unpack()));
        let disaster = self.disaster().map(|x| Box::new(x.unpack()));
        let nodeUpgrade = self.nodeUpgrade().map(|x| Box::new(x.unpack()));
        let copper = self.copper().map(|x| Box::new(x.unpack()));
        let wrath = self.wrath().map(|x| Box::new(x.unpack()));
        let candle = self.candle().map(|x| Box::new(x.unpack()));
        let sky = self.sky().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeModuleT {
            moduleTypes,
            sanCheck,
            dice,
            chaos,
            totemBuff,
            vision,
            fragment,
            disaster,
            nodeUpgrade,
            copper,
            wrath,
            candle,
            sky,
        }
    }

    #[inline]
    pub fn moduleTypes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_RoguelikeModuleType>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_RoguelikeModuleType>,
            >>(clz_Torappu_RoguelikeModule::VT_MODULETYPES, None)
        }
    }
    #[inline]
    pub fn sanCheck(&self) -> Option<clz_Torappu_RoguelikeSanCheckModuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSanCheckModuleData>>(
                    clz_Torappu_RoguelikeModule::VT_SANCHECK,
                    None,
                )
        }
    }
    #[inline]
    pub fn dice(&self) -> Option<clz_Torappu_RoguelikeDiceModuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDiceModuleData>>(
                    clz_Torappu_RoguelikeModule::VT_DICE,
                    None,
                )
        }
    }
    #[inline]
    pub fn chaos(&self) -> Option<clz_Torappu_RoguelikeChaosModuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeChaosModuleData>>(
                    clz_Torappu_RoguelikeModule::VT_CHAOS,
                    None,
                )
        }
    }
    #[inline]
    pub fn totemBuff(&self) -> Option<clz_Torappu_RoguelikeTotemBuffModuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTotemBuffModuleData>>(
                    clz_Torappu_RoguelikeModule::VT_TOTEMBUFF,
                    None,
                )
        }
    }
    #[inline]
    pub fn vision(&self) -> Option<clz_Torappu_RoguelikeVisionModuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeVisionModuleData>>(
                    clz_Torappu_RoguelikeModule::VT_VISION,
                    None,
                )
        }
    }
    #[inline]
    pub fn fragment(&self) -> Option<clz_Torappu_RoguelikeFragmentModuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeFragmentModuleData>>(
                    clz_Torappu_RoguelikeModule::VT_FRAGMENT,
                    None,
                )
        }
    }
    #[inline]
    pub fn disaster(&self) -> Option<clz_Torappu_RoguelikeDisasterModuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDisasterModuleData>>(
                    clz_Torappu_RoguelikeModule::VT_DISASTER,
                    None,
                )
        }
    }
    #[inline]
    pub fn nodeUpgrade(&self) -> Option<clz_Torappu_RoguelikeNodeUpgradeModuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeNodeUpgradeModuleData>>(
                    clz_Torappu_RoguelikeModule::VT_NODEUPGRADE,
                    None,
                )
        }
    }
    #[inline]
    pub fn copper(&self) -> Option<clz_Torappu_RoguelikeCopperModuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCopperModuleData>>(
                    clz_Torappu_RoguelikeModule::VT_COPPER,
                    None,
                )
        }
    }
    #[inline]
    pub fn wrath(&self) -> Option<clz_Torappu_RoguelikeWrathModuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeWrathModuleData>>(
                    clz_Torappu_RoguelikeModule::VT_WRATH,
                    None,
                )
        }
    }
    #[inline]
    pub fn candle(&self) -> Option<clz_Torappu_RoguelikeCandleModuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCandleModuleData>>(
                    clz_Torappu_RoguelikeModule::VT_CANDLE,
                    None,
                )
        }
    }
    #[inline]
    pub fn sky(&self) -> Option<clz_Torappu_RoguelikeSkyModuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSkyModuleData>>(
                    clz_Torappu_RoguelikeModule::VT_SKY,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeModule<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_RoguelikeModuleType>>>("moduleTypes", Self::VT_MODULETYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSanCheckModuleData>>("sanCheck", Self::VT_SANCHECK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDiceModuleData>>("dice", Self::VT_DICE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeChaosModuleData>>("chaos", Self::VT_CHAOS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTotemBuffModuleData>>("totemBuff", Self::VT_TOTEMBUFF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeVisionModuleData>>("vision", Self::VT_VISION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeFragmentModuleData>>("fragment", Self::VT_FRAGMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeDisasterModuleData>>("disaster", Self::VT_DISASTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeNodeUpgradeModuleData>>("nodeUpgrade", Self::VT_NODEUPGRADE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCopperModuleData>>("copper", Self::VT_COPPER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeWrathModuleData>>("wrath", Self::VT_WRATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCandleModuleData>>("candle", Self::VT_CANDLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeSkyModuleData>>("sky", Self::VT_SKY, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeModuleArgs<'a> {
    pub moduleTypes:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_RoguelikeModuleType>>>,
    pub sanCheck: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeSanCheckModuleData<'a>>>,
    pub dice: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceModuleData<'a>>>,
    pub chaos: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosModuleData<'a>>>,
    pub totemBuff: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemBuffModuleData<'a>>>,
    pub vision: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleData<'a>>>,
    pub fragment: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentModuleData<'a>>>,
    pub disaster: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeDisasterModuleData<'a>>>,
    pub nodeUpgrade: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeNodeUpgradeModuleData<'a>>>,
    pub copper: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperModuleData<'a>>>,
    pub wrath: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathModuleData<'a>>>,
    pub candle: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCandleModuleData<'a>>>,
    pub sky: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyModuleData<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeModuleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeModuleArgs {
            moduleTypes: None,
            sanCheck: None,
            dice: None,
            chaos: None,
            totemBuff: None,
            vision: None,
            fragment: None,
            disaster: None,
            nodeUpgrade: None,
            copper: None,
            wrath: None,
            candle: None,
            sky: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeModule<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeModule", 13)?;
        if let Some(f) = self.moduleTypes() {
            s.serialize_field("moduleTypes", &f)?;
        } else {
            s.skip_field("moduleTypes")?;
        }
        if let Some(f) = self.sanCheck() {
            s.serialize_field("sanCheck", &f)?;
        } else {
            s.skip_field("sanCheck")?;
        }
        if let Some(f) = self.dice() {
            s.serialize_field("dice", &f)?;
        } else {
            s.skip_field("dice")?;
        }
        if let Some(f) = self.chaos() {
            s.serialize_field("chaos", &f)?;
        } else {
            s.skip_field("chaos")?;
        }
        if let Some(f) = self.totemBuff() {
            s.serialize_field("totemBuff", &f)?;
        } else {
            s.skip_field("totemBuff")?;
        }
        if let Some(f) = self.vision() {
            s.serialize_field("vision", &f)?;
        } else {
            s.skip_field("vision")?;
        }
        if let Some(f) = self.fragment() {
            s.serialize_field("fragment", &f)?;
        } else {
            s.skip_field("fragment")?;
        }
        if let Some(f) = self.disaster() {
            s.serialize_field("disaster", &f)?;
        } else {
            s.skip_field("disaster")?;
        }
        if let Some(f) = self.nodeUpgrade() {
            s.serialize_field("nodeUpgrade", &f)?;
        } else {
            s.skip_field("nodeUpgrade")?;
        }
        if let Some(f) = self.copper() {
            s.serialize_field("copper", &f)?;
        } else {
            s.skip_field("copper")?;
        }
        if let Some(f) = self.wrath() {
            s.serialize_field("wrath", &f)?;
        } else {
            s.skip_field("wrath")?;
        }
        if let Some(f) = self.candle() {
            s.serialize_field("candle", &f)?;
        } else {
            s.skip_field("candle")?;
        }
        if let Some(f) = self.sky() {
            s.serialize_field("sky", &f)?;
        } else {
            s.skip_field("sky")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeModuleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RoguelikeModuleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_moduleTypes(
        &mut self,
        moduleTypes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_RoguelikeModuleType>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeModule::VT_MODULETYPES,
            moduleTypes,
        );
    }
    #[inline]
    pub fn add_sanCheck(
        &mut self,
        sanCheck: flatbuffers::WIPOffset<clz_Torappu_RoguelikeSanCheckModuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeSanCheckModuleData>>(
                clz_Torappu_RoguelikeModule::VT_SANCHECK,
                sanCheck,
            );
    }
    #[inline]
    pub fn add_dice(
        &mut self,
        dice: flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceModuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeDiceModuleData>>(
                clz_Torappu_RoguelikeModule::VT_DICE,
                dice,
            );
    }
    #[inline]
    pub fn add_chaos(
        &mut self,
        chaos: flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosModuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeChaosModuleData>>(
                clz_Torappu_RoguelikeModule::VT_CHAOS,
                chaos,
            );
    }
    #[inline]
    pub fn add_totemBuff(
        &mut self,
        totemBuff: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemBuffModuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTotemBuffModuleData>>(
                clz_Torappu_RoguelikeModule::VT_TOTEMBUFF,
                totemBuff,
            );
    }
    #[inline]
    pub fn add_vision(
        &mut self,
        vision: flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeVisionModuleData>>(
                clz_Torappu_RoguelikeModule::VT_VISION,
                vision,
            );
    }
    #[inline]
    pub fn add_fragment(
        &mut self,
        fragment: flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentModuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeFragmentModuleData>>(
                clz_Torappu_RoguelikeModule::VT_FRAGMENT,
                fragment,
            );
    }
    #[inline]
    pub fn add_disaster(
        &mut self,
        disaster: flatbuffers::WIPOffset<clz_Torappu_RoguelikeDisasterModuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeDisasterModuleData>>(
                clz_Torappu_RoguelikeModule::VT_DISASTER,
                disaster,
            );
    }
    #[inline]
    pub fn add_nodeUpgrade(
        &mut self,
        nodeUpgrade: flatbuffers::WIPOffset<clz_Torappu_RoguelikeNodeUpgradeModuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeNodeUpgradeModuleData>>(
                clz_Torappu_RoguelikeModule::VT_NODEUPGRADE,
                nodeUpgrade,
            );
    }
    #[inline]
    pub fn add_copper(
        &mut self,
        copper: flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperModuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCopperModuleData>>(
                clz_Torappu_RoguelikeModule::VT_COPPER,
                copper,
            );
    }
    #[inline]
    pub fn add_wrath(
        &mut self,
        wrath: flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathModuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeWrathModuleData>>(
                clz_Torappu_RoguelikeModule::VT_WRATH,
                wrath,
            );
    }
    #[inline]
    pub fn add_candle(
        &mut self,
        candle: flatbuffers::WIPOffset<clz_Torappu_RoguelikeCandleModuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCandleModuleData>>(
                clz_Torappu_RoguelikeModule::VT_CANDLE,
                candle,
            );
    }
    #[inline]
    pub fn add_sky(&mut self, sky: flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyModuleData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeSkyModuleData>>(
                clz_Torappu_RoguelikeModule::VT_SKY,
                sky,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeModuleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeModuleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeModule<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeModule<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeModule");
        ds.field("moduleTypes", &self.moduleTypes());
        ds.field("sanCheck", &self.sanCheck());
        ds.field("dice", &self.dice());
        ds.field("chaos", &self.chaos());
        ds.field("totemBuff", &self.totemBuff());
        ds.field("vision", &self.vision());
        ds.field("fragment", &self.fragment());
        ds.field("disaster", &self.disaster());
        ds.field("nodeUpgrade", &self.nodeUpgrade());
        ds.field("copper", &self.copper());
        ds.field("wrath", &self.wrath());
        ds.field("candle", &self.candle());
        ds.field("sky", &self.sky());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeModuleT {
    pub moduleTypes: Option<Vec<enum__Torappu_RoguelikeModuleType>>,
    pub sanCheck: Option<Box<clz_Torappu_RoguelikeSanCheckModuleDataT>>,
    pub dice: Option<Box<clz_Torappu_RoguelikeDiceModuleDataT>>,
    pub chaos: Option<Box<clz_Torappu_RoguelikeChaosModuleDataT>>,
    pub totemBuff: Option<Box<clz_Torappu_RoguelikeTotemBuffModuleDataT>>,
    pub vision: Option<Box<clz_Torappu_RoguelikeVisionModuleDataT>>,
    pub fragment: Option<Box<clz_Torappu_RoguelikeFragmentModuleDataT>>,
    pub disaster: Option<Box<clz_Torappu_RoguelikeDisasterModuleDataT>>,
    pub nodeUpgrade: Option<Box<clz_Torappu_RoguelikeNodeUpgradeModuleDataT>>,
    pub copper: Option<Box<clz_Torappu_RoguelikeCopperModuleDataT>>,
    pub wrath: Option<Box<clz_Torappu_RoguelikeWrathModuleDataT>>,
    pub candle: Option<Box<clz_Torappu_RoguelikeCandleModuleDataT>>,
    pub sky: Option<Box<clz_Torappu_RoguelikeSkyModuleDataT>>,
}
impl Default for clz_Torappu_RoguelikeModuleT {
    fn default() -> Self {
        Self {
            moduleTypes: None,
            sanCheck: None,
            dice: None,
            chaos: None,
            totemBuff: None,
            vision: None,
            fragment: None,
            disaster: None,
            nodeUpgrade: None,
            copper: None,
            wrath: None,
            candle: None,
            sky: None,
        }
    }
}
impl clz_Torappu_RoguelikeModuleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeModule<'b>> {
        let moduleTypes = self.moduleTypes.as_ref().map(|x| _fbb.create_vector(x));
        let sanCheck = self.sanCheck.as_ref().map(|x| x.pack(_fbb));
        let dice = self.dice.as_ref().map(|x| x.pack(_fbb));
        let chaos = self.chaos.as_ref().map(|x| x.pack(_fbb));
        let totemBuff = self.totemBuff.as_ref().map(|x| x.pack(_fbb));
        let vision = self.vision.as_ref().map(|x| x.pack(_fbb));
        let fragment = self.fragment.as_ref().map(|x| x.pack(_fbb));
        let disaster = self.disaster.as_ref().map(|x| x.pack(_fbb));
        let nodeUpgrade = self.nodeUpgrade.as_ref().map(|x| x.pack(_fbb));
        let copper = self.copper.as_ref().map(|x| x.pack(_fbb));
        let wrath = self.wrath.as_ref().map(|x| x.pack(_fbb));
        let candle = self.candle.as_ref().map(|x| x.pack(_fbb));
        let sky = self.sky.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeModule::create(
            _fbb,
            &clz_Torappu_RoguelikeModuleArgs {
                moduleTypes,
                sanCheck,
                dice,
                chaos,
                totemBuff,
                vision,
                fragment,
                disaster,
                nodeUpgrade,
                copper,
                wrath,
                candle,
                sky,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeModuleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeModule<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeModule<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeModule<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeModule<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeModule { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeModuleArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeModule<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeModuleBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeModuleT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeModuleT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeModule::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_RoguelikeModule) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeModule<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeModule>>(
                    dict__string__clz_Torappu_RoguelikeModule::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeModule<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeModule>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeModuleArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeModule<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeModuleArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeModuleArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeModule<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeModule", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeModuleBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeModuleBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeModule::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeModule<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeModule>>(
                dict__string__clz_Torappu_RoguelikeModule::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeModuleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeModuleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeModule<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_RoguelikeModule::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeModule<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeModule");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeModuleT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeModuleT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeModuleT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeModuleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeModule<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeModule::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeModuleArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicDisplayItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicDisplayItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicDisplayItem<'a> {
    type Inner = clz_Torappu_RoguelikeTopicDisplayItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicDisplayItem<'a> {
    pub const VT_DISPLAYTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_DISPLAYNUM: flatbuffers::VOffsetT = 6;
    pub const VT_DISPLAYFORM: flatbuffers::VOffsetT = 8;
    pub const VT_TOKENDESC: flatbuffers::VOffsetT = 10;
    pub const VT_SORTID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicDisplayItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicDisplayItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDisplayItem<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicDisplayItemBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.tokenDesc {
            builder.add_tokenDesc(x);
        }
        builder.add_displayForm(args.displayForm);
        builder.add_displayNum(args.displayNum);
        if let Some(x) = args.displayType {
            builder.add_displayType(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicDisplayItemT {
        let displayType = self.displayType().map(|x| x.to_string());
        let displayNum = self.displayNum();
        let displayForm = self.displayForm();
        let tokenDesc = self.tokenDesc().map(|x| x.to_string());
        let sortId = self.sortId();
        clz_Torappu_RoguelikeTopicDisplayItemT {
            displayType,
            displayNum,
            displayForm,
            tokenDesc,
            sortId,
        }
    }

    #[inline]
    pub fn displayType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDisplayItem::VT_DISPLAYTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn displayNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeTopicDisplayItem::VT_DISPLAYNUM,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn displayForm(&self) -> enum__Torappu_RoguelikeTopicDevTokenDisplayForm {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTopicDevTokenDisplayForm>(
                    clz_Torappu_RoguelikeTopicDisplayItem::VT_DISPLAYFORM,
                    Some(enum__Torappu_RoguelikeTopicDevTokenDisplayForm::ABSOLUTE_VAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn tokenDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDisplayItem::VT_TOKENDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicDisplayItem::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicDisplayItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "displayType",
                Self::VT_DISPLAYTYPE,
                false,
            )?
            .visit_field::<i32>("displayNum", Self::VT_DISPLAYNUM, false)?
            .visit_field::<enum__Torappu_RoguelikeTopicDevTokenDisplayForm>(
                "displayForm",
                Self::VT_DISPLAYFORM,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tokenDesc",
                Self::VT_TOKENDESC,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicDisplayItemArgs<'a> {
    pub displayType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub displayNum: i32,
    pub displayForm: enum__Torappu_RoguelikeTopicDevTokenDisplayForm,
    pub tokenDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicDisplayItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicDisplayItemArgs {
            displayType: None,
            displayNum: 0,
            displayForm: enum__Torappu_RoguelikeTopicDevTokenDisplayForm::ABSOLUTE_VAL,
            tokenDesc: None,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicDisplayItem<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicDisplayItem", 5)?;
        if let Some(f) = self.displayType() {
            s.serialize_field("displayType", &f)?;
        } else {
            s.skip_field("displayType")?;
        }
        s.serialize_field("displayNum", &self.displayNum())?;
        s.serialize_field("displayForm", &self.displayForm())?;
        if let Some(f) = self.tokenDesc() {
            s.serialize_field("tokenDesc", &f)?;
        } else {
            s.skip_field("tokenDesc")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicDisplayItemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicDisplayItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_displayType(&mut self, displayType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDisplayItem::VT_DISPLAYTYPE,
            displayType,
        );
    }
    #[inline]
    pub fn add_displayNum(&mut self, displayNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeTopicDisplayItem::VT_DISPLAYNUM,
            displayNum,
            0,
        );
    }
    #[inline]
    pub fn add_displayForm(
        &mut self,
        displayForm: enum__Torappu_RoguelikeTopicDevTokenDisplayForm,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeTopicDevTokenDisplayForm>(
                clz_Torappu_RoguelikeTopicDisplayItem::VT_DISPLAYFORM,
                displayForm,
                enum__Torappu_RoguelikeTopicDevTokenDisplayForm::ABSOLUTE_VAL,
            );
    }
    #[inline]
    pub fn add_tokenDesc(&mut self, tokenDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDisplayItem::VT_TOKENDESC,
            tokenDesc,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeTopicDisplayItem::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicDisplayItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicDisplayItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDisplayItem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicDisplayItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicDisplayItem");
        ds.field("displayType", &self.displayType());
        ds.field("displayNum", &self.displayNum());
        ds.field("displayForm", &self.displayForm());
        ds.field("tokenDesc", &self.tokenDesc());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicDisplayItemT {
    pub displayType: Option<String>,
    pub displayNum: i32,
    pub displayForm: enum__Torappu_RoguelikeTopicDevTokenDisplayForm,
    pub tokenDesc: Option<String>,
    pub sortId: i32,
}
impl Default for clz_Torappu_RoguelikeTopicDisplayItemT {
    fn default() -> Self {
        Self {
            displayType: None,
            displayNum: 0,
            displayForm: enum__Torappu_RoguelikeTopicDevTokenDisplayForm::ABSOLUTE_VAL,
            tokenDesc: None,
            sortId: 0,
        }
    }
}
impl clz_Torappu_RoguelikeTopicDisplayItemT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDisplayItem<'b>> {
        let displayType = self.displayType.as_ref().map(|x| _fbb.create_string(x));
        let displayNum = self.displayNum;
        let displayForm = self.displayForm;
        let tokenDesc = self.tokenDesc.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        clz_Torappu_RoguelikeTopicDisplayItem::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicDisplayItemArgs {
                displayType,
                displayNum,
                displayForm,
                tokenDesc,
                sortId,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicDevOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicDev<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicDev<'a> {
    type Inner = clz_Torappu_RoguelikeTopicDev<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicDev<'a> {
    pub const VT_BUFFID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_NODETYPE: flatbuffers::VOffsetT = 8;
    pub const VT_NEXTNODEID: flatbuffers::VOffsetT = 10;
    pub const VT_FRONTNODEID: flatbuffers::VOffsetT = 12;
    pub const VT_TOKENCOST: flatbuffers::VOffsetT = 14;
    pub const VT_BUFFNAME: flatbuffers::VOffsetT = 16;
    pub const VT_BUFFICONID: flatbuffers::VOffsetT = 18;
    pub const VT_BUFFTYPENAME: flatbuffers::VOffsetT = 20;
    pub const VT_BUFFDISPLAYINFO: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicDev { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicDevArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDev<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicDevBuilder::new(_fbb);
        if let Some(x) = args.buffDisplayInfo {
            builder.add_buffDisplayInfo(x);
        }
        if let Some(x) = args.buffTypeName {
            builder.add_buffTypeName(x);
        }
        if let Some(x) = args.buffIconId {
            builder.add_buffIconId(x);
        }
        if let Some(x) = args.buffName {
            builder.add_buffName(x);
        }
        builder.add_tokenCost(args.tokenCost);
        if let Some(x) = args.frontNodeId {
            builder.add_frontNodeId(x);
        }
        if let Some(x) = args.nextNodeId {
            builder.add_nextNodeId(x);
        }
        builder.add_nodeType(args.nodeType);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicDevT {
        let buffId = self.buffId().map(|x| x.to_string());
        let sortId = self.sortId();
        let nodeType = self.nodeType();
        let nextNodeId = self
            .nextNodeId()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let frontNodeId = self
            .frontNodeId()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let tokenCost = self.tokenCost();
        let buffName = self.buffName().map(|x| x.to_string());
        let buffIconId = self.buffIconId().map(|x| x.to_string());
        let buffTypeName = self.buffTypeName().map(|x| x.to_string());
        let buffDisplayInfo = self
            .buffDisplayInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeTopicDevT {
            buffId,
            sortId,
            nodeType,
            nextNodeId,
            frontNodeId,
            tokenCost,
            buffName,
            buffIconId,
            buffTypeName,
            buffDisplayInfo,
        }
    }

    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDev::VT_BUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicDev::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn nodeType(&self) -> enum__Torappu_RoguelikeTopicDevNodeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTopicDevNodeType>(
                    clz_Torappu_RoguelikeTopicDev::VT_NODETYPE,
                    Some(enum__Torappu_RoguelikeTopicDevNodeType::BRANCH),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn nextNodeId(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RoguelikeTopicDev::VT_NEXTNODEID, None)
        }
    }
    #[inline]
    pub fn frontNodeId(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RoguelikeTopicDev::VT_FRONTNODEID, None)
        }
    }
    #[inline]
    pub fn tokenCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicDev::VT_TOKENCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn buffName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDev::VT_BUFFNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn buffIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDev::VT_BUFFICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn buffTypeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDev::VT_BUFFTYPENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn buffDisplayInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem>,
                >,
            >>(clz_Torappu_RoguelikeTopicDev::VT_BUFFDISPLAYINFO, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicDev<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<enum__Torappu_RoguelikeTopicDevNodeType>(
                "nodeType",
                Self::VT_NODETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("nextNodeId", Self::VT_NEXTNODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("frontNodeId", Self::VT_FRONTNODEID, false)?
            .visit_field::<i32>("tokenCost", Self::VT_TOKENCOST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffName",
                Self::VT_BUFFNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffIconId",
                Self::VT_BUFFICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffTypeName",
                Self::VT_BUFFTYPENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem>,
                >,
            >>("buffDisplayInfo", Self::VT_BUFFDISPLAYINFO, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicDevArgs<'a> {
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub nodeType: enum__Torappu_RoguelikeTopicDevNodeType,
    pub nextNodeId: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub frontNodeId: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub tokenCost: i32,
    pub buffName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffTypeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffDisplayInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicDevArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicDevArgs {
            buffId: None,
            sortId: 0,
            nodeType: enum__Torappu_RoguelikeTopicDevNodeType::BRANCH,
            nextNodeId: None,
            frontNodeId: None,
            tokenCost: 0,
            buffName: None,
            buffIconId: None,
            buffTypeName: None,
            buffDisplayInfo: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicDev<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicDev", 10)?;
        if let Some(f) = self.buffId() {
            s.serialize_field("buffId", &f)?;
        } else {
            s.skip_field("buffId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("nodeType", &self.nodeType())?;
        if let Some(f) = self.nextNodeId() {
            s.serialize_field("nextNodeId", &f)?;
        } else {
            s.skip_field("nextNodeId")?;
        }
        if let Some(f) = self.frontNodeId() {
            s.serialize_field("frontNodeId", &f)?;
        } else {
            s.skip_field("frontNodeId")?;
        }
        s.serialize_field("tokenCost", &self.tokenCost())?;
        if let Some(f) = self.buffName() {
            s.serialize_field("buffName", &f)?;
        } else {
            s.skip_field("buffName")?;
        }
        if let Some(f) = self.buffIconId() {
            s.serialize_field("buffIconId", &f)?;
        } else {
            s.skip_field("buffIconId")?;
        }
        if let Some(f) = self.buffTypeName() {
            s.serialize_field("buffTypeName", &f)?;
        } else {
            s.skip_field("buffTypeName")?;
        }
        if let Some(f) = self.buffDisplayInfo() {
            s.serialize_field("buffDisplayInfo", &f)?;
        } else {
            s.skip_field("buffDisplayInfo")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicDevBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RoguelikeTopicDevBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDev::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeTopicDev::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_nodeType(&mut self, nodeType: enum__Torappu_RoguelikeTopicDevNodeType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeTopicDevNodeType>(
                clz_Torappu_RoguelikeTopicDev::VT_NODETYPE,
                nodeType,
                enum__Torappu_RoguelikeTopicDevNodeType::BRANCH,
            );
    }
    #[inline]
    pub fn add_nextNodeId(
        &mut self,
        nextNodeId: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDev::VT_NEXTNODEID,
            nextNodeId,
        );
    }
    #[inline]
    pub fn add_frontNodeId(
        &mut self,
        frontNodeId: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDev::VT_FRONTNODEID,
            frontNodeId,
        );
    }
    #[inline]
    pub fn add_tokenCost(&mut self, tokenCost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeTopicDev::VT_TOKENCOST, tokenCost, 0);
    }
    #[inline]
    pub fn add_buffName(&mut self, buffName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDev::VT_BUFFNAME,
            buffName,
        );
    }
    #[inline]
    pub fn add_buffIconId(&mut self, buffIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDev::VT_BUFFICONID,
            buffIconId,
        );
    }
    #[inline]
    pub fn add_buffTypeName(&mut self, buffTypeName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDev::VT_BUFFTYPENAME,
            buffTypeName,
        );
    }
    #[inline]
    pub fn add_buffDisplayInfo(
        &mut self,
        buffDisplayInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDev::VT_BUFFDISPLAYINFO,
            buffDisplayInfo,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicDevBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicDevBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDev<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicDev<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicDev");
        ds.field("buffId", &self.buffId());
        ds.field("sortId", &self.sortId());
        ds.field("nodeType", &self.nodeType());
        ds.field("nextNodeId", &self.nextNodeId());
        ds.field("frontNodeId", &self.frontNodeId());
        ds.field("tokenCost", &self.tokenCost());
        ds.field("buffName", &self.buffName());
        ds.field("buffIconId", &self.buffIconId());
        ds.field("buffTypeName", &self.buffTypeName());
        ds.field("buffDisplayInfo", &self.buffDisplayInfo());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicDevT {
    pub buffId: Option<String>,
    pub sortId: i32,
    pub nodeType: enum__Torappu_RoguelikeTopicDevNodeType,
    pub nextNodeId: Option<Vec<String>>,
    pub frontNodeId: Option<Vec<String>>,
    pub tokenCost: i32,
    pub buffName: Option<String>,
    pub buffIconId: Option<String>,
    pub buffTypeName: Option<String>,
    pub buffDisplayInfo: Option<Vec<clz_Torappu_RoguelikeTopicDisplayItemT>>,
}
impl Default for clz_Torappu_RoguelikeTopicDevT {
    fn default() -> Self {
        Self {
            buffId: None,
            sortId: 0,
            nodeType: enum__Torappu_RoguelikeTopicDevNodeType::BRANCH,
            nextNodeId: None,
            frontNodeId: None,
            tokenCost: 0,
            buffName: None,
            buffIconId: None,
            buffTypeName: None,
            buffDisplayInfo: None,
        }
    }
}
impl clz_Torappu_RoguelikeTopicDevT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDev<'b>> {
        let buffId = self.buffId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let nodeType = self.nodeType;
        let nextNodeId = self.nextNodeId.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let frontNodeId = self.frontNodeId.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let tokenCost = self.tokenCost;
        let buffName = self.buffName.as_ref().map(|x| _fbb.create_string(x));
        let buffIconId = self.buffIconId.as_ref().map(|x| _fbb.create_string(x));
        let buffTypeName = self.buffTypeName.as_ref().map(|x| _fbb.create_string(x));
        let buffDisplayInfo = self.buffDisplayInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RoguelikeTopicDev::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicDevArgs {
                buffId,
                sortId,
                nodeType,
                nextNodeId,
                frontNodeId,
                tokenCost,
                buffName,
                buffIconId,
                buffTypeName,
                buffDisplayInfo,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeTopicDevOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeTopicDev<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeTopicDev<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeTopicDev<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeTopicDev<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeTopicDev { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeTopicDevArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicDev<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeTopicDevBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeTopicDevT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeTopicDevT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeTopicDev::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_RoguelikeTopicDev) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeTopicDev<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDev>>(
                    dict__string__clz_Torappu_RoguelikeTopicDev::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeTopicDev<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDev>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeTopicDevArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDev<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeTopicDevArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeTopicDevArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeTopicDev<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeTopicDev", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeTopicDevBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeTopicDevBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeTopicDev::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDev<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDev>>(
                dict__string__clz_Torappu_RoguelikeTopicDev::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeTopicDevBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeTopicDevBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicDev<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeTopicDev::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeTopicDev<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeTopicDev");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeTopicDevT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeTopicDevT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeTopicDevT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeTopicDevT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicDev<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeTopicDev::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeTopicDevArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicDevTokenOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicDevToken<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicDevToken<'a> {
    type Inner = clz_Torappu_RoguelikeTopicDevToken<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicDevToken<'a> {
    pub const VT_SORTID: flatbuffers::VOffsetT = 4;
    pub const VT_DISPLAYFORM: flatbuffers::VOffsetT = 6;
    pub const VT_TOKENDESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicDevToken { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicDevTokenArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDevToken<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicDevTokenBuilder::new(_fbb);
        if let Some(x) = args.tokenDesc {
            builder.add_tokenDesc(x);
        }
        builder.add_displayForm(args.displayForm);
        builder.add_sortId(args.sortId);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicDevTokenT {
        let sortId = self.sortId();
        let displayForm = self.displayForm();
        let tokenDesc = self.tokenDesc().map(|x| x.to_string());
        clz_Torappu_RoguelikeTopicDevTokenT {
            sortId,
            displayForm,
            tokenDesc,
        }
    }

    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RoguelikeTopicDevToken::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn displayForm(&self) -> enum__Torappu_RoguelikeTopicDevTokenDisplayForm {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTopicDevTokenDisplayForm>(
                    clz_Torappu_RoguelikeTopicDevToken::VT_DISPLAYFORM,
                    Some(enum__Torappu_RoguelikeTopicDevTokenDisplayForm::ABSOLUTE_VAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn tokenDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeTopicDevToken::VT_TOKENDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicDevToken<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<enum__Torappu_RoguelikeTopicDevTokenDisplayForm>(
                "displayForm",
                Self::VT_DISPLAYFORM,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "tokenDesc",
                Self::VT_TOKENDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicDevTokenArgs<'a> {
    pub sortId: i32,
    pub displayForm: enum__Torappu_RoguelikeTopicDevTokenDisplayForm,
    pub tokenDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicDevTokenArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicDevTokenArgs {
            sortId: 0,
            displayForm: enum__Torappu_RoguelikeTopicDevTokenDisplayForm::ABSOLUTE_VAL,
            tokenDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicDevToken<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicDevToken", 3)?;
        s.serialize_field("sortId", &self.sortId())?;
        s.serialize_field("displayForm", &self.displayForm())?;
        if let Some(f) = self.tokenDesc() {
            s.serialize_field("tokenDesc", &f)?;
        } else {
            s.skip_field("tokenDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicDevTokenBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicDevTokenBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RoguelikeTopicDevToken::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_displayForm(
        &mut self,
        displayForm: enum__Torappu_RoguelikeTopicDevTokenDisplayForm,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeTopicDevTokenDisplayForm>(
                clz_Torappu_RoguelikeTopicDevToken::VT_DISPLAYFORM,
                displayForm,
                enum__Torappu_RoguelikeTopicDevTokenDisplayForm::ABSOLUTE_VAL,
            );
    }
    #[inline]
    pub fn add_tokenDesc(&mut self, tokenDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicDevToken::VT_TOKENDESC,
            tokenDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicDevTokenBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicDevTokenBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDevToken<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicDevToken<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicDevToken");
        ds.field("sortId", &self.sortId());
        ds.field("displayForm", &self.displayForm());
        ds.field("tokenDesc", &self.tokenDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicDevTokenT {
    pub sortId: i32,
    pub displayForm: enum__Torappu_RoguelikeTopicDevTokenDisplayForm,
    pub tokenDesc: Option<String>,
}
impl Default for clz_Torappu_RoguelikeTopicDevTokenT {
    fn default() -> Self {
        Self {
            sortId: 0,
            displayForm: enum__Torappu_RoguelikeTopicDevTokenDisplayForm::ABSOLUTE_VAL,
            tokenDesc: None,
        }
    }
}
impl clz_Torappu_RoguelikeTopicDevTokenT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDevToken<'b>> {
        let sortId = self.sortId;
        let displayForm = self.displayForm;
        let tokenDesc = self.tokenDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeTopicDevToken::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicDevTokenArgs {
                sortId,
                displayForm,
                tokenDesc,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeTopicDevTokenOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeTopicDevToken<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeTopicDevToken<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeTopicDevToken<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeTopicDevToken<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeTopicDevToken { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeTopicDevTokenArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeTopicDevTokenBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeTopicDevTokenT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeTopicDevTokenT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeTopicDevToken::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeTopicDevToken,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeTopicDevToken<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDevToken>>(
                    dict__string__clz_Torappu_RoguelikeTopicDevToken::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeTopicDevToken<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDevToken>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeTopicDevTokenArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDevToken<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeTopicDevTokenArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeTopicDevTokenArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeTopicDevToken<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RoguelikeTopicDevToken", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeTopicDevTokenBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeTopicDevTokenBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeTopicDevToken::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDevToken<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicDevToken>>(
                dict__string__clz_Torappu_RoguelikeTopicDevToken::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeTopicDevTokenBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeTopicDevTokenBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeTopicDevToken::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeTopicDevToken<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeTopicDevToken");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeTopicDevTokenT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeTopicDevTokenT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeTopicDevTokenT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeTopicDevTokenT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeTopicDevToken::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeTopicDevTokenArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RL01EndingTextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL01EndingText<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL01EndingText<'a> {
    type Inner = clz_Torappu_RL01EndingText<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL01EndingText<'a> {
    pub const VT_SUMMARYVARIATION: flatbuffers::VOffsetT = 4;
    pub const VT_SUMMARYFUSION: flatbuffers::VOffsetT = 6;
    pub const VT_SUMMARYCAPSULE: flatbuffers::VOffsetT = 8;
    pub const VT_SUMMARYACTOR: flatbuffers::VOffsetT = 10;
    pub const VT_SUMMARYTOP: flatbuffers::VOffsetT = 12;
    pub const VT_SUMMARYZONE: flatbuffers::VOffsetT = 14;
    pub const VT_SUMMARYENDING: flatbuffers::VOffsetT = 16;
    pub const VT_SUMMARYDIFFICULTYZONE: flatbuffers::VOffsetT = 18;
    pub const VT_SUMMARYDIFFICULTYENDING: flatbuffers::VOffsetT = 20;
    pub const VT_SUMMARYMODE: flatbuffers::VOffsetT = 22;
    pub const VT_SUMMARYGROUP: flatbuffers::VOffsetT = 24;
    pub const VT_SUMMARYSUPPORT: flatbuffers::VOffsetT = 26;
    pub const VT_SUMMARYNORMALRECRUIT: flatbuffers::VOffsetT = 28;
    pub const VT_SUMMARYDIRECTRECRUIT: flatbuffers::VOffsetT = 30;
    pub const VT_SUMMARYFRIENDRECRUIT: flatbuffers::VOffsetT = 32;
    pub const VT_SUMMARYFREERECRUIT: flatbuffers::VOffsetT = 34;
    pub const VT_SUMMARYMONTHRECRUIT: flatbuffers::VOffsetT = 36;
    pub const VT_SUMMARYUPGRADE: flatbuffers::VOffsetT = 38;
    pub const VT_SUMMARYCOMPLETEENDING: flatbuffers::VOffsetT = 40;
    pub const VT_SUMMARYEACHZONE: flatbuffers::VOffsetT = 42;
    pub const VT_SUMMARYMEETSPZONE: flatbuffers::VOffsetT = 44;
    pub const VT_SUMMARYPERFECTBATTLE: flatbuffers::VOffsetT = 46;
    pub const VT_SUMMARYMEETBATTLE: flatbuffers::VOffsetT = 48;
    pub const VT_SUMMARYMEETEVENT: flatbuffers::VOffsetT = 50;
    pub const VT_SUMMARYMEETSHOP: flatbuffers::VOffsetT = 52;
    pub const VT_SUMMARYMEETTREASURE: flatbuffers::VOffsetT = 54;
    pub const VT_SUMMARYMEETSECRETPATH: flatbuffers::VOffsetT = 56;
    pub const VT_SUMMARYEXCHANGERELIC: flatbuffers::VOffsetT = 58;
    pub const VT_SUMMARYMEETTRADE: flatbuffers::VOffsetT = 60;
    pub const VT_SUMMARYBUY: flatbuffers::VOffsetT = 62;
    pub const VT_SUMMARYBUYWITHPRICEID: flatbuffers::VOffsetT = 64;
    pub const VT_SUMMARYINVEST: flatbuffers::VOffsetT = 66;
    pub const VT_SUMMARYGET: flatbuffers::VOffsetT = 68;
    pub const VT_SUMMARYRELIC: flatbuffers::VOffsetT = 70;
    pub const VT_SUMMARYSAFEHOUSE: flatbuffers::VOffsetT = 72;
    pub const VT_SUMMARYFAILEND: flatbuffers::VOffsetT = 74;
    pub const VT_SUMMARYSTOCKRECRUITTICKET: flatbuffers::VOffsetT = 76;
    pub const VT_SUMMARYDUELWIN: flatbuffers::VOffsetT = 78;
    pub const VT_SUMMARYDUELTIE: flatbuffers::VOffsetT = 80;
    pub const VT_SUMMARYDUELLOSE: flatbuffers::VOffsetT = 82;
    pub const VT_SUMMARYEXPEDITIONGO: flatbuffers::VOffsetT = 84;
    pub const VT_SUMMARYEXPEDITIONBACK: flatbuffers::VOffsetT = 86;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL01EndingText { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL01EndingTextArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL01EndingText<'bldr>> {
        let mut builder = clz_Torappu_RL01EndingTextBuilder::new(_fbb);
        if let Some(x) = args.summaryExpeditionBack {
            builder.add_summaryExpeditionBack(x);
        }
        if let Some(x) = args.summaryExpeditionGo {
            builder.add_summaryExpeditionGo(x);
        }
        if let Some(x) = args.summaryDuelLose {
            builder.add_summaryDuelLose(x);
        }
        if let Some(x) = args.summaryDuelTie {
            builder.add_summaryDuelTie(x);
        }
        if let Some(x) = args.summaryDuelWin {
            builder.add_summaryDuelWin(x);
        }
        if let Some(x) = args.summaryStockRecruitTicket {
            builder.add_summaryStockRecruitTicket(x);
        }
        if let Some(x) = args.summaryFailEnd {
            builder.add_summaryFailEnd(x);
        }
        if let Some(x) = args.summarySafeHouse {
            builder.add_summarySafeHouse(x);
        }
        if let Some(x) = args.summaryRelic {
            builder.add_summaryRelic(x);
        }
        if let Some(x) = args.summaryGet {
            builder.add_summaryGet(x);
        }
        if let Some(x) = args.summaryInvest {
            builder.add_summaryInvest(x);
        }
        if let Some(x) = args.summaryBuyWithPriceId {
            builder.add_summaryBuyWithPriceId(x);
        }
        if let Some(x) = args.summaryBuy {
            builder.add_summaryBuy(x);
        }
        if let Some(x) = args.summaryMeetTrade {
            builder.add_summaryMeetTrade(x);
        }
        if let Some(x) = args.summaryExchangeRelic {
            builder.add_summaryExchangeRelic(x);
        }
        if let Some(x) = args.summaryMeetSecretpath {
            builder.add_summaryMeetSecretpath(x);
        }
        if let Some(x) = args.summaryMeetTreasure {
            builder.add_summaryMeetTreasure(x);
        }
        if let Some(x) = args.summaryMeetShop {
            builder.add_summaryMeetShop(x);
        }
        if let Some(x) = args.summaryMeetEvent {
            builder.add_summaryMeetEvent(x);
        }
        if let Some(x) = args.summaryMeetBattle {
            builder.add_summaryMeetBattle(x);
        }
        if let Some(x) = args.summaryPerfectBattle {
            builder.add_summaryPerfectBattle(x);
        }
        if let Some(x) = args.summaryMeetSpZone {
            builder.add_summaryMeetSpZone(x);
        }
        if let Some(x) = args.summaryEachZone {
            builder.add_summaryEachZone(x);
        }
        if let Some(x) = args.summaryCompleteEnding {
            builder.add_summaryCompleteEnding(x);
        }
        if let Some(x) = args.summaryUpgrade {
            builder.add_summaryUpgrade(x);
        }
        if let Some(x) = args.summaryMonthRecruit {
            builder.add_summaryMonthRecruit(x);
        }
        if let Some(x) = args.summaryFreeRecruit {
            builder.add_summaryFreeRecruit(x);
        }
        if let Some(x) = args.summaryFriendRecruit {
            builder.add_summaryFriendRecruit(x);
        }
        if let Some(x) = args.summaryDirectRecruit {
            builder.add_summaryDirectRecruit(x);
        }
        if let Some(x) = args.summaryNormalRecruit {
            builder.add_summaryNormalRecruit(x);
        }
        if let Some(x) = args.summarySupport {
            builder.add_summarySupport(x);
        }
        if let Some(x) = args.summaryGroup {
            builder.add_summaryGroup(x);
        }
        if let Some(x) = args.summaryMode {
            builder.add_summaryMode(x);
        }
        if let Some(x) = args.summaryDifficultyEnding {
            builder.add_summaryDifficultyEnding(x);
        }
        if let Some(x) = args.summaryDifficultyZone {
            builder.add_summaryDifficultyZone(x);
        }
        if let Some(x) = args.summaryEnding {
            builder.add_summaryEnding(x);
        }
        if let Some(x) = args.summaryZone {
            builder.add_summaryZone(x);
        }
        if let Some(x) = args.summaryTop {
            builder.add_summaryTop(x);
        }
        if let Some(x) = args.summaryActor {
            builder.add_summaryActor(x);
        }
        if let Some(x) = args.summaryCapsule {
            builder.add_summaryCapsule(x);
        }
        if let Some(x) = args.summaryFusion {
            builder.add_summaryFusion(x);
        }
        if let Some(x) = args.summaryVariation {
            builder.add_summaryVariation(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL01EndingTextT {
        let summaryVariation = self.summaryVariation().map(|x| x.to_string());
        let summaryFusion = self.summaryFusion().map(|x| x.to_string());
        let summaryCapsule = self.summaryCapsule().map(|x| x.to_string());
        let summaryActor = self.summaryActor().map(|x| x.to_string());
        let summaryTop = self.summaryTop().map(|x| x.to_string());
        let summaryZone = self.summaryZone().map(|x| x.to_string());
        let summaryEnding = self.summaryEnding().map(|x| x.to_string());
        let summaryDifficultyZone = self.summaryDifficultyZone().map(|x| x.to_string());
        let summaryDifficultyEnding = self.summaryDifficultyEnding().map(|x| x.to_string());
        let summaryMode = self.summaryMode().map(|x| x.to_string());
        let summaryGroup = self.summaryGroup().map(|x| x.to_string());
        let summarySupport = self.summarySupport().map(|x| x.to_string());
        let summaryNormalRecruit = self.summaryNormalRecruit().map(|x| x.to_string());
        let summaryDirectRecruit = self.summaryDirectRecruit().map(|x| x.to_string());
        let summaryFriendRecruit = self.summaryFriendRecruit().map(|x| x.to_string());
        let summaryFreeRecruit = self.summaryFreeRecruit().map(|x| x.to_string());
        let summaryMonthRecruit = self.summaryMonthRecruit().map(|x| x.to_string());
        let summaryUpgrade = self.summaryUpgrade().map(|x| x.to_string());
        let summaryCompleteEnding = self.summaryCompleteEnding().map(|x| x.to_string());
        let summaryEachZone = self.summaryEachZone().map(|x| x.to_string());
        let summaryMeetSpZone = self.summaryMeetSpZone().map(|x| x.to_string());
        let summaryPerfectBattle = self.summaryPerfectBattle().map(|x| x.to_string());
        let summaryMeetBattle = self.summaryMeetBattle().map(|x| x.to_string());
        let summaryMeetEvent = self.summaryMeetEvent().map(|x| x.to_string());
        let summaryMeetShop = self.summaryMeetShop().map(|x| x.to_string());
        let summaryMeetTreasure = self.summaryMeetTreasure().map(|x| x.to_string());
        let summaryMeetSecretpath = self.summaryMeetSecretpath().map(|x| x.to_string());
        let summaryExchangeRelic = self.summaryExchangeRelic().map(|x| x.to_string());
        let summaryMeetTrade = self.summaryMeetTrade().map(|x| x.to_string());
        let summaryBuy = self.summaryBuy().map(|x| x.to_string());
        let summaryBuyWithPriceId = self.summaryBuyWithPriceId().map(|x| x.to_string());
        let summaryInvest = self.summaryInvest().map(|x| x.to_string());
        let summaryGet = self.summaryGet().map(|x| x.to_string());
        let summaryRelic = self.summaryRelic().map(|x| x.to_string());
        let summarySafeHouse = self.summarySafeHouse().map(|x| x.to_string());
        let summaryFailEnd = self.summaryFailEnd().map(|x| x.to_string());
        let summaryStockRecruitTicket = self.summaryStockRecruitTicket().map(|x| x.to_string());
        let summaryDuelWin = self.summaryDuelWin().map(|x| x.to_string());
        let summaryDuelTie = self.summaryDuelTie().map(|x| x.to_string());
        let summaryDuelLose = self.summaryDuelLose().map(|x| x.to_string());
        let summaryExpeditionGo = self.summaryExpeditionGo().map(|x| x.to_string());
        let summaryExpeditionBack = self.summaryExpeditionBack().map(|x| x.to_string());
        clz_Torappu_RL01EndingTextT {
            summaryVariation,
            summaryFusion,
            summaryCapsule,
            summaryActor,
            summaryTop,
            summaryZone,
            summaryEnding,
            summaryDifficultyZone,
            summaryDifficultyEnding,
            summaryMode,
            summaryGroup,
            summarySupport,
            summaryNormalRecruit,
            summaryDirectRecruit,
            summaryFriendRecruit,
            summaryFreeRecruit,
            summaryMonthRecruit,
            summaryUpgrade,
            summaryCompleteEnding,
            summaryEachZone,
            summaryMeetSpZone,
            summaryPerfectBattle,
            summaryMeetBattle,
            summaryMeetEvent,
            summaryMeetShop,
            summaryMeetTreasure,
            summaryMeetSecretpath,
            summaryExchangeRelic,
            summaryMeetTrade,
            summaryBuy,
            summaryBuyWithPriceId,
            summaryInvest,
            summaryGet,
            summaryRelic,
            summarySafeHouse,
            summaryFailEnd,
            summaryStockRecruitTicket,
            summaryDuelWin,
            summaryDuelTie,
            summaryDuelLose,
            summaryExpeditionGo,
            summaryExpeditionBack,
        }
    }

    #[inline]
    pub fn summaryVariation(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYVARIATION,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryFusion(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYFUSION,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryCapsule(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYCAPSULE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryActor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYACTOR,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryTop(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYTOP,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryEnding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYENDING,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDifficultyZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYDIFFICULTYZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDifficultyEnding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYDIFFICULTYENDING,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMode(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYMODE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryGroup(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn summarySupport(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYSUPPORT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryNormalRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYNORMALRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDirectRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYDIRECTRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryFriendRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYFRIENDRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryFreeRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYFREERECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMonthRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYMONTHRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryUpgrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYUPGRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryCompleteEnding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYCOMPLETEENDING,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryEachZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYEACHZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetSpZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYMEETSPZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryPerfectBattle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYPERFECTBATTLE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetBattle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYMEETBATTLE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetEvent(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYMEETEVENT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetShop(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYMEETSHOP,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetTreasure(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYMEETTREASURE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetSecretpath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYMEETSECRETPATH,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExchangeRelic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYEXCHANGERELIC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetTrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYMEETTRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryBuy(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYBUY,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryBuyWithPriceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYBUYWITHPRICEID,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryInvest(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYINVEST,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryGet(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYGET,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryRelic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYRELIC,
                None,
            )
        }
    }
    #[inline]
    pub fn summarySafeHouse(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYSAFEHOUSE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryFailEnd(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYFAILEND,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryStockRecruitTicket(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYSTOCKRECRUITTICKET,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDuelWin(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYDUELWIN,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDuelTie(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYDUELTIE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDuelLose(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYDUELLOSE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExpeditionGo(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYEXPEDITIONGO,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExpeditionBack(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL01EndingText::VT_SUMMARYEXPEDITIONBACK,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL01EndingText<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryVariation",
                Self::VT_SUMMARYVARIATION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryFusion",
                Self::VT_SUMMARYFUSION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryCapsule",
                Self::VT_SUMMARYCAPSULE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryActor",
                Self::VT_SUMMARYACTOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryTop",
                Self::VT_SUMMARYTOP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryZone",
                Self::VT_SUMMARYZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryEnding",
                Self::VT_SUMMARYENDING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDifficultyZone",
                Self::VT_SUMMARYDIFFICULTYZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDifficultyEnding",
                Self::VT_SUMMARYDIFFICULTYENDING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMode",
                Self::VT_SUMMARYMODE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryGroup",
                Self::VT_SUMMARYGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summarySupport",
                Self::VT_SUMMARYSUPPORT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryNormalRecruit",
                Self::VT_SUMMARYNORMALRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDirectRecruit",
                Self::VT_SUMMARYDIRECTRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryFriendRecruit",
                Self::VT_SUMMARYFRIENDRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryFreeRecruit",
                Self::VT_SUMMARYFREERECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMonthRecruit",
                Self::VT_SUMMARYMONTHRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryUpgrade",
                Self::VT_SUMMARYUPGRADE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryCompleteEnding",
                Self::VT_SUMMARYCOMPLETEENDING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryEachZone",
                Self::VT_SUMMARYEACHZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetSpZone",
                Self::VT_SUMMARYMEETSPZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryPerfectBattle",
                Self::VT_SUMMARYPERFECTBATTLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetBattle",
                Self::VT_SUMMARYMEETBATTLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetEvent",
                Self::VT_SUMMARYMEETEVENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetShop",
                Self::VT_SUMMARYMEETSHOP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetTreasure",
                Self::VT_SUMMARYMEETTREASURE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetSecretpath",
                Self::VT_SUMMARYMEETSECRETPATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExchangeRelic",
                Self::VT_SUMMARYEXCHANGERELIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetTrade",
                Self::VT_SUMMARYMEETTRADE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryBuy",
                Self::VT_SUMMARYBUY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryBuyWithPriceId",
                Self::VT_SUMMARYBUYWITHPRICEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryInvest",
                Self::VT_SUMMARYINVEST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryGet",
                Self::VT_SUMMARYGET,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryRelic",
                Self::VT_SUMMARYRELIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summarySafeHouse",
                Self::VT_SUMMARYSAFEHOUSE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryFailEnd",
                Self::VT_SUMMARYFAILEND,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryStockRecruitTicket",
                Self::VT_SUMMARYSTOCKRECRUITTICKET,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDuelWin",
                Self::VT_SUMMARYDUELWIN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDuelTie",
                Self::VT_SUMMARYDUELTIE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDuelLose",
                Self::VT_SUMMARYDUELLOSE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExpeditionGo",
                Self::VT_SUMMARYEXPEDITIONGO,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExpeditionBack",
                Self::VT_SUMMARYEXPEDITIONBACK,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL01EndingTextArgs<'a> {
    pub summaryVariation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryFusion: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryCapsule: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryActor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryTop: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryEnding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDifficultyZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDifficultyEnding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summarySupport: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryNormalRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDirectRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryFriendRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryFreeRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMonthRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryUpgrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryCompleteEnding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryEachZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetSpZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryPerfectBattle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetBattle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetEvent: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetShop: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetTreasure: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetSecretpath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExchangeRelic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetTrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryBuy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryBuyWithPriceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryInvest: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryGet: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryRelic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summarySafeHouse: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryFailEnd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryStockRecruitTicket: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDuelWin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDuelTie: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDuelLose: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExpeditionGo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExpeditionBack: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RL01EndingTextArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL01EndingTextArgs {
            summaryVariation: None,
            summaryFusion: None,
            summaryCapsule: None,
            summaryActor: None,
            summaryTop: None,
            summaryZone: None,
            summaryEnding: None,
            summaryDifficultyZone: None,
            summaryDifficultyEnding: None,
            summaryMode: None,
            summaryGroup: None,
            summarySupport: None,
            summaryNormalRecruit: None,
            summaryDirectRecruit: None,
            summaryFriendRecruit: None,
            summaryFreeRecruit: None,
            summaryMonthRecruit: None,
            summaryUpgrade: None,
            summaryCompleteEnding: None,
            summaryEachZone: None,
            summaryMeetSpZone: None,
            summaryPerfectBattle: None,
            summaryMeetBattle: None,
            summaryMeetEvent: None,
            summaryMeetShop: None,
            summaryMeetTreasure: None,
            summaryMeetSecretpath: None,
            summaryExchangeRelic: None,
            summaryMeetTrade: None,
            summaryBuy: None,
            summaryBuyWithPriceId: None,
            summaryInvest: None,
            summaryGet: None,
            summaryRelic: None,
            summarySafeHouse: None,
            summaryFailEnd: None,
            summaryStockRecruitTicket: None,
            summaryDuelWin: None,
            summaryDuelTie: None,
            summaryDuelLose: None,
            summaryExpeditionGo: None,
            summaryExpeditionBack: None,
        }
    }
}

impl Serialize for clz_Torappu_RL01EndingText<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL01EndingText", 42)?;
        if let Some(f) = self.summaryVariation() {
            s.serialize_field("summaryVariation", &f)?;
        } else {
            s.skip_field("summaryVariation")?;
        }
        if let Some(f) = self.summaryFusion() {
            s.serialize_field("summaryFusion", &f)?;
        } else {
            s.skip_field("summaryFusion")?;
        }
        if let Some(f) = self.summaryCapsule() {
            s.serialize_field("summaryCapsule", &f)?;
        } else {
            s.skip_field("summaryCapsule")?;
        }
        if let Some(f) = self.summaryActor() {
            s.serialize_field("summaryActor", &f)?;
        } else {
            s.skip_field("summaryActor")?;
        }
        if let Some(f) = self.summaryTop() {
            s.serialize_field("summaryTop", &f)?;
        } else {
            s.skip_field("summaryTop")?;
        }
        if let Some(f) = self.summaryZone() {
            s.serialize_field("summaryZone", &f)?;
        } else {
            s.skip_field("summaryZone")?;
        }
        if let Some(f) = self.summaryEnding() {
            s.serialize_field("summaryEnding", &f)?;
        } else {
            s.skip_field("summaryEnding")?;
        }
        if let Some(f) = self.summaryDifficultyZone() {
            s.serialize_field("summaryDifficultyZone", &f)?;
        } else {
            s.skip_field("summaryDifficultyZone")?;
        }
        if let Some(f) = self.summaryDifficultyEnding() {
            s.serialize_field("summaryDifficultyEnding", &f)?;
        } else {
            s.skip_field("summaryDifficultyEnding")?;
        }
        if let Some(f) = self.summaryMode() {
            s.serialize_field("summaryMode", &f)?;
        } else {
            s.skip_field("summaryMode")?;
        }
        if let Some(f) = self.summaryGroup() {
            s.serialize_field("summaryGroup", &f)?;
        } else {
            s.skip_field("summaryGroup")?;
        }
        if let Some(f) = self.summarySupport() {
            s.serialize_field("summarySupport", &f)?;
        } else {
            s.skip_field("summarySupport")?;
        }
        if let Some(f) = self.summaryNormalRecruit() {
            s.serialize_field("summaryNormalRecruit", &f)?;
        } else {
            s.skip_field("summaryNormalRecruit")?;
        }
        if let Some(f) = self.summaryDirectRecruit() {
            s.serialize_field("summaryDirectRecruit", &f)?;
        } else {
            s.skip_field("summaryDirectRecruit")?;
        }
        if let Some(f) = self.summaryFriendRecruit() {
            s.serialize_field("summaryFriendRecruit", &f)?;
        } else {
            s.skip_field("summaryFriendRecruit")?;
        }
        if let Some(f) = self.summaryFreeRecruit() {
            s.serialize_field("summaryFreeRecruit", &f)?;
        } else {
            s.skip_field("summaryFreeRecruit")?;
        }
        if let Some(f) = self.summaryMonthRecruit() {
            s.serialize_field("summaryMonthRecruit", &f)?;
        } else {
            s.skip_field("summaryMonthRecruit")?;
        }
        if let Some(f) = self.summaryUpgrade() {
            s.serialize_field("summaryUpgrade", &f)?;
        } else {
            s.skip_field("summaryUpgrade")?;
        }
        if let Some(f) = self.summaryCompleteEnding() {
            s.serialize_field("summaryCompleteEnding", &f)?;
        } else {
            s.skip_field("summaryCompleteEnding")?;
        }
        if let Some(f) = self.summaryEachZone() {
            s.serialize_field("summaryEachZone", &f)?;
        } else {
            s.skip_field("summaryEachZone")?;
        }
        if let Some(f) = self.summaryMeetSpZone() {
            s.serialize_field("summaryMeetSpZone", &f)?;
        } else {
            s.skip_field("summaryMeetSpZone")?;
        }
        if let Some(f) = self.summaryPerfectBattle() {
            s.serialize_field("summaryPerfectBattle", &f)?;
        } else {
            s.skip_field("summaryPerfectBattle")?;
        }
        if let Some(f) = self.summaryMeetBattle() {
            s.serialize_field("summaryMeetBattle", &f)?;
        } else {
            s.skip_field("summaryMeetBattle")?;
        }
        if let Some(f) = self.summaryMeetEvent() {
            s.serialize_field("summaryMeetEvent", &f)?;
        } else {
            s.skip_field("summaryMeetEvent")?;
        }
        if let Some(f) = self.summaryMeetShop() {
            s.serialize_field("summaryMeetShop", &f)?;
        } else {
            s.skip_field("summaryMeetShop")?;
        }
        if let Some(f) = self.summaryMeetTreasure() {
            s.serialize_field("summaryMeetTreasure", &f)?;
        } else {
            s.skip_field("summaryMeetTreasure")?;
        }
        if let Some(f) = self.summaryMeetSecretpath() {
            s.serialize_field("summaryMeetSecretpath", &f)?;
        } else {
            s.skip_field("summaryMeetSecretpath")?;
        }
        if let Some(f) = self.summaryExchangeRelic() {
            s.serialize_field("summaryExchangeRelic", &f)?;
        } else {
            s.skip_field("summaryExchangeRelic")?;
        }
        if let Some(f) = self.summaryMeetTrade() {
            s.serialize_field("summaryMeetTrade", &f)?;
        } else {
            s.skip_field("summaryMeetTrade")?;
        }
        if let Some(f) = self.summaryBuy() {
            s.serialize_field("summaryBuy", &f)?;
        } else {
            s.skip_field("summaryBuy")?;
        }
        if let Some(f) = self.summaryBuyWithPriceId() {
            s.serialize_field("summaryBuyWithPriceId", &f)?;
        } else {
            s.skip_field("summaryBuyWithPriceId")?;
        }
        if let Some(f) = self.summaryInvest() {
            s.serialize_field("summaryInvest", &f)?;
        } else {
            s.skip_field("summaryInvest")?;
        }
        if let Some(f) = self.summaryGet() {
            s.serialize_field("summaryGet", &f)?;
        } else {
            s.skip_field("summaryGet")?;
        }
        if let Some(f) = self.summaryRelic() {
            s.serialize_field("summaryRelic", &f)?;
        } else {
            s.skip_field("summaryRelic")?;
        }
        if let Some(f) = self.summarySafeHouse() {
            s.serialize_field("summarySafeHouse", &f)?;
        } else {
            s.skip_field("summarySafeHouse")?;
        }
        if let Some(f) = self.summaryFailEnd() {
            s.serialize_field("summaryFailEnd", &f)?;
        } else {
            s.skip_field("summaryFailEnd")?;
        }
        if let Some(f) = self.summaryStockRecruitTicket() {
            s.serialize_field("summaryStockRecruitTicket", &f)?;
        } else {
            s.skip_field("summaryStockRecruitTicket")?;
        }
        if let Some(f) = self.summaryDuelWin() {
            s.serialize_field("summaryDuelWin", &f)?;
        } else {
            s.skip_field("summaryDuelWin")?;
        }
        if let Some(f) = self.summaryDuelTie() {
            s.serialize_field("summaryDuelTie", &f)?;
        } else {
            s.skip_field("summaryDuelTie")?;
        }
        if let Some(f) = self.summaryDuelLose() {
            s.serialize_field("summaryDuelLose", &f)?;
        } else {
            s.skip_field("summaryDuelLose")?;
        }
        if let Some(f) = self.summaryExpeditionGo() {
            s.serialize_field("summaryExpeditionGo", &f)?;
        } else {
            s.skip_field("summaryExpeditionGo")?;
        }
        if let Some(f) = self.summaryExpeditionBack() {
            s.serialize_field("summaryExpeditionBack", &f)?;
        } else {
            s.skip_field("summaryExpeditionBack")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL01EndingTextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL01EndingTextBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_summaryVariation(&mut self, summaryVariation: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYVARIATION,
            summaryVariation,
        );
    }
    #[inline]
    pub fn add_summaryFusion(&mut self, summaryFusion: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYFUSION,
            summaryFusion,
        );
    }
    #[inline]
    pub fn add_summaryCapsule(&mut self, summaryCapsule: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYCAPSULE,
            summaryCapsule,
        );
    }
    #[inline]
    pub fn add_summaryActor(&mut self, summaryActor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYACTOR,
            summaryActor,
        );
    }
    #[inline]
    pub fn add_summaryTop(&mut self, summaryTop: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYTOP,
            summaryTop,
        );
    }
    #[inline]
    pub fn add_summaryZone(&mut self, summaryZone: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYZONE,
            summaryZone,
        );
    }
    #[inline]
    pub fn add_summaryEnding(&mut self, summaryEnding: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYENDING,
            summaryEnding,
        );
    }
    #[inline]
    pub fn add_summaryDifficultyZone(
        &mut self,
        summaryDifficultyZone: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYDIFFICULTYZONE,
            summaryDifficultyZone,
        );
    }
    #[inline]
    pub fn add_summaryDifficultyEnding(
        &mut self,
        summaryDifficultyEnding: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYDIFFICULTYENDING,
            summaryDifficultyEnding,
        );
    }
    #[inline]
    pub fn add_summaryMode(&mut self, summaryMode: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYMODE,
            summaryMode,
        );
    }
    #[inline]
    pub fn add_summaryGroup(&mut self, summaryGroup: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYGROUP,
            summaryGroup,
        );
    }
    #[inline]
    pub fn add_summarySupport(&mut self, summarySupport: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYSUPPORT,
            summarySupport,
        );
    }
    #[inline]
    pub fn add_summaryNormalRecruit(
        &mut self,
        summaryNormalRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYNORMALRECRUIT,
            summaryNormalRecruit,
        );
    }
    #[inline]
    pub fn add_summaryDirectRecruit(
        &mut self,
        summaryDirectRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYDIRECTRECRUIT,
            summaryDirectRecruit,
        );
    }
    #[inline]
    pub fn add_summaryFriendRecruit(
        &mut self,
        summaryFriendRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYFRIENDRECRUIT,
            summaryFriendRecruit,
        );
    }
    #[inline]
    pub fn add_summaryFreeRecruit(&mut self, summaryFreeRecruit: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYFREERECRUIT,
            summaryFreeRecruit,
        );
    }
    #[inline]
    pub fn add_summaryMonthRecruit(
        &mut self,
        summaryMonthRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYMONTHRECRUIT,
            summaryMonthRecruit,
        );
    }
    #[inline]
    pub fn add_summaryUpgrade(&mut self, summaryUpgrade: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYUPGRADE,
            summaryUpgrade,
        );
    }
    #[inline]
    pub fn add_summaryCompleteEnding(
        &mut self,
        summaryCompleteEnding: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYCOMPLETEENDING,
            summaryCompleteEnding,
        );
    }
    #[inline]
    pub fn add_summaryEachZone(&mut self, summaryEachZone: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYEACHZONE,
            summaryEachZone,
        );
    }
    #[inline]
    pub fn add_summaryMeetSpZone(&mut self, summaryMeetSpZone: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYMEETSPZONE,
            summaryMeetSpZone,
        );
    }
    #[inline]
    pub fn add_summaryPerfectBattle(
        &mut self,
        summaryPerfectBattle: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYPERFECTBATTLE,
            summaryPerfectBattle,
        );
    }
    #[inline]
    pub fn add_summaryMeetBattle(&mut self, summaryMeetBattle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYMEETBATTLE,
            summaryMeetBattle,
        );
    }
    #[inline]
    pub fn add_summaryMeetEvent(&mut self, summaryMeetEvent: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYMEETEVENT,
            summaryMeetEvent,
        );
    }
    #[inline]
    pub fn add_summaryMeetShop(&mut self, summaryMeetShop: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYMEETSHOP,
            summaryMeetShop,
        );
    }
    #[inline]
    pub fn add_summaryMeetTreasure(
        &mut self,
        summaryMeetTreasure: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYMEETTREASURE,
            summaryMeetTreasure,
        );
    }
    #[inline]
    pub fn add_summaryMeetSecretpath(
        &mut self,
        summaryMeetSecretpath: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYMEETSECRETPATH,
            summaryMeetSecretpath,
        );
    }
    #[inline]
    pub fn add_summaryExchangeRelic(
        &mut self,
        summaryExchangeRelic: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYEXCHANGERELIC,
            summaryExchangeRelic,
        );
    }
    #[inline]
    pub fn add_summaryMeetTrade(&mut self, summaryMeetTrade: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYMEETTRADE,
            summaryMeetTrade,
        );
    }
    #[inline]
    pub fn add_summaryBuy(&mut self, summaryBuy: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYBUY,
            summaryBuy,
        );
    }
    #[inline]
    pub fn add_summaryBuyWithPriceId(
        &mut self,
        summaryBuyWithPriceId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYBUYWITHPRICEID,
            summaryBuyWithPriceId,
        );
    }
    #[inline]
    pub fn add_summaryInvest(&mut self, summaryInvest: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYINVEST,
            summaryInvest,
        );
    }
    #[inline]
    pub fn add_summaryGet(&mut self, summaryGet: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYGET,
            summaryGet,
        );
    }
    #[inline]
    pub fn add_summaryRelic(&mut self, summaryRelic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYRELIC,
            summaryRelic,
        );
    }
    #[inline]
    pub fn add_summarySafeHouse(&mut self, summarySafeHouse: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYSAFEHOUSE,
            summarySafeHouse,
        );
    }
    #[inline]
    pub fn add_summaryFailEnd(&mut self, summaryFailEnd: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYFAILEND,
            summaryFailEnd,
        );
    }
    #[inline]
    pub fn add_summaryStockRecruitTicket(
        &mut self,
        summaryStockRecruitTicket: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYSTOCKRECRUITTICKET,
            summaryStockRecruitTicket,
        );
    }
    #[inline]
    pub fn add_summaryDuelWin(&mut self, summaryDuelWin: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYDUELWIN,
            summaryDuelWin,
        );
    }
    #[inline]
    pub fn add_summaryDuelTie(&mut self, summaryDuelTie: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYDUELTIE,
            summaryDuelTie,
        );
    }
    #[inline]
    pub fn add_summaryDuelLose(&mut self, summaryDuelLose: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYDUELLOSE,
            summaryDuelLose,
        );
    }
    #[inline]
    pub fn add_summaryExpeditionGo(
        &mut self,
        summaryExpeditionGo: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYEXPEDITIONGO,
            summaryExpeditionGo,
        );
    }
    #[inline]
    pub fn add_summaryExpeditionBack(
        &mut self,
        summaryExpeditionBack: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01EndingText::VT_SUMMARYEXPEDITIONBACK,
            summaryExpeditionBack,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL01EndingTextBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL01EndingTextBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL01EndingText<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL01EndingText<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL01EndingText");
        ds.field("summaryVariation", &self.summaryVariation());
        ds.field("summaryFusion", &self.summaryFusion());
        ds.field("summaryCapsule", &self.summaryCapsule());
        ds.field("summaryActor", &self.summaryActor());
        ds.field("summaryTop", &self.summaryTop());
        ds.field("summaryZone", &self.summaryZone());
        ds.field("summaryEnding", &self.summaryEnding());
        ds.field("summaryDifficultyZone", &self.summaryDifficultyZone());
        ds.field("summaryDifficultyEnding", &self.summaryDifficultyEnding());
        ds.field("summaryMode", &self.summaryMode());
        ds.field("summaryGroup", &self.summaryGroup());
        ds.field("summarySupport", &self.summarySupport());
        ds.field("summaryNormalRecruit", &self.summaryNormalRecruit());
        ds.field("summaryDirectRecruit", &self.summaryDirectRecruit());
        ds.field("summaryFriendRecruit", &self.summaryFriendRecruit());
        ds.field("summaryFreeRecruit", &self.summaryFreeRecruit());
        ds.field("summaryMonthRecruit", &self.summaryMonthRecruit());
        ds.field("summaryUpgrade", &self.summaryUpgrade());
        ds.field("summaryCompleteEnding", &self.summaryCompleteEnding());
        ds.field("summaryEachZone", &self.summaryEachZone());
        ds.field("summaryMeetSpZone", &self.summaryMeetSpZone());
        ds.field("summaryPerfectBattle", &self.summaryPerfectBattle());
        ds.field("summaryMeetBattle", &self.summaryMeetBattle());
        ds.field("summaryMeetEvent", &self.summaryMeetEvent());
        ds.field("summaryMeetShop", &self.summaryMeetShop());
        ds.field("summaryMeetTreasure", &self.summaryMeetTreasure());
        ds.field("summaryMeetSecretpath", &self.summaryMeetSecretpath());
        ds.field("summaryExchangeRelic", &self.summaryExchangeRelic());
        ds.field("summaryMeetTrade", &self.summaryMeetTrade());
        ds.field("summaryBuy", &self.summaryBuy());
        ds.field("summaryBuyWithPriceId", &self.summaryBuyWithPriceId());
        ds.field("summaryInvest", &self.summaryInvest());
        ds.field("summaryGet", &self.summaryGet());
        ds.field("summaryRelic", &self.summaryRelic());
        ds.field("summarySafeHouse", &self.summarySafeHouse());
        ds.field("summaryFailEnd", &self.summaryFailEnd());
        ds.field(
            "summaryStockRecruitTicket",
            &self.summaryStockRecruitTicket(),
        );
        ds.field("summaryDuelWin", &self.summaryDuelWin());
        ds.field("summaryDuelTie", &self.summaryDuelTie());
        ds.field("summaryDuelLose", &self.summaryDuelLose());
        ds.field("summaryExpeditionGo", &self.summaryExpeditionGo());
        ds.field("summaryExpeditionBack", &self.summaryExpeditionBack());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL01EndingTextT {
    pub summaryVariation: Option<String>,
    pub summaryFusion: Option<String>,
    pub summaryCapsule: Option<String>,
    pub summaryActor: Option<String>,
    pub summaryTop: Option<String>,
    pub summaryZone: Option<String>,
    pub summaryEnding: Option<String>,
    pub summaryDifficultyZone: Option<String>,
    pub summaryDifficultyEnding: Option<String>,
    pub summaryMode: Option<String>,
    pub summaryGroup: Option<String>,
    pub summarySupport: Option<String>,
    pub summaryNormalRecruit: Option<String>,
    pub summaryDirectRecruit: Option<String>,
    pub summaryFriendRecruit: Option<String>,
    pub summaryFreeRecruit: Option<String>,
    pub summaryMonthRecruit: Option<String>,
    pub summaryUpgrade: Option<String>,
    pub summaryCompleteEnding: Option<String>,
    pub summaryEachZone: Option<String>,
    pub summaryMeetSpZone: Option<String>,
    pub summaryPerfectBattle: Option<String>,
    pub summaryMeetBattle: Option<String>,
    pub summaryMeetEvent: Option<String>,
    pub summaryMeetShop: Option<String>,
    pub summaryMeetTreasure: Option<String>,
    pub summaryMeetSecretpath: Option<String>,
    pub summaryExchangeRelic: Option<String>,
    pub summaryMeetTrade: Option<String>,
    pub summaryBuy: Option<String>,
    pub summaryBuyWithPriceId: Option<String>,
    pub summaryInvest: Option<String>,
    pub summaryGet: Option<String>,
    pub summaryRelic: Option<String>,
    pub summarySafeHouse: Option<String>,
    pub summaryFailEnd: Option<String>,
    pub summaryStockRecruitTicket: Option<String>,
    pub summaryDuelWin: Option<String>,
    pub summaryDuelTie: Option<String>,
    pub summaryDuelLose: Option<String>,
    pub summaryExpeditionGo: Option<String>,
    pub summaryExpeditionBack: Option<String>,
}
impl Default for clz_Torappu_RL01EndingTextT {
    fn default() -> Self {
        Self {
            summaryVariation: None,
            summaryFusion: None,
            summaryCapsule: None,
            summaryActor: None,
            summaryTop: None,
            summaryZone: None,
            summaryEnding: None,
            summaryDifficultyZone: None,
            summaryDifficultyEnding: None,
            summaryMode: None,
            summaryGroup: None,
            summarySupport: None,
            summaryNormalRecruit: None,
            summaryDirectRecruit: None,
            summaryFriendRecruit: None,
            summaryFreeRecruit: None,
            summaryMonthRecruit: None,
            summaryUpgrade: None,
            summaryCompleteEnding: None,
            summaryEachZone: None,
            summaryMeetSpZone: None,
            summaryPerfectBattle: None,
            summaryMeetBattle: None,
            summaryMeetEvent: None,
            summaryMeetShop: None,
            summaryMeetTreasure: None,
            summaryMeetSecretpath: None,
            summaryExchangeRelic: None,
            summaryMeetTrade: None,
            summaryBuy: None,
            summaryBuyWithPriceId: None,
            summaryInvest: None,
            summaryGet: None,
            summaryRelic: None,
            summarySafeHouse: None,
            summaryFailEnd: None,
            summaryStockRecruitTicket: None,
            summaryDuelWin: None,
            summaryDuelTie: None,
            summaryDuelLose: None,
            summaryExpeditionGo: None,
            summaryExpeditionBack: None,
        }
    }
}
impl clz_Torappu_RL01EndingTextT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL01EndingText<'b>> {
        let summaryVariation = self
            .summaryVariation
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryFusion = self.summaryFusion.as_ref().map(|x| _fbb.create_string(x));
        let summaryCapsule = self.summaryCapsule.as_ref().map(|x| _fbb.create_string(x));
        let summaryActor = self.summaryActor.as_ref().map(|x| _fbb.create_string(x));
        let summaryTop = self.summaryTop.as_ref().map(|x| _fbb.create_string(x));
        let summaryZone = self.summaryZone.as_ref().map(|x| _fbb.create_string(x));
        let summaryEnding = self.summaryEnding.as_ref().map(|x| _fbb.create_string(x));
        let summaryDifficultyZone = self
            .summaryDifficultyZone
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDifficultyEnding = self
            .summaryDifficultyEnding
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMode = self.summaryMode.as_ref().map(|x| _fbb.create_string(x));
        let summaryGroup = self.summaryGroup.as_ref().map(|x| _fbb.create_string(x));
        let summarySupport = self.summarySupport.as_ref().map(|x| _fbb.create_string(x));
        let summaryNormalRecruit = self
            .summaryNormalRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDirectRecruit = self
            .summaryDirectRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryFriendRecruit = self
            .summaryFriendRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryFreeRecruit = self
            .summaryFreeRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMonthRecruit = self
            .summaryMonthRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryUpgrade = self.summaryUpgrade.as_ref().map(|x| _fbb.create_string(x));
        let summaryCompleteEnding = self
            .summaryCompleteEnding
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryEachZone = self.summaryEachZone.as_ref().map(|x| _fbb.create_string(x));
        let summaryMeetSpZone = self
            .summaryMeetSpZone
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryPerfectBattle = self
            .summaryPerfectBattle
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetBattle = self
            .summaryMeetBattle
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetEvent = self
            .summaryMeetEvent
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetShop = self.summaryMeetShop.as_ref().map(|x| _fbb.create_string(x));
        let summaryMeetTreasure = self
            .summaryMeetTreasure
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetSecretpath = self
            .summaryMeetSecretpath
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExchangeRelic = self
            .summaryExchangeRelic
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetTrade = self
            .summaryMeetTrade
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryBuy = self.summaryBuy.as_ref().map(|x| _fbb.create_string(x));
        let summaryBuyWithPriceId = self
            .summaryBuyWithPriceId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryInvest = self.summaryInvest.as_ref().map(|x| _fbb.create_string(x));
        let summaryGet = self.summaryGet.as_ref().map(|x| _fbb.create_string(x));
        let summaryRelic = self.summaryRelic.as_ref().map(|x| _fbb.create_string(x));
        let summarySafeHouse = self
            .summarySafeHouse
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryFailEnd = self.summaryFailEnd.as_ref().map(|x| _fbb.create_string(x));
        let summaryStockRecruitTicket = self
            .summaryStockRecruitTicket
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDuelWin = self.summaryDuelWin.as_ref().map(|x| _fbb.create_string(x));
        let summaryDuelTie = self.summaryDuelTie.as_ref().map(|x| _fbb.create_string(x));
        let summaryDuelLose = self.summaryDuelLose.as_ref().map(|x| _fbb.create_string(x));
        let summaryExpeditionGo = self
            .summaryExpeditionGo
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExpeditionBack = self
            .summaryExpeditionBack
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RL01EndingText::create(
            _fbb,
            &clz_Torappu_RL01EndingTextArgs {
                summaryVariation,
                summaryFusion,
                summaryCapsule,
                summaryActor,
                summaryTop,
                summaryZone,
                summaryEnding,
                summaryDifficultyZone,
                summaryDifficultyEnding,
                summaryMode,
                summaryGroup,
                summarySupport,
                summaryNormalRecruit,
                summaryDirectRecruit,
                summaryFriendRecruit,
                summaryFreeRecruit,
                summaryMonthRecruit,
                summaryUpgrade,
                summaryCompleteEnding,
                summaryEachZone,
                summaryMeetSpZone,
                summaryPerfectBattle,
                summaryMeetBattle,
                summaryMeetEvent,
                summaryMeetShop,
                summaryMeetTreasure,
                summaryMeetSecretpath,
                summaryExchangeRelic,
                summaryMeetTrade,
                summaryBuy,
                summaryBuyWithPriceId,
                summaryInvest,
                summaryGet,
                summaryRelic,
                summarySafeHouse,
                summaryFailEnd,
                summaryStockRecruitTicket,
                summaryDuelWin,
                summaryDuelTie,
                summaryDuelLose,
                summaryExpeditionGo,
                summaryExpeditionBack,
            },
        )
    }
}
pub enum clz_Torappu_RL01DifficultyExtOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL01DifficultyExt<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL01DifficultyExt<'a> {
    type Inner = clz_Torappu_RL01DifficultyExt<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL01DifficultyExt<'a> {
    pub const VT_MODEDIFFICULTY: flatbuffers::VOffsetT = 4;
    pub const VT_GRADE: flatbuffers::VOffsetT = 6;
    pub const VT_BUFFDESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL01DifficultyExt { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL01DifficultyExtArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL01DifficultyExt<'bldr>> {
        let mut builder = clz_Torappu_RL01DifficultyExtBuilder::new(_fbb);
        if let Some(x) = args.buffDesc {
            builder.add_buffDesc(x);
        }
        builder.add_grade(args.grade);
        builder.add_modeDifficulty(args.modeDifficulty);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL01DifficultyExtT {
        let modeDifficulty = self.modeDifficulty();
        let grade = self.grade();
        let buffDesc = self
            .buffDesc()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_RL01DifficultyExtT {
            modeDifficulty,
            grade,
            buffDesc,
        }
    }

    #[inline]
    pub fn modeDifficulty(&self) -> enum__Torappu_RoguelikeTopicMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTopicMode>(
                    clz_Torappu_RL01DifficultyExt::VT_MODEDIFFICULTY,
                    Some(enum__Torappu_RoguelikeTopicMode::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn grade(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL01DifficultyExt::VT_GRADE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn buffDesc(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RL01DifficultyExt::VT_BUFFDESC, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL01DifficultyExt<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeTopicMode>(
                "modeDifficulty",
                Self::VT_MODEDIFFICULTY,
                false,
            )?
            .visit_field::<i32>("grade", Self::VT_GRADE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("buffDesc", Self::VT_BUFFDESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL01DifficultyExtArgs<'a> {
    pub modeDifficulty: enum__Torappu_RoguelikeTopicMode,
    pub grade: i32,
    pub buffDesc: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_RL01DifficultyExtArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL01DifficultyExtArgs {
            modeDifficulty: enum__Torappu_RoguelikeTopicMode::NONE,
            grade: 0,
            buffDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_RL01DifficultyExt<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL01DifficultyExt", 3)?;
        s.serialize_field("modeDifficulty", &self.modeDifficulty())?;
        s.serialize_field("grade", &self.grade())?;
        if let Some(f) = self.buffDesc() {
            s.serialize_field("buffDesc", &f)?;
        } else {
            s.skip_field("buffDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL01DifficultyExtBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL01DifficultyExtBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_modeDifficulty(&mut self, modeDifficulty: enum__Torappu_RoguelikeTopicMode) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeTopicMode>(
            clz_Torappu_RL01DifficultyExt::VT_MODEDIFFICULTY,
            modeDifficulty,
            enum__Torappu_RoguelikeTopicMode::NONE,
        );
    }
    #[inline]
    pub fn add_grade(&mut self, grade: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL01DifficultyExt::VT_GRADE, grade, 0);
    }
    #[inline]
    pub fn add_buffDesc(
        &mut self,
        buffDesc: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01DifficultyExt::VT_BUFFDESC,
            buffDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL01DifficultyExtBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL01DifficultyExtBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL01DifficultyExt<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL01DifficultyExt<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL01DifficultyExt");
        ds.field("modeDifficulty", &self.modeDifficulty());
        ds.field("grade", &self.grade());
        ds.field("buffDesc", &self.buffDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL01DifficultyExtT {
    pub modeDifficulty: enum__Torappu_RoguelikeTopicMode,
    pub grade: i32,
    pub buffDesc: Option<Vec<String>>,
}
impl Default for clz_Torappu_RL01DifficultyExtT {
    fn default() -> Self {
        Self {
            modeDifficulty: enum__Torappu_RoguelikeTopicMode::NONE,
            grade: 0,
            buffDesc: None,
        }
    }
}
impl clz_Torappu_RL01DifficultyExtT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL01DifficultyExt<'b>> {
        let modeDifficulty = self.modeDifficulty;
        let grade = self.grade;
        let buffDesc = self.buffDesc.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RL01DifficultyExt::create(
            _fbb,
            &clz_Torappu_RL01DifficultyExtArgs {
                modeDifficulty,
                grade,
                buffDesc,
            },
        )
    }
}
pub enum clz_Torappu_RL01CustomizeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL01CustomizeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL01CustomizeData<'a> {
    type Inner = clz_Torappu_RL01CustomizeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL01CustomizeData<'a> {
    pub const VT_DEVELOPMENTS: flatbuffers::VOffsetT = 4;
    pub const VT_DEVELOPMENTTOKENS: flatbuffers::VOffsetT = 6;
    pub const VT_ENDINGTEXT: flatbuffers::VOffsetT = 8;
    pub const VT_DIFFICULTIES: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL01CustomizeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL01CustomizeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL01CustomizeData<'bldr>> {
        let mut builder = clz_Torappu_RL01CustomizeDataBuilder::new(_fbb);
        if let Some(x) = args.difficulties {
            builder.add_difficulties(x);
        }
        if let Some(x) = args.endingText {
            builder.add_endingText(x);
        }
        if let Some(x) = args.developmentTokens {
            builder.add_developmentTokens(x);
        }
        if let Some(x) = args.developments {
            builder.add_developments(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL01CustomizeDataT {
        let developments = self
            .developments()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let developmentTokens = self
            .developmentTokens()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let endingText = self.endingText().map(|x| Box::new(x.unpack()));
        let difficulties = self
            .difficulties()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RL01CustomizeDataT {
            developments,
            developmentTokens,
            endingText,
            difficulties,
        }
    }

    #[inline]
    pub fn developments(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDev<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDev>,
                >,
            >>(clz_Torappu_RL01CustomizeData::VT_DEVELOPMENTS, None)
        }
    }
    #[inline]
    pub fn developmentTokens(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken>,
                >,
            >>(clz_Torappu_RL01CustomizeData::VT_DEVELOPMENTTOKENS, None)
        }
    }
    #[inline]
    pub fn endingText(&self) -> Option<clz_Torappu_RL01EndingText<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RL01EndingText>>(
                    clz_Torappu_RL01CustomizeData::VT_ENDINGTEXT,
                    None,
                )
        }
    }
    #[inline]
    pub fn difficulties(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RL01DifficultyExt<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL01DifficultyExt>,
                >,
            >>(clz_Torappu_RL01CustomizeData::VT_DIFFICULTIES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL01CustomizeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDev>,
                >,
            >>("developments", Self::VT_DEVELOPMENTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken>,
                >,
            >>("developmentTokens", Self::VT_DEVELOPMENTTOKENS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RL01EndingText>>(
                "endingText",
                Self::VT_ENDINGTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL01DifficultyExt>,
                >,
            >>("difficulties", Self::VT_DIFFICULTIES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL01CustomizeDataArgs<'a> {
    pub developments: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDev<'a>>,
            >,
        >,
    >,
    pub developmentTokens: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken<'a>>,
            >,
        >,
    >,
    pub endingText: Option<flatbuffers::WIPOffset<clz_Torappu_RL01EndingText<'a>>>,
    pub difficulties: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL01DifficultyExt<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RL01CustomizeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL01CustomizeDataArgs {
            developments: None,
            developmentTokens: None,
            endingText: None,
            difficulties: None,
        }
    }
}

impl Serialize for clz_Torappu_RL01CustomizeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL01CustomizeData", 4)?;
        if let Some(f) = self.developments() {
            s.serialize_field("developments", &f)?;
        } else {
            s.skip_field("developments")?;
        }
        if let Some(f) = self.developmentTokens() {
            s.serialize_field("developmentTokens", &f)?;
        } else {
            s.skip_field("developmentTokens")?;
        }
        if let Some(f) = self.endingText() {
            s.serialize_field("endingText", &f)?;
        } else {
            s.skip_field("endingText")?;
        }
        if let Some(f) = self.difficulties() {
            s.serialize_field("difficulties", &f)?;
        } else {
            s.skip_field("difficulties")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL01CustomizeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL01CustomizeDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_developments(
        &mut self,
        developments: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDev<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01CustomizeData::VT_DEVELOPMENTS,
            developments,
        );
    }
    #[inline]
    pub fn add_developmentTokens(
        &mut self,
        developmentTokens: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01CustomizeData::VT_DEVELOPMENTTOKENS,
            developmentTokens,
        );
    }
    #[inline]
    pub fn add_endingText(
        &mut self,
        endingText: flatbuffers::WIPOffset<clz_Torappu_RL01EndingText<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RL01EndingText>>(
                clz_Torappu_RL01CustomizeData::VT_ENDINGTEXT,
                endingText,
            );
    }
    #[inline]
    pub fn add_difficulties(
        &mut self,
        difficulties: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL01DifficultyExt<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL01CustomizeData::VT_DIFFICULTIES,
            difficulties,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL01CustomizeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL01CustomizeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL01CustomizeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL01CustomizeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL01CustomizeData");
        ds.field("developments", &self.developments());
        ds.field("developmentTokens", &self.developmentTokens());
        ds.field("endingText", &self.endingText());
        ds.field("difficulties", &self.difficulties());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL01CustomizeDataT {
    pub developments: Option<Vec<dict__string__clz_Torappu_RoguelikeTopicDevT>>,
    pub developmentTokens: Option<Vec<dict__string__clz_Torappu_RoguelikeTopicDevTokenT>>,
    pub endingText: Option<Box<clz_Torappu_RL01EndingTextT>>,
    pub difficulties: Option<Vec<clz_Torappu_RL01DifficultyExtT>>,
}
impl Default for clz_Torappu_RL01CustomizeDataT {
    fn default() -> Self {
        Self {
            developments: None,
            developmentTokens: None,
            endingText: None,
            difficulties: None,
        }
    }
}
impl clz_Torappu_RL01CustomizeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL01CustomizeData<'b>> {
        let developments = self.developments.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let developmentTokens = self.developmentTokens.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let endingText = self.endingText.as_ref().map(|x| x.pack(_fbb));
        let difficulties = self.difficulties.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RL01CustomizeData::create(
            _fbb,
            &clz_Torappu_RL01CustomizeDataArgs {
                developments,
                developmentTokens,
                endingText,
                difficulties,
            },
        )
    }
}
pub enum clz_Torappu_RL02DevelopmentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL02Development<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL02Development<'a> {
    type Inner = clz_Torappu_RL02Development<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL02Development<'a> {
    pub const VT_BUFFID: flatbuffers::VOffsetT = 4;
    pub const VT_NODETYPE: flatbuffers::VOffsetT = 6;
    pub const VT_FRONTNODEID: flatbuffers::VOffsetT = 8;
    pub const VT_NEXTNODEID: flatbuffers::VOffsetT = 10;
    pub const VT_POSITIONP: flatbuffers::VOffsetT = 12;
    pub const VT_POSITIONR: flatbuffers::VOffsetT = 14;
    pub const VT_TOKENCOST: flatbuffers::VOffsetT = 16;
    pub const VT_BUFFNAME: flatbuffers::VOffsetT = 18;
    pub const VT_BUFFICONID: flatbuffers::VOffsetT = 20;
    pub const VT_EFFECTTYPE: flatbuffers::VOffsetT = 22;
    pub const VT_RAWDESC: flatbuffers::VOffsetT = 24;
    pub const VT_BUFFDISPLAYINFO: flatbuffers::VOffsetT = 26;
    pub const VT_ENROLLID: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL02Development { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL02DevelopmentArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL02Development<'bldr>> {
        let mut builder = clz_Torappu_RL02DevelopmentBuilder::new(_fbb);
        if let Some(x) = args.enrollId {
            builder.add_enrollId(x);
        }
        if let Some(x) = args.buffDisplayInfo {
            builder.add_buffDisplayInfo(x);
        }
        if let Some(x) = args.rawDesc {
            builder.add_rawDesc(x);
        }
        builder.add_effectType(args.effectType);
        if let Some(x) = args.buffIconId {
            builder.add_buffIconId(x);
        }
        if let Some(x) = args.buffName {
            builder.add_buffName(x);
        }
        builder.add_tokenCost(args.tokenCost);
        builder.add_positionR(args.positionR);
        builder.add_positionP(args.positionP);
        if let Some(x) = args.nextNodeId {
            builder.add_nextNodeId(x);
        }
        if let Some(x) = args.frontNodeId {
            builder.add_frontNodeId(x);
        }
        builder.add_nodeType(args.nodeType);
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL02DevelopmentT {
        let buffId = self.buffId().map(|x| x.to_string());
        let nodeType = self.nodeType();
        let frontNodeId = self
            .frontNodeId()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let nextNodeId = self
            .nextNodeId()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let positionP = self.positionP();
        let positionR = self.positionR();
        let tokenCost = self.tokenCost();
        let buffName = self.buffName().map(|x| x.to_string());
        let buffIconId = self.buffIconId().map(|x| x.to_string());
        let effectType = self.effectType();
        let rawDesc = self.rawDesc().map(|x| x.to_string());
        let buffDisplayInfo = self
            .buffDisplayInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let enrollId = self.enrollId().map(|x| x.to_string());
        clz_Torappu_RL02DevelopmentT {
            buffId,
            nodeType,
            frontNodeId,
            nextNodeId,
            positionP,
            positionR,
            tokenCost,
            buffName,
            buffIconId,
            effectType,
            rawDesc,
            buffDisplayInfo,
            enrollId,
        }
    }

    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02Development::VT_BUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeType(&self) -> enum__Torappu_RL02DevelopmentNodeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RL02DevelopmentNodeType>(
                    clz_Torappu_RL02Development::VT_NODETYPE,
                    Some(enum__Torappu_RL02DevelopmentNodeType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn frontNodeId(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RL02Development::VT_FRONTNODEID, None)
        }
    }
    #[inline]
    pub fn nextNodeId(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RL02Development::VT_NEXTNODEID, None)
        }
    }
    #[inline]
    pub fn positionP(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL02Development::VT_POSITIONP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn positionR(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL02Development::VT_POSITIONR, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn tokenCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL02Development::VT_TOKENCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn buffName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02Development::VT_BUFFNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn buffIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02Development::VT_BUFFICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn effectType(&self) -> enum__Torappu_RL02DevelopmentEffectType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RL02DevelopmentEffectType>(
                    clz_Torappu_RL02Development::VT_EFFECTTYPE,
                    Some(enum__Torappu_RL02DevelopmentEffectType::BUFF),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rawDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02Development::VT_RAWDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn buffDisplayInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem>,
                >,
            >>(clz_Torappu_RL02Development::VT_BUFFDISPLAYINFO, None)
        }
    }
    #[inline]
    pub fn enrollId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02Development::VT_ENROLLID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL02Development<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .visit_field::<enum__Torappu_RL02DevelopmentNodeType>(
                "nodeType",
                Self::VT_NODETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("frontNodeId", Self::VT_FRONTNODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("nextNodeId", Self::VT_NEXTNODEID, false)?
            .visit_field::<i32>("positionP", Self::VT_POSITIONP, false)?
            .visit_field::<i32>("positionR", Self::VT_POSITIONR, false)?
            .visit_field::<i32>("tokenCost", Self::VT_TOKENCOST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffName",
                Self::VT_BUFFNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffIconId",
                Self::VT_BUFFICONID,
                false,
            )?
            .visit_field::<enum__Torappu_RL02DevelopmentEffectType>(
                "effectType",
                Self::VT_EFFECTTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rawDesc", Self::VT_RAWDESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem>,
                >,
            >>("buffDisplayInfo", Self::VT_BUFFDISPLAYINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollId",
                Self::VT_ENROLLID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL02DevelopmentArgs<'a> {
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeType: enum__Torappu_RL02DevelopmentNodeType,
    pub frontNodeId: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub nextNodeId: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub positionP: i32,
    pub positionR: i32,
    pub tokenCost: i32,
    pub buffName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub effectType: enum__Torappu_RL02DevelopmentEffectType,
    pub rawDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffDisplayInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem<'a>>,
            >,
        >,
    >,
    pub enrollId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RL02DevelopmentArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL02DevelopmentArgs {
            buffId: None,
            nodeType: enum__Torappu_RL02DevelopmentNodeType::NONE,
            frontNodeId: None,
            nextNodeId: None,
            positionP: 0,
            positionR: 0,
            tokenCost: 0,
            buffName: None,
            buffIconId: None,
            effectType: enum__Torappu_RL02DevelopmentEffectType::BUFF,
            rawDesc: None,
            buffDisplayInfo: None,
            enrollId: None,
        }
    }
}

impl Serialize for clz_Torappu_RL02Development<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL02Development", 13)?;
        if let Some(f) = self.buffId() {
            s.serialize_field("buffId", &f)?;
        } else {
            s.skip_field("buffId")?;
        }
        s.serialize_field("nodeType", &self.nodeType())?;
        if let Some(f) = self.frontNodeId() {
            s.serialize_field("frontNodeId", &f)?;
        } else {
            s.skip_field("frontNodeId")?;
        }
        if let Some(f) = self.nextNodeId() {
            s.serialize_field("nextNodeId", &f)?;
        } else {
            s.skip_field("nextNodeId")?;
        }
        s.serialize_field("positionP", &self.positionP())?;
        s.serialize_field("positionR", &self.positionR())?;
        s.serialize_field("tokenCost", &self.tokenCost())?;
        if let Some(f) = self.buffName() {
            s.serialize_field("buffName", &f)?;
        } else {
            s.skip_field("buffName")?;
        }
        if let Some(f) = self.buffIconId() {
            s.serialize_field("buffIconId", &f)?;
        } else {
            s.skip_field("buffIconId")?;
        }
        s.serialize_field("effectType", &self.effectType())?;
        if let Some(f) = self.rawDesc() {
            s.serialize_field("rawDesc", &f)?;
        } else {
            s.skip_field("rawDesc")?;
        }
        if let Some(f) = self.buffDisplayInfo() {
            s.serialize_field("buffDisplayInfo", &f)?;
        } else {
            s.skip_field("buffDisplayInfo")?;
        }
        if let Some(f) = self.enrollId() {
            s.serialize_field("enrollId", &f)?;
        } else {
            s.skip_field("enrollId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL02DevelopmentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL02DevelopmentBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02Development::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn add_nodeType(&mut self, nodeType: enum__Torappu_RL02DevelopmentNodeType) {
        self.fbb_
            .push_slot::<enum__Torappu_RL02DevelopmentNodeType>(
                clz_Torappu_RL02Development::VT_NODETYPE,
                nodeType,
                enum__Torappu_RL02DevelopmentNodeType::NONE,
            );
    }
    #[inline]
    pub fn add_frontNodeId(
        &mut self,
        frontNodeId: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02Development::VT_FRONTNODEID,
            frontNodeId,
        );
    }
    #[inline]
    pub fn add_nextNodeId(
        &mut self,
        nextNodeId: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02Development::VT_NEXTNODEID,
            nextNodeId,
        );
    }
    #[inline]
    pub fn add_positionP(&mut self, positionP: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL02Development::VT_POSITIONP, positionP, 0);
    }
    #[inline]
    pub fn add_positionR(&mut self, positionR: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL02Development::VT_POSITIONR, positionR, 0);
    }
    #[inline]
    pub fn add_tokenCost(&mut self, tokenCost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL02Development::VT_TOKENCOST, tokenCost, 0);
    }
    #[inline]
    pub fn add_buffName(&mut self, buffName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02Development::VT_BUFFNAME,
            buffName,
        );
    }
    #[inline]
    pub fn add_buffIconId(&mut self, buffIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02Development::VT_BUFFICONID,
            buffIconId,
        );
    }
    #[inline]
    pub fn add_effectType(&mut self, effectType: enum__Torappu_RL02DevelopmentEffectType) {
        self.fbb_
            .push_slot::<enum__Torappu_RL02DevelopmentEffectType>(
                clz_Torappu_RL02Development::VT_EFFECTTYPE,
                effectType,
                enum__Torappu_RL02DevelopmentEffectType::BUFF,
            );
    }
    #[inline]
    pub fn add_rawDesc(&mut self, rawDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02Development::VT_RAWDESC,
            rawDesc,
        );
    }
    #[inline]
    pub fn add_buffDisplayInfo(
        &mut self,
        buffDisplayInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02Development::VT_BUFFDISPLAYINFO,
            buffDisplayInfo,
        );
    }
    #[inline]
    pub fn add_enrollId(&mut self, enrollId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02Development::VT_ENROLLID,
            enrollId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL02DevelopmentBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL02DevelopmentBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL02Development<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL02Development<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL02Development");
        ds.field("buffId", &self.buffId());
        ds.field("nodeType", &self.nodeType());
        ds.field("frontNodeId", &self.frontNodeId());
        ds.field("nextNodeId", &self.nextNodeId());
        ds.field("positionP", &self.positionP());
        ds.field("positionR", &self.positionR());
        ds.field("tokenCost", &self.tokenCost());
        ds.field("buffName", &self.buffName());
        ds.field("buffIconId", &self.buffIconId());
        ds.field("effectType", &self.effectType());
        ds.field("rawDesc", &self.rawDesc());
        ds.field("buffDisplayInfo", &self.buffDisplayInfo());
        ds.field("enrollId", &self.enrollId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL02DevelopmentT {
    pub buffId: Option<String>,
    pub nodeType: enum__Torappu_RL02DevelopmentNodeType,
    pub frontNodeId: Option<Vec<String>>,
    pub nextNodeId: Option<Vec<String>>,
    pub positionP: i32,
    pub positionR: i32,
    pub tokenCost: i32,
    pub buffName: Option<String>,
    pub buffIconId: Option<String>,
    pub effectType: enum__Torappu_RL02DevelopmentEffectType,
    pub rawDesc: Option<String>,
    pub buffDisplayInfo: Option<Vec<clz_Torappu_RoguelikeTopicDisplayItemT>>,
    pub enrollId: Option<String>,
}
impl Default for clz_Torappu_RL02DevelopmentT {
    fn default() -> Self {
        Self {
            buffId: None,
            nodeType: enum__Torappu_RL02DevelopmentNodeType::NONE,
            frontNodeId: None,
            nextNodeId: None,
            positionP: 0,
            positionR: 0,
            tokenCost: 0,
            buffName: None,
            buffIconId: None,
            effectType: enum__Torappu_RL02DevelopmentEffectType::BUFF,
            rawDesc: None,
            buffDisplayInfo: None,
            enrollId: None,
        }
    }
}
impl clz_Torappu_RL02DevelopmentT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL02Development<'b>> {
        let buffId = self.buffId.as_ref().map(|x| _fbb.create_string(x));
        let nodeType = self.nodeType;
        let frontNodeId = self.frontNodeId.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let nextNodeId = self.nextNodeId.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let positionP = self.positionP;
        let positionR = self.positionR;
        let tokenCost = self.tokenCost;
        let buffName = self.buffName.as_ref().map(|x| _fbb.create_string(x));
        let buffIconId = self.buffIconId.as_ref().map(|x| _fbb.create_string(x));
        let effectType = self.effectType;
        let rawDesc = self.rawDesc.as_ref().map(|x| _fbb.create_string(x));
        let buffDisplayInfo = self.buffDisplayInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let enrollId = self.enrollId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RL02Development::create(
            _fbb,
            &clz_Torappu_RL02DevelopmentArgs {
                buffId,
                nodeType,
                frontNodeId,
                nextNodeId,
                positionP,
                positionR,
                tokenCost,
                buffName,
                buffIconId,
                effectType,
                rawDesc,
                buffDisplayInfo,
                enrollId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RL02DevelopmentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RL02Development<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RL02Development<'a> {
    type Inner = dict__string__clz_Torappu_RL02Development<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RL02Development<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RL02Development { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RL02DevelopmentArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RL02Development<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RL02DevelopmentBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RL02DevelopmentT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RL02DevelopmentT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RL02Development::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_RL02Development) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RL02Development<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RL02Development>>(
                    dict__string__clz_Torappu_RL02Development::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RL02Development<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RL02Development>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RL02DevelopmentArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RL02Development<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RL02DevelopmentArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RL02DevelopmentArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RL02Development<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_RL02Development", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RL02DevelopmentBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RL02DevelopmentBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RL02Development::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_RL02Development<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RL02Development>>(
                dict__string__clz_Torappu_RL02Development::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RL02DevelopmentBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RL02DevelopmentBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RL02Development<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_RL02Development::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RL02Development<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RL02Development");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RL02DevelopmentT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RL02DevelopmentT>>,
}
impl Default for dict__string__clz_Torappu_RL02DevelopmentT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RL02DevelopmentT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RL02Development<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RL02Development::create(
            _fbb,
            &dict__string__clz_Torappu_RL02DevelopmentArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RL02DevRawTextBuffGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL02DevRawTextBuffGroup<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL02DevRawTextBuffGroup<'a> {
    type Inner = clz_Torappu_RL02DevRawTextBuffGroup<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL02DevRawTextBuffGroup<'a> {
    pub const VT_NODEIDLIST: flatbuffers::VOffsetT = 4;
    pub const VT_USELEVELMARK: flatbuffers::VOffsetT = 6;
    pub const VT_GROUPICONID: flatbuffers::VOffsetT = 8;
    pub const VT_USEUPBREAK: flatbuffers::VOffsetT = 10;
    pub const VT_SORTID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL02DevRawTextBuffGroup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL02DevRawTextBuffGroupArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL02DevRawTextBuffGroup<'bldr>> {
        let mut builder = clz_Torappu_RL02DevRawTextBuffGroupBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.groupIconId {
            builder.add_groupIconId(x);
        }
        if let Some(x) = args.nodeIdList {
            builder.add_nodeIdList(x);
        }
        builder.add_useUpBreak(args.useUpBreak);
        builder.add_useLevelMark(args.useLevelMark);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL02DevRawTextBuffGroupT {
        let nodeIdList = self
            .nodeIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let useLevelMark = self.useLevelMark();
        let groupIconId = self.groupIconId().map(|x| x.to_string());
        let useUpBreak = self.useUpBreak();
        let sortId = self.sortId();
        clz_Torappu_RL02DevRawTextBuffGroupT {
            nodeIdList,
            useLevelMark,
            groupIconId,
            useUpBreak,
            sortId,
        }
    }

    #[inline]
    pub fn nodeIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RL02DevRawTextBuffGroup::VT_NODEIDLIST, None)
        }
    }
    #[inline]
    pub fn useLevelMark(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RL02DevRawTextBuffGroup::VT_USELEVELMARK,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn groupIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02DevRawTextBuffGroup::VT_GROUPICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn useUpBreak(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RL02DevRawTextBuffGroup::VT_USEUPBREAK,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL02DevRawTextBuffGroup::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL02DevRawTextBuffGroup<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("nodeIdList", Self::VT_NODEIDLIST, false)?
            .visit_field::<bool>("useLevelMark", Self::VT_USELEVELMARK, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "groupIconId",
                Self::VT_GROUPICONID,
                false,
            )?
            .visit_field::<bool>("useUpBreak", Self::VT_USEUPBREAK, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL02DevRawTextBuffGroupArgs<'a> {
    pub nodeIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub useLevelMark: bool,
    pub groupIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub useUpBreak: bool,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_RL02DevRawTextBuffGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL02DevRawTextBuffGroupArgs {
            nodeIdList: None,
            useLevelMark: false,
            groupIconId: None,
            useUpBreak: false,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_RL02DevRawTextBuffGroup<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL02DevRawTextBuffGroup", 5)?;
        if let Some(f) = self.nodeIdList() {
            s.serialize_field("nodeIdList", &f)?;
        } else {
            s.skip_field("nodeIdList")?;
        }
        s.serialize_field("useLevelMark", &self.useLevelMark())?;
        if let Some(f) = self.groupIconId() {
            s.serialize_field("groupIconId", &f)?;
        } else {
            s.skip_field("groupIconId")?;
        }
        s.serialize_field("useUpBreak", &self.useUpBreak())?;
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_RL02DevRawTextBuffGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RL02DevRawTextBuffGroupBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeIdList(
        &mut self,
        nodeIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02DevRawTextBuffGroup::VT_NODEIDLIST,
            nodeIdList,
        );
    }
    #[inline]
    pub fn add_useLevelMark(&mut self, useLevelMark: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RL02DevRawTextBuffGroup::VT_USELEVELMARK,
            useLevelMark,
            false,
        );
    }
    #[inline]
    pub fn add_groupIconId(&mut self, groupIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02DevRawTextBuffGroup::VT_GROUPICONID,
            groupIconId,
        );
    }
    #[inline]
    pub fn add_useUpBreak(&mut self, useUpBreak: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RL02DevRawTextBuffGroup::VT_USEUPBREAK,
            useUpBreak,
            false,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL02DevRawTextBuffGroup::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL02DevRawTextBuffGroupBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL02DevRawTextBuffGroupBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL02DevRawTextBuffGroup<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL02DevRawTextBuffGroup<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL02DevRawTextBuffGroup");
        ds.field("nodeIdList", &self.nodeIdList());
        ds.field("useLevelMark", &self.useLevelMark());
        ds.field("groupIconId", &self.groupIconId());
        ds.field("useUpBreak", &self.useUpBreak());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL02DevRawTextBuffGroupT {
    pub nodeIdList: Option<Vec<String>>,
    pub useLevelMark: bool,
    pub groupIconId: Option<String>,
    pub useUpBreak: bool,
    pub sortId: i32,
}
impl Default for clz_Torappu_RL02DevRawTextBuffGroupT {
    fn default() -> Self {
        Self {
            nodeIdList: None,
            useLevelMark: false,
            groupIconId: None,
            useUpBreak: false,
            sortId: 0,
        }
    }
}
impl clz_Torappu_RL02DevRawTextBuffGroupT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL02DevRawTextBuffGroup<'b>> {
        let nodeIdList = self.nodeIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let useLevelMark = self.useLevelMark;
        let groupIconId = self.groupIconId.as_ref().map(|x| _fbb.create_string(x));
        let useUpBreak = self.useUpBreak;
        let sortId = self.sortId;
        clz_Torappu_RL02DevRawTextBuffGroup::create(
            _fbb,
            &clz_Torappu_RL02DevRawTextBuffGroupArgs {
                nodeIdList,
                useLevelMark,
                groupIconId,
                useUpBreak,
                sortId,
            },
        )
    }
}
pub enum clz_Torappu_RL02DevelopmentLineOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL02DevelopmentLine<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL02DevelopmentLine<'a> {
    type Inner = clz_Torappu_RL02DevelopmentLine<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL02DevelopmentLine<'a> {
    pub const VT_FROMNODE: flatbuffers::VOffsetT = 4;
    pub const VT_TONODE: flatbuffers::VOffsetT = 6;
    pub const VT_FROMNODEP: flatbuffers::VOffsetT = 8;
    pub const VT_FROMNODER: flatbuffers::VOffsetT = 10;
    pub const VT_TONODEP: flatbuffers::VOffsetT = 12;
    pub const VT_TONODER: flatbuffers::VOffsetT = 14;
    pub const VT_ENROLLID: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL02DevelopmentLine { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL02DevelopmentLineArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL02DevelopmentLine<'bldr>> {
        let mut builder = clz_Torappu_RL02DevelopmentLineBuilder::new(_fbb);
        if let Some(x) = args.enrollId {
            builder.add_enrollId(x);
        }
        builder.add_toNodeR(args.toNodeR);
        builder.add_toNodeP(args.toNodeP);
        builder.add_fromNodeR(args.fromNodeR);
        builder.add_fromNodeP(args.fromNodeP);
        if let Some(x) = args.toNode {
            builder.add_toNode(x);
        }
        if let Some(x) = args.fromNode {
            builder.add_fromNode(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL02DevelopmentLineT {
        let fromNode = self.fromNode().map(|x| x.to_string());
        let toNode = self.toNode().map(|x| x.to_string());
        let fromNodeP = self.fromNodeP();
        let fromNodeR = self.fromNodeR();
        let toNodeP = self.toNodeP();
        let toNodeR = self.toNodeR();
        let enrollId = self.enrollId().map(|x| x.to_string());
        clz_Torappu_RL02DevelopmentLineT {
            fromNode,
            toNode,
            fromNodeP,
            fromNodeR,
            toNodeP,
            toNodeR,
            enrollId,
        }
    }

    #[inline]
    pub fn fromNode(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02DevelopmentLine::VT_FROMNODE,
                None,
            )
        }
    }
    #[inline]
    pub fn toNode(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02DevelopmentLine::VT_TONODE,
                None,
            )
        }
    }
    #[inline]
    pub fn fromNodeP(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL02DevelopmentLine::VT_FROMNODEP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn fromNodeR(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL02DevelopmentLine::VT_FROMNODER, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn toNodeP(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL02DevelopmentLine::VT_TONODEP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn toNodeR(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL02DevelopmentLine::VT_TONODER, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn enrollId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02DevelopmentLine::VT_ENROLLID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL02DevelopmentLine<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "fromNode",
                Self::VT_FROMNODE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("toNode", Self::VT_TONODE, false)?
            .visit_field::<i32>("fromNodeP", Self::VT_FROMNODEP, false)?
            .visit_field::<i32>("fromNodeR", Self::VT_FROMNODER, false)?
            .visit_field::<i32>("toNodeP", Self::VT_TONODEP, false)?
            .visit_field::<i32>("toNodeR", Self::VT_TONODER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollId",
                Self::VT_ENROLLID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL02DevelopmentLineArgs<'a> {
    pub fromNode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub toNode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fromNodeP: i32,
    pub fromNodeR: i32,
    pub toNodeP: i32,
    pub toNodeR: i32,
    pub enrollId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RL02DevelopmentLineArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL02DevelopmentLineArgs {
            fromNode: None,
            toNode: None,
            fromNodeP: 0,
            fromNodeR: 0,
            toNodeP: 0,
            toNodeR: 0,
            enrollId: None,
        }
    }
}

impl Serialize for clz_Torappu_RL02DevelopmentLine<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL02DevelopmentLine", 7)?;
        if let Some(f) = self.fromNode() {
            s.serialize_field("fromNode", &f)?;
        } else {
            s.skip_field("fromNode")?;
        }
        if let Some(f) = self.toNode() {
            s.serialize_field("toNode", &f)?;
        } else {
            s.skip_field("toNode")?;
        }
        s.serialize_field("fromNodeP", &self.fromNodeP())?;
        s.serialize_field("fromNodeR", &self.fromNodeR())?;
        s.serialize_field("toNodeP", &self.toNodeP())?;
        s.serialize_field("toNodeR", &self.toNodeR())?;
        if let Some(f) = self.enrollId() {
            s.serialize_field("enrollId", &f)?;
        } else {
            s.skip_field("enrollId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL02DevelopmentLineBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL02DevelopmentLineBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_fromNode(&mut self, fromNode: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02DevelopmentLine::VT_FROMNODE,
            fromNode,
        );
    }
    #[inline]
    pub fn add_toNode(&mut self, toNode: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02DevelopmentLine::VT_TONODE,
            toNode,
        );
    }
    #[inline]
    pub fn add_fromNodeP(&mut self, fromNodeP: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL02DevelopmentLine::VT_FROMNODEP, fromNodeP, 0);
    }
    #[inline]
    pub fn add_fromNodeR(&mut self, fromNodeR: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL02DevelopmentLine::VT_FROMNODER, fromNodeR, 0);
    }
    #[inline]
    pub fn add_toNodeP(&mut self, toNodeP: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL02DevelopmentLine::VT_TONODEP, toNodeP, 0);
    }
    #[inline]
    pub fn add_toNodeR(&mut self, toNodeR: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL02DevelopmentLine::VT_TONODER, toNodeR, 0);
    }
    #[inline]
    pub fn add_enrollId(&mut self, enrollId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02DevelopmentLine::VT_ENROLLID,
            enrollId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL02DevelopmentLineBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL02DevelopmentLineBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL02DevelopmentLine<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL02DevelopmentLine<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL02DevelopmentLine");
        ds.field("fromNode", &self.fromNode());
        ds.field("toNode", &self.toNode());
        ds.field("fromNodeP", &self.fromNodeP());
        ds.field("fromNodeR", &self.fromNodeR());
        ds.field("toNodeP", &self.toNodeP());
        ds.field("toNodeR", &self.toNodeR());
        ds.field("enrollId", &self.enrollId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL02DevelopmentLineT {
    pub fromNode: Option<String>,
    pub toNode: Option<String>,
    pub fromNodeP: i32,
    pub fromNodeR: i32,
    pub toNodeP: i32,
    pub toNodeR: i32,
    pub enrollId: Option<String>,
}
impl Default for clz_Torappu_RL02DevelopmentLineT {
    fn default() -> Self {
        Self {
            fromNode: None,
            toNode: None,
            fromNodeP: 0,
            fromNodeR: 0,
            toNodeP: 0,
            toNodeR: 0,
            enrollId: None,
        }
    }
}
impl clz_Torappu_RL02DevelopmentLineT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL02DevelopmentLine<'b>> {
        let fromNode = self.fromNode.as_ref().map(|x| _fbb.create_string(x));
        let toNode = self.toNode.as_ref().map(|x| _fbb.create_string(x));
        let fromNodeP = self.fromNodeP;
        let fromNodeR = self.fromNodeR;
        let toNodeP = self.toNodeP;
        let toNodeR = self.toNodeR;
        let enrollId = self.enrollId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RL02DevelopmentLine::create(
            _fbb,
            &clz_Torappu_RL02DevelopmentLineArgs {
                fromNode,
                toNode,
                fromNodeP,
                fromNodeR,
                toNodeP,
                toNodeR,
                enrollId,
            },
        )
    }
}
pub enum clz_Torappu_RL02EndingTextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL02EndingText<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL02EndingText<'a> {
    type Inner = clz_Torappu_RL02EndingText<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL02EndingText<'a> {
    pub const VT_SUMMARYMUTATION: flatbuffers::VOffsetT = 4;
    pub const VT_SUMMARYDICE: flatbuffers::VOffsetT = 6;
    pub const VT_SUMMARYDICERESULTGOOD: flatbuffers::VOffsetT = 8;
    pub const VT_SUMMARYDICERESULTNORMAL: flatbuffers::VOffsetT = 10;
    pub const VT_SUMMARYDICERESULTBAD: flatbuffers::VOffsetT = 12;
    pub const VT_SUMMARYDICERESULTDESC: flatbuffers::VOffsetT = 14;
    pub const VT_SUMMARYCOMMUDESC: flatbuffers::VOffsetT = 16;
    pub const VT_SUMMARYHIDDENDESC: flatbuffers::VOffsetT = 18;
    pub const VT_SUMMARYKNIGHTDESC: flatbuffers::VOffsetT = 20;
    pub const VT_SUMMARYGOLDDESC: flatbuffers::VOffsetT = 22;
    pub const VT_SUMMARYPRACTICEDESC: flatbuffers::VOffsetT = 24;
    pub const VT_SUMMARYCOMMUEMPTYDESC: flatbuffers::VOffsetT = 26;
    pub const VT_SUMMARYCOMMUNOTEMPTYDESC: flatbuffers::VOffsetT = 28;
    pub const VT_SUMMARYHIDDENPASSEDDESC: flatbuffers::VOffsetT = 30;
    pub const VT_SUMMARYHIDDENNOTPASSEDDESC: flatbuffers::VOffsetT = 32;
    pub const VT_SUMMARYKNIGHTPASSEDDESC: flatbuffers::VOffsetT = 34;
    pub const VT_SUMMARYKNIGHTNOTPASSEDDESC: flatbuffers::VOffsetT = 36;
    pub const VT_SUMMARYGOLDTHRESHOLD: flatbuffers::VOffsetT = 38;
    pub const VT_SUMMARYGOLDHIGHDESC: flatbuffers::VOffsetT = 40;
    pub const VT_SUMMARYGOLDLOWDESC: flatbuffers::VOffsetT = 42;
    pub const VT_SUMMARYPRACTICETHRESHOLD: flatbuffers::VOffsetT = 44;
    pub const VT_SUMMARYPRACTICEHIGHDESC: flatbuffers::VOffsetT = 46;
    pub const VT_SUMMARYPRACTICELOWDESC: flatbuffers::VOffsetT = 48;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL02EndingText { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL02EndingTextArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL02EndingText<'bldr>> {
        let mut builder = clz_Torappu_RL02EndingTextBuilder::new(_fbb);
        if let Some(x) = args.summaryPracticeLowDesc {
            builder.add_summaryPracticeLowDesc(x);
        }
        if let Some(x) = args.summaryPracticeHighDesc {
            builder.add_summaryPracticeHighDesc(x);
        }
        builder.add_summaryPracticeThreshold(args.summaryPracticeThreshold);
        if let Some(x) = args.summaryGoldLowDesc {
            builder.add_summaryGoldLowDesc(x);
        }
        if let Some(x) = args.summaryGoldHighDesc {
            builder.add_summaryGoldHighDesc(x);
        }
        builder.add_summaryGoldThreshold(args.summaryGoldThreshold);
        if let Some(x) = args.summaryKnightNotPassedDesc {
            builder.add_summaryKnightNotPassedDesc(x);
        }
        if let Some(x) = args.summaryKnightPassedDesc {
            builder.add_summaryKnightPassedDesc(x);
        }
        if let Some(x) = args.summaryHiddenNotPassedDesc {
            builder.add_summaryHiddenNotPassedDesc(x);
        }
        if let Some(x) = args.summaryHiddenPassedDesc {
            builder.add_summaryHiddenPassedDesc(x);
        }
        if let Some(x) = args.summaryCommuNotEmptyDesc {
            builder.add_summaryCommuNotEmptyDesc(x);
        }
        if let Some(x) = args.summaryCommuEmptyDesc {
            builder.add_summaryCommuEmptyDesc(x);
        }
        if let Some(x) = args.summaryPracticeDesc {
            builder.add_summaryPracticeDesc(x);
        }
        if let Some(x) = args.summaryGoldDesc {
            builder.add_summaryGoldDesc(x);
        }
        if let Some(x) = args.summaryKnightDesc {
            builder.add_summaryKnightDesc(x);
        }
        if let Some(x) = args.summaryHiddenDesc {
            builder.add_summaryHiddenDesc(x);
        }
        if let Some(x) = args.summaryCommuDesc {
            builder.add_summaryCommuDesc(x);
        }
        if let Some(x) = args.summaryDiceResultDesc {
            builder.add_summaryDiceResultDesc(x);
        }
        if let Some(x) = args.summaryDiceResultBad {
            builder.add_summaryDiceResultBad(x);
        }
        if let Some(x) = args.summaryDiceResultNormal {
            builder.add_summaryDiceResultNormal(x);
        }
        if let Some(x) = args.summaryDiceResultGood {
            builder.add_summaryDiceResultGood(x);
        }
        if let Some(x) = args.summaryDice {
            builder.add_summaryDice(x);
        }
        if let Some(x) = args.summaryMutation {
            builder.add_summaryMutation(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL02EndingTextT {
        let summaryMutation = self.summaryMutation().map(|x| x.to_string());
        let summaryDice = self.summaryDice().map(|x| x.to_string());
        let summaryDiceResultGood = self.summaryDiceResultGood().map(|x| x.to_string());
        let summaryDiceResultNormal = self.summaryDiceResultNormal().map(|x| x.to_string());
        let summaryDiceResultBad = self.summaryDiceResultBad().map(|x| x.to_string());
        let summaryDiceResultDesc = self.summaryDiceResultDesc().map(|x| x.to_string());
        let summaryCommuDesc = self.summaryCommuDesc().map(|x| x.to_string());
        let summaryHiddenDesc = self.summaryHiddenDesc().map(|x| x.to_string());
        let summaryKnightDesc = self.summaryKnightDesc().map(|x| x.to_string());
        let summaryGoldDesc = self.summaryGoldDesc().map(|x| x.to_string());
        let summaryPracticeDesc = self.summaryPracticeDesc().map(|x| x.to_string());
        let summaryCommuEmptyDesc = self.summaryCommuEmptyDesc().map(|x| x.to_string());
        let summaryCommuNotEmptyDesc = self.summaryCommuNotEmptyDesc().map(|x| x.to_string());
        let summaryHiddenPassedDesc = self.summaryHiddenPassedDesc().map(|x| x.to_string());
        let summaryHiddenNotPassedDesc = self.summaryHiddenNotPassedDesc().map(|x| x.to_string());
        let summaryKnightPassedDesc = self.summaryKnightPassedDesc().map(|x| x.to_string());
        let summaryKnightNotPassedDesc = self.summaryKnightNotPassedDesc().map(|x| x.to_string());
        let summaryGoldThreshold = self.summaryGoldThreshold();
        let summaryGoldHighDesc = self.summaryGoldHighDesc().map(|x| x.to_string());
        let summaryGoldLowDesc = self.summaryGoldLowDesc().map(|x| x.to_string());
        let summaryPracticeThreshold = self.summaryPracticeThreshold();
        let summaryPracticeHighDesc = self.summaryPracticeHighDesc().map(|x| x.to_string());
        let summaryPracticeLowDesc = self.summaryPracticeLowDesc().map(|x| x.to_string());
        clz_Torappu_RL02EndingTextT {
            summaryMutation,
            summaryDice,
            summaryDiceResultGood,
            summaryDiceResultNormal,
            summaryDiceResultBad,
            summaryDiceResultDesc,
            summaryCommuDesc,
            summaryHiddenDesc,
            summaryKnightDesc,
            summaryGoldDesc,
            summaryPracticeDesc,
            summaryCommuEmptyDesc,
            summaryCommuNotEmptyDesc,
            summaryHiddenPassedDesc,
            summaryHiddenNotPassedDesc,
            summaryKnightPassedDesc,
            summaryKnightNotPassedDesc,
            summaryGoldThreshold,
            summaryGoldHighDesc,
            summaryGoldLowDesc,
            summaryPracticeThreshold,
            summaryPracticeHighDesc,
            summaryPracticeLowDesc,
        }
    }

    #[inline]
    pub fn summaryMutation(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYMUTATION,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDice(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYDICE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDiceResultGood(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYDICERESULTGOOD,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDiceResultNormal(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYDICERESULTNORMAL,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDiceResultBad(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYDICERESULTBAD,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDiceResultDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYDICERESULTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryCommuDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYCOMMUDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryHiddenDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYHIDDENDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryKnightDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYKNIGHTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryGoldDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYGOLDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryPracticeDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYPRACTICEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryCommuEmptyDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYCOMMUEMPTYDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryCommuNotEmptyDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYCOMMUNOTEMPTYDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryHiddenPassedDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYHIDDENPASSEDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryHiddenNotPassedDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYHIDDENNOTPASSEDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryKnightPassedDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYKNIGHTPASSEDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryKnightNotPassedDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYKNIGHTNOTPASSEDDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryGoldThreshold(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL02EndingText::VT_SUMMARYGOLDTHRESHOLD, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn summaryGoldHighDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYGOLDHIGHDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryGoldLowDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYGOLDLOWDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryPracticeThreshold(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RL02EndingText::VT_SUMMARYPRACTICETHRESHOLD,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn summaryPracticeHighDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYPRACTICEHIGHDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryPracticeLowDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL02EndingText::VT_SUMMARYPRACTICELOWDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL02EndingText<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMutation",
                Self::VT_SUMMARYMUTATION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDice",
                Self::VT_SUMMARYDICE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDiceResultGood",
                Self::VT_SUMMARYDICERESULTGOOD,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDiceResultNormal",
                Self::VT_SUMMARYDICERESULTNORMAL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDiceResultBad",
                Self::VT_SUMMARYDICERESULTBAD,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDiceResultDesc",
                Self::VT_SUMMARYDICERESULTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryCommuDesc",
                Self::VT_SUMMARYCOMMUDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryHiddenDesc",
                Self::VT_SUMMARYHIDDENDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryKnightDesc",
                Self::VT_SUMMARYKNIGHTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryGoldDesc",
                Self::VT_SUMMARYGOLDDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryPracticeDesc",
                Self::VT_SUMMARYPRACTICEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryCommuEmptyDesc",
                Self::VT_SUMMARYCOMMUEMPTYDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryCommuNotEmptyDesc",
                Self::VT_SUMMARYCOMMUNOTEMPTYDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryHiddenPassedDesc",
                Self::VT_SUMMARYHIDDENPASSEDDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryHiddenNotPassedDesc",
                Self::VT_SUMMARYHIDDENNOTPASSEDDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryKnightPassedDesc",
                Self::VT_SUMMARYKNIGHTPASSEDDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryKnightNotPassedDesc",
                Self::VT_SUMMARYKNIGHTNOTPASSEDDESC,
                false,
            )?
            .visit_field::<i32>("summaryGoldThreshold", Self::VT_SUMMARYGOLDTHRESHOLD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryGoldHighDesc",
                Self::VT_SUMMARYGOLDHIGHDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryGoldLowDesc",
                Self::VT_SUMMARYGOLDLOWDESC,
                false,
            )?
            .visit_field::<i32>(
                "summaryPracticeThreshold",
                Self::VT_SUMMARYPRACTICETHRESHOLD,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryPracticeHighDesc",
                Self::VT_SUMMARYPRACTICEHIGHDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryPracticeLowDesc",
                Self::VT_SUMMARYPRACTICELOWDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL02EndingTextArgs<'a> {
    pub summaryMutation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDice: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDiceResultGood: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDiceResultNormal: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDiceResultBad: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDiceResultDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryCommuDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryHiddenDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryKnightDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryGoldDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryPracticeDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryCommuEmptyDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryCommuNotEmptyDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryHiddenPassedDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryHiddenNotPassedDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryKnightPassedDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryKnightNotPassedDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryGoldThreshold: i32,
    pub summaryGoldHighDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryGoldLowDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryPracticeThreshold: i32,
    pub summaryPracticeHighDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryPracticeLowDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RL02EndingTextArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL02EndingTextArgs {
            summaryMutation: None,
            summaryDice: None,
            summaryDiceResultGood: None,
            summaryDiceResultNormal: None,
            summaryDiceResultBad: None,
            summaryDiceResultDesc: None,
            summaryCommuDesc: None,
            summaryHiddenDesc: None,
            summaryKnightDesc: None,
            summaryGoldDesc: None,
            summaryPracticeDesc: None,
            summaryCommuEmptyDesc: None,
            summaryCommuNotEmptyDesc: None,
            summaryHiddenPassedDesc: None,
            summaryHiddenNotPassedDesc: None,
            summaryKnightPassedDesc: None,
            summaryKnightNotPassedDesc: None,
            summaryGoldThreshold: 0,
            summaryGoldHighDesc: None,
            summaryGoldLowDesc: None,
            summaryPracticeThreshold: 0,
            summaryPracticeHighDesc: None,
            summaryPracticeLowDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_RL02EndingText<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL02EndingText", 23)?;
        if let Some(f) = self.summaryMutation() {
            s.serialize_field("summaryMutation", &f)?;
        } else {
            s.skip_field("summaryMutation")?;
        }
        if let Some(f) = self.summaryDice() {
            s.serialize_field("summaryDice", &f)?;
        } else {
            s.skip_field("summaryDice")?;
        }
        if let Some(f) = self.summaryDiceResultGood() {
            s.serialize_field("summaryDiceResultGood", &f)?;
        } else {
            s.skip_field("summaryDiceResultGood")?;
        }
        if let Some(f) = self.summaryDiceResultNormal() {
            s.serialize_field("summaryDiceResultNormal", &f)?;
        } else {
            s.skip_field("summaryDiceResultNormal")?;
        }
        if let Some(f) = self.summaryDiceResultBad() {
            s.serialize_field("summaryDiceResultBad", &f)?;
        } else {
            s.skip_field("summaryDiceResultBad")?;
        }
        if let Some(f) = self.summaryDiceResultDesc() {
            s.serialize_field("summaryDiceResultDesc", &f)?;
        } else {
            s.skip_field("summaryDiceResultDesc")?;
        }
        if let Some(f) = self.summaryCommuDesc() {
            s.serialize_field("summaryCommuDesc", &f)?;
        } else {
            s.skip_field("summaryCommuDesc")?;
        }
        if let Some(f) = self.summaryHiddenDesc() {
            s.serialize_field("summaryHiddenDesc", &f)?;
        } else {
            s.skip_field("summaryHiddenDesc")?;
        }
        if let Some(f) = self.summaryKnightDesc() {
            s.serialize_field("summaryKnightDesc", &f)?;
        } else {
            s.skip_field("summaryKnightDesc")?;
        }
        if let Some(f) = self.summaryGoldDesc() {
            s.serialize_field("summaryGoldDesc", &f)?;
        } else {
            s.skip_field("summaryGoldDesc")?;
        }
        if let Some(f) = self.summaryPracticeDesc() {
            s.serialize_field("summaryPracticeDesc", &f)?;
        } else {
            s.skip_field("summaryPracticeDesc")?;
        }
        if let Some(f) = self.summaryCommuEmptyDesc() {
            s.serialize_field("summaryCommuEmptyDesc", &f)?;
        } else {
            s.skip_field("summaryCommuEmptyDesc")?;
        }
        if let Some(f) = self.summaryCommuNotEmptyDesc() {
            s.serialize_field("summaryCommuNotEmptyDesc", &f)?;
        } else {
            s.skip_field("summaryCommuNotEmptyDesc")?;
        }
        if let Some(f) = self.summaryHiddenPassedDesc() {
            s.serialize_field("summaryHiddenPassedDesc", &f)?;
        } else {
            s.skip_field("summaryHiddenPassedDesc")?;
        }
        if let Some(f) = self.summaryHiddenNotPassedDesc() {
            s.serialize_field("summaryHiddenNotPassedDesc", &f)?;
        } else {
            s.skip_field("summaryHiddenNotPassedDesc")?;
        }
        if let Some(f) = self.summaryKnightPassedDesc() {
            s.serialize_field("summaryKnightPassedDesc", &f)?;
        } else {
            s.skip_field("summaryKnightPassedDesc")?;
        }
        if let Some(f) = self.summaryKnightNotPassedDesc() {
            s.serialize_field("summaryKnightNotPassedDesc", &f)?;
        } else {
            s.skip_field("summaryKnightNotPassedDesc")?;
        }
        s.serialize_field("summaryGoldThreshold", &self.summaryGoldThreshold())?;
        if let Some(f) = self.summaryGoldHighDesc() {
            s.serialize_field("summaryGoldHighDesc", &f)?;
        } else {
            s.skip_field("summaryGoldHighDesc")?;
        }
        if let Some(f) = self.summaryGoldLowDesc() {
            s.serialize_field("summaryGoldLowDesc", &f)?;
        } else {
            s.skip_field("summaryGoldLowDesc")?;
        }
        s.serialize_field("summaryPracticeThreshold", &self.summaryPracticeThreshold())?;
        if let Some(f) = self.summaryPracticeHighDesc() {
            s.serialize_field("summaryPracticeHighDesc", &f)?;
        } else {
            s.skip_field("summaryPracticeHighDesc")?;
        }
        if let Some(f) = self.summaryPracticeLowDesc() {
            s.serialize_field("summaryPracticeLowDesc", &f)?;
        } else {
            s.skip_field("summaryPracticeLowDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL02EndingTextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL02EndingTextBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_summaryMutation(&mut self, summaryMutation: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYMUTATION,
            summaryMutation,
        );
    }
    #[inline]
    pub fn add_summaryDice(&mut self, summaryDice: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYDICE,
            summaryDice,
        );
    }
    #[inline]
    pub fn add_summaryDiceResultGood(
        &mut self,
        summaryDiceResultGood: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYDICERESULTGOOD,
            summaryDiceResultGood,
        );
    }
    #[inline]
    pub fn add_summaryDiceResultNormal(
        &mut self,
        summaryDiceResultNormal: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYDICERESULTNORMAL,
            summaryDiceResultNormal,
        );
    }
    #[inline]
    pub fn add_summaryDiceResultBad(
        &mut self,
        summaryDiceResultBad: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYDICERESULTBAD,
            summaryDiceResultBad,
        );
    }
    #[inline]
    pub fn add_summaryDiceResultDesc(
        &mut self,
        summaryDiceResultDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYDICERESULTDESC,
            summaryDiceResultDesc,
        );
    }
    #[inline]
    pub fn add_summaryCommuDesc(&mut self, summaryCommuDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYCOMMUDESC,
            summaryCommuDesc,
        );
    }
    #[inline]
    pub fn add_summaryHiddenDesc(&mut self, summaryHiddenDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYHIDDENDESC,
            summaryHiddenDesc,
        );
    }
    #[inline]
    pub fn add_summaryKnightDesc(&mut self, summaryKnightDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYKNIGHTDESC,
            summaryKnightDesc,
        );
    }
    #[inline]
    pub fn add_summaryGoldDesc(&mut self, summaryGoldDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYGOLDDESC,
            summaryGoldDesc,
        );
    }
    #[inline]
    pub fn add_summaryPracticeDesc(
        &mut self,
        summaryPracticeDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYPRACTICEDESC,
            summaryPracticeDesc,
        );
    }
    #[inline]
    pub fn add_summaryCommuEmptyDesc(
        &mut self,
        summaryCommuEmptyDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYCOMMUEMPTYDESC,
            summaryCommuEmptyDesc,
        );
    }
    #[inline]
    pub fn add_summaryCommuNotEmptyDesc(
        &mut self,
        summaryCommuNotEmptyDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYCOMMUNOTEMPTYDESC,
            summaryCommuNotEmptyDesc,
        );
    }
    #[inline]
    pub fn add_summaryHiddenPassedDesc(
        &mut self,
        summaryHiddenPassedDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYHIDDENPASSEDDESC,
            summaryHiddenPassedDesc,
        );
    }
    #[inline]
    pub fn add_summaryHiddenNotPassedDesc(
        &mut self,
        summaryHiddenNotPassedDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYHIDDENNOTPASSEDDESC,
            summaryHiddenNotPassedDesc,
        );
    }
    #[inline]
    pub fn add_summaryKnightPassedDesc(
        &mut self,
        summaryKnightPassedDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYKNIGHTPASSEDDESC,
            summaryKnightPassedDesc,
        );
    }
    #[inline]
    pub fn add_summaryKnightNotPassedDesc(
        &mut self,
        summaryKnightNotPassedDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYKNIGHTNOTPASSEDDESC,
            summaryKnightNotPassedDesc,
        );
    }
    #[inline]
    pub fn add_summaryGoldThreshold(&mut self, summaryGoldThreshold: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RL02EndingText::VT_SUMMARYGOLDTHRESHOLD,
            summaryGoldThreshold,
            0,
        );
    }
    #[inline]
    pub fn add_summaryGoldHighDesc(
        &mut self,
        summaryGoldHighDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYGOLDHIGHDESC,
            summaryGoldHighDesc,
        );
    }
    #[inline]
    pub fn add_summaryGoldLowDesc(&mut self, summaryGoldLowDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYGOLDLOWDESC,
            summaryGoldLowDesc,
        );
    }
    #[inline]
    pub fn add_summaryPracticeThreshold(&mut self, summaryPracticeThreshold: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RL02EndingText::VT_SUMMARYPRACTICETHRESHOLD,
            summaryPracticeThreshold,
            0,
        );
    }
    #[inline]
    pub fn add_summaryPracticeHighDesc(
        &mut self,
        summaryPracticeHighDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYPRACTICEHIGHDESC,
            summaryPracticeHighDesc,
        );
    }
    #[inline]
    pub fn add_summaryPracticeLowDesc(
        &mut self,
        summaryPracticeLowDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02EndingText::VT_SUMMARYPRACTICELOWDESC,
            summaryPracticeLowDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL02EndingTextBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL02EndingTextBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL02EndingText<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL02EndingText<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL02EndingText");
        ds.field("summaryMutation", &self.summaryMutation());
        ds.field("summaryDice", &self.summaryDice());
        ds.field("summaryDiceResultGood", &self.summaryDiceResultGood());
        ds.field("summaryDiceResultNormal", &self.summaryDiceResultNormal());
        ds.field("summaryDiceResultBad", &self.summaryDiceResultBad());
        ds.field("summaryDiceResultDesc", &self.summaryDiceResultDesc());
        ds.field("summaryCommuDesc", &self.summaryCommuDesc());
        ds.field("summaryHiddenDesc", &self.summaryHiddenDesc());
        ds.field("summaryKnightDesc", &self.summaryKnightDesc());
        ds.field("summaryGoldDesc", &self.summaryGoldDesc());
        ds.field("summaryPracticeDesc", &self.summaryPracticeDesc());
        ds.field("summaryCommuEmptyDesc", &self.summaryCommuEmptyDesc());
        ds.field("summaryCommuNotEmptyDesc", &self.summaryCommuNotEmptyDesc());
        ds.field("summaryHiddenPassedDesc", &self.summaryHiddenPassedDesc());
        ds.field(
            "summaryHiddenNotPassedDesc",
            &self.summaryHiddenNotPassedDesc(),
        );
        ds.field("summaryKnightPassedDesc", &self.summaryKnightPassedDesc());
        ds.field(
            "summaryKnightNotPassedDesc",
            &self.summaryKnightNotPassedDesc(),
        );
        ds.field("summaryGoldThreshold", &self.summaryGoldThreshold());
        ds.field("summaryGoldHighDesc", &self.summaryGoldHighDesc());
        ds.field("summaryGoldLowDesc", &self.summaryGoldLowDesc());
        ds.field("summaryPracticeThreshold", &self.summaryPracticeThreshold());
        ds.field("summaryPracticeHighDesc", &self.summaryPracticeHighDesc());
        ds.field("summaryPracticeLowDesc", &self.summaryPracticeLowDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL02EndingTextT {
    pub summaryMutation: Option<String>,
    pub summaryDice: Option<String>,
    pub summaryDiceResultGood: Option<String>,
    pub summaryDiceResultNormal: Option<String>,
    pub summaryDiceResultBad: Option<String>,
    pub summaryDiceResultDesc: Option<String>,
    pub summaryCommuDesc: Option<String>,
    pub summaryHiddenDesc: Option<String>,
    pub summaryKnightDesc: Option<String>,
    pub summaryGoldDesc: Option<String>,
    pub summaryPracticeDesc: Option<String>,
    pub summaryCommuEmptyDesc: Option<String>,
    pub summaryCommuNotEmptyDesc: Option<String>,
    pub summaryHiddenPassedDesc: Option<String>,
    pub summaryHiddenNotPassedDesc: Option<String>,
    pub summaryKnightPassedDesc: Option<String>,
    pub summaryKnightNotPassedDesc: Option<String>,
    pub summaryGoldThreshold: i32,
    pub summaryGoldHighDesc: Option<String>,
    pub summaryGoldLowDesc: Option<String>,
    pub summaryPracticeThreshold: i32,
    pub summaryPracticeHighDesc: Option<String>,
    pub summaryPracticeLowDesc: Option<String>,
}
impl Default for clz_Torappu_RL02EndingTextT {
    fn default() -> Self {
        Self {
            summaryMutation: None,
            summaryDice: None,
            summaryDiceResultGood: None,
            summaryDiceResultNormal: None,
            summaryDiceResultBad: None,
            summaryDiceResultDesc: None,
            summaryCommuDesc: None,
            summaryHiddenDesc: None,
            summaryKnightDesc: None,
            summaryGoldDesc: None,
            summaryPracticeDesc: None,
            summaryCommuEmptyDesc: None,
            summaryCommuNotEmptyDesc: None,
            summaryHiddenPassedDesc: None,
            summaryHiddenNotPassedDesc: None,
            summaryKnightPassedDesc: None,
            summaryKnightNotPassedDesc: None,
            summaryGoldThreshold: 0,
            summaryGoldHighDesc: None,
            summaryGoldLowDesc: None,
            summaryPracticeThreshold: 0,
            summaryPracticeHighDesc: None,
            summaryPracticeLowDesc: None,
        }
    }
}
impl clz_Torappu_RL02EndingTextT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL02EndingText<'b>> {
        let summaryMutation = self.summaryMutation.as_ref().map(|x| _fbb.create_string(x));
        let summaryDice = self.summaryDice.as_ref().map(|x| _fbb.create_string(x));
        let summaryDiceResultGood = self
            .summaryDiceResultGood
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDiceResultNormal = self
            .summaryDiceResultNormal
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDiceResultBad = self
            .summaryDiceResultBad
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDiceResultDesc = self
            .summaryDiceResultDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryCommuDesc = self
            .summaryCommuDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryHiddenDesc = self
            .summaryHiddenDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryKnightDesc = self
            .summaryKnightDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryGoldDesc = self.summaryGoldDesc.as_ref().map(|x| _fbb.create_string(x));
        let summaryPracticeDesc = self
            .summaryPracticeDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryCommuEmptyDesc = self
            .summaryCommuEmptyDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryCommuNotEmptyDesc = self
            .summaryCommuNotEmptyDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryHiddenPassedDesc = self
            .summaryHiddenPassedDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryHiddenNotPassedDesc = self
            .summaryHiddenNotPassedDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryKnightPassedDesc = self
            .summaryKnightPassedDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryKnightNotPassedDesc = self
            .summaryKnightNotPassedDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryGoldThreshold = self.summaryGoldThreshold;
        let summaryGoldHighDesc = self
            .summaryGoldHighDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryGoldLowDesc = self
            .summaryGoldLowDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryPracticeThreshold = self.summaryPracticeThreshold;
        let summaryPracticeHighDesc = self
            .summaryPracticeHighDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryPracticeLowDesc = self
            .summaryPracticeLowDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RL02EndingText::create(
            _fbb,
            &clz_Torappu_RL02EndingTextArgs {
                summaryMutation,
                summaryDice,
                summaryDiceResultGood,
                summaryDiceResultNormal,
                summaryDiceResultBad,
                summaryDiceResultDesc,
                summaryCommuDesc,
                summaryHiddenDesc,
                summaryKnightDesc,
                summaryGoldDesc,
                summaryPracticeDesc,
                summaryCommuEmptyDesc,
                summaryCommuNotEmptyDesc,
                summaryHiddenPassedDesc,
                summaryHiddenNotPassedDesc,
                summaryKnightPassedDesc,
                summaryKnightNotPassedDesc,
                summaryGoldThreshold,
                summaryGoldHighDesc,
                summaryGoldLowDesc,
                summaryPracticeThreshold,
                summaryPracticeHighDesc,
                summaryPracticeLowDesc,
            },
        )
    }
}
pub enum clz_Torappu_RL02DifficultyExtOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL02DifficultyExt<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL02DifficultyExt<'a> {
    type Inner = clz_Torappu_RL02DifficultyExt<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL02DifficultyExt<'a> {
    pub const VT_MODEDIFFICULTY: flatbuffers::VOffsetT = 4;
    pub const VT_GRADE: flatbuffers::VOffsetT = 6;
    pub const VT_BUFFDESC: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL02DifficultyExt { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL02DifficultyExtArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL02DifficultyExt<'bldr>> {
        let mut builder = clz_Torappu_RL02DifficultyExtBuilder::new(_fbb);
        if let Some(x) = args.buffDesc {
            builder.add_buffDesc(x);
        }
        builder.add_grade(args.grade);
        builder.add_modeDifficulty(args.modeDifficulty);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL02DifficultyExtT {
        let modeDifficulty = self.modeDifficulty();
        let grade = self.grade();
        let buffDesc = self
            .buffDesc()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_RL02DifficultyExtT {
            modeDifficulty,
            grade,
            buffDesc,
        }
    }

    #[inline]
    pub fn modeDifficulty(&self) -> enum__Torappu_RoguelikeTopicMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTopicMode>(
                    clz_Torappu_RL02DifficultyExt::VT_MODEDIFFICULTY,
                    Some(enum__Torappu_RoguelikeTopicMode::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn grade(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL02DifficultyExt::VT_GRADE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn buffDesc(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RL02DifficultyExt::VT_BUFFDESC, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL02DifficultyExt<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeTopicMode>(
                "modeDifficulty",
                Self::VT_MODEDIFFICULTY,
                false,
            )?
            .visit_field::<i32>("grade", Self::VT_GRADE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("buffDesc", Self::VT_BUFFDESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL02DifficultyExtArgs<'a> {
    pub modeDifficulty: enum__Torappu_RoguelikeTopicMode,
    pub grade: i32,
    pub buffDesc: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_RL02DifficultyExtArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL02DifficultyExtArgs {
            modeDifficulty: enum__Torappu_RoguelikeTopicMode::NONE,
            grade: 0,
            buffDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_RL02DifficultyExt<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL02DifficultyExt", 3)?;
        s.serialize_field("modeDifficulty", &self.modeDifficulty())?;
        s.serialize_field("grade", &self.grade())?;
        if let Some(f) = self.buffDesc() {
            s.serialize_field("buffDesc", &f)?;
        } else {
            s.skip_field("buffDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL02DifficultyExtBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL02DifficultyExtBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_modeDifficulty(&mut self, modeDifficulty: enum__Torappu_RoguelikeTopicMode) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeTopicMode>(
            clz_Torappu_RL02DifficultyExt::VT_MODEDIFFICULTY,
            modeDifficulty,
            enum__Torappu_RoguelikeTopicMode::NONE,
        );
    }
    #[inline]
    pub fn add_grade(&mut self, grade: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL02DifficultyExt::VT_GRADE, grade, 0);
    }
    #[inline]
    pub fn add_buffDesc(
        &mut self,
        buffDesc: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02DifficultyExt::VT_BUFFDESC,
            buffDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL02DifficultyExtBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL02DifficultyExtBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL02DifficultyExt<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL02DifficultyExt<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL02DifficultyExt");
        ds.field("modeDifficulty", &self.modeDifficulty());
        ds.field("grade", &self.grade());
        ds.field("buffDesc", &self.buffDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL02DifficultyExtT {
    pub modeDifficulty: enum__Torappu_RoguelikeTopicMode,
    pub grade: i32,
    pub buffDesc: Option<Vec<String>>,
}
impl Default for clz_Torappu_RL02DifficultyExtT {
    fn default() -> Self {
        Self {
            modeDifficulty: enum__Torappu_RoguelikeTopicMode::NONE,
            grade: 0,
            buffDesc: None,
        }
    }
}
impl clz_Torappu_RL02DifficultyExtT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL02DifficultyExt<'b>> {
        let modeDifficulty = self.modeDifficulty;
        let grade = self.grade;
        let buffDesc = self.buffDesc.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RL02DifficultyExt::create(
            _fbb,
            &clz_Torappu_RL02DifficultyExtArgs {
                modeDifficulty,
                grade,
                buffDesc,
            },
        )
    }
}
pub enum clz_Torappu_RL02CustomizeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL02CustomizeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL02CustomizeData<'a> {
    type Inner = clz_Torappu_RL02CustomizeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL02CustomizeData<'a> {
    pub const VT_DEVELOPMENTS: flatbuffers::VOffsetT = 4;
    pub const VT_DEVELOPMENTTOKENS: flatbuffers::VOffsetT = 6;
    pub const VT_DEVELOPMENTRAWTEXTGROUP: flatbuffers::VOffsetT = 8;
    pub const VT_DEVELOPMENTLINES: flatbuffers::VOffsetT = 10;
    pub const VT_ENDINGTEXT: flatbuffers::VOffsetT = 12;
    pub const VT_DIFFICULTIES: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL02CustomizeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL02CustomizeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL02CustomizeData<'bldr>> {
        let mut builder = clz_Torappu_RL02CustomizeDataBuilder::new(_fbb);
        if let Some(x) = args.difficulties {
            builder.add_difficulties(x);
        }
        if let Some(x) = args.endingText {
            builder.add_endingText(x);
        }
        if let Some(x) = args.developmentLines {
            builder.add_developmentLines(x);
        }
        if let Some(x) = args.developmentRawTextGroup {
            builder.add_developmentRawTextGroup(x);
        }
        if let Some(x) = args.developmentTokens {
            builder.add_developmentTokens(x);
        }
        if let Some(x) = args.developments {
            builder.add_developments(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL02CustomizeDataT {
        let developments = self
            .developments()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let developmentTokens = self
            .developmentTokens()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let developmentRawTextGroup = self
            .developmentRawTextGroup()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let developmentLines = self
            .developmentLines()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let endingText = self.endingText().map(|x| Box::new(x.unpack()));
        let difficulties = self
            .difficulties()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RL02CustomizeDataT {
            developments,
            developmentTokens,
            developmentRawTextGroup,
            developmentLines,
            endingText,
            difficulties,
        }
    }

    #[inline]
    pub fn developments(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RL02Development<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RL02Development>,
                >,
            >>(clz_Torappu_RL02CustomizeData::VT_DEVELOPMENTS, None)
        }
    }
    #[inline]
    pub fn developmentTokens(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken>,
                >,
            >>(clz_Torappu_RL02CustomizeData::VT_DEVELOPMENTTOKENS, None)
        }
    }
    #[inline]
    pub fn developmentRawTextGroup(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RL02DevRawTextBuffGroup<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL02DevRawTextBuffGroup>,
                >,
            >>(
                clz_Torappu_RL02CustomizeData::VT_DEVELOPMENTRAWTEXTGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn developmentLines(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RL02DevelopmentLine<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL02DevelopmentLine>,
                >,
            >>(clz_Torappu_RL02CustomizeData::VT_DEVELOPMENTLINES, None)
        }
    }
    #[inline]
    pub fn endingText(&self) -> Option<clz_Torappu_RL02EndingText<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RL02EndingText>>(
                    clz_Torappu_RL02CustomizeData::VT_ENDINGTEXT,
                    None,
                )
        }
    }
    #[inline]
    pub fn difficulties(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RL02DifficultyExt<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL02DifficultyExt>,
                >,
            >>(clz_Torappu_RL02CustomizeData::VT_DIFFICULTIES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL02CustomizeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RL02Development>,
                >,
            >>("developments", Self::VT_DEVELOPMENTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken>,
                >,
            >>("developmentTokens", Self::VT_DEVELOPMENTTOKENS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL02DevRawTextBuffGroup>,
                >,
            >>(
                "developmentRawTextGroup",
                Self::VT_DEVELOPMENTRAWTEXTGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL02DevelopmentLine>,
                >,
            >>("developmentLines", Self::VT_DEVELOPMENTLINES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RL02EndingText>>(
                "endingText",
                Self::VT_ENDINGTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL02DifficultyExt>,
                >,
            >>("difficulties", Self::VT_DIFFICULTIES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL02CustomizeDataArgs<'a> {
    pub developments: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RL02Development<'a>>,
            >,
        >,
    >,
    pub developmentTokens: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken<'a>>,
            >,
        >,
    >,
    pub developmentRawTextGroup: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL02DevRawTextBuffGroup<'a>>,
            >,
        >,
    >,
    pub developmentLines: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL02DevelopmentLine<'a>>,
            >,
        >,
    >,
    pub endingText: Option<flatbuffers::WIPOffset<clz_Torappu_RL02EndingText<'a>>>,
    pub difficulties: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL02DifficultyExt<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RL02CustomizeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL02CustomizeDataArgs {
            developments: None,
            developmentTokens: None,
            developmentRawTextGroup: None,
            developmentLines: None,
            endingText: None,
            difficulties: None,
        }
    }
}

impl Serialize for clz_Torappu_RL02CustomizeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL02CustomizeData", 6)?;
        if let Some(f) = self.developments() {
            s.serialize_field("developments", &f)?;
        } else {
            s.skip_field("developments")?;
        }
        if let Some(f) = self.developmentTokens() {
            s.serialize_field("developmentTokens", &f)?;
        } else {
            s.skip_field("developmentTokens")?;
        }
        if let Some(f) = self.developmentRawTextGroup() {
            s.serialize_field("developmentRawTextGroup", &f)?;
        } else {
            s.skip_field("developmentRawTextGroup")?;
        }
        if let Some(f) = self.developmentLines() {
            s.serialize_field("developmentLines", &f)?;
        } else {
            s.skip_field("developmentLines")?;
        }
        if let Some(f) = self.endingText() {
            s.serialize_field("endingText", &f)?;
        } else {
            s.skip_field("endingText")?;
        }
        if let Some(f) = self.difficulties() {
            s.serialize_field("difficulties", &f)?;
        } else {
            s.skip_field("difficulties")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL02CustomizeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL02CustomizeDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_developments(
        &mut self,
        developments: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RL02Development<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02CustomizeData::VT_DEVELOPMENTS,
            developments,
        );
    }
    #[inline]
    pub fn add_developmentTokens(
        &mut self,
        developmentTokens: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02CustomizeData::VT_DEVELOPMENTTOKENS,
            developmentTokens,
        );
    }
    #[inline]
    pub fn add_developmentRawTextGroup(
        &mut self,
        developmentRawTextGroup: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL02DevRawTextBuffGroup<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02CustomizeData::VT_DEVELOPMENTRAWTEXTGROUP,
            developmentRawTextGroup,
        );
    }
    #[inline]
    pub fn add_developmentLines(
        &mut self,
        developmentLines: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL02DevelopmentLine<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02CustomizeData::VT_DEVELOPMENTLINES,
            developmentLines,
        );
    }
    #[inline]
    pub fn add_endingText(
        &mut self,
        endingText: flatbuffers::WIPOffset<clz_Torappu_RL02EndingText<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RL02EndingText>>(
                clz_Torappu_RL02CustomizeData::VT_ENDINGTEXT,
                endingText,
            );
    }
    #[inline]
    pub fn add_difficulties(
        &mut self,
        difficulties: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL02DifficultyExt<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL02CustomizeData::VT_DIFFICULTIES,
            difficulties,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL02CustomizeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL02CustomizeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL02CustomizeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL02CustomizeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL02CustomizeData");
        ds.field("developments", &self.developments());
        ds.field("developmentTokens", &self.developmentTokens());
        ds.field("developmentRawTextGroup", &self.developmentRawTextGroup());
        ds.field("developmentLines", &self.developmentLines());
        ds.field("endingText", &self.endingText());
        ds.field("difficulties", &self.difficulties());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL02CustomizeDataT {
    pub developments: Option<Vec<dict__string__clz_Torappu_RL02DevelopmentT>>,
    pub developmentTokens: Option<Vec<dict__string__clz_Torappu_RoguelikeTopicDevTokenT>>,
    pub developmentRawTextGroup: Option<Vec<clz_Torappu_RL02DevRawTextBuffGroupT>>,
    pub developmentLines: Option<Vec<clz_Torappu_RL02DevelopmentLineT>>,
    pub endingText: Option<Box<clz_Torappu_RL02EndingTextT>>,
    pub difficulties: Option<Vec<clz_Torappu_RL02DifficultyExtT>>,
}
impl Default for clz_Torappu_RL02CustomizeDataT {
    fn default() -> Self {
        Self {
            developments: None,
            developmentTokens: None,
            developmentRawTextGroup: None,
            developmentLines: None,
            endingText: None,
            difficulties: None,
        }
    }
}
impl clz_Torappu_RL02CustomizeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL02CustomizeData<'b>> {
        let developments = self.developments.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let developmentTokens = self.developmentTokens.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let developmentRawTextGroup = self.developmentRawTextGroup.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let developmentLines = self.developmentLines.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let endingText = self.endingText.as_ref().map(|x| x.pack(_fbb));
        let difficulties = self.difficulties.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RL02CustomizeData::create(
            _fbb,
            &clz_Torappu_RL02CustomizeDataArgs {
                developments,
                developmentTokens,
                developmentRawTextGroup,
                developmentLines,
                endingText,
                difficulties,
            },
        )
    }
}
pub enum clz_Torappu_RL03DevelopmentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL03Development<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL03Development<'a> {
    type Inner = clz_Torappu_RL03Development<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL03Development<'a> {
    pub const VT_BUFFID: flatbuffers::VOffsetT = 4;
    pub const VT_NODETYPE: flatbuffers::VOffsetT = 6;
    pub const VT_FRONTNODEID: flatbuffers::VOffsetT = 8;
    pub const VT_NEXTNODEID: flatbuffers::VOffsetT = 10;
    pub const VT_POSITIONROW: flatbuffers::VOffsetT = 12;
    pub const VT_POSITIONORDER: flatbuffers::VOffsetT = 14;
    pub const VT_TOKENCOST: flatbuffers::VOffsetT = 16;
    pub const VT_BUFFNAME: flatbuffers::VOffsetT = 18;
    pub const VT_BUFFICONID: flatbuffers::VOffsetT = 20;
    pub const VT_EFFECTTYPE: flatbuffers::VOffsetT = 22;
    pub const VT_RAWDESC: flatbuffers::VOffsetT = 24;
    pub const VT_BUFFDISPLAYINFO: flatbuffers::VOffsetT = 26;
    pub const VT_GROUPID: flatbuffers::VOffsetT = 28;
    pub const VT_ENROLLID: flatbuffers::VOffsetT = 30;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL03Development { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL03DevelopmentArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL03Development<'bldr>> {
        let mut builder = clz_Torappu_RL03DevelopmentBuilder::new(_fbb);
        if let Some(x) = args.enrollId {
            builder.add_enrollId(x);
        }
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        if let Some(x) = args.buffDisplayInfo {
            builder.add_buffDisplayInfo(x);
        }
        if let Some(x) = args.rawDesc {
            builder.add_rawDesc(x);
        }
        builder.add_effectType(args.effectType);
        if let Some(x) = args.buffIconId {
            builder.add_buffIconId(x);
        }
        if let Some(x) = args.buffName {
            builder.add_buffName(x);
        }
        builder.add_tokenCost(args.tokenCost);
        builder.add_positionOrder(args.positionOrder);
        builder.add_positionRow(args.positionRow);
        if let Some(x) = args.nextNodeId {
            builder.add_nextNodeId(x);
        }
        if let Some(x) = args.frontNodeId {
            builder.add_frontNodeId(x);
        }
        builder.add_nodeType(args.nodeType);
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL03DevelopmentT {
        let buffId = self.buffId().map(|x| x.to_string());
        let nodeType = self.nodeType();
        let frontNodeId = self
            .frontNodeId()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let nextNodeId = self
            .nextNodeId()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let positionRow = self.positionRow();
        let positionOrder = self.positionOrder();
        let tokenCost = self.tokenCost();
        let buffName = self.buffName().map(|x| x.to_string());
        let buffIconId = self.buffIconId().map(|x| x.to_string());
        let effectType = self.effectType();
        let rawDesc = self
            .rawDesc()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let buffDisplayInfo = self
            .buffDisplayInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let groupId = self.groupId().map(|x| x.to_string());
        let enrollId = self.enrollId().map(|x| x.to_string());
        clz_Torappu_RL03DevelopmentT {
            buffId,
            nodeType,
            frontNodeId,
            nextNodeId,
            positionRow,
            positionOrder,
            tokenCost,
            buffName,
            buffIconId,
            effectType,
            rawDesc,
            buffDisplayInfo,
            groupId,
            enrollId,
        }
    }

    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03Development::VT_BUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeType(&self) -> enum__Torappu_RL03DevelopmentNodeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RL03DevelopmentNodeType>(
                    clz_Torappu_RL03Development::VT_NODETYPE,
                    Some(enum__Torappu_RL03DevelopmentNodeType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn frontNodeId(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RL03Development::VT_FRONTNODEID, None)
        }
    }
    #[inline]
    pub fn nextNodeId(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RL03Development::VT_NEXTNODEID, None)
        }
    }
    #[inline]
    pub fn positionRow(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL03Development::VT_POSITIONROW, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn positionOrder(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL03Development::VT_POSITIONORDER, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn tokenCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL03Development::VT_TOKENCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn buffName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03Development::VT_BUFFNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn buffIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03Development::VT_BUFFICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn effectType(&self) -> enum__Torappu_RL03DevelopmentEffectType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RL03DevelopmentEffectType>(
                    clz_Torappu_RL03Development::VT_EFFECTTYPE,
                    Some(enum__Torappu_RL03DevelopmentEffectType::BUFF),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rawDesc(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RL03Development::VT_RAWDESC, None)
        }
    }
    #[inline]
    pub fn buffDisplayInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem>,
                >,
            >>(clz_Torappu_RL03Development::VT_BUFFDISPLAYINFO, None)
        }
    }
    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03Development::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn enrollId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03Development::VT_ENROLLID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL03Development<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .visit_field::<enum__Torappu_RL03DevelopmentNodeType>(
                "nodeType",
                Self::VT_NODETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("frontNodeId", Self::VT_FRONTNODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("nextNodeId", Self::VT_NEXTNODEID, false)?
            .visit_field::<i32>("positionRow", Self::VT_POSITIONROW, false)?
            .visit_field::<i32>("positionOrder", Self::VT_POSITIONORDER, false)?
            .visit_field::<i32>("tokenCost", Self::VT_TOKENCOST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffName",
                Self::VT_BUFFNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffIconId",
                Self::VT_BUFFICONID,
                false,
            )?
            .visit_field::<enum__Torappu_RL03DevelopmentEffectType>(
                "effectType",
                Self::VT_EFFECTTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("rawDesc", Self::VT_RAWDESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem>,
                >,
            >>("buffDisplayInfo", Self::VT_BUFFDISPLAYINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollId",
                Self::VT_ENROLLID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL03DevelopmentArgs<'a> {
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeType: enum__Torappu_RL03DevelopmentNodeType,
    pub frontNodeId: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub nextNodeId: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub positionRow: i32,
    pub positionOrder: i32,
    pub tokenCost: i32,
    pub buffName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub effectType: enum__Torappu_RL03DevelopmentEffectType,
    pub rawDesc: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub buffDisplayInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem<'a>>,
            >,
        >,
    >,
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enrollId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RL03DevelopmentArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL03DevelopmentArgs {
            buffId: None,
            nodeType: enum__Torappu_RL03DevelopmentNodeType::NONE,
            frontNodeId: None,
            nextNodeId: None,
            positionRow: 0,
            positionOrder: 0,
            tokenCost: 0,
            buffName: None,
            buffIconId: None,
            effectType: enum__Torappu_RL03DevelopmentEffectType::BUFF,
            rawDesc: None,
            buffDisplayInfo: None,
            groupId: None,
            enrollId: None,
        }
    }
}

impl Serialize for clz_Torappu_RL03Development<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL03Development", 14)?;
        if let Some(f) = self.buffId() {
            s.serialize_field("buffId", &f)?;
        } else {
            s.skip_field("buffId")?;
        }
        s.serialize_field("nodeType", &self.nodeType())?;
        if let Some(f) = self.frontNodeId() {
            s.serialize_field("frontNodeId", &f)?;
        } else {
            s.skip_field("frontNodeId")?;
        }
        if let Some(f) = self.nextNodeId() {
            s.serialize_field("nextNodeId", &f)?;
        } else {
            s.skip_field("nextNodeId")?;
        }
        s.serialize_field("positionRow", &self.positionRow())?;
        s.serialize_field("positionOrder", &self.positionOrder())?;
        s.serialize_field("tokenCost", &self.tokenCost())?;
        if let Some(f) = self.buffName() {
            s.serialize_field("buffName", &f)?;
        } else {
            s.skip_field("buffName")?;
        }
        if let Some(f) = self.buffIconId() {
            s.serialize_field("buffIconId", &f)?;
        } else {
            s.skip_field("buffIconId")?;
        }
        s.serialize_field("effectType", &self.effectType())?;
        if let Some(f) = self.rawDesc() {
            s.serialize_field("rawDesc", &f)?;
        } else {
            s.skip_field("rawDesc")?;
        }
        if let Some(f) = self.buffDisplayInfo() {
            s.serialize_field("buffDisplayInfo", &f)?;
        } else {
            s.skip_field("buffDisplayInfo")?;
        }
        if let Some(f) = self.groupId() {
            s.serialize_field("groupId", &f)?;
        } else {
            s.skip_field("groupId")?;
        }
        if let Some(f) = self.enrollId() {
            s.serialize_field("enrollId", &f)?;
        } else {
            s.skip_field("enrollId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL03DevelopmentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL03DevelopmentBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03Development::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn add_nodeType(&mut self, nodeType: enum__Torappu_RL03DevelopmentNodeType) {
        self.fbb_
            .push_slot::<enum__Torappu_RL03DevelopmentNodeType>(
                clz_Torappu_RL03Development::VT_NODETYPE,
                nodeType,
                enum__Torappu_RL03DevelopmentNodeType::NONE,
            );
    }
    #[inline]
    pub fn add_frontNodeId(
        &mut self,
        frontNodeId: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03Development::VT_FRONTNODEID,
            frontNodeId,
        );
    }
    #[inline]
    pub fn add_nextNodeId(
        &mut self,
        nextNodeId: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03Development::VT_NEXTNODEID,
            nextNodeId,
        );
    }
    #[inline]
    pub fn add_positionRow(&mut self, positionRow: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL03Development::VT_POSITIONROW, positionRow, 0);
    }
    #[inline]
    pub fn add_positionOrder(&mut self, positionOrder: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RL03Development::VT_POSITIONORDER,
            positionOrder,
            0,
        );
    }
    #[inline]
    pub fn add_tokenCost(&mut self, tokenCost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL03Development::VT_TOKENCOST, tokenCost, 0);
    }
    #[inline]
    pub fn add_buffName(&mut self, buffName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03Development::VT_BUFFNAME,
            buffName,
        );
    }
    #[inline]
    pub fn add_buffIconId(&mut self, buffIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03Development::VT_BUFFICONID,
            buffIconId,
        );
    }
    #[inline]
    pub fn add_effectType(&mut self, effectType: enum__Torappu_RL03DevelopmentEffectType) {
        self.fbb_
            .push_slot::<enum__Torappu_RL03DevelopmentEffectType>(
                clz_Torappu_RL03Development::VT_EFFECTTYPE,
                effectType,
                enum__Torappu_RL03DevelopmentEffectType::BUFF,
            );
    }
    #[inline]
    pub fn add_rawDesc(
        &mut self,
        rawDesc: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03Development::VT_RAWDESC,
            rawDesc,
        );
    }
    #[inline]
    pub fn add_buffDisplayInfo(
        &mut self,
        buffDisplayInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03Development::VT_BUFFDISPLAYINFO,
            buffDisplayInfo,
        );
    }
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03Development::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_enrollId(&mut self, enrollId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03Development::VT_ENROLLID,
            enrollId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL03DevelopmentBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL03DevelopmentBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL03Development<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL03Development<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL03Development");
        ds.field("buffId", &self.buffId());
        ds.field("nodeType", &self.nodeType());
        ds.field("frontNodeId", &self.frontNodeId());
        ds.field("nextNodeId", &self.nextNodeId());
        ds.field("positionRow", &self.positionRow());
        ds.field("positionOrder", &self.positionOrder());
        ds.field("tokenCost", &self.tokenCost());
        ds.field("buffName", &self.buffName());
        ds.field("buffIconId", &self.buffIconId());
        ds.field("effectType", &self.effectType());
        ds.field("rawDesc", &self.rawDesc());
        ds.field("buffDisplayInfo", &self.buffDisplayInfo());
        ds.field("groupId", &self.groupId());
        ds.field("enrollId", &self.enrollId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL03DevelopmentT {
    pub buffId: Option<String>,
    pub nodeType: enum__Torappu_RL03DevelopmentNodeType,
    pub frontNodeId: Option<Vec<String>>,
    pub nextNodeId: Option<Vec<String>>,
    pub positionRow: i32,
    pub positionOrder: i32,
    pub tokenCost: i32,
    pub buffName: Option<String>,
    pub buffIconId: Option<String>,
    pub effectType: enum__Torappu_RL03DevelopmentEffectType,
    pub rawDesc: Option<Vec<String>>,
    pub buffDisplayInfo: Option<Vec<clz_Torappu_RoguelikeTopicDisplayItemT>>,
    pub groupId: Option<String>,
    pub enrollId: Option<String>,
}
impl Default for clz_Torappu_RL03DevelopmentT {
    fn default() -> Self {
        Self {
            buffId: None,
            nodeType: enum__Torappu_RL03DevelopmentNodeType::NONE,
            frontNodeId: None,
            nextNodeId: None,
            positionRow: 0,
            positionOrder: 0,
            tokenCost: 0,
            buffName: None,
            buffIconId: None,
            effectType: enum__Torappu_RL03DevelopmentEffectType::BUFF,
            rawDesc: None,
            buffDisplayInfo: None,
            groupId: None,
            enrollId: None,
        }
    }
}
impl clz_Torappu_RL03DevelopmentT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL03Development<'b>> {
        let buffId = self.buffId.as_ref().map(|x| _fbb.create_string(x));
        let nodeType = self.nodeType;
        let frontNodeId = self.frontNodeId.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let nextNodeId = self.nextNodeId.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let positionRow = self.positionRow;
        let positionOrder = self.positionOrder;
        let tokenCost = self.tokenCost;
        let buffName = self.buffName.as_ref().map(|x| _fbb.create_string(x));
        let buffIconId = self.buffIconId.as_ref().map(|x| _fbb.create_string(x));
        let effectType = self.effectType;
        let rawDesc = self.rawDesc.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let buffDisplayInfo = self.buffDisplayInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let groupId = self.groupId.as_ref().map(|x| _fbb.create_string(x));
        let enrollId = self.enrollId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RL03Development::create(
            _fbb,
            &clz_Torappu_RL03DevelopmentArgs {
                buffId,
                nodeType,
                frontNodeId,
                nextNodeId,
                positionRow,
                positionOrder,
                tokenCost,
                buffName,
                buffIconId,
                effectType,
                rawDesc,
                buffDisplayInfo,
                groupId,
                enrollId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RL03DevelopmentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RL03Development<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RL03Development<'a> {
    type Inner = dict__string__clz_Torappu_RL03Development<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RL03Development<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RL03Development { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RL03DevelopmentArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RL03Development<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RL03DevelopmentBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RL03DevelopmentT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RL03DevelopmentT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RL03Development::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_RL03Development) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RL03Development<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RL03Development>>(
                    dict__string__clz_Torappu_RL03Development::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RL03Development<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RL03Development>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RL03DevelopmentArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RL03Development<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RL03DevelopmentArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RL03DevelopmentArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RL03Development<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_RL03Development", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RL03DevelopmentBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RL03DevelopmentBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RL03Development::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_RL03Development<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RL03Development>>(
                dict__string__clz_Torappu_RL03Development::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RL03DevelopmentBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RL03DevelopmentBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RL03Development<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_RL03Development::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RL03Development<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RL03Development");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RL03DevelopmentT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RL03DevelopmentT>>,
}
impl Default for dict__string__clz_Torappu_RL03DevelopmentT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RL03DevelopmentT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RL03Development<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RL03Development::create(
            _fbb,
            &dict__string__clz_Torappu_RL03DevelopmentArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RL03DevRawTextBuffGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL03DevRawTextBuffGroup<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL03DevRawTextBuffGroup<'a> {
    type Inner = clz_Torappu_RL03DevRawTextBuffGroup<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL03DevRawTextBuffGroup<'a> {
    pub const VT_NODEIDLIST: flatbuffers::VOffsetT = 4;
    pub const VT_USELEVELMARK: flatbuffers::VOffsetT = 6;
    pub const VT_GROUPICONID: flatbuffers::VOffsetT = 8;
    pub const VT_SORTID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL03DevRawTextBuffGroup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL03DevRawTextBuffGroupArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL03DevRawTextBuffGroup<'bldr>> {
        let mut builder = clz_Torappu_RL03DevRawTextBuffGroupBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.groupIconId {
            builder.add_groupIconId(x);
        }
        if let Some(x) = args.nodeIdList {
            builder.add_nodeIdList(x);
        }
        builder.add_useLevelMark(args.useLevelMark);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL03DevRawTextBuffGroupT {
        let nodeIdList = self
            .nodeIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let useLevelMark = self.useLevelMark();
        let groupIconId = self.groupIconId().map(|x| x.to_string());
        let sortId = self.sortId();
        clz_Torappu_RL03DevRawTextBuffGroupT {
            nodeIdList,
            useLevelMark,
            groupIconId,
            sortId,
        }
    }

    #[inline]
    pub fn nodeIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RL03DevRawTextBuffGroup::VT_NODEIDLIST, None)
        }
    }
    #[inline]
    pub fn useLevelMark(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RL03DevRawTextBuffGroup::VT_USELEVELMARK,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn groupIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03DevRawTextBuffGroup::VT_GROUPICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL03DevRawTextBuffGroup::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL03DevRawTextBuffGroup<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("nodeIdList", Self::VT_NODEIDLIST, false)?
            .visit_field::<bool>("useLevelMark", Self::VT_USELEVELMARK, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "groupIconId",
                Self::VT_GROUPICONID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL03DevRawTextBuffGroupArgs<'a> {
    pub nodeIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub useLevelMark: bool,
    pub groupIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_RL03DevRawTextBuffGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL03DevRawTextBuffGroupArgs {
            nodeIdList: None,
            useLevelMark: false,
            groupIconId: None,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_RL03DevRawTextBuffGroup<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL03DevRawTextBuffGroup", 4)?;
        if let Some(f) = self.nodeIdList() {
            s.serialize_field("nodeIdList", &f)?;
        } else {
            s.skip_field("nodeIdList")?;
        }
        s.serialize_field("useLevelMark", &self.useLevelMark())?;
        if let Some(f) = self.groupIconId() {
            s.serialize_field("groupIconId", &f)?;
        } else {
            s.skip_field("groupIconId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_RL03DevRawTextBuffGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RL03DevRawTextBuffGroupBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeIdList(
        &mut self,
        nodeIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03DevRawTextBuffGroup::VT_NODEIDLIST,
            nodeIdList,
        );
    }
    #[inline]
    pub fn add_useLevelMark(&mut self, useLevelMark: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RL03DevRawTextBuffGroup::VT_USELEVELMARK,
            useLevelMark,
            false,
        );
    }
    #[inline]
    pub fn add_groupIconId(&mut self, groupIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03DevRawTextBuffGroup::VT_GROUPICONID,
            groupIconId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL03DevRawTextBuffGroup::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL03DevRawTextBuffGroupBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL03DevRawTextBuffGroupBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL03DevRawTextBuffGroup<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL03DevRawTextBuffGroup<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL03DevRawTextBuffGroup");
        ds.field("nodeIdList", &self.nodeIdList());
        ds.field("useLevelMark", &self.useLevelMark());
        ds.field("groupIconId", &self.groupIconId());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL03DevRawTextBuffGroupT {
    pub nodeIdList: Option<Vec<String>>,
    pub useLevelMark: bool,
    pub groupIconId: Option<String>,
    pub sortId: i32,
}
impl Default for clz_Torappu_RL03DevRawTextBuffGroupT {
    fn default() -> Self {
        Self {
            nodeIdList: None,
            useLevelMark: false,
            groupIconId: None,
            sortId: 0,
        }
    }
}
impl clz_Torappu_RL03DevRawTextBuffGroupT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL03DevRawTextBuffGroup<'b>> {
        let nodeIdList = self.nodeIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let useLevelMark = self.useLevelMark;
        let groupIconId = self.groupIconId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        clz_Torappu_RL03DevRawTextBuffGroup::create(
            _fbb,
            &clz_Torappu_RL03DevRawTextBuffGroupArgs {
                nodeIdList,
                useLevelMark,
                groupIconId,
                sortId,
            },
        )
    }
}
pub enum clz_Torappu_RL03DevDifficultyNodePairInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL03DevDifficultyNodePairInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL03DevDifficultyNodePairInfo<'a> {
    type Inner = clz_Torappu_RL03DevDifficultyNodePairInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL03DevDifficultyNodePairInfo<'a> {
    pub const VT_FRONTNODE: flatbuffers::VOffsetT = 4;
    pub const VT_NEXTNODE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL03DevDifficultyNodePairInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL03DevDifficultyNodePairInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL03DevDifficultyNodePairInfo<'bldr>> {
        let mut builder = clz_Torappu_RL03DevDifficultyNodePairInfoBuilder::new(_fbb);
        if let Some(x) = args.nextNode {
            builder.add_nextNode(x);
        }
        if let Some(x) = args.frontNode {
            builder.add_frontNode(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL03DevDifficultyNodePairInfoT {
        let frontNode = self.frontNode().map(|x| x.to_string());
        let nextNode = self.nextNode().map(|x| x.to_string());
        clz_Torappu_RL03DevDifficultyNodePairInfoT {
            frontNode,
            nextNode,
        }
    }

    #[inline]
    pub fn frontNode(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03DevDifficultyNodePairInfo::VT_FRONTNODE,
                None,
            )
        }
    }
    #[inline]
    pub fn nextNode(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03DevDifficultyNodePairInfo::VT_NEXTNODE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL03DevDifficultyNodePairInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "frontNode",
                Self::VT_FRONTNODE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nextNode",
                Self::VT_NEXTNODE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL03DevDifficultyNodePairInfoArgs<'a> {
    pub frontNode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nextNode: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RL03DevDifficultyNodePairInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL03DevDifficultyNodePairInfoArgs {
            frontNode: None,
            nextNode: None,
        }
    }
}

impl Serialize for clz_Torappu_RL03DevDifficultyNodePairInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL03DevDifficultyNodePairInfo", 2)?;
        if let Some(f) = self.frontNode() {
            s.serialize_field("frontNode", &f)?;
        } else {
            s.skip_field("frontNode")?;
        }
        if let Some(f) = self.nextNode() {
            s.serialize_field("nextNode", &f)?;
        } else {
            s.skip_field("nextNode")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL03DevDifficultyNodePairInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RL03DevDifficultyNodePairInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_frontNode(&mut self, frontNode: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03DevDifficultyNodePairInfo::VT_FRONTNODE,
            frontNode,
        );
    }
    #[inline]
    pub fn add_nextNode(&mut self, nextNode: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03DevDifficultyNodePairInfo::VT_NEXTNODE,
            nextNode,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL03DevDifficultyNodePairInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL03DevDifficultyNodePairInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL03DevDifficultyNodePairInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL03DevDifficultyNodePairInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL03DevDifficultyNodePairInfo");
        ds.field("frontNode", &self.frontNode());
        ds.field("nextNode", &self.nextNode());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL03DevDifficultyNodePairInfoT {
    pub frontNode: Option<String>,
    pub nextNode: Option<String>,
}
impl Default for clz_Torappu_RL03DevDifficultyNodePairInfoT {
    fn default() -> Self {
        Self {
            frontNode: None,
            nextNode: None,
        }
    }
}
impl clz_Torappu_RL03DevDifficultyNodePairInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL03DevDifficultyNodePairInfo<'b>> {
        let frontNode = self.frontNode.as_ref().map(|x| _fbb.create_string(x));
        let nextNode = self.nextNode.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RL03DevDifficultyNodePairInfo::create(
            _fbb,
            &clz_Torappu_RL03DevDifficultyNodePairInfoArgs {
                frontNode,
                nextNode,
            },
        )
    }
}
pub enum clz_Torappu_RL03DevDifficultyNodeInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL03DevDifficultyNodeInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL03DevDifficultyNodeInfo<'a> {
    type Inner = clz_Torappu_RL03DevDifficultyNodeInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL03DevDifficultyNodeInfo<'a> {
    pub const VT_BUFFID: flatbuffers::VOffsetT = 4;
    pub const VT_NODEMAP: flatbuffers::VOffsetT = 6;
    pub const VT_ENABLEGRADE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL03DevDifficultyNodeInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL03DevDifficultyNodeInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL03DevDifficultyNodeInfo<'bldr>> {
        let mut builder = clz_Torappu_RL03DevDifficultyNodeInfoBuilder::new(_fbb);
        builder.add_enableGrade(args.enableGrade);
        if let Some(x) = args.nodeMap {
            builder.add_nodeMap(x);
        }
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL03DevDifficultyNodeInfoT {
        let buffId = self.buffId().map(|x| x.to_string());
        let nodeMap = self
            .nodeMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let enableGrade = self.enableGrade();
        clz_Torappu_RL03DevDifficultyNodeInfoT {
            buffId,
            nodeMap,
            enableGrade,
        }
    }

    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03DevDifficultyNodeInfo::VT_BUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RL03DevDifficultyNodePairInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL03DevDifficultyNodePairInfo>,
                >,
            >>(clz_Torappu_RL03DevDifficultyNodeInfo::VT_NODEMAP, None)
        }
    }
    #[inline]
    pub fn enableGrade(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RL03DevDifficultyNodeInfo::VT_ENABLEGRADE,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL03DevDifficultyNodeInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL03DevDifficultyNodePairInfo>,
                >,
            >>("nodeMap", Self::VT_NODEMAP, false)?
            .visit_field::<i32>("enableGrade", Self::VT_ENABLEGRADE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL03DevDifficultyNodeInfoArgs<'a> {
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL03DevDifficultyNodePairInfo<'a>>,
            >,
        >,
    >,
    pub enableGrade: i32,
}
impl<'a> Default for clz_Torappu_RL03DevDifficultyNodeInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL03DevDifficultyNodeInfoArgs {
            buffId: None,
            nodeMap: None,
            enableGrade: 0,
        }
    }
}

impl Serialize for clz_Torappu_RL03DevDifficultyNodeInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL03DevDifficultyNodeInfo", 3)?;
        if let Some(f) = self.buffId() {
            s.serialize_field("buffId", &f)?;
        } else {
            s.skip_field("buffId")?;
        }
        if let Some(f) = self.nodeMap() {
            s.serialize_field("nodeMap", &f)?;
        } else {
            s.skip_field("nodeMap")?;
        }
        s.serialize_field("enableGrade", &self.enableGrade())?;
        s.end()
    }
}

pub struct clz_Torappu_RL03DevDifficultyNodeInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RL03DevDifficultyNodeInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03DevDifficultyNodeInfo::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn add_nodeMap(
        &mut self,
        nodeMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL03DevDifficultyNodePairInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03DevDifficultyNodeInfo::VT_NODEMAP,
            nodeMap,
        );
    }
    #[inline]
    pub fn add_enableGrade(&mut self, enableGrade: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RL03DevDifficultyNodeInfo::VT_ENABLEGRADE,
            enableGrade,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL03DevDifficultyNodeInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL03DevDifficultyNodeInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL03DevDifficultyNodeInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL03DevDifficultyNodeInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL03DevDifficultyNodeInfo");
        ds.field("buffId", &self.buffId());
        ds.field("nodeMap", &self.nodeMap());
        ds.field("enableGrade", &self.enableGrade());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL03DevDifficultyNodeInfoT {
    pub buffId: Option<String>,
    pub nodeMap: Option<Vec<clz_Torappu_RL03DevDifficultyNodePairInfoT>>,
    pub enableGrade: i32,
}
impl Default for clz_Torappu_RL03DevDifficultyNodeInfoT {
    fn default() -> Self {
        Self {
            buffId: None,
            nodeMap: None,
            enableGrade: 0,
        }
    }
}
impl clz_Torappu_RL03DevDifficultyNodeInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL03DevDifficultyNodeInfo<'b>> {
        let buffId = self.buffId.as_ref().map(|x| _fbb.create_string(x));
        let nodeMap = self.nodeMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let enableGrade = self.enableGrade;
        clz_Torappu_RL03DevDifficultyNodeInfo::create(
            _fbb,
            &clz_Torappu_RL03DevDifficultyNodeInfoArgs {
                buffId,
                nodeMap,
                enableGrade,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RL03DevDifficultyNodeInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RL03DevDifficultyNodeInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RL03DevDifficultyNodeInfo<'a> {
    type Inner = dict__string__clz_Torappu_RL03DevDifficultyNodeInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RL03DevDifficultyNodeInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RL03DevDifficultyNodeInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RL03DevDifficultyNodeInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RL03DevDifficultyNodeInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RL03DevDifficultyNodeInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RL03DevDifficultyNodeInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RL03DevDifficultyNodeInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RL03DevDifficultyNodeInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RL03DevDifficultyNodeInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RL03DevDifficultyNodeInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RL03DevDifficultyNodeInfo>>(
                    dict__string__clz_Torappu_RL03DevDifficultyNodeInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RL03DevDifficultyNodeInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RL03DevDifficultyNodeInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RL03DevDifficultyNodeInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RL03DevDifficultyNodeInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RL03DevDifficultyNodeInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RL03DevDifficultyNodeInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RL03DevDifficultyNodeInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RL03DevDifficultyNodeInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RL03DevDifficultyNodeInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RL03DevDifficultyNodeInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RL03DevDifficultyNodeInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RL03DevDifficultyNodeInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RL03DevDifficultyNodeInfo>>(
                dict__string__clz_Torappu_RL03DevDifficultyNodeInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RL03DevDifficultyNodeInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RL03DevDifficultyNodeInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RL03DevDifficultyNodeInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RL03DevDifficultyNodeInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RL03DevDifficultyNodeInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RL03DevDifficultyNodeInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RL03DevDifficultyNodeInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RL03DevDifficultyNodeInfoT>>,
}
impl Default for dict__string__clz_Torappu_RL03DevDifficultyNodeInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RL03DevDifficultyNodeInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RL03DevDifficultyNodeInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RL03DevDifficultyNodeInfo::create(
            _fbb,
            &dict__string__clz_Torappu_RL03DevDifficultyNodeInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RL03EndingTextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL03EndingText<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL03EndingText<'a> {
    type Inner = clz_Torappu_RL03EndingText<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL03EndingText<'a> {
    pub const VT_SUMMARYGETTOTEM: flatbuffers::VOffsetT = 4;
    pub const VT_SUMMARYDEMOPOINTUP: flatbuffers::VOffsetT = 6;
    pub const VT_SUMMARYDEMOPOINTDOWN: flatbuffers::VOffsetT = 8;
    pub const VT_SUMMARYDEMOGRADEUP: flatbuffers::VOffsetT = 10;
    pub const VT_SUMMARYDEMOGRADEDOWN: flatbuffers::VOffsetT = 12;
    pub const VT_SUMMARYVISIONPOINTUP: flatbuffers::VOffsetT = 14;
    pub const VT_SUMMARYVISIONPOINTDOWN: flatbuffers::VOffsetT = 16;
    pub const VT_SUMMARYVISIONGRADEUP: flatbuffers::VOffsetT = 18;
    pub const VT_SUMMARYVISIONGRADEDOWN: flatbuffers::VOffsetT = 20;
    pub const VT_SUMMARYFIGHTWIN: flatbuffers::VOffsetT = 22;
    pub const VT_SUMMARYFIGHTFAIL: flatbuffers::VOffsetT = 24;
    pub const VT_SUMMARYEXCHANGETOTEM: flatbuffers::VOffsetT = 26;
    pub const VT_SUMMARYUSETOTEM: flatbuffers::VOffsetT = 28;
    pub const VT_SUMMARYVISIONGRADE: flatbuffers::VOffsetT = 30;
    pub const VT_SUMMARYACTOR: flatbuffers::VOffsetT = 32;
    pub const VT_SUMMARYTOP: flatbuffers::VOffsetT = 34;
    pub const VT_SUMMARYZONE: flatbuffers::VOffsetT = 36;
    pub const VT_SUMMARYENDING: flatbuffers::VOffsetT = 38;
    pub const VT_SUMMARYDIFFICULTYZONE: flatbuffers::VOffsetT = 40;
    pub const VT_SUMMARYDIFFICULTYENDING: flatbuffers::VOffsetT = 42;
    pub const VT_SUMMARYMODE: flatbuffers::VOffsetT = 44;
    pub const VT_SUMMARYGROUP: flatbuffers::VOffsetT = 46;
    pub const VT_SUMMARYSUPPORT: flatbuffers::VOffsetT = 48;
    pub const VT_SUMMARYNORMALRECRUIT: flatbuffers::VOffsetT = 50;
    pub const VT_SUMMARYDIRECTRECRUIT: flatbuffers::VOffsetT = 52;
    pub const VT_SUMMARYFRIENDRECRUIT: flatbuffers::VOffsetT = 54;
    pub const VT_SUMMARYFREERECRUIT: flatbuffers::VOffsetT = 56;
    pub const VT_SUMMARYMONTHRECRUIT: flatbuffers::VOffsetT = 58;
    pub const VT_SUMMARYUPGRADE: flatbuffers::VOffsetT = 60;
    pub const VT_SUMMARYCOMPLETEENDING: flatbuffers::VOffsetT = 62;
    pub const VT_SUMMARYEACHZONE: flatbuffers::VOffsetT = 64;
    pub const VT_SUMMARYMEETSPZONE: flatbuffers::VOffsetT = 66;
    pub const VT_SUMMARYPERFECTBATTLE: flatbuffers::VOffsetT = 68;
    pub const VT_SUMMARYMEETBATTLE: flatbuffers::VOffsetT = 70;
    pub const VT_SUMMARYMEETEVENT: flatbuffers::VOffsetT = 72;
    pub const VT_SUMMARYMEETSHOP: flatbuffers::VOffsetT = 74;
    pub const VT_SUMMARYMEETTREASURE: flatbuffers::VOffsetT = 76;
    pub const VT_SUMMARYMEETSECRETPATH: flatbuffers::VOffsetT = 78;
    pub const VT_SUMMARYEXCHANGERELIC: flatbuffers::VOffsetT = 80;
    pub const VT_SUMMARYMEETTRADE: flatbuffers::VOffsetT = 82;
    pub const VT_SUMMARYBUY: flatbuffers::VOffsetT = 84;
    pub const VT_SUMMARYBUYWITHPRICEID: flatbuffers::VOffsetT = 86;
    pub const VT_SUMMARYINVEST: flatbuffers::VOffsetT = 88;
    pub const VT_SUMMARYGET: flatbuffers::VOffsetT = 90;
    pub const VT_SUMMARYRELIC: flatbuffers::VOffsetT = 92;
    pub const VT_SUMMARYSAFEHOUSE: flatbuffers::VOffsetT = 94;
    pub const VT_SUMMARYFAILEND: flatbuffers::VOffsetT = 96;
    pub const VT_SUMMARYSTOCKRECRUITTICKET: flatbuffers::VOffsetT = 98;
    pub const VT_SUMMARYDUELWIN: flatbuffers::VOffsetT = 100;
    pub const VT_SUMMARYDUELTIE: flatbuffers::VOffsetT = 102;
    pub const VT_SUMMARYDUELLOSE: flatbuffers::VOffsetT = 104;
    pub const VT_SUMMARYEXPEDITIONGO: flatbuffers::VOffsetT = 106;
    pub const VT_SUMMARYEXPEDITIONBACK: flatbuffers::VOffsetT = 108;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL03EndingText { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL03EndingTextArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL03EndingText<'bldr>> {
        let mut builder = clz_Torappu_RL03EndingTextBuilder::new(_fbb);
        if let Some(x) = args.summaryExpeditionBack {
            builder.add_summaryExpeditionBack(x);
        }
        if let Some(x) = args.summaryExpeditionGo {
            builder.add_summaryExpeditionGo(x);
        }
        if let Some(x) = args.summaryDuelLose {
            builder.add_summaryDuelLose(x);
        }
        if let Some(x) = args.summaryDuelTie {
            builder.add_summaryDuelTie(x);
        }
        if let Some(x) = args.summaryDuelWin {
            builder.add_summaryDuelWin(x);
        }
        if let Some(x) = args.summaryStockRecruitTicket {
            builder.add_summaryStockRecruitTicket(x);
        }
        if let Some(x) = args.summaryFailEnd {
            builder.add_summaryFailEnd(x);
        }
        if let Some(x) = args.summarySafeHouse {
            builder.add_summarySafeHouse(x);
        }
        if let Some(x) = args.summaryRelic {
            builder.add_summaryRelic(x);
        }
        if let Some(x) = args.summaryGet {
            builder.add_summaryGet(x);
        }
        if let Some(x) = args.summaryInvest {
            builder.add_summaryInvest(x);
        }
        if let Some(x) = args.summaryBuyWithPriceId {
            builder.add_summaryBuyWithPriceId(x);
        }
        if let Some(x) = args.summaryBuy {
            builder.add_summaryBuy(x);
        }
        if let Some(x) = args.summaryMeetTrade {
            builder.add_summaryMeetTrade(x);
        }
        if let Some(x) = args.summaryExchangeRelic {
            builder.add_summaryExchangeRelic(x);
        }
        if let Some(x) = args.summaryMeetSecretpath {
            builder.add_summaryMeetSecretpath(x);
        }
        if let Some(x) = args.summaryMeetTreasure {
            builder.add_summaryMeetTreasure(x);
        }
        if let Some(x) = args.summaryMeetShop {
            builder.add_summaryMeetShop(x);
        }
        if let Some(x) = args.summaryMeetEvent {
            builder.add_summaryMeetEvent(x);
        }
        if let Some(x) = args.summaryMeetBattle {
            builder.add_summaryMeetBattle(x);
        }
        if let Some(x) = args.summaryPerfectBattle {
            builder.add_summaryPerfectBattle(x);
        }
        if let Some(x) = args.summaryMeetSpZone {
            builder.add_summaryMeetSpZone(x);
        }
        if let Some(x) = args.summaryEachZone {
            builder.add_summaryEachZone(x);
        }
        if let Some(x) = args.summaryCompleteEnding {
            builder.add_summaryCompleteEnding(x);
        }
        if let Some(x) = args.summaryUpgrade {
            builder.add_summaryUpgrade(x);
        }
        if let Some(x) = args.summaryMonthRecruit {
            builder.add_summaryMonthRecruit(x);
        }
        if let Some(x) = args.summaryFreeRecruit {
            builder.add_summaryFreeRecruit(x);
        }
        if let Some(x) = args.summaryFriendRecruit {
            builder.add_summaryFriendRecruit(x);
        }
        if let Some(x) = args.summaryDirectRecruit {
            builder.add_summaryDirectRecruit(x);
        }
        if let Some(x) = args.summaryNormalRecruit {
            builder.add_summaryNormalRecruit(x);
        }
        if let Some(x) = args.summarySupport {
            builder.add_summarySupport(x);
        }
        if let Some(x) = args.summaryGroup {
            builder.add_summaryGroup(x);
        }
        if let Some(x) = args.summaryMode {
            builder.add_summaryMode(x);
        }
        if let Some(x) = args.summaryDifficultyEnding {
            builder.add_summaryDifficultyEnding(x);
        }
        if let Some(x) = args.summaryDifficultyZone {
            builder.add_summaryDifficultyZone(x);
        }
        if let Some(x) = args.summaryEnding {
            builder.add_summaryEnding(x);
        }
        if let Some(x) = args.summaryZone {
            builder.add_summaryZone(x);
        }
        if let Some(x) = args.summaryTop {
            builder.add_summaryTop(x);
        }
        if let Some(x) = args.summaryActor {
            builder.add_summaryActor(x);
        }
        if let Some(x) = args.summaryVisionGrade {
            builder.add_summaryVisionGrade(x);
        }
        if let Some(x) = args.summaryUseTotem {
            builder.add_summaryUseTotem(x);
        }
        if let Some(x) = args.summaryExchangeTotem {
            builder.add_summaryExchangeTotem(x);
        }
        if let Some(x) = args.summaryFightFail {
            builder.add_summaryFightFail(x);
        }
        if let Some(x) = args.summaryFightWin {
            builder.add_summaryFightWin(x);
        }
        if let Some(x) = args.summaryVisionGradeDown {
            builder.add_summaryVisionGradeDown(x);
        }
        if let Some(x) = args.summaryVisionGradeUp {
            builder.add_summaryVisionGradeUp(x);
        }
        if let Some(x) = args.summaryVisionPointDown {
            builder.add_summaryVisionPointDown(x);
        }
        if let Some(x) = args.summaryVisionPointUp {
            builder.add_summaryVisionPointUp(x);
        }
        if let Some(x) = args.summaryDemoGradeDown {
            builder.add_summaryDemoGradeDown(x);
        }
        if let Some(x) = args.summaryDemoGradeUp {
            builder.add_summaryDemoGradeUp(x);
        }
        if let Some(x) = args.summaryDemoPointDown {
            builder.add_summaryDemoPointDown(x);
        }
        if let Some(x) = args.summaryDemoPointUp {
            builder.add_summaryDemoPointUp(x);
        }
        if let Some(x) = args.summaryGetTotem {
            builder.add_summaryGetTotem(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL03EndingTextT {
        let summaryGetTotem = self.summaryGetTotem().map(|x| x.to_string());
        let summaryDemoPointUp = self.summaryDemoPointUp().map(|x| x.to_string());
        let summaryDemoPointDown = self.summaryDemoPointDown().map(|x| x.to_string());
        let summaryDemoGradeUp = self.summaryDemoGradeUp().map(|x| x.to_string());
        let summaryDemoGradeDown = self.summaryDemoGradeDown().map(|x| x.to_string());
        let summaryVisionPointUp = self.summaryVisionPointUp().map(|x| x.to_string());
        let summaryVisionPointDown = self.summaryVisionPointDown().map(|x| x.to_string());
        let summaryVisionGradeUp = self.summaryVisionGradeUp().map(|x| x.to_string());
        let summaryVisionGradeDown = self.summaryVisionGradeDown().map(|x| x.to_string());
        let summaryFightWin = self.summaryFightWin().map(|x| x.to_string());
        let summaryFightFail = self.summaryFightFail().map(|x| x.to_string());
        let summaryExchangeTotem = self.summaryExchangeTotem().map(|x| x.to_string());
        let summaryUseTotem = self.summaryUseTotem().map(|x| x.to_string());
        let summaryVisionGrade = self.summaryVisionGrade().map(|x| x.to_string());
        let summaryActor = self.summaryActor().map(|x| x.to_string());
        let summaryTop = self.summaryTop().map(|x| x.to_string());
        let summaryZone = self.summaryZone().map(|x| x.to_string());
        let summaryEnding = self.summaryEnding().map(|x| x.to_string());
        let summaryDifficultyZone = self.summaryDifficultyZone().map(|x| x.to_string());
        let summaryDifficultyEnding = self.summaryDifficultyEnding().map(|x| x.to_string());
        let summaryMode = self.summaryMode().map(|x| x.to_string());
        let summaryGroup = self.summaryGroup().map(|x| x.to_string());
        let summarySupport = self.summarySupport().map(|x| x.to_string());
        let summaryNormalRecruit = self.summaryNormalRecruit().map(|x| x.to_string());
        let summaryDirectRecruit = self.summaryDirectRecruit().map(|x| x.to_string());
        let summaryFriendRecruit = self.summaryFriendRecruit().map(|x| x.to_string());
        let summaryFreeRecruit = self.summaryFreeRecruit().map(|x| x.to_string());
        let summaryMonthRecruit = self.summaryMonthRecruit().map(|x| x.to_string());
        let summaryUpgrade = self.summaryUpgrade().map(|x| x.to_string());
        let summaryCompleteEnding = self.summaryCompleteEnding().map(|x| x.to_string());
        let summaryEachZone = self.summaryEachZone().map(|x| x.to_string());
        let summaryMeetSpZone = self.summaryMeetSpZone().map(|x| x.to_string());
        let summaryPerfectBattle = self.summaryPerfectBattle().map(|x| x.to_string());
        let summaryMeetBattle = self.summaryMeetBattle().map(|x| x.to_string());
        let summaryMeetEvent = self.summaryMeetEvent().map(|x| x.to_string());
        let summaryMeetShop = self.summaryMeetShop().map(|x| x.to_string());
        let summaryMeetTreasure = self.summaryMeetTreasure().map(|x| x.to_string());
        let summaryMeetSecretpath = self.summaryMeetSecretpath().map(|x| x.to_string());
        let summaryExchangeRelic = self.summaryExchangeRelic().map(|x| x.to_string());
        let summaryMeetTrade = self.summaryMeetTrade().map(|x| x.to_string());
        let summaryBuy = self.summaryBuy().map(|x| x.to_string());
        let summaryBuyWithPriceId = self.summaryBuyWithPriceId().map(|x| x.to_string());
        let summaryInvest = self.summaryInvest().map(|x| x.to_string());
        let summaryGet = self.summaryGet().map(|x| x.to_string());
        let summaryRelic = self.summaryRelic().map(|x| x.to_string());
        let summarySafeHouse = self.summarySafeHouse().map(|x| x.to_string());
        let summaryFailEnd = self.summaryFailEnd().map(|x| x.to_string());
        let summaryStockRecruitTicket = self.summaryStockRecruitTicket().map(|x| x.to_string());
        let summaryDuelWin = self.summaryDuelWin().map(|x| x.to_string());
        let summaryDuelTie = self.summaryDuelTie().map(|x| x.to_string());
        let summaryDuelLose = self.summaryDuelLose().map(|x| x.to_string());
        let summaryExpeditionGo = self.summaryExpeditionGo().map(|x| x.to_string());
        let summaryExpeditionBack = self.summaryExpeditionBack().map(|x| x.to_string());
        clz_Torappu_RL03EndingTextT {
            summaryGetTotem,
            summaryDemoPointUp,
            summaryDemoPointDown,
            summaryDemoGradeUp,
            summaryDemoGradeDown,
            summaryVisionPointUp,
            summaryVisionPointDown,
            summaryVisionGradeUp,
            summaryVisionGradeDown,
            summaryFightWin,
            summaryFightFail,
            summaryExchangeTotem,
            summaryUseTotem,
            summaryVisionGrade,
            summaryActor,
            summaryTop,
            summaryZone,
            summaryEnding,
            summaryDifficultyZone,
            summaryDifficultyEnding,
            summaryMode,
            summaryGroup,
            summarySupport,
            summaryNormalRecruit,
            summaryDirectRecruit,
            summaryFriendRecruit,
            summaryFreeRecruit,
            summaryMonthRecruit,
            summaryUpgrade,
            summaryCompleteEnding,
            summaryEachZone,
            summaryMeetSpZone,
            summaryPerfectBattle,
            summaryMeetBattle,
            summaryMeetEvent,
            summaryMeetShop,
            summaryMeetTreasure,
            summaryMeetSecretpath,
            summaryExchangeRelic,
            summaryMeetTrade,
            summaryBuy,
            summaryBuyWithPriceId,
            summaryInvest,
            summaryGet,
            summaryRelic,
            summarySafeHouse,
            summaryFailEnd,
            summaryStockRecruitTicket,
            summaryDuelWin,
            summaryDuelTie,
            summaryDuelLose,
            summaryExpeditionGo,
            summaryExpeditionBack,
        }
    }

    #[inline]
    pub fn summaryGetTotem(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYGETTOTEM,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDemoPointUp(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYDEMOPOINTUP,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDemoPointDown(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYDEMOPOINTDOWN,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDemoGradeUp(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYDEMOGRADEUP,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDemoGradeDown(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYDEMOGRADEDOWN,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryVisionPointUp(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYVISIONPOINTUP,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryVisionPointDown(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYVISIONPOINTDOWN,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryVisionGradeUp(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYVISIONGRADEUP,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryVisionGradeDown(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYVISIONGRADEDOWN,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryFightWin(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYFIGHTWIN,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryFightFail(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYFIGHTFAIL,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExchangeTotem(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYEXCHANGETOTEM,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryUseTotem(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYUSETOTEM,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryVisionGrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYVISIONGRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryActor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYACTOR,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryTop(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYTOP,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryEnding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYENDING,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDifficultyZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYDIFFICULTYZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDifficultyEnding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYDIFFICULTYENDING,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMode(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYMODE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryGroup(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn summarySupport(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYSUPPORT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryNormalRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYNORMALRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDirectRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYDIRECTRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryFriendRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYFRIENDRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryFreeRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYFREERECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMonthRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYMONTHRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryUpgrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYUPGRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryCompleteEnding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYCOMPLETEENDING,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryEachZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYEACHZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetSpZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYMEETSPZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryPerfectBattle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYPERFECTBATTLE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetBattle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYMEETBATTLE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetEvent(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYMEETEVENT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetShop(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYMEETSHOP,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetTreasure(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYMEETTREASURE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetSecretpath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYMEETSECRETPATH,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExchangeRelic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYEXCHANGERELIC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetTrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYMEETTRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryBuy(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYBUY,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryBuyWithPriceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYBUYWITHPRICEID,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryInvest(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYINVEST,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryGet(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYGET,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryRelic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYRELIC,
                None,
            )
        }
    }
    #[inline]
    pub fn summarySafeHouse(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYSAFEHOUSE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryFailEnd(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYFAILEND,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryStockRecruitTicket(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYSTOCKRECRUITTICKET,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDuelWin(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYDUELWIN,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDuelTie(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYDUELTIE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDuelLose(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYDUELLOSE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExpeditionGo(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYEXPEDITIONGO,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExpeditionBack(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03EndingText::VT_SUMMARYEXPEDITIONBACK,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL03EndingText<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryGetTotem",
                Self::VT_SUMMARYGETTOTEM,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDemoPointUp",
                Self::VT_SUMMARYDEMOPOINTUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDemoPointDown",
                Self::VT_SUMMARYDEMOPOINTDOWN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDemoGradeUp",
                Self::VT_SUMMARYDEMOGRADEUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDemoGradeDown",
                Self::VT_SUMMARYDEMOGRADEDOWN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryVisionPointUp",
                Self::VT_SUMMARYVISIONPOINTUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryVisionPointDown",
                Self::VT_SUMMARYVISIONPOINTDOWN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryVisionGradeUp",
                Self::VT_SUMMARYVISIONGRADEUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryVisionGradeDown",
                Self::VT_SUMMARYVISIONGRADEDOWN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryFightWin",
                Self::VT_SUMMARYFIGHTWIN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryFightFail",
                Self::VT_SUMMARYFIGHTFAIL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExchangeTotem",
                Self::VT_SUMMARYEXCHANGETOTEM,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryUseTotem",
                Self::VT_SUMMARYUSETOTEM,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryVisionGrade",
                Self::VT_SUMMARYVISIONGRADE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryActor",
                Self::VT_SUMMARYACTOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryTop",
                Self::VT_SUMMARYTOP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryZone",
                Self::VT_SUMMARYZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryEnding",
                Self::VT_SUMMARYENDING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDifficultyZone",
                Self::VT_SUMMARYDIFFICULTYZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDifficultyEnding",
                Self::VT_SUMMARYDIFFICULTYENDING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMode",
                Self::VT_SUMMARYMODE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryGroup",
                Self::VT_SUMMARYGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summarySupport",
                Self::VT_SUMMARYSUPPORT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryNormalRecruit",
                Self::VT_SUMMARYNORMALRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDirectRecruit",
                Self::VT_SUMMARYDIRECTRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryFriendRecruit",
                Self::VT_SUMMARYFRIENDRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryFreeRecruit",
                Self::VT_SUMMARYFREERECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMonthRecruit",
                Self::VT_SUMMARYMONTHRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryUpgrade",
                Self::VT_SUMMARYUPGRADE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryCompleteEnding",
                Self::VT_SUMMARYCOMPLETEENDING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryEachZone",
                Self::VT_SUMMARYEACHZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetSpZone",
                Self::VT_SUMMARYMEETSPZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryPerfectBattle",
                Self::VT_SUMMARYPERFECTBATTLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetBattle",
                Self::VT_SUMMARYMEETBATTLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetEvent",
                Self::VT_SUMMARYMEETEVENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetShop",
                Self::VT_SUMMARYMEETSHOP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetTreasure",
                Self::VT_SUMMARYMEETTREASURE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetSecretpath",
                Self::VT_SUMMARYMEETSECRETPATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExchangeRelic",
                Self::VT_SUMMARYEXCHANGERELIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetTrade",
                Self::VT_SUMMARYMEETTRADE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryBuy",
                Self::VT_SUMMARYBUY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryBuyWithPriceId",
                Self::VT_SUMMARYBUYWITHPRICEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryInvest",
                Self::VT_SUMMARYINVEST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryGet",
                Self::VT_SUMMARYGET,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryRelic",
                Self::VT_SUMMARYRELIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summarySafeHouse",
                Self::VT_SUMMARYSAFEHOUSE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryFailEnd",
                Self::VT_SUMMARYFAILEND,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryStockRecruitTicket",
                Self::VT_SUMMARYSTOCKRECRUITTICKET,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDuelWin",
                Self::VT_SUMMARYDUELWIN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDuelTie",
                Self::VT_SUMMARYDUELTIE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDuelLose",
                Self::VT_SUMMARYDUELLOSE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExpeditionGo",
                Self::VT_SUMMARYEXPEDITIONGO,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExpeditionBack",
                Self::VT_SUMMARYEXPEDITIONBACK,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL03EndingTextArgs<'a> {
    pub summaryGetTotem: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDemoPointUp: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDemoPointDown: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDemoGradeUp: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDemoGradeDown: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryVisionPointUp: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryVisionPointDown: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryVisionGradeUp: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryVisionGradeDown: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryFightWin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryFightFail: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExchangeTotem: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryUseTotem: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryVisionGrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryActor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryTop: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryEnding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDifficultyZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDifficultyEnding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summarySupport: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryNormalRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDirectRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryFriendRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryFreeRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMonthRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryUpgrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryCompleteEnding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryEachZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetSpZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryPerfectBattle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetBattle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetEvent: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetShop: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetTreasure: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetSecretpath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExchangeRelic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetTrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryBuy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryBuyWithPriceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryInvest: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryGet: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryRelic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summarySafeHouse: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryFailEnd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryStockRecruitTicket: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDuelWin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDuelTie: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDuelLose: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExpeditionGo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExpeditionBack: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RL03EndingTextArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL03EndingTextArgs {
            summaryGetTotem: None,
            summaryDemoPointUp: None,
            summaryDemoPointDown: None,
            summaryDemoGradeUp: None,
            summaryDemoGradeDown: None,
            summaryVisionPointUp: None,
            summaryVisionPointDown: None,
            summaryVisionGradeUp: None,
            summaryVisionGradeDown: None,
            summaryFightWin: None,
            summaryFightFail: None,
            summaryExchangeTotem: None,
            summaryUseTotem: None,
            summaryVisionGrade: None,
            summaryActor: None,
            summaryTop: None,
            summaryZone: None,
            summaryEnding: None,
            summaryDifficultyZone: None,
            summaryDifficultyEnding: None,
            summaryMode: None,
            summaryGroup: None,
            summarySupport: None,
            summaryNormalRecruit: None,
            summaryDirectRecruit: None,
            summaryFriendRecruit: None,
            summaryFreeRecruit: None,
            summaryMonthRecruit: None,
            summaryUpgrade: None,
            summaryCompleteEnding: None,
            summaryEachZone: None,
            summaryMeetSpZone: None,
            summaryPerfectBattle: None,
            summaryMeetBattle: None,
            summaryMeetEvent: None,
            summaryMeetShop: None,
            summaryMeetTreasure: None,
            summaryMeetSecretpath: None,
            summaryExchangeRelic: None,
            summaryMeetTrade: None,
            summaryBuy: None,
            summaryBuyWithPriceId: None,
            summaryInvest: None,
            summaryGet: None,
            summaryRelic: None,
            summarySafeHouse: None,
            summaryFailEnd: None,
            summaryStockRecruitTicket: None,
            summaryDuelWin: None,
            summaryDuelTie: None,
            summaryDuelLose: None,
            summaryExpeditionGo: None,
            summaryExpeditionBack: None,
        }
    }
}

impl Serialize for clz_Torappu_RL03EndingText<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL03EndingText", 53)?;
        if let Some(f) = self.summaryGetTotem() {
            s.serialize_field("summaryGetTotem", &f)?;
        } else {
            s.skip_field("summaryGetTotem")?;
        }
        if let Some(f) = self.summaryDemoPointUp() {
            s.serialize_field("summaryDemoPointUp", &f)?;
        } else {
            s.skip_field("summaryDemoPointUp")?;
        }
        if let Some(f) = self.summaryDemoPointDown() {
            s.serialize_field("summaryDemoPointDown", &f)?;
        } else {
            s.skip_field("summaryDemoPointDown")?;
        }
        if let Some(f) = self.summaryDemoGradeUp() {
            s.serialize_field("summaryDemoGradeUp", &f)?;
        } else {
            s.skip_field("summaryDemoGradeUp")?;
        }
        if let Some(f) = self.summaryDemoGradeDown() {
            s.serialize_field("summaryDemoGradeDown", &f)?;
        } else {
            s.skip_field("summaryDemoGradeDown")?;
        }
        if let Some(f) = self.summaryVisionPointUp() {
            s.serialize_field("summaryVisionPointUp", &f)?;
        } else {
            s.skip_field("summaryVisionPointUp")?;
        }
        if let Some(f) = self.summaryVisionPointDown() {
            s.serialize_field("summaryVisionPointDown", &f)?;
        } else {
            s.skip_field("summaryVisionPointDown")?;
        }
        if let Some(f) = self.summaryVisionGradeUp() {
            s.serialize_field("summaryVisionGradeUp", &f)?;
        } else {
            s.skip_field("summaryVisionGradeUp")?;
        }
        if let Some(f) = self.summaryVisionGradeDown() {
            s.serialize_field("summaryVisionGradeDown", &f)?;
        } else {
            s.skip_field("summaryVisionGradeDown")?;
        }
        if let Some(f) = self.summaryFightWin() {
            s.serialize_field("summaryFightWin", &f)?;
        } else {
            s.skip_field("summaryFightWin")?;
        }
        if let Some(f) = self.summaryFightFail() {
            s.serialize_field("summaryFightFail", &f)?;
        } else {
            s.skip_field("summaryFightFail")?;
        }
        if let Some(f) = self.summaryExchangeTotem() {
            s.serialize_field("summaryExchangeTotem", &f)?;
        } else {
            s.skip_field("summaryExchangeTotem")?;
        }
        if let Some(f) = self.summaryUseTotem() {
            s.serialize_field("summaryUseTotem", &f)?;
        } else {
            s.skip_field("summaryUseTotem")?;
        }
        if let Some(f) = self.summaryVisionGrade() {
            s.serialize_field("summaryVisionGrade", &f)?;
        } else {
            s.skip_field("summaryVisionGrade")?;
        }
        if let Some(f) = self.summaryActor() {
            s.serialize_field("summaryActor", &f)?;
        } else {
            s.skip_field("summaryActor")?;
        }
        if let Some(f) = self.summaryTop() {
            s.serialize_field("summaryTop", &f)?;
        } else {
            s.skip_field("summaryTop")?;
        }
        if let Some(f) = self.summaryZone() {
            s.serialize_field("summaryZone", &f)?;
        } else {
            s.skip_field("summaryZone")?;
        }
        if let Some(f) = self.summaryEnding() {
            s.serialize_field("summaryEnding", &f)?;
        } else {
            s.skip_field("summaryEnding")?;
        }
        if let Some(f) = self.summaryDifficultyZone() {
            s.serialize_field("summaryDifficultyZone", &f)?;
        } else {
            s.skip_field("summaryDifficultyZone")?;
        }
        if let Some(f) = self.summaryDifficultyEnding() {
            s.serialize_field("summaryDifficultyEnding", &f)?;
        } else {
            s.skip_field("summaryDifficultyEnding")?;
        }
        if let Some(f) = self.summaryMode() {
            s.serialize_field("summaryMode", &f)?;
        } else {
            s.skip_field("summaryMode")?;
        }
        if let Some(f) = self.summaryGroup() {
            s.serialize_field("summaryGroup", &f)?;
        } else {
            s.skip_field("summaryGroup")?;
        }
        if let Some(f) = self.summarySupport() {
            s.serialize_field("summarySupport", &f)?;
        } else {
            s.skip_field("summarySupport")?;
        }
        if let Some(f) = self.summaryNormalRecruit() {
            s.serialize_field("summaryNormalRecruit", &f)?;
        } else {
            s.skip_field("summaryNormalRecruit")?;
        }
        if let Some(f) = self.summaryDirectRecruit() {
            s.serialize_field("summaryDirectRecruit", &f)?;
        } else {
            s.skip_field("summaryDirectRecruit")?;
        }
        if let Some(f) = self.summaryFriendRecruit() {
            s.serialize_field("summaryFriendRecruit", &f)?;
        } else {
            s.skip_field("summaryFriendRecruit")?;
        }
        if let Some(f) = self.summaryFreeRecruit() {
            s.serialize_field("summaryFreeRecruit", &f)?;
        } else {
            s.skip_field("summaryFreeRecruit")?;
        }
        if let Some(f) = self.summaryMonthRecruit() {
            s.serialize_field("summaryMonthRecruit", &f)?;
        } else {
            s.skip_field("summaryMonthRecruit")?;
        }
        if let Some(f) = self.summaryUpgrade() {
            s.serialize_field("summaryUpgrade", &f)?;
        } else {
            s.skip_field("summaryUpgrade")?;
        }
        if let Some(f) = self.summaryCompleteEnding() {
            s.serialize_field("summaryCompleteEnding", &f)?;
        } else {
            s.skip_field("summaryCompleteEnding")?;
        }
        if let Some(f) = self.summaryEachZone() {
            s.serialize_field("summaryEachZone", &f)?;
        } else {
            s.skip_field("summaryEachZone")?;
        }
        if let Some(f) = self.summaryMeetSpZone() {
            s.serialize_field("summaryMeetSpZone", &f)?;
        } else {
            s.skip_field("summaryMeetSpZone")?;
        }
        if let Some(f) = self.summaryPerfectBattle() {
            s.serialize_field("summaryPerfectBattle", &f)?;
        } else {
            s.skip_field("summaryPerfectBattle")?;
        }
        if let Some(f) = self.summaryMeetBattle() {
            s.serialize_field("summaryMeetBattle", &f)?;
        } else {
            s.skip_field("summaryMeetBattle")?;
        }
        if let Some(f) = self.summaryMeetEvent() {
            s.serialize_field("summaryMeetEvent", &f)?;
        } else {
            s.skip_field("summaryMeetEvent")?;
        }
        if let Some(f) = self.summaryMeetShop() {
            s.serialize_field("summaryMeetShop", &f)?;
        } else {
            s.skip_field("summaryMeetShop")?;
        }
        if let Some(f) = self.summaryMeetTreasure() {
            s.serialize_field("summaryMeetTreasure", &f)?;
        } else {
            s.skip_field("summaryMeetTreasure")?;
        }
        if let Some(f) = self.summaryMeetSecretpath() {
            s.serialize_field("summaryMeetSecretpath", &f)?;
        } else {
            s.skip_field("summaryMeetSecretpath")?;
        }
        if let Some(f) = self.summaryExchangeRelic() {
            s.serialize_field("summaryExchangeRelic", &f)?;
        } else {
            s.skip_field("summaryExchangeRelic")?;
        }
        if let Some(f) = self.summaryMeetTrade() {
            s.serialize_field("summaryMeetTrade", &f)?;
        } else {
            s.skip_field("summaryMeetTrade")?;
        }
        if let Some(f) = self.summaryBuy() {
            s.serialize_field("summaryBuy", &f)?;
        } else {
            s.skip_field("summaryBuy")?;
        }
        if let Some(f) = self.summaryBuyWithPriceId() {
            s.serialize_field("summaryBuyWithPriceId", &f)?;
        } else {
            s.skip_field("summaryBuyWithPriceId")?;
        }
        if let Some(f) = self.summaryInvest() {
            s.serialize_field("summaryInvest", &f)?;
        } else {
            s.skip_field("summaryInvest")?;
        }
        if let Some(f) = self.summaryGet() {
            s.serialize_field("summaryGet", &f)?;
        } else {
            s.skip_field("summaryGet")?;
        }
        if let Some(f) = self.summaryRelic() {
            s.serialize_field("summaryRelic", &f)?;
        } else {
            s.skip_field("summaryRelic")?;
        }
        if let Some(f) = self.summarySafeHouse() {
            s.serialize_field("summarySafeHouse", &f)?;
        } else {
            s.skip_field("summarySafeHouse")?;
        }
        if let Some(f) = self.summaryFailEnd() {
            s.serialize_field("summaryFailEnd", &f)?;
        } else {
            s.skip_field("summaryFailEnd")?;
        }
        if let Some(f) = self.summaryStockRecruitTicket() {
            s.serialize_field("summaryStockRecruitTicket", &f)?;
        } else {
            s.skip_field("summaryStockRecruitTicket")?;
        }
        if let Some(f) = self.summaryDuelWin() {
            s.serialize_field("summaryDuelWin", &f)?;
        } else {
            s.skip_field("summaryDuelWin")?;
        }
        if let Some(f) = self.summaryDuelTie() {
            s.serialize_field("summaryDuelTie", &f)?;
        } else {
            s.skip_field("summaryDuelTie")?;
        }
        if let Some(f) = self.summaryDuelLose() {
            s.serialize_field("summaryDuelLose", &f)?;
        } else {
            s.skip_field("summaryDuelLose")?;
        }
        if let Some(f) = self.summaryExpeditionGo() {
            s.serialize_field("summaryExpeditionGo", &f)?;
        } else {
            s.skip_field("summaryExpeditionGo")?;
        }
        if let Some(f) = self.summaryExpeditionBack() {
            s.serialize_field("summaryExpeditionBack", &f)?;
        } else {
            s.skip_field("summaryExpeditionBack")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL03EndingTextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL03EndingTextBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_summaryGetTotem(&mut self, summaryGetTotem: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYGETTOTEM,
            summaryGetTotem,
        );
    }
    #[inline]
    pub fn add_summaryDemoPointUp(&mut self, summaryDemoPointUp: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYDEMOPOINTUP,
            summaryDemoPointUp,
        );
    }
    #[inline]
    pub fn add_summaryDemoPointDown(
        &mut self,
        summaryDemoPointDown: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYDEMOPOINTDOWN,
            summaryDemoPointDown,
        );
    }
    #[inline]
    pub fn add_summaryDemoGradeUp(&mut self, summaryDemoGradeUp: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYDEMOGRADEUP,
            summaryDemoGradeUp,
        );
    }
    #[inline]
    pub fn add_summaryDemoGradeDown(
        &mut self,
        summaryDemoGradeDown: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYDEMOGRADEDOWN,
            summaryDemoGradeDown,
        );
    }
    #[inline]
    pub fn add_summaryVisionPointUp(
        &mut self,
        summaryVisionPointUp: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYVISIONPOINTUP,
            summaryVisionPointUp,
        );
    }
    #[inline]
    pub fn add_summaryVisionPointDown(
        &mut self,
        summaryVisionPointDown: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYVISIONPOINTDOWN,
            summaryVisionPointDown,
        );
    }
    #[inline]
    pub fn add_summaryVisionGradeUp(
        &mut self,
        summaryVisionGradeUp: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYVISIONGRADEUP,
            summaryVisionGradeUp,
        );
    }
    #[inline]
    pub fn add_summaryVisionGradeDown(
        &mut self,
        summaryVisionGradeDown: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYVISIONGRADEDOWN,
            summaryVisionGradeDown,
        );
    }
    #[inline]
    pub fn add_summaryFightWin(&mut self, summaryFightWin: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYFIGHTWIN,
            summaryFightWin,
        );
    }
    #[inline]
    pub fn add_summaryFightFail(&mut self, summaryFightFail: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYFIGHTFAIL,
            summaryFightFail,
        );
    }
    #[inline]
    pub fn add_summaryExchangeTotem(
        &mut self,
        summaryExchangeTotem: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYEXCHANGETOTEM,
            summaryExchangeTotem,
        );
    }
    #[inline]
    pub fn add_summaryUseTotem(&mut self, summaryUseTotem: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYUSETOTEM,
            summaryUseTotem,
        );
    }
    #[inline]
    pub fn add_summaryVisionGrade(&mut self, summaryVisionGrade: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYVISIONGRADE,
            summaryVisionGrade,
        );
    }
    #[inline]
    pub fn add_summaryActor(&mut self, summaryActor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYACTOR,
            summaryActor,
        );
    }
    #[inline]
    pub fn add_summaryTop(&mut self, summaryTop: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYTOP,
            summaryTop,
        );
    }
    #[inline]
    pub fn add_summaryZone(&mut self, summaryZone: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYZONE,
            summaryZone,
        );
    }
    #[inline]
    pub fn add_summaryEnding(&mut self, summaryEnding: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYENDING,
            summaryEnding,
        );
    }
    #[inline]
    pub fn add_summaryDifficultyZone(
        &mut self,
        summaryDifficultyZone: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYDIFFICULTYZONE,
            summaryDifficultyZone,
        );
    }
    #[inline]
    pub fn add_summaryDifficultyEnding(
        &mut self,
        summaryDifficultyEnding: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYDIFFICULTYENDING,
            summaryDifficultyEnding,
        );
    }
    #[inline]
    pub fn add_summaryMode(&mut self, summaryMode: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYMODE,
            summaryMode,
        );
    }
    #[inline]
    pub fn add_summaryGroup(&mut self, summaryGroup: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYGROUP,
            summaryGroup,
        );
    }
    #[inline]
    pub fn add_summarySupport(&mut self, summarySupport: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYSUPPORT,
            summarySupport,
        );
    }
    #[inline]
    pub fn add_summaryNormalRecruit(
        &mut self,
        summaryNormalRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYNORMALRECRUIT,
            summaryNormalRecruit,
        );
    }
    #[inline]
    pub fn add_summaryDirectRecruit(
        &mut self,
        summaryDirectRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYDIRECTRECRUIT,
            summaryDirectRecruit,
        );
    }
    #[inline]
    pub fn add_summaryFriendRecruit(
        &mut self,
        summaryFriendRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYFRIENDRECRUIT,
            summaryFriendRecruit,
        );
    }
    #[inline]
    pub fn add_summaryFreeRecruit(&mut self, summaryFreeRecruit: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYFREERECRUIT,
            summaryFreeRecruit,
        );
    }
    #[inline]
    pub fn add_summaryMonthRecruit(
        &mut self,
        summaryMonthRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYMONTHRECRUIT,
            summaryMonthRecruit,
        );
    }
    #[inline]
    pub fn add_summaryUpgrade(&mut self, summaryUpgrade: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYUPGRADE,
            summaryUpgrade,
        );
    }
    #[inline]
    pub fn add_summaryCompleteEnding(
        &mut self,
        summaryCompleteEnding: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYCOMPLETEENDING,
            summaryCompleteEnding,
        );
    }
    #[inline]
    pub fn add_summaryEachZone(&mut self, summaryEachZone: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYEACHZONE,
            summaryEachZone,
        );
    }
    #[inline]
    pub fn add_summaryMeetSpZone(&mut self, summaryMeetSpZone: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYMEETSPZONE,
            summaryMeetSpZone,
        );
    }
    #[inline]
    pub fn add_summaryPerfectBattle(
        &mut self,
        summaryPerfectBattle: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYPERFECTBATTLE,
            summaryPerfectBattle,
        );
    }
    #[inline]
    pub fn add_summaryMeetBattle(&mut self, summaryMeetBattle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYMEETBATTLE,
            summaryMeetBattle,
        );
    }
    #[inline]
    pub fn add_summaryMeetEvent(&mut self, summaryMeetEvent: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYMEETEVENT,
            summaryMeetEvent,
        );
    }
    #[inline]
    pub fn add_summaryMeetShop(&mut self, summaryMeetShop: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYMEETSHOP,
            summaryMeetShop,
        );
    }
    #[inline]
    pub fn add_summaryMeetTreasure(
        &mut self,
        summaryMeetTreasure: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYMEETTREASURE,
            summaryMeetTreasure,
        );
    }
    #[inline]
    pub fn add_summaryMeetSecretpath(
        &mut self,
        summaryMeetSecretpath: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYMEETSECRETPATH,
            summaryMeetSecretpath,
        );
    }
    #[inline]
    pub fn add_summaryExchangeRelic(
        &mut self,
        summaryExchangeRelic: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYEXCHANGERELIC,
            summaryExchangeRelic,
        );
    }
    #[inline]
    pub fn add_summaryMeetTrade(&mut self, summaryMeetTrade: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYMEETTRADE,
            summaryMeetTrade,
        );
    }
    #[inline]
    pub fn add_summaryBuy(&mut self, summaryBuy: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYBUY,
            summaryBuy,
        );
    }
    #[inline]
    pub fn add_summaryBuyWithPriceId(
        &mut self,
        summaryBuyWithPriceId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYBUYWITHPRICEID,
            summaryBuyWithPriceId,
        );
    }
    #[inline]
    pub fn add_summaryInvest(&mut self, summaryInvest: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYINVEST,
            summaryInvest,
        );
    }
    #[inline]
    pub fn add_summaryGet(&mut self, summaryGet: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYGET,
            summaryGet,
        );
    }
    #[inline]
    pub fn add_summaryRelic(&mut self, summaryRelic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYRELIC,
            summaryRelic,
        );
    }
    #[inline]
    pub fn add_summarySafeHouse(&mut self, summarySafeHouse: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYSAFEHOUSE,
            summarySafeHouse,
        );
    }
    #[inline]
    pub fn add_summaryFailEnd(&mut self, summaryFailEnd: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYFAILEND,
            summaryFailEnd,
        );
    }
    #[inline]
    pub fn add_summaryStockRecruitTicket(
        &mut self,
        summaryStockRecruitTicket: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYSTOCKRECRUITTICKET,
            summaryStockRecruitTicket,
        );
    }
    #[inline]
    pub fn add_summaryDuelWin(&mut self, summaryDuelWin: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYDUELWIN,
            summaryDuelWin,
        );
    }
    #[inline]
    pub fn add_summaryDuelTie(&mut self, summaryDuelTie: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYDUELTIE,
            summaryDuelTie,
        );
    }
    #[inline]
    pub fn add_summaryDuelLose(&mut self, summaryDuelLose: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYDUELLOSE,
            summaryDuelLose,
        );
    }
    #[inline]
    pub fn add_summaryExpeditionGo(
        &mut self,
        summaryExpeditionGo: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYEXPEDITIONGO,
            summaryExpeditionGo,
        );
    }
    #[inline]
    pub fn add_summaryExpeditionBack(
        &mut self,
        summaryExpeditionBack: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03EndingText::VT_SUMMARYEXPEDITIONBACK,
            summaryExpeditionBack,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL03EndingTextBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL03EndingTextBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL03EndingText<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL03EndingText<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL03EndingText");
        ds.field("summaryGetTotem", &self.summaryGetTotem());
        ds.field("summaryDemoPointUp", &self.summaryDemoPointUp());
        ds.field("summaryDemoPointDown", &self.summaryDemoPointDown());
        ds.field("summaryDemoGradeUp", &self.summaryDemoGradeUp());
        ds.field("summaryDemoGradeDown", &self.summaryDemoGradeDown());
        ds.field("summaryVisionPointUp", &self.summaryVisionPointUp());
        ds.field("summaryVisionPointDown", &self.summaryVisionPointDown());
        ds.field("summaryVisionGradeUp", &self.summaryVisionGradeUp());
        ds.field("summaryVisionGradeDown", &self.summaryVisionGradeDown());
        ds.field("summaryFightWin", &self.summaryFightWin());
        ds.field("summaryFightFail", &self.summaryFightFail());
        ds.field("summaryExchangeTotem", &self.summaryExchangeTotem());
        ds.field("summaryUseTotem", &self.summaryUseTotem());
        ds.field("summaryVisionGrade", &self.summaryVisionGrade());
        ds.field("summaryActor", &self.summaryActor());
        ds.field("summaryTop", &self.summaryTop());
        ds.field("summaryZone", &self.summaryZone());
        ds.field("summaryEnding", &self.summaryEnding());
        ds.field("summaryDifficultyZone", &self.summaryDifficultyZone());
        ds.field("summaryDifficultyEnding", &self.summaryDifficultyEnding());
        ds.field("summaryMode", &self.summaryMode());
        ds.field("summaryGroup", &self.summaryGroup());
        ds.field("summarySupport", &self.summarySupport());
        ds.field("summaryNormalRecruit", &self.summaryNormalRecruit());
        ds.field("summaryDirectRecruit", &self.summaryDirectRecruit());
        ds.field("summaryFriendRecruit", &self.summaryFriendRecruit());
        ds.field("summaryFreeRecruit", &self.summaryFreeRecruit());
        ds.field("summaryMonthRecruit", &self.summaryMonthRecruit());
        ds.field("summaryUpgrade", &self.summaryUpgrade());
        ds.field("summaryCompleteEnding", &self.summaryCompleteEnding());
        ds.field("summaryEachZone", &self.summaryEachZone());
        ds.field("summaryMeetSpZone", &self.summaryMeetSpZone());
        ds.field("summaryPerfectBattle", &self.summaryPerfectBattle());
        ds.field("summaryMeetBattle", &self.summaryMeetBattle());
        ds.field("summaryMeetEvent", &self.summaryMeetEvent());
        ds.field("summaryMeetShop", &self.summaryMeetShop());
        ds.field("summaryMeetTreasure", &self.summaryMeetTreasure());
        ds.field("summaryMeetSecretpath", &self.summaryMeetSecretpath());
        ds.field("summaryExchangeRelic", &self.summaryExchangeRelic());
        ds.field("summaryMeetTrade", &self.summaryMeetTrade());
        ds.field("summaryBuy", &self.summaryBuy());
        ds.field("summaryBuyWithPriceId", &self.summaryBuyWithPriceId());
        ds.field("summaryInvest", &self.summaryInvest());
        ds.field("summaryGet", &self.summaryGet());
        ds.field("summaryRelic", &self.summaryRelic());
        ds.field("summarySafeHouse", &self.summarySafeHouse());
        ds.field("summaryFailEnd", &self.summaryFailEnd());
        ds.field(
            "summaryStockRecruitTicket",
            &self.summaryStockRecruitTicket(),
        );
        ds.field("summaryDuelWin", &self.summaryDuelWin());
        ds.field("summaryDuelTie", &self.summaryDuelTie());
        ds.field("summaryDuelLose", &self.summaryDuelLose());
        ds.field("summaryExpeditionGo", &self.summaryExpeditionGo());
        ds.field("summaryExpeditionBack", &self.summaryExpeditionBack());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL03EndingTextT {
    pub summaryGetTotem: Option<String>,
    pub summaryDemoPointUp: Option<String>,
    pub summaryDemoPointDown: Option<String>,
    pub summaryDemoGradeUp: Option<String>,
    pub summaryDemoGradeDown: Option<String>,
    pub summaryVisionPointUp: Option<String>,
    pub summaryVisionPointDown: Option<String>,
    pub summaryVisionGradeUp: Option<String>,
    pub summaryVisionGradeDown: Option<String>,
    pub summaryFightWin: Option<String>,
    pub summaryFightFail: Option<String>,
    pub summaryExchangeTotem: Option<String>,
    pub summaryUseTotem: Option<String>,
    pub summaryVisionGrade: Option<String>,
    pub summaryActor: Option<String>,
    pub summaryTop: Option<String>,
    pub summaryZone: Option<String>,
    pub summaryEnding: Option<String>,
    pub summaryDifficultyZone: Option<String>,
    pub summaryDifficultyEnding: Option<String>,
    pub summaryMode: Option<String>,
    pub summaryGroup: Option<String>,
    pub summarySupport: Option<String>,
    pub summaryNormalRecruit: Option<String>,
    pub summaryDirectRecruit: Option<String>,
    pub summaryFriendRecruit: Option<String>,
    pub summaryFreeRecruit: Option<String>,
    pub summaryMonthRecruit: Option<String>,
    pub summaryUpgrade: Option<String>,
    pub summaryCompleteEnding: Option<String>,
    pub summaryEachZone: Option<String>,
    pub summaryMeetSpZone: Option<String>,
    pub summaryPerfectBattle: Option<String>,
    pub summaryMeetBattle: Option<String>,
    pub summaryMeetEvent: Option<String>,
    pub summaryMeetShop: Option<String>,
    pub summaryMeetTreasure: Option<String>,
    pub summaryMeetSecretpath: Option<String>,
    pub summaryExchangeRelic: Option<String>,
    pub summaryMeetTrade: Option<String>,
    pub summaryBuy: Option<String>,
    pub summaryBuyWithPriceId: Option<String>,
    pub summaryInvest: Option<String>,
    pub summaryGet: Option<String>,
    pub summaryRelic: Option<String>,
    pub summarySafeHouse: Option<String>,
    pub summaryFailEnd: Option<String>,
    pub summaryStockRecruitTicket: Option<String>,
    pub summaryDuelWin: Option<String>,
    pub summaryDuelTie: Option<String>,
    pub summaryDuelLose: Option<String>,
    pub summaryExpeditionGo: Option<String>,
    pub summaryExpeditionBack: Option<String>,
}
impl Default for clz_Torappu_RL03EndingTextT {
    fn default() -> Self {
        Self {
            summaryGetTotem: None,
            summaryDemoPointUp: None,
            summaryDemoPointDown: None,
            summaryDemoGradeUp: None,
            summaryDemoGradeDown: None,
            summaryVisionPointUp: None,
            summaryVisionPointDown: None,
            summaryVisionGradeUp: None,
            summaryVisionGradeDown: None,
            summaryFightWin: None,
            summaryFightFail: None,
            summaryExchangeTotem: None,
            summaryUseTotem: None,
            summaryVisionGrade: None,
            summaryActor: None,
            summaryTop: None,
            summaryZone: None,
            summaryEnding: None,
            summaryDifficultyZone: None,
            summaryDifficultyEnding: None,
            summaryMode: None,
            summaryGroup: None,
            summarySupport: None,
            summaryNormalRecruit: None,
            summaryDirectRecruit: None,
            summaryFriendRecruit: None,
            summaryFreeRecruit: None,
            summaryMonthRecruit: None,
            summaryUpgrade: None,
            summaryCompleteEnding: None,
            summaryEachZone: None,
            summaryMeetSpZone: None,
            summaryPerfectBattle: None,
            summaryMeetBattle: None,
            summaryMeetEvent: None,
            summaryMeetShop: None,
            summaryMeetTreasure: None,
            summaryMeetSecretpath: None,
            summaryExchangeRelic: None,
            summaryMeetTrade: None,
            summaryBuy: None,
            summaryBuyWithPriceId: None,
            summaryInvest: None,
            summaryGet: None,
            summaryRelic: None,
            summarySafeHouse: None,
            summaryFailEnd: None,
            summaryStockRecruitTicket: None,
            summaryDuelWin: None,
            summaryDuelTie: None,
            summaryDuelLose: None,
            summaryExpeditionGo: None,
            summaryExpeditionBack: None,
        }
    }
}
impl clz_Torappu_RL03EndingTextT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL03EndingText<'b>> {
        let summaryGetTotem = self.summaryGetTotem.as_ref().map(|x| _fbb.create_string(x));
        let summaryDemoPointUp = self
            .summaryDemoPointUp
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDemoPointDown = self
            .summaryDemoPointDown
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDemoGradeUp = self
            .summaryDemoGradeUp
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDemoGradeDown = self
            .summaryDemoGradeDown
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryVisionPointUp = self
            .summaryVisionPointUp
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryVisionPointDown = self
            .summaryVisionPointDown
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryVisionGradeUp = self
            .summaryVisionGradeUp
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryVisionGradeDown = self
            .summaryVisionGradeDown
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryFightWin = self.summaryFightWin.as_ref().map(|x| _fbb.create_string(x));
        let summaryFightFail = self
            .summaryFightFail
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExchangeTotem = self
            .summaryExchangeTotem
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryUseTotem = self.summaryUseTotem.as_ref().map(|x| _fbb.create_string(x));
        let summaryVisionGrade = self
            .summaryVisionGrade
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryActor = self.summaryActor.as_ref().map(|x| _fbb.create_string(x));
        let summaryTop = self.summaryTop.as_ref().map(|x| _fbb.create_string(x));
        let summaryZone = self.summaryZone.as_ref().map(|x| _fbb.create_string(x));
        let summaryEnding = self.summaryEnding.as_ref().map(|x| _fbb.create_string(x));
        let summaryDifficultyZone = self
            .summaryDifficultyZone
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDifficultyEnding = self
            .summaryDifficultyEnding
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMode = self.summaryMode.as_ref().map(|x| _fbb.create_string(x));
        let summaryGroup = self.summaryGroup.as_ref().map(|x| _fbb.create_string(x));
        let summarySupport = self.summarySupport.as_ref().map(|x| _fbb.create_string(x));
        let summaryNormalRecruit = self
            .summaryNormalRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDirectRecruit = self
            .summaryDirectRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryFriendRecruit = self
            .summaryFriendRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryFreeRecruit = self
            .summaryFreeRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMonthRecruit = self
            .summaryMonthRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryUpgrade = self.summaryUpgrade.as_ref().map(|x| _fbb.create_string(x));
        let summaryCompleteEnding = self
            .summaryCompleteEnding
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryEachZone = self.summaryEachZone.as_ref().map(|x| _fbb.create_string(x));
        let summaryMeetSpZone = self
            .summaryMeetSpZone
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryPerfectBattle = self
            .summaryPerfectBattle
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetBattle = self
            .summaryMeetBattle
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetEvent = self
            .summaryMeetEvent
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetShop = self.summaryMeetShop.as_ref().map(|x| _fbb.create_string(x));
        let summaryMeetTreasure = self
            .summaryMeetTreasure
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetSecretpath = self
            .summaryMeetSecretpath
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExchangeRelic = self
            .summaryExchangeRelic
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetTrade = self
            .summaryMeetTrade
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryBuy = self.summaryBuy.as_ref().map(|x| _fbb.create_string(x));
        let summaryBuyWithPriceId = self
            .summaryBuyWithPriceId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryInvest = self.summaryInvest.as_ref().map(|x| _fbb.create_string(x));
        let summaryGet = self.summaryGet.as_ref().map(|x| _fbb.create_string(x));
        let summaryRelic = self.summaryRelic.as_ref().map(|x| _fbb.create_string(x));
        let summarySafeHouse = self
            .summarySafeHouse
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryFailEnd = self.summaryFailEnd.as_ref().map(|x| _fbb.create_string(x));
        let summaryStockRecruitTicket = self
            .summaryStockRecruitTicket
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDuelWin = self.summaryDuelWin.as_ref().map(|x| _fbb.create_string(x));
        let summaryDuelTie = self.summaryDuelTie.as_ref().map(|x| _fbb.create_string(x));
        let summaryDuelLose = self.summaryDuelLose.as_ref().map(|x| _fbb.create_string(x));
        let summaryExpeditionGo = self
            .summaryExpeditionGo
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExpeditionBack = self
            .summaryExpeditionBack
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RL03EndingText::create(
            _fbb,
            &clz_Torappu_RL03EndingTextArgs {
                summaryGetTotem,
                summaryDemoPointUp,
                summaryDemoPointDown,
                summaryDemoGradeUp,
                summaryDemoGradeDown,
                summaryVisionPointUp,
                summaryVisionPointDown,
                summaryVisionGradeUp,
                summaryVisionGradeDown,
                summaryFightWin,
                summaryFightFail,
                summaryExchangeTotem,
                summaryUseTotem,
                summaryVisionGrade,
                summaryActor,
                summaryTop,
                summaryZone,
                summaryEnding,
                summaryDifficultyZone,
                summaryDifficultyEnding,
                summaryMode,
                summaryGroup,
                summarySupport,
                summaryNormalRecruit,
                summaryDirectRecruit,
                summaryFriendRecruit,
                summaryFreeRecruit,
                summaryMonthRecruit,
                summaryUpgrade,
                summaryCompleteEnding,
                summaryEachZone,
                summaryMeetSpZone,
                summaryPerfectBattle,
                summaryMeetBattle,
                summaryMeetEvent,
                summaryMeetShop,
                summaryMeetTreasure,
                summaryMeetSecretpath,
                summaryExchangeRelic,
                summaryMeetTrade,
                summaryBuy,
                summaryBuyWithPriceId,
                summaryInvest,
                summaryGet,
                summaryRelic,
                summarySafeHouse,
                summaryFailEnd,
                summaryStockRecruitTicket,
                summaryDuelWin,
                summaryDuelTie,
                summaryDuelLose,
                summaryExpeditionGo,
                summaryExpeditionBack,
            },
        )
    }
}
pub enum clz_Torappu_RL03DifficultyExtOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL03DifficultyExt<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL03DifficultyExt<'a> {
    type Inner = clz_Torappu_RL03DifficultyExt<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL03DifficultyExt<'a> {
    pub const VT_MODEDIFFICULTY: flatbuffers::VOffsetT = 4;
    pub const VT_GRADE: flatbuffers::VOffsetT = 6;
    pub const VT_TOTEMPROB: flatbuffers::VOffsetT = 8;
    pub const VT_RELICDEVLEVEL: flatbuffers::VOffsetT = 10;
    pub const VT_BUFFS: flatbuffers::VOffsetT = 12;
    pub const VT_BUFFDESC: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL03DifficultyExt { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL03DifficultyExtArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL03DifficultyExt<'bldr>> {
        let mut builder = clz_Torappu_RL03DifficultyExtBuilder::new(_fbb);
        if let Some(x) = args.buffDesc {
            builder.add_buffDesc(x);
        }
        if let Some(x) = args.buffs {
            builder.add_buffs(x);
        }
        if let Some(x) = args.relicDevLevel {
            builder.add_relicDevLevel(x);
        }
        builder.add_totemProb(args.totemProb);
        builder.add_grade(args.grade);
        builder.add_modeDifficulty(args.modeDifficulty);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL03DifficultyExtT {
        let modeDifficulty = self.modeDifficulty();
        let grade = self.grade();
        let totemProb = self.totemProb();
        let relicDevLevel = self.relicDevLevel().map(|x| x.to_string());
        let buffs = self
            .buffs()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let buffDesc = self
            .buffDesc()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_RL03DifficultyExtT {
            modeDifficulty,
            grade,
            totemProb,
            relicDevLevel,
            buffs,
            buffDesc,
        }
    }

    #[inline]
    pub fn modeDifficulty(&self) -> enum__Torappu_RoguelikeTopicMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTopicMode>(
                    clz_Torappu_RL03DifficultyExt::VT_MODEDIFFICULTY,
                    Some(enum__Torappu_RoguelikeTopicMode::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn grade(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL03DifficultyExt::VT_GRADE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn totemProb(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_RL03DifficultyExt::VT_TOTEMPROB, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn relicDevLevel(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL03DifficultyExt::VT_RELICDEVLEVEL,
                None,
            )
        }
    }
    #[inline]
    pub fn buffs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RL03DifficultyExt::VT_BUFFS, None)
        }
    }
    #[inline]
    pub fn buffDesc(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RL03DifficultyExt::VT_BUFFDESC, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL03DifficultyExt<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeTopicMode>(
                "modeDifficulty",
                Self::VT_MODEDIFFICULTY,
                false,
            )?
            .visit_field::<i32>("grade", Self::VT_GRADE, false)?
            .visit_field::<f32>("totemProb", Self::VT_TOTEMPROB, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "relicDevLevel",
                Self::VT_RELICDEVLEVEL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("buffs", Self::VT_BUFFS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("buffDesc", Self::VT_BUFFDESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL03DifficultyExtArgs<'a> {
    pub modeDifficulty: enum__Torappu_RoguelikeTopicMode,
    pub grade: i32,
    pub totemProb: f32,
    pub relicDevLevel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffs: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub buffDesc: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_RL03DifficultyExtArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL03DifficultyExtArgs {
            modeDifficulty: enum__Torappu_RoguelikeTopicMode::NONE,
            grade: 0,
            totemProb: 0.0,
            relicDevLevel: None,
            buffs: None,
            buffDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_RL03DifficultyExt<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL03DifficultyExt", 6)?;
        s.serialize_field("modeDifficulty", &self.modeDifficulty())?;
        s.serialize_field("grade", &self.grade())?;
        s.serialize_field("totemProb", &self.totemProb())?;
        if let Some(f) = self.relicDevLevel() {
            s.serialize_field("relicDevLevel", &f)?;
        } else {
            s.skip_field("relicDevLevel")?;
        }
        if let Some(f) = self.buffs() {
            s.serialize_field("buffs", &f)?;
        } else {
            s.skip_field("buffs")?;
        }
        if let Some(f) = self.buffDesc() {
            s.serialize_field("buffDesc", &f)?;
        } else {
            s.skip_field("buffDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL03DifficultyExtBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL03DifficultyExtBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_modeDifficulty(&mut self, modeDifficulty: enum__Torappu_RoguelikeTopicMode) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeTopicMode>(
            clz_Torappu_RL03DifficultyExt::VT_MODEDIFFICULTY,
            modeDifficulty,
            enum__Torappu_RoguelikeTopicMode::NONE,
        );
    }
    #[inline]
    pub fn add_grade(&mut self, grade: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL03DifficultyExt::VT_GRADE, grade, 0);
    }
    #[inline]
    pub fn add_totemProb(&mut self, totemProb: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_RL03DifficultyExt::VT_TOTEMPROB, totemProb, 0.0);
    }
    #[inline]
    pub fn add_relicDevLevel(&mut self, relicDevLevel: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03DifficultyExt::VT_RELICDEVLEVEL,
            relicDevLevel,
        );
    }
    #[inline]
    pub fn add_buffs(
        &mut self,
        buffs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03DifficultyExt::VT_BUFFS,
            buffs,
        );
    }
    #[inline]
    pub fn add_buffDesc(
        &mut self,
        buffDesc: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03DifficultyExt::VT_BUFFDESC,
            buffDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL03DifficultyExtBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL03DifficultyExtBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL03DifficultyExt<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL03DifficultyExt<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL03DifficultyExt");
        ds.field("modeDifficulty", &self.modeDifficulty());
        ds.field("grade", &self.grade());
        ds.field("totemProb", &self.totemProb());
        ds.field("relicDevLevel", &self.relicDevLevel());
        ds.field("buffs", &self.buffs());
        ds.field("buffDesc", &self.buffDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL03DifficultyExtT {
    pub modeDifficulty: enum__Torappu_RoguelikeTopicMode,
    pub grade: i32,
    pub totemProb: f32,
    pub relicDevLevel: Option<String>,
    pub buffs: Option<Vec<String>>,
    pub buffDesc: Option<Vec<String>>,
}
impl Default for clz_Torappu_RL03DifficultyExtT {
    fn default() -> Self {
        Self {
            modeDifficulty: enum__Torappu_RoguelikeTopicMode::NONE,
            grade: 0,
            totemProb: 0.0,
            relicDevLevel: None,
            buffs: None,
            buffDesc: None,
        }
    }
}
impl clz_Torappu_RL03DifficultyExtT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL03DifficultyExt<'b>> {
        let modeDifficulty = self.modeDifficulty;
        let grade = self.grade;
        let totemProb = self.totemProb;
        let relicDevLevel = self.relicDevLevel.as_ref().map(|x| _fbb.create_string(x));
        let buffs = self.buffs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let buffDesc = self.buffDesc.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RL03DifficultyExt::create(
            _fbb,
            &clz_Torappu_RL03DifficultyExtArgs {
                modeDifficulty,
                grade,
                totemProb,
                relicDevLevel,
                buffs,
                buffDesc,
            },
        )
    }
}
pub enum clz_Torappu_RL03CustomizeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL03CustomizeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL03CustomizeData<'a> {
    type Inner = clz_Torappu_RL03CustomizeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL03CustomizeData<'a> {
    pub const VT_DEVELOPMENTS: flatbuffers::VOffsetT = 4;
    pub const VT_DEVELOPMENTSTOKENS: flatbuffers::VOffsetT = 6;
    pub const VT_DEVELOPMENTRAWTEXTGROUP: flatbuffers::VOffsetT = 8;
    pub const VT_DEVELOPMENTSDIFFICULTYNODEINFOS: flatbuffers::VOffsetT = 10;
    pub const VT_ENDINGTEXT: flatbuffers::VOffsetT = 12;
    pub const VT_DIFFICULTIES: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL03CustomizeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL03CustomizeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL03CustomizeData<'bldr>> {
        let mut builder = clz_Torappu_RL03CustomizeDataBuilder::new(_fbb);
        if let Some(x) = args.difficulties {
            builder.add_difficulties(x);
        }
        if let Some(x) = args.endingText {
            builder.add_endingText(x);
        }
        if let Some(x) = args.developmentsDifficultyNodeInfos {
            builder.add_developmentsDifficultyNodeInfos(x);
        }
        if let Some(x) = args.developmentRawTextGroup {
            builder.add_developmentRawTextGroup(x);
        }
        if let Some(x) = args.developmentsTokens {
            builder.add_developmentsTokens(x);
        }
        if let Some(x) = args.developments {
            builder.add_developments(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL03CustomizeDataT {
        let developments = self
            .developments()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let developmentsTokens = self
            .developmentsTokens()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let developmentRawTextGroup = self
            .developmentRawTextGroup()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let developmentsDifficultyNodeInfos = self
            .developmentsDifficultyNodeInfos()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let endingText = self.endingText().map(|x| Box::new(x.unpack()));
        let difficulties = self
            .difficulties()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RL03CustomizeDataT {
            developments,
            developmentsTokens,
            developmentRawTextGroup,
            developmentsDifficultyNodeInfos,
            endingText,
            difficulties,
        }
    }

    #[inline]
    pub fn developments(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RL03Development<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RL03Development>,
                >,
            >>(clz_Torappu_RL03CustomizeData::VT_DEVELOPMENTS, None)
        }
    }
    #[inline]
    pub fn developmentsTokens(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken>,
                >,
            >>(clz_Torappu_RL03CustomizeData::VT_DEVELOPMENTSTOKENS, None)
        }
    }
    #[inline]
    pub fn developmentRawTextGroup(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RL03DevRawTextBuffGroup<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL03DevRawTextBuffGroup>,
                >,
            >>(
                clz_Torappu_RL03CustomizeData::VT_DEVELOPMENTRAWTEXTGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn developmentsDifficultyNodeInfos(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RL03DevDifficultyNodeInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RL03DevDifficultyNodeInfo,
                    >,
                >,
            >>(
                clz_Torappu_RL03CustomizeData::VT_DEVELOPMENTSDIFFICULTYNODEINFOS,
                None,
            )
        }
    }
    #[inline]
    pub fn endingText(&self) -> Option<clz_Torappu_RL03EndingText<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RL03EndingText>>(
                    clz_Torappu_RL03CustomizeData::VT_ENDINGTEXT,
                    None,
                )
        }
    }
    #[inline]
    pub fn difficulties(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RL03DifficultyExt<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL03DifficultyExt>,
                >,
            >>(clz_Torappu_RL03CustomizeData::VT_DIFFICULTIES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL03CustomizeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RL03Development>,
                >,
            >>("developments", Self::VT_DEVELOPMENTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken>,
                >,
            >>("developmentsTokens", Self::VT_DEVELOPMENTSTOKENS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL03DevRawTextBuffGroup>,
                >,
            >>(
                "developmentRawTextGroup",
                Self::VT_DEVELOPMENTRAWTEXTGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RL03DevDifficultyNodeInfo,
                    >,
                >,
            >>(
                "developmentsDifficultyNodeInfos",
                Self::VT_DEVELOPMENTSDIFFICULTYNODEINFOS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RL03EndingText>>(
                "endingText",
                Self::VT_ENDINGTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL03DifficultyExt>,
                >,
            >>("difficulties", Self::VT_DIFFICULTIES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL03CustomizeDataArgs<'a> {
    pub developments: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RL03Development<'a>>,
            >,
        >,
    >,
    pub developmentsTokens: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken<'a>>,
            >,
        >,
    >,
    pub developmentRawTextGroup: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL03DevRawTextBuffGroup<'a>>,
            >,
        >,
    >,
    pub developmentsDifficultyNodeInfos: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RL03DevDifficultyNodeInfo<'a>,
                >,
            >,
        >,
    >,
    pub endingText: Option<flatbuffers::WIPOffset<clz_Torappu_RL03EndingText<'a>>>,
    pub difficulties: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL03DifficultyExt<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RL03CustomizeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL03CustomizeDataArgs {
            developments: None,
            developmentsTokens: None,
            developmentRawTextGroup: None,
            developmentsDifficultyNodeInfos: None,
            endingText: None,
            difficulties: None,
        }
    }
}

impl Serialize for clz_Torappu_RL03CustomizeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL03CustomizeData", 6)?;
        if let Some(f) = self.developments() {
            s.serialize_field("developments", &f)?;
        } else {
            s.skip_field("developments")?;
        }
        if let Some(f) = self.developmentsTokens() {
            s.serialize_field("developmentsTokens", &f)?;
        } else {
            s.skip_field("developmentsTokens")?;
        }
        if let Some(f) = self.developmentRawTextGroup() {
            s.serialize_field("developmentRawTextGroup", &f)?;
        } else {
            s.skip_field("developmentRawTextGroup")?;
        }
        if let Some(f) = self.developmentsDifficultyNodeInfos() {
            s.serialize_field("developmentsDifficultyNodeInfos", &f)?;
        } else {
            s.skip_field("developmentsDifficultyNodeInfos")?;
        }
        if let Some(f) = self.endingText() {
            s.serialize_field("endingText", &f)?;
        } else {
            s.skip_field("endingText")?;
        }
        if let Some(f) = self.difficulties() {
            s.serialize_field("difficulties", &f)?;
        } else {
            s.skip_field("difficulties")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL03CustomizeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL03CustomizeDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_developments(
        &mut self,
        developments: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RL03Development<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03CustomizeData::VT_DEVELOPMENTS,
            developments,
        );
    }
    #[inline]
    pub fn add_developmentsTokens(
        &mut self,
        developmentsTokens: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03CustomizeData::VT_DEVELOPMENTSTOKENS,
            developmentsTokens,
        );
    }
    #[inline]
    pub fn add_developmentRawTextGroup(
        &mut self,
        developmentRawTextGroup: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL03DevRawTextBuffGroup<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03CustomizeData::VT_DEVELOPMENTRAWTEXTGROUP,
            developmentRawTextGroup,
        );
    }
    #[inline]
    pub fn add_developmentsDifficultyNodeInfos(
        &mut self,
        developmentsDifficultyNodeInfos: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RL03DevDifficultyNodeInfo<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03CustomizeData::VT_DEVELOPMENTSDIFFICULTYNODEINFOS,
            developmentsDifficultyNodeInfos,
        );
    }
    #[inline]
    pub fn add_endingText(
        &mut self,
        endingText: flatbuffers::WIPOffset<clz_Torappu_RL03EndingText<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RL03EndingText>>(
                clz_Torappu_RL03CustomizeData::VT_ENDINGTEXT,
                endingText,
            );
    }
    #[inline]
    pub fn add_difficulties(
        &mut self,
        difficulties: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL03DifficultyExt<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL03CustomizeData::VT_DIFFICULTIES,
            difficulties,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL03CustomizeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL03CustomizeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL03CustomizeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL03CustomizeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL03CustomizeData");
        ds.field("developments", &self.developments());
        ds.field("developmentsTokens", &self.developmentsTokens());
        ds.field("developmentRawTextGroup", &self.developmentRawTextGroup());
        ds.field(
            "developmentsDifficultyNodeInfos",
            &self.developmentsDifficultyNodeInfos(),
        );
        ds.field("endingText", &self.endingText());
        ds.field("difficulties", &self.difficulties());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL03CustomizeDataT {
    pub developments: Option<Vec<dict__string__clz_Torappu_RL03DevelopmentT>>,
    pub developmentsTokens: Option<Vec<dict__string__clz_Torappu_RoguelikeTopicDevTokenT>>,
    pub developmentRawTextGroup: Option<Vec<clz_Torappu_RL03DevRawTextBuffGroupT>>,
    pub developmentsDifficultyNodeInfos:
        Option<Vec<dict__string__clz_Torappu_RL03DevDifficultyNodeInfoT>>,
    pub endingText: Option<Box<clz_Torappu_RL03EndingTextT>>,
    pub difficulties: Option<Vec<clz_Torappu_RL03DifficultyExtT>>,
}
impl Default for clz_Torappu_RL03CustomizeDataT {
    fn default() -> Self {
        Self {
            developments: None,
            developmentsTokens: None,
            developmentRawTextGroup: None,
            developmentsDifficultyNodeInfos: None,
            endingText: None,
            difficulties: None,
        }
    }
}
impl clz_Torappu_RL03CustomizeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL03CustomizeData<'b>> {
        let developments = self.developments.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let developmentsTokens = self.developmentsTokens.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let developmentRawTextGroup = self.developmentRawTextGroup.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let developmentsDifficultyNodeInfos =
            self.developmentsDifficultyNodeInfos.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
        let endingText = self.endingText.as_ref().map(|x| x.pack(_fbb));
        let difficulties = self.difficulties.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RL03CustomizeData::create(
            _fbb,
            &clz_Torappu_RL03CustomizeDataArgs {
                developments,
                developmentsTokens,
                developmentRawTextGroup,
                developmentsDifficultyNodeInfos,
                endingText,
                difficulties,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeCommonDevelopmentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeCommonDevelopment<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeCommonDevelopment<'a> {
    type Inner = clz_Torappu_RoguelikeCommonDevelopment<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeCommonDevelopment<'a> {
    pub const VT_BUFFID: flatbuffers::VOffsetT = 4;
    pub const VT_NODETYPE: flatbuffers::VOffsetT = 6;
    pub const VT_FRONTNODEID: flatbuffers::VOffsetT = 8;
    pub const VT_NEXTNODEID: flatbuffers::VOffsetT = 10;
    pub const VT_POSITIONROW: flatbuffers::VOffsetT = 12;
    pub const VT_POSITIONORDER: flatbuffers::VOffsetT = 14;
    pub const VT_TOKENCOST: flatbuffers::VOffsetT = 16;
    pub const VT_BUFFNAME: flatbuffers::VOffsetT = 18;
    pub const VT_ACTIVEICONID: flatbuffers::VOffsetT = 20;
    pub const VT_INACTIVEICONID: flatbuffers::VOffsetT = 22;
    pub const VT_BOTTOMICONID: flatbuffers::VOffsetT = 24;
    pub const VT_EFFECTTYPE: flatbuffers::VOffsetT = 26;
    pub const VT_RAWDESC: flatbuffers::VOffsetT = 28;
    pub const VT_BUFFDISPLAYINFO: flatbuffers::VOffsetT = 30;
    pub const VT_GROUPID: flatbuffers::VOffsetT = 32;
    pub const VT_ENROLLID: flatbuffers::VOffsetT = 34;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeCommonDevelopment { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeCommonDevelopmentArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevelopment<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeCommonDevelopmentBuilder::new(_fbb);
        if let Some(x) = args.enrollId {
            builder.add_enrollId(x);
        }
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        if let Some(x) = args.buffDisplayInfo {
            builder.add_buffDisplayInfo(x);
        }
        if let Some(x) = args.rawDesc {
            builder.add_rawDesc(x);
        }
        builder.add_effectType(args.effectType);
        if let Some(x) = args.bottomIconId {
            builder.add_bottomIconId(x);
        }
        if let Some(x) = args.inactiveIconId {
            builder.add_inactiveIconId(x);
        }
        if let Some(x) = args.activeIconId {
            builder.add_activeIconId(x);
        }
        if let Some(x) = args.buffName {
            builder.add_buffName(x);
        }
        builder.add_tokenCost(args.tokenCost);
        builder.add_positionOrder(args.positionOrder);
        builder.add_positionRow(args.positionRow);
        if let Some(x) = args.nextNodeId {
            builder.add_nextNodeId(x);
        }
        if let Some(x) = args.frontNodeId {
            builder.add_frontNodeId(x);
        }
        builder.add_nodeType(args.nodeType);
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeCommonDevelopmentT {
        let buffId = self.buffId().map(|x| x.to_string());
        let nodeType = self.nodeType();
        let frontNodeId = self
            .frontNodeId()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let nextNodeId = self
            .nextNodeId()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let positionRow = self.positionRow();
        let positionOrder = self.positionOrder();
        let tokenCost = self.tokenCost();
        let buffName = self.buffName().map(|x| x.to_string());
        let activeIconId = self.activeIconId().map(|x| x.to_string());
        let inactiveIconId = self.inactiveIconId().map(|x| x.to_string());
        let bottomIconId = self.bottomIconId().map(|x| x.to_string());
        let effectType = self.effectType();
        let rawDesc = self
            .rawDesc()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let buffDisplayInfo = self
            .buffDisplayInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let groupId = self.groupId().map(|x| x.to_string());
        let enrollId = self.enrollId().map(|x| x.to_string());
        clz_Torappu_RoguelikeCommonDevelopmentT {
            buffId,
            nodeType,
            frontNodeId,
            nextNodeId,
            positionRow,
            positionOrder,
            tokenCost,
            buffName,
            activeIconId,
            inactiveIconId,
            bottomIconId,
            effectType,
            rawDesc,
            buffDisplayInfo,
            groupId,
            enrollId,
        }
    }

    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCommonDevelopment::VT_BUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeType(&self) -> enum__Torappu_RoguelikeCommonDevelopmentNodeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeCommonDevelopmentNodeType>(
                    clz_Torappu_RoguelikeCommonDevelopment::VT_NODETYPE,
                    Some(enum__Torappu_RoguelikeCommonDevelopmentNodeType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn frontNodeId(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RoguelikeCommonDevelopment::VT_FRONTNODEID, None)
        }
    }
    #[inline]
    pub fn nextNodeId(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RoguelikeCommonDevelopment::VT_NEXTNODEID, None)
        }
    }
    #[inline]
    pub fn positionRow(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeCommonDevelopment::VT_POSITIONROW,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn positionOrder(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeCommonDevelopment::VT_POSITIONORDER,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn tokenCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeCommonDevelopment::VT_TOKENCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buffName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCommonDevelopment::VT_BUFFNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn activeIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCommonDevelopment::VT_ACTIVEICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn inactiveIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCommonDevelopment::VT_INACTIVEICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn bottomIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCommonDevelopment::VT_BOTTOMICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn effectType(&self) -> enum__Torappu_RoguelikeCommonDevelopmentEffectType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeCommonDevelopmentEffectType>(
                    clz_Torappu_RoguelikeCommonDevelopment::VT_EFFECTTYPE,
                    Some(enum__Torappu_RoguelikeCommonDevelopmentEffectType::BUFF),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rawDesc(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RoguelikeCommonDevelopment::VT_RAWDESC, None)
        }
    }
    #[inline]
    pub fn buffDisplayInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem>,
                >,
            >>(
                clz_Torappu_RoguelikeCommonDevelopment::VT_BUFFDISPLAYINFO,
                None,
            )
        }
    }
    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCommonDevelopment::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn enrollId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCommonDevelopment::VT_ENROLLID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeCommonDevelopment<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .visit_field::<enum__Torappu_RoguelikeCommonDevelopmentNodeType>(
                "nodeType",
                Self::VT_NODETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("frontNodeId", Self::VT_FRONTNODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("nextNodeId", Self::VT_NEXTNODEID, false)?
            .visit_field::<i32>("positionRow", Self::VT_POSITIONROW, false)?
            .visit_field::<i32>("positionOrder", Self::VT_POSITIONORDER, false)?
            .visit_field::<i32>("tokenCost", Self::VT_TOKENCOST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffName",
                Self::VT_BUFFNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "activeIconId",
                Self::VT_ACTIVEICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "inactiveIconId",
                Self::VT_INACTIVEICONID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bottomIconId",
                Self::VT_BOTTOMICONID,
                false,
            )?
            .visit_field::<enum__Torappu_RoguelikeCommonDevelopmentEffectType>(
                "effectType",
                Self::VT_EFFECTTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("rawDesc", Self::VT_RAWDESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem>,
                >,
            >>("buffDisplayInfo", Self::VT_BUFFDISPLAYINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enrollId",
                Self::VT_ENROLLID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeCommonDevelopmentArgs<'a> {
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeType: enum__Torappu_RoguelikeCommonDevelopmentNodeType,
    pub frontNodeId: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub nextNodeId: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub positionRow: i32,
    pub positionOrder: i32,
    pub tokenCost: i32,
    pub buffName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub activeIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub inactiveIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bottomIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub effectType: enum__Torappu_RoguelikeCommonDevelopmentEffectType,
    pub rawDesc: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub buffDisplayInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem<'a>>,
            >,
        >,
    >,
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enrollId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeCommonDevelopmentArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeCommonDevelopmentArgs {
            buffId: None,
            nodeType: enum__Torappu_RoguelikeCommonDevelopmentNodeType::NONE,
            frontNodeId: None,
            nextNodeId: None,
            positionRow: 0,
            positionOrder: 0,
            tokenCost: 0,
            buffName: None,
            activeIconId: None,
            inactiveIconId: None,
            bottomIconId: None,
            effectType: enum__Torappu_RoguelikeCommonDevelopmentEffectType::BUFF,
            rawDesc: None,
            buffDisplayInfo: None,
            groupId: None,
            enrollId: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeCommonDevelopment<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeCommonDevelopment", 16)?;
        if let Some(f) = self.buffId() {
            s.serialize_field("buffId", &f)?;
        } else {
            s.skip_field("buffId")?;
        }
        s.serialize_field("nodeType", &self.nodeType())?;
        if let Some(f) = self.frontNodeId() {
            s.serialize_field("frontNodeId", &f)?;
        } else {
            s.skip_field("frontNodeId")?;
        }
        if let Some(f) = self.nextNodeId() {
            s.serialize_field("nextNodeId", &f)?;
        } else {
            s.skip_field("nextNodeId")?;
        }
        s.serialize_field("positionRow", &self.positionRow())?;
        s.serialize_field("positionOrder", &self.positionOrder())?;
        s.serialize_field("tokenCost", &self.tokenCost())?;
        if let Some(f) = self.buffName() {
            s.serialize_field("buffName", &f)?;
        } else {
            s.skip_field("buffName")?;
        }
        if let Some(f) = self.activeIconId() {
            s.serialize_field("activeIconId", &f)?;
        } else {
            s.skip_field("activeIconId")?;
        }
        if let Some(f) = self.inactiveIconId() {
            s.serialize_field("inactiveIconId", &f)?;
        } else {
            s.skip_field("inactiveIconId")?;
        }
        if let Some(f) = self.bottomIconId() {
            s.serialize_field("bottomIconId", &f)?;
        } else {
            s.skip_field("bottomIconId")?;
        }
        s.serialize_field("effectType", &self.effectType())?;
        if let Some(f) = self.rawDesc() {
            s.serialize_field("rawDesc", &f)?;
        } else {
            s.skip_field("rawDesc")?;
        }
        if let Some(f) = self.buffDisplayInfo() {
            s.serialize_field("buffDisplayInfo", &f)?;
        } else {
            s.skip_field("buffDisplayInfo")?;
        }
        if let Some(f) = self.groupId() {
            s.serialize_field("groupId", &f)?;
        } else {
            s.skip_field("groupId")?;
        }
        if let Some(f) = self.enrollId() {
            s.serialize_field("enrollId", &f)?;
        } else {
            s.skip_field("enrollId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeCommonDevelopmentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeCommonDevelopmentBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevelopment::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn add_nodeType(&mut self, nodeType: enum__Torappu_RoguelikeCommonDevelopmentNodeType) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeCommonDevelopmentNodeType>(
                clz_Torappu_RoguelikeCommonDevelopment::VT_NODETYPE,
                nodeType,
                enum__Torappu_RoguelikeCommonDevelopmentNodeType::NONE,
            );
    }
    #[inline]
    pub fn add_frontNodeId(
        &mut self,
        frontNodeId: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevelopment::VT_FRONTNODEID,
            frontNodeId,
        );
    }
    #[inline]
    pub fn add_nextNodeId(
        &mut self,
        nextNodeId: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevelopment::VT_NEXTNODEID,
            nextNodeId,
        );
    }
    #[inline]
    pub fn add_positionRow(&mut self, positionRow: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeCommonDevelopment::VT_POSITIONROW,
            positionRow,
            0,
        );
    }
    #[inline]
    pub fn add_positionOrder(&mut self, positionOrder: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeCommonDevelopment::VT_POSITIONORDER,
            positionOrder,
            0,
        );
    }
    #[inline]
    pub fn add_tokenCost(&mut self, tokenCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeCommonDevelopment::VT_TOKENCOST,
            tokenCost,
            0,
        );
    }
    #[inline]
    pub fn add_buffName(&mut self, buffName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevelopment::VT_BUFFNAME,
            buffName,
        );
    }
    #[inline]
    pub fn add_activeIconId(&mut self, activeIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevelopment::VT_ACTIVEICONID,
            activeIconId,
        );
    }
    #[inline]
    pub fn add_inactiveIconId(&mut self, inactiveIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevelopment::VT_INACTIVEICONID,
            inactiveIconId,
        );
    }
    #[inline]
    pub fn add_bottomIconId(&mut self, bottomIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevelopment::VT_BOTTOMICONID,
            bottomIconId,
        );
    }
    #[inline]
    pub fn add_effectType(
        &mut self,
        effectType: enum__Torappu_RoguelikeCommonDevelopmentEffectType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_RoguelikeCommonDevelopmentEffectType>(
                clz_Torappu_RoguelikeCommonDevelopment::VT_EFFECTTYPE,
                effectType,
                enum__Torappu_RoguelikeCommonDevelopmentEffectType::BUFF,
            );
    }
    #[inline]
    pub fn add_rawDesc(
        &mut self,
        rawDesc: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevelopment::VT_RAWDESC,
            rawDesc,
        );
    }
    #[inline]
    pub fn add_buffDisplayInfo(
        &mut self,
        buffDisplayInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicDisplayItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevelopment::VT_BUFFDISPLAYINFO,
            buffDisplayInfo,
        );
    }
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevelopment::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_enrollId(&mut self, enrollId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevelopment::VT_ENROLLID,
            enrollId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeCommonDevelopmentBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeCommonDevelopmentBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevelopment<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeCommonDevelopment<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeCommonDevelopment");
        ds.field("buffId", &self.buffId());
        ds.field("nodeType", &self.nodeType());
        ds.field("frontNodeId", &self.frontNodeId());
        ds.field("nextNodeId", &self.nextNodeId());
        ds.field("positionRow", &self.positionRow());
        ds.field("positionOrder", &self.positionOrder());
        ds.field("tokenCost", &self.tokenCost());
        ds.field("buffName", &self.buffName());
        ds.field("activeIconId", &self.activeIconId());
        ds.field("inactiveIconId", &self.inactiveIconId());
        ds.field("bottomIconId", &self.bottomIconId());
        ds.field("effectType", &self.effectType());
        ds.field("rawDesc", &self.rawDesc());
        ds.field("buffDisplayInfo", &self.buffDisplayInfo());
        ds.field("groupId", &self.groupId());
        ds.field("enrollId", &self.enrollId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeCommonDevelopmentT {
    pub buffId: Option<String>,
    pub nodeType: enum__Torappu_RoguelikeCommonDevelopmentNodeType,
    pub frontNodeId: Option<Vec<String>>,
    pub nextNodeId: Option<Vec<String>>,
    pub positionRow: i32,
    pub positionOrder: i32,
    pub tokenCost: i32,
    pub buffName: Option<String>,
    pub activeIconId: Option<String>,
    pub inactiveIconId: Option<String>,
    pub bottomIconId: Option<String>,
    pub effectType: enum__Torappu_RoguelikeCommonDevelopmentEffectType,
    pub rawDesc: Option<Vec<String>>,
    pub buffDisplayInfo: Option<Vec<clz_Torappu_RoguelikeTopicDisplayItemT>>,
    pub groupId: Option<String>,
    pub enrollId: Option<String>,
}
impl Default for clz_Torappu_RoguelikeCommonDevelopmentT {
    fn default() -> Self {
        Self {
            buffId: None,
            nodeType: enum__Torappu_RoguelikeCommonDevelopmentNodeType::NONE,
            frontNodeId: None,
            nextNodeId: None,
            positionRow: 0,
            positionOrder: 0,
            tokenCost: 0,
            buffName: None,
            activeIconId: None,
            inactiveIconId: None,
            bottomIconId: None,
            effectType: enum__Torappu_RoguelikeCommonDevelopmentEffectType::BUFF,
            rawDesc: None,
            buffDisplayInfo: None,
            groupId: None,
            enrollId: None,
        }
    }
}
impl clz_Torappu_RoguelikeCommonDevelopmentT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevelopment<'b>> {
        let buffId = self.buffId.as_ref().map(|x| _fbb.create_string(x));
        let nodeType = self.nodeType;
        let frontNodeId = self.frontNodeId.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let nextNodeId = self.nextNodeId.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let positionRow = self.positionRow;
        let positionOrder = self.positionOrder;
        let tokenCost = self.tokenCost;
        let buffName = self.buffName.as_ref().map(|x| _fbb.create_string(x));
        let activeIconId = self.activeIconId.as_ref().map(|x| _fbb.create_string(x));
        let inactiveIconId = self.inactiveIconId.as_ref().map(|x| _fbb.create_string(x));
        let bottomIconId = self.bottomIconId.as_ref().map(|x| _fbb.create_string(x));
        let effectType = self.effectType;
        let rawDesc = self.rawDesc.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let buffDisplayInfo = self.buffDisplayInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let groupId = self.groupId.as_ref().map(|x| _fbb.create_string(x));
        let enrollId = self.enrollId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeCommonDevelopment::create(
            _fbb,
            &clz_Torappu_RoguelikeCommonDevelopmentArgs {
                buffId,
                nodeType,
                frontNodeId,
                nextNodeId,
                positionRow,
                positionOrder,
                tokenCost,
                buffName,
                activeIconId,
                inactiveIconId,
                bottomIconId,
                effectType,
                rawDesc,
                buffDisplayInfo,
                groupId,
                enrollId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeCommonDevelopmentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeCommonDevelopment<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RoguelikeCommonDevelopment<'a> {
    type Inner = dict__string__clz_Torappu_RoguelikeCommonDevelopment<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeCommonDevelopment<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeCommonDevelopment { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeCommonDevelopmentArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeCommonDevelopment<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RoguelikeCommonDevelopmentBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeCommonDevelopmentT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeCommonDevelopmentT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeCommonDevelopment::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeCommonDevelopment,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeCommonDevelopment<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCommonDevelopment>>(
                    dict__string__clz_Torappu_RoguelikeCommonDevelopment::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RoguelikeCommonDevelopment<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCommonDevelopment>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeCommonDevelopmentArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevelopment<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeCommonDevelopmentArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeCommonDevelopmentArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeCommonDevelopment<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_RoguelikeCommonDevelopment", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeCommonDevelopmentBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeCommonDevelopmentBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeCommonDevelopment::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevelopment<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevelopment>>(
                dict__string__clz_Torappu_RoguelikeCommonDevelopment::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeCommonDevelopmentBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeCommonDevelopmentBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeCommonDevelopment<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeCommonDevelopment::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeCommonDevelopment<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RoguelikeCommonDevelopment");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeCommonDevelopmentT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeCommonDevelopmentT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeCommonDevelopmentT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeCommonDevelopmentT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeCommonDevelopment<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeCommonDevelopment::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeCommonDevelopmentArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeCommonDevRawTextBuffGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeCommonDevRawTextBuffGroup<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeCommonDevRawTextBuffGroup<'a> {
    type Inner = clz_Torappu_RoguelikeCommonDevRawTextBuffGroup<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeCommonDevRawTextBuffGroup<'a> {
    pub const VT_NODEIDLIST: flatbuffers::VOffsetT = 4;
    pub const VT_GROUPICONID: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeCommonDevRawTextBuffGroup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeCommonDevRawTextBuffGroupArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevRawTextBuffGroup<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeCommonDevRawTextBuffGroupBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.groupIconId {
            builder.add_groupIconId(x);
        }
        if let Some(x) = args.nodeIdList {
            builder.add_nodeIdList(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeCommonDevRawTextBuffGroupT {
        let nodeIdList = self
            .nodeIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let groupIconId = self.groupIconId().map(|x| x.to_string());
        let sortId = self.sortId();
        clz_Torappu_RoguelikeCommonDevRawTextBuffGroupT {
            nodeIdList,
            groupIconId,
            sortId,
        }
    }

    #[inline]
    pub fn nodeIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RoguelikeCommonDevRawTextBuffGroup::VT_NODEIDLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn groupIconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCommonDevRawTextBuffGroup::VT_GROUPICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeCommonDevRawTextBuffGroup::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeCommonDevRawTextBuffGroup<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("nodeIdList", Self::VT_NODEIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "groupIconId",
                Self::VT_GROUPICONID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeCommonDevRawTextBuffGroupArgs<'a> {
    pub nodeIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub groupIconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_RoguelikeCommonDevRawTextBuffGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeCommonDevRawTextBuffGroupArgs {
            nodeIdList: None,
            groupIconId: None,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeCommonDevRawTextBuffGroup<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeCommonDevRawTextBuffGroup", 3)?;
        if let Some(f) = self.nodeIdList() {
            s.serialize_field("nodeIdList", &f)?;
        } else {
            s.skip_field("nodeIdList")?;
        }
        if let Some(f) = self.groupIconId() {
            s.serialize_field("groupIconId", &f)?;
        } else {
            s.skip_field("groupIconId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeCommonDevRawTextBuffGroupBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeCommonDevRawTextBuffGroupBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeIdList(
        &mut self,
        nodeIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevRawTextBuffGroup::VT_NODEIDLIST,
            nodeIdList,
        );
    }
    #[inline]
    pub fn add_groupIconId(&mut self, groupIconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevRawTextBuffGroup::VT_GROUPICONID,
            groupIconId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeCommonDevRawTextBuffGroup::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeCommonDevRawTextBuffGroupBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeCommonDevRawTextBuffGroupBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevRawTextBuffGroup<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeCommonDevRawTextBuffGroup<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeCommonDevRawTextBuffGroup");
        ds.field("nodeIdList", &self.nodeIdList());
        ds.field("groupIconId", &self.groupIconId());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeCommonDevRawTextBuffGroupT {
    pub nodeIdList: Option<Vec<String>>,
    pub groupIconId: Option<String>,
    pub sortId: i32,
}
impl Default for clz_Torappu_RoguelikeCommonDevRawTextBuffGroupT {
    fn default() -> Self {
        Self {
            nodeIdList: None,
            groupIconId: None,
            sortId: 0,
        }
    }
}
impl clz_Torappu_RoguelikeCommonDevRawTextBuffGroupT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevRawTextBuffGroup<'b>> {
        let nodeIdList = self.nodeIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let groupIconId = self.groupIconId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        clz_Torappu_RoguelikeCommonDevRawTextBuffGroup::create(
            _fbb,
            &clz_Torappu_RoguelikeCommonDevRawTextBuffGroupArgs {
                nodeIdList,
                groupIconId,
                sortId,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo<'a> {
    type Inner = clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo<'a> {
    pub const VT_FRONTNODES: flatbuffers::VOffsetT = 4;
    pub const VT_NEXTNODE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoBuilder::new(_fbb);
        if let Some(x) = args.nextNode {
            builder.add_nextNode(x);
        }
        if let Some(x) = args.frontNodes {
            builder.add_frontNodes(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoT {
        let frontNodes = self
            .frontNodes()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let nextNode = self.nextNode().map(|x| x.to_string());
        clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoT {
            frontNodes,
            nextNode,
        }
    }

    #[inline]
    pub fn frontNodes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo::VT_FRONTNODES,
                None,
            )
        }
    }
    #[inline]
    pub fn nextNode(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo::VT_NEXTNODE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("frontNodes", Self::VT_FRONTNODES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nextNode",
                Self::VT_NEXTNODE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoArgs<'a> {
    pub frontNodes: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub nextNode: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoArgs {
            frontNodes: None,
            nextNode: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo", 2)?;
        if let Some(f) = self.frontNodes() {
            s.serialize_field("frontNodes", &f)?;
        } else {
            s.skip_field("frontNodes")?;
        }
        if let Some(f) = self.nextNode() {
            s.serialize_field("nextNode", &f)?;
        } else {
            s.skip_field("nextNode")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_frontNodes(
        &mut self,
        frontNodes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo::VT_FRONTNODES,
            frontNodes,
        );
    }
    #[inline]
    pub fn add_nextNode(&mut self, nextNode: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo::VT_NEXTNODE,
            nextNode,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo");
        ds.field("frontNodes", &self.frontNodes());
        ds.field("nextNode", &self.nextNode());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoT {
    pub frontNodes: Option<Vec<String>>,
    pub nextNode: Option<String>,
}
impl Default for clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoT {
    fn default() -> Self {
        Self {
            frontNodes: None,
            nextNode: None,
        }
    }
}
impl clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo<'b>> {
        let frontNodes = self.frontNodes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let nextNode = self.nextNode.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo::create(
            _fbb,
            &clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoArgs {
                frontNodes,
                nextNode,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'a> {
    type Inner = clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'a> {
    pub const VT_BUFFID: flatbuffers::VOffsetT = 4;
    pub const VT_NODEMAP: flatbuffers::VOffsetT = 6;
    pub const VT_ENABLEGRADE: flatbuffers::VOffsetT = 8;
    pub const VT_ENABLEDESC: flatbuffers::VOffsetT = 10;
    pub const VT_LIGHTID: flatbuffers::VOffsetT = 12;
    pub const VT_DECOID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoBuilder::new(_fbb);
        if let Some(x) = args.decoId {
            builder.add_decoId(x);
        }
        if let Some(x) = args.lightId {
            builder.add_lightId(x);
        }
        if let Some(x) = args.enableDesc {
            builder.add_enableDesc(x);
        }
        builder.add_enableGrade(args.enableGrade);
        if let Some(x) = args.nodeMap {
            builder.add_nodeMap(x);
        }
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoT {
        let buffId = self.buffId().map(|x| x.to_string());
        let nodeMap = self
            .nodeMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let enableGrade = self.enableGrade();
        let enableDesc = self.enableDesc().map(|x| x.to_string());
        let lightId = self.lightId().map(|x| x.to_string());
        let decoId = self.decoId().map(|x| x.to_string());
        clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoT {
            buffId,
            nodeMap,
            enableGrade,
            enableDesc,
            lightId,
            decoId,
        }
    }

    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_BUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_NODEMAP,
                None,
            )
        }
    }
    #[inline]
    pub fn enableGrade(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_ENABLEGRADE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn enableDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_ENABLEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn lightId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_LIGHTID,
                None,
            )
        }
    }
    #[inline]
    pub fn decoId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_DECOID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo,
                    >,
                >,
            >>("nodeMap", Self::VT_NODEMAP, false)?
            .visit_field::<i32>("enableGrade", Self::VT_ENABLEGRADE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enableDesc",
                Self::VT_ENABLEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lightId", Self::VT_LIGHTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("decoId", Self::VT_DECOID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoArgs<'a> {
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo<'a>,
                >,
            >,
        >,
    >,
    pub enableGrade: i32,
    pub enableDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lightId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub decoId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoArgs {
            buffId: None,
            nodeMap: None,
            enableGrade: 0,
            enableDesc: None,
            lightId: None,
            decoId: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo", 6)?;
        if let Some(f) = self.buffId() {
            s.serialize_field("buffId", &f)?;
        } else {
            s.skip_field("buffId")?;
        }
        if let Some(f) = self.nodeMap() {
            s.serialize_field("nodeMap", &f)?;
        } else {
            s.skip_field("nodeMap")?;
        }
        s.serialize_field("enableGrade", &self.enableGrade())?;
        if let Some(f) = self.enableDesc() {
            s.serialize_field("enableDesc", &f)?;
        } else {
            s.skip_field("enableDesc")?;
        }
        if let Some(f) = self.lightId() {
            s.serialize_field("lightId", &f)?;
        } else {
            s.skip_field("lightId")?;
        }
        if let Some(f) = self.decoId() {
            s.serialize_field("decoId", &f)?;
        } else {
            s.skip_field("decoId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn add_nodeMap(
        &mut self,
        nodeMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfo<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_NODEMAP,
            nodeMap,
        );
    }
    #[inline]
    pub fn add_enableGrade(&mut self, enableGrade: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_ENABLEGRADE,
            enableGrade,
            0,
        );
    }
    #[inline]
    pub fn add_enableDesc(&mut self, enableDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_ENABLEDESC,
            enableDesc,
        );
    }
    #[inline]
    pub fn add_lightId(&mut self, lightId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_LIGHTID,
            lightId,
        );
    }
    #[inline]
    pub fn add_decoId(&mut self, decoId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_DECOID,
            decoId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo");
        ds.field("buffId", &self.buffId());
        ds.field("nodeMap", &self.nodeMap());
        ds.field("enableGrade", &self.enableGrade());
        ds.field("enableDesc", &self.enableDesc());
        ds.field("lightId", &self.lightId());
        ds.field("decoId", &self.decoId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoT {
    pub buffId: Option<String>,
    pub nodeMap: Option<Vec<clz_Torappu_RoguelikeCommonDevDifficultyNodePairInfoT>>,
    pub enableGrade: i32,
    pub enableDesc: Option<String>,
    pub lightId: Option<String>,
    pub decoId: Option<String>,
}
impl Default for clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoT {
    fn default() -> Self {
        Self {
            buffId: None,
            nodeMap: None,
            enableGrade: 0,
            enableDesc: None,
            lightId: None,
            decoId: None,
        }
    }
}
impl clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'b>> {
        let buffId = self.buffId.as_ref().map(|x| _fbb.create_string(x));
        let nodeMap = self.nodeMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let enableGrade = self.enableGrade;
        let enableDesc = self.enableDesc.as_ref().map(|x| _fbb.create_string(x));
        let lightId = self.lightId.as_ref().map(|x| _fbb.create_string(x));
        let decoId = self.decoId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::create(
            _fbb,
            &clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoArgs {
                buffId,
                nodeMap,
                enableGrade,
                enableDesc,
                lightId,
                decoId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'a>
{
    type Inner = dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo>>(dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo>>(dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoT>>,
}
impl Default for dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo::create(
            _fbb,
            &dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RoguelikeCommonDevelopmentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeCommonDevelopmentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeCommonDevelopmentData<'a> {
    type Inner = clz_Torappu_RoguelikeCommonDevelopmentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeCommonDevelopmentData<'a> {
    pub const VT_DEVELOPMENTS: flatbuffers::VOffsetT = 4;
    pub const VT_DEVELOPMENTSTOKENS: flatbuffers::VOffsetT = 6;
    pub const VT_DEVELOPMENTRAWTEXTGROUP: flatbuffers::VOffsetT = 8;
    pub const VT_DEVELOPMENTSDIFFICULTYNODEINFOS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeCommonDevelopmentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeCommonDevelopmentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevelopmentData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeCommonDevelopmentDataBuilder::new(_fbb);
        if let Some(x) = args.developmentsDifficultyNodeInfos {
            builder.add_developmentsDifficultyNodeInfos(x);
        }
        if let Some(x) = args.developmentRawTextGroup {
            builder.add_developmentRawTextGroup(x);
        }
        if let Some(x) = args.developmentsTokens {
            builder.add_developmentsTokens(x);
        }
        if let Some(x) = args.developments {
            builder.add_developments(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeCommonDevelopmentDataT {
        let developments = self
            .developments()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let developmentsTokens = self
            .developmentsTokens()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let developmentRawTextGroup = self
            .developmentRawTextGroup()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let developmentsDifficultyNodeInfos = self
            .developmentsDifficultyNodeInfos()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RoguelikeCommonDevelopmentDataT {
            developments,
            developmentsTokens,
            developmentRawTextGroup,
            developmentsDifficultyNodeInfos,
        }
    }

    #[inline]
    pub fn developments(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeCommonDevelopment<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeCommonDevelopment,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeCommonDevelopmentData::VT_DEVELOPMENTS,
                None,
            )
        }
    }
    #[inline]
    pub fn developmentsTokens(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken>,
                >,
            >>(
                clz_Torappu_RoguelikeCommonDevelopmentData::VT_DEVELOPMENTSTOKENS,
                None,
            )
        }
    }
    #[inline]
    pub fn developmentRawTextGroup(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCommonDevRawTextBuffGroup<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCommonDevRawTextBuffGroup>,
                >,
            >>(
                clz_Torappu_RoguelikeCommonDevelopmentData::VT_DEVELOPMENTRAWTEXTGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn developmentsDifficultyNodeInfos(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo,
                    >,
                >,
            >>(
                clz_Torappu_RoguelikeCommonDevelopmentData::VT_DEVELOPMENTSDIFFICULTYNODEINFOS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeCommonDevelopmentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeCommonDevelopment,
                    >,
                >,
            >>("developments", Self::VT_DEVELOPMENTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken>,
                >,
            >>("developmentsTokens", Self::VT_DEVELOPMENTSTOKENS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCommonDevRawTextBuffGroup>,
                >,
            >>(
                "developmentRawTextGroup",
                Self::VT_DEVELOPMENTRAWTEXTGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo,
                    >,
                >,
            >>(
                "developmentsDifficultyNodeInfos",
                Self::VT_DEVELOPMENTSDIFFICULTYNODEINFOS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeCommonDevelopmentDataArgs<'a> {
    pub developments: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeCommonDevelopment<'a>,
                >,
            >,
        >,
    >,
    pub developmentsTokens: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken<'a>>,
            >,
        >,
    >,
    pub developmentRawTextGroup: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCommonDevRawTextBuffGroup<'a>>,
            >,
        >,
    >,
    pub developmentsDifficultyNodeInfos: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RoguelikeCommonDevelopmentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeCommonDevelopmentDataArgs {
            developments: None,
            developmentsTokens: None,
            developmentRawTextGroup: None,
            developmentsDifficultyNodeInfos: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeCommonDevelopmentData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeCommonDevelopmentData", 4)?;
        if let Some(f) = self.developments() {
            s.serialize_field("developments", &f)?;
        } else {
            s.skip_field("developments")?;
        }
        if let Some(f) = self.developmentsTokens() {
            s.serialize_field("developmentsTokens", &f)?;
        } else {
            s.skip_field("developmentsTokens")?;
        }
        if let Some(f) = self.developmentRawTextGroup() {
            s.serialize_field("developmentRawTextGroup", &f)?;
        } else {
            s.skip_field("developmentRawTextGroup")?;
        }
        if let Some(f) = self.developmentsDifficultyNodeInfos() {
            s.serialize_field("developmentsDifficultyNodeInfos", &f)?;
        } else {
            s.skip_field("developmentsDifficultyNodeInfos")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeCommonDevelopmentDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeCommonDevelopmentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_developments(
        &mut self,
        developments: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeCommonDevelopment<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevelopmentData::VT_DEVELOPMENTS,
            developments,
        );
    }
    #[inline]
    pub fn add_developmentsTokens(
        &mut self,
        developmentsTokens: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDevToken<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevelopmentData::VT_DEVELOPMENTSTOKENS,
            developmentsTokens,
        );
    }
    #[inline]
    pub fn add_developmentRawTextGroup(
        &mut self,
        developmentRawTextGroup: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCommonDevRawTextBuffGroup<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevelopmentData::VT_DEVELOPMENTRAWTEXTGROUP,
            developmentRawTextGroup,
        );
    }
    #[inline]
    pub fn add_developmentsDifficultyNodeInfos(
        &mut self,
        developmentsDifficultyNodeInfos: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfo<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeCommonDevelopmentData::VT_DEVELOPMENTSDIFFICULTYNODEINFOS,
            developmentsDifficultyNodeInfos,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeCommonDevelopmentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeCommonDevelopmentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevelopmentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeCommonDevelopmentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeCommonDevelopmentData");
        ds.field("developments", &self.developments());
        ds.field("developmentsTokens", &self.developmentsTokens());
        ds.field("developmentRawTextGroup", &self.developmentRawTextGroup());
        ds.field(
            "developmentsDifficultyNodeInfos",
            &self.developmentsDifficultyNodeInfos(),
        );
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeCommonDevelopmentDataT {
    pub developments: Option<Vec<dict__string__clz_Torappu_RoguelikeCommonDevelopmentT>>,
    pub developmentsTokens: Option<Vec<dict__string__clz_Torappu_RoguelikeTopicDevTokenT>>,
    pub developmentRawTextGroup: Option<Vec<clz_Torappu_RoguelikeCommonDevRawTextBuffGroupT>>,
    pub developmentsDifficultyNodeInfos:
        Option<Vec<dict__string__clz_Torappu_RoguelikeCommonDevDifficultyNodeInfoT>>,
}
impl Default for clz_Torappu_RoguelikeCommonDevelopmentDataT {
    fn default() -> Self {
        Self {
            developments: None,
            developmentsTokens: None,
            developmentRawTextGroup: None,
            developmentsDifficultyNodeInfos: None,
        }
    }
}
impl clz_Torappu_RoguelikeCommonDevelopmentDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevelopmentData<'b>> {
        let developments = self.developments.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let developmentsTokens = self.developmentsTokens.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let developmentRawTextGroup = self.developmentRawTextGroup.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let developmentsDifficultyNodeInfos =
            self.developmentsDifficultyNodeInfos.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
        clz_Torappu_RoguelikeCommonDevelopmentData::create(
            _fbb,
            &clz_Torappu_RoguelikeCommonDevelopmentDataArgs {
                developments,
                developmentsTokens,
                developmentRawTextGroup,
                developmentsDifficultyNodeInfos,
            },
        )
    }
}
pub enum clz_Torappu_RL04DifficultyExtOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL04DifficultyExt<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL04DifficultyExt<'a> {
    type Inner = clz_Torappu_RL04DifficultyExt<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL04DifficultyExt<'a> {
    pub const VT_MODEDIFFICULTY: flatbuffers::VOffsetT = 4;
    pub const VT_GRADE: flatbuffers::VOffsetT = 6;
    pub const VT_LEFTDISASTERDESC: flatbuffers::VOffsetT = 8;
    pub const VT_LEFTOVERWEIGHTDESC: flatbuffers::VOffsetT = 10;
    pub const VT_RELICDEVLEVEL: flatbuffers::VOffsetT = 12;
    pub const VT_WEIGHTSTATUSLIMITDESC: flatbuffers::VOffsetT = 14;
    pub const VT_BUFFS: flatbuffers::VOffsetT = 16;
    pub const VT_BUFFDESC: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL04DifficultyExt { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL04DifficultyExtArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL04DifficultyExt<'bldr>> {
        let mut builder = clz_Torappu_RL04DifficultyExtBuilder::new(_fbb);
        if let Some(x) = args.buffDesc {
            builder.add_buffDesc(x);
        }
        if let Some(x) = args.buffs {
            builder.add_buffs(x);
        }
        if let Some(x) = args.weightStatusLimitDesc {
            builder.add_weightStatusLimitDesc(x);
        }
        if let Some(x) = args.relicDevLevel {
            builder.add_relicDevLevel(x);
        }
        if let Some(x) = args.leftOverweightDesc {
            builder.add_leftOverweightDesc(x);
        }
        if let Some(x) = args.leftDisasterDesc {
            builder.add_leftDisasterDesc(x);
        }
        builder.add_grade(args.grade);
        builder.add_modeDifficulty(args.modeDifficulty);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL04DifficultyExtT {
        let modeDifficulty = self.modeDifficulty();
        let grade = self.grade();
        let leftDisasterDesc = self.leftDisasterDesc().map(|x| x.to_string());
        let leftOverweightDesc = self.leftOverweightDesc().map(|x| x.to_string());
        let relicDevLevel = self.relicDevLevel().map(|x| x.to_string());
        let weightStatusLimitDesc = self.weightStatusLimitDesc().map(|x| x.to_string());
        let buffs = self
            .buffs()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let buffDesc = self
            .buffDesc()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_RL04DifficultyExtT {
            modeDifficulty,
            grade,
            leftDisasterDesc,
            leftOverweightDesc,
            relicDevLevel,
            weightStatusLimitDesc,
            buffs,
            buffDesc,
        }
    }

    #[inline]
    pub fn modeDifficulty(&self) -> enum__Torappu_RoguelikeTopicMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTopicMode>(
                    clz_Torappu_RL04DifficultyExt::VT_MODEDIFFICULTY,
                    Some(enum__Torappu_RoguelikeTopicMode::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn grade(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL04DifficultyExt::VT_GRADE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn leftDisasterDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04DifficultyExt::VT_LEFTDISASTERDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn leftOverweightDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04DifficultyExt::VT_LEFTOVERWEIGHTDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn relicDevLevel(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04DifficultyExt::VT_RELICDEVLEVEL,
                None,
            )
        }
    }
    #[inline]
    pub fn weightStatusLimitDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04DifficultyExt::VT_WEIGHTSTATUSLIMITDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn buffs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RL04DifficultyExt::VT_BUFFS, None)
        }
    }
    #[inline]
    pub fn buffDesc(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RL04DifficultyExt::VT_BUFFDESC, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL04DifficultyExt<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeTopicMode>(
                "modeDifficulty",
                Self::VT_MODEDIFFICULTY,
                false,
            )?
            .visit_field::<i32>("grade", Self::VT_GRADE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "leftDisasterDesc",
                Self::VT_LEFTDISASTERDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "leftOverweightDesc",
                Self::VT_LEFTOVERWEIGHTDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "relicDevLevel",
                Self::VT_RELICDEVLEVEL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "weightStatusLimitDesc",
                Self::VT_WEIGHTSTATUSLIMITDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("buffs", Self::VT_BUFFS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("buffDesc", Self::VT_BUFFDESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL04DifficultyExtArgs<'a> {
    pub modeDifficulty: enum__Torappu_RoguelikeTopicMode,
    pub grade: i32,
    pub leftDisasterDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub leftOverweightDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relicDevLevel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weightStatusLimitDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffs: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub buffDesc: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_RL04DifficultyExtArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL04DifficultyExtArgs {
            modeDifficulty: enum__Torappu_RoguelikeTopicMode::NONE,
            grade: 0,
            leftDisasterDesc: None,
            leftOverweightDesc: None,
            relicDevLevel: None,
            weightStatusLimitDesc: None,
            buffs: None,
            buffDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_RL04DifficultyExt<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL04DifficultyExt", 8)?;
        s.serialize_field("modeDifficulty", &self.modeDifficulty())?;
        s.serialize_field("grade", &self.grade())?;
        if let Some(f) = self.leftDisasterDesc() {
            s.serialize_field("leftDisasterDesc", &f)?;
        } else {
            s.skip_field("leftDisasterDesc")?;
        }
        if let Some(f) = self.leftOverweightDesc() {
            s.serialize_field("leftOverweightDesc", &f)?;
        } else {
            s.skip_field("leftOverweightDesc")?;
        }
        if let Some(f) = self.relicDevLevel() {
            s.serialize_field("relicDevLevel", &f)?;
        } else {
            s.skip_field("relicDevLevel")?;
        }
        if let Some(f) = self.weightStatusLimitDesc() {
            s.serialize_field("weightStatusLimitDesc", &f)?;
        } else {
            s.skip_field("weightStatusLimitDesc")?;
        }
        if let Some(f) = self.buffs() {
            s.serialize_field("buffs", &f)?;
        } else {
            s.skip_field("buffs")?;
        }
        if let Some(f) = self.buffDesc() {
            s.serialize_field("buffDesc", &f)?;
        } else {
            s.skip_field("buffDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL04DifficultyExtBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL04DifficultyExtBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_modeDifficulty(&mut self, modeDifficulty: enum__Torappu_RoguelikeTopicMode) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeTopicMode>(
            clz_Torappu_RL04DifficultyExt::VT_MODEDIFFICULTY,
            modeDifficulty,
            enum__Torappu_RoguelikeTopicMode::NONE,
        );
    }
    #[inline]
    pub fn add_grade(&mut self, grade: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL04DifficultyExt::VT_GRADE, grade, 0);
    }
    #[inline]
    pub fn add_leftDisasterDesc(&mut self, leftDisasterDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04DifficultyExt::VT_LEFTDISASTERDESC,
            leftDisasterDesc,
        );
    }
    #[inline]
    pub fn add_leftOverweightDesc(&mut self, leftOverweightDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04DifficultyExt::VT_LEFTOVERWEIGHTDESC,
            leftOverweightDesc,
        );
    }
    #[inline]
    pub fn add_relicDevLevel(&mut self, relicDevLevel: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04DifficultyExt::VT_RELICDEVLEVEL,
            relicDevLevel,
        );
    }
    #[inline]
    pub fn add_weightStatusLimitDesc(
        &mut self,
        weightStatusLimitDesc: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04DifficultyExt::VT_WEIGHTSTATUSLIMITDESC,
            weightStatusLimitDesc,
        );
    }
    #[inline]
    pub fn add_buffs(
        &mut self,
        buffs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04DifficultyExt::VT_BUFFS,
            buffs,
        );
    }
    #[inline]
    pub fn add_buffDesc(
        &mut self,
        buffDesc: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04DifficultyExt::VT_BUFFDESC,
            buffDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL04DifficultyExtBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL04DifficultyExtBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL04DifficultyExt<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL04DifficultyExt<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL04DifficultyExt");
        ds.field("modeDifficulty", &self.modeDifficulty());
        ds.field("grade", &self.grade());
        ds.field("leftDisasterDesc", &self.leftDisasterDesc());
        ds.field("leftOverweightDesc", &self.leftOverweightDesc());
        ds.field("relicDevLevel", &self.relicDevLevel());
        ds.field("weightStatusLimitDesc", &self.weightStatusLimitDesc());
        ds.field("buffs", &self.buffs());
        ds.field("buffDesc", &self.buffDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL04DifficultyExtT {
    pub modeDifficulty: enum__Torappu_RoguelikeTopicMode,
    pub grade: i32,
    pub leftDisasterDesc: Option<String>,
    pub leftOverweightDesc: Option<String>,
    pub relicDevLevel: Option<String>,
    pub weightStatusLimitDesc: Option<String>,
    pub buffs: Option<Vec<String>>,
    pub buffDesc: Option<Vec<String>>,
}
impl Default for clz_Torappu_RL04DifficultyExtT {
    fn default() -> Self {
        Self {
            modeDifficulty: enum__Torappu_RoguelikeTopicMode::NONE,
            grade: 0,
            leftDisasterDesc: None,
            leftOverweightDesc: None,
            relicDevLevel: None,
            weightStatusLimitDesc: None,
            buffs: None,
            buffDesc: None,
        }
    }
}
impl clz_Torappu_RL04DifficultyExtT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL04DifficultyExt<'b>> {
        let modeDifficulty = self.modeDifficulty;
        let grade = self.grade;
        let leftDisasterDesc = self
            .leftDisasterDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let leftOverweightDesc = self
            .leftOverweightDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let relicDevLevel = self.relicDevLevel.as_ref().map(|x| _fbb.create_string(x));
        let weightStatusLimitDesc = self
            .weightStatusLimitDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let buffs = self.buffs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let buffDesc = self.buffDesc.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RL04DifficultyExt::create(
            _fbb,
            &clz_Torappu_RL04DifficultyExtArgs {
                modeDifficulty,
                grade,
                leftDisasterDesc,
                leftOverweightDesc,
                relicDevLevel,
                weightStatusLimitDesc,
                buffs,
                buffDesc,
            },
        )
    }
}
pub enum clz_Torappu_RL04EndingTextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL04EndingText<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL04EndingText<'a> {
    type Inner = clz_Torappu_RL04EndingText<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL04EndingText<'a> {
    pub const VT_SUMMARYGETFRAGMENT: flatbuffers::VOffsetT = 4;
    pub const VT_SUMMARYUSEIDEA: flatbuffers::VOffsetT = 6;
    pub const VT_SUMMARYUSEFOOD: flatbuffers::VOffsetT = 8;
    pub const VT_SUMMARYDROPFRAGMENT: flatbuffers::VOffsetT = 10;
    pub const VT_SUMMARYMEETDISASTER: flatbuffers::VOffsetT = 12;
    pub const VT_SUMMARYLEAVEDISASTER: flatbuffers::VOffsetT = 14;
    pub const VT_SUMMARYENTERALCHEMY: flatbuffers::VOffsetT = 16;
    pub const VT_SUMMARYALCHEMYOTHERS: flatbuffers::VOffsetT = 18;
    pub const VT_SUMMARYALCHEMYFRAGMENT: flatbuffers::VOffsetT = 20;
    pub const VT_SUMMARYWEIGHTOVERWEIGHT: flatbuffers::VOffsetT = 22;
    pub const VT_SUMMARYWEIGHTLIMIT: flatbuffers::VOffsetT = 24;
    pub const VT_SUMMARYWEIGHTSAFE: flatbuffers::VOffsetT = 26;
    pub const VT_SUMMARYPERMUPGRADE: flatbuffers::VOffsetT = 28;
    pub const VT_SUMMARYTEMPUPGRADE: flatbuffers::VOffsetT = 30;
    pub const VT_SUMMARYSELLFRAGMENT: flatbuffers::VOffsetT = 32;
    pub const VT_SUMMARYACTOR: flatbuffers::VOffsetT = 34;
    pub const VT_SUMMARYTOP: flatbuffers::VOffsetT = 36;
    pub const VT_SUMMARYZONE: flatbuffers::VOffsetT = 38;
    pub const VT_SUMMARYENDING: flatbuffers::VOffsetT = 40;
    pub const VT_SUMMARYDIFFICULTYZONE: flatbuffers::VOffsetT = 42;
    pub const VT_SUMMARYDIFFICULTYENDING: flatbuffers::VOffsetT = 44;
    pub const VT_SUMMARYMODE: flatbuffers::VOffsetT = 46;
    pub const VT_SUMMARYSUPPORT: flatbuffers::VOffsetT = 48;
    pub const VT_SUMMARYGROUP: flatbuffers::VOffsetT = 50;
    pub const VT_SUMMARYNORMALRECRUIT: flatbuffers::VOffsetT = 52;
    pub const VT_SUMMARYDIRECTRECRUIT: flatbuffers::VOffsetT = 54;
    pub const VT_SUMMARYFRIENDRECRUIT: flatbuffers::VOffsetT = 56;
    pub const VT_SUMMARYFREERECRUIT: flatbuffers::VOffsetT = 58;
    pub const VT_SUMMARYMONTHRECRUIT: flatbuffers::VOffsetT = 60;
    pub const VT_SUMMARYUPGRADE: flatbuffers::VOffsetT = 62;
    pub const VT_SUMMARYCOMPLETEENDING: flatbuffers::VOffsetT = 64;
    pub const VT_SUMMARYEACHZONE: flatbuffers::VOffsetT = 66;
    pub const VT_SUMMARYMEETSPZONE: flatbuffers::VOffsetT = 68;
    pub const VT_SUMMARYPERFECTBATTLE: flatbuffers::VOffsetT = 70;
    pub const VT_SUMMARYMEETBATTLE: flatbuffers::VOffsetT = 72;
    pub const VT_SUMMARYMEETEVENT: flatbuffers::VOffsetT = 74;
    pub const VT_SUMMARYMEETSHOP: flatbuffers::VOffsetT = 76;
    pub const VT_SUMMARYMEETTREASURE: flatbuffers::VOffsetT = 78;
    pub const VT_SUMMARYMEETSECRETPATH: flatbuffers::VOffsetT = 80;
    pub const VT_SUMMARYEXCHANGERELIC: flatbuffers::VOffsetT = 82;
    pub const VT_SUMMARYMEETTRADE: flatbuffers::VOffsetT = 84;
    pub const VT_SUMMARYBUY: flatbuffers::VOffsetT = 86;
    pub const VT_SUMMARYBUYWITHPRICEID: flatbuffers::VOffsetT = 88;
    pub const VT_SUMMARYINVEST: flatbuffers::VOffsetT = 90;
    pub const VT_SUMMARYGET: flatbuffers::VOffsetT = 92;
    pub const VT_SUMMARYRELIC: flatbuffers::VOffsetT = 94;
    pub const VT_SUMMARYSAFEHOUSE: flatbuffers::VOffsetT = 96;
    pub const VT_SUMMARYFAILEND: flatbuffers::VOffsetT = 98;
    pub const VT_SUMMARYDUELWIN: flatbuffers::VOffsetT = 100;
    pub const VT_SUMMARYDUELTIE: flatbuffers::VOffsetT = 102;
    pub const VT_SUMMARYDUELLOSE: flatbuffers::VOffsetT = 104;
    pub const VT_SUMMARYSTOCKRECRUITTICKET: flatbuffers::VOffsetT = 106;
    pub const VT_SUMMARYEXPEDITIONGO: flatbuffers::VOffsetT = 108;
    pub const VT_SUMMARYEXPEDITIONBACK: flatbuffers::VOffsetT = 110;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL04EndingText { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL04EndingTextArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL04EndingText<'bldr>> {
        let mut builder = clz_Torappu_RL04EndingTextBuilder::new(_fbb);
        if let Some(x) = args.summaryExpeditionBack {
            builder.add_summaryExpeditionBack(x);
        }
        if let Some(x) = args.summaryExpeditionGo {
            builder.add_summaryExpeditionGo(x);
        }
        if let Some(x) = args.summaryStockRecruitTicket {
            builder.add_summaryStockRecruitTicket(x);
        }
        if let Some(x) = args.summaryDuelLose {
            builder.add_summaryDuelLose(x);
        }
        if let Some(x) = args.summaryDuelTie {
            builder.add_summaryDuelTie(x);
        }
        if let Some(x) = args.summaryDuelWin {
            builder.add_summaryDuelWin(x);
        }
        if let Some(x) = args.summaryFailEnd {
            builder.add_summaryFailEnd(x);
        }
        if let Some(x) = args.summarySafeHouse {
            builder.add_summarySafeHouse(x);
        }
        if let Some(x) = args.summaryRelic {
            builder.add_summaryRelic(x);
        }
        if let Some(x) = args.summaryGet {
            builder.add_summaryGet(x);
        }
        if let Some(x) = args.summaryInvest {
            builder.add_summaryInvest(x);
        }
        if let Some(x) = args.summaryBuyWithPriceId {
            builder.add_summaryBuyWithPriceId(x);
        }
        if let Some(x) = args.summaryBuy {
            builder.add_summaryBuy(x);
        }
        if let Some(x) = args.summaryMeetTrade {
            builder.add_summaryMeetTrade(x);
        }
        if let Some(x) = args.summaryExchangeRelic {
            builder.add_summaryExchangeRelic(x);
        }
        if let Some(x) = args.summaryMeetSecretpath {
            builder.add_summaryMeetSecretpath(x);
        }
        if let Some(x) = args.summaryMeetTreasure {
            builder.add_summaryMeetTreasure(x);
        }
        if let Some(x) = args.summaryMeetShop {
            builder.add_summaryMeetShop(x);
        }
        if let Some(x) = args.summaryMeetEvent {
            builder.add_summaryMeetEvent(x);
        }
        if let Some(x) = args.summaryMeetBattle {
            builder.add_summaryMeetBattle(x);
        }
        if let Some(x) = args.summaryPerfectBattle {
            builder.add_summaryPerfectBattle(x);
        }
        if let Some(x) = args.summaryMeetSpZone {
            builder.add_summaryMeetSpZone(x);
        }
        if let Some(x) = args.summaryEachZone {
            builder.add_summaryEachZone(x);
        }
        if let Some(x) = args.summaryCompleteEnding {
            builder.add_summaryCompleteEnding(x);
        }
        if let Some(x) = args.summaryUpgrade {
            builder.add_summaryUpgrade(x);
        }
        if let Some(x) = args.summaryMonthRecruit {
            builder.add_summaryMonthRecruit(x);
        }
        if let Some(x) = args.summaryFreeRecruit {
            builder.add_summaryFreeRecruit(x);
        }
        if let Some(x) = args.summaryFriendRecruit {
            builder.add_summaryFriendRecruit(x);
        }
        if let Some(x) = args.summaryDirectRecruit {
            builder.add_summaryDirectRecruit(x);
        }
        if let Some(x) = args.summaryNormalRecruit {
            builder.add_summaryNormalRecruit(x);
        }
        if let Some(x) = args.summaryGroup {
            builder.add_summaryGroup(x);
        }
        if let Some(x) = args.summarySupport {
            builder.add_summarySupport(x);
        }
        if let Some(x) = args.summaryMode {
            builder.add_summaryMode(x);
        }
        if let Some(x) = args.summaryDifficultyEnding {
            builder.add_summaryDifficultyEnding(x);
        }
        if let Some(x) = args.summaryDifficultyZone {
            builder.add_summaryDifficultyZone(x);
        }
        if let Some(x) = args.summaryEnding {
            builder.add_summaryEnding(x);
        }
        if let Some(x) = args.summaryZone {
            builder.add_summaryZone(x);
        }
        if let Some(x) = args.summaryTop {
            builder.add_summaryTop(x);
        }
        if let Some(x) = args.summaryActor {
            builder.add_summaryActor(x);
        }
        if let Some(x) = args.summarySellFragment {
            builder.add_summarySellFragment(x);
        }
        if let Some(x) = args.summaryTempUpgrade {
            builder.add_summaryTempUpgrade(x);
        }
        if let Some(x) = args.summaryPermUpgrade {
            builder.add_summaryPermUpgrade(x);
        }
        if let Some(x) = args.summaryWeightSafe {
            builder.add_summaryWeightSafe(x);
        }
        if let Some(x) = args.summaryWeightLimit {
            builder.add_summaryWeightLimit(x);
        }
        if let Some(x) = args.summaryWeightOverweight {
            builder.add_summaryWeightOverweight(x);
        }
        if let Some(x) = args.summaryAlchemyFragment {
            builder.add_summaryAlchemyFragment(x);
        }
        if let Some(x) = args.summaryAlchemyOthers {
            builder.add_summaryAlchemyOthers(x);
        }
        if let Some(x) = args.summaryEnterAlchemy {
            builder.add_summaryEnterAlchemy(x);
        }
        if let Some(x) = args.summaryLeaveDisaster {
            builder.add_summaryLeaveDisaster(x);
        }
        if let Some(x) = args.summaryMeetDisaster {
            builder.add_summaryMeetDisaster(x);
        }
        if let Some(x) = args.summaryDropFragment {
            builder.add_summaryDropFragment(x);
        }
        if let Some(x) = args.summaryUseFood {
            builder.add_summaryUseFood(x);
        }
        if let Some(x) = args.summaryUseIdea {
            builder.add_summaryUseIdea(x);
        }
        if let Some(x) = args.summaryGetFragment {
            builder.add_summaryGetFragment(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL04EndingTextT {
        let summaryGetFragment = self.summaryGetFragment().map(|x| x.to_string());
        let summaryUseIdea = self.summaryUseIdea().map(|x| x.to_string());
        let summaryUseFood = self.summaryUseFood().map(|x| x.to_string());
        let summaryDropFragment = self.summaryDropFragment().map(|x| x.to_string());
        let summaryMeetDisaster = self.summaryMeetDisaster().map(|x| x.to_string());
        let summaryLeaveDisaster = self.summaryLeaveDisaster().map(|x| x.to_string());
        let summaryEnterAlchemy = self.summaryEnterAlchemy().map(|x| x.to_string());
        let summaryAlchemyOthers = self.summaryAlchemyOthers().map(|x| x.to_string());
        let summaryAlchemyFragment = self.summaryAlchemyFragment().map(|x| x.to_string());
        let summaryWeightOverweight = self.summaryWeightOverweight().map(|x| x.to_string());
        let summaryWeightLimit = self.summaryWeightLimit().map(|x| x.to_string());
        let summaryWeightSafe = self.summaryWeightSafe().map(|x| x.to_string());
        let summaryPermUpgrade = self.summaryPermUpgrade().map(|x| x.to_string());
        let summaryTempUpgrade = self.summaryTempUpgrade().map(|x| x.to_string());
        let summarySellFragment = self.summarySellFragment().map(|x| x.to_string());
        let summaryActor = self.summaryActor().map(|x| x.to_string());
        let summaryTop = self.summaryTop().map(|x| x.to_string());
        let summaryZone = self.summaryZone().map(|x| x.to_string());
        let summaryEnding = self.summaryEnding().map(|x| x.to_string());
        let summaryDifficultyZone = self.summaryDifficultyZone().map(|x| x.to_string());
        let summaryDifficultyEnding = self.summaryDifficultyEnding().map(|x| x.to_string());
        let summaryMode = self.summaryMode().map(|x| x.to_string());
        let summarySupport = self.summarySupport().map(|x| x.to_string());
        let summaryGroup = self.summaryGroup().map(|x| x.to_string());
        let summaryNormalRecruit = self.summaryNormalRecruit().map(|x| x.to_string());
        let summaryDirectRecruit = self.summaryDirectRecruit().map(|x| x.to_string());
        let summaryFriendRecruit = self.summaryFriendRecruit().map(|x| x.to_string());
        let summaryFreeRecruit = self.summaryFreeRecruit().map(|x| x.to_string());
        let summaryMonthRecruit = self.summaryMonthRecruit().map(|x| x.to_string());
        let summaryUpgrade = self.summaryUpgrade().map(|x| x.to_string());
        let summaryCompleteEnding = self.summaryCompleteEnding().map(|x| x.to_string());
        let summaryEachZone = self.summaryEachZone().map(|x| x.to_string());
        let summaryMeetSpZone = self.summaryMeetSpZone().map(|x| x.to_string());
        let summaryPerfectBattle = self.summaryPerfectBattle().map(|x| x.to_string());
        let summaryMeetBattle = self.summaryMeetBattle().map(|x| x.to_string());
        let summaryMeetEvent = self.summaryMeetEvent().map(|x| x.to_string());
        let summaryMeetShop = self.summaryMeetShop().map(|x| x.to_string());
        let summaryMeetTreasure = self.summaryMeetTreasure().map(|x| x.to_string());
        let summaryMeetSecretpath = self.summaryMeetSecretpath().map(|x| x.to_string());
        let summaryExchangeRelic = self.summaryExchangeRelic().map(|x| x.to_string());
        let summaryMeetTrade = self.summaryMeetTrade().map(|x| x.to_string());
        let summaryBuy = self.summaryBuy().map(|x| x.to_string());
        let summaryBuyWithPriceId = self.summaryBuyWithPriceId().map(|x| x.to_string());
        let summaryInvest = self.summaryInvest().map(|x| x.to_string());
        let summaryGet = self.summaryGet().map(|x| x.to_string());
        let summaryRelic = self.summaryRelic().map(|x| x.to_string());
        let summarySafeHouse = self.summarySafeHouse().map(|x| x.to_string());
        let summaryFailEnd = self.summaryFailEnd().map(|x| x.to_string());
        let summaryDuelWin = self.summaryDuelWin().map(|x| x.to_string());
        let summaryDuelTie = self.summaryDuelTie().map(|x| x.to_string());
        let summaryDuelLose = self.summaryDuelLose().map(|x| x.to_string());
        let summaryStockRecruitTicket = self.summaryStockRecruitTicket().map(|x| x.to_string());
        let summaryExpeditionGo = self.summaryExpeditionGo().map(|x| x.to_string());
        let summaryExpeditionBack = self.summaryExpeditionBack().map(|x| x.to_string());
        clz_Torappu_RL04EndingTextT {
            summaryGetFragment,
            summaryUseIdea,
            summaryUseFood,
            summaryDropFragment,
            summaryMeetDisaster,
            summaryLeaveDisaster,
            summaryEnterAlchemy,
            summaryAlchemyOthers,
            summaryAlchemyFragment,
            summaryWeightOverweight,
            summaryWeightLimit,
            summaryWeightSafe,
            summaryPermUpgrade,
            summaryTempUpgrade,
            summarySellFragment,
            summaryActor,
            summaryTop,
            summaryZone,
            summaryEnding,
            summaryDifficultyZone,
            summaryDifficultyEnding,
            summaryMode,
            summarySupport,
            summaryGroup,
            summaryNormalRecruit,
            summaryDirectRecruit,
            summaryFriendRecruit,
            summaryFreeRecruit,
            summaryMonthRecruit,
            summaryUpgrade,
            summaryCompleteEnding,
            summaryEachZone,
            summaryMeetSpZone,
            summaryPerfectBattle,
            summaryMeetBattle,
            summaryMeetEvent,
            summaryMeetShop,
            summaryMeetTreasure,
            summaryMeetSecretpath,
            summaryExchangeRelic,
            summaryMeetTrade,
            summaryBuy,
            summaryBuyWithPriceId,
            summaryInvest,
            summaryGet,
            summaryRelic,
            summarySafeHouse,
            summaryFailEnd,
            summaryDuelWin,
            summaryDuelTie,
            summaryDuelLose,
            summaryStockRecruitTicket,
            summaryExpeditionGo,
            summaryExpeditionBack,
        }
    }

    #[inline]
    pub fn summaryGetFragment(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYGETFRAGMENT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryUseIdea(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYUSEIDEA,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryUseFood(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYUSEFOOD,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDropFragment(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYDROPFRAGMENT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetDisaster(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYMEETDISASTER,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryLeaveDisaster(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYLEAVEDISASTER,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryEnterAlchemy(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYENTERALCHEMY,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryAlchemyOthers(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYALCHEMYOTHERS,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryAlchemyFragment(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYALCHEMYFRAGMENT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryWeightOverweight(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYWEIGHTOVERWEIGHT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryWeightLimit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYWEIGHTLIMIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryWeightSafe(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYWEIGHTSAFE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryPermUpgrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYPERMUPGRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryTempUpgrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYTEMPUPGRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn summarySellFragment(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYSELLFRAGMENT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryActor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYACTOR,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryTop(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYTOP,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryEnding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYENDING,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDifficultyZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYDIFFICULTYZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDifficultyEnding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYDIFFICULTYENDING,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMode(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYMODE,
                None,
            )
        }
    }
    #[inline]
    pub fn summarySupport(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYSUPPORT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryGroup(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryNormalRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYNORMALRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDirectRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYDIRECTRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryFriendRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYFRIENDRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryFreeRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYFREERECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMonthRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYMONTHRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryUpgrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYUPGRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryCompleteEnding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYCOMPLETEENDING,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryEachZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYEACHZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetSpZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYMEETSPZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryPerfectBattle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYPERFECTBATTLE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetBattle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYMEETBATTLE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetEvent(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYMEETEVENT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetShop(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYMEETSHOP,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetTreasure(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYMEETTREASURE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetSecretpath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYMEETSECRETPATH,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExchangeRelic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYEXCHANGERELIC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetTrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYMEETTRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryBuy(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYBUY,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryBuyWithPriceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYBUYWITHPRICEID,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryInvest(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYINVEST,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryGet(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYGET,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryRelic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYRELIC,
                None,
            )
        }
    }
    #[inline]
    pub fn summarySafeHouse(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYSAFEHOUSE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryFailEnd(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYFAILEND,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDuelWin(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYDUELWIN,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDuelTie(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYDUELTIE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDuelLose(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYDUELLOSE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryStockRecruitTicket(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYSTOCKRECRUITTICKET,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExpeditionGo(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYEXPEDITIONGO,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExpeditionBack(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL04EndingText::VT_SUMMARYEXPEDITIONBACK,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL04EndingText<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryGetFragment",
                Self::VT_SUMMARYGETFRAGMENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryUseIdea",
                Self::VT_SUMMARYUSEIDEA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryUseFood",
                Self::VT_SUMMARYUSEFOOD,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDropFragment",
                Self::VT_SUMMARYDROPFRAGMENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetDisaster",
                Self::VT_SUMMARYMEETDISASTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryLeaveDisaster",
                Self::VT_SUMMARYLEAVEDISASTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryEnterAlchemy",
                Self::VT_SUMMARYENTERALCHEMY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryAlchemyOthers",
                Self::VT_SUMMARYALCHEMYOTHERS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryAlchemyFragment",
                Self::VT_SUMMARYALCHEMYFRAGMENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryWeightOverweight",
                Self::VT_SUMMARYWEIGHTOVERWEIGHT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryWeightLimit",
                Self::VT_SUMMARYWEIGHTLIMIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryWeightSafe",
                Self::VT_SUMMARYWEIGHTSAFE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryPermUpgrade",
                Self::VT_SUMMARYPERMUPGRADE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryTempUpgrade",
                Self::VT_SUMMARYTEMPUPGRADE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summarySellFragment",
                Self::VT_SUMMARYSELLFRAGMENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryActor",
                Self::VT_SUMMARYACTOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryTop",
                Self::VT_SUMMARYTOP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryZone",
                Self::VT_SUMMARYZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryEnding",
                Self::VT_SUMMARYENDING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDifficultyZone",
                Self::VT_SUMMARYDIFFICULTYZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDifficultyEnding",
                Self::VT_SUMMARYDIFFICULTYENDING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMode",
                Self::VT_SUMMARYMODE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summarySupport",
                Self::VT_SUMMARYSUPPORT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryGroup",
                Self::VT_SUMMARYGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryNormalRecruit",
                Self::VT_SUMMARYNORMALRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDirectRecruit",
                Self::VT_SUMMARYDIRECTRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryFriendRecruit",
                Self::VT_SUMMARYFRIENDRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryFreeRecruit",
                Self::VT_SUMMARYFREERECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMonthRecruit",
                Self::VT_SUMMARYMONTHRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryUpgrade",
                Self::VT_SUMMARYUPGRADE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryCompleteEnding",
                Self::VT_SUMMARYCOMPLETEENDING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryEachZone",
                Self::VT_SUMMARYEACHZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetSpZone",
                Self::VT_SUMMARYMEETSPZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryPerfectBattle",
                Self::VT_SUMMARYPERFECTBATTLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetBattle",
                Self::VT_SUMMARYMEETBATTLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetEvent",
                Self::VT_SUMMARYMEETEVENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetShop",
                Self::VT_SUMMARYMEETSHOP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetTreasure",
                Self::VT_SUMMARYMEETTREASURE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetSecretpath",
                Self::VT_SUMMARYMEETSECRETPATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExchangeRelic",
                Self::VT_SUMMARYEXCHANGERELIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetTrade",
                Self::VT_SUMMARYMEETTRADE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryBuy",
                Self::VT_SUMMARYBUY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryBuyWithPriceId",
                Self::VT_SUMMARYBUYWITHPRICEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryInvest",
                Self::VT_SUMMARYINVEST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryGet",
                Self::VT_SUMMARYGET,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryRelic",
                Self::VT_SUMMARYRELIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summarySafeHouse",
                Self::VT_SUMMARYSAFEHOUSE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryFailEnd",
                Self::VT_SUMMARYFAILEND,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDuelWin",
                Self::VT_SUMMARYDUELWIN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDuelTie",
                Self::VT_SUMMARYDUELTIE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDuelLose",
                Self::VT_SUMMARYDUELLOSE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryStockRecruitTicket",
                Self::VT_SUMMARYSTOCKRECRUITTICKET,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExpeditionGo",
                Self::VT_SUMMARYEXPEDITIONGO,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExpeditionBack",
                Self::VT_SUMMARYEXPEDITIONBACK,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL04EndingTextArgs<'a> {
    pub summaryGetFragment: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryUseIdea: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryUseFood: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDropFragment: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetDisaster: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryLeaveDisaster: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryEnterAlchemy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryAlchemyOthers: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryAlchemyFragment: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryWeightOverweight: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryWeightLimit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryWeightSafe: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryPermUpgrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryTempUpgrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summarySellFragment: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryActor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryTop: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryEnding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDifficultyZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDifficultyEnding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summarySupport: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryNormalRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDirectRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryFriendRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryFreeRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMonthRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryUpgrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryCompleteEnding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryEachZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetSpZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryPerfectBattle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetBattle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetEvent: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetShop: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetTreasure: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetSecretpath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExchangeRelic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetTrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryBuy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryBuyWithPriceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryInvest: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryGet: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryRelic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summarySafeHouse: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryFailEnd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDuelWin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDuelTie: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDuelLose: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryStockRecruitTicket: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExpeditionGo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExpeditionBack: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RL04EndingTextArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL04EndingTextArgs {
            summaryGetFragment: None,
            summaryUseIdea: None,
            summaryUseFood: None,
            summaryDropFragment: None,
            summaryMeetDisaster: None,
            summaryLeaveDisaster: None,
            summaryEnterAlchemy: None,
            summaryAlchemyOthers: None,
            summaryAlchemyFragment: None,
            summaryWeightOverweight: None,
            summaryWeightLimit: None,
            summaryWeightSafe: None,
            summaryPermUpgrade: None,
            summaryTempUpgrade: None,
            summarySellFragment: None,
            summaryActor: None,
            summaryTop: None,
            summaryZone: None,
            summaryEnding: None,
            summaryDifficultyZone: None,
            summaryDifficultyEnding: None,
            summaryMode: None,
            summarySupport: None,
            summaryGroup: None,
            summaryNormalRecruit: None,
            summaryDirectRecruit: None,
            summaryFriendRecruit: None,
            summaryFreeRecruit: None,
            summaryMonthRecruit: None,
            summaryUpgrade: None,
            summaryCompleteEnding: None,
            summaryEachZone: None,
            summaryMeetSpZone: None,
            summaryPerfectBattle: None,
            summaryMeetBattle: None,
            summaryMeetEvent: None,
            summaryMeetShop: None,
            summaryMeetTreasure: None,
            summaryMeetSecretpath: None,
            summaryExchangeRelic: None,
            summaryMeetTrade: None,
            summaryBuy: None,
            summaryBuyWithPriceId: None,
            summaryInvest: None,
            summaryGet: None,
            summaryRelic: None,
            summarySafeHouse: None,
            summaryFailEnd: None,
            summaryDuelWin: None,
            summaryDuelTie: None,
            summaryDuelLose: None,
            summaryStockRecruitTicket: None,
            summaryExpeditionGo: None,
            summaryExpeditionBack: None,
        }
    }
}

impl Serialize for clz_Torappu_RL04EndingText<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL04EndingText", 54)?;
        if let Some(f) = self.summaryGetFragment() {
            s.serialize_field("summaryGetFragment", &f)?;
        } else {
            s.skip_field("summaryGetFragment")?;
        }
        if let Some(f) = self.summaryUseIdea() {
            s.serialize_field("summaryUseIdea", &f)?;
        } else {
            s.skip_field("summaryUseIdea")?;
        }
        if let Some(f) = self.summaryUseFood() {
            s.serialize_field("summaryUseFood", &f)?;
        } else {
            s.skip_field("summaryUseFood")?;
        }
        if let Some(f) = self.summaryDropFragment() {
            s.serialize_field("summaryDropFragment", &f)?;
        } else {
            s.skip_field("summaryDropFragment")?;
        }
        if let Some(f) = self.summaryMeetDisaster() {
            s.serialize_field("summaryMeetDisaster", &f)?;
        } else {
            s.skip_field("summaryMeetDisaster")?;
        }
        if let Some(f) = self.summaryLeaveDisaster() {
            s.serialize_field("summaryLeaveDisaster", &f)?;
        } else {
            s.skip_field("summaryLeaveDisaster")?;
        }
        if let Some(f) = self.summaryEnterAlchemy() {
            s.serialize_field("summaryEnterAlchemy", &f)?;
        } else {
            s.skip_field("summaryEnterAlchemy")?;
        }
        if let Some(f) = self.summaryAlchemyOthers() {
            s.serialize_field("summaryAlchemyOthers", &f)?;
        } else {
            s.skip_field("summaryAlchemyOthers")?;
        }
        if let Some(f) = self.summaryAlchemyFragment() {
            s.serialize_field("summaryAlchemyFragment", &f)?;
        } else {
            s.skip_field("summaryAlchemyFragment")?;
        }
        if let Some(f) = self.summaryWeightOverweight() {
            s.serialize_field("summaryWeightOverweight", &f)?;
        } else {
            s.skip_field("summaryWeightOverweight")?;
        }
        if let Some(f) = self.summaryWeightLimit() {
            s.serialize_field("summaryWeightLimit", &f)?;
        } else {
            s.skip_field("summaryWeightLimit")?;
        }
        if let Some(f) = self.summaryWeightSafe() {
            s.serialize_field("summaryWeightSafe", &f)?;
        } else {
            s.skip_field("summaryWeightSafe")?;
        }
        if let Some(f) = self.summaryPermUpgrade() {
            s.serialize_field("summaryPermUpgrade", &f)?;
        } else {
            s.skip_field("summaryPermUpgrade")?;
        }
        if let Some(f) = self.summaryTempUpgrade() {
            s.serialize_field("summaryTempUpgrade", &f)?;
        } else {
            s.skip_field("summaryTempUpgrade")?;
        }
        if let Some(f) = self.summarySellFragment() {
            s.serialize_field("summarySellFragment", &f)?;
        } else {
            s.skip_field("summarySellFragment")?;
        }
        if let Some(f) = self.summaryActor() {
            s.serialize_field("summaryActor", &f)?;
        } else {
            s.skip_field("summaryActor")?;
        }
        if let Some(f) = self.summaryTop() {
            s.serialize_field("summaryTop", &f)?;
        } else {
            s.skip_field("summaryTop")?;
        }
        if let Some(f) = self.summaryZone() {
            s.serialize_field("summaryZone", &f)?;
        } else {
            s.skip_field("summaryZone")?;
        }
        if let Some(f) = self.summaryEnding() {
            s.serialize_field("summaryEnding", &f)?;
        } else {
            s.skip_field("summaryEnding")?;
        }
        if let Some(f) = self.summaryDifficultyZone() {
            s.serialize_field("summaryDifficultyZone", &f)?;
        } else {
            s.skip_field("summaryDifficultyZone")?;
        }
        if let Some(f) = self.summaryDifficultyEnding() {
            s.serialize_field("summaryDifficultyEnding", &f)?;
        } else {
            s.skip_field("summaryDifficultyEnding")?;
        }
        if let Some(f) = self.summaryMode() {
            s.serialize_field("summaryMode", &f)?;
        } else {
            s.skip_field("summaryMode")?;
        }
        if let Some(f) = self.summarySupport() {
            s.serialize_field("summarySupport", &f)?;
        } else {
            s.skip_field("summarySupport")?;
        }
        if let Some(f) = self.summaryGroup() {
            s.serialize_field("summaryGroup", &f)?;
        } else {
            s.skip_field("summaryGroup")?;
        }
        if let Some(f) = self.summaryNormalRecruit() {
            s.serialize_field("summaryNormalRecruit", &f)?;
        } else {
            s.skip_field("summaryNormalRecruit")?;
        }
        if let Some(f) = self.summaryDirectRecruit() {
            s.serialize_field("summaryDirectRecruit", &f)?;
        } else {
            s.skip_field("summaryDirectRecruit")?;
        }
        if let Some(f) = self.summaryFriendRecruit() {
            s.serialize_field("summaryFriendRecruit", &f)?;
        } else {
            s.skip_field("summaryFriendRecruit")?;
        }
        if let Some(f) = self.summaryFreeRecruit() {
            s.serialize_field("summaryFreeRecruit", &f)?;
        } else {
            s.skip_field("summaryFreeRecruit")?;
        }
        if let Some(f) = self.summaryMonthRecruit() {
            s.serialize_field("summaryMonthRecruit", &f)?;
        } else {
            s.skip_field("summaryMonthRecruit")?;
        }
        if let Some(f) = self.summaryUpgrade() {
            s.serialize_field("summaryUpgrade", &f)?;
        } else {
            s.skip_field("summaryUpgrade")?;
        }
        if let Some(f) = self.summaryCompleteEnding() {
            s.serialize_field("summaryCompleteEnding", &f)?;
        } else {
            s.skip_field("summaryCompleteEnding")?;
        }
        if let Some(f) = self.summaryEachZone() {
            s.serialize_field("summaryEachZone", &f)?;
        } else {
            s.skip_field("summaryEachZone")?;
        }
        if let Some(f) = self.summaryMeetSpZone() {
            s.serialize_field("summaryMeetSpZone", &f)?;
        } else {
            s.skip_field("summaryMeetSpZone")?;
        }
        if let Some(f) = self.summaryPerfectBattle() {
            s.serialize_field("summaryPerfectBattle", &f)?;
        } else {
            s.skip_field("summaryPerfectBattle")?;
        }
        if let Some(f) = self.summaryMeetBattle() {
            s.serialize_field("summaryMeetBattle", &f)?;
        } else {
            s.skip_field("summaryMeetBattle")?;
        }
        if let Some(f) = self.summaryMeetEvent() {
            s.serialize_field("summaryMeetEvent", &f)?;
        } else {
            s.skip_field("summaryMeetEvent")?;
        }
        if let Some(f) = self.summaryMeetShop() {
            s.serialize_field("summaryMeetShop", &f)?;
        } else {
            s.skip_field("summaryMeetShop")?;
        }
        if let Some(f) = self.summaryMeetTreasure() {
            s.serialize_field("summaryMeetTreasure", &f)?;
        } else {
            s.skip_field("summaryMeetTreasure")?;
        }
        if let Some(f) = self.summaryMeetSecretpath() {
            s.serialize_field("summaryMeetSecretpath", &f)?;
        } else {
            s.skip_field("summaryMeetSecretpath")?;
        }
        if let Some(f) = self.summaryExchangeRelic() {
            s.serialize_field("summaryExchangeRelic", &f)?;
        } else {
            s.skip_field("summaryExchangeRelic")?;
        }
        if let Some(f) = self.summaryMeetTrade() {
            s.serialize_field("summaryMeetTrade", &f)?;
        } else {
            s.skip_field("summaryMeetTrade")?;
        }
        if let Some(f) = self.summaryBuy() {
            s.serialize_field("summaryBuy", &f)?;
        } else {
            s.skip_field("summaryBuy")?;
        }
        if let Some(f) = self.summaryBuyWithPriceId() {
            s.serialize_field("summaryBuyWithPriceId", &f)?;
        } else {
            s.skip_field("summaryBuyWithPriceId")?;
        }
        if let Some(f) = self.summaryInvest() {
            s.serialize_field("summaryInvest", &f)?;
        } else {
            s.skip_field("summaryInvest")?;
        }
        if let Some(f) = self.summaryGet() {
            s.serialize_field("summaryGet", &f)?;
        } else {
            s.skip_field("summaryGet")?;
        }
        if let Some(f) = self.summaryRelic() {
            s.serialize_field("summaryRelic", &f)?;
        } else {
            s.skip_field("summaryRelic")?;
        }
        if let Some(f) = self.summarySafeHouse() {
            s.serialize_field("summarySafeHouse", &f)?;
        } else {
            s.skip_field("summarySafeHouse")?;
        }
        if let Some(f) = self.summaryFailEnd() {
            s.serialize_field("summaryFailEnd", &f)?;
        } else {
            s.skip_field("summaryFailEnd")?;
        }
        if let Some(f) = self.summaryDuelWin() {
            s.serialize_field("summaryDuelWin", &f)?;
        } else {
            s.skip_field("summaryDuelWin")?;
        }
        if let Some(f) = self.summaryDuelTie() {
            s.serialize_field("summaryDuelTie", &f)?;
        } else {
            s.skip_field("summaryDuelTie")?;
        }
        if let Some(f) = self.summaryDuelLose() {
            s.serialize_field("summaryDuelLose", &f)?;
        } else {
            s.skip_field("summaryDuelLose")?;
        }
        if let Some(f) = self.summaryStockRecruitTicket() {
            s.serialize_field("summaryStockRecruitTicket", &f)?;
        } else {
            s.skip_field("summaryStockRecruitTicket")?;
        }
        if let Some(f) = self.summaryExpeditionGo() {
            s.serialize_field("summaryExpeditionGo", &f)?;
        } else {
            s.skip_field("summaryExpeditionGo")?;
        }
        if let Some(f) = self.summaryExpeditionBack() {
            s.serialize_field("summaryExpeditionBack", &f)?;
        } else {
            s.skip_field("summaryExpeditionBack")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL04EndingTextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL04EndingTextBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_summaryGetFragment(&mut self, summaryGetFragment: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYGETFRAGMENT,
            summaryGetFragment,
        );
    }
    #[inline]
    pub fn add_summaryUseIdea(&mut self, summaryUseIdea: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYUSEIDEA,
            summaryUseIdea,
        );
    }
    #[inline]
    pub fn add_summaryUseFood(&mut self, summaryUseFood: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYUSEFOOD,
            summaryUseFood,
        );
    }
    #[inline]
    pub fn add_summaryDropFragment(
        &mut self,
        summaryDropFragment: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYDROPFRAGMENT,
            summaryDropFragment,
        );
    }
    #[inline]
    pub fn add_summaryMeetDisaster(
        &mut self,
        summaryMeetDisaster: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYMEETDISASTER,
            summaryMeetDisaster,
        );
    }
    #[inline]
    pub fn add_summaryLeaveDisaster(
        &mut self,
        summaryLeaveDisaster: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYLEAVEDISASTER,
            summaryLeaveDisaster,
        );
    }
    #[inline]
    pub fn add_summaryEnterAlchemy(
        &mut self,
        summaryEnterAlchemy: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYENTERALCHEMY,
            summaryEnterAlchemy,
        );
    }
    #[inline]
    pub fn add_summaryAlchemyOthers(
        &mut self,
        summaryAlchemyOthers: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYALCHEMYOTHERS,
            summaryAlchemyOthers,
        );
    }
    #[inline]
    pub fn add_summaryAlchemyFragment(
        &mut self,
        summaryAlchemyFragment: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYALCHEMYFRAGMENT,
            summaryAlchemyFragment,
        );
    }
    #[inline]
    pub fn add_summaryWeightOverweight(
        &mut self,
        summaryWeightOverweight: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYWEIGHTOVERWEIGHT,
            summaryWeightOverweight,
        );
    }
    #[inline]
    pub fn add_summaryWeightLimit(&mut self, summaryWeightLimit: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYWEIGHTLIMIT,
            summaryWeightLimit,
        );
    }
    #[inline]
    pub fn add_summaryWeightSafe(&mut self, summaryWeightSafe: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYWEIGHTSAFE,
            summaryWeightSafe,
        );
    }
    #[inline]
    pub fn add_summaryPermUpgrade(&mut self, summaryPermUpgrade: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYPERMUPGRADE,
            summaryPermUpgrade,
        );
    }
    #[inline]
    pub fn add_summaryTempUpgrade(&mut self, summaryTempUpgrade: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYTEMPUPGRADE,
            summaryTempUpgrade,
        );
    }
    #[inline]
    pub fn add_summarySellFragment(
        &mut self,
        summarySellFragment: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYSELLFRAGMENT,
            summarySellFragment,
        );
    }
    #[inline]
    pub fn add_summaryActor(&mut self, summaryActor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYACTOR,
            summaryActor,
        );
    }
    #[inline]
    pub fn add_summaryTop(&mut self, summaryTop: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYTOP,
            summaryTop,
        );
    }
    #[inline]
    pub fn add_summaryZone(&mut self, summaryZone: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYZONE,
            summaryZone,
        );
    }
    #[inline]
    pub fn add_summaryEnding(&mut self, summaryEnding: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYENDING,
            summaryEnding,
        );
    }
    #[inline]
    pub fn add_summaryDifficultyZone(
        &mut self,
        summaryDifficultyZone: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYDIFFICULTYZONE,
            summaryDifficultyZone,
        );
    }
    #[inline]
    pub fn add_summaryDifficultyEnding(
        &mut self,
        summaryDifficultyEnding: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYDIFFICULTYENDING,
            summaryDifficultyEnding,
        );
    }
    #[inline]
    pub fn add_summaryMode(&mut self, summaryMode: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYMODE,
            summaryMode,
        );
    }
    #[inline]
    pub fn add_summarySupport(&mut self, summarySupport: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYSUPPORT,
            summarySupport,
        );
    }
    #[inline]
    pub fn add_summaryGroup(&mut self, summaryGroup: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYGROUP,
            summaryGroup,
        );
    }
    #[inline]
    pub fn add_summaryNormalRecruit(
        &mut self,
        summaryNormalRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYNORMALRECRUIT,
            summaryNormalRecruit,
        );
    }
    #[inline]
    pub fn add_summaryDirectRecruit(
        &mut self,
        summaryDirectRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYDIRECTRECRUIT,
            summaryDirectRecruit,
        );
    }
    #[inline]
    pub fn add_summaryFriendRecruit(
        &mut self,
        summaryFriendRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYFRIENDRECRUIT,
            summaryFriendRecruit,
        );
    }
    #[inline]
    pub fn add_summaryFreeRecruit(&mut self, summaryFreeRecruit: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYFREERECRUIT,
            summaryFreeRecruit,
        );
    }
    #[inline]
    pub fn add_summaryMonthRecruit(
        &mut self,
        summaryMonthRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYMONTHRECRUIT,
            summaryMonthRecruit,
        );
    }
    #[inline]
    pub fn add_summaryUpgrade(&mut self, summaryUpgrade: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYUPGRADE,
            summaryUpgrade,
        );
    }
    #[inline]
    pub fn add_summaryCompleteEnding(
        &mut self,
        summaryCompleteEnding: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYCOMPLETEENDING,
            summaryCompleteEnding,
        );
    }
    #[inline]
    pub fn add_summaryEachZone(&mut self, summaryEachZone: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYEACHZONE,
            summaryEachZone,
        );
    }
    #[inline]
    pub fn add_summaryMeetSpZone(&mut self, summaryMeetSpZone: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYMEETSPZONE,
            summaryMeetSpZone,
        );
    }
    #[inline]
    pub fn add_summaryPerfectBattle(
        &mut self,
        summaryPerfectBattle: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYPERFECTBATTLE,
            summaryPerfectBattle,
        );
    }
    #[inline]
    pub fn add_summaryMeetBattle(&mut self, summaryMeetBattle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYMEETBATTLE,
            summaryMeetBattle,
        );
    }
    #[inline]
    pub fn add_summaryMeetEvent(&mut self, summaryMeetEvent: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYMEETEVENT,
            summaryMeetEvent,
        );
    }
    #[inline]
    pub fn add_summaryMeetShop(&mut self, summaryMeetShop: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYMEETSHOP,
            summaryMeetShop,
        );
    }
    #[inline]
    pub fn add_summaryMeetTreasure(
        &mut self,
        summaryMeetTreasure: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYMEETTREASURE,
            summaryMeetTreasure,
        );
    }
    #[inline]
    pub fn add_summaryMeetSecretpath(
        &mut self,
        summaryMeetSecretpath: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYMEETSECRETPATH,
            summaryMeetSecretpath,
        );
    }
    #[inline]
    pub fn add_summaryExchangeRelic(
        &mut self,
        summaryExchangeRelic: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYEXCHANGERELIC,
            summaryExchangeRelic,
        );
    }
    #[inline]
    pub fn add_summaryMeetTrade(&mut self, summaryMeetTrade: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYMEETTRADE,
            summaryMeetTrade,
        );
    }
    #[inline]
    pub fn add_summaryBuy(&mut self, summaryBuy: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYBUY,
            summaryBuy,
        );
    }
    #[inline]
    pub fn add_summaryBuyWithPriceId(
        &mut self,
        summaryBuyWithPriceId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYBUYWITHPRICEID,
            summaryBuyWithPriceId,
        );
    }
    #[inline]
    pub fn add_summaryInvest(&mut self, summaryInvest: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYINVEST,
            summaryInvest,
        );
    }
    #[inline]
    pub fn add_summaryGet(&mut self, summaryGet: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYGET,
            summaryGet,
        );
    }
    #[inline]
    pub fn add_summaryRelic(&mut self, summaryRelic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYRELIC,
            summaryRelic,
        );
    }
    #[inline]
    pub fn add_summarySafeHouse(&mut self, summarySafeHouse: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYSAFEHOUSE,
            summarySafeHouse,
        );
    }
    #[inline]
    pub fn add_summaryFailEnd(&mut self, summaryFailEnd: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYFAILEND,
            summaryFailEnd,
        );
    }
    #[inline]
    pub fn add_summaryDuelWin(&mut self, summaryDuelWin: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYDUELWIN,
            summaryDuelWin,
        );
    }
    #[inline]
    pub fn add_summaryDuelTie(&mut self, summaryDuelTie: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYDUELTIE,
            summaryDuelTie,
        );
    }
    #[inline]
    pub fn add_summaryDuelLose(&mut self, summaryDuelLose: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYDUELLOSE,
            summaryDuelLose,
        );
    }
    #[inline]
    pub fn add_summaryStockRecruitTicket(
        &mut self,
        summaryStockRecruitTicket: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYSTOCKRECRUITTICKET,
            summaryStockRecruitTicket,
        );
    }
    #[inline]
    pub fn add_summaryExpeditionGo(
        &mut self,
        summaryExpeditionGo: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYEXPEDITIONGO,
            summaryExpeditionGo,
        );
    }
    #[inline]
    pub fn add_summaryExpeditionBack(
        &mut self,
        summaryExpeditionBack: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04EndingText::VT_SUMMARYEXPEDITIONBACK,
            summaryExpeditionBack,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL04EndingTextBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL04EndingTextBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL04EndingText<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL04EndingText<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL04EndingText");
        ds.field("summaryGetFragment", &self.summaryGetFragment());
        ds.field("summaryUseIdea", &self.summaryUseIdea());
        ds.field("summaryUseFood", &self.summaryUseFood());
        ds.field("summaryDropFragment", &self.summaryDropFragment());
        ds.field("summaryMeetDisaster", &self.summaryMeetDisaster());
        ds.field("summaryLeaveDisaster", &self.summaryLeaveDisaster());
        ds.field("summaryEnterAlchemy", &self.summaryEnterAlchemy());
        ds.field("summaryAlchemyOthers", &self.summaryAlchemyOthers());
        ds.field("summaryAlchemyFragment", &self.summaryAlchemyFragment());
        ds.field("summaryWeightOverweight", &self.summaryWeightOverweight());
        ds.field("summaryWeightLimit", &self.summaryWeightLimit());
        ds.field("summaryWeightSafe", &self.summaryWeightSafe());
        ds.field("summaryPermUpgrade", &self.summaryPermUpgrade());
        ds.field("summaryTempUpgrade", &self.summaryTempUpgrade());
        ds.field("summarySellFragment", &self.summarySellFragment());
        ds.field("summaryActor", &self.summaryActor());
        ds.field("summaryTop", &self.summaryTop());
        ds.field("summaryZone", &self.summaryZone());
        ds.field("summaryEnding", &self.summaryEnding());
        ds.field("summaryDifficultyZone", &self.summaryDifficultyZone());
        ds.field("summaryDifficultyEnding", &self.summaryDifficultyEnding());
        ds.field("summaryMode", &self.summaryMode());
        ds.field("summarySupport", &self.summarySupport());
        ds.field("summaryGroup", &self.summaryGroup());
        ds.field("summaryNormalRecruit", &self.summaryNormalRecruit());
        ds.field("summaryDirectRecruit", &self.summaryDirectRecruit());
        ds.field("summaryFriendRecruit", &self.summaryFriendRecruit());
        ds.field("summaryFreeRecruit", &self.summaryFreeRecruit());
        ds.field("summaryMonthRecruit", &self.summaryMonthRecruit());
        ds.field("summaryUpgrade", &self.summaryUpgrade());
        ds.field("summaryCompleteEnding", &self.summaryCompleteEnding());
        ds.field("summaryEachZone", &self.summaryEachZone());
        ds.field("summaryMeetSpZone", &self.summaryMeetSpZone());
        ds.field("summaryPerfectBattle", &self.summaryPerfectBattle());
        ds.field("summaryMeetBattle", &self.summaryMeetBattle());
        ds.field("summaryMeetEvent", &self.summaryMeetEvent());
        ds.field("summaryMeetShop", &self.summaryMeetShop());
        ds.field("summaryMeetTreasure", &self.summaryMeetTreasure());
        ds.field("summaryMeetSecretpath", &self.summaryMeetSecretpath());
        ds.field("summaryExchangeRelic", &self.summaryExchangeRelic());
        ds.field("summaryMeetTrade", &self.summaryMeetTrade());
        ds.field("summaryBuy", &self.summaryBuy());
        ds.field("summaryBuyWithPriceId", &self.summaryBuyWithPriceId());
        ds.field("summaryInvest", &self.summaryInvest());
        ds.field("summaryGet", &self.summaryGet());
        ds.field("summaryRelic", &self.summaryRelic());
        ds.field("summarySafeHouse", &self.summarySafeHouse());
        ds.field("summaryFailEnd", &self.summaryFailEnd());
        ds.field("summaryDuelWin", &self.summaryDuelWin());
        ds.field("summaryDuelTie", &self.summaryDuelTie());
        ds.field("summaryDuelLose", &self.summaryDuelLose());
        ds.field(
            "summaryStockRecruitTicket",
            &self.summaryStockRecruitTicket(),
        );
        ds.field("summaryExpeditionGo", &self.summaryExpeditionGo());
        ds.field("summaryExpeditionBack", &self.summaryExpeditionBack());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL04EndingTextT {
    pub summaryGetFragment: Option<String>,
    pub summaryUseIdea: Option<String>,
    pub summaryUseFood: Option<String>,
    pub summaryDropFragment: Option<String>,
    pub summaryMeetDisaster: Option<String>,
    pub summaryLeaveDisaster: Option<String>,
    pub summaryEnterAlchemy: Option<String>,
    pub summaryAlchemyOthers: Option<String>,
    pub summaryAlchemyFragment: Option<String>,
    pub summaryWeightOverweight: Option<String>,
    pub summaryWeightLimit: Option<String>,
    pub summaryWeightSafe: Option<String>,
    pub summaryPermUpgrade: Option<String>,
    pub summaryTempUpgrade: Option<String>,
    pub summarySellFragment: Option<String>,
    pub summaryActor: Option<String>,
    pub summaryTop: Option<String>,
    pub summaryZone: Option<String>,
    pub summaryEnding: Option<String>,
    pub summaryDifficultyZone: Option<String>,
    pub summaryDifficultyEnding: Option<String>,
    pub summaryMode: Option<String>,
    pub summarySupport: Option<String>,
    pub summaryGroup: Option<String>,
    pub summaryNormalRecruit: Option<String>,
    pub summaryDirectRecruit: Option<String>,
    pub summaryFriendRecruit: Option<String>,
    pub summaryFreeRecruit: Option<String>,
    pub summaryMonthRecruit: Option<String>,
    pub summaryUpgrade: Option<String>,
    pub summaryCompleteEnding: Option<String>,
    pub summaryEachZone: Option<String>,
    pub summaryMeetSpZone: Option<String>,
    pub summaryPerfectBattle: Option<String>,
    pub summaryMeetBattle: Option<String>,
    pub summaryMeetEvent: Option<String>,
    pub summaryMeetShop: Option<String>,
    pub summaryMeetTreasure: Option<String>,
    pub summaryMeetSecretpath: Option<String>,
    pub summaryExchangeRelic: Option<String>,
    pub summaryMeetTrade: Option<String>,
    pub summaryBuy: Option<String>,
    pub summaryBuyWithPriceId: Option<String>,
    pub summaryInvest: Option<String>,
    pub summaryGet: Option<String>,
    pub summaryRelic: Option<String>,
    pub summarySafeHouse: Option<String>,
    pub summaryFailEnd: Option<String>,
    pub summaryDuelWin: Option<String>,
    pub summaryDuelTie: Option<String>,
    pub summaryDuelLose: Option<String>,
    pub summaryStockRecruitTicket: Option<String>,
    pub summaryExpeditionGo: Option<String>,
    pub summaryExpeditionBack: Option<String>,
}
impl Default for clz_Torappu_RL04EndingTextT {
    fn default() -> Self {
        Self {
            summaryGetFragment: None,
            summaryUseIdea: None,
            summaryUseFood: None,
            summaryDropFragment: None,
            summaryMeetDisaster: None,
            summaryLeaveDisaster: None,
            summaryEnterAlchemy: None,
            summaryAlchemyOthers: None,
            summaryAlchemyFragment: None,
            summaryWeightOverweight: None,
            summaryWeightLimit: None,
            summaryWeightSafe: None,
            summaryPermUpgrade: None,
            summaryTempUpgrade: None,
            summarySellFragment: None,
            summaryActor: None,
            summaryTop: None,
            summaryZone: None,
            summaryEnding: None,
            summaryDifficultyZone: None,
            summaryDifficultyEnding: None,
            summaryMode: None,
            summarySupport: None,
            summaryGroup: None,
            summaryNormalRecruit: None,
            summaryDirectRecruit: None,
            summaryFriendRecruit: None,
            summaryFreeRecruit: None,
            summaryMonthRecruit: None,
            summaryUpgrade: None,
            summaryCompleteEnding: None,
            summaryEachZone: None,
            summaryMeetSpZone: None,
            summaryPerfectBattle: None,
            summaryMeetBattle: None,
            summaryMeetEvent: None,
            summaryMeetShop: None,
            summaryMeetTreasure: None,
            summaryMeetSecretpath: None,
            summaryExchangeRelic: None,
            summaryMeetTrade: None,
            summaryBuy: None,
            summaryBuyWithPriceId: None,
            summaryInvest: None,
            summaryGet: None,
            summaryRelic: None,
            summarySafeHouse: None,
            summaryFailEnd: None,
            summaryDuelWin: None,
            summaryDuelTie: None,
            summaryDuelLose: None,
            summaryStockRecruitTicket: None,
            summaryExpeditionGo: None,
            summaryExpeditionBack: None,
        }
    }
}
impl clz_Torappu_RL04EndingTextT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL04EndingText<'b>> {
        let summaryGetFragment = self
            .summaryGetFragment
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryUseIdea = self.summaryUseIdea.as_ref().map(|x| _fbb.create_string(x));
        let summaryUseFood = self.summaryUseFood.as_ref().map(|x| _fbb.create_string(x));
        let summaryDropFragment = self
            .summaryDropFragment
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetDisaster = self
            .summaryMeetDisaster
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryLeaveDisaster = self
            .summaryLeaveDisaster
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryEnterAlchemy = self
            .summaryEnterAlchemy
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryAlchemyOthers = self
            .summaryAlchemyOthers
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryAlchemyFragment = self
            .summaryAlchemyFragment
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryWeightOverweight = self
            .summaryWeightOverweight
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryWeightLimit = self
            .summaryWeightLimit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryWeightSafe = self
            .summaryWeightSafe
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryPermUpgrade = self
            .summaryPermUpgrade
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryTempUpgrade = self
            .summaryTempUpgrade
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summarySellFragment = self
            .summarySellFragment
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryActor = self.summaryActor.as_ref().map(|x| _fbb.create_string(x));
        let summaryTop = self.summaryTop.as_ref().map(|x| _fbb.create_string(x));
        let summaryZone = self.summaryZone.as_ref().map(|x| _fbb.create_string(x));
        let summaryEnding = self.summaryEnding.as_ref().map(|x| _fbb.create_string(x));
        let summaryDifficultyZone = self
            .summaryDifficultyZone
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDifficultyEnding = self
            .summaryDifficultyEnding
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMode = self.summaryMode.as_ref().map(|x| _fbb.create_string(x));
        let summarySupport = self.summarySupport.as_ref().map(|x| _fbb.create_string(x));
        let summaryGroup = self.summaryGroup.as_ref().map(|x| _fbb.create_string(x));
        let summaryNormalRecruit = self
            .summaryNormalRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDirectRecruit = self
            .summaryDirectRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryFriendRecruit = self
            .summaryFriendRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryFreeRecruit = self
            .summaryFreeRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMonthRecruit = self
            .summaryMonthRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryUpgrade = self.summaryUpgrade.as_ref().map(|x| _fbb.create_string(x));
        let summaryCompleteEnding = self
            .summaryCompleteEnding
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryEachZone = self.summaryEachZone.as_ref().map(|x| _fbb.create_string(x));
        let summaryMeetSpZone = self
            .summaryMeetSpZone
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryPerfectBattle = self
            .summaryPerfectBattle
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetBattle = self
            .summaryMeetBattle
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetEvent = self
            .summaryMeetEvent
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetShop = self.summaryMeetShop.as_ref().map(|x| _fbb.create_string(x));
        let summaryMeetTreasure = self
            .summaryMeetTreasure
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetSecretpath = self
            .summaryMeetSecretpath
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExchangeRelic = self
            .summaryExchangeRelic
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetTrade = self
            .summaryMeetTrade
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryBuy = self.summaryBuy.as_ref().map(|x| _fbb.create_string(x));
        let summaryBuyWithPriceId = self
            .summaryBuyWithPriceId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryInvest = self.summaryInvest.as_ref().map(|x| _fbb.create_string(x));
        let summaryGet = self.summaryGet.as_ref().map(|x| _fbb.create_string(x));
        let summaryRelic = self.summaryRelic.as_ref().map(|x| _fbb.create_string(x));
        let summarySafeHouse = self
            .summarySafeHouse
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryFailEnd = self.summaryFailEnd.as_ref().map(|x| _fbb.create_string(x));
        let summaryDuelWin = self.summaryDuelWin.as_ref().map(|x| _fbb.create_string(x));
        let summaryDuelTie = self.summaryDuelTie.as_ref().map(|x| _fbb.create_string(x));
        let summaryDuelLose = self.summaryDuelLose.as_ref().map(|x| _fbb.create_string(x));
        let summaryStockRecruitTicket = self
            .summaryStockRecruitTicket
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExpeditionGo = self
            .summaryExpeditionGo
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExpeditionBack = self
            .summaryExpeditionBack
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RL04EndingText::create(
            _fbb,
            &clz_Torappu_RL04EndingTextArgs {
                summaryGetFragment,
                summaryUseIdea,
                summaryUseFood,
                summaryDropFragment,
                summaryMeetDisaster,
                summaryLeaveDisaster,
                summaryEnterAlchemy,
                summaryAlchemyOthers,
                summaryAlchemyFragment,
                summaryWeightOverweight,
                summaryWeightLimit,
                summaryWeightSafe,
                summaryPermUpgrade,
                summaryTempUpgrade,
                summarySellFragment,
                summaryActor,
                summaryTop,
                summaryZone,
                summaryEnding,
                summaryDifficultyZone,
                summaryDifficultyEnding,
                summaryMode,
                summarySupport,
                summaryGroup,
                summaryNormalRecruit,
                summaryDirectRecruit,
                summaryFriendRecruit,
                summaryFreeRecruit,
                summaryMonthRecruit,
                summaryUpgrade,
                summaryCompleteEnding,
                summaryEachZone,
                summaryMeetSpZone,
                summaryPerfectBattle,
                summaryMeetBattle,
                summaryMeetEvent,
                summaryMeetShop,
                summaryMeetTreasure,
                summaryMeetSecretpath,
                summaryExchangeRelic,
                summaryMeetTrade,
                summaryBuy,
                summaryBuyWithPriceId,
                summaryInvest,
                summaryGet,
                summaryRelic,
                summarySafeHouse,
                summaryFailEnd,
                summaryDuelWin,
                summaryDuelTie,
                summaryDuelLose,
                summaryStockRecruitTicket,
                summaryExpeditionGo,
                summaryExpeditionBack,
            },
        )
    }
}
pub enum clz_Torappu_RL04CustomizeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL04CustomizeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL04CustomizeData<'a> {
    type Inner = clz_Torappu_RL04CustomizeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL04CustomizeData<'a> {
    pub const VT_COMMONDEVELOPMENT: flatbuffers::VOffsetT = 4;
    pub const VT_DIFFICULTIES: flatbuffers::VOffsetT = 6;
    pub const VT_ENDINGTEXT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL04CustomizeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL04CustomizeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL04CustomizeData<'bldr>> {
        let mut builder = clz_Torappu_RL04CustomizeDataBuilder::new(_fbb);
        if let Some(x) = args.endingText {
            builder.add_endingText(x);
        }
        if let Some(x) = args.difficulties {
            builder.add_difficulties(x);
        }
        if let Some(x) = args.commonDevelopment {
            builder.add_commonDevelopment(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL04CustomizeDataT {
        let commonDevelopment = self.commonDevelopment().map(|x| Box::new(x.unpack()));
        let difficulties = self
            .difficulties()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let endingText = self.endingText().map(|x| Box::new(x.unpack()));
        clz_Torappu_RL04CustomizeDataT {
            commonDevelopment,
            difficulties,
            endingText,
        }
    }

    #[inline]
    pub fn commonDevelopment(&self) -> Option<clz_Torappu_RoguelikeCommonDevelopmentData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCommonDevelopmentData>>(
                    clz_Torappu_RL04CustomizeData::VT_COMMONDEVELOPMENT,
                    None,
                )
        }
    }
    #[inline]
    pub fn difficulties(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RL04DifficultyExt<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL04DifficultyExt>,
                >,
            >>(clz_Torappu_RL04CustomizeData::VT_DIFFICULTIES, None)
        }
    }
    #[inline]
    pub fn endingText(&self) -> Option<clz_Torappu_RL04EndingText<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RL04EndingText>>(
                    clz_Torappu_RL04CustomizeData::VT_ENDINGTEXT,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL04CustomizeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCommonDevelopmentData>>("commonDevelopment", Self::VT_COMMONDEVELOPMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RL04DifficultyExt>>>>("difficulties", Self::VT_DIFFICULTIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RL04EndingText>>("endingText", Self::VT_ENDINGTEXT, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL04CustomizeDataArgs<'a> {
    pub commonDevelopment:
        Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevelopmentData<'a>>>,
    pub difficulties: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL04DifficultyExt<'a>>,
            >,
        >,
    >,
    pub endingText: Option<flatbuffers::WIPOffset<clz_Torappu_RL04EndingText<'a>>>,
}
impl<'a> Default for clz_Torappu_RL04CustomizeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL04CustomizeDataArgs {
            commonDevelopment: None,
            difficulties: None,
            endingText: None,
        }
    }
}

impl Serialize for clz_Torappu_RL04CustomizeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL04CustomizeData", 3)?;
        if let Some(f) = self.commonDevelopment() {
            s.serialize_field("commonDevelopment", &f)?;
        } else {
            s.skip_field("commonDevelopment")?;
        }
        if let Some(f) = self.difficulties() {
            s.serialize_field("difficulties", &f)?;
        } else {
            s.skip_field("difficulties")?;
        }
        if let Some(f) = self.endingText() {
            s.serialize_field("endingText", &f)?;
        } else {
            s.skip_field("endingText")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL04CustomizeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL04CustomizeDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_commonDevelopment(
        &mut self,
        commonDevelopment: flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevelopmentData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevelopmentData>>(
                clz_Torappu_RL04CustomizeData::VT_COMMONDEVELOPMENT,
                commonDevelopment,
            );
    }
    #[inline]
    pub fn add_difficulties(
        &mut self,
        difficulties: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL04DifficultyExt<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL04CustomizeData::VT_DIFFICULTIES,
            difficulties,
        );
    }
    #[inline]
    pub fn add_endingText(
        &mut self,
        endingText: flatbuffers::WIPOffset<clz_Torappu_RL04EndingText<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RL04EndingText>>(
                clz_Torappu_RL04CustomizeData::VT_ENDINGTEXT,
                endingText,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL04CustomizeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL04CustomizeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL04CustomizeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL04CustomizeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL04CustomizeData");
        ds.field("commonDevelopment", &self.commonDevelopment());
        ds.field("difficulties", &self.difficulties());
        ds.field("endingText", &self.endingText());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL04CustomizeDataT {
    pub commonDevelopment: Option<Box<clz_Torappu_RoguelikeCommonDevelopmentDataT>>,
    pub difficulties: Option<Vec<clz_Torappu_RL04DifficultyExtT>>,
    pub endingText: Option<Box<clz_Torappu_RL04EndingTextT>>,
}
impl Default for clz_Torappu_RL04CustomizeDataT {
    fn default() -> Self {
        Self {
            commonDevelopment: None,
            difficulties: None,
            endingText: None,
        }
    }
}
impl clz_Torappu_RL04CustomizeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL04CustomizeData<'b>> {
        let commonDevelopment = self.commonDevelopment.as_ref().map(|x| x.pack(_fbb));
        let difficulties = self.difficulties.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let endingText = self.endingText.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RL04CustomizeData::create(
            _fbb,
            &clz_Torappu_RL04CustomizeDataArgs {
                commonDevelopment,
                difficulties,
                endingText,
            },
        )
    }
}
pub enum clz_Torappu_RL05DifficultyExtOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL05DifficultyExt<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL05DifficultyExt<'a> {
    type Inner = clz_Torappu_RL05DifficultyExt<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL05DifficultyExt<'a> {
    pub const VT_MODEDIFFICULTY: flatbuffers::VOffsetT = 4;
    pub const VT_GRADE: flatbuffers::VOffsetT = 6;
    pub const VT_BUFFS: flatbuffers::VOffsetT = 8;
    pub const VT_BUFFDESC: flatbuffers::VOffsetT = 10;
    pub const VT_LEFTWRATHDESC: flatbuffers::VOffsetT = 12;
    pub const VT_RELICDEVLEVEL: flatbuffers::VOffsetT = 14;
    pub const VT_GILDPROBDISPLAY: flatbuffers::VOffsetT = 16;
    pub const VT_SKYSTEPDESCRIPTION: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL05DifficultyExt { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL05DifficultyExtArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL05DifficultyExt<'bldr>> {
        let mut builder = clz_Torappu_RL05DifficultyExtBuilder::new(_fbb);
        if let Some(x) = args.skyStepDescription {
            builder.add_skyStepDescription(x);
        }
        if let Some(x) = args.gildProbDisplay {
            builder.add_gildProbDisplay(x);
        }
        if let Some(x) = args.relicDevLevel {
            builder.add_relicDevLevel(x);
        }
        if let Some(x) = args.leftWrathDesc {
            builder.add_leftWrathDesc(x);
        }
        if let Some(x) = args.buffDesc {
            builder.add_buffDesc(x);
        }
        if let Some(x) = args.buffs {
            builder.add_buffs(x);
        }
        builder.add_grade(args.grade);
        builder.add_modeDifficulty(args.modeDifficulty);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL05DifficultyExtT {
        let modeDifficulty = self.modeDifficulty();
        let grade = self.grade();
        let buffs = self
            .buffs()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let buffDesc = self
            .buffDesc()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let leftWrathDesc = self.leftWrathDesc().map(|x| x.to_string());
        let relicDevLevel = self.relicDevLevel().map(|x| x.to_string());
        let gildProbDisplay = self.gildProbDisplay().map(|x| x.to_string());
        let skyStepDescription = self.skyStepDescription().map(|x| x.to_string());
        clz_Torappu_RL05DifficultyExtT {
            modeDifficulty,
            grade,
            buffs,
            buffDesc,
            leftWrathDesc,
            relicDevLevel,
            gildProbDisplay,
            skyStepDescription,
        }
    }

    #[inline]
    pub fn modeDifficulty(&self) -> enum__Torappu_RoguelikeTopicMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RoguelikeTopicMode>(
                    clz_Torappu_RL05DifficultyExt::VT_MODEDIFFICULTY,
                    Some(enum__Torappu_RoguelikeTopicMode::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn grade(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RL05DifficultyExt::VT_GRADE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn buffs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RL05DifficultyExt::VT_BUFFS, None)
        }
    }
    #[inline]
    pub fn buffDesc(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RL05DifficultyExt::VT_BUFFDESC, None)
        }
    }
    #[inline]
    pub fn leftWrathDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05DifficultyExt::VT_LEFTWRATHDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn relicDevLevel(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05DifficultyExt::VT_RELICDEVLEVEL,
                None,
            )
        }
    }
    #[inline]
    pub fn gildProbDisplay(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05DifficultyExt::VT_GILDPROBDISPLAY,
                None,
            )
        }
    }
    #[inline]
    pub fn skyStepDescription(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05DifficultyExt::VT_SKYSTEPDESCRIPTION,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL05DifficultyExt<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_RoguelikeTopicMode>(
                "modeDifficulty",
                Self::VT_MODEDIFFICULTY,
                false,
            )?
            .visit_field::<i32>("grade", Self::VT_GRADE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("buffs", Self::VT_BUFFS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("buffDesc", Self::VT_BUFFDESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "leftWrathDesc",
                Self::VT_LEFTWRATHDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "relicDevLevel",
                Self::VT_RELICDEVLEVEL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "gildProbDisplay",
                Self::VT_GILDPROBDISPLAY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "skyStepDescription",
                Self::VT_SKYSTEPDESCRIPTION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL05DifficultyExtArgs<'a> {
    pub modeDifficulty: enum__Torappu_RoguelikeTopicMode,
    pub grade: i32,
    pub buffs: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub buffDesc: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub leftWrathDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relicDevLevel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gildProbDisplay: Option<flatbuffers::WIPOffset<&'a str>>,
    pub skyStepDescription: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RL05DifficultyExtArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL05DifficultyExtArgs {
            modeDifficulty: enum__Torappu_RoguelikeTopicMode::NONE,
            grade: 0,
            buffs: None,
            buffDesc: None,
            leftWrathDesc: None,
            relicDevLevel: None,
            gildProbDisplay: None,
            skyStepDescription: None,
        }
    }
}

impl Serialize for clz_Torappu_RL05DifficultyExt<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL05DifficultyExt", 8)?;
        s.serialize_field("modeDifficulty", &self.modeDifficulty())?;
        s.serialize_field("grade", &self.grade())?;
        if let Some(f) = self.buffs() {
            s.serialize_field("buffs", &f)?;
        } else {
            s.skip_field("buffs")?;
        }
        if let Some(f) = self.buffDesc() {
            s.serialize_field("buffDesc", &f)?;
        } else {
            s.skip_field("buffDesc")?;
        }
        if let Some(f) = self.leftWrathDesc() {
            s.serialize_field("leftWrathDesc", &f)?;
        } else {
            s.skip_field("leftWrathDesc")?;
        }
        if let Some(f) = self.relicDevLevel() {
            s.serialize_field("relicDevLevel", &f)?;
        } else {
            s.skip_field("relicDevLevel")?;
        }
        if let Some(f) = self.gildProbDisplay() {
            s.serialize_field("gildProbDisplay", &f)?;
        } else {
            s.skip_field("gildProbDisplay")?;
        }
        if let Some(f) = self.skyStepDescription() {
            s.serialize_field("skyStepDescription", &f)?;
        } else {
            s.skip_field("skyStepDescription")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL05DifficultyExtBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL05DifficultyExtBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_modeDifficulty(&mut self, modeDifficulty: enum__Torappu_RoguelikeTopicMode) {
        self.fbb_.push_slot::<enum__Torappu_RoguelikeTopicMode>(
            clz_Torappu_RL05DifficultyExt::VT_MODEDIFFICULTY,
            modeDifficulty,
            enum__Torappu_RoguelikeTopicMode::NONE,
        );
    }
    #[inline]
    pub fn add_grade(&mut self, grade: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RL05DifficultyExt::VT_GRADE, grade, 0);
    }
    #[inline]
    pub fn add_buffs(
        &mut self,
        buffs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05DifficultyExt::VT_BUFFS,
            buffs,
        );
    }
    #[inline]
    pub fn add_buffDesc(
        &mut self,
        buffDesc: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05DifficultyExt::VT_BUFFDESC,
            buffDesc,
        );
    }
    #[inline]
    pub fn add_leftWrathDesc(&mut self, leftWrathDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05DifficultyExt::VT_LEFTWRATHDESC,
            leftWrathDesc,
        );
    }
    #[inline]
    pub fn add_relicDevLevel(&mut self, relicDevLevel: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05DifficultyExt::VT_RELICDEVLEVEL,
            relicDevLevel,
        );
    }
    #[inline]
    pub fn add_gildProbDisplay(&mut self, gildProbDisplay: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05DifficultyExt::VT_GILDPROBDISPLAY,
            gildProbDisplay,
        );
    }
    #[inline]
    pub fn add_skyStepDescription(&mut self, skyStepDescription: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05DifficultyExt::VT_SKYSTEPDESCRIPTION,
            skyStepDescription,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL05DifficultyExtBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL05DifficultyExtBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL05DifficultyExt<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL05DifficultyExt<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL05DifficultyExt");
        ds.field("modeDifficulty", &self.modeDifficulty());
        ds.field("grade", &self.grade());
        ds.field("buffs", &self.buffs());
        ds.field("buffDesc", &self.buffDesc());
        ds.field("leftWrathDesc", &self.leftWrathDesc());
        ds.field("relicDevLevel", &self.relicDevLevel());
        ds.field("gildProbDisplay", &self.gildProbDisplay());
        ds.field("skyStepDescription", &self.skyStepDescription());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL05DifficultyExtT {
    pub modeDifficulty: enum__Torappu_RoguelikeTopicMode,
    pub grade: i32,
    pub buffs: Option<Vec<String>>,
    pub buffDesc: Option<Vec<String>>,
    pub leftWrathDesc: Option<String>,
    pub relicDevLevel: Option<String>,
    pub gildProbDisplay: Option<String>,
    pub skyStepDescription: Option<String>,
}
impl Default for clz_Torappu_RL05DifficultyExtT {
    fn default() -> Self {
        Self {
            modeDifficulty: enum__Torappu_RoguelikeTopicMode::NONE,
            grade: 0,
            buffs: None,
            buffDesc: None,
            leftWrathDesc: None,
            relicDevLevel: None,
            gildProbDisplay: None,
            skyStepDescription: None,
        }
    }
}
impl clz_Torappu_RL05DifficultyExtT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL05DifficultyExt<'b>> {
        let modeDifficulty = self.modeDifficulty;
        let grade = self.grade;
        let buffs = self.buffs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let buffDesc = self.buffDesc.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let leftWrathDesc = self.leftWrathDesc.as_ref().map(|x| _fbb.create_string(x));
        let relicDevLevel = self.relicDevLevel.as_ref().map(|x| _fbb.create_string(x));
        let gildProbDisplay = self.gildProbDisplay.as_ref().map(|x| _fbb.create_string(x));
        let skyStepDescription = self
            .skyStepDescription
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RL05DifficultyExt::create(
            _fbb,
            &clz_Torappu_RL05DifficultyExtArgs {
                modeDifficulty,
                grade,
                buffs,
                buffDesc,
                leftWrathDesc,
                relicDevLevel,
                gildProbDisplay,
                skyStepDescription,
            },
        )
    }
}
pub enum clz_Torappu_RL05EndingTextOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL05EndingText<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL05EndingText<'a> {
    type Inner = clz_Torappu_RL05EndingText<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL05EndingText<'a> {
    pub const VT_SUMMARYGETCOPPER: flatbuffers::VOffsetT = 4;
    pub const VT_SUMMARYLOSTCOPPER: flatbuffers::VOffsetT = 6;
    pub const VT_SUMMARYDRAWCOPPER: flatbuffers::VOffsetT = 8;
    pub const VT_SUMMARYCOPPERRESULTGOOD: flatbuffers::VOffsetT = 10;
    pub const VT_SUMMARYCOPPERRESULTBAD: flatbuffers::VOffsetT = 12;
    pub const VT_SUMMARYCOPPERRESULTNORMAL: flatbuffers::VOffsetT = 14;
    pub const VT_SUMMARYCOPPERCHECKSUCCESS: flatbuffers::VOffsetT = 16;
    pub const VT_SUMMARYCOPPERCHECKFAIL: flatbuffers::VOffsetT = 18;
    pub const VT_SUMMARYCOPPERCHECKNORMAL: flatbuffers::VOffsetT = 20;
    pub const VT_SUMMARYMEETWRATH: flatbuffers::VOffsetT = 22;
    pub const VT_SUMMARYEXPEDITIONGOENDINGFOUR: flatbuffers::VOffsetT = 24;
    pub const VT_SUMMARYEXPEDITIONBACKENDINGFOUR: flatbuffers::VOffsetT = 26;
    pub const VT_SUMMARYEXPEDITIONBACKCANDLE: flatbuffers::VOffsetT = 28;
    pub const VT_SUMMARYEXPEDITIONGOENDING: flatbuffers::VOffsetT = 30;
    pub const VT_SUMMARYEXPEDITIONBACKENDING: flatbuffers::VOffsetT = 32;
    pub const VT_SUMMARYHOLDCANDLE: flatbuffers::VOffsetT = 34;
    pub const VT_SUMMARYHOLDCANDLERECRUIT: flatbuffers::VOffsetT = 36;
    pub const VT_SUMMARYHOLDCANDLEUPGRADE: flatbuffers::VOffsetT = 38;
    pub const VT_SUMMARYEXCHANGESPZONEGET: flatbuffers::VOffsetT = 40;
    pub const VT_SUMMARYMEETSHOPSPZONE: flatbuffers::VOffsetT = 42;
    pub const VT_SUMMARYBATTLEFAILSPZONE: flatbuffers::VOffsetT = 44;
    pub const VT_SUMMARYMEETEVENTLOCK: flatbuffers::VOffsetT = 46;
    pub const VT_SUMMARYTREASURESPZONE: flatbuffers::VOffsetT = 48;
    pub const VT_SUMMARYMEETEXCHANGESPZONE: flatbuffers::VOffsetT = 50;
    pub const VT_SUMMARYMEETTRADESPZONE: flatbuffers::VOffsetT = 52;
    pub const VT_SUMMARYACTOR: flatbuffers::VOffsetT = 54;
    pub const VT_SUMMARYTOP: flatbuffers::VOffsetT = 56;
    pub const VT_SUMMARYZONE: flatbuffers::VOffsetT = 58;
    pub const VT_SUMMARYENDING: flatbuffers::VOffsetT = 60;
    pub const VT_SUMMARYDIFFICULTYZONE: flatbuffers::VOffsetT = 62;
    pub const VT_SUMMARYDIFFICULTYENDING: flatbuffers::VOffsetT = 64;
    pub const VT_SUMMARYMODE: flatbuffers::VOffsetT = 66;
    pub const VT_SUMMARYSUPPORT: flatbuffers::VOffsetT = 68;
    pub const VT_SUMMARYGROUP: flatbuffers::VOffsetT = 70;
    pub const VT_SUMMARYNORMALRECRUIT: flatbuffers::VOffsetT = 72;
    pub const VT_SUMMARYDIRECTRECRUIT: flatbuffers::VOffsetT = 74;
    pub const VT_SUMMARYFRIENDRECRUIT: flatbuffers::VOffsetT = 76;
    pub const VT_SUMMARYFREERECRUIT: flatbuffers::VOffsetT = 78;
    pub const VT_SUMMARYMONTHRECRUIT: flatbuffers::VOffsetT = 80;
    pub const VT_SUMMARYUPGRADE: flatbuffers::VOffsetT = 82;
    pub const VT_SUMMARYCOMPLETEENDING: flatbuffers::VOffsetT = 84;
    pub const VT_SUMMARYEACHZONE: flatbuffers::VOffsetT = 86;
    pub const VT_SUMMARYMEETSPZONE: flatbuffers::VOffsetT = 88;
    pub const VT_SUMMARYPERFECTBATTLE: flatbuffers::VOffsetT = 90;
    pub const VT_SUMMARYMEETBATTLE: flatbuffers::VOffsetT = 92;
    pub const VT_SUMMARYMEETEVENT: flatbuffers::VOffsetT = 94;
    pub const VT_SUMMARYMEETSHOP: flatbuffers::VOffsetT = 96;
    pub const VT_SUMMARYMEETTREASURE: flatbuffers::VOffsetT = 98;
    pub const VT_SUMMARYMEETSECRETPATH: flatbuffers::VOffsetT = 100;
    pub const VT_SUMMARYEXCHANGERELIC: flatbuffers::VOffsetT = 102;
    pub const VT_SUMMARYMEETTRADE: flatbuffers::VOffsetT = 104;
    pub const VT_SUMMARYBUY: flatbuffers::VOffsetT = 106;
    pub const VT_SUMMARYBUYWITHPRICEID: flatbuffers::VOffsetT = 108;
    pub const VT_SUMMARYINVEST: flatbuffers::VOffsetT = 110;
    pub const VT_SUMMARYGET: flatbuffers::VOffsetT = 112;
    pub const VT_SUMMARYRELIC: flatbuffers::VOffsetT = 114;
    pub const VT_SUMMARYSAFEHOUSE: flatbuffers::VOffsetT = 116;
    pub const VT_SUMMARYFAILEND: flatbuffers::VOffsetT = 118;
    pub const VT_SUMMARYSTOCKRECRUITTICKET: flatbuffers::VOffsetT = 120;
    pub const VT_SUMMARYDUELWIN: flatbuffers::VOffsetT = 122;
    pub const VT_SUMMARYDUELTIE: flatbuffers::VOffsetT = 124;
    pub const VT_SUMMARYDUELLOSE: flatbuffers::VOffsetT = 126;
    pub const VT_SUMMARYEXPEDITIONGO: flatbuffers::VOffsetT = 128;
    pub const VT_SUMMARYEXPEDITIONBACK: flatbuffers::VOffsetT = 130;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL05EndingText { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL05EndingTextArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL05EndingText<'bldr>> {
        let mut builder = clz_Torappu_RL05EndingTextBuilder::new(_fbb);
        if let Some(x) = args.summaryExpeditionBack {
            builder.add_summaryExpeditionBack(x);
        }
        if let Some(x) = args.summaryExpeditionGo {
            builder.add_summaryExpeditionGo(x);
        }
        if let Some(x) = args.summaryDuelLose {
            builder.add_summaryDuelLose(x);
        }
        if let Some(x) = args.summaryDuelTie {
            builder.add_summaryDuelTie(x);
        }
        if let Some(x) = args.summaryDuelWin {
            builder.add_summaryDuelWin(x);
        }
        if let Some(x) = args.summaryStockRecruitTicket {
            builder.add_summaryStockRecruitTicket(x);
        }
        if let Some(x) = args.summaryFailEnd {
            builder.add_summaryFailEnd(x);
        }
        if let Some(x) = args.summarySafeHouse {
            builder.add_summarySafeHouse(x);
        }
        if let Some(x) = args.summaryRelic {
            builder.add_summaryRelic(x);
        }
        if let Some(x) = args.summaryGet {
            builder.add_summaryGet(x);
        }
        if let Some(x) = args.summaryInvest {
            builder.add_summaryInvest(x);
        }
        if let Some(x) = args.summaryBuyWithPriceId {
            builder.add_summaryBuyWithPriceId(x);
        }
        if let Some(x) = args.summaryBuy {
            builder.add_summaryBuy(x);
        }
        if let Some(x) = args.summaryMeetTrade {
            builder.add_summaryMeetTrade(x);
        }
        if let Some(x) = args.summaryExchangeRelic {
            builder.add_summaryExchangeRelic(x);
        }
        if let Some(x) = args.summaryMeetSecretpath {
            builder.add_summaryMeetSecretpath(x);
        }
        if let Some(x) = args.summaryMeetTreasure {
            builder.add_summaryMeetTreasure(x);
        }
        if let Some(x) = args.summaryMeetShop {
            builder.add_summaryMeetShop(x);
        }
        if let Some(x) = args.summaryMeetEvent {
            builder.add_summaryMeetEvent(x);
        }
        if let Some(x) = args.summaryMeetBattle {
            builder.add_summaryMeetBattle(x);
        }
        if let Some(x) = args.summaryPerfectBattle {
            builder.add_summaryPerfectBattle(x);
        }
        if let Some(x) = args.summaryMeetSpZone {
            builder.add_summaryMeetSpZone(x);
        }
        if let Some(x) = args.summaryEachZone {
            builder.add_summaryEachZone(x);
        }
        if let Some(x) = args.summaryCompleteEnding {
            builder.add_summaryCompleteEnding(x);
        }
        if let Some(x) = args.summaryUpgrade {
            builder.add_summaryUpgrade(x);
        }
        if let Some(x) = args.summaryMonthRecruit {
            builder.add_summaryMonthRecruit(x);
        }
        if let Some(x) = args.summaryFreeRecruit {
            builder.add_summaryFreeRecruit(x);
        }
        if let Some(x) = args.summaryFriendRecruit {
            builder.add_summaryFriendRecruit(x);
        }
        if let Some(x) = args.summaryDirectRecruit {
            builder.add_summaryDirectRecruit(x);
        }
        if let Some(x) = args.summaryNormalRecruit {
            builder.add_summaryNormalRecruit(x);
        }
        if let Some(x) = args.summaryGroup {
            builder.add_summaryGroup(x);
        }
        if let Some(x) = args.summarySupport {
            builder.add_summarySupport(x);
        }
        if let Some(x) = args.summaryMode {
            builder.add_summaryMode(x);
        }
        if let Some(x) = args.summaryDifficultyEnding {
            builder.add_summaryDifficultyEnding(x);
        }
        if let Some(x) = args.summaryDifficultyZone {
            builder.add_summaryDifficultyZone(x);
        }
        if let Some(x) = args.summaryEnding {
            builder.add_summaryEnding(x);
        }
        if let Some(x) = args.summaryZone {
            builder.add_summaryZone(x);
        }
        if let Some(x) = args.summaryTop {
            builder.add_summaryTop(x);
        }
        if let Some(x) = args.summaryActor {
            builder.add_summaryActor(x);
        }
        if let Some(x) = args.summaryMeetTradeSpZone {
            builder.add_summaryMeetTradeSpZone(x);
        }
        if let Some(x) = args.summaryMeetExchangeSpZone {
            builder.add_summaryMeetExchangeSpZone(x);
        }
        if let Some(x) = args.summaryTreasureSpZone {
            builder.add_summaryTreasureSpZone(x);
        }
        if let Some(x) = args.summaryMeetEventLock {
            builder.add_summaryMeetEventLock(x);
        }
        if let Some(x) = args.summaryBattleFailSpZone {
            builder.add_summaryBattleFailSpZone(x);
        }
        if let Some(x) = args.summaryMeetShopSpZone {
            builder.add_summaryMeetShopSpZone(x);
        }
        if let Some(x) = args.summaryExchangeSpZoneGet {
            builder.add_summaryExchangeSpZoneGet(x);
        }
        if let Some(x) = args.summaryHoldCandleUpgrade {
            builder.add_summaryHoldCandleUpgrade(x);
        }
        if let Some(x) = args.summaryHoldCandleRecruit {
            builder.add_summaryHoldCandleRecruit(x);
        }
        if let Some(x) = args.summaryHoldCandle {
            builder.add_summaryHoldCandle(x);
        }
        if let Some(x) = args.summaryExpeditionBackEnding {
            builder.add_summaryExpeditionBackEnding(x);
        }
        if let Some(x) = args.summaryExpeditionGoEnding {
            builder.add_summaryExpeditionGoEnding(x);
        }
        if let Some(x) = args.summaryExpeditionBackCandle {
            builder.add_summaryExpeditionBackCandle(x);
        }
        if let Some(x) = args.summaryExpeditionBackEndingFour {
            builder.add_summaryExpeditionBackEndingFour(x);
        }
        if let Some(x) = args.summaryExpeditionGoEndingFour {
            builder.add_summaryExpeditionGoEndingFour(x);
        }
        if let Some(x) = args.summaryMeetWrath {
            builder.add_summaryMeetWrath(x);
        }
        if let Some(x) = args.summaryCopperCheckNormal {
            builder.add_summaryCopperCheckNormal(x);
        }
        if let Some(x) = args.summaryCopperCheckFail {
            builder.add_summaryCopperCheckFail(x);
        }
        if let Some(x) = args.summaryCopperCheckSuccess {
            builder.add_summaryCopperCheckSuccess(x);
        }
        if let Some(x) = args.summaryCopperResultNormal {
            builder.add_summaryCopperResultNormal(x);
        }
        if let Some(x) = args.summaryCopperResultBad {
            builder.add_summaryCopperResultBad(x);
        }
        if let Some(x) = args.summaryCopperResultGood {
            builder.add_summaryCopperResultGood(x);
        }
        if let Some(x) = args.summaryDrawCopper {
            builder.add_summaryDrawCopper(x);
        }
        if let Some(x) = args.summaryLostCopper {
            builder.add_summaryLostCopper(x);
        }
        if let Some(x) = args.summaryGetCopper {
            builder.add_summaryGetCopper(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL05EndingTextT {
        let summaryGetCopper = self.summaryGetCopper().map(|x| x.to_string());
        let summaryLostCopper = self.summaryLostCopper().map(|x| x.to_string());
        let summaryDrawCopper = self.summaryDrawCopper().map(|x| x.to_string());
        let summaryCopperResultGood = self.summaryCopperResultGood().map(|x| x.to_string());
        let summaryCopperResultBad = self.summaryCopperResultBad().map(|x| x.to_string());
        let summaryCopperResultNormal = self.summaryCopperResultNormal().map(|x| x.to_string());
        let summaryCopperCheckSuccess = self.summaryCopperCheckSuccess().map(|x| x.to_string());
        let summaryCopperCheckFail = self.summaryCopperCheckFail().map(|x| x.to_string());
        let summaryCopperCheckNormal = self.summaryCopperCheckNormal().map(|x| x.to_string());
        let summaryMeetWrath = self.summaryMeetWrath().map(|x| x.to_string());
        let summaryExpeditionGoEndingFour =
            self.summaryExpeditionGoEndingFour().map(|x| x.to_string());
        let summaryExpeditionBackEndingFour = self
            .summaryExpeditionBackEndingFour()
            .map(|x| x.to_string());
        let summaryExpeditionBackCandle = self.summaryExpeditionBackCandle().map(|x| x.to_string());
        let summaryExpeditionGoEnding = self.summaryExpeditionGoEnding().map(|x| x.to_string());
        let summaryExpeditionBackEnding = self.summaryExpeditionBackEnding().map(|x| x.to_string());
        let summaryHoldCandle = self.summaryHoldCandle().map(|x| x.to_string());
        let summaryHoldCandleRecruit = self.summaryHoldCandleRecruit().map(|x| x.to_string());
        let summaryHoldCandleUpgrade = self.summaryHoldCandleUpgrade().map(|x| x.to_string());
        let summaryExchangeSpZoneGet = self.summaryExchangeSpZoneGet().map(|x| x.to_string());
        let summaryMeetShopSpZone = self.summaryMeetShopSpZone().map(|x| x.to_string());
        let summaryBattleFailSpZone = self.summaryBattleFailSpZone().map(|x| x.to_string());
        let summaryMeetEventLock = self.summaryMeetEventLock().map(|x| x.to_string());
        let summaryTreasureSpZone = self.summaryTreasureSpZone().map(|x| x.to_string());
        let summaryMeetExchangeSpZone = self.summaryMeetExchangeSpZone().map(|x| x.to_string());
        let summaryMeetTradeSpZone = self.summaryMeetTradeSpZone().map(|x| x.to_string());
        let summaryActor = self.summaryActor().map(|x| x.to_string());
        let summaryTop = self.summaryTop().map(|x| x.to_string());
        let summaryZone = self.summaryZone().map(|x| x.to_string());
        let summaryEnding = self.summaryEnding().map(|x| x.to_string());
        let summaryDifficultyZone = self.summaryDifficultyZone().map(|x| x.to_string());
        let summaryDifficultyEnding = self.summaryDifficultyEnding().map(|x| x.to_string());
        let summaryMode = self.summaryMode().map(|x| x.to_string());
        let summarySupport = self.summarySupport().map(|x| x.to_string());
        let summaryGroup = self.summaryGroup().map(|x| x.to_string());
        let summaryNormalRecruit = self.summaryNormalRecruit().map(|x| x.to_string());
        let summaryDirectRecruit = self.summaryDirectRecruit().map(|x| x.to_string());
        let summaryFriendRecruit = self.summaryFriendRecruit().map(|x| x.to_string());
        let summaryFreeRecruit = self.summaryFreeRecruit().map(|x| x.to_string());
        let summaryMonthRecruit = self.summaryMonthRecruit().map(|x| x.to_string());
        let summaryUpgrade = self.summaryUpgrade().map(|x| x.to_string());
        let summaryCompleteEnding = self.summaryCompleteEnding().map(|x| x.to_string());
        let summaryEachZone = self.summaryEachZone().map(|x| x.to_string());
        let summaryMeetSpZone = self.summaryMeetSpZone().map(|x| x.to_string());
        let summaryPerfectBattle = self.summaryPerfectBattle().map(|x| x.to_string());
        let summaryMeetBattle = self.summaryMeetBattle().map(|x| x.to_string());
        let summaryMeetEvent = self.summaryMeetEvent().map(|x| x.to_string());
        let summaryMeetShop = self.summaryMeetShop().map(|x| x.to_string());
        let summaryMeetTreasure = self.summaryMeetTreasure().map(|x| x.to_string());
        let summaryMeetSecretpath = self.summaryMeetSecretpath().map(|x| x.to_string());
        let summaryExchangeRelic = self.summaryExchangeRelic().map(|x| x.to_string());
        let summaryMeetTrade = self.summaryMeetTrade().map(|x| x.to_string());
        let summaryBuy = self.summaryBuy().map(|x| x.to_string());
        let summaryBuyWithPriceId = self.summaryBuyWithPriceId().map(|x| x.to_string());
        let summaryInvest = self.summaryInvest().map(|x| x.to_string());
        let summaryGet = self.summaryGet().map(|x| x.to_string());
        let summaryRelic = self.summaryRelic().map(|x| x.to_string());
        let summarySafeHouse = self.summarySafeHouse().map(|x| x.to_string());
        let summaryFailEnd = self.summaryFailEnd().map(|x| x.to_string());
        let summaryStockRecruitTicket = self.summaryStockRecruitTicket().map(|x| x.to_string());
        let summaryDuelWin = self.summaryDuelWin().map(|x| x.to_string());
        let summaryDuelTie = self.summaryDuelTie().map(|x| x.to_string());
        let summaryDuelLose = self.summaryDuelLose().map(|x| x.to_string());
        let summaryExpeditionGo = self.summaryExpeditionGo().map(|x| x.to_string());
        let summaryExpeditionBack = self.summaryExpeditionBack().map(|x| x.to_string());
        clz_Torappu_RL05EndingTextT {
            summaryGetCopper,
            summaryLostCopper,
            summaryDrawCopper,
            summaryCopperResultGood,
            summaryCopperResultBad,
            summaryCopperResultNormal,
            summaryCopperCheckSuccess,
            summaryCopperCheckFail,
            summaryCopperCheckNormal,
            summaryMeetWrath,
            summaryExpeditionGoEndingFour,
            summaryExpeditionBackEndingFour,
            summaryExpeditionBackCandle,
            summaryExpeditionGoEnding,
            summaryExpeditionBackEnding,
            summaryHoldCandle,
            summaryHoldCandleRecruit,
            summaryHoldCandleUpgrade,
            summaryExchangeSpZoneGet,
            summaryMeetShopSpZone,
            summaryBattleFailSpZone,
            summaryMeetEventLock,
            summaryTreasureSpZone,
            summaryMeetExchangeSpZone,
            summaryMeetTradeSpZone,
            summaryActor,
            summaryTop,
            summaryZone,
            summaryEnding,
            summaryDifficultyZone,
            summaryDifficultyEnding,
            summaryMode,
            summarySupport,
            summaryGroup,
            summaryNormalRecruit,
            summaryDirectRecruit,
            summaryFriendRecruit,
            summaryFreeRecruit,
            summaryMonthRecruit,
            summaryUpgrade,
            summaryCompleteEnding,
            summaryEachZone,
            summaryMeetSpZone,
            summaryPerfectBattle,
            summaryMeetBattle,
            summaryMeetEvent,
            summaryMeetShop,
            summaryMeetTreasure,
            summaryMeetSecretpath,
            summaryExchangeRelic,
            summaryMeetTrade,
            summaryBuy,
            summaryBuyWithPriceId,
            summaryInvest,
            summaryGet,
            summaryRelic,
            summarySafeHouse,
            summaryFailEnd,
            summaryStockRecruitTicket,
            summaryDuelWin,
            summaryDuelTie,
            summaryDuelLose,
            summaryExpeditionGo,
            summaryExpeditionBack,
        }
    }

    #[inline]
    pub fn summaryGetCopper(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYGETCOPPER,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryLostCopper(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYLOSTCOPPER,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDrawCopper(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYDRAWCOPPER,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryCopperResultGood(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYCOPPERRESULTGOOD,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryCopperResultBad(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYCOPPERRESULTBAD,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryCopperResultNormal(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYCOPPERRESULTNORMAL,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryCopperCheckSuccess(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYCOPPERCHECKSUCCESS,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryCopperCheckFail(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYCOPPERCHECKFAIL,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryCopperCheckNormal(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYCOPPERCHECKNORMAL,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetWrath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYMEETWRATH,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExpeditionGoEndingFour(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYEXPEDITIONGOENDINGFOUR,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExpeditionBackEndingFour(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYEXPEDITIONBACKENDINGFOUR,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExpeditionBackCandle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYEXPEDITIONBACKCANDLE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExpeditionGoEnding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYEXPEDITIONGOENDING,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExpeditionBackEnding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYEXPEDITIONBACKENDING,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryHoldCandle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYHOLDCANDLE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryHoldCandleRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYHOLDCANDLERECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryHoldCandleUpgrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYHOLDCANDLEUPGRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExchangeSpZoneGet(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYEXCHANGESPZONEGET,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetShopSpZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYMEETSHOPSPZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryBattleFailSpZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYBATTLEFAILSPZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetEventLock(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYMEETEVENTLOCK,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryTreasureSpZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYTREASURESPZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetExchangeSpZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYMEETEXCHANGESPZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetTradeSpZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYMEETTRADESPZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryActor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYACTOR,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryTop(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYTOP,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryEnding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYENDING,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDifficultyZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYDIFFICULTYZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDifficultyEnding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYDIFFICULTYENDING,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMode(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYMODE,
                None,
            )
        }
    }
    #[inline]
    pub fn summarySupport(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYSUPPORT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryGroup(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryNormalRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYNORMALRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDirectRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYDIRECTRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryFriendRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYFRIENDRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryFreeRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYFREERECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMonthRecruit(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYMONTHRECRUIT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryUpgrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYUPGRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryCompleteEnding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYCOMPLETEENDING,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryEachZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYEACHZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetSpZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYMEETSPZONE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryPerfectBattle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYPERFECTBATTLE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetBattle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYMEETBATTLE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetEvent(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYMEETEVENT,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetShop(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYMEETSHOP,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetTreasure(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYMEETTREASURE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetSecretpath(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYMEETSECRETPATH,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExchangeRelic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYEXCHANGERELIC,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryMeetTrade(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYMEETTRADE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryBuy(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYBUY,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryBuyWithPriceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYBUYWITHPRICEID,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryInvest(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYINVEST,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryGet(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYGET,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryRelic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYRELIC,
                None,
            )
        }
    }
    #[inline]
    pub fn summarySafeHouse(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYSAFEHOUSE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryFailEnd(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYFAILEND,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryStockRecruitTicket(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYSTOCKRECRUITTICKET,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDuelWin(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYDUELWIN,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDuelTie(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYDUELTIE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryDuelLose(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYDUELLOSE,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExpeditionGo(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYEXPEDITIONGO,
                None,
            )
        }
    }
    #[inline]
    pub fn summaryExpeditionBack(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RL05EndingText::VT_SUMMARYEXPEDITIONBACK,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL05EndingText<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryGetCopper",
                Self::VT_SUMMARYGETCOPPER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryLostCopper",
                Self::VT_SUMMARYLOSTCOPPER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDrawCopper",
                Self::VT_SUMMARYDRAWCOPPER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryCopperResultGood",
                Self::VT_SUMMARYCOPPERRESULTGOOD,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryCopperResultBad",
                Self::VT_SUMMARYCOPPERRESULTBAD,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryCopperResultNormal",
                Self::VT_SUMMARYCOPPERRESULTNORMAL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryCopperCheckSuccess",
                Self::VT_SUMMARYCOPPERCHECKSUCCESS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryCopperCheckFail",
                Self::VT_SUMMARYCOPPERCHECKFAIL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryCopperCheckNormal",
                Self::VT_SUMMARYCOPPERCHECKNORMAL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetWrath",
                Self::VT_SUMMARYMEETWRATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExpeditionGoEndingFour",
                Self::VT_SUMMARYEXPEDITIONGOENDINGFOUR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExpeditionBackEndingFour",
                Self::VT_SUMMARYEXPEDITIONBACKENDINGFOUR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExpeditionBackCandle",
                Self::VT_SUMMARYEXPEDITIONBACKCANDLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExpeditionGoEnding",
                Self::VT_SUMMARYEXPEDITIONGOENDING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExpeditionBackEnding",
                Self::VT_SUMMARYEXPEDITIONBACKENDING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryHoldCandle",
                Self::VT_SUMMARYHOLDCANDLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryHoldCandleRecruit",
                Self::VT_SUMMARYHOLDCANDLERECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryHoldCandleUpgrade",
                Self::VT_SUMMARYHOLDCANDLEUPGRADE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExchangeSpZoneGet",
                Self::VT_SUMMARYEXCHANGESPZONEGET,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetShopSpZone",
                Self::VT_SUMMARYMEETSHOPSPZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryBattleFailSpZone",
                Self::VT_SUMMARYBATTLEFAILSPZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetEventLock",
                Self::VT_SUMMARYMEETEVENTLOCK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryTreasureSpZone",
                Self::VT_SUMMARYTREASURESPZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetExchangeSpZone",
                Self::VT_SUMMARYMEETEXCHANGESPZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetTradeSpZone",
                Self::VT_SUMMARYMEETTRADESPZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryActor",
                Self::VT_SUMMARYACTOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryTop",
                Self::VT_SUMMARYTOP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryZone",
                Self::VT_SUMMARYZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryEnding",
                Self::VT_SUMMARYENDING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDifficultyZone",
                Self::VT_SUMMARYDIFFICULTYZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDifficultyEnding",
                Self::VT_SUMMARYDIFFICULTYENDING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMode",
                Self::VT_SUMMARYMODE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summarySupport",
                Self::VT_SUMMARYSUPPORT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryGroup",
                Self::VT_SUMMARYGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryNormalRecruit",
                Self::VT_SUMMARYNORMALRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDirectRecruit",
                Self::VT_SUMMARYDIRECTRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryFriendRecruit",
                Self::VT_SUMMARYFRIENDRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryFreeRecruit",
                Self::VT_SUMMARYFREERECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMonthRecruit",
                Self::VT_SUMMARYMONTHRECRUIT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryUpgrade",
                Self::VT_SUMMARYUPGRADE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryCompleteEnding",
                Self::VT_SUMMARYCOMPLETEENDING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryEachZone",
                Self::VT_SUMMARYEACHZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetSpZone",
                Self::VT_SUMMARYMEETSPZONE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryPerfectBattle",
                Self::VT_SUMMARYPERFECTBATTLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetBattle",
                Self::VT_SUMMARYMEETBATTLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetEvent",
                Self::VT_SUMMARYMEETEVENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetShop",
                Self::VT_SUMMARYMEETSHOP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetTreasure",
                Self::VT_SUMMARYMEETTREASURE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetSecretpath",
                Self::VT_SUMMARYMEETSECRETPATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExchangeRelic",
                Self::VT_SUMMARYEXCHANGERELIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryMeetTrade",
                Self::VT_SUMMARYMEETTRADE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryBuy",
                Self::VT_SUMMARYBUY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryBuyWithPriceId",
                Self::VT_SUMMARYBUYWITHPRICEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryInvest",
                Self::VT_SUMMARYINVEST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryGet",
                Self::VT_SUMMARYGET,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryRelic",
                Self::VT_SUMMARYRELIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summarySafeHouse",
                Self::VT_SUMMARYSAFEHOUSE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryFailEnd",
                Self::VT_SUMMARYFAILEND,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryStockRecruitTicket",
                Self::VT_SUMMARYSTOCKRECRUITTICKET,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDuelWin",
                Self::VT_SUMMARYDUELWIN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDuelTie",
                Self::VT_SUMMARYDUELTIE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryDuelLose",
                Self::VT_SUMMARYDUELLOSE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExpeditionGo",
                Self::VT_SUMMARYEXPEDITIONGO,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "summaryExpeditionBack",
                Self::VT_SUMMARYEXPEDITIONBACK,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL05EndingTextArgs<'a> {
    pub summaryGetCopper: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryLostCopper: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDrawCopper: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryCopperResultGood: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryCopperResultBad: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryCopperResultNormal: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryCopperCheckSuccess: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryCopperCheckFail: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryCopperCheckNormal: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetWrath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExpeditionGoEndingFour: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExpeditionBackEndingFour: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExpeditionBackCandle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExpeditionGoEnding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExpeditionBackEnding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryHoldCandle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryHoldCandleRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryHoldCandleUpgrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExchangeSpZoneGet: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetShopSpZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryBattleFailSpZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetEventLock: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryTreasureSpZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetExchangeSpZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetTradeSpZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryActor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryTop: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryEnding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDifficultyZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDifficultyEnding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMode: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summarySupport: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryNormalRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDirectRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryFriendRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryFreeRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMonthRecruit: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryUpgrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryCompleteEnding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryEachZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetSpZone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryPerfectBattle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetBattle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetEvent: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetShop: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetTreasure: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetSecretpath: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExchangeRelic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryMeetTrade: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryBuy: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryBuyWithPriceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryInvest: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryGet: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryRelic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summarySafeHouse: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryFailEnd: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryStockRecruitTicket: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDuelWin: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDuelTie: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryDuelLose: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExpeditionGo: Option<flatbuffers::WIPOffset<&'a str>>,
    pub summaryExpeditionBack: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RL05EndingTextArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL05EndingTextArgs {
            summaryGetCopper: None,
            summaryLostCopper: None,
            summaryDrawCopper: None,
            summaryCopperResultGood: None,
            summaryCopperResultBad: None,
            summaryCopperResultNormal: None,
            summaryCopperCheckSuccess: None,
            summaryCopperCheckFail: None,
            summaryCopperCheckNormal: None,
            summaryMeetWrath: None,
            summaryExpeditionGoEndingFour: None,
            summaryExpeditionBackEndingFour: None,
            summaryExpeditionBackCandle: None,
            summaryExpeditionGoEnding: None,
            summaryExpeditionBackEnding: None,
            summaryHoldCandle: None,
            summaryHoldCandleRecruit: None,
            summaryHoldCandleUpgrade: None,
            summaryExchangeSpZoneGet: None,
            summaryMeetShopSpZone: None,
            summaryBattleFailSpZone: None,
            summaryMeetEventLock: None,
            summaryTreasureSpZone: None,
            summaryMeetExchangeSpZone: None,
            summaryMeetTradeSpZone: None,
            summaryActor: None,
            summaryTop: None,
            summaryZone: None,
            summaryEnding: None,
            summaryDifficultyZone: None,
            summaryDifficultyEnding: None,
            summaryMode: None,
            summarySupport: None,
            summaryGroup: None,
            summaryNormalRecruit: None,
            summaryDirectRecruit: None,
            summaryFriendRecruit: None,
            summaryFreeRecruit: None,
            summaryMonthRecruit: None,
            summaryUpgrade: None,
            summaryCompleteEnding: None,
            summaryEachZone: None,
            summaryMeetSpZone: None,
            summaryPerfectBattle: None,
            summaryMeetBattle: None,
            summaryMeetEvent: None,
            summaryMeetShop: None,
            summaryMeetTreasure: None,
            summaryMeetSecretpath: None,
            summaryExchangeRelic: None,
            summaryMeetTrade: None,
            summaryBuy: None,
            summaryBuyWithPriceId: None,
            summaryInvest: None,
            summaryGet: None,
            summaryRelic: None,
            summarySafeHouse: None,
            summaryFailEnd: None,
            summaryStockRecruitTicket: None,
            summaryDuelWin: None,
            summaryDuelTie: None,
            summaryDuelLose: None,
            summaryExpeditionGo: None,
            summaryExpeditionBack: None,
        }
    }
}

impl Serialize for clz_Torappu_RL05EndingText<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL05EndingText", 64)?;
        if let Some(f) = self.summaryGetCopper() {
            s.serialize_field("summaryGetCopper", &f)?;
        } else {
            s.skip_field("summaryGetCopper")?;
        }
        if let Some(f) = self.summaryLostCopper() {
            s.serialize_field("summaryLostCopper", &f)?;
        } else {
            s.skip_field("summaryLostCopper")?;
        }
        if let Some(f) = self.summaryDrawCopper() {
            s.serialize_field("summaryDrawCopper", &f)?;
        } else {
            s.skip_field("summaryDrawCopper")?;
        }
        if let Some(f) = self.summaryCopperResultGood() {
            s.serialize_field("summaryCopperResultGood", &f)?;
        } else {
            s.skip_field("summaryCopperResultGood")?;
        }
        if let Some(f) = self.summaryCopperResultBad() {
            s.serialize_field("summaryCopperResultBad", &f)?;
        } else {
            s.skip_field("summaryCopperResultBad")?;
        }
        if let Some(f) = self.summaryCopperResultNormal() {
            s.serialize_field("summaryCopperResultNormal", &f)?;
        } else {
            s.skip_field("summaryCopperResultNormal")?;
        }
        if let Some(f) = self.summaryCopperCheckSuccess() {
            s.serialize_field("summaryCopperCheckSuccess", &f)?;
        } else {
            s.skip_field("summaryCopperCheckSuccess")?;
        }
        if let Some(f) = self.summaryCopperCheckFail() {
            s.serialize_field("summaryCopperCheckFail", &f)?;
        } else {
            s.skip_field("summaryCopperCheckFail")?;
        }
        if let Some(f) = self.summaryCopperCheckNormal() {
            s.serialize_field("summaryCopperCheckNormal", &f)?;
        } else {
            s.skip_field("summaryCopperCheckNormal")?;
        }
        if let Some(f) = self.summaryMeetWrath() {
            s.serialize_field("summaryMeetWrath", &f)?;
        } else {
            s.skip_field("summaryMeetWrath")?;
        }
        if let Some(f) = self.summaryExpeditionGoEndingFour() {
            s.serialize_field("summaryExpeditionGoEndingFour", &f)?;
        } else {
            s.skip_field("summaryExpeditionGoEndingFour")?;
        }
        if let Some(f) = self.summaryExpeditionBackEndingFour() {
            s.serialize_field("summaryExpeditionBackEndingFour", &f)?;
        } else {
            s.skip_field("summaryExpeditionBackEndingFour")?;
        }
        if let Some(f) = self.summaryExpeditionBackCandle() {
            s.serialize_field("summaryExpeditionBackCandle", &f)?;
        } else {
            s.skip_field("summaryExpeditionBackCandle")?;
        }
        if let Some(f) = self.summaryExpeditionGoEnding() {
            s.serialize_field("summaryExpeditionGoEnding", &f)?;
        } else {
            s.skip_field("summaryExpeditionGoEnding")?;
        }
        if let Some(f) = self.summaryExpeditionBackEnding() {
            s.serialize_field("summaryExpeditionBackEnding", &f)?;
        } else {
            s.skip_field("summaryExpeditionBackEnding")?;
        }
        if let Some(f) = self.summaryHoldCandle() {
            s.serialize_field("summaryHoldCandle", &f)?;
        } else {
            s.skip_field("summaryHoldCandle")?;
        }
        if let Some(f) = self.summaryHoldCandleRecruit() {
            s.serialize_field("summaryHoldCandleRecruit", &f)?;
        } else {
            s.skip_field("summaryHoldCandleRecruit")?;
        }
        if let Some(f) = self.summaryHoldCandleUpgrade() {
            s.serialize_field("summaryHoldCandleUpgrade", &f)?;
        } else {
            s.skip_field("summaryHoldCandleUpgrade")?;
        }
        if let Some(f) = self.summaryExchangeSpZoneGet() {
            s.serialize_field("summaryExchangeSpZoneGet", &f)?;
        } else {
            s.skip_field("summaryExchangeSpZoneGet")?;
        }
        if let Some(f) = self.summaryMeetShopSpZone() {
            s.serialize_field("summaryMeetShopSpZone", &f)?;
        } else {
            s.skip_field("summaryMeetShopSpZone")?;
        }
        if let Some(f) = self.summaryBattleFailSpZone() {
            s.serialize_field("summaryBattleFailSpZone", &f)?;
        } else {
            s.skip_field("summaryBattleFailSpZone")?;
        }
        if let Some(f) = self.summaryMeetEventLock() {
            s.serialize_field("summaryMeetEventLock", &f)?;
        } else {
            s.skip_field("summaryMeetEventLock")?;
        }
        if let Some(f) = self.summaryTreasureSpZone() {
            s.serialize_field("summaryTreasureSpZone", &f)?;
        } else {
            s.skip_field("summaryTreasureSpZone")?;
        }
        if let Some(f) = self.summaryMeetExchangeSpZone() {
            s.serialize_field("summaryMeetExchangeSpZone", &f)?;
        } else {
            s.skip_field("summaryMeetExchangeSpZone")?;
        }
        if let Some(f) = self.summaryMeetTradeSpZone() {
            s.serialize_field("summaryMeetTradeSpZone", &f)?;
        } else {
            s.skip_field("summaryMeetTradeSpZone")?;
        }
        if let Some(f) = self.summaryActor() {
            s.serialize_field("summaryActor", &f)?;
        } else {
            s.skip_field("summaryActor")?;
        }
        if let Some(f) = self.summaryTop() {
            s.serialize_field("summaryTop", &f)?;
        } else {
            s.skip_field("summaryTop")?;
        }
        if let Some(f) = self.summaryZone() {
            s.serialize_field("summaryZone", &f)?;
        } else {
            s.skip_field("summaryZone")?;
        }
        if let Some(f) = self.summaryEnding() {
            s.serialize_field("summaryEnding", &f)?;
        } else {
            s.skip_field("summaryEnding")?;
        }
        if let Some(f) = self.summaryDifficultyZone() {
            s.serialize_field("summaryDifficultyZone", &f)?;
        } else {
            s.skip_field("summaryDifficultyZone")?;
        }
        if let Some(f) = self.summaryDifficultyEnding() {
            s.serialize_field("summaryDifficultyEnding", &f)?;
        } else {
            s.skip_field("summaryDifficultyEnding")?;
        }
        if let Some(f) = self.summaryMode() {
            s.serialize_field("summaryMode", &f)?;
        } else {
            s.skip_field("summaryMode")?;
        }
        if let Some(f) = self.summarySupport() {
            s.serialize_field("summarySupport", &f)?;
        } else {
            s.skip_field("summarySupport")?;
        }
        if let Some(f) = self.summaryGroup() {
            s.serialize_field("summaryGroup", &f)?;
        } else {
            s.skip_field("summaryGroup")?;
        }
        if let Some(f) = self.summaryNormalRecruit() {
            s.serialize_field("summaryNormalRecruit", &f)?;
        } else {
            s.skip_field("summaryNormalRecruit")?;
        }
        if let Some(f) = self.summaryDirectRecruit() {
            s.serialize_field("summaryDirectRecruit", &f)?;
        } else {
            s.skip_field("summaryDirectRecruit")?;
        }
        if let Some(f) = self.summaryFriendRecruit() {
            s.serialize_field("summaryFriendRecruit", &f)?;
        } else {
            s.skip_field("summaryFriendRecruit")?;
        }
        if let Some(f) = self.summaryFreeRecruit() {
            s.serialize_field("summaryFreeRecruit", &f)?;
        } else {
            s.skip_field("summaryFreeRecruit")?;
        }
        if let Some(f) = self.summaryMonthRecruit() {
            s.serialize_field("summaryMonthRecruit", &f)?;
        } else {
            s.skip_field("summaryMonthRecruit")?;
        }
        if let Some(f) = self.summaryUpgrade() {
            s.serialize_field("summaryUpgrade", &f)?;
        } else {
            s.skip_field("summaryUpgrade")?;
        }
        if let Some(f) = self.summaryCompleteEnding() {
            s.serialize_field("summaryCompleteEnding", &f)?;
        } else {
            s.skip_field("summaryCompleteEnding")?;
        }
        if let Some(f) = self.summaryEachZone() {
            s.serialize_field("summaryEachZone", &f)?;
        } else {
            s.skip_field("summaryEachZone")?;
        }
        if let Some(f) = self.summaryMeetSpZone() {
            s.serialize_field("summaryMeetSpZone", &f)?;
        } else {
            s.skip_field("summaryMeetSpZone")?;
        }
        if let Some(f) = self.summaryPerfectBattle() {
            s.serialize_field("summaryPerfectBattle", &f)?;
        } else {
            s.skip_field("summaryPerfectBattle")?;
        }
        if let Some(f) = self.summaryMeetBattle() {
            s.serialize_field("summaryMeetBattle", &f)?;
        } else {
            s.skip_field("summaryMeetBattle")?;
        }
        if let Some(f) = self.summaryMeetEvent() {
            s.serialize_field("summaryMeetEvent", &f)?;
        } else {
            s.skip_field("summaryMeetEvent")?;
        }
        if let Some(f) = self.summaryMeetShop() {
            s.serialize_field("summaryMeetShop", &f)?;
        } else {
            s.skip_field("summaryMeetShop")?;
        }
        if let Some(f) = self.summaryMeetTreasure() {
            s.serialize_field("summaryMeetTreasure", &f)?;
        } else {
            s.skip_field("summaryMeetTreasure")?;
        }
        if let Some(f) = self.summaryMeetSecretpath() {
            s.serialize_field("summaryMeetSecretpath", &f)?;
        } else {
            s.skip_field("summaryMeetSecretpath")?;
        }
        if let Some(f) = self.summaryExchangeRelic() {
            s.serialize_field("summaryExchangeRelic", &f)?;
        } else {
            s.skip_field("summaryExchangeRelic")?;
        }
        if let Some(f) = self.summaryMeetTrade() {
            s.serialize_field("summaryMeetTrade", &f)?;
        } else {
            s.skip_field("summaryMeetTrade")?;
        }
        if let Some(f) = self.summaryBuy() {
            s.serialize_field("summaryBuy", &f)?;
        } else {
            s.skip_field("summaryBuy")?;
        }
        if let Some(f) = self.summaryBuyWithPriceId() {
            s.serialize_field("summaryBuyWithPriceId", &f)?;
        } else {
            s.skip_field("summaryBuyWithPriceId")?;
        }
        if let Some(f) = self.summaryInvest() {
            s.serialize_field("summaryInvest", &f)?;
        } else {
            s.skip_field("summaryInvest")?;
        }
        if let Some(f) = self.summaryGet() {
            s.serialize_field("summaryGet", &f)?;
        } else {
            s.skip_field("summaryGet")?;
        }
        if let Some(f) = self.summaryRelic() {
            s.serialize_field("summaryRelic", &f)?;
        } else {
            s.skip_field("summaryRelic")?;
        }
        if let Some(f) = self.summarySafeHouse() {
            s.serialize_field("summarySafeHouse", &f)?;
        } else {
            s.skip_field("summarySafeHouse")?;
        }
        if let Some(f) = self.summaryFailEnd() {
            s.serialize_field("summaryFailEnd", &f)?;
        } else {
            s.skip_field("summaryFailEnd")?;
        }
        if let Some(f) = self.summaryStockRecruitTicket() {
            s.serialize_field("summaryStockRecruitTicket", &f)?;
        } else {
            s.skip_field("summaryStockRecruitTicket")?;
        }
        if let Some(f) = self.summaryDuelWin() {
            s.serialize_field("summaryDuelWin", &f)?;
        } else {
            s.skip_field("summaryDuelWin")?;
        }
        if let Some(f) = self.summaryDuelTie() {
            s.serialize_field("summaryDuelTie", &f)?;
        } else {
            s.skip_field("summaryDuelTie")?;
        }
        if let Some(f) = self.summaryDuelLose() {
            s.serialize_field("summaryDuelLose", &f)?;
        } else {
            s.skip_field("summaryDuelLose")?;
        }
        if let Some(f) = self.summaryExpeditionGo() {
            s.serialize_field("summaryExpeditionGo", &f)?;
        } else {
            s.skip_field("summaryExpeditionGo")?;
        }
        if let Some(f) = self.summaryExpeditionBack() {
            s.serialize_field("summaryExpeditionBack", &f)?;
        } else {
            s.skip_field("summaryExpeditionBack")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL05EndingTextBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL05EndingTextBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_summaryGetCopper(&mut self, summaryGetCopper: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYGETCOPPER,
            summaryGetCopper,
        );
    }
    #[inline]
    pub fn add_summaryLostCopper(&mut self, summaryLostCopper: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYLOSTCOPPER,
            summaryLostCopper,
        );
    }
    #[inline]
    pub fn add_summaryDrawCopper(&mut self, summaryDrawCopper: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYDRAWCOPPER,
            summaryDrawCopper,
        );
    }
    #[inline]
    pub fn add_summaryCopperResultGood(
        &mut self,
        summaryCopperResultGood: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYCOPPERRESULTGOOD,
            summaryCopperResultGood,
        );
    }
    #[inline]
    pub fn add_summaryCopperResultBad(
        &mut self,
        summaryCopperResultBad: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYCOPPERRESULTBAD,
            summaryCopperResultBad,
        );
    }
    #[inline]
    pub fn add_summaryCopperResultNormal(
        &mut self,
        summaryCopperResultNormal: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYCOPPERRESULTNORMAL,
            summaryCopperResultNormal,
        );
    }
    #[inline]
    pub fn add_summaryCopperCheckSuccess(
        &mut self,
        summaryCopperCheckSuccess: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYCOPPERCHECKSUCCESS,
            summaryCopperCheckSuccess,
        );
    }
    #[inline]
    pub fn add_summaryCopperCheckFail(
        &mut self,
        summaryCopperCheckFail: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYCOPPERCHECKFAIL,
            summaryCopperCheckFail,
        );
    }
    #[inline]
    pub fn add_summaryCopperCheckNormal(
        &mut self,
        summaryCopperCheckNormal: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYCOPPERCHECKNORMAL,
            summaryCopperCheckNormal,
        );
    }
    #[inline]
    pub fn add_summaryMeetWrath(&mut self, summaryMeetWrath: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYMEETWRATH,
            summaryMeetWrath,
        );
    }
    #[inline]
    pub fn add_summaryExpeditionGoEndingFour(
        &mut self,
        summaryExpeditionGoEndingFour: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYEXPEDITIONGOENDINGFOUR,
            summaryExpeditionGoEndingFour,
        );
    }
    #[inline]
    pub fn add_summaryExpeditionBackEndingFour(
        &mut self,
        summaryExpeditionBackEndingFour: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYEXPEDITIONBACKENDINGFOUR,
            summaryExpeditionBackEndingFour,
        );
    }
    #[inline]
    pub fn add_summaryExpeditionBackCandle(
        &mut self,
        summaryExpeditionBackCandle: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYEXPEDITIONBACKCANDLE,
            summaryExpeditionBackCandle,
        );
    }
    #[inline]
    pub fn add_summaryExpeditionGoEnding(
        &mut self,
        summaryExpeditionGoEnding: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYEXPEDITIONGOENDING,
            summaryExpeditionGoEnding,
        );
    }
    #[inline]
    pub fn add_summaryExpeditionBackEnding(
        &mut self,
        summaryExpeditionBackEnding: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYEXPEDITIONBACKENDING,
            summaryExpeditionBackEnding,
        );
    }
    #[inline]
    pub fn add_summaryHoldCandle(&mut self, summaryHoldCandle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYHOLDCANDLE,
            summaryHoldCandle,
        );
    }
    #[inline]
    pub fn add_summaryHoldCandleRecruit(
        &mut self,
        summaryHoldCandleRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYHOLDCANDLERECRUIT,
            summaryHoldCandleRecruit,
        );
    }
    #[inline]
    pub fn add_summaryHoldCandleUpgrade(
        &mut self,
        summaryHoldCandleUpgrade: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYHOLDCANDLEUPGRADE,
            summaryHoldCandleUpgrade,
        );
    }
    #[inline]
    pub fn add_summaryExchangeSpZoneGet(
        &mut self,
        summaryExchangeSpZoneGet: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYEXCHANGESPZONEGET,
            summaryExchangeSpZoneGet,
        );
    }
    #[inline]
    pub fn add_summaryMeetShopSpZone(
        &mut self,
        summaryMeetShopSpZone: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYMEETSHOPSPZONE,
            summaryMeetShopSpZone,
        );
    }
    #[inline]
    pub fn add_summaryBattleFailSpZone(
        &mut self,
        summaryBattleFailSpZone: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYBATTLEFAILSPZONE,
            summaryBattleFailSpZone,
        );
    }
    #[inline]
    pub fn add_summaryMeetEventLock(
        &mut self,
        summaryMeetEventLock: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYMEETEVENTLOCK,
            summaryMeetEventLock,
        );
    }
    #[inline]
    pub fn add_summaryTreasureSpZone(
        &mut self,
        summaryTreasureSpZone: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYTREASURESPZONE,
            summaryTreasureSpZone,
        );
    }
    #[inline]
    pub fn add_summaryMeetExchangeSpZone(
        &mut self,
        summaryMeetExchangeSpZone: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYMEETEXCHANGESPZONE,
            summaryMeetExchangeSpZone,
        );
    }
    #[inline]
    pub fn add_summaryMeetTradeSpZone(
        &mut self,
        summaryMeetTradeSpZone: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYMEETTRADESPZONE,
            summaryMeetTradeSpZone,
        );
    }
    #[inline]
    pub fn add_summaryActor(&mut self, summaryActor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYACTOR,
            summaryActor,
        );
    }
    #[inline]
    pub fn add_summaryTop(&mut self, summaryTop: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYTOP,
            summaryTop,
        );
    }
    #[inline]
    pub fn add_summaryZone(&mut self, summaryZone: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYZONE,
            summaryZone,
        );
    }
    #[inline]
    pub fn add_summaryEnding(&mut self, summaryEnding: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYENDING,
            summaryEnding,
        );
    }
    #[inline]
    pub fn add_summaryDifficultyZone(
        &mut self,
        summaryDifficultyZone: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYDIFFICULTYZONE,
            summaryDifficultyZone,
        );
    }
    #[inline]
    pub fn add_summaryDifficultyEnding(
        &mut self,
        summaryDifficultyEnding: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYDIFFICULTYENDING,
            summaryDifficultyEnding,
        );
    }
    #[inline]
    pub fn add_summaryMode(&mut self, summaryMode: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYMODE,
            summaryMode,
        );
    }
    #[inline]
    pub fn add_summarySupport(&mut self, summarySupport: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYSUPPORT,
            summarySupport,
        );
    }
    #[inline]
    pub fn add_summaryGroup(&mut self, summaryGroup: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYGROUP,
            summaryGroup,
        );
    }
    #[inline]
    pub fn add_summaryNormalRecruit(
        &mut self,
        summaryNormalRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYNORMALRECRUIT,
            summaryNormalRecruit,
        );
    }
    #[inline]
    pub fn add_summaryDirectRecruit(
        &mut self,
        summaryDirectRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYDIRECTRECRUIT,
            summaryDirectRecruit,
        );
    }
    #[inline]
    pub fn add_summaryFriendRecruit(
        &mut self,
        summaryFriendRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYFRIENDRECRUIT,
            summaryFriendRecruit,
        );
    }
    #[inline]
    pub fn add_summaryFreeRecruit(&mut self, summaryFreeRecruit: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYFREERECRUIT,
            summaryFreeRecruit,
        );
    }
    #[inline]
    pub fn add_summaryMonthRecruit(
        &mut self,
        summaryMonthRecruit: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYMONTHRECRUIT,
            summaryMonthRecruit,
        );
    }
    #[inline]
    pub fn add_summaryUpgrade(&mut self, summaryUpgrade: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYUPGRADE,
            summaryUpgrade,
        );
    }
    #[inline]
    pub fn add_summaryCompleteEnding(
        &mut self,
        summaryCompleteEnding: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYCOMPLETEENDING,
            summaryCompleteEnding,
        );
    }
    #[inline]
    pub fn add_summaryEachZone(&mut self, summaryEachZone: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYEACHZONE,
            summaryEachZone,
        );
    }
    #[inline]
    pub fn add_summaryMeetSpZone(&mut self, summaryMeetSpZone: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYMEETSPZONE,
            summaryMeetSpZone,
        );
    }
    #[inline]
    pub fn add_summaryPerfectBattle(
        &mut self,
        summaryPerfectBattle: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYPERFECTBATTLE,
            summaryPerfectBattle,
        );
    }
    #[inline]
    pub fn add_summaryMeetBattle(&mut self, summaryMeetBattle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYMEETBATTLE,
            summaryMeetBattle,
        );
    }
    #[inline]
    pub fn add_summaryMeetEvent(&mut self, summaryMeetEvent: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYMEETEVENT,
            summaryMeetEvent,
        );
    }
    #[inline]
    pub fn add_summaryMeetShop(&mut self, summaryMeetShop: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYMEETSHOP,
            summaryMeetShop,
        );
    }
    #[inline]
    pub fn add_summaryMeetTreasure(
        &mut self,
        summaryMeetTreasure: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYMEETTREASURE,
            summaryMeetTreasure,
        );
    }
    #[inline]
    pub fn add_summaryMeetSecretpath(
        &mut self,
        summaryMeetSecretpath: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYMEETSECRETPATH,
            summaryMeetSecretpath,
        );
    }
    #[inline]
    pub fn add_summaryExchangeRelic(
        &mut self,
        summaryExchangeRelic: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYEXCHANGERELIC,
            summaryExchangeRelic,
        );
    }
    #[inline]
    pub fn add_summaryMeetTrade(&mut self, summaryMeetTrade: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYMEETTRADE,
            summaryMeetTrade,
        );
    }
    #[inline]
    pub fn add_summaryBuy(&mut self, summaryBuy: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYBUY,
            summaryBuy,
        );
    }
    #[inline]
    pub fn add_summaryBuyWithPriceId(
        &mut self,
        summaryBuyWithPriceId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYBUYWITHPRICEID,
            summaryBuyWithPriceId,
        );
    }
    #[inline]
    pub fn add_summaryInvest(&mut self, summaryInvest: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYINVEST,
            summaryInvest,
        );
    }
    #[inline]
    pub fn add_summaryGet(&mut self, summaryGet: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYGET,
            summaryGet,
        );
    }
    #[inline]
    pub fn add_summaryRelic(&mut self, summaryRelic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYRELIC,
            summaryRelic,
        );
    }
    #[inline]
    pub fn add_summarySafeHouse(&mut self, summarySafeHouse: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYSAFEHOUSE,
            summarySafeHouse,
        );
    }
    #[inline]
    pub fn add_summaryFailEnd(&mut self, summaryFailEnd: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYFAILEND,
            summaryFailEnd,
        );
    }
    #[inline]
    pub fn add_summaryStockRecruitTicket(
        &mut self,
        summaryStockRecruitTicket: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYSTOCKRECRUITTICKET,
            summaryStockRecruitTicket,
        );
    }
    #[inline]
    pub fn add_summaryDuelWin(&mut self, summaryDuelWin: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYDUELWIN,
            summaryDuelWin,
        );
    }
    #[inline]
    pub fn add_summaryDuelTie(&mut self, summaryDuelTie: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYDUELTIE,
            summaryDuelTie,
        );
    }
    #[inline]
    pub fn add_summaryDuelLose(&mut self, summaryDuelLose: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYDUELLOSE,
            summaryDuelLose,
        );
    }
    #[inline]
    pub fn add_summaryExpeditionGo(
        &mut self,
        summaryExpeditionGo: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYEXPEDITIONGO,
            summaryExpeditionGo,
        );
    }
    #[inline]
    pub fn add_summaryExpeditionBack(
        &mut self,
        summaryExpeditionBack: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05EndingText::VT_SUMMARYEXPEDITIONBACK,
            summaryExpeditionBack,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL05EndingTextBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL05EndingTextBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL05EndingText<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL05EndingText<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL05EndingText");
        ds.field("summaryGetCopper", &self.summaryGetCopper());
        ds.field("summaryLostCopper", &self.summaryLostCopper());
        ds.field("summaryDrawCopper", &self.summaryDrawCopper());
        ds.field("summaryCopperResultGood", &self.summaryCopperResultGood());
        ds.field("summaryCopperResultBad", &self.summaryCopperResultBad());
        ds.field(
            "summaryCopperResultNormal",
            &self.summaryCopperResultNormal(),
        );
        ds.field(
            "summaryCopperCheckSuccess",
            &self.summaryCopperCheckSuccess(),
        );
        ds.field("summaryCopperCheckFail", &self.summaryCopperCheckFail());
        ds.field("summaryCopperCheckNormal", &self.summaryCopperCheckNormal());
        ds.field("summaryMeetWrath", &self.summaryMeetWrath());
        ds.field(
            "summaryExpeditionGoEndingFour",
            &self.summaryExpeditionGoEndingFour(),
        );
        ds.field(
            "summaryExpeditionBackEndingFour",
            &self.summaryExpeditionBackEndingFour(),
        );
        ds.field(
            "summaryExpeditionBackCandle",
            &self.summaryExpeditionBackCandle(),
        );
        ds.field(
            "summaryExpeditionGoEnding",
            &self.summaryExpeditionGoEnding(),
        );
        ds.field(
            "summaryExpeditionBackEnding",
            &self.summaryExpeditionBackEnding(),
        );
        ds.field("summaryHoldCandle", &self.summaryHoldCandle());
        ds.field("summaryHoldCandleRecruit", &self.summaryHoldCandleRecruit());
        ds.field("summaryHoldCandleUpgrade", &self.summaryHoldCandleUpgrade());
        ds.field("summaryExchangeSpZoneGet", &self.summaryExchangeSpZoneGet());
        ds.field("summaryMeetShopSpZone", &self.summaryMeetShopSpZone());
        ds.field("summaryBattleFailSpZone", &self.summaryBattleFailSpZone());
        ds.field("summaryMeetEventLock", &self.summaryMeetEventLock());
        ds.field("summaryTreasureSpZone", &self.summaryTreasureSpZone());
        ds.field(
            "summaryMeetExchangeSpZone",
            &self.summaryMeetExchangeSpZone(),
        );
        ds.field("summaryMeetTradeSpZone", &self.summaryMeetTradeSpZone());
        ds.field("summaryActor", &self.summaryActor());
        ds.field("summaryTop", &self.summaryTop());
        ds.field("summaryZone", &self.summaryZone());
        ds.field("summaryEnding", &self.summaryEnding());
        ds.field("summaryDifficultyZone", &self.summaryDifficultyZone());
        ds.field("summaryDifficultyEnding", &self.summaryDifficultyEnding());
        ds.field("summaryMode", &self.summaryMode());
        ds.field("summarySupport", &self.summarySupport());
        ds.field("summaryGroup", &self.summaryGroup());
        ds.field("summaryNormalRecruit", &self.summaryNormalRecruit());
        ds.field("summaryDirectRecruit", &self.summaryDirectRecruit());
        ds.field("summaryFriendRecruit", &self.summaryFriendRecruit());
        ds.field("summaryFreeRecruit", &self.summaryFreeRecruit());
        ds.field("summaryMonthRecruit", &self.summaryMonthRecruit());
        ds.field("summaryUpgrade", &self.summaryUpgrade());
        ds.field("summaryCompleteEnding", &self.summaryCompleteEnding());
        ds.field("summaryEachZone", &self.summaryEachZone());
        ds.field("summaryMeetSpZone", &self.summaryMeetSpZone());
        ds.field("summaryPerfectBattle", &self.summaryPerfectBattle());
        ds.field("summaryMeetBattle", &self.summaryMeetBattle());
        ds.field("summaryMeetEvent", &self.summaryMeetEvent());
        ds.field("summaryMeetShop", &self.summaryMeetShop());
        ds.field("summaryMeetTreasure", &self.summaryMeetTreasure());
        ds.field("summaryMeetSecretpath", &self.summaryMeetSecretpath());
        ds.field("summaryExchangeRelic", &self.summaryExchangeRelic());
        ds.field("summaryMeetTrade", &self.summaryMeetTrade());
        ds.field("summaryBuy", &self.summaryBuy());
        ds.field("summaryBuyWithPriceId", &self.summaryBuyWithPriceId());
        ds.field("summaryInvest", &self.summaryInvest());
        ds.field("summaryGet", &self.summaryGet());
        ds.field("summaryRelic", &self.summaryRelic());
        ds.field("summarySafeHouse", &self.summarySafeHouse());
        ds.field("summaryFailEnd", &self.summaryFailEnd());
        ds.field(
            "summaryStockRecruitTicket",
            &self.summaryStockRecruitTicket(),
        );
        ds.field("summaryDuelWin", &self.summaryDuelWin());
        ds.field("summaryDuelTie", &self.summaryDuelTie());
        ds.field("summaryDuelLose", &self.summaryDuelLose());
        ds.field("summaryExpeditionGo", &self.summaryExpeditionGo());
        ds.field("summaryExpeditionBack", &self.summaryExpeditionBack());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL05EndingTextT {
    pub summaryGetCopper: Option<String>,
    pub summaryLostCopper: Option<String>,
    pub summaryDrawCopper: Option<String>,
    pub summaryCopperResultGood: Option<String>,
    pub summaryCopperResultBad: Option<String>,
    pub summaryCopperResultNormal: Option<String>,
    pub summaryCopperCheckSuccess: Option<String>,
    pub summaryCopperCheckFail: Option<String>,
    pub summaryCopperCheckNormal: Option<String>,
    pub summaryMeetWrath: Option<String>,
    pub summaryExpeditionGoEndingFour: Option<String>,
    pub summaryExpeditionBackEndingFour: Option<String>,
    pub summaryExpeditionBackCandle: Option<String>,
    pub summaryExpeditionGoEnding: Option<String>,
    pub summaryExpeditionBackEnding: Option<String>,
    pub summaryHoldCandle: Option<String>,
    pub summaryHoldCandleRecruit: Option<String>,
    pub summaryHoldCandleUpgrade: Option<String>,
    pub summaryExchangeSpZoneGet: Option<String>,
    pub summaryMeetShopSpZone: Option<String>,
    pub summaryBattleFailSpZone: Option<String>,
    pub summaryMeetEventLock: Option<String>,
    pub summaryTreasureSpZone: Option<String>,
    pub summaryMeetExchangeSpZone: Option<String>,
    pub summaryMeetTradeSpZone: Option<String>,
    pub summaryActor: Option<String>,
    pub summaryTop: Option<String>,
    pub summaryZone: Option<String>,
    pub summaryEnding: Option<String>,
    pub summaryDifficultyZone: Option<String>,
    pub summaryDifficultyEnding: Option<String>,
    pub summaryMode: Option<String>,
    pub summarySupport: Option<String>,
    pub summaryGroup: Option<String>,
    pub summaryNormalRecruit: Option<String>,
    pub summaryDirectRecruit: Option<String>,
    pub summaryFriendRecruit: Option<String>,
    pub summaryFreeRecruit: Option<String>,
    pub summaryMonthRecruit: Option<String>,
    pub summaryUpgrade: Option<String>,
    pub summaryCompleteEnding: Option<String>,
    pub summaryEachZone: Option<String>,
    pub summaryMeetSpZone: Option<String>,
    pub summaryPerfectBattle: Option<String>,
    pub summaryMeetBattle: Option<String>,
    pub summaryMeetEvent: Option<String>,
    pub summaryMeetShop: Option<String>,
    pub summaryMeetTreasure: Option<String>,
    pub summaryMeetSecretpath: Option<String>,
    pub summaryExchangeRelic: Option<String>,
    pub summaryMeetTrade: Option<String>,
    pub summaryBuy: Option<String>,
    pub summaryBuyWithPriceId: Option<String>,
    pub summaryInvest: Option<String>,
    pub summaryGet: Option<String>,
    pub summaryRelic: Option<String>,
    pub summarySafeHouse: Option<String>,
    pub summaryFailEnd: Option<String>,
    pub summaryStockRecruitTicket: Option<String>,
    pub summaryDuelWin: Option<String>,
    pub summaryDuelTie: Option<String>,
    pub summaryDuelLose: Option<String>,
    pub summaryExpeditionGo: Option<String>,
    pub summaryExpeditionBack: Option<String>,
}
impl Default for clz_Torappu_RL05EndingTextT {
    fn default() -> Self {
        Self {
            summaryGetCopper: None,
            summaryLostCopper: None,
            summaryDrawCopper: None,
            summaryCopperResultGood: None,
            summaryCopperResultBad: None,
            summaryCopperResultNormal: None,
            summaryCopperCheckSuccess: None,
            summaryCopperCheckFail: None,
            summaryCopperCheckNormal: None,
            summaryMeetWrath: None,
            summaryExpeditionGoEndingFour: None,
            summaryExpeditionBackEndingFour: None,
            summaryExpeditionBackCandle: None,
            summaryExpeditionGoEnding: None,
            summaryExpeditionBackEnding: None,
            summaryHoldCandle: None,
            summaryHoldCandleRecruit: None,
            summaryHoldCandleUpgrade: None,
            summaryExchangeSpZoneGet: None,
            summaryMeetShopSpZone: None,
            summaryBattleFailSpZone: None,
            summaryMeetEventLock: None,
            summaryTreasureSpZone: None,
            summaryMeetExchangeSpZone: None,
            summaryMeetTradeSpZone: None,
            summaryActor: None,
            summaryTop: None,
            summaryZone: None,
            summaryEnding: None,
            summaryDifficultyZone: None,
            summaryDifficultyEnding: None,
            summaryMode: None,
            summarySupport: None,
            summaryGroup: None,
            summaryNormalRecruit: None,
            summaryDirectRecruit: None,
            summaryFriendRecruit: None,
            summaryFreeRecruit: None,
            summaryMonthRecruit: None,
            summaryUpgrade: None,
            summaryCompleteEnding: None,
            summaryEachZone: None,
            summaryMeetSpZone: None,
            summaryPerfectBattle: None,
            summaryMeetBattle: None,
            summaryMeetEvent: None,
            summaryMeetShop: None,
            summaryMeetTreasure: None,
            summaryMeetSecretpath: None,
            summaryExchangeRelic: None,
            summaryMeetTrade: None,
            summaryBuy: None,
            summaryBuyWithPriceId: None,
            summaryInvest: None,
            summaryGet: None,
            summaryRelic: None,
            summarySafeHouse: None,
            summaryFailEnd: None,
            summaryStockRecruitTicket: None,
            summaryDuelWin: None,
            summaryDuelTie: None,
            summaryDuelLose: None,
            summaryExpeditionGo: None,
            summaryExpeditionBack: None,
        }
    }
}
impl clz_Torappu_RL05EndingTextT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL05EndingText<'b>> {
        let summaryGetCopper = self
            .summaryGetCopper
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryLostCopper = self
            .summaryLostCopper
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDrawCopper = self
            .summaryDrawCopper
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryCopperResultGood = self
            .summaryCopperResultGood
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryCopperResultBad = self
            .summaryCopperResultBad
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryCopperResultNormal = self
            .summaryCopperResultNormal
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryCopperCheckSuccess = self
            .summaryCopperCheckSuccess
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryCopperCheckFail = self
            .summaryCopperCheckFail
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryCopperCheckNormal = self
            .summaryCopperCheckNormal
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetWrath = self
            .summaryMeetWrath
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExpeditionGoEndingFour = self
            .summaryExpeditionGoEndingFour
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExpeditionBackEndingFour = self
            .summaryExpeditionBackEndingFour
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExpeditionBackCandle = self
            .summaryExpeditionBackCandle
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExpeditionGoEnding = self
            .summaryExpeditionGoEnding
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExpeditionBackEnding = self
            .summaryExpeditionBackEnding
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryHoldCandle = self
            .summaryHoldCandle
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryHoldCandleRecruit = self
            .summaryHoldCandleRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryHoldCandleUpgrade = self
            .summaryHoldCandleUpgrade
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExchangeSpZoneGet = self
            .summaryExchangeSpZoneGet
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetShopSpZone = self
            .summaryMeetShopSpZone
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryBattleFailSpZone = self
            .summaryBattleFailSpZone
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetEventLock = self
            .summaryMeetEventLock
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryTreasureSpZone = self
            .summaryTreasureSpZone
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetExchangeSpZone = self
            .summaryMeetExchangeSpZone
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetTradeSpZone = self
            .summaryMeetTradeSpZone
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryActor = self.summaryActor.as_ref().map(|x| _fbb.create_string(x));
        let summaryTop = self.summaryTop.as_ref().map(|x| _fbb.create_string(x));
        let summaryZone = self.summaryZone.as_ref().map(|x| _fbb.create_string(x));
        let summaryEnding = self.summaryEnding.as_ref().map(|x| _fbb.create_string(x));
        let summaryDifficultyZone = self
            .summaryDifficultyZone
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDifficultyEnding = self
            .summaryDifficultyEnding
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMode = self.summaryMode.as_ref().map(|x| _fbb.create_string(x));
        let summarySupport = self.summarySupport.as_ref().map(|x| _fbb.create_string(x));
        let summaryGroup = self.summaryGroup.as_ref().map(|x| _fbb.create_string(x));
        let summaryNormalRecruit = self
            .summaryNormalRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDirectRecruit = self
            .summaryDirectRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryFriendRecruit = self
            .summaryFriendRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryFreeRecruit = self
            .summaryFreeRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMonthRecruit = self
            .summaryMonthRecruit
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryUpgrade = self.summaryUpgrade.as_ref().map(|x| _fbb.create_string(x));
        let summaryCompleteEnding = self
            .summaryCompleteEnding
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryEachZone = self.summaryEachZone.as_ref().map(|x| _fbb.create_string(x));
        let summaryMeetSpZone = self
            .summaryMeetSpZone
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryPerfectBattle = self
            .summaryPerfectBattle
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetBattle = self
            .summaryMeetBattle
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetEvent = self
            .summaryMeetEvent
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetShop = self.summaryMeetShop.as_ref().map(|x| _fbb.create_string(x));
        let summaryMeetTreasure = self
            .summaryMeetTreasure
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetSecretpath = self
            .summaryMeetSecretpath
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExchangeRelic = self
            .summaryExchangeRelic
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryMeetTrade = self
            .summaryMeetTrade
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryBuy = self.summaryBuy.as_ref().map(|x| _fbb.create_string(x));
        let summaryBuyWithPriceId = self
            .summaryBuyWithPriceId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryInvest = self.summaryInvest.as_ref().map(|x| _fbb.create_string(x));
        let summaryGet = self.summaryGet.as_ref().map(|x| _fbb.create_string(x));
        let summaryRelic = self.summaryRelic.as_ref().map(|x| _fbb.create_string(x));
        let summarySafeHouse = self
            .summarySafeHouse
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryFailEnd = self.summaryFailEnd.as_ref().map(|x| _fbb.create_string(x));
        let summaryStockRecruitTicket = self
            .summaryStockRecruitTicket
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryDuelWin = self.summaryDuelWin.as_ref().map(|x| _fbb.create_string(x));
        let summaryDuelTie = self.summaryDuelTie.as_ref().map(|x| _fbb.create_string(x));
        let summaryDuelLose = self.summaryDuelLose.as_ref().map(|x| _fbb.create_string(x));
        let summaryExpeditionGo = self
            .summaryExpeditionGo
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let summaryExpeditionBack = self
            .summaryExpeditionBack
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RL05EndingText::create(
            _fbb,
            &clz_Torappu_RL05EndingTextArgs {
                summaryGetCopper,
                summaryLostCopper,
                summaryDrawCopper,
                summaryCopperResultGood,
                summaryCopperResultBad,
                summaryCopperResultNormal,
                summaryCopperCheckSuccess,
                summaryCopperCheckFail,
                summaryCopperCheckNormal,
                summaryMeetWrath,
                summaryExpeditionGoEndingFour,
                summaryExpeditionBackEndingFour,
                summaryExpeditionBackCandle,
                summaryExpeditionGoEnding,
                summaryExpeditionBackEnding,
                summaryHoldCandle,
                summaryHoldCandleRecruit,
                summaryHoldCandleUpgrade,
                summaryExchangeSpZoneGet,
                summaryMeetShopSpZone,
                summaryBattleFailSpZone,
                summaryMeetEventLock,
                summaryTreasureSpZone,
                summaryMeetExchangeSpZone,
                summaryMeetTradeSpZone,
                summaryActor,
                summaryTop,
                summaryZone,
                summaryEnding,
                summaryDifficultyZone,
                summaryDifficultyEnding,
                summaryMode,
                summarySupport,
                summaryGroup,
                summaryNormalRecruit,
                summaryDirectRecruit,
                summaryFriendRecruit,
                summaryFreeRecruit,
                summaryMonthRecruit,
                summaryUpgrade,
                summaryCompleteEnding,
                summaryEachZone,
                summaryMeetSpZone,
                summaryPerfectBattle,
                summaryMeetBattle,
                summaryMeetEvent,
                summaryMeetShop,
                summaryMeetTreasure,
                summaryMeetSecretpath,
                summaryExchangeRelic,
                summaryMeetTrade,
                summaryBuy,
                summaryBuyWithPriceId,
                summaryInvest,
                summaryGet,
                summaryRelic,
                summarySafeHouse,
                summaryFailEnd,
                summaryStockRecruitTicket,
                summaryDuelWin,
                summaryDuelTie,
                summaryDuelLose,
                summaryExpeditionGo,
                summaryExpeditionBack,
            },
        )
    }
}
pub enum clz_Torappu_RL05CustomizeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RL05CustomizeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RL05CustomizeData<'a> {
    type Inner = clz_Torappu_RL05CustomizeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RL05CustomizeData<'a> {
    pub const VT_COMMONDEVELOPMENT: flatbuffers::VOffsetT = 4;
    pub const VT_DIFFICULTIES: flatbuffers::VOffsetT = 6;
    pub const VT_SPECIALSHOPDIALOG: flatbuffers::VOffsetT = 8;
    pub const VT_ENDINGTEXT: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RL05CustomizeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RL05CustomizeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL05CustomizeData<'bldr>> {
        let mut builder = clz_Torappu_RL05CustomizeDataBuilder::new(_fbb);
        if let Some(x) = args.endingText {
            builder.add_endingText(x);
        }
        if let Some(x) = args.specialShopDialog {
            builder.add_specialShopDialog(x);
        }
        if let Some(x) = args.difficulties {
            builder.add_difficulties(x);
        }
        if let Some(x) = args.commonDevelopment {
            builder.add_commonDevelopment(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RL05CustomizeDataT {
        let commonDevelopment = self.commonDevelopment().map(|x| Box::new(x.unpack()));
        let difficulties = self
            .difficulties()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let specialShopDialog = self.specialShopDialog().map(|x| Box::new(x.unpack()));
        let endingText = self.endingText().map(|x| Box::new(x.unpack()));
        clz_Torappu_RL05CustomizeDataT {
            commonDevelopment,
            difficulties,
            specialShopDialog,
            endingText,
        }
    }

    #[inline]
    pub fn commonDevelopment(&self) -> Option<clz_Torappu_RoguelikeCommonDevelopmentData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCommonDevelopmentData>>(
                    clz_Torappu_RL05CustomizeData::VT_COMMONDEVELOPMENT,
                    None,
                )
        }
    }
    #[inline]
    pub fn difficulties(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RL05DifficultyExt<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RL05DifficultyExt>,
                >,
            >>(clz_Torappu_RL05CustomizeData::VT_DIFFICULTIES, None)
        }
    }
    #[inline]
    pub fn specialShopDialog(&self) -> Option<clz_Torappu_RoguelikeGameShopDialogData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameShopDialogData>>(
                    clz_Torappu_RL05CustomizeData::VT_SPECIALSHOPDIALOG,
                    None,
                )
        }
    }
    #[inline]
    pub fn endingText(&self) -> Option<clz_Torappu_RL05EndingText<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RL05EndingText>>(
                    clz_Torappu_RL05CustomizeData::VT_ENDINGTEXT,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RL05CustomizeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeCommonDevelopmentData>>("commonDevelopment", Self::VT_COMMONDEVELOPMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RL05DifficultyExt>>>>("difficulties", Self::VT_DIFFICULTIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeGameShopDialogData>>("specialShopDialog", Self::VT_SPECIALSHOPDIALOG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RL05EndingText>>("endingText", Self::VT_ENDINGTEXT, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RL05CustomizeDataArgs<'a> {
    pub commonDevelopment:
        Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevelopmentData<'a>>>,
    pub difficulties: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL05DifficultyExt<'a>>,
            >,
        >,
    >,
    pub specialShopDialog:
        Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogData<'a>>>,
    pub endingText: Option<flatbuffers::WIPOffset<clz_Torappu_RL05EndingText<'a>>>,
}
impl<'a> Default for clz_Torappu_RL05CustomizeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RL05CustomizeDataArgs {
            commonDevelopment: None,
            difficulties: None,
            specialShopDialog: None,
            endingText: None,
        }
    }
}

impl Serialize for clz_Torappu_RL05CustomizeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RL05CustomizeData", 4)?;
        if let Some(f) = self.commonDevelopment() {
            s.serialize_field("commonDevelopment", &f)?;
        } else {
            s.skip_field("commonDevelopment")?;
        }
        if let Some(f) = self.difficulties() {
            s.serialize_field("difficulties", &f)?;
        } else {
            s.skip_field("difficulties")?;
        }
        if let Some(f) = self.specialShopDialog() {
            s.serialize_field("specialShopDialog", &f)?;
        } else {
            s.skip_field("specialShopDialog")?;
        }
        if let Some(f) = self.endingText() {
            s.serialize_field("endingText", &f)?;
        } else {
            s.skip_field("endingText")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RL05CustomizeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RL05CustomizeDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_commonDevelopment(
        &mut self,
        commonDevelopment: flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevelopmentData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeCommonDevelopmentData>>(
                clz_Torappu_RL05CustomizeData::VT_COMMONDEVELOPMENT,
                commonDevelopment,
            );
    }
    #[inline]
    pub fn add_difficulties(
        &mut self,
        difficulties: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RL05DifficultyExt<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RL05CustomizeData::VT_DIFFICULTIES,
            difficulties,
        );
    }
    #[inline]
    pub fn add_specialShopDialog(
        &mut self,
        specialShopDialog: flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeGameShopDialogData>>(
                clz_Torappu_RL05CustomizeData::VT_SPECIALSHOPDIALOG,
                specialShopDialog,
            );
    }
    #[inline]
    pub fn add_endingText(
        &mut self,
        endingText: flatbuffers::WIPOffset<clz_Torappu_RL05EndingText<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RL05EndingText>>(
                clz_Torappu_RL05CustomizeData::VT_ENDINGTEXT,
                endingText,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RL05CustomizeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RL05CustomizeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RL05CustomizeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RL05CustomizeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RL05CustomizeData");
        ds.field("commonDevelopment", &self.commonDevelopment());
        ds.field("difficulties", &self.difficulties());
        ds.field("specialShopDialog", &self.specialShopDialog());
        ds.field("endingText", &self.endingText());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RL05CustomizeDataT {
    pub commonDevelopment: Option<Box<clz_Torappu_RoguelikeCommonDevelopmentDataT>>,
    pub difficulties: Option<Vec<clz_Torappu_RL05DifficultyExtT>>,
    pub specialShopDialog: Option<Box<clz_Torappu_RoguelikeGameShopDialogDataT>>,
    pub endingText: Option<Box<clz_Torappu_RL05EndingTextT>>,
}
impl Default for clz_Torappu_RL05CustomizeDataT {
    fn default() -> Self {
        Self {
            commonDevelopment: None,
            difficulties: None,
            specialShopDialog: None,
            endingText: None,
        }
    }
}
impl clz_Torappu_RL05CustomizeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RL05CustomizeData<'b>> {
        let commonDevelopment = self.commonDevelopment.as_ref().map(|x| x.pack(_fbb));
        let difficulties = self.difficulties.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let specialShopDialog = self.specialShopDialog.as_ref().map(|x| x.pack(_fbb));
        let endingText = self.endingText.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RL05CustomizeData::create(
            _fbb,
            &clz_Torappu_RL05CustomizeDataArgs {
                commonDevelopment,
                difficulties,
                specialShopDialog,
                endingText,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicCustomizeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicCustomizeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicCustomizeData<'a> {
    type Inner = clz_Torappu_RoguelikeTopicCustomizeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicCustomizeData<'a> {
    pub const VT_ROGUE_1: flatbuffers::VOffsetT = 4;
    pub const VT_ROGUE_2: flatbuffers::VOffsetT = 6;
    pub const VT_ROGUE_3: flatbuffers::VOffsetT = 8;
    pub const VT_ROGUE_4: flatbuffers::VOffsetT = 10;
    pub const VT_ROGUE_5: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicCustomizeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicCustomizeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicCustomizeData<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicCustomizeDataBuilder::new(_fbb);
        if let Some(x) = args.rogue_5 {
            builder.add_rogue_5(x);
        }
        if let Some(x) = args.rogue_4 {
            builder.add_rogue_4(x);
        }
        if let Some(x) = args.rogue_3 {
            builder.add_rogue_3(x);
        }
        if let Some(x) = args.rogue_2 {
            builder.add_rogue_2(x);
        }
        if let Some(x) = args.rogue_1 {
            builder.add_rogue_1(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicCustomizeDataT {
        let rogue_1 = self.rogue_1().map(|x| Box::new(x.unpack()));
        let rogue_2 = self.rogue_2().map(|x| Box::new(x.unpack()));
        let rogue_3 = self.rogue_3().map(|x| Box::new(x.unpack()));
        let rogue_4 = self.rogue_4().map(|x| Box::new(x.unpack()));
        let rogue_5 = self.rogue_5().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeTopicCustomizeDataT {
            rogue_1,
            rogue_2,
            rogue_3,
            rogue_4,
            rogue_5,
        }
    }

    #[inline]
    pub fn rogue_1(&self) -> Option<clz_Torappu_RL01CustomizeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RL01CustomizeData>>(
                    clz_Torappu_RoguelikeTopicCustomizeData::VT_ROGUE_1,
                    None,
                )
        }
    }
    #[inline]
    pub fn rogue_2(&self) -> Option<clz_Torappu_RL02CustomizeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RL02CustomizeData>>(
                    clz_Torappu_RoguelikeTopicCustomizeData::VT_ROGUE_2,
                    None,
                )
        }
    }
    #[inline]
    pub fn rogue_3(&self) -> Option<clz_Torappu_RL03CustomizeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RL03CustomizeData>>(
                    clz_Torappu_RoguelikeTopicCustomizeData::VT_ROGUE_3,
                    None,
                )
        }
    }
    #[inline]
    pub fn rogue_4(&self) -> Option<clz_Torappu_RL04CustomizeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RL04CustomizeData>>(
                    clz_Torappu_RoguelikeTopicCustomizeData::VT_ROGUE_4,
                    None,
                )
        }
    }
    #[inline]
    pub fn rogue_5(&self) -> Option<clz_Torappu_RL05CustomizeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RL05CustomizeData>>(
                    clz_Torappu_RoguelikeTopicCustomizeData::VT_ROGUE_5,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicCustomizeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RL01CustomizeData>>(
                "rogue_1",
                Self::VT_ROGUE_1,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RL02CustomizeData>>(
                "rogue_2",
                Self::VT_ROGUE_2,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RL03CustomizeData>>(
                "rogue_3",
                Self::VT_ROGUE_3,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RL04CustomizeData>>(
                "rogue_4",
                Self::VT_ROGUE_4,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RL05CustomizeData>>(
                "rogue_5",
                Self::VT_ROGUE_5,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicCustomizeDataArgs<'a> {
    pub rogue_1: Option<flatbuffers::WIPOffset<clz_Torappu_RL01CustomizeData<'a>>>,
    pub rogue_2: Option<flatbuffers::WIPOffset<clz_Torappu_RL02CustomizeData<'a>>>,
    pub rogue_3: Option<flatbuffers::WIPOffset<clz_Torappu_RL03CustomizeData<'a>>>,
    pub rogue_4: Option<flatbuffers::WIPOffset<clz_Torappu_RL04CustomizeData<'a>>>,
    pub rogue_5: Option<flatbuffers::WIPOffset<clz_Torappu_RL05CustomizeData<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicCustomizeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicCustomizeDataArgs {
            rogue_1: None,
            rogue_2: None,
            rogue_3: None,
            rogue_4: None,
            rogue_5: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicCustomizeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicCustomizeData", 5)?;
        if let Some(f) = self.rogue_1() {
            s.serialize_field("rogue_1", &f)?;
        } else {
            s.skip_field("rogue_1")?;
        }
        if let Some(f) = self.rogue_2() {
            s.serialize_field("rogue_2", &f)?;
        } else {
            s.skip_field("rogue_2")?;
        }
        if let Some(f) = self.rogue_3() {
            s.serialize_field("rogue_3", &f)?;
        } else {
            s.skip_field("rogue_3")?;
        }
        if let Some(f) = self.rogue_4() {
            s.serialize_field("rogue_4", &f)?;
        } else {
            s.skip_field("rogue_4")?;
        }
        if let Some(f) = self.rogue_5() {
            s.serialize_field("rogue_5", &f)?;
        } else {
            s.skip_field("rogue_5")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicCustomizeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RoguelikeTopicCustomizeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_rogue_1(
        &mut self,
        rogue_1: flatbuffers::WIPOffset<clz_Torappu_RL01CustomizeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RL01CustomizeData>>(
                clz_Torappu_RoguelikeTopicCustomizeData::VT_ROGUE_1,
                rogue_1,
            );
    }
    #[inline]
    pub fn add_rogue_2(
        &mut self,
        rogue_2: flatbuffers::WIPOffset<clz_Torappu_RL02CustomizeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RL02CustomizeData>>(
                clz_Torappu_RoguelikeTopicCustomizeData::VT_ROGUE_2,
                rogue_2,
            );
    }
    #[inline]
    pub fn add_rogue_3(
        &mut self,
        rogue_3: flatbuffers::WIPOffset<clz_Torappu_RL03CustomizeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RL03CustomizeData>>(
                clz_Torappu_RoguelikeTopicCustomizeData::VT_ROGUE_3,
                rogue_3,
            );
    }
    #[inline]
    pub fn add_rogue_4(
        &mut self,
        rogue_4: flatbuffers::WIPOffset<clz_Torappu_RL04CustomizeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RL04CustomizeData>>(
                clz_Torappu_RoguelikeTopicCustomizeData::VT_ROGUE_4,
                rogue_4,
            );
    }
    #[inline]
    pub fn add_rogue_5(
        &mut self,
        rogue_5: flatbuffers::WIPOffset<clz_Torappu_RL05CustomizeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RL05CustomizeData>>(
                clz_Torappu_RoguelikeTopicCustomizeData::VT_ROGUE_5,
                rogue_5,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicCustomizeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicCustomizeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicCustomizeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicCustomizeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicCustomizeData");
        ds.field("rogue_1", &self.rogue_1());
        ds.field("rogue_2", &self.rogue_2());
        ds.field("rogue_3", &self.rogue_3());
        ds.field("rogue_4", &self.rogue_4());
        ds.field("rogue_5", &self.rogue_5());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicCustomizeDataT {
    pub rogue_1: Option<Box<clz_Torappu_RL01CustomizeDataT>>,
    pub rogue_2: Option<Box<clz_Torappu_RL02CustomizeDataT>>,
    pub rogue_3: Option<Box<clz_Torappu_RL03CustomizeDataT>>,
    pub rogue_4: Option<Box<clz_Torappu_RL04CustomizeDataT>>,
    pub rogue_5: Option<Box<clz_Torappu_RL05CustomizeDataT>>,
}
impl Default for clz_Torappu_RoguelikeTopicCustomizeDataT {
    fn default() -> Self {
        Self {
            rogue_1: None,
            rogue_2: None,
            rogue_3: None,
            rogue_4: None,
            rogue_5: None,
        }
    }
}
impl clz_Torappu_RoguelikeTopicCustomizeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicCustomizeData<'b>> {
        let rogue_1 = self.rogue_1.as_ref().map(|x| x.pack(_fbb));
        let rogue_2 = self.rogue_2.as_ref().map(|x| x.pack(_fbb));
        let rogue_3 = self.rogue_3.as_ref().map(|x| x.pack(_fbb));
        let rogue_4 = self.rogue_4.as_ref().map(|x| x.pack(_fbb));
        let rogue_5 = self.rogue_5.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeTopicCustomizeData::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicCustomizeDataArgs {
                rogue_1,
                rogue_2,
                rogue_3,
                rogue_4,
                rogue_5,
            },
        )
    }
}
pub enum clz_Torappu_RoguelikeTopicTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RoguelikeTopicTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RoguelikeTopicTable<'a> {
    type Inner = clz_Torappu_RoguelikeTopicTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RoguelikeTopicTable<'a> {
    pub const VT_TOPICS: flatbuffers::VOffsetT = 4;
    pub const VT_CONSTANT: flatbuffers::VOffsetT = 6;
    pub const VT_DETAILS: flatbuffers::VOffsetT = 8;
    pub const VT_MODULES: flatbuffers::VOffsetT = 10;
    pub const VT_CUSTOMIZEDATA: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RoguelikeTopicTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RoguelikeTopicTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicTable<'bldr>> {
        let mut builder = clz_Torappu_RoguelikeTopicTableBuilder::new(_fbb);
        if let Some(x) = args.customizeData {
            builder.add_customizeData(x);
        }
        if let Some(x) = args.modules {
            builder.add_modules(x);
        }
        if let Some(x) = args.details {
            builder.add_details(x);
        }
        if let Some(x) = args.constant {
            builder.add_constant(x);
        }
        if let Some(x) = args.topics {
            builder.add_topics(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RoguelikeTopicTableT {
        let topics = self
            .topics()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let constant = self.constant().map(|x| Box::new(x.unpack()));
        let details = self
            .details()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let modules = self
            .modules()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let customizeData = self.customizeData().map(|x| Box::new(x.unpack()));
        clz_Torappu_RoguelikeTopicTableT {
            topics,
            constant,
            details,
            modules,
            customizeData,
        }
    }

    #[inline]
    pub fn topics(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicBasicData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicBasicData>,
                >,
            >>(clz_Torappu_RoguelikeTopicTable::VT_TOPICS, None)
        }
    }
    #[inline]
    pub fn constant(&self) -> Option<clz_Torappu_RoguelikeTopicConst<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicConst>>(
                    clz_Torappu_RoguelikeTopicTable::VT_CONSTANT,
                    None,
                )
        }
    }
    #[inline]
    pub fn details(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDetail<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDetail>,
                >,
            >>(clz_Torappu_RoguelikeTopicTable::VT_DETAILS, None)
        }
    }
    #[inline]
    pub fn modules(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeModule<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeModule>,
                >,
            >>(clz_Torappu_RoguelikeTopicTable::VT_MODULES, None)
        }
    }
    #[inline]
    pub fn customizeData(&self) -> Option<clz_Torappu_RoguelikeTopicCustomizeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicCustomizeData>>(
                    clz_Torappu_RoguelikeTopicTable::VT_CUSTOMIZEDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RoguelikeTopicTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicBasicData>,
                >,
            >>("topics", Self::VT_TOPICS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicConst>>(
                "constant",
                Self::VT_CONSTANT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDetail>,
                >,
            >>("details", Self::VT_DETAILS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeModule>,
                >,
            >>("modules", Self::VT_MODULES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RoguelikeTopicCustomizeData>>(
                "customizeData",
                Self::VT_CUSTOMIZEDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RoguelikeTopicTableArgs<'a> {
    pub topics: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicBasicData<'a>>,
            >,
        >,
    >,
    pub constant: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConst<'a>>>,
    pub details: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDetail<'a>>,
            >,
        >,
    >,
    pub modules: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeModule<'a>>,
            >,
        >,
    >,
    pub customizeData: Option<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicCustomizeData<'a>>>,
}
impl<'a> Default for clz_Torappu_RoguelikeTopicTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RoguelikeTopicTableArgs {
            topics: None,
            constant: None,
            details: None,
            modules: None,
            customizeData: None,
        }
    }
}

impl Serialize for clz_Torappu_RoguelikeTopicTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RoguelikeTopicTable", 5)?;
        if let Some(f) = self.topics() {
            s.serialize_field("topics", &f)?;
        } else {
            s.skip_field("topics")?;
        }
        if let Some(f) = self.constant() {
            s.serialize_field("constant", &f)?;
        } else {
            s.skip_field("constant")?;
        }
        if let Some(f) = self.details() {
            s.serialize_field("details", &f)?;
        } else {
            s.skip_field("details")?;
        }
        if let Some(f) = self.modules() {
            s.serialize_field("modules", &f)?;
        } else {
            s.skip_field("modules")?;
        }
        if let Some(f) = self.customizeData() {
            s.serialize_field("customizeData", &f)?;
        } else {
            s.skip_field("customizeData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RoguelikeTopicTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RoguelikeTopicTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_topics(
        &mut self,
        topics: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicBasicData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicTable::VT_TOPICS,
            topics,
        );
    }
    #[inline]
    pub fn add_constant(
        &mut self,
        constant: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConst<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicConst>>(
                clz_Torappu_RoguelikeTopicTable::VT_CONSTANT,
                constant,
            );
    }
    #[inline]
    pub fn add_details(
        &mut self,
        details: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeTopicDetail<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicTable::VT_DETAILS,
            details,
        );
    }
    #[inline]
    pub fn add_modules(
        &mut self,
        modules: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RoguelikeModule<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RoguelikeTopicTable::VT_MODULES,
            modules,
        );
    }
    #[inline]
    pub fn add_customizeData(
        &mut self,
        customizeData: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicCustomizeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicCustomizeData>>(
                clz_Torappu_RoguelikeTopicTable::VT_CUSTOMIZEDATA,
                customizeData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RoguelikeTopicTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RoguelikeTopicTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RoguelikeTopicTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RoguelikeTopicTable");
        ds.field("topics", &self.topics());
        ds.field("constant", &self.constant());
        ds.field("details", &self.details());
        ds.field("modules", &self.modules());
        ds.field("customizeData", &self.customizeData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RoguelikeTopicTableT {
    pub topics: Option<Vec<dict__string__clz_Torappu_RoguelikeTopicBasicDataT>>,
    pub constant: Option<Box<clz_Torappu_RoguelikeTopicConstT>>,
    pub details: Option<Vec<dict__string__clz_Torappu_RoguelikeTopicDetailT>>,
    pub modules: Option<Vec<dict__string__clz_Torappu_RoguelikeModuleT>>,
    pub customizeData: Option<Box<clz_Torappu_RoguelikeTopicCustomizeDataT>>,
}
impl Default for clz_Torappu_RoguelikeTopicTableT {
    fn default() -> Self {
        Self {
            topics: None,
            constant: None,
            details: None,
            modules: None,
            customizeData: None,
        }
    }
}
impl clz_Torappu_RoguelikeTopicTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicTable<'b>> {
        let topics = self.topics.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let constant = self.constant.as_ref().map(|x| x.pack(_fbb));
        let details = self.details.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let modules = self.modules.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let customizeData = self.customizeData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RoguelikeTopicTable::create(
            _fbb,
            &clz_Torappu_RoguelikeTopicTableArgs {
                topics,
                constant,
                details,
                modules,
                customizeData,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_RoguelikeTopicTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_roguelike_topic_table_unchecked`.
pub fn root_as_clz_torappu_roguelike_topic_table(
    buf: &[u8],
) -> Result<clz_Torappu_RoguelikeTopicTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_RoguelikeTopicTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_RoguelikeTopicTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_roguelike_topic_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_roguelike_topic_table(
    buf: &[u8],
) -> Result<clz_Torappu_RoguelikeTopicTable, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_RoguelikeTopicTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_RoguelikeTopicTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_roguelike_topic_table_unchecked`.
pub fn root_as_clz_torappu_roguelike_topic_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_RoguelikeTopicTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_RoguelikeTopicTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_RoguelikeTopicTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_roguelike_topic_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_roguelike_topic_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_RoguelikeTopicTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_RoguelikeTopicTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_RoguelikeTopicTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_RoguelikeTopicTable`.
pub unsafe fn root_as_clz_torappu_roguelike_topic_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_RoguelikeTopicTable {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_RoguelikeTopicTable>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_RoguelikeTopicTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_RoguelikeTopicTable`.
pub unsafe fn size_prefixed_root_as_clz_torappu_roguelike_topic_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_RoguelikeTopicTable {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_RoguelikeTopicTable>(buf) }
}
#[inline]
pub fn finish_clz_torappu_roguelike_topic_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicTable<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_roguelike_topic_table_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_RoguelikeTopicTable<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
