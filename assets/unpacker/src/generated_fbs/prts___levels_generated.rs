// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BATTLE_FUNCTION_DISABLE_MASK: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BATTLE_FUNCTION_DISABLE_MASK: i32 = 262143;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BATTLE_FUNCTION_DISABLE_MASK:
    [enum__Torappu_BattleFunctionDisableMask; 20] = [
    enum__Torappu_BattleFunctionDisableMask::NONE,
    enum__Torappu_BattleFunctionDisableMask::CARD_LIST,
    enum__Torappu_BattleFunctionDisableMask::CHARACTER_MENU,
    enum__Torappu_BattleFunctionDisableMask::CHARACTER_INFO,
    enum__Torappu_BattleFunctionDisableMask::SYSTEM_MENU,
    enum__Torappu_BattleFunctionDisableMask::PAUSE_BUTTON,
    enum__Torappu_BattleFunctionDisableMask::SPEED_SWITCHER_BUTTON,
    enum__Torappu_BattleFunctionDisableMask::BATTLE_STATUS,
    enum__Torappu_BattleFunctionDisableMask::COST_PANEL,
    enum__Torappu_BattleFunctionDisableMask::SLOW_MOTION,
    enum__Torappu_BattleFunctionDisableMask::PAUSE_BUTTON_INTERACT,
    enum__Torappu_BattleFunctionDisableMask::SYSTEM_MENU_INTERACT,
    enum__Torappu_BattleFunctionDisableMask::SPEED_SWITCHER_BUTTON_INTERACT,
    enum__Torappu_BattleFunctionDisableMask::UNIT_HUD_SKILL_CAST_MASK,
    enum__Torappu_BattleFunctionDisableMask::WITHDRAWABLE_PANEL,
    enum__Torappu_BattleFunctionDisableMask::COST_PANEL_KEEP_CHARACTERLIMIT,
    enum__Torappu_BattleFunctionDisableMask::CHARACTER_LIMIT,
    enum__Torappu_BattleFunctionDisableMask::AUTOCHESS_SELL_OR_DESTORY,
    enum__Torappu_BattleFunctionDisableMask::CHARACTER_MENU_PANEL,
    enum__Torappu_BattleFunctionDisableMask::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BattleFunctionDisableMask(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BattleFunctionDisableMask {
    pub const NONE: Self = Self(0);
    pub const CARD_LIST: Self = Self(1);
    pub const CHARACTER_MENU: Self = Self(2);
    pub const CHARACTER_INFO: Self = Self(4);
    pub const SYSTEM_MENU: Self = Self(8);
    pub const PAUSE_BUTTON: Self = Self(16);
    pub const SPEED_SWITCHER_BUTTON: Self = Self(32);
    pub const BATTLE_STATUS: Self = Self(64);
    pub const COST_PANEL: Self = Self(128);
    pub const SLOW_MOTION: Self = Self(256);
    pub const PAUSE_BUTTON_INTERACT: Self = Self(512);
    pub const SYSTEM_MENU_INTERACT: Self = Self(1024);
    pub const SPEED_SWITCHER_BUTTON_INTERACT: Self = Self(2048);
    pub const UNIT_HUD_SKILL_CAST_MASK: Self = Self(4096);
    pub const WITHDRAWABLE_PANEL: Self = Self(8192);
    pub const COST_PANEL_KEEP_CHARACTERLIMIT: Self = Self(16384);
    pub const CHARACTER_LIMIT: Self = Self(32768);
    pub const AUTOCHESS_SELL_OR_DESTORY: Self = Self(65536);
    pub const CHARACTER_MENU_PANEL: Self = Self(131072);
    pub const ALL: Self = Self(262143);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 262143;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CARD_LIST,
        Self::CHARACTER_MENU,
        Self::CHARACTER_INFO,
        Self::SYSTEM_MENU,
        Self::PAUSE_BUTTON,
        Self::SPEED_SWITCHER_BUTTON,
        Self::BATTLE_STATUS,
        Self::COST_PANEL,
        Self::SLOW_MOTION,
        Self::PAUSE_BUTTON_INTERACT,
        Self::SYSTEM_MENU_INTERACT,
        Self::SPEED_SWITCHER_BUTTON_INTERACT,
        Self::UNIT_HUD_SKILL_CAST_MASK,
        Self::WITHDRAWABLE_PANEL,
        Self::COST_PANEL_KEEP_CHARACTERLIMIT,
        Self::CHARACTER_LIMIT,
        Self::AUTOCHESS_SELL_OR_DESTORY,
        Self::CHARACTER_MENU_PANEL,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CARD_LIST => Some("CARD_LIST"),
            Self::CHARACTER_MENU => Some("CHARACTER_MENU"),
            Self::CHARACTER_INFO => Some("CHARACTER_INFO"),
            Self::SYSTEM_MENU => Some("SYSTEM_MENU"),
            Self::PAUSE_BUTTON => Some("PAUSE_BUTTON"),
            Self::SPEED_SWITCHER_BUTTON => Some("SPEED_SWITCHER_BUTTON"),
            Self::BATTLE_STATUS => Some("BATTLE_STATUS"),
            Self::COST_PANEL => Some("COST_PANEL"),
            Self::SLOW_MOTION => Some("SLOW_MOTION"),
            Self::PAUSE_BUTTON_INTERACT => Some("PAUSE_BUTTON_INTERACT"),
            Self::SYSTEM_MENU_INTERACT => Some("SYSTEM_MENU_INTERACT"),
            Self::SPEED_SWITCHER_BUTTON_INTERACT => Some("SPEED_SWITCHER_BUTTON_INTERACT"),
            Self::UNIT_HUD_SKILL_CAST_MASK => Some("UNIT_HUD_SKILL_CAST_MASK"),
            Self::WITHDRAWABLE_PANEL => Some("WITHDRAWABLE_PANEL"),
            Self::COST_PANEL_KEEP_CHARACTERLIMIT => Some("COST_PANEL_KEEP_CHARACTERLIMIT"),
            Self::CHARACTER_LIMIT => Some("CHARACTER_LIMIT"),
            Self::AUTOCHESS_SELL_OR_DESTORY => Some("AUTOCHESS_SELL_OR_DESTORY"),
            Self::CHARACTER_MENU_PANEL => Some("CHARACTER_MENU_PANEL"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BattleFunctionDisableMask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_BattleFunctionDisableMask {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_BattleFunctionDisableMask",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BattleFunctionDisableMask {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BattleFunctionDisableMask {
    type Output = enum__Torappu_BattleFunctionDisableMask;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BattleFunctionDisableMask {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BattleFunctionDisableMask {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BattleFunctionDisableMask {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_TILE_DATA_HEIGHT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_TILE_DATA_HEIGHT_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_TILE_DATA_HEIGHT_TYPE: [enum__Torappu_TileData_HeightType; 3] = [
    enum__Torappu_TileData_HeightType::LOWLAND,
    enum__Torappu_TileData_HeightType::HIGHLAND,
    enum__Torappu_TileData_HeightType::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_TileData_HeightType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_TileData_HeightType {
    pub const LOWLAND: Self = Self(0);
    pub const HIGHLAND: Self = Self(1);
    pub const E_NUM: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::LOWLAND, Self::HIGHLAND, Self::E_NUM];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::LOWLAND => Some("LOWLAND"),
            Self::HIGHLAND => Some("HIGHLAND"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_TileData_HeightType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_TileData_HeightType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_TileData_HeightType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_TileData_HeightType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_TileData_HeightType {
    type Output = enum__Torappu_TileData_HeightType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_TileData_HeightType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_TileData_HeightType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_TileData_HeightType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDABLE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDABLE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDABLE_TYPE: [enum__Torappu_BuildableType; 4] = [
    enum__Torappu_BuildableType::NONE,
    enum__Torappu_BuildableType::MELEE,
    enum__Torappu_BuildableType::RANGED,
    enum__Torappu_BuildableType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildableType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildableType {
    pub const NONE: Self = Self(0);
    pub const MELEE: Self = Self(1);
    pub const RANGED: Self = Self(2);
    pub const ALL: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::MELEE, Self::RANGED, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MELEE => Some("MELEE"),
            Self::RANGED => Some("RANGED"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildableType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_BuildableType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_BuildableType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildableType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildableType {
    type Output = enum__Torappu_BuildableType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildableType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildableType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildableType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_MOTION_MASK: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_MOTION_MASK: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_MOTION_MASK: [enum__Torappu_MotionMask; 4] = [
    enum__Torappu_MotionMask::NONE,
    enum__Torappu_MotionMask::WALK_ONLY,
    enum__Torappu_MotionMask::FLY_ONLY,
    enum__Torappu_MotionMask::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_MotionMask(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_MotionMask {
    pub const NONE: Self = Self(0);
    pub const WALK_ONLY: Self = Self(1);
    pub const FLY_ONLY: Self = Self(2);
    pub const ALL: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::WALK_ONLY, Self::FLY_ONLY, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::WALK_ONLY => Some("WALK_ONLY"),
            Self::FLY_ONLY => Some("FLY_ONLY"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_MotionMask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_MotionMask {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_MotionMask",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_MotionMask {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_MotionMask {
    type Output = enum__Torappu_MotionMask;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_MotionMask {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_MotionMask {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_MotionMask {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PLAYER_SIDE_MASK: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PLAYER_SIDE_MASK: u8 = 255;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PLAYER_SIDE_MASK: [enum__Torappu_PlayerSideMask; 4] = [
    enum__Torappu_PlayerSideMask::ALL,
    enum__Torappu_PlayerSideMask::SIDE_A,
    enum__Torappu_PlayerSideMask::SIDE_B,
    enum__Torappu_PlayerSideMask::NONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_PlayerSideMask(pub u8);
#[allow(non_upper_case_globals)]
impl enum__Torappu_PlayerSideMask {
    pub const ALL: Self = Self(0);
    pub const SIDE_A: Self = Self(2);
    pub const SIDE_B: Self = Self(4);
    pub const NONE: Self = Self(255);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 255;
    pub const ENUM_VALUES: &'static [Self] = &[Self::ALL, Self::SIDE_A, Self::SIDE_B, Self::NONE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ALL => Some("ALL"),
            Self::SIDE_A => Some("SIDE_A"),
            Self::SIDE_B => Some("SIDE_B"),
            Self::NONE => Some("NONE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_PlayerSideMask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_PlayerSideMask {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_PlayerSideMask",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_PlayerSideMask {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_PlayerSideMask {
    type Output = enum__Torappu_PlayerSideMask;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_PlayerSideMask {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_PlayerSideMask {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_PlayerSideMask {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SHARED_CONSTS_DIRECTION: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SHARED_CONSTS_DIRECTION: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SHARED_CONSTS_DIRECTION:
    [enum__Torappu_SharedConsts_Direction; 6] = [
    enum__Torappu_SharedConsts_Direction::UP,
    enum__Torappu_SharedConsts_Direction::RIGHT,
    enum__Torappu_SharedConsts_Direction::DOWN,
    enum__Torappu_SharedConsts_Direction::LEFT,
    enum__Torappu_SharedConsts_Direction::E_NUM,
    enum__Torappu_SharedConsts_Direction::INVALID,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SharedConsts_Direction(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SharedConsts_Direction {
    pub const UP: Self = Self(0);
    pub const RIGHT: Self = Self(1);
    pub const DOWN: Self = Self(2);
    pub const LEFT: Self = Self(3);
    pub const E_NUM: Self = Self(4);
    pub const INVALID: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::UP,
        Self::RIGHT,
        Self::DOWN,
        Self::LEFT,
        Self::E_NUM,
        Self::INVALID,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::UP => Some("UP"),
            Self::RIGHT => Some("RIGHT"),
            Self::DOWN => Some("DOWN"),
            Self::LEFT => Some("LEFT"),
            Self::E_NUM => Some("E_NUM"),
            Self::INVALID => Some("INVALID"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SharedConsts_Direction {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SharedConsts_Direction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SharedConsts_Direction",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SharedConsts_Direction {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SharedConsts_Direction {
    type Output = enum__Torappu_SharedConsts_Direction;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SharedConsts_Direction {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SharedConsts_Direction {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SharedConsts_Direction {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: i32 = 15;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: [enum__Torappu_LevelData_Difficulty; 6] = [
    enum__Torappu_LevelData_Difficulty::NONE,
    enum__Torappu_LevelData_Difficulty::NORMAL,
    enum__Torappu_LevelData_Difficulty::FOUR_STAR,
    enum__Torappu_LevelData_Difficulty::EASY,
    enum__Torappu_LevelData_Difficulty::SIX_STAR,
    enum__Torappu_LevelData_Difficulty::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_LevelData_Difficulty(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_LevelData_Difficulty {
    pub const NONE: Self = Self(0);
    pub const NORMAL: Self = Self(1);
    pub const FOUR_STAR: Self = Self(2);
    pub const EASY: Self = Self(4);
    pub const SIX_STAR: Self = Self(8);
    pub const ALL: Self = Self(15);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 15;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::NORMAL,
        Self::FOUR_STAR,
        Self::EASY,
        Self::SIX_STAR,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NORMAL => Some("NORMAL"),
            Self::FOUR_STAR => Some("FOUR_STAR"),
            Self::EASY => Some("EASY"),
            Self::SIX_STAR => Some("SIX_STAR"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_LevelData_Difficulty {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_LevelData_Difficulty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_LevelData_Difficulty",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_LevelData_Difficulty {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_LevelData_Difficulty {
    type Output = enum__Torappu_LevelData_Difficulty;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_LevelData_Difficulty {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_LevelData_Difficulty {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_LevelData_Difficulty {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 512;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PROFESSION_CATEGORY: [enum__Torappu_ProfessionCategory; 11] = [
    enum__Torappu_ProfessionCategory::NONE,
    enum__Torappu_ProfessionCategory::WARRIOR,
    enum__Torappu_ProfessionCategory::SNIPER,
    enum__Torappu_ProfessionCategory::TANK,
    enum__Torappu_ProfessionCategory::MEDIC,
    enum__Torappu_ProfessionCategory::SUPPORT,
    enum__Torappu_ProfessionCategory::CASTER,
    enum__Torappu_ProfessionCategory::SPECIAL,
    enum__Torappu_ProfessionCategory::TOKEN,
    enum__Torappu_ProfessionCategory::TRAP,
    enum__Torappu_ProfessionCategory::PIONEER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ProfessionCategory(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ProfessionCategory {
    pub const NONE: Self = Self(0);
    pub const WARRIOR: Self = Self(1);
    pub const SNIPER: Self = Self(2);
    pub const TANK: Self = Self(4);
    pub const MEDIC: Self = Self(8);
    pub const SUPPORT: Self = Self(16);
    pub const CASTER: Self = Self(32);
    pub const SPECIAL: Self = Self(64);
    pub const TOKEN: Self = Self(128);
    pub const TRAP: Self = Self(256);
    pub const PIONEER: Self = Self(512);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 512;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::WARRIOR,
        Self::SNIPER,
        Self::TANK,
        Self::MEDIC,
        Self::SUPPORT,
        Self::CASTER,
        Self::SPECIAL,
        Self::TOKEN,
        Self::TRAP,
        Self::PIONEER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::WARRIOR => Some("WARRIOR"),
            Self::SNIPER => Some("SNIPER"),
            Self::TANK => Some("TANK"),
            Self::MEDIC => Some("MEDIC"),
            Self::SUPPORT => Some("SUPPORT"),
            Self::CASTER => Some("CASTER"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::TOKEN => Some("TOKEN"),
            Self::TRAP => Some("TRAP"),
            Self::PIONEER => Some("PIONEER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ProfessionCategory {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ProfessionCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ProfessionCategory",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ProfessionCategory {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ProfessionCategory {
    type Output = enum__Torappu_ProfessionCategory;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ProfessionCategory {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ProfessionCategory {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ProfessionCategory {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_MOTION_MODE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_MOTION_MODE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_MOTION_MODE: [enum__Torappu_MotionMode; 3] = [
    enum__Torappu_MotionMode::WALK,
    enum__Torappu_MotionMode::FLY,
    enum__Torappu_MotionMode::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_MotionMode(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_MotionMode {
    pub const WALK: Self = Self(0);
    pub const FLY: Self = Self(1);
    pub const E_NUM: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::WALK, Self::FLY, Self::E_NUM];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::WALK => Some("WALK"),
            Self::FLY => Some("FLY"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_MotionMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_MotionMode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_MotionMode",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_MotionMode {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_MotionMode {
    type Output = enum__Torappu_MotionMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_MotionMode {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_MotionMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_MotionMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_CHECKPOINT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_CHECKPOINT_TYPE: i32 = 11;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_CHECKPOINT_TYPE: [enum__Torappu_CheckpointType; 12] = [
    enum__Torappu_CheckpointType::MOVE,
    enum__Torappu_CheckpointType::WAIT_FOR_SECONDS,
    enum__Torappu_CheckpointType::WAIT_FOR_PLAY_TIME,
    enum__Torappu_CheckpointType::WAIT_CURRENT_FRAGMENT_TIME,
    enum__Torappu_CheckpointType::WAIT_CURRENT_WAVE_TIME,
    enum__Torappu_CheckpointType::DISAPPEAR,
    enum__Torappu_CheckpointType::APPEAR_AT_POS,
    enum__Torappu_CheckpointType::ALERT,
    enum__Torappu_CheckpointType::PATROL_MOVE,
    enum__Torappu_CheckpointType::WAIT_BOSSRUSH_WAVE,
    enum__Torappu_CheckpointType::MAP_OFFSET_MOVE,
    enum__Torappu_CheckpointType::INVALID,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_CheckpointType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_CheckpointType {
    pub const MOVE: Self = Self(0);
    pub const WAIT_FOR_SECONDS: Self = Self(1);
    pub const WAIT_FOR_PLAY_TIME: Self = Self(2);
    pub const WAIT_CURRENT_FRAGMENT_TIME: Self = Self(3);
    pub const WAIT_CURRENT_WAVE_TIME: Self = Self(4);
    pub const DISAPPEAR: Self = Self(5);
    pub const APPEAR_AT_POS: Self = Self(6);
    pub const ALERT: Self = Self(7);
    pub const PATROL_MOVE: Self = Self(8);
    pub const WAIT_BOSSRUSH_WAVE: Self = Self(9);
    pub const MAP_OFFSET_MOVE: Self = Self(10);
    pub const INVALID: Self = Self(11);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 11;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::MOVE,
        Self::WAIT_FOR_SECONDS,
        Self::WAIT_FOR_PLAY_TIME,
        Self::WAIT_CURRENT_FRAGMENT_TIME,
        Self::WAIT_CURRENT_WAVE_TIME,
        Self::DISAPPEAR,
        Self::APPEAR_AT_POS,
        Self::ALERT,
        Self::PATROL_MOVE,
        Self::WAIT_BOSSRUSH_WAVE,
        Self::MAP_OFFSET_MOVE,
        Self::INVALID,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MOVE => Some("MOVE"),
            Self::WAIT_FOR_SECONDS => Some("WAIT_FOR_SECONDS"),
            Self::WAIT_FOR_PLAY_TIME => Some("WAIT_FOR_PLAY_TIME"),
            Self::WAIT_CURRENT_FRAGMENT_TIME => Some("WAIT_CURRENT_FRAGMENT_TIME"),
            Self::WAIT_CURRENT_WAVE_TIME => Some("WAIT_CURRENT_WAVE_TIME"),
            Self::DISAPPEAR => Some("DISAPPEAR"),
            Self::APPEAR_AT_POS => Some("APPEAR_AT_POS"),
            Self::ALERT => Some("ALERT"),
            Self::PATROL_MOVE => Some("PATROL_MOVE"),
            Self::WAIT_BOSSRUSH_WAVE => Some("WAIT_BOSSRUSH_WAVE"),
            Self::MAP_OFFSET_MOVE => Some("MAP_OFFSET_MOVE"),
            Self::INVALID => Some("INVALID"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_CheckpointType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_CheckpointType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_CheckpointType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_CheckpointType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_CheckpointType {
    type Output = enum__Torappu_CheckpointType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_CheckpointType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_CheckpointType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_CheckpointType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SOURCE_APPLY_WAY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SOURCE_APPLY_WAY: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SOURCE_APPLY_WAY: [enum__Torappu_SourceApplyWay; 4] = [
    enum__Torappu_SourceApplyWay::NONE,
    enum__Torappu_SourceApplyWay::MELEE,
    enum__Torappu_SourceApplyWay::RANGED,
    enum__Torappu_SourceApplyWay::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SourceApplyWay(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SourceApplyWay {
    pub const NONE: Self = Self(0);
    pub const MELEE: Self = Self(1);
    pub const RANGED: Self = Self(2);
    pub const ALL: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::MELEE, Self::RANGED, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MELEE => Some("MELEE"),
            Self::RANGED => Some("RANGED"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SourceApplyWay {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SourceApplyWay {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SourceApplyWay",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SourceApplyWay {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SourceApplyWay {
    type Output = enum__Torappu_SourceApplyWay;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SourceApplyWay {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SourceApplyWay {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SourceApplyWay {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ENEMY_LEVEL_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ENEMY_LEVEL_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ENEMY_LEVEL_TYPE: [enum__Torappu_EnemyLevelType; 4] = [
    enum__Torappu_EnemyLevelType::NORMAL,
    enum__Torappu_EnemyLevelType::ELITE,
    enum__Torappu_EnemyLevelType::BOSS,
    enum__Torappu_EnemyLevelType::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EnemyLevelType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EnemyLevelType {
    pub const NORMAL: Self = Self(0);
    pub const ELITE: Self = Self(1);
    pub const BOSS: Self = Self(2);
    pub const E_NUM: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NORMAL, Self::ELITE, Self::BOSS, Self::E_NUM];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::ELITE => Some("ELITE"),
            Self::BOSS => Some("BOSS"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EnemyLevelType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_EnemyLevelType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_EnemyLevelType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EnemyLevelType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EnemyLevelType {
    type Output = enum__Torappu_EnemyLevelType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EnemyLevelType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EnemyLevelType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EnemyLevelType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_SP_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_SP_TYPE: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_SP_TYPE: [enum__Torappu_SpType; 6] = [
    enum__Torappu_SpType::NONE,
    enum__Torappu_SpType::INCREASE_WITH_TIME,
    enum__Torappu_SpType::INCREASE_WHEN_ATTACK,
    enum__Torappu_SpType::INCREASE_WHEN_TAKEN_DAMAGE,
    enum__Torappu_SpType::ATTACK_OR_DAMAGE,
    enum__Torappu_SpType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_SpType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_SpType {
    pub const NONE: Self = Self(0);
    pub const INCREASE_WITH_TIME: Self = Self(1);
    pub const INCREASE_WHEN_ATTACK: Self = Self(2);
    pub const INCREASE_WHEN_TAKEN_DAMAGE: Self = Self(4);
    pub const ATTACK_OR_DAMAGE: Self = Self(6);
    pub const ALL: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::INCREASE_WITH_TIME,
        Self::INCREASE_WHEN_ATTACK,
        Self::INCREASE_WHEN_TAKEN_DAMAGE,
        Self::ATTACK_OR_DAMAGE,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::INCREASE_WITH_TIME => Some("INCREASE_WITH_TIME"),
            Self::INCREASE_WHEN_ATTACK => Some("INCREASE_WHEN_ATTACK"),
            Self::INCREASE_WHEN_TAKEN_DAMAGE => Some("INCREASE_WHEN_TAKEN_DAMAGE"),
            Self::ATTACK_OR_DAMAGE => Some("ATTACK_OR_DAMAGE"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_SpType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_SpType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_SpType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_SpType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_SpType {
    type Output = enum__Torappu_SpType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_SpType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_SpType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_SpType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_LEVEL_DATA_WAVE_DATA_FRAGMENT_DATA_ACTION_DATA_ACTION_TYPE: i32 =
    0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_LEVEL_DATA_WAVE_DATA_FRAGMENT_DATA_ACTION_DATA_ACTION_TYPE: i32 =
    14;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_LEVEL_DATA_WAVE_DATA_FRAGMENT_DATA_ACTION_DATA_ACTION_TYPE:
    [enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType; 15] = [
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::SPAWN,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::PREVIEW_CURSOR,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::STORY,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::TUTORIAL,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::PLAY_BGM,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::DISPLAY_ENEMY_INFO,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::ACTIVATE_PREDEFINED,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::PLAY_OPERA,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::TRIGGER_PREDEFINED,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::BATTLE_EVENTS,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::WITHDRAW_PREDEFINED,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::DIALOG,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::SHOW_ALL_HIDDEN_CARDS,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::EMPTY,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType {
    pub const SPAWN: Self = Self(0);
    pub const PREVIEW_CURSOR: Self = Self(1);
    pub const STORY: Self = Self(2);
    pub const TUTORIAL: Self = Self(3);
    pub const PLAY_BGM: Self = Self(4);
    pub const DISPLAY_ENEMY_INFO: Self = Self(5);
    pub const ACTIVATE_PREDEFINED: Self = Self(6);
    pub const PLAY_OPERA: Self = Self(7);
    pub const TRIGGER_PREDEFINED: Self = Self(8);
    pub const BATTLE_EVENTS: Self = Self(9);
    pub const WITHDRAW_PREDEFINED: Self = Self(10);
    pub const DIALOG: Self = Self(11);
    pub const SHOW_ALL_HIDDEN_CARDS: Self = Self(12);
    pub const EMPTY: Self = Self(13);
    pub const E_NUM: Self = Self(14);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 14;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::SPAWN,
        Self::PREVIEW_CURSOR,
        Self::STORY,
        Self::TUTORIAL,
        Self::PLAY_BGM,
        Self::DISPLAY_ENEMY_INFO,
        Self::ACTIVATE_PREDEFINED,
        Self::PLAY_OPERA,
        Self::TRIGGER_PREDEFINED,
        Self::BATTLE_EVENTS,
        Self::WITHDRAW_PREDEFINED,
        Self::DIALOG,
        Self::SHOW_ALL_HIDDEN_CARDS,
        Self::EMPTY,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::SPAWN => Some("SPAWN"),
            Self::PREVIEW_CURSOR => Some("PREVIEW_CURSOR"),
            Self::STORY => Some("STORY"),
            Self::TUTORIAL => Some("TUTORIAL"),
            Self::PLAY_BGM => Some("PLAY_BGM"),
            Self::DISPLAY_ENEMY_INFO => Some("DISPLAY_ENEMY_INFO"),
            Self::ACTIVATE_PREDEFINED => Some("ACTIVATE_PREDEFINED"),
            Self::PLAY_OPERA => Some("PLAY_OPERA"),
            Self::TRIGGER_PREDEFINED => Some("TRIGGER_PREDEFINED"),
            Self::BATTLE_EVENTS => Some("BATTLE_EVENTS"),
            Self::WITHDRAW_PREDEFINED => Some("WITHDRAW_PREDEFINED"),
            Self::DIALOG => Some("DIALOG"),
            Self::SHOW_ALL_HIDDEN_CARDS => Some("SHOW_ALL_HIDDEN_CARDS"),
            Self::EMPTY => Some("EMPTY"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a>
    for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType
{
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType {
    type Output = enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar
    for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType
{
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable
    for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice
    for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType
{
}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_LEVEL_DATA_WAVE_DATA_FRAGMENT_DATA_ACTION_DATA_RANDOM_TYPE: i32 =
    0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_LEVEL_DATA_WAVE_DATA_FRAGMENT_DATA_ACTION_DATA_RANDOM_TYPE: i32 =
    4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_LEVEL_DATA_WAVE_DATA_FRAGMENT_DATA_ACTION_DATA_RANDOM_TYPE:
    [enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType; 5] = [
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType::ALWAYS,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType::PER_DAY,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType::NEVER,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType::PER_SETTLE_DAY,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType::PER_SEASON,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType {
    pub const ALWAYS: Self = Self(0);
    pub const PER_DAY: Self = Self(1);
    pub const NEVER: Self = Self(2);
    pub const PER_SETTLE_DAY: Self = Self(3);
    pub const PER_SEASON: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::ALWAYS,
        Self::PER_DAY,
        Self::NEVER,
        Self::PER_SETTLE_DAY,
        Self::PER_SEASON,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ALWAYS => Some("ALWAYS"),
            Self::PER_DAY => Some("PER_DAY"),
            Self::NEVER => Some("NEVER"),
            Self::PER_SETTLE_DAY => Some("PER_SETTLE_DAY"),
            Self::PER_SEASON => Some("PER_SEASON"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a>
    for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType
{
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType {
    type Output = enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar
    for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType
{
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable
    for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice
    for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType
{
}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_LEVEL_DATA_WAVE_DATA_FRAGMENT_DATA_ACTION_DATA_REFRESH_TYPE: i32 =
    0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_LEVEL_DATA_WAVE_DATA_FRAGMENT_DATA_ACTION_DATA_REFRESH_TYPE: i32 =
    4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_LEVEL_DATA_WAVE_DATA_FRAGMENT_DATA_ACTION_DATA_REFRESH_TYPE:
    [enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType; 5] = [
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType::ALWAYS,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType::PER_DAY,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType::NEVER,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType::PER_SETTLE_DAY,
    enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType::PER_SEASON,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType {
    pub const ALWAYS: Self = Self(0);
    pub const PER_DAY: Self = Self(1);
    pub const NEVER: Self = Self(2);
    pub const PER_SETTLE_DAY: Self = Self(3);
    pub const PER_SEASON: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::ALWAYS,
        Self::PER_DAY,
        Self::NEVER,
        Self::PER_SETTLE_DAY,
        Self::PER_SEASON,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ALWAYS => Some("ALWAYS"),
            Self::PER_DAY => Some("PER_DAY"),
            Self::NEVER => Some("NEVER"),
            Self::PER_SETTLE_DAY => Some("PER_SETTLE_DAY"),
            Self::PER_SEASON => Some("PER_SEASON"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a>
    for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType
{
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType {
    type Output = enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar
    for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType
{
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable
    for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice
    for enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType
{
}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_EVOLVE_PHASE: [enum__Torappu_EvolvePhase; 5] = [
    enum__Torappu_EvolvePhase::PHASE_0,
    enum__Torappu_EvolvePhase::PHASE_1,
    enum__Torappu_EvolvePhase::PHASE_2,
    enum__Torappu_EvolvePhase::PHASE_3,
    enum__Torappu_EvolvePhase::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EvolvePhase(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EvolvePhase {
    pub const PHASE_0: Self = Self(0);
    pub const PHASE_1: Self = Self(1);
    pub const PHASE_2: Self = Self(2);
    pub const PHASE_3: Self = Self(3);
    pub const E_NUM: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::PHASE_0,
        Self::PHASE_1,
        Self::PHASE_2,
        Self::PHASE_3,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::PHASE_0 => Some("PHASE_0"),
            Self::PHASE_1 => Some("PHASE_1"),
            Self::PHASE_2 => Some("PHASE_2"),
            Self::PHASE_3 => Some("PHASE_3"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EvolvePhase {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_EvolvePhase {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_EvolvePhase",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EvolvePhase {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EvolvePhase {
    type Output = enum__Torappu_EvolvePhase;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EvolvePhase {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EvolvePhase {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EvolvePhase {}
pub enum clz_Torappu_Blackboard_DataPairOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Blackboard_DataPair<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Blackboard_DataPair<'a> {
    type Inner = clz_Torappu_Blackboard_DataPair<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Blackboard_DataPair<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_VALUESTR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Blackboard_DataPair { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Blackboard_DataPairArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'bldr>> {
        let mut builder = clz_Torappu_Blackboard_DataPairBuilder::new(_fbb);
        if let Some(x) = args.valueStr {
            builder.add_valueStr(x);
        }
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Blackboard_DataPairT {
        let key = self.key().map(|x| x.to_string());
        let value = self.value();
        let valueStr = self.valueStr().map(|x| x.to_string());
        clz_Torappu_Blackboard_DataPairT {
            key,
            value,
            valueStr,
        }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn valueStr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Blackboard_DataPair<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "valueStr",
                Self::VT_VALUESTR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Blackboard_DataPairArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f32,
    pub valueStr: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Blackboard_DataPairArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Blackboard_DataPairArgs {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}

impl Serialize for clz_Torappu_Blackboard_DataPair<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Blackboard_DataPair", 3)?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        s.serialize_field("value", &self.value())?;
        if let Some(f) = self.valueStr() {
            s.serialize_field("valueStr", &f)?;
        } else {
            s.skip_field("valueStr")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Blackboard_DataPairBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn add_valueStr(&mut self, valueStr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
            valueStr,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Blackboard_DataPairBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Blackboard_DataPair<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Blackboard_DataPair");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.field("valueStr", &self.valueStr());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Blackboard_DataPairT {
    pub key: Option<String>,
    pub value: f32,
    pub valueStr: Option<String>,
}
impl Default for clz_Torappu_Blackboard_DataPairT {
    fn default() -> Self {
        Self {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}
impl clz_Torappu_Blackboard_DataPairT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let value = self.value;
        let valueStr = self.valueStr.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Blackboard_DataPair::create(
            _fbb,
            &clz_Torappu_Blackboard_DataPairArgs {
                key,
                value,
                valueStr,
            },
        )
    }
}
pub enum clz_Torappu_LevelData_OptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_Options<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_Options<'a> {
    type Inner = clz_Torappu_LevelData_Options<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_Options<'a> {
    pub const VT_CHARACTERLIMIT: flatbuffers::VOffsetT = 4;
    pub const VT_MAXLIFEPOINT: flatbuffers::VOffsetT = 6;
    pub const VT_INITIALCOST: flatbuffers::VOffsetT = 8;
    pub const VT_MAXCOST: flatbuffers::VOffsetT = 10;
    pub const VT_COSTINCREASETIME: flatbuffers::VOffsetT = 12;
    pub const VT_MOVEMULTIPLIER: flatbuffers::VOffsetT = 14;
    pub const VT_STEERINGENABLED: flatbuffers::VOffsetT = 16;
    pub const VT_ISTRAININGLEVEL: flatbuffers::VOffsetT = 18;
    pub const VT_ISHARDTRAININGLEVEL: flatbuffers::VOffsetT = 20;
    pub const VT_ISPREDEFINEDCARDSSELECTABLE: flatbuffers::VOffsetT = 22;
    pub const VT_DISPLAYRESTTIME: flatbuffers::VOffsetT = 24;
    pub const VT_MAXPLAYTIME: flatbuffers::VOffsetT = 26;
    pub const VT_FUNCTIONDISABLEMASK: flatbuffers::VOffsetT = 28;
    pub const VT_CONFIGBLACKBOARD: flatbuffers::VOffsetT = 30;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_Options { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_OptionsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_Options<'bldr>> {
        let mut builder = clz_Torappu_LevelData_OptionsBuilder::new(_fbb);
        if let Some(x) = args.configBlackBoard {
            builder.add_configBlackBoard(x);
        }
        builder.add_functionDisableMask(args.functionDisableMask);
        builder.add_maxPlayTime(args.maxPlayTime);
        builder.add_moveMultiplier(args.moveMultiplier);
        builder.add_costIncreaseTime(args.costIncreaseTime);
        builder.add_maxCost(args.maxCost);
        builder.add_initialCost(args.initialCost);
        builder.add_maxLifePoint(args.maxLifePoint);
        builder.add_characterLimit(args.characterLimit);
        builder.add_displayRestTime(args.displayRestTime);
        builder.add_isPredefinedCardsSelectable(args.isPredefinedCardsSelectable);
        builder.add_isHardTrainingLevel(args.isHardTrainingLevel);
        builder.add_isTrainingLevel(args.isTrainingLevel);
        builder.add_steeringEnabled(args.steeringEnabled);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_OptionsT {
        let characterLimit = self.characterLimit();
        let maxLifePoint = self.maxLifePoint();
        let initialCost = self.initialCost();
        let maxCost = self.maxCost();
        let costIncreaseTime = self.costIncreaseTime();
        let moveMultiplier = self.moveMultiplier();
        let steeringEnabled = self.steeringEnabled();
        let isTrainingLevel = self.isTrainingLevel();
        let isHardTrainingLevel = self.isHardTrainingLevel();
        let isPredefinedCardsSelectable = self.isPredefinedCardsSelectable();
        let displayRestTime = self.displayRestTime();
        let maxPlayTime = self.maxPlayTime();
        let functionDisableMask = self.functionDisableMask();
        let configBlackBoard = self
            .configBlackBoard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_LevelData_OptionsT {
            characterLimit,
            maxLifePoint,
            initialCost,
            maxCost,
            costIncreaseTime,
            moveMultiplier,
            steeringEnabled,
            isTrainingLevel,
            isHardTrainingLevel,
            isPredefinedCardsSelectable,
            displayRestTime,
            maxPlayTime,
            functionDisableMask,
            configBlackBoard,
        }
    }

    #[inline]
    pub fn characterLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_LevelData_Options::VT_CHARACTERLIMIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn maxLifePoint(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_LevelData_Options::VT_MAXLIFEPOINT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn initialCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_LevelData_Options::VT_INITIALCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn maxCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_LevelData_Options::VT_MAXCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn costIncreaseTime(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_LevelData_Options::VT_COSTINCREASETIME,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn moveMultiplier(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_LevelData_Options::VT_MOVEMULTIPLIER, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn steeringEnabled(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_Options::VT_STEERINGENABLED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isTrainingLevel(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_Options::VT_ISTRAININGLEVEL,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isHardTrainingLevel(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_Options::VT_ISHARDTRAININGLEVEL,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isPredefinedCardsSelectable(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_Options::VT_ISPREDEFINEDCARDSSELECTABLE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn displayRestTime(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_Options::VT_DISPLAYRESTTIME,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxPlayTime(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_LevelData_Options::VT_MAXPLAYTIME, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn functionDisableMask(&self) -> enum__Torappu_BattleFunctionDisableMask {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BattleFunctionDisableMask>(
                    clz_Torappu_LevelData_Options::VT_FUNCTIONDISABLEMASK,
                    Some(enum__Torappu_BattleFunctionDisableMask::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn configBlackBoard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_LevelData_Options::VT_CONFIGBLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_Options<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("characterLimit", Self::VT_CHARACTERLIMIT, false)?
            .visit_field::<i32>("maxLifePoint", Self::VT_MAXLIFEPOINT, false)?
            .visit_field::<i32>("initialCost", Self::VT_INITIALCOST, false)?
            .visit_field::<i32>("maxCost", Self::VT_MAXCOST, false)?
            .visit_field::<f32>("costIncreaseTime", Self::VT_COSTINCREASETIME, false)?
            .visit_field::<f32>("moveMultiplier", Self::VT_MOVEMULTIPLIER, false)?
            .visit_field::<bool>("steeringEnabled", Self::VT_STEERINGENABLED, false)?
            .visit_field::<bool>("isTrainingLevel", Self::VT_ISTRAININGLEVEL, false)?
            .visit_field::<bool>("isHardTrainingLevel", Self::VT_ISHARDTRAININGLEVEL, false)?
            .visit_field::<bool>(
                "isPredefinedCardsSelectable",
                Self::VT_ISPREDEFINEDCARDSSELECTABLE,
                false,
            )?
            .visit_field::<bool>("displayRestTime", Self::VT_DISPLAYRESTTIME, false)?
            .visit_field::<f32>("maxPlayTime", Self::VT_MAXPLAYTIME, false)?
            .visit_field::<enum__Torappu_BattleFunctionDisableMask>(
                "functionDisableMask",
                Self::VT_FUNCTIONDISABLEMASK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("configBlackBoard", Self::VT_CONFIGBLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_OptionsArgs<'a> {
    pub characterLimit: i32,
    pub maxLifePoint: i32,
    pub initialCost: i32,
    pub maxCost: i32,
    pub costIncreaseTime: f32,
    pub moveMultiplier: f32,
    pub steeringEnabled: bool,
    pub isTrainingLevel: bool,
    pub isHardTrainingLevel: bool,
    pub isPredefinedCardsSelectable: bool,
    pub displayRestTime: bool,
    pub maxPlayTime: f32,
    pub functionDisableMask: enum__Torappu_BattleFunctionDisableMask,
    pub configBlackBoard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_LevelData_OptionsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_OptionsArgs {
            characterLimit: 0,
            maxLifePoint: 0,
            initialCost: 0,
            maxCost: 0,
            costIncreaseTime: 0.0,
            moveMultiplier: 0.0,
            steeringEnabled: false,
            isTrainingLevel: false,
            isHardTrainingLevel: false,
            isPredefinedCardsSelectable: false,
            displayRestTime: false,
            maxPlayTime: 0.0,
            functionDisableMask: enum__Torappu_BattleFunctionDisableMask::NONE,
            configBlackBoard: None,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_Options<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LevelData_Options", 14)?;
        s.serialize_field("characterLimit", &self.characterLimit())?;
        s.serialize_field("maxLifePoint", &self.maxLifePoint())?;
        s.serialize_field("initialCost", &self.initialCost())?;
        s.serialize_field("maxCost", &self.maxCost())?;
        s.serialize_field("costIncreaseTime", &self.costIncreaseTime())?;
        s.serialize_field("moveMultiplier", &self.moveMultiplier())?;
        s.serialize_field("steeringEnabled", &self.steeringEnabled())?;
        s.serialize_field("isTrainingLevel", &self.isTrainingLevel())?;
        s.serialize_field("isHardTrainingLevel", &self.isHardTrainingLevel())?;
        s.serialize_field(
            "isPredefinedCardsSelectable",
            &self.isPredefinedCardsSelectable(),
        )?;
        s.serialize_field("displayRestTime", &self.displayRestTime())?;
        s.serialize_field("maxPlayTime", &self.maxPlayTime())?;
        s.serialize_field("functionDisableMask", &self.functionDisableMask())?;
        if let Some(f) = self.configBlackBoard() {
            s.serialize_field("configBlackBoard", &f)?;
        } else {
            s.skip_field("configBlackBoard")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LevelData_OptionsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_LevelData_OptionsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_characterLimit(&mut self, characterLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_Options::VT_CHARACTERLIMIT,
            characterLimit,
            0,
        );
    }
    #[inline]
    pub fn add_maxLifePoint(&mut self, maxLifePoint: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_Options::VT_MAXLIFEPOINT,
            maxLifePoint,
            0,
        );
    }
    #[inline]
    pub fn add_initialCost(&mut self, initialCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_Options::VT_INITIALCOST,
            initialCost,
            0,
        );
    }
    #[inline]
    pub fn add_maxCost(&mut self, maxCost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_LevelData_Options::VT_MAXCOST, maxCost, 0);
    }
    #[inline]
    pub fn add_costIncreaseTime(&mut self, costIncreaseTime: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_Options::VT_COSTINCREASETIME,
            costIncreaseTime,
            0.0,
        );
    }
    #[inline]
    pub fn add_moveMultiplier(&mut self, moveMultiplier: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_Options::VT_MOVEMULTIPLIER,
            moveMultiplier,
            0.0,
        );
    }
    #[inline]
    pub fn add_steeringEnabled(&mut self, steeringEnabled: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_Options::VT_STEERINGENABLED,
            steeringEnabled,
            false,
        );
    }
    #[inline]
    pub fn add_isTrainingLevel(&mut self, isTrainingLevel: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_Options::VT_ISTRAININGLEVEL,
            isTrainingLevel,
            false,
        );
    }
    #[inline]
    pub fn add_isHardTrainingLevel(&mut self, isHardTrainingLevel: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_Options::VT_ISHARDTRAININGLEVEL,
            isHardTrainingLevel,
            false,
        );
    }
    #[inline]
    pub fn add_isPredefinedCardsSelectable(&mut self, isPredefinedCardsSelectable: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_Options::VT_ISPREDEFINEDCARDSSELECTABLE,
            isPredefinedCardsSelectable,
            false,
        );
    }
    #[inline]
    pub fn add_displayRestTime(&mut self, displayRestTime: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_Options::VT_DISPLAYRESTTIME,
            displayRestTime,
            false,
        );
    }
    #[inline]
    pub fn add_maxPlayTime(&mut self, maxPlayTime: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_Options::VT_MAXPLAYTIME,
            maxPlayTime,
            0.0,
        );
    }
    #[inline]
    pub fn add_functionDisableMask(
        &mut self,
        functionDisableMask: enum__Torappu_BattleFunctionDisableMask,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_BattleFunctionDisableMask>(
                clz_Torappu_LevelData_Options::VT_FUNCTIONDISABLEMASK,
                functionDisableMask,
                enum__Torappu_BattleFunctionDisableMask::NONE,
            );
    }
    #[inline]
    pub fn add_configBlackBoard(
        &mut self,
        configBlackBoard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_Options::VT_CONFIGBLACKBOARD,
            configBlackBoard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_OptionsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_OptionsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_Options<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_Options<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_Options");
        ds.field("characterLimit", &self.characterLimit());
        ds.field("maxLifePoint", &self.maxLifePoint());
        ds.field("initialCost", &self.initialCost());
        ds.field("maxCost", &self.maxCost());
        ds.field("costIncreaseTime", &self.costIncreaseTime());
        ds.field("moveMultiplier", &self.moveMultiplier());
        ds.field("steeringEnabled", &self.steeringEnabled());
        ds.field("isTrainingLevel", &self.isTrainingLevel());
        ds.field("isHardTrainingLevel", &self.isHardTrainingLevel());
        ds.field(
            "isPredefinedCardsSelectable",
            &self.isPredefinedCardsSelectable(),
        );
        ds.field("displayRestTime", &self.displayRestTime());
        ds.field("maxPlayTime", &self.maxPlayTime());
        ds.field("functionDisableMask", &self.functionDisableMask());
        ds.field("configBlackBoard", &self.configBlackBoard());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_OptionsT {
    pub characterLimit: i32,
    pub maxLifePoint: i32,
    pub initialCost: i32,
    pub maxCost: i32,
    pub costIncreaseTime: f32,
    pub moveMultiplier: f32,
    pub steeringEnabled: bool,
    pub isTrainingLevel: bool,
    pub isHardTrainingLevel: bool,
    pub isPredefinedCardsSelectable: bool,
    pub displayRestTime: bool,
    pub maxPlayTime: f32,
    pub functionDisableMask: enum__Torappu_BattleFunctionDisableMask,
    pub configBlackBoard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for clz_Torappu_LevelData_OptionsT {
    fn default() -> Self {
        Self {
            characterLimit: 0,
            maxLifePoint: 0,
            initialCost: 0,
            maxCost: 0,
            costIncreaseTime: 0.0,
            moveMultiplier: 0.0,
            steeringEnabled: false,
            isTrainingLevel: false,
            isHardTrainingLevel: false,
            isPredefinedCardsSelectable: false,
            displayRestTime: false,
            maxPlayTime: 0.0,
            functionDisableMask: enum__Torappu_BattleFunctionDisableMask::NONE,
            configBlackBoard: None,
        }
    }
}
impl clz_Torappu_LevelData_OptionsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_Options<'b>> {
        let characterLimit = self.characterLimit;
        let maxLifePoint = self.maxLifePoint;
        let initialCost = self.initialCost;
        let maxCost = self.maxCost;
        let costIncreaseTime = self.costIncreaseTime;
        let moveMultiplier = self.moveMultiplier;
        let steeringEnabled = self.steeringEnabled;
        let isTrainingLevel = self.isTrainingLevel;
        let isHardTrainingLevel = self.isHardTrainingLevel;
        let isPredefinedCardsSelectable = self.isPredefinedCardsSelectable;
        let displayRestTime = self.displayRestTime;
        let maxPlayTime = self.maxPlayTime;
        let functionDisableMask = self.functionDisableMask;
        let configBlackBoard = self.configBlackBoard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_LevelData_Options::create(
            _fbb,
            &clz_Torappu_LevelData_OptionsArgs {
                characterLimit,
                maxLifePoint,
                initialCost,
                maxCost,
                costIncreaseTime,
                moveMultiplier,
                steeringEnabled,
                isTrainingLevel,
                isHardTrainingLevel,
                isPredefinedCardsSelectable,
                displayRestTime,
                maxPlayTime,
                functionDisableMask,
                configBlackBoard,
            },
        )
    }
}
pub enum hg__internal__MapDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct hg__internal__MapData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for hg__internal__MapData<'a> {
    type Inner = hg__internal__MapData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> hg__internal__MapData<'a> {
    pub const VT_ROW_SIZE: flatbuffers::VOffsetT = 4;
    pub const VT_COLUMN_SIZE: flatbuffers::VOffsetT = 6;
    pub const VT_MATRIX_DATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        hg__internal__MapData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args hg__internal__MapDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<hg__internal__MapData<'bldr>> {
        let mut builder = hg__internal__MapDataBuilder::new(_fbb);
        if let Some(x) = args.matrix_data {
            builder.add_matrix_data(x);
        }
        builder.add_column_size(args.column_size);
        builder.add_row_size(args.row_size);
        builder.finish()
    }

    pub fn unpack(&self) -> hg__internal__MapDataT {
        let row_size = self.row_size();
        let column_size = self.column_size();
        let matrix_data = self.matrix_data().map(|x| x.into_iter().collect());
        hg__internal__MapDataT {
            row_size,
            column_size,
            matrix_data,
        }
    }

    #[inline]
    pub fn row_size(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(hg__internal__MapData::VT_ROW_SIZE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn column_size(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(hg__internal__MapData::VT_COLUMN_SIZE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn matrix_data(&self) -> Option<flatbuffers::Vector<'a, i16>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i16>>>(
                    hg__internal__MapData::VT_MATRIX_DATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for hg__internal__MapData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("row_size", Self::VT_ROW_SIZE, false)?
            .visit_field::<i32>("column_size", Self::VT_COLUMN_SIZE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i16>>>(
                "matrix_data",
                Self::VT_MATRIX_DATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct hg__internal__MapDataArgs<'a> {
    pub row_size: i32,
    pub column_size: i32,
    pub matrix_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i16>>>,
}
impl<'a> Default for hg__internal__MapDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        hg__internal__MapDataArgs {
            row_size: 0,
            column_size: 0,
            matrix_data: None,
        }
    }
}

impl Serialize for hg__internal__MapData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("hg__internal__MapData", 3)?;
        s.serialize_field("row_size", &self.row_size())?;
        s.serialize_field("column_size", &self.column_size())?;
        if let Some(f) = self.matrix_data() {
            s.serialize_field("matrix_data", &f)?;
        } else {
            s.skip_field("matrix_data")?;
        }
        s.end()
    }
}

pub struct hg__internal__MapDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> hg__internal__MapDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_row_size(&mut self, row_size: i32) {
        self.fbb_
            .push_slot::<i32>(hg__internal__MapData::VT_ROW_SIZE, row_size, 0);
    }
    #[inline]
    pub fn add_column_size(&mut self, column_size: i32) {
        self.fbb_
            .push_slot::<i32>(hg__internal__MapData::VT_COLUMN_SIZE, column_size, 0);
    }
    #[inline]
    pub fn add_matrix_data(
        &mut self,
        matrix_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i16>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            hg__internal__MapData::VT_MATRIX_DATA,
            matrix_data,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> hg__internal__MapDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        hg__internal__MapDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<hg__internal__MapData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for hg__internal__MapData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("hg__internal__MapData");
        ds.field("row_size", &self.row_size());
        ds.field("column_size", &self.column_size());
        ds.field("matrix_data", &self.matrix_data());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct hg__internal__MapDataT {
    pub row_size: i32,
    pub column_size: i32,
    pub matrix_data: Option<Vec<i16>>,
}
impl Default for hg__internal__MapDataT {
    fn default() -> Self {
        Self {
            row_size: 0,
            column_size: 0,
            matrix_data: None,
        }
    }
}
impl hg__internal__MapDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<hg__internal__MapData<'b>> {
        let row_size = self.row_size;
        let column_size = self.column_size;
        let matrix_data = self.matrix_data.as_ref().map(|x| _fbb.create_vector(x));
        hg__internal__MapData::create(
            _fbb,
            &hg__internal__MapDataArgs {
                row_size,
                column_size,
                matrix_data,
            },
        )
    }
}
pub enum clz_UnityEngine_Vector3Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_UnityEngine_Vector3<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_UnityEngine_Vector3<'a> {
    type Inner = clz_UnityEngine_Vector3<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_UnityEngine_Vector3<'a> {
    pub const VT_X: flatbuffers::VOffsetT = 4;
    pub const VT_Y: flatbuffers::VOffsetT = 6;
    pub const VT_Z: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_UnityEngine_Vector3 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_UnityEngine_Vector3Args,
    ) -> flatbuffers::WIPOffset<clz_UnityEngine_Vector3<'bldr>> {
        let mut builder = clz_UnityEngine_Vector3Builder::new(_fbb);
        builder.add_z(args.z);
        builder.add_y(args.y);
        builder.add_x(args.x);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_UnityEngine_Vector3T {
        let x = self.x();
        let y = self.y();
        let z = self.z();
        clz_UnityEngine_Vector3T { x, y, z }
    }

    #[inline]
    pub fn x(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_UnityEngine_Vector3::VT_X, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn y(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_UnityEngine_Vector3::VT_Y, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn z(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_UnityEngine_Vector3::VT_Z, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_UnityEngine_Vector3<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("x", Self::VT_X, false)?
            .visit_field::<f32>("y", Self::VT_Y, false)?
            .visit_field::<f32>("z", Self::VT_Z, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_UnityEngine_Vector3Args {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
impl<'a> Default for clz_UnityEngine_Vector3Args {
    #[inline]
    fn default() -> Self {
        clz_UnityEngine_Vector3Args {
            x: 0.0,
            y: 0.0,
            z: 0.0,
        }
    }
}

impl Serialize for clz_UnityEngine_Vector3<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_UnityEngine_Vector3", 3)?;
        s.serialize_field("x", &self.x())?;
        s.serialize_field("y", &self.y())?;
        s.serialize_field("z", &self.z())?;
        s.end()
    }
}

pub struct clz_UnityEngine_Vector3Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_UnityEngine_Vector3Builder<'a, 'b, A> {
    #[inline]
    pub fn add_x(&mut self, x: f32) {
        self.fbb_
            .push_slot::<f32>(clz_UnityEngine_Vector3::VT_X, x, 0.0);
    }
    #[inline]
    pub fn add_y(&mut self, y: f32) {
        self.fbb_
            .push_slot::<f32>(clz_UnityEngine_Vector3::VT_Y, y, 0.0);
    }
    #[inline]
    pub fn add_z(&mut self, z: f32) {
        self.fbb_
            .push_slot::<f32>(clz_UnityEngine_Vector3::VT_Z, z, 0.0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_UnityEngine_Vector3Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_UnityEngine_Vector3Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_UnityEngine_Vector3<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_UnityEngine_Vector3<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_UnityEngine_Vector3");
        ds.field("x", &self.x());
        ds.field("y", &self.y());
        ds.field("z", &self.z());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_UnityEngine_Vector3T {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
impl Default for clz_UnityEngine_Vector3T {
    fn default() -> Self {
        Self {
            x: 0.0,
            y: 0.0,
            z: 0.0,
        }
    }
}
impl clz_UnityEngine_Vector3T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_UnityEngine_Vector3<'b>> {
        let x = self.x;
        let y = self.y;
        let z = self.z;
        clz_UnityEngine_Vector3::create(_fbb, &clz_UnityEngine_Vector3Args { x, y, z })
    }
}
pub enum clz_Torappu_MapEffectDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MapEffectData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MapEffectData<'a> {
    type Inner = clz_Torappu_MapEffectData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MapEffectData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_OFFSET: flatbuffers::VOffsetT = 6;
    pub const VT_DIRECTION: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MapEffectData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MapEffectDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MapEffectData<'bldr>> {
        let mut builder = clz_Torappu_MapEffectDataBuilder::new(_fbb);
        builder.add_direction(args.direction);
        if let Some(x) = args.offset {
            builder.add_offset(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MapEffectDataT {
        let key = self.key().map(|x| x.to_string());
        let offset = self.offset().map(|x| Box::new(x.unpack()));
        let direction = self.direction();
        clz_Torappu_MapEffectDataT {
            key,
            offset,
            direction,
        }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_MapEffectData::VT_KEY, None)
        }
    }
    #[inline]
    pub fn offset(&self) -> Option<clz_UnityEngine_Vector3<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector3>>(
                    clz_Torappu_MapEffectData::VT_OFFSET,
                    None,
                )
        }
    }
    #[inline]
    pub fn direction(&self) -> enum__Torappu_SharedConsts_Direction {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SharedConsts_Direction>(
                    clz_Torappu_MapEffectData::VT_DIRECTION,
                    Some(enum__Torappu_SharedConsts_Direction::UP),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MapEffectData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector3>>(
                "offset",
                Self::VT_OFFSET,
                false,
            )?
            .visit_field::<enum__Torappu_SharedConsts_Direction>(
                "direction",
                Self::VT_DIRECTION,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MapEffectDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub offset: Option<flatbuffers::WIPOffset<clz_UnityEngine_Vector3<'a>>>,
    pub direction: enum__Torappu_SharedConsts_Direction,
}
impl<'a> Default for clz_Torappu_MapEffectDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MapEffectDataArgs {
            key: None,
            offset: None,
            direction: enum__Torappu_SharedConsts_Direction::UP,
        }
    }
}

impl Serialize for clz_Torappu_MapEffectData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MapEffectData", 3)?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        if let Some(f) = self.offset() {
            s.serialize_field("offset", &f)?;
        } else {
            s.skip_field("offset")?;
        }
        s.serialize_field("direction", &self.direction())?;
        s.end()
    }
}

pub struct clz_Torappu_MapEffectDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_MapEffectDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_MapEffectData::VT_KEY, key);
    }
    #[inline]
    pub fn add_offset(&mut self, offset: flatbuffers::WIPOffset<clz_UnityEngine_Vector3<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_UnityEngine_Vector3>>(
                clz_Torappu_MapEffectData::VT_OFFSET,
                offset,
            );
    }
    #[inline]
    pub fn add_direction(&mut self, direction: enum__Torappu_SharedConsts_Direction) {
        self.fbb_.push_slot::<enum__Torappu_SharedConsts_Direction>(
            clz_Torappu_MapEffectData::VT_DIRECTION,
            direction,
            enum__Torappu_SharedConsts_Direction::UP,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MapEffectDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MapEffectDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MapEffectData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MapEffectData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MapEffectData");
        ds.field("key", &self.key());
        ds.field("offset", &self.offset());
        ds.field("direction", &self.direction());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MapEffectDataT {
    pub key: Option<String>,
    pub offset: Option<Box<clz_UnityEngine_Vector3T>>,
    pub direction: enum__Torappu_SharedConsts_Direction,
}
impl Default for clz_Torappu_MapEffectDataT {
    fn default() -> Self {
        Self {
            key: None,
            offset: None,
            direction: enum__Torappu_SharedConsts_Direction::UP,
        }
    }
}
impl clz_Torappu_MapEffectDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MapEffectData<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let offset = self.offset.as_ref().map(|x| x.pack(_fbb));
        let direction = self.direction;
        clz_Torappu_MapEffectData::create(
            _fbb,
            &clz_Torappu_MapEffectDataArgs {
                key,
                offset,
                direction,
            },
        )
    }
}
pub enum clz_Torappu_TileDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TileData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TileData<'a> {
    type Inner = clz_Torappu_TileData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_TileData<'a> {
    pub const VT_TILEKEY: flatbuffers::VOffsetT = 4;
    pub const VT_HEIGHTTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_BUILDABLETYPE: flatbuffers::VOffsetT = 8;
    pub const VT_PASSABLEMASK: flatbuffers::VOffsetT = 10;
    pub const VT_PLAYERSIDEMASK: flatbuffers::VOffsetT = 12;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 14;
    pub const VT_EFFECTS: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TileData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TileDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TileData<'bldr>> {
        let mut builder = clz_Torappu_TileDataBuilder::new(_fbb);
        if let Some(x) = args.effects {
            builder.add_effects(x);
        }
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        builder.add_passableMask(args.passableMask);
        builder.add_buildableType(args.buildableType);
        builder.add_heightType(args.heightType);
        if let Some(x) = args.tileKey {
            builder.add_tileKey(x);
        }
        builder.add_playerSideMask(args.playerSideMask);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_TileDataT {
        let tileKey = self.tileKey().map(|x| x.to_string());
        let heightType = self.heightType();
        let buildableType = self.buildableType();
        let passableMask = self.passableMask();
        let playerSideMask = self.playerSideMask();
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let effects = self
            .effects()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_TileDataT {
            tileKey,
            heightType,
            buildableType,
            passableMask,
            playerSideMask,
            blackboard,
            effects,
        }
    }

    #[inline]
    pub fn tileKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_TileData::VT_TILEKEY, None)
        }
    }
    #[inline]
    pub fn heightType(&self) -> enum__Torappu_TileData_HeightType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_TileData_HeightType>(
                    clz_Torappu_TileData::VT_HEIGHTTYPE,
                    Some(enum__Torappu_TileData_HeightType::LOWLAND),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buildableType(&self) -> enum__Torappu_BuildableType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildableType>(
                    clz_Torappu_TileData::VT_BUILDABLETYPE,
                    Some(enum__Torappu_BuildableType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn passableMask(&self) -> enum__Torappu_MotionMask {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_MotionMask>(
                    clz_Torappu_TileData::VT_PASSABLEMASK,
                    Some(enum__Torappu_MotionMask::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn playerSideMask(&self) -> enum__Torappu_PlayerSideMask {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_PlayerSideMask>(
                    clz_Torappu_TileData::VT_PLAYERSIDEMASK,
                    Some(enum__Torappu_PlayerSideMask::ALL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_TileData::VT_BLACKBOARD, None)
        }
    }
    #[inline]
    pub fn effects(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_MapEffectData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_MapEffectData>>,
            >>(clz_Torappu_TileData::VT_EFFECTS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TileData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tileKey", Self::VT_TILEKEY, false)?
            .visit_field::<enum__Torappu_TileData_HeightType>(
                "heightType",
                Self::VT_HEIGHTTYPE,
                false,
            )?
            .visit_field::<enum__Torappu_BuildableType>(
                "buildableType",
                Self::VT_BUILDABLETYPE,
                false,
            )?
            .visit_field::<enum__Torappu_MotionMask>("passableMask", Self::VT_PASSABLEMASK, false)?
            .visit_field::<enum__Torappu_PlayerSideMask>(
                "playerSideMask",
                Self::VT_PLAYERSIDEMASK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_MapEffectData>>,
            >>("effects", Self::VT_EFFECTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TileDataArgs<'a> {
    pub tileKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub heightType: enum__Torappu_TileData_HeightType,
    pub buildableType: enum__Torappu_BuildableType,
    pub passableMask: enum__Torappu_MotionMask,
    pub playerSideMask: enum__Torappu_PlayerSideMask,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
    pub effects: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_MapEffectData<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_TileDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TileDataArgs {
            tileKey: None,
            heightType: enum__Torappu_TileData_HeightType::LOWLAND,
            buildableType: enum__Torappu_BuildableType::NONE,
            passableMask: enum__Torappu_MotionMask::NONE,
            playerSideMask: enum__Torappu_PlayerSideMask::ALL,
            blackboard: None,
            effects: None,
        }
    }
}

impl Serialize for clz_Torappu_TileData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_TileData", 7)?;
        if let Some(f) = self.tileKey() {
            s.serialize_field("tileKey", &f)?;
        } else {
            s.skip_field("tileKey")?;
        }
        s.serialize_field("heightType", &self.heightType())?;
        s.serialize_field("buildableType", &self.buildableType())?;
        s.serialize_field("passableMask", &self.passableMask())?;
        s.serialize_field("playerSideMask", &self.playerSideMask())?;
        if let Some(f) = self.blackboard() {
            s.serialize_field("blackboard", &f)?;
        } else {
            s.skip_field("blackboard")?;
        }
        if let Some(f) = self.effects() {
            s.serialize_field("effects", &f)?;
        } else {
            s.skip_field("effects")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_TileDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TileDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_tileKey(&mut self, tileKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TileData::VT_TILEKEY,
            tileKey,
        );
    }
    #[inline]
    pub fn add_heightType(&mut self, heightType: enum__Torappu_TileData_HeightType) {
        self.fbb_.push_slot::<enum__Torappu_TileData_HeightType>(
            clz_Torappu_TileData::VT_HEIGHTTYPE,
            heightType,
            enum__Torappu_TileData_HeightType::LOWLAND,
        );
    }
    #[inline]
    pub fn add_buildableType(&mut self, buildableType: enum__Torappu_BuildableType) {
        self.fbb_.push_slot::<enum__Torappu_BuildableType>(
            clz_Torappu_TileData::VT_BUILDABLETYPE,
            buildableType,
            enum__Torappu_BuildableType::NONE,
        );
    }
    #[inline]
    pub fn add_passableMask(&mut self, passableMask: enum__Torappu_MotionMask) {
        self.fbb_.push_slot::<enum__Torappu_MotionMask>(
            clz_Torappu_TileData::VT_PASSABLEMASK,
            passableMask,
            enum__Torappu_MotionMask::NONE,
        );
    }
    #[inline]
    pub fn add_playerSideMask(&mut self, playerSideMask: enum__Torappu_PlayerSideMask) {
        self.fbb_.push_slot::<enum__Torappu_PlayerSideMask>(
            clz_Torappu_TileData::VT_PLAYERSIDEMASK,
            playerSideMask,
            enum__Torappu_PlayerSideMask::ALL,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TileData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn add_effects(
        &mut self,
        effects: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_MapEffectData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TileData::VT_EFFECTS,
            effects,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TileDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TileDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TileData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TileData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TileData");
        ds.field("tileKey", &self.tileKey());
        ds.field("heightType", &self.heightType());
        ds.field("buildableType", &self.buildableType());
        ds.field("passableMask", &self.passableMask());
        ds.field("playerSideMask", &self.playerSideMask());
        ds.field("blackboard", &self.blackboard());
        ds.field("effects", &self.effects());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_TileDataT {
    pub tileKey: Option<String>,
    pub heightType: enum__Torappu_TileData_HeightType,
    pub buildableType: enum__Torappu_BuildableType,
    pub passableMask: enum__Torappu_MotionMask,
    pub playerSideMask: enum__Torappu_PlayerSideMask,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
    pub effects: Option<Vec<clz_Torappu_MapEffectDataT>>,
}
impl Default for clz_Torappu_TileDataT {
    fn default() -> Self {
        Self {
            tileKey: None,
            heightType: enum__Torappu_TileData_HeightType::LOWLAND,
            buildableType: enum__Torappu_BuildableType::NONE,
            passableMask: enum__Torappu_MotionMask::NONE,
            playerSideMask: enum__Torappu_PlayerSideMask::ALL,
            blackboard: None,
            effects: None,
        }
    }
}
impl clz_Torappu_TileDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TileData<'b>> {
        let tileKey = self.tileKey.as_ref().map(|x| _fbb.create_string(x));
        let heightType = self.heightType;
        let buildableType = self.buildableType;
        let passableMask = self.passableMask;
        let playerSideMask = self.playerSideMask;
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let effects = self.effects.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_TileData::create(
            _fbb,
            &clz_Torappu_TileDataArgs {
                tileKey,
                heightType,
                buildableType,
                passableMask,
                playerSideMask,
                blackboard,
                effects,
            },
        )
    }
}
pub enum clz_Torappu_GridPositionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_GridPosition<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_GridPosition<'a> {
    type Inner = clz_Torappu_GridPosition<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_GridPosition<'a> {
    pub const VT_ROW: flatbuffers::VOffsetT = 4;
    pub const VT_COL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_GridPosition { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_GridPositionArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_GridPosition<'bldr>> {
        let mut builder = clz_Torappu_GridPositionBuilder::new(_fbb);
        builder.add_col(args.col);
        builder.add_row(args.row);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_GridPositionT {
        let row = self.row();
        let col = self.col();
        clz_Torappu_GridPositionT { row, col }
    }

    #[inline]
    pub fn row(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_GridPosition::VT_ROW, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn col(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_GridPosition::VT_COL, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_GridPosition<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("row", Self::VT_ROW, false)?
            .visit_field::<i32>("col", Self::VT_COL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_GridPositionArgs {
    pub row: i32,
    pub col: i32,
}
impl<'a> Default for clz_Torappu_GridPositionArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_GridPositionArgs { row: 0, col: 0 }
    }
}

impl Serialize for clz_Torappu_GridPosition<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_GridPosition", 2)?;
        s.serialize_field("row", &self.row())?;
        s.serialize_field("col", &self.col())?;
        s.end()
    }
}

pub struct clz_Torappu_GridPositionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_GridPositionBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_row(&mut self, row: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_GridPosition::VT_ROW, row, 0);
    }
    #[inline]
    pub fn add_col(&mut self, col: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_GridPosition::VT_COL, col, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_GridPositionBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_GridPositionBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_GridPosition<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_GridPosition<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_GridPosition");
        ds.field("row", &self.row());
        ds.field("col", &self.col());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_GridPositionT {
    pub row: i32,
    pub col: i32,
}
impl Default for clz_Torappu_GridPositionT {
    fn default() -> Self {
        Self { row: 0, col: 0 }
    }
}
impl clz_Torappu_GridPositionT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_GridPosition<'b>> {
        let row = self.row;
        let col = self.col;
        clz_Torappu_GridPosition::create(_fbb, &clz_Torappu_GridPositionArgs { row, col })
    }
}
pub enum clz_Torappu_MapData_EdgeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MapData_Edge<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MapData_Edge<'a> {
    type Inner = clz_Torappu_MapData_Edge<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MapData_Edge<'a> {
    pub const VT_POS: flatbuffers::VOffsetT = 4;
    pub const VT_DIRECTION: flatbuffers::VOffsetT = 6;
    pub const VT_BLOCKMASK: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MapData_Edge { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MapData_EdgeArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MapData_Edge<'bldr>> {
        let mut builder = clz_Torappu_MapData_EdgeBuilder::new(_fbb);
        builder.add_blockMask(args.blockMask);
        builder.add_direction(args.direction);
        if let Some(x) = args.pos {
            builder.add_pos(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MapData_EdgeT {
        let pos = self.pos().map(|x| Box::new(x.unpack()));
        let direction = self.direction();
        let blockMask = self.blockMask();
        clz_Torappu_MapData_EdgeT {
            pos,
            direction,
            blockMask,
        }
    }

    #[inline]
    pub fn pos(&self) -> Option<clz_Torappu_GridPosition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                    clz_Torappu_MapData_Edge::VT_POS,
                    None,
                )
        }
    }
    #[inline]
    pub fn direction(&self) -> enum__Torappu_SharedConsts_Direction {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SharedConsts_Direction>(
                    clz_Torappu_MapData_Edge::VT_DIRECTION,
                    Some(enum__Torappu_SharedConsts_Direction::UP),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn blockMask(&self) -> enum__Torappu_MotionMask {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_MotionMask>(
                    clz_Torappu_MapData_Edge::VT_BLOCKMASK,
                    Some(enum__Torappu_MotionMask::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MapData_Edge<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                "pos",
                Self::VT_POS,
                false,
            )?
            .visit_field::<enum__Torappu_SharedConsts_Direction>(
                "direction",
                Self::VT_DIRECTION,
                false,
            )?
            .visit_field::<enum__Torappu_MotionMask>("blockMask", Self::VT_BLOCKMASK, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MapData_EdgeArgs<'a> {
    pub pos: Option<flatbuffers::WIPOffset<clz_Torappu_GridPosition<'a>>>,
    pub direction: enum__Torappu_SharedConsts_Direction,
    pub blockMask: enum__Torappu_MotionMask,
}
impl<'a> Default for clz_Torappu_MapData_EdgeArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MapData_EdgeArgs {
            pos: None,
            direction: enum__Torappu_SharedConsts_Direction::UP,
            blockMask: enum__Torappu_MotionMask::NONE,
        }
    }
}

impl Serialize for clz_Torappu_MapData_Edge<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MapData_Edge", 3)?;
        if let Some(f) = self.pos() {
            s.serialize_field("pos", &f)?;
        } else {
            s.skip_field("pos")?;
        }
        s.serialize_field("direction", &self.direction())?;
        s.serialize_field("blockMask", &self.blockMask())?;
        s.end()
    }
}

pub struct clz_Torappu_MapData_EdgeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_MapData_EdgeBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_pos(&mut self, pos: flatbuffers::WIPOffset<clz_Torappu_GridPosition<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_GridPosition>>(
                clz_Torappu_MapData_Edge::VT_POS,
                pos,
            );
    }
    #[inline]
    pub fn add_direction(&mut self, direction: enum__Torappu_SharedConsts_Direction) {
        self.fbb_.push_slot::<enum__Torappu_SharedConsts_Direction>(
            clz_Torappu_MapData_Edge::VT_DIRECTION,
            direction,
            enum__Torappu_SharedConsts_Direction::UP,
        );
    }
    #[inline]
    pub fn add_blockMask(&mut self, blockMask: enum__Torappu_MotionMask) {
        self.fbb_.push_slot::<enum__Torappu_MotionMask>(
            clz_Torappu_MapData_Edge::VT_BLOCKMASK,
            blockMask,
            enum__Torappu_MotionMask::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MapData_EdgeBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MapData_EdgeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MapData_Edge<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MapData_Edge<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MapData_Edge");
        ds.field("pos", &self.pos());
        ds.field("direction", &self.direction());
        ds.field("blockMask", &self.blockMask());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MapData_EdgeT {
    pub pos: Option<Box<clz_Torappu_GridPositionT>>,
    pub direction: enum__Torappu_SharedConsts_Direction,
    pub blockMask: enum__Torappu_MotionMask,
}
impl Default for clz_Torappu_MapData_EdgeT {
    fn default() -> Self {
        Self {
            pos: None,
            direction: enum__Torappu_SharedConsts_Direction::UP,
            blockMask: enum__Torappu_MotionMask::NONE,
        }
    }
}
impl clz_Torappu_MapData_EdgeT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MapData_Edge<'b>> {
        let pos = self.pos.as_ref().map(|x| x.pack(_fbb));
        let direction = self.direction;
        let blockMask = self.blockMask;
        clz_Torappu_MapData_Edge::create(
            _fbb,
            &clz_Torappu_MapData_EdgeArgs {
                pos,
                direction,
                blockMask,
            },
        )
    }
}
pub enum clz_Torappu_MapDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_MapData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_MapData<'a> {
    type Inner = clz_Torappu_MapData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_MapData<'a> {
    pub const VT_MAP: flatbuffers::VOffsetT = 4;
    pub const VT_TILES: flatbuffers::VOffsetT = 6;
    pub const VT_BLOCKEDGES: flatbuffers::VOffsetT = 8;
    pub const VT_TAGS: flatbuffers::VOffsetT = 10;
    pub const VT_EFFECTS: flatbuffers::VOffsetT = 12;
    pub const VT_LAYERRECTS: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_MapData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_MapDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MapData<'bldr>> {
        let mut builder = clz_Torappu_MapDataBuilder::new(_fbb);
        if let Some(x) = args.layerRects {
            builder.add_layerRects(x);
        }
        if let Some(x) = args.effects {
            builder.add_effects(x);
        }
        if let Some(x) = args.tags {
            builder.add_tags(x);
        }
        if let Some(x) = args.blockEdges {
            builder.add_blockEdges(x);
        }
        if let Some(x) = args.tiles {
            builder.add_tiles(x);
        }
        if let Some(x) = args.map {
            builder.add_map(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_MapDataT {
        let map = self.map().map(|x| Box::new(x.unpack()));
        let tiles = self.tiles().map(|x| x.iter().map(|t| t.unpack()).collect());
        let blockEdges = self
            .blockEdges()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let tags = self
            .tags()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let effects = self
            .effects()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let layerRects = self
            .layerRects()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_MapDataT {
            map,
            tiles,
            blockEdges,
            tags,
            effects,
            layerRects,
        }
    }

    #[inline]
    pub fn map(&self) -> Option<hg__internal__MapData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<hg__internal__MapData>>(
                    clz_Torappu_MapData::VT_MAP,
                    None,
                )
        }
    }
    #[inline]
    pub fn tiles(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TileData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TileData>>,
            >>(clz_Torappu_MapData::VT_TILES, None)
        }
    }
    #[inline]
    pub fn blockEdges(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_MapData_Edge<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_MapData_Edge>>,
            >>(clz_Torappu_MapData::VT_BLOCKEDGES, None)
        }
    }
    #[inline]
    pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_MapData::VT_TAGS, None)
        }
    }
    #[inline]
    pub fn effects(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_MapEffectData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_MapEffectData>>,
            >>(clz_Torappu_MapData::VT_EFFECTS, None)
        }
    }
    #[inline]
    pub fn layerRects(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_MapData::VT_LAYERRECTS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_MapData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<hg__internal__MapData>>(
                "map",
                Self::VT_MAP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_TileData>>,
            >>("tiles", Self::VT_TILES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_MapData_Edge>>,
            >>("blockEdges", Self::VT_BLOCKEDGES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("tags", Self::VT_TAGS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_MapEffectData>>,
            >>("effects", Self::VT_EFFECTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("layerRects", Self::VT_LAYERRECTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_MapDataArgs<'a> {
    pub map: Option<flatbuffers::WIPOffset<hg__internal__MapData<'a>>>,
    pub tiles: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TileData<'a>>>,
        >,
    >,
    pub blockEdges: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_MapData_Edge<'a>>>,
        >,
    >,
    pub tags: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub effects: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_MapEffectData<'a>>>,
        >,
    >,
    pub layerRects: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_MapDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_MapDataArgs {
            map: None,
            tiles: None,
            blockEdges: None,
            tags: None,
            effects: None,
            layerRects: None,
        }
    }
}

impl Serialize for clz_Torappu_MapData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_MapData", 6)?;
        if let Some(f) = self.map() {
            s.serialize_field("map", &f)?;
        } else {
            s.skip_field("map")?;
        }
        if let Some(f) = self.tiles() {
            s.serialize_field("tiles", &f)?;
        } else {
            s.skip_field("tiles")?;
        }
        if let Some(f) = self.blockEdges() {
            s.serialize_field("blockEdges", &f)?;
        } else {
            s.skip_field("blockEdges")?;
        }
        if let Some(f) = self.tags() {
            s.serialize_field("tags", &f)?;
        } else {
            s.skip_field("tags")?;
        }
        if let Some(f) = self.effects() {
            s.serialize_field("effects", &f)?;
        } else {
            s.skip_field("effects")?;
        }
        if let Some(f) = self.layerRects() {
            s.serialize_field("layerRects", &f)?;
        } else {
            s.skip_field("layerRects")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_MapDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_MapDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_map(&mut self, map: flatbuffers::WIPOffset<hg__internal__MapData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<hg__internal__MapData>>(
                clz_Torappu_MapData::VT_MAP,
                map,
            );
    }
    #[inline]
    pub fn add_tiles(
        &mut self,
        tiles: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_TileData<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_MapData::VT_TILES, tiles);
    }
    #[inline]
    pub fn add_blockEdges(
        &mut self,
        blockEdges: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_MapData_Edge<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MapData::VT_BLOCKEDGES,
            blockEdges,
        );
    }
    #[inline]
    pub fn add_tags(
        &mut self,
        tags: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_MapData::VT_TAGS, tags);
    }
    #[inline]
    pub fn add_effects(
        &mut self,
        effects: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_MapEffectData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MapData::VT_EFFECTS,
            effects,
        );
    }
    #[inline]
    pub fn add_layerRects(
        &mut self,
        layerRects: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_MapData::VT_LAYERRECTS,
            layerRects,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_MapDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_MapDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_MapData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_MapData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_MapData");
        ds.field("map", &self.map());
        ds.field("tiles", &self.tiles());
        ds.field("blockEdges", &self.blockEdges());
        ds.field("tags", &self.tags());
        ds.field("effects", &self.effects());
        ds.field("layerRects", &self.layerRects());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_MapDataT {
    pub map: Option<Box<hg__internal__MapDataT>>,
    pub tiles: Option<Vec<clz_Torappu_TileDataT>>,
    pub blockEdges: Option<Vec<clz_Torappu_MapData_EdgeT>>,
    pub tags: Option<Vec<String>>,
    pub effects: Option<Vec<clz_Torappu_MapEffectDataT>>,
    pub layerRects: Option<Vec<String>>,
}
impl Default for clz_Torappu_MapDataT {
    fn default() -> Self {
        Self {
            map: None,
            tiles: None,
            blockEdges: None,
            tags: None,
            effects: None,
            layerRects: None,
        }
    }
}
impl clz_Torappu_MapDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_MapData<'b>> {
        let map = self.map.as_ref().map(|x| x.pack(_fbb));
        let tiles = self.tiles.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let blockEdges = self.blockEdges.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let tags = self.tags.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let effects = self.effects.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let layerRects = self.layerRects.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_MapData::create(
            _fbb,
            &clz_Torappu_MapDataArgs {
                map,
                tiles,
                blockEdges,
                tags,
                effects,
                layerRects,
            },
        )
    }
}
pub enum clz_Torappu_LegacyInLevelRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LegacyInLevelRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LegacyInLevelRuneData<'a> {
    type Inner = clz_Torappu_LegacyInLevelRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LegacyInLevelRuneData<'a> {
    pub const VT_DIFFICULTYMASK: flatbuffers::VOffsetT = 4;
    pub const VT_KEY: flatbuffers::VOffsetT = 6;
    pub const VT_PROFESSIONMASK: flatbuffers::VOffsetT = 8;
    pub const VT_BUILDABLEMASK: flatbuffers::VOffsetT = 10;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LegacyInLevelRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LegacyInLevelRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LegacyInLevelRuneData<'bldr>> {
        let mut builder = clz_Torappu_LegacyInLevelRuneDataBuilder::new(_fbb);
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        builder.add_buildableMask(args.buildableMask);
        builder.add_professionMask(args.professionMask);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.add_difficultyMask(args.difficultyMask);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LegacyInLevelRuneDataT {
        let difficultyMask = self.difficultyMask();
        let key = self.key().map(|x| x.to_string());
        let professionMask = self.professionMask();
        let buildableMask = self.buildableMask();
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_LegacyInLevelRuneDataT {
            difficultyMask,
            key,
            professionMask,
            buildableMask,
            blackboard,
        }
    }

    #[inline]
    pub fn difficultyMask(&self) -> enum__Torappu_LevelData_Difficulty {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_LevelData_Difficulty>(
                    clz_Torappu_LegacyInLevelRuneData::VT_DIFFICULTYMASK,
                    Some(enum__Torappu_LevelData_Difficulty::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LegacyInLevelRuneData::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn professionMask(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_LegacyInLevelRuneData::VT_PROFESSIONMASK,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buildableMask(&self) -> enum__Torappu_BuildableType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildableType>(
                    clz_Torappu_LegacyInLevelRuneData::VT_BUILDABLEMASK,
                    Some(enum__Torappu_BuildableType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_LegacyInLevelRuneData::VT_BLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LegacyInLevelRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_LevelData_Difficulty>(
                "difficultyMask",
                Self::VT_DIFFICULTYMASK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<enum__Torappu_ProfessionCategory>(
                "professionMask",
                Self::VT_PROFESSIONMASK,
                false,
            )?
            .visit_field::<enum__Torappu_BuildableType>(
                "buildableMask",
                Self::VT_BUILDABLEMASK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    pub difficultyMask: enum__Torappu_LevelData_Difficulty,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub buildableMask: enum__Torappu_BuildableType,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LegacyInLevelRuneDataArgs {
            difficultyMask: enum__Torappu_LevelData_Difficulty::NONE,
            key: None,
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            buildableMask: enum__Torappu_BuildableType::NONE,
            blackboard: None,
        }
    }
}

impl Serialize for clz_Torappu_LegacyInLevelRuneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LegacyInLevelRuneData", 5)?;
        s.serialize_field("difficultyMask", &self.difficultyMask())?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        s.serialize_field("professionMask", &self.professionMask())?;
        s.serialize_field("buildableMask", &self.buildableMask())?;
        if let Some(f) = self.blackboard() {
            s.serialize_field("blackboard", &f)?;
        } else {
            s.skip_field("blackboard")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LegacyInLevelRuneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_difficultyMask(&mut self, difficultyMask: enum__Torappu_LevelData_Difficulty) {
        self.fbb_.push_slot::<enum__Torappu_LevelData_Difficulty>(
            clz_Torappu_LegacyInLevelRuneData::VT_DIFFICULTYMASK,
            difficultyMask,
            enum__Torappu_LevelData_Difficulty::NONE,
        );
    }
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LegacyInLevelRuneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_professionMask(&mut self, professionMask: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_LegacyInLevelRuneData::VT_PROFESSIONMASK,
            professionMask,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_buildableMask(&mut self, buildableMask: enum__Torappu_BuildableType) {
        self.fbb_.push_slot::<enum__Torappu_BuildableType>(
            clz_Torappu_LegacyInLevelRuneData::VT_BUILDABLEMASK,
            buildableMask,
            enum__Torappu_BuildableType::NONE,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LegacyInLevelRuneData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LegacyInLevelRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LegacyInLevelRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LegacyInLevelRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LegacyInLevelRuneData");
        ds.field("difficultyMask", &self.difficultyMask());
        ds.field("key", &self.key());
        ds.field("professionMask", &self.professionMask());
        ds.field("buildableMask", &self.buildableMask());
        ds.field("blackboard", &self.blackboard());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LegacyInLevelRuneDataT {
    pub difficultyMask: enum__Torappu_LevelData_Difficulty,
    pub key: Option<String>,
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub buildableMask: enum__Torappu_BuildableType,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for clz_Torappu_LegacyInLevelRuneDataT {
    fn default() -> Self {
        Self {
            difficultyMask: enum__Torappu_LevelData_Difficulty::NONE,
            key: None,
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            buildableMask: enum__Torappu_BuildableType::NONE,
            blackboard: None,
        }
    }
}
impl clz_Torappu_LegacyInLevelRuneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LegacyInLevelRuneData<'b>> {
        let difficultyMask = self.difficultyMask;
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let professionMask = self.professionMask;
        let buildableMask = self.buildableMask;
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_LegacyInLevelRuneData::create(
            _fbb,
            &clz_Torappu_LegacyInLevelRuneDataArgs {
                difficultyMask,
                key,
                professionMask,
                buildableMask,
                blackboard,
            },
        )
    }
}
pub enum dict__string__list_clz_Torappu_LegacyInLevelRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a> {
    type Inner = dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_clz_Torappu_LegacyInLevelRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData<'bldr>> {
        let mut builder = dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__list_clz_Torappu_LegacyInLevelRuneDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.iter().map(|t| t.unpack()).collect());
        dict__string__list_clz_Torappu_LegacyInLevelRuneDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_clz_Torappu_LegacyInLevelRuneData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData>,
                >,
            >>(
                dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_clz_Torappu_LegacyInLevelRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__list_clz_Torappu_LegacyInLevelRuneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__list_clz_Torappu_LegacyInLevelRuneData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_clz_Torappu_LegacyInLevelRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__list_clz_Torappu_LegacyInLevelRuneData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_clz_Torappu_LegacyInLevelRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_clz_Torappu_LegacyInLevelRuneData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__list_clz_Torappu_LegacyInLevelRuneDataT {
    pub key: String,
    pub value: Option<Vec<clz_Torappu_LegacyInLevelRuneDataT>>,
}
impl Default for dict__string__list_clz_Torappu_LegacyInLevelRuneDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__list_clz_Torappu_LegacyInLevelRuneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        dict__string__list_clz_Torappu_LegacyInLevelRuneData::create(
            _fbb,
            &dict__string__list_clz_Torappu_LegacyInLevelRuneDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_LevelData_GlobalBuffDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_GlobalBuffData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_GlobalBuffData<'a> {
    type Inner = clz_Torappu_LevelData_GlobalBuffData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_GlobalBuffData<'a> {
    pub const VT_PREFABKEY: flatbuffers::VOffsetT = 4;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 6;
    pub const VT_OVERRIDECAMERAEFFECT: flatbuffers::VOffsetT = 8;
    pub const VT_PASSPROFESSIONMASKFLAG: flatbuffers::VOffsetT = 10;
    pub const VT_PROFESSIONMASK: flatbuffers::VOffsetT = 12;
    pub const VT_PLAYERSIDEMASK: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_GlobalBuffData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_GlobalBuffDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_GlobalBuffData<'bldr>> {
        let mut builder = clz_Torappu_LevelData_GlobalBuffDataBuilder::new(_fbb);
        builder.add_professionMask(args.professionMask);
        if let Some(x) = args.overrideCameraEffect {
            builder.add_overrideCameraEffect(x);
        }
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        if let Some(x) = args.prefabKey {
            builder.add_prefabKey(x);
        }
        builder.add_playerSideMask(args.playerSideMask);
        builder.add_passProfessionMaskFlag(args.passProfessionMaskFlag);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_GlobalBuffDataT {
        let prefabKey = self.prefabKey().map(|x| x.to_string());
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let overrideCameraEffect = self.overrideCameraEffect().map(|x| x.to_string());
        let passProfessionMaskFlag = self.passProfessionMaskFlag();
        let professionMask = self.professionMask();
        let playerSideMask = self.playerSideMask();
        clz_Torappu_LevelData_GlobalBuffDataT {
            prefabKey,
            blackboard,
            overrideCameraEffect,
            passProfessionMaskFlag,
            professionMask,
            playerSideMask,
        }
    }

    #[inline]
    pub fn prefabKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_GlobalBuffData::VT_PREFABKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_LevelData_GlobalBuffData::VT_BLACKBOARD, None)
        }
    }
    #[inline]
    pub fn overrideCameraEffect(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_GlobalBuffData::VT_OVERRIDECAMERAEFFECT,
                None,
            )
        }
    }
    #[inline]
    pub fn passProfessionMaskFlag(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_GlobalBuffData::VT_PASSPROFESSIONMASKFLAG,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn professionMask(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_LevelData_GlobalBuffData::VT_PROFESSIONMASK,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn playerSideMask(&self) -> enum__Torappu_PlayerSideMask {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_PlayerSideMask>(
                    clz_Torappu_LevelData_GlobalBuffData::VT_PLAYERSIDEMASK,
                    Some(enum__Torappu_PlayerSideMask::ALL),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_GlobalBuffData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "prefabKey",
                Self::VT_PREFABKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "overrideCameraEffect",
                Self::VT_OVERRIDECAMERAEFFECT,
                false,
            )?
            .visit_field::<bool>(
                "passProfessionMaskFlag",
                Self::VT_PASSPROFESSIONMASKFLAG,
                false,
            )?
            .visit_field::<enum__Torappu_ProfessionCategory>(
                "professionMask",
                Self::VT_PROFESSIONMASK,
                false,
            )?
            .visit_field::<enum__Torappu_PlayerSideMask>(
                "playerSideMask",
                Self::VT_PLAYERSIDEMASK,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_GlobalBuffDataArgs<'a> {
    pub prefabKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
    pub overrideCameraEffect: Option<flatbuffers::WIPOffset<&'a str>>,
    pub passProfessionMaskFlag: bool,
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub playerSideMask: enum__Torappu_PlayerSideMask,
}
impl<'a> Default for clz_Torappu_LevelData_GlobalBuffDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_GlobalBuffDataArgs {
            prefabKey: None,
            blackboard: None,
            overrideCameraEffect: None,
            passProfessionMaskFlag: false,
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            playerSideMask: enum__Torappu_PlayerSideMask::ALL,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_GlobalBuffData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LevelData_GlobalBuffData", 6)?;
        if let Some(f) = self.prefabKey() {
            s.serialize_field("prefabKey", &f)?;
        } else {
            s.skip_field("prefabKey")?;
        }
        if let Some(f) = self.blackboard() {
            s.serialize_field("blackboard", &f)?;
        } else {
            s.skip_field("blackboard")?;
        }
        if let Some(f) = self.overrideCameraEffect() {
            s.serialize_field("overrideCameraEffect", &f)?;
        } else {
            s.skip_field("overrideCameraEffect")?;
        }
        s.serialize_field("passProfessionMaskFlag", &self.passProfessionMaskFlag())?;
        s.serialize_field("professionMask", &self.professionMask())?;
        s.serialize_field("playerSideMask", &self.playerSideMask())?;
        s.end()
    }
}

pub struct clz_Torappu_LevelData_GlobalBuffDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LevelData_GlobalBuffDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_prefabKey(&mut self, prefabKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_GlobalBuffData::VT_PREFABKEY,
            prefabKey,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_GlobalBuffData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn add_overrideCameraEffect(
        &mut self,
        overrideCameraEffect: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_GlobalBuffData::VT_OVERRIDECAMERAEFFECT,
            overrideCameraEffect,
        );
    }
    #[inline]
    pub fn add_passProfessionMaskFlag(&mut self, passProfessionMaskFlag: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_GlobalBuffData::VT_PASSPROFESSIONMASKFLAG,
            passProfessionMaskFlag,
            false,
        );
    }
    #[inline]
    pub fn add_professionMask(&mut self, professionMask: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_LevelData_GlobalBuffData::VT_PROFESSIONMASK,
            professionMask,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_playerSideMask(&mut self, playerSideMask: enum__Torappu_PlayerSideMask) {
        self.fbb_.push_slot::<enum__Torappu_PlayerSideMask>(
            clz_Torappu_LevelData_GlobalBuffData::VT_PLAYERSIDEMASK,
            playerSideMask,
            enum__Torappu_PlayerSideMask::ALL,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_GlobalBuffDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_GlobalBuffDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_GlobalBuffData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_GlobalBuffData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_GlobalBuffData");
        ds.field("prefabKey", &self.prefabKey());
        ds.field("blackboard", &self.blackboard());
        ds.field("overrideCameraEffect", &self.overrideCameraEffect());
        ds.field("passProfessionMaskFlag", &self.passProfessionMaskFlag());
        ds.field("professionMask", &self.professionMask());
        ds.field("playerSideMask", &self.playerSideMask());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_GlobalBuffDataT {
    pub prefabKey: Option<String>,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
    pub overrideCameraEffect: Option<String>,
    pub passProfessionMaskFlag: bool,
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub playerSideMask: enum__Torappu_PlayerSideMask,
}
impl Default for clz_Torappu_LevelData_GlobalBuffDataT {
    fn default() -> Self {
        Self {
            prefabKey: None,
            blackboard: None,
            overrideCameraEffect: None,
            passProfessionMaskFlag: false,
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            playerSideMask: enum__Torappu_PlayerSideMask::ALL,
        }
    }
}
impl clz_Torappu_LevelData_GlobalBuffDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_GlobalBuffData<'b>> {
        let prefabKey = self.prefabKey.as_ref().map(|x| _fbb.create_string(x));
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let overrideCameraEffect = self
            .overrideCameraEffect
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let passProfessionMaskFlag = self.passProfessionMaskFlag;
        let professionMask = self.professionMask;
        let playerSideMask = self.playerSideMask;
        clz_Torappu_LevelData_GlobalBuffData::create(
            _fbb,
            &clz_Torappu_LevelData_GlobalBuffDataArgs {
                prefabKey,
                blackboard,
                overrideCameraEffect,
                passProfessionMaskFlag,
                professionMask,
                playerSideMask,
            },
        )
    }
}
pub enum clz_UnityEngine_Vector2Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_UnityEngine_Vector2<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_UnityEngine_Vector2<'a> {
    type Inner = clz_UnityEngine_Vector2<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_UnityEngine_Vector2<'a> {
    pub const VT_X: flatbuffers::VOffsetT = 4;
    pub const VT_Y: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_UnityEngine_Vector2 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_UnityEngine_Vector2Args,
    ) -> flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'bldr>> {
        let mut builder = clz_UnityEngine_Vector2Builder::new(_fbb);
        builder.add_y(args.y);
        builder.add_x(args.x);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_UnityEngine_Vector2T {
        let x = self.x();
        let y = self.y();
        clz_UnityEngine_Vector2T { x, y }
    }

    #[inline]
    pub fn x(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_UnityEngine_Vector2::VT_X, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn y(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_UnityEngine_Vector2::VT_Y, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_UnityEngine_Vector2<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("x", Self::VT_X, false)?
            .visit_field::<f32>("y", Self::VT_Y, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_UnityEngine_Vector2Args {
    pub x: f32,
    pub y: f32,
}
impl<'a> Default for clz_UnityEngine_Vector2Args {
    #[inline]
    fn default() -> Self {
        clz_UnityEngine_Vector2Args { x: 0.0, y: 0.0 }
    }
}

impl Serialize for clz_UnityEngine_Vector2<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_UnityEngine_Vector2", 2)?;
        s.serialize_field("x", &self.x())?;
        s.serialize_field("y", &self.y())?;
        s.end()
    }
}

pub struct clz_UnityEngine_Vector2Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_UnityEngine_Vector2Builder<'a, 'b, A> {
    #[inline]
    pub fn add_x(&mut self, x: f32) {
        self.fbb_
            .push_slot::<f32>(clz_UnityEngine_Vector2::VT_X, x, 0.0);
    }
    #[inline]
    pub fn add_y(&mut self, y: f32) {
        self.fbb_
            .push_slot::<f32>(clz_UnityEngine_Vector2::VT_Y, y, 0.0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_UnityEngine_Vector2Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_UnityEngine_Vector2Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_UnityEngine_Vector2<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_UnityEngine_Vector2");
        ds.field("x", &self.x());
        ds.field("y", &self.y());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_UnityEngine_Vector2T {
    pub x: f32,
    pub y: f32,
}
impl Default for clz_UnityEngine_Vector2T {
    fn default() -> Self {
        Self { x: 0.0, y: 0.0 }
    }
}
impl clz_UnityEngine_Vector2T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'b>> {
        let x = self.x;
        let y = self.y;
        clz_UnityEngine_Vector2::create(_fbb, &clz_UnityEngine_Vector2Args { x, y })
    }
}
pub enum clz_Torappu_RouteData_CheckpointDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RouteData_CheckpointData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RouteData_CheckpointData<'a> {
    type Inner = clz_Torappu_RouteData_CheckpointData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RouteData_CheckpointData<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_TIME: flatbuffers::VOffsetT = 6;
    pub const VT_POSITION: flatbuffers::VOffsetT = 8;
    pub const VT_REACHOFFSET: flatbuffers::VOffsetT = 10;
    pub const VT_RANDOMIZEREACHOFFSET: flatbuffers::VOffsetT = 12;
    pub const VT_REACHDISTANCE: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RouteData_CheckpointData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RouteData_CheckpointDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RouteData_CheckpointData<'bldr>> {
        let mut builder = clz_Torappu_RouteData_CheckpointDataBuilder::new(_fbb);
        builder.add_reachDistance(args.reachDistance);
        if let Some(x) = args.reachOffset {
            builder.add_reachOffset(x);
        }
        if let Some(x) = args.position {
            builder.add_position(x);
        }
        builder.add_time(args.time);
        builder.add_type_(args.type_);
        builder.add_randomizeReachOffset(args.randomizeReachOffset);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RouteData_CheckpointDataT {
        let type_ = self.type_();
        let time = self.time();
        let position = self.position().map(|x| Box::new(x.unpack()));
        let reachOffset = self.reachOffset().map(|x| Box::new(x.unpack()));
        let randomizeReachOffset = self.randomizeReachOffset();
        let reachDistance = self.reachDistance();
        clz_Torappu_RouteData_CheckpointDataT {
            type_,
            time,
            position,
            reachOffset,
            randomizeReachOffset,
            reachDistance,
        }
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_CheckpointType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_CheckpointType>(
                    clz_Torappu_RouteData_CheckpointData::VT_TYPE_,
                    Some(enum__Torappu_CheckpointType::MOVE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn time(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_RouteData_CheckpointData::VT_TIME, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn position(&self) -> Option<clz_Torappu_GridPosition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                    clz_Torappu_RouteData_CheckpointData::VT_POSITION,
                    None,
                )
        }
    }
    #[inline]
    pub fn reachOffset(&self) -> Option<clz_UnityEngine_Vector2<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                    clz_Torappu_RouteData_CheckpointData::VT_REACHOFFSET,
                    None,
                )
        }
    }
    #[inline]
    pub fn randomizeReachOffset(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RouteData_CheckpointData::VT_RANDOMIZEREACHOFFSET,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn reachDistance(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_RouteData_CheckpointData::VT_REACHDISTANCE,
                    Some(0.0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RouteData_CheckpointData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_CheckpointType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<f32>("time", Self::VT_TIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                "position",
                Self::VT_POSITION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                "reachOffset",
                Self::VT_REACHOFFSET,
                false,
            )?
            .visit_field::<bool>("randomizeReachOffset", Self::VT_RANDOMIZEREACHOFFSET, false)?
            .visit_field::<f32>("reachDistance", Self::VT_REACHDISTANCE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RouteData_CheckpointDataArgs<'a> {
    pub type_: enum__Torappu_CheckpointType,
    pub time: f32,
    pub position: Option<flatbuffers::WIPOffset<clz_Torappu_GridPosition<'a>>>,
    pub reachOffset: Option<flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>>>,
    pub randomizeReachOffset: bool,
    pub reachDistance: f32,
}
impl<'a> Default for clz_Torappu_RouteData_CheckpointDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RouteData_CheckpointDataArgs {
            type_: enum__Torappu_CheckpointType::MOVE,
            time: 0.0,
            position: None,
            reachOffset: None,
            randomizeReachOffset: false,
            reachDistance: 0.0,
        }
    }
}

impl Serialize for clz_Torappu_RouteData_CheckpointData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RouteData_CheckpointData", 6)?;
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("time", &self.time())?;
        if let Some(f) = self.position() {
            s.serialize_field("position", &f)?;
        } else {
            s.skip_field("position")?;
        }
        if let Some(f) = self.reachOffset() {
            s.serialize_field("reachOffset", &f)?;
        } else {
            s.skip_field("reachOffset")?;
        }
        s.serialize_field("randomizeReachOffset", &self.randomizeReachOffset())?;
        s.serialize_field("reachDistance", &self.reachDistance())?;
        s.end()
    }
}

pub struct clz_Torappu_RouteData_CheckpointDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RouteData_CheckpointDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_CheckpointType) {
        self.fbb_.push_slot::<enum__Torappu_CheckpointType>(
            clz_Torappu_RouteData_CheckpointData::VT_TYPE_,
            type_,
            enum__Torappu_CheckpointType::MOVE,
        );
    }
    #[inline]
    pub fn add_time(&mut self, time: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_RouteData_CheckpointData::VT_TIME, time, 0.0);
    }
    #[inline]
    pub fn add_position(&mut self, position: flatbuffers::WIPOffset<clz_Torappu_GridPosition<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_GridPosition>>(
                clz_Torappu_RouteData_CheckpointData::VT_POSITION,
                position,
            );
    }
    #[inline]
    pub fn add_reachOffset(
        &mut self,
        reachOffset: flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_UnityEngine_Vector2>>(
                clz_Torappu_RouteData_CheckpointData::VT_REACHOFFSET,
                reachOffset,
            );
    }
    #[inline]
    pub fn add_randomizeReachOffset(&mut self, randomizeReachOffset: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RouteData_CheckpointData::VT_RANDOMIZEREACHOFFSET,
            randomizeReachOffset,
            false,
        );
    }
    #[inline]
    pub fn add_reachDistance(&mut self, reachDistance: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_RouteData_CheckpointData::VT_REACHDISTANCE,
            reachDistance,
            0.0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RouteData_CheckpointDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RouteData_CheckpointDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RouteData_CheckpointData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RouteData_CheckpointData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RouteData_CheckpointData");
        ds.field("type_", &self.type_());
        ds.field("time", &self.time());
        ds.field("position", &self.position());
        ds.field("reachOffset", &self.reachOffset());
        ds.field("randomizeReachOffset", &self.randomizeReachOffset());
        ds.field("reachDistance", &self.reachDistance());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RouteData_CheckpointDataT {
    pub type_: enum__Torappu_CheckpointType,
    pub time: f32,
    pub position: Option<Box<clz_Torappu_GridPositionT>>,
    pub reachOffset: Option<Box<clz_UnityEngine_Vector2T>>,
    pub randomizeReachOffset: bool,
    pub reachDistance: f32,
}
impl Default for clz_Torappu_RouteData_CheckpointDataT {
    fn default() -> Self {
        Self {
            type_: enum__Torappu_CheckpointType::MOVE,
            time: 0.0,
            position: None,
            reachOffset: None,
            randomizeReachOffset: false,
            reachDistance: 0.0,
        }
    }
}
impl clz_Torappu_RouteData_CheckpointDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RouteData_CheckpointData<'b>> {
        let type_ = self.type_;
        let time = self.time;
        let position = self.position.as_ref().map(|x| x.pack(_fbb));
        let reachOffset = self.reachOffset.as_ref().map(|x| x.pack(_fbb));
        let randomizeReachOffset = self.randomizeReachOffset;
        let reachDistance = self.reachDistance;
        clz_Torappu_RouteData_CheckpointData::create(
            _fbb,
            &clz_Torappu_RouteData_CheckpointDataArgs {
                type_,
                time,
                position,
                reachOffset,
                randomizeReachOffset,
                reachDistance,
            },
        )
    }
}
pub enum clz_Torappu_RouteDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RouteData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RouteData<'a> {
    type Inner = clz_Torappu_RouteData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RouteData<'a> {
    pub const VT_MOTIONMODE: flatbuffers::VOffsetT = 4;
    pub const VT_STARTPOSITION: flatbuffers::VOffsetT = 6;
    pub const VT_ENDPOSITION: flatbuffers::VOffsetT = 8;
    pub const VT_SPAWNRANDOMRANGE: flatbuffers::VOffsetT = 10;
    pub const VT_SPAWNOFFSET: flatbuffers::VOffsetT = 12;
    pub const VT_CHECKPOINTS: flatbuffers::VOffsetT = 14;
    pub const VT_ALLOWDIAGONALMOVE: flatbuffers::VOffsetT = 16;
    pub const VT_VISITEVERYTILECENTER: flatbuffers::VOffsetT = 18;
    pub const VT_VISITEVERYNODECENTER: flatbuffers::VOffsetT = 20;
    pub const VT_VISITEVERYCHECKPOINT: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RouteData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RouteDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RouteData<'bldr>> {
        let mut builder = clz_Torappu_RouteDataBuilder::new(_fbb);
        if let Some(x) = args.checkpoints {
            builder.add_checkpoints(x);
        }
        if let Some(x) = args.spawnOffset {
            builder.add_spawnOffset(x);
        }
        if let Some(x) = args.spawnRandomRange {
            builder.add_spawnRandomRange(x);
        }
        if let Some(x) = args.endPosition {
            builder.add_endPosition(x);
        }
        if let Some(x) = args.startPosition {
            builder.add_startPosition(x);
        }
        builder.add_motionMode(args.motionMode);
        builder.add_visitEveryCheckPoint(args.visitEveryCheckPoint);
        builder.add_visitEveryNodeCenter(args.visitEveryNodeCenter);
        builder.add_visitEveryTileCenter(args.visitEveryTileCenter);
        builder.add_allowDiagonalMove(args.allowDiagonalMove);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RouteDataT {
        let motionMode = self.motionMode();
        let startPosition = self.startPosition().map(|x| Box::new(x.unpack()));
        let endPosition = self.endPosition().map(|x| Box::new(x.unpack()));
        let spawnRandomRange = self.spawnRandomRange().map(|x| Box::new(x.unpack()));
        let spawnOffset = self.spawnOffset().map(|x| Box::new(x.unpack()));
        let checkpoints = self
            .checkpoints()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let allowDiagonalMove = self.allowDiagonalMove();
        let visitEveryTileCenter = self.visitEveryTileCenter();
        let visitEveryNodeCenter = self.visitEveryNodeCenter();
        let visitEveryCheckPoint = self.visitEveryCheckPoint();
        clz_Torappu_RouteDataT {
            motionMode,
            startPosition,
            endPosition,
            spawnRandomRange,
            spawnOffset,
            checkpoints,
            allowDiagonalMove,
            visitEveryTileCenter,
            visitEveryNodeCenter,
            visitEveryCheckPoint,
        }
    }

    #[inline]
    pub fn motionMode(&self) -> enum__Torappu_MotionMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_MotionMode>(
                    clz_Torappu_RouteData::VT_MOTIONMODE,
                    Some(enum__Torappu_MotionMode::WALK),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn startPosition(&self) -> Option<clz_Torappu_GridPosition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                    clz_Torappu_RouteData::VT_STARTPOSITION,
                    None,
                )
        }
    }
    #[inline]
    pub fn endPosition(&self) -> Option<clz_Torappu_GridPosition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                    clz_Torappu_RouteData::VT_ENDPOSITION,
                    None,
                )
        }
    }
    #[inline]
    pub fn spawnRandomRange(&self) -> Option<clz_UnityEngine_Vector2<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                    clz_Torappu_RouteData::VT_SPAWNRANDOMRANGE,
                    None,
                )
        }
    }
    #[inline]
    pub fn spawnOffset(&self) -> Option<clz_UnityEngine_Vector2<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                    clz_Torappu_RouteData::VT_SPAWNOFFSET,
                    None,
                )
        }
    }
    #[inline]
    pub fn checkpoints(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_RouteData_CheckpointData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RouteData_CheckpointData>,
                >,
            >>(clz_Torappu_RouteData::VT_CHECKPOINTS, None)
        }
    }
    #[inline]
    pub fn allowDiagonalMove(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_RouteData::VT_ALLOWDIAGONALMOVE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn visitEveryTileCenter(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_RouteData::VT_VISITEVERYTILECENTER, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn visitEveryNodeCenter(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_RouteData::VT_VISITEVERYNODECENTER, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn visitEveryCheckPoint(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_RouteData::VT_VISITEVERYCHECKPOINT, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RouteData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_MotionMode>("motionMode", Self::VT_MOTIONMODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                "startPosition",
                Self::VT_STARTPOSITION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                "endPosition",
                Self::VT_ENDPOSITION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                "spawnRandomRange",
                Self::VT_SPAWNRANDOMRANGE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_UnityEngine_Vector2>>(
                "spawnOffset",
                Self::VT_SPAWNOFFSET,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RouteData_CheckpointData>,
                >,
            >>("checkpoints", Self::VT_CHECKPOINTS, false)?
            .visit_field::<bool>("allowDiagonalMove", Self::VT_ALLOWDIAGONALMOVE, false)?
            .visit_field::<bool>("visitEveryTileCenter", Self::VT_VISITEVERYTILECENTER, false)?
            .visit_field::<bool>("visitEveryNodeCenter", Self::VT_VISITEVERYNODECENTER, false)?
            .visit_field::<bool>("visitEveryCheckPoint", Self::VT_VISITEVERYCHECKPOINT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RouteDataArgs<'a> {
    pub motionMode: enum__Torappu_MotionMode,
    pub startPosition: Option<flatbuffers::WIPOffset<clz_Torappu_GridPosition<'a>>>,
    pub endPosition: Option<flatbuffers::WIPOffset<clz_Torappu_GridPosition<'a>>>,
    pub spawnRandomRange: Option<flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>>>,
    pub spawnOffset: Option<flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'a>>>,
    pub checkpoints: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RouteData_CheckpointData<'a>>,
            >,
        >,
    >,
    pub allowDiagonalMove: bool,
    pub visitEveryTileCenter: bool,
    pub visitEveryNodeCenter: bool,
    pub visitEveryCheckPoint: bool,
}
impl<'a> Default for clz_Torappu_RouteDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RouteDataArgs {
            motionMode: enum__Torappu_MotionMode::WALK,
            startPosition: None,
            endPosition: None,
            spawnRandomRange: None,
            spawnOffset: None,
            checkpoints: None,
            allowDiagonalMove: false,
            visitEveryTileCenter: false,
            visitEveryNodeCenter: false,
            visitEveryCheckPoint: false,
        }
    }
}

impl Serialize for clz_Torappu_RouteData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RouteData", 10)?;
        s.serialize_field("motionMode", &self.motionMode())?;
        if let Some(f) = self.startPosition() {
            s.serialize_field("startPosition", &f)?;
        } else {
            s.skip_field("startPosition")?;
        }
        if let Some(f) = self.endPosition() {
            s.serialize_field("endPosition", &f)?;
        } else {
            s.skip_field("endPosition")?;
        }
        if let Some(f) = self.spawnRandomRange() {
            s.serialize_field("spawnRandomRange", &f)?;
        } else {
            s.skip_field("spawnRandomRange")?;
        }
        if let Some(f) = self.spawnOffset() {
            s.serialize_field("spawnOffset", &f)?;
        } else {
            s.skip_field("spawnOffset")?;
        }
        if let Some(f) = self.checkpoints() {
            s.serialize_field("checkpoints", &f)?;
        } else {
            s.skip_field("checkpoints")?;
        }
        s.serialize_field("allowDiagonalMove", &self.allowDiagonalMove())?;
        s.serialize_field("visitEveryTileCenter", &self.visitEveryTileCenter())?;
        s.serialize_field("visitEveryNodeCenter", &self.visitEveryNodeCenter())?;
        s.serialize_field("visitEveryCheckPoint", &self.visitEveryCheckPoint())?;
        s.end()
    }
}

pub struct clz_Torappu_RouteDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RouteDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_motionMode(&mut self, motionMode: enum__Torappu_MotionMode) {
        self.fbb_.push_slot::<enum__Torappu_MotionMode>(
            clz_Torappu_RouteData::VT_MOTIONMODE,
            motionMode,
            enum__Torappu_MotionMode::WALK,
        );
    }
    #[inline]
    pub fn add_startPosition(
        &mut self,
        startPosition: flatbuffers::WIPOffset<clz_Torappu_GridPosition<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_GridPosition>>(
                clz_Torappu_RouteData::VT_STARTPOSITION,
                startPosition,
            );
    }
    #[inline]
    pub fn add_endPosition(
        &mut self,
        endPosition: flatbuffers::WIPOffset<clz_Torappu_GridPosition<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_GridPosition>>(
                clz_Torappu_RouteData::VT_ENDPOSITION,
                endPosition,
            );
    }
    #[inline]
    pub fn add_spawnRandomRange(
        &mut self,
        spawnRandomRange: flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_UnityEngine_Vector2>>(
                clz_Torappu_RouteData::VT_SPAWNRANDOMRANGE,
                spawnRandomRange,
            );
    }
    #[inline]
    pub fn add_spawnOffset(
        &mut self,
        spawnOffset: flatbuffers::WIPOffset<clz_UnityEngine_Vector2<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_UnityEngine_Vector2>>(
                clz_Torappu_RouteData::VT_SPAWNOFFSET,
                spawnOffset,
            );
    }
    #[inline]
    pub fn add_checkpoints(
        &mut self,
        checkpoints: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RouteData_CheckpointData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RouteData::VT_CHECKPOINTS,
            checkpoints,
        );
    }
    #[inline]
    pub fn add_allowDiagonalMove(&mut self, allowDiagonalMove: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RouteData::VT_ALLOWDIAGONALMOVE,
            allowDiagonalMove,
            false,
        );
    }
    #[inline]
    pub fn add_visitEveryTileCenter(&mut self, visitEveryTileCenter: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RouteData::VT_VISITEVERYTILECENTER,
            visitEveryTileCenter,
            false,
        );
    }
    #[inline]
    pub fn add_visitEveryNodeCenter(&mut self, visitEveryNodeCenter: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RouteData::VT_VISITEVERYNODECENTER,
            visitEveryNodeCenter,
            false,
        );
    }
    #[inline]
    pub fn add_visitEveryCheckPoint(&mut self, visitEveryCheckPoint: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RouteData::VT_VISITEVERYCHECKPOINT,
            visitEveryCheckPoint,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RouteDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RouteDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RouteData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RouteData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RouteData");
        ds.field("motionMode", &self.motionMode());
        ds.field("startPosition", &self.startPosition());
        ds.field("endPosition", &self.endPosition());
        ds.field("spawnRandomRange", &self.spawnRandomRange());
        ds.field("spawnOffset", &self.spawnOffset());
        ds.field("checkpoints", &self.checkpoints());
        ds.field("allowDiagonalMove", &self.allowDiagonalMove());
        ds.field("visitEveryTileCenter", &self.visitEveryTileCenter());
        ds.field("visitEveryNodeCenter", &self.visitEveryNodeCenter());
        ds.field("visitEveryCheckPoint", &self.visitEveryCheckPoint());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RouteDataT {
    pub motionMode: enum__Torappu_MotionMode,
    pub startPosition: Option<Box<clz_Torappu_GridPositionT>>,
    pub endPosition: Option<Box<clz_Torappu_GridPositionT>>,
    pub spawnRandomRange: Option<Box<clz_UnityEngine_Vector2T>>,
    pub spawnOffset: Option<Box<clz_UnityEngine_Vector2T>>,
    pub checkpoints: Option<Vec<clz_Torappu_RouteData_CheckpointDataT>>,
    pub allowDiagonalMove: bool,
    pub visitEveryTileCenter: bool,
    pub visitEveryNodeCenter: bool,
    pub visitEveryCheckPoint: bool,
}
impl Default for clz_Torappu_RouteDataT {
    fn default() -> Self {
        Self {
            motionMode: enum__Torappu_MotionMode::WALK,
            startPosition: None,
            endPosition: None,
            spawnRandomRange: None,
            spawnOffset: None,
            checkpoints: None,
            allowDiagonalMove: false,
            visitEveryTileCenter: false,
            visitEveryNodeCenter: false,
            visitEveryCheckPoint: false,
        }
    }
}
impl clz_Torappu_RouteDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RouteData<'b>> {
        let motionMode = self.motionMode;
        let startPosition = self.startPosition.as_ref().map(|x| x.pack(_fbb));
        let endPosition = self.endPosition.as_ref().map(|x| x.pack(_fbb));
        let spawnRandomRange = self.spawnRandomRange.as_ref().map(|x| x.pack(_fbb));
        let spawnOffset = self.spawnOffset.as_ref().map(|x| x.pack(_fbb));
        let checkpoints = self.checkpoints.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let allowDiagonalMove = self.allowDiagonalMove;
        let visitEveryTileCenter = self.visitEveryTileCenter;
        let visitEveryNodeCenter = self.visitEveryNodeCenter;
        let visitEveryCheckPoint = self.visitEveryCheckPoint;
        clz_Torappu_RouteData::create(
            _fbb,
            &clz_Torappu_RouteDataArgs {
                motionMode,
                startPosition,
                endPosition,
                spawnRandomRange,
                spawnOffset,
                checkpoints,
                allowDiagonalMove,
                visitEveryTileCenter,
                visitEveryNodeCenter,
                visitEveryCheckPoint,
            },
        )
    }
}
pub enum clz_Torappu_AttributesDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_AttributesData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_AttributesData<'a> {
    type Inner = clz_Torappu_AttributesData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_AttributesData<'a> {
    pub const VT_MAXHP: flatbuffers::VOffsetT = 4;
    pub const VT_ATK: flatbuffers::VOffsetT = 6;
    pub const VT_DEF: flatbuffers::VOffsetT = 8;
    pub const VT_MAGICRESISTANCE: flatbuffers::VOffsetT = 10;
    pub const VT_COST: flatbuffers::VOffsetT = 12;
    pub const VT_BLOCKCNT: flatbuffers::VOffsetT = 14;
    pub const VT_MOVESPEED: flatbuffers::VOffsetT = 16;
    pub const VT_ATTACKSPEED: flatbuffers::VOffsetT = 18;
    pub const VT_BASEATTACKTIME: flatbuffers::VOffsetT = 20;
    pub const VT_RESPAWNTIME: flatbuffers::VOffsetT = 22;
    pub const VT_HPRECOVERYPERSEC: flatbuffers::VOffsetT = 24;
    pub const VT_SPRECOVERYPERSEC: flatbuffers::VOffsetT = 26;
    pub const VT_MAXDEPLOYCOUNT: flatbuffers::VOffsetT = 28;
    pub const VT_MAXDECKSTACKCNT: flatbuffers::VOffsetT = 30;
    pub const VT_TAUNTLEVEL: flatbuffers::VOffsetT = 32;
    pub const VT_MASSLEVEL: flatbuffers::VOffsetT = 34;
    pub const VT_BASEFORCELEVEL: flatbuffers::VOffsetT = 36;
    pub const VT_STUNIMMUNE: flatbuffers::VOffsetT = 38;
    pub const VT_SILENCEIMMUNE: flatbuffers::VOffsetT = 40;
    pub const VT_SLEEPIMMUNE: flatbuffers::VOffsetT = 42;
    pub const VT_FROZENIMMUNE: flatbuffers::VOffsetT = 44;
    pub const VT_LEVITATEIMMUNE: flatbuffers::VOffsetT = 46;
    pub const VT_DISARMEDCOMBATIMMUNE: flatbuffers::VOffsetT = 48;
    pub const VT_FEAREDIMMUNE: flatbuffers::VOffsetT = 50;
    pub const VT_PALSYIMMUNE: flatbuffers::VOffsetT = 52;
    pub const VT_ATTRACTIMMUNE: flatbuffers::VOffsetT = 54;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_AttributesData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_AttributesDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributesData<'bldr>> {
        let mut builder = clz_Torappu_AttributesDataBuilder::new(_fbb);
        builder.add_baseForceLevel(args.baseForceLevel);
        builder.add_massLevel(args.massLevel);
        builder.add_tauntLevel(args.tauntLevel);
        builder.add_maxDeckStackCnt(args.maxDeckStackCnt);
        builder.add_maxDeployCount(args.maxDeployCount);
        builder.add_spRecoveryPerSec(args.spRecoveryPerSec);
        builder.add_hpRecoveryPerSec(args.hpRecoveryPerSec);
        builder.add_respawnTime(args.respawnTime);
        builder.add_baseAttackTime(args.baseAttackTime);
        builder.add_attackSpeed(args.attackSpeed);
        builder.add_moveSpeed(args.moveSpeed);
        builder.add_blockCnt(args.blockCnt);
        builder.add_cost(args.cost);
        builder.add_magicResistance(args.magicResistance);
        builder.add_def(args.def);
        builder.add_atk(args.atk);
        builder.add_maxHp(args.maxHp);
        builder.add_attractImmune(args.attractImmune);
        builder.add_palsyImmune(args.palsyImmune);
        builder.add_fearedImmune(args.fearedImmune);
        builder.add_disarmedCombatImmune(args.disarmedCombatImmune);
        builder.add_levitateImmune(args.levitateImmune);
        builder.add_frozenImmune(args.frozenImmune);
        builder.add_sleepImmune(args.sleepImmune);
        builder.add_silenceImmune(args.silenceImmune);
        builder.add_stunImmune(args.stunImmune);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_AttributesDataT {
        let maxHp = self.maxHp();
        let atk = self.atk();
        let def = self.def();
        let magicResistance = self.magicResistance();
        let cost = self.cost();
        let blockCnt = self.blockCnt();
        let moveSpeed = self.moveSpeed();
        let attackSpeed = self.attackSpeed();
        let baseAttackTime = self.baseAttackTime();
        let respawnTime = self.respawnTime();
        let hpRecoveryPerSec = self.hpRecoveryPerSec();
        let spRecoveryPerSec = self.spRecoveryPerSec();
        let maxDeployCount = self.maxDeployCount();
        let maxDeckStackCnt = self.maxDeckStackCnt();
        let tauntLevel = self.tauntLevel();
        let massLevel = self.massLevel();
        let baseForceLevel = self.baseForceLevel();
        let stunImmune = self.stunImmune();
        let silenceImmune = self.silenceImmune();
        let sleepImmune = self.sleepImmune();
        let frozenImmune = self.frozenImmune();
        let levitateImmune = self.levitateImmune();
        let disarmedCombatImmune = self.disarmedCombatImmune();
        let fearedImmune = self.fearedImmune();
        let palsyImmune = self.palsyImmune();
        let attractImmune = self.attractImmune();
        clz_Torappu_AttributesDataT {
            maxHp,
            atk,
            def,
            magicResistance,
            cost,
            blockCnt,
            moveSpeed,
            attackSpeed,
            baseAttackTime,
            respawnTime,
            hpRecoveryPerSec,
            spRecoveryPerSec,
            maxDeployCount,
            maxDeckStackCnt,
            tauntLevel,
            massLevel,
            baseForceLevel,
            stunImmune,
            silenceImmune,
            sleepImmune,
            frozenImmune,
            levitateImmune,
            disarmedCombatImmune,
            fearedImmune,
            palsyImmune,
            attractImmune,
        }
    }

    #[inline]
    pub fn maxHp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_MAXHP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn atk(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_ATK, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn def(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_DEF, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn magicResistance(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_AttributesData::VT_MAGICRESISTANCE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn cost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_COST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn blockCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_BLOCKCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn moveSpeed(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_AttributesData::VT_MOVESPEED, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn attackSpeed(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_AttributesData::VT_ATTACKSPEED, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn baseAttackTime(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_AttributesData::VT_BASEATTACKTIME, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn respawnTime(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_RESPAWNTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn hpRecoveryPerSec(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_AttributesData::VT_HPRECOVERYPERSEC, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn spRecoveryPerSec(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_AttributesData::VT_SPRECOVERYPERSEC, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn maxDeployCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_MAXDEPLOYCOUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn maxDeckStackCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_MAXDECKSTACKCNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn tauntLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_TAUNTLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn massLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_MASSLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn baseForceLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_AttributesData::VT_BASEFORCELEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn stunImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_STUNIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn silenceImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_SILENCEIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn sleepImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_SLEEPIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn frozenImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_FROZENIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn levitateImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_LEVITATEIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn disarmedCombatImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_AttributesData::VT_DISARMEDCOMBATIMMUNE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fearedImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_FEAREDIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn palsyImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_PALSYIMMUNE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn attractImmune(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_AttributesData::VT_ATTRACTIMMUNE, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_AttributesData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("maxHp", Self::VT_MAXHP, false)?
            .visit_field::<i32>("atk", Self::VT_ATK, false)?
            .visit_field::<i32>("def", Self::VT_DEF, false)?
            .visit_field::<f32>("magicResistance", Self::VT_MAGICRESISTANCE, false)?
            .visit_field::<i32>("cost", Self::VT_COST, false)?
            .visit_field::<i32>("blockCnt", Self::VT_BLOCKCNT, false)?
            .visit_field::<f32>("moveSpeed", Self::VT_MOVESPEED, false)?
            .visit_field::<f32>("attackSpeed", Self::VT_ATTACKSPEED, false)?
            .visit_field::<f32>("baseAttackTime", Self::VT_BASEATTACKTIME, false)?
            .visit_field::<i32>("respawnTime", Self::VT_RESPAWNTIME, false)?
            .visit_field::<f32>("hpRecoveryPerSec", Self::VT_HPRECOVERYPERSEC, false)?
            .visit_field::<f32>("spRecoveryPerSec", Self::VT_SPRECOVERYPERSEC, false)?
            .visit_field::<i32>("maxDeployCount", Self::VT_MAXDEPLOYCOUNT, false)?
            .visit_field::<i32>("maxDeckStackCnt", Self::VT_MAXDECKSTACKCNT, false)?
            .visit_field::<i32>("tauntLevel", Self::VT_TAUNTLEVEL, false)?
            .visit_field::<i32>("massLevel", Self::VT_MASSLEVEL, false)?
            .visit_field::<i32>("baseForceLevel", Self::VT_BASEFORCELEVEL, false)?
            .visit_field::<bool>("stunImmune", Self::VT_STUNIMMUNE, false)?
            .visit_field::<bool>("silenceImmune", Self::VT_SILENCEIMMUNE, false)?
            .visit_field::<bool>("sleepImmune", Self::VT_SLEEPIMMUNE, false)?
            .visit_field::<bool>("frozenImmune", Self::VT_FROZENIMMUNE, false)?
            .visit_field::<bool>("levitateImmune", Self::VT_LEVITATEIMMUNE, false)?
            .visit_field::<bool>("disarmedCombatImmune", Self::VT_DISARMEDCOMBATIMMUNE, false)?
            .visit_field::<bool>("fearedImmune", Self::VT_FEAREDIMMUNE, false)?
            .visit_field::<bool>("palsyImmune", Self::VT_PALSYIMMUNE, false)?
            .visit_field::<bool>("attractImmune", Self::VT_ATTRACTIMMUNE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_AttributesDataArgs {
    pub maxHp: i32,
    pub atk: i32,
    pub def: i32,
    pub magicResistance: f32,
    pub cost: i32,
    pub blockCnt: i32,
    pub moveSpeed: f32,
    pub attackSpeed: f32,
    pub baseAttackTime: f32,
    pub respawnTime: i32,
    pub hpRecoveryPerSec: f32,
    pub spRecoveryPerSec: f32,
    pub maxDeployCount: i32,
    pub maxDeckStackCnt: i32,
    pub tauntLevel: i32,
    pub massLevel: i32,
    pub baseForceLevel: i32,
    pub stunImmune: bool,
    pub silenceImmune: bool,
    pub sleepImmune: bool,
    pub frozenImmune: bool,
    pub levitateImmune: bool,
    pub disarmedCombatImmune: bool,
    pub fearedImmune: bool,
    pub palsyImmune: bool,
    pub attractImmune: bool,
}
impl<'a> Default for clz_Torappu_AttributesDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_AttributesDataArgs {
            maxHp: 0,
            atk: 0,
            def: 0,
            magicResistance: 0.0,
            cost: 0,
            blockCnt: 0,
            moveSpeed: 0.0,
            attackSpeed: 0.0,
            baseAttackTime: 0.0,
            respawnTime: 0,
            hpRecoveryPerSec: 0.0,
            spRecoveryPerSec: 0.0,
            maxDeployCount: 0,
            maxDeckStackCnt: 0,
            tauntLevel: 0,
            massLevel: 0,
            baseForceLevel: 0,
            stunImmune: false,
            silenceImmune: false,
            sleepImmune: false,
            frozenImmune: false,
            levitateImmune: false,
            disarmedCombatImmune: false,
            fearedImmune: false,
            palsyImmune: false,
            attractImmune: false,
        }
    }
}

impl Serialize for clz_Torappu_AttributesData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_AttributesData", 26)?;
        s.serialize_field("maxHp", &self.maxHp())?;
        s.serialize_field("atk", &self.atk())?;
        s.serialize_field("def", &self.def())?;
        s.serialize_field("magicResistance", &self.magicResistance())?;
        s.serialize_field("cost", &self.cost())?;
        s.serialize_field("blockCnt", &self.blockCnt())?;
        s.serialize_field("moveSpeed", &self.moveSpeed())?;
        s.serialize_field("attackSpeed", &self.attackSpeed())?;
        s.serialize_field("baseAttackTime", &self.baseAttackTime())?;
        s.serialize_field("respawnTime", &self.respawnTime())?;
        s.serialize_field("hpRecoveryPerSec", &self.hpRecoveryPerSec())?;
        s.serialize_field("spRecoveryPerSec", &self.spRecoveryPerSec())?;
        s.serialize_field("maxDeployCount", &self.maxDeployCount())?;
        s.serialize_field("maxDeckStackCnt", &self.maxDeckStackCnt())?;
        s.serialize_field("tauntLevel", &self.tauntLevel())?;
        s.serialize_field("massLevel", &self.massLevel())?;
        s.serialize_field("baseForceLevel", &self.baseForceLevel())?;
        s.serialize_field("stunImmune", &self.stunImmune())?;
        s.serialize_field("silenceImmune", &self.silenceImmune())?;
        s.serialize_field("sleepImmune", &self.sleepImmune())?;
        s.serialize_field("frozenImmune", &self.frozenImmune())?;
        s.serialize_field("levitateImmune", &self.levitateImmune())?;
        s.serialize_field("disarmedCombatImmune", &self.disarmedCombatImmune())?;
        s.serialize_field("fearedImmune", &self.fearedImmune())?;
        s.serialize_field("palsyImmune", &self.palsyImmune())?;
        s.serialize_field("attractImmune", &self.attractImmune())?;
        s.end()
    }
}

pub struct clz_Torappu_AttributesDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_AttributesDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_maxHp(&mut self, maxHp: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_MAXHP, maxHp, 0);
    }
    #[inline]
    pub fn add_atk(&mut self, atk: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_ATK, atk, 0);
    }
    #[inline]
    pub fn add_def(&mut self, def: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_DEF, def, 0);
    }
    #[inline]
    pub fn add_magicResistance(&mut self, magicResistance: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributesData::VT_MAGICRESISTANCE,
            magicResistance,
            0.0,
        );
    }
    #[inline]
    pub fn add_cost(&mut self, cost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_COST, cost, 0);
    }
    #[inline]
    pub fn add_blockCnt(&mut self, blockCnt: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_BLOCKCNT, blockCnt, 0);
    }
    #[inline]
    pub fn add_moveSpeed(&mut self, moveSpeed: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_AttributesData::VT_MOVESPEED, moveSpeed, 0.0);
    }
    #[inline]
    pub fn add_attackSpeed(&mut self, attackSpeed: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_AttributesData::VT_ATTACKSPEED, attackSpeed, 0.0);
    }
    #[inline]
    pub fn add_baseAttackTime(&mut self, baseAttackTime: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributesData::VT_BASEATTACKTIME,
            baseAttackTime,
            0.0,
        );
    }
    #[inline]
    pub fn add_respawnTime(&mut self, respawnTime: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_RESPAWNTIME, respawnTime, 0);
    }
    #[inline]
    pub fn add_hpRecoveryPerSec(&mut self, hpRecoveryPerSec: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributesData::VT_HPRECOVERYPERSEC,
            hpRecoveryPerSec,
            0.0,
        );
    }
    #[inline]
    pub fn add_spRecoveryPerSec(&mut self, spRecoveryPerSec: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_AttributesData::VT_SPRECOVERYPERSEC,
            spRecoveryPerSec,
            0.0,
        );
    }
    #[inline]
    pub fn add_maxDeployCount(&mut self, maxDeployCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_AttributesData::VT_MAXDEPLOYCOUNT,
            maxDeployCount,
            0,
        );
    }
    #[inline]
    pub fn add_maxDeckStackCnt(&mut self, maxDeckStackCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_AttributesData::VT_MAXDECKSTACKCNT,
            maxDeckStackCnt,
            0,
        );
    }
    #[inline]
    pub fn add_tauntLevel(&mut self, tauntLevel: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_TAUNTLEVEL, tauntLevel, 0);
    }
    #[inline]
    pub fn add_massLevel(&mut self, massLevel: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_AttributesData::VT_MASSLEVEL, massLevel, 0);
    }
    #[inline]
    pub fn add_baseForceLevel(&mut self, baseForceLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_AttributesData::VT_BASEFORCELEVEL,
            baseForceLevel,
            0,
        );
    }
    #[inline]
    pub fn add_stunImmune(&mut self, stunImmune: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_AttributesData::VT_STUNIMMUNE, stunImmune, false);
    }
    #[inline]
    pub fn add_silenceImmune(&mut self, silenceImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_SILENCEIMMUNE,
            silenceImmune,
            false,
        );
    }
    #[inline]
    pub fn add_sleepImmune(&mut self, sleepImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_SLEEPIMMUNE,
            sleepImmune,
            false,
        );
    }
    #[inline]
    pub fn add_frozenImmune(&mut self, frozenImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_FROZENIMMUNE,
            frozenImmune,
            false,
        );
    }
    #[inline]
    pub fn add_levitateImmune(&mut self, levitateImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_LEVITATEIMMUNE,
            levitateImmune,
            false,
        );
    }
    #[inline]
    pub fn add_disarmedCombatImmune(&mut self, disarmedCombatImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_DISARMEDCOMBATIMMUNE,
            disarmedCombatImmune,
            false,
        );
    }
    #[inline]
    pub fn add_fearedImmune(&mut self, fearedImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_FEAREDIMMUNE,
            fearedImmune,
            false,
        );
    }
    #[inline]
    pub fn add_palsyImmune(&mut self, palsyImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_PALSYIMMUNE,
            palsyImmune,
            false,
        );
    }
    #[inline]
    pub fn add_attractImmune(&mut self, attractImmune: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_AttributesData::VT_ATTRACTIMMUNE,
            attractImmune,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_AttributesDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_AttributesDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_AttributesData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_AttributesData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_AttributesData");
        ds.field("maxHp", &self.maxHp());
        ds.field("atk", &self.atk());
        ds.field("def", &self.def());
        ds.field("magicResistance", &self.magicResistance());
        ds.field("cost", &self.cost());
        ds.field("blockCnt", &self.blockCnt());
        ds.field("moveSpeed", &self.moveSpeed());
        ds.field("attackSpeed", &self.attackSpeed());
        ds.field("baseAttackTime", &self.baseAttackTime());
        ds.field("respawnTime", &self.respawnTime());
        ds.field("hpRecoveryPerSec", &self.hpRecoveryPerSec());
        ds.field("spRecoveryPerSec", &self.spRecoveryPerSec());
        ds.field("maxDeployCount", &self.maxDeployCount());
        ds.field("maxDeckStackCnt", &self.maxDeckStackCnt());
        ds.field("tauntLevel", &self.tauntLevel());
        ds.field("massLevel", &self.massLevel());
        ds.field("baseForceLevel", &self.baseForceLevel());
        ds.field("stunImmune", &self.stunImmune());
        ds.field("silenceImmune", &self.silenceImmune());
        ds.field("sleepImmune", &self.sleepImmune());
        ds.field("frozenImmune", &self.frozenImmune());
        ds.field("levitateImmune", &self.levitateImmune());
        ds.field("disarmedCombatImmune", &self.disarmedCombatImmune());
        ds.field("fearedImmune", &self.fearedImmune());
        ds.field("palsyImmune", &self.palsyImmune());
        ds.field("attractImmune", &self.attractImmune());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_AttributesDataT {
    pub maxHp: i32,
    pub atk: i32,
    pub def: i32,
    pub magicResistance: f32,
    pub cost: i32,
    pub blockCnt: i32,
    pub moveSpeed: f32,
    pub attackSpeed: f32,
    pub baseAttackTime: f32,
    pub respawnTime: i32,
    pub hpRecoveryPerSec: f32,
    pub spRecoveryPerSec: f32,
    pub maxDeployCount: i32,
    pub maxDeckStackCnt: i32,
    pub tauntLevel: i32,
    pub massLevel: i32,
    pub baseForceLevel: i32,
    pub stunImmune: bool,
    pub silenceImmune: bool,
    pub sleepImmune: bool,
    pub frozenImmune: bool,
    pub levitateImmune: bool,
    pub disarmedCombatImmune: bool,
    pub fearedImmune: bool,
    pub palsyImmune: bool,
    pub attractImmune: bool,
}
impl Default for clz_Torappu_AttributesDataT {
    fn default() -> Self {
        Self {
            maxHp: 0,
            atk: 0,
            def: 0,
            magicResistance: 0.0,
            cost: 0,
            blockCnt: 0,
            moveSpeed: 0.0,
            attackSpeed: 0.0,
            baseAttackTime: 0.0,
            respawnTime: 0,
            hpRecoveryPerSec: 0.0,
            spRecoveryPerSec: 0.0,
            maxDeployCount: 0,
            maxDeckStackCnt: 0,
            tauntLevel: 0,
            massLevel: 0,
            baseForceLevel: 0,
            stunImmune: false,
            silenceImmune: false,
            sleepImmune: false,
            frozenImmune: false,
            levitateImmune: false,
            disarmedCombatImmune: false,
            fearedImmune: false,
            palsyImmune: false,
            attractImmune: false,
        }
    }
}
impl clz_Torappu_AttributesDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_AttributesData<'b>> {
        let maxHp = self.maxHp;
        let atk = self.atk;
        let def = self.def;
        let magicResistance = self.magicResistance;
        let cost = self.cost;
        let blockCnt = self.blockCnt;
        let moveSpeed = self.moveSpeed;
        let attackSpeed = self.attackSpeed;
        let baseAttackTime = self.baseAttackTime;
        let respawnTime = self.respawnTime;
        let hpRecoveryPerSec = self.hpRecoveryPerSec;
        let spRecoveryPerSec = self.spRecoveryPerSec;
        let maxDeployCount = self.maxDeployCount;
        let maxDeckStackCnt = self.maxDeckStackCnt;
        let tauntLevel = self.tauntLevel;
        let massLevel = self.massLevel;
        let baseForceLevel = self.baseForceLevel;
        let stunImmune = self.stunImmune;
        let silenceImmune = self.silenceImmune;
        let sleepImmune = self.sleepImmune;
        let frozenImmune = self.frozenImmune;
        let levitateImmune = self.levitateImmune;
        let disarmedCombatImmune = self.disarmedCombatImmune;
        let fearedImmune = self.fearedImmune;
        let palsyImmune = self.palsyImmune;
        let attractImmune = self.attractImmune;
        clz_Torappu_AttributesData::create(
            _fbb,
            &clz_Torappu_AttributesDataArgs {
                maxHp,
                atk,
                def,
                magicResistance,
                cost,
                blockCnt,
                moveSpeed,
                attackSpeed,
                baseAttackTime,
                respawnTime,
                hpRecoveryPerSec,
                spRecoveryPerSec,
                maxDeployCount,
                maxDeckStackCnt,
                tauntLevel,
                massLevel,
                baseForceLevel,
                stunImmune,
                silenceImmune,
                sleepImmune,
                frozenImmune,
                levitateImmune,
                disarmedCombatImmune,
                fearedImmune,
                palsyImmune,
                attractImmune,
            },
        )
    }
}
pub enum clz_Torappu_LevelData_EnemyData_ESkillDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_EnemyData_ESkillData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_EnemyData_ESkillData<'a> {
    type Inner = clz_Torappu_LevelData_EnemyData_ESkillData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_EnemyData_ESkillData<'a> {
    pub const VT_PREFABKEY: flatbuffers::VOffsetT = 4;
    pub const VT_PRIORITY: flatbuffers::VOffsetT = 6;
    pub const VT_COOLDOWN: flatbuffers::VOffsetT = 8;
    pub const VT_INITCOOLDOWN: flatbuffers::VOffsetT = 10;
    pub const VT_SPCOST: flatbuffers::VOffsetT = 12;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_EnemyData_ESkillData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_EnemyData_ESkillDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESkillData<'bldr>> {
        let mut builder = clz_Torappu_LevelData_EnemyData_ESkillDataBuilder::new(_fbb);
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        builder.add_spCost(args.spCost);
        builder.add_initCooldown(args.initCooldown);
        builder.add_cooldown(args.cooldown);
        builder.add_priority(args.priority);
        if let Some(x) = args.prefabKey {
            builder.add_prefabKey(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_EnemyData_ESkillDataT {
        let prefabKey = self.prefabKey().map(|x| x.to_string());
        let priority = self.priority();
        let cooldown = self.cooldown();
        let initCooldown = self.initCooldown();
        let spCost = self.spCost();
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_LevelData_EnemyData_ESkillDataT {
            prefabKey,
            priority,
            cooldown,
            initCooldown,
            spCost,
            blackboard,
        }
    }

    #[inline]
    pub fn prefabKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_EnemyData_ESkillData::VT_PREFABKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn priority(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_LevelData_EnemyData_ESkillData::VT_PRIORITY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn cooldown(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_LevelData_EnemyData_ESkillData::VT_COOLDOWN,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn initCooldown(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_LevelData_EnemyData_ESkillData::VT_INITCOOLDOWN,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn spCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_LevelData_EnemyData_ESkillData::VT_SPCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(
                clz_Torappu_LevelData_EnemyData_ESkillData::VT_BLACKBOARD,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_EnemyData_ESkillData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "prefabKey",
                Self::VT_PREFABKEY,
                false,
            )?
            .visit_field::<i32>("priority", Self::VT_PRIORITY, false)?
            .visit_field::<f32>("cooldown", Self::VT_COOLDOWN, false)?
            .visit_field::<f32>("initCooldown", Self::VT_INITCOOLDOWN, false)?
            .visit_field::<i32>("spCost", Self::VT_SPCOST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_EnemyData_ESkillDataArgs<'a> {
    pub prefabKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub priority: i32,
    pub cooldown: f32,
    pub initCooldown: f32,
    pub spCost: i32,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_LevelData_EnemyData_ESkillDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_EnemyData_ESkillDataArgs {
            prefabKey: None,
            priority: 0,
            cooldown: 0.0,
            initCooldown: 0.0,
            spCost: 0,
            blackboard: None,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_EnemyData_ESkillData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LevelData_EnemyData_ESkillData", 6)?;
        if let Some(f) = self.prefabKey() {
            s.serialize_field("prefabKey", &f)?;
        } else {
            s.skip_field("prefabKey")?;
        }
        s.serialize_field("priority", &self.priority())?;
        s.serialize_field("cooldown", &self.cooldown())?;
        s.serialize_field("initCooldown", &self.initCooldown())?;
        s.serialize_field("spCost", &self.spCost())?;
        if let Some(f) = self.blackboard() {
            s.serialize_field("blackboard", &f)?;
        } else {
            s.skip_field("blackboard")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LevelData_EnemyData_ESkillDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LevelData_EnemyData_ESkillDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_prefabKey(&mut self, prefabKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_EnemyData_ESkillData::VT_PREFABKEY,
            prefabKey,
        );
    }
    #[inline]
    pub fn add_priority(&mut self, priority: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_EnemyData_ESkillData::VT_PRIORITY,
            priority,
            0,
        );
    }
    #[inline]
    pub fn add_cooldown(&mut self, cooldown: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_EnemyData_ESkillData::VT_COOLDOWN,
            cooldown,
            0.0,
        );
    }
    #[inline]
    pub fn add_initCooldown(&mut self, initCooldown: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_EnemyData_ESkillData::VT_INITCOOLDOWN,
            initCooldown,
            0.0,
        );
    }
    #[inline]
    pub fn add_spCost(&mut self, spCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_EnemyData_ESkillData::VT_SPCOST,
            spCost,
            0,
        );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_EnemyData_ESkillData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_EnemyData_ESkillDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_EnemyData_ESkillDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESkillData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_EnemyData_ESkillData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_EnemyData_ESkillData");
        ds.field("prefabKey", &self.prefabKey());
        ds.field("priority", &self.priority());
        ds.field("cooldown", &self.cooldown());
        ds.field("initCooldown", &self.initCooldown());
        ds.field("spCost", &self.spCost());
        ds.field("blackboard", &self.blackboard());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_EnemyData_ESkillDataT {
    pub prefabKey: Option<String>,
    pub priority: i32,
    pub cooldown: f32,
    pub initCooldown: f32,
    pub spCost: i32,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for clz_Torappu_LevelData_EnemyData_ESkillDataT {
    fn default() -> Self {
        Self {
            prefabKey: None,
            priority: 0,
            cooldown: 0.0,
            initCooldown: 0.0,
            spCost: 0,
            blackboard: None,
        }
    }
}
impl clz_Torappu_LevelData_EnemyData_ESkillDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESkillData<'b>> {
        let prefabKey = self.prefabKey.as_ref().map(|x| _fbb.create_string(x));
        let priority = self.priority;
        let cooldown = self.cooldown;
        let initCooldown = self.initCooldown;
        let spCost = self.spCost;
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_LevelData_EnemyData_ESkillData::create(
            _fbb,
            &clz_Torappu_LevelData_EnemyData_ESkillDataArgs {
                prefabKey,
                priority,
                cooldown,
                initCooldown,
                spCost,
                blackboard,
            },
        )
    }
}
pub enum clz_Torappu_LevelData_EnemyData_ESpDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_EnemyData_ESpData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_EnemyData_ESpData<'a> {
    type Inner = clz_Torappu_LevelData_EnemyData_ESpData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_EnemyData_ESpData<'a> {
    pub const VT_SPTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_MAXSP: flatbuffers::VOffsetT = 6;
    pub const VT_INITSP: flatbuffers::VOffsetT = 8;
    pub const VT_INCREMENT: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_EnemyData_ESpData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_EnemyData_ESpDataArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESpData<'bldr>> {
        let mut builder = clz_Torappu_LevelData_EnemyData_ESpDataBuilder::new(_fbb);
        builder.add_increment(args.increment);
        builder.add_initSp(args.initSp);
        builder.add_maxSp(args.maxSp);
        builder.add_spType(args.spType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_EnemyData_ESpDataT {
        let spType = self.spType();
        let maxSp = self.maxSp();
        let initSp = self.initSp();
        let increment = self.increment();
        clz_Torappu_LevelData_EnemyData_ESpDataT {
            spType,
            maxSp,
            initSp,
            increment,
        }
    }

    #[inline]
    pub fn spType(&self) -> enum__Torappu_SpType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SpType>(
                    clz_Torappu_LevelData_EnemyData_ESpData::VT_SPTYPE,
                    Some(enum__Torappu_SpType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxSp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_LevelData_EnemyData_ESpData::VT_MAXSP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn initSp(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_LevelData_EnemyData_ESpData::VT_INITSP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn increment(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_LevelData_EnemyData_ESpData::VT_INCREMENT,
                    Some(0.0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_EnemyData_ESpData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_SpType>("spType", Self::VT_SPTYPE, false)?
            .visit_field::<i32>("maxSp", Self::VT_MAXSP, false)?
            .visit_field::<i32>("initSp", Self::VT_INITSP, false)?
            .visit_field::<f32>("increment", Self::VT_INCREMENT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_EnemyData_ESpDataArgs {
    pub spType: enum__Torappu_SpType,
    pub maxSp: i32,
    pub initSp: i32,
    pub increment: f32,
}
impl<'a> Default for clz_Torappu_LevelData_EnemyData_ESpDataArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_EnemyData_ESpDataArgs {
            spType: enum__Torappu_SpType::NONE,
            maxSp: 0,
            initSp: 0,
            increment: 0.0,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_EnemyData_ESpData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LevelData_EnemyData_ESpData", 4)?;
        s.serialize_field("spType", &self.spType())?;
        s.serialize_field("maxSp", &self.maxSp())?;
        s.serialize_field("initSp", &self.initSp())?;
        s.serialize_field("increment", &self.increment())?;
        s.end()
    }
}

pub struct clz_Torappu_LevelData_EnemyData_ESpDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LevelData_EnemyData_ESpDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_spType(&mut self, spType: enum__Torappu_SpType) {
        self.fbb_.push_slot::<enum__Torappu_SpType>(
            clz_Torappu_LevelData_EnemyData_ESpData::VT_SPTYPE,
            spType,
            enum__Torappu_SpType::NONE,
        );
    }
    #[inline]
    pub fn add_maxSp(&mut self, maxSp: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_LevelData_EnemyData_ESpData::VT_MAXSP, maxSp, 0);
    }
    #[inline]
    pub fn add_initSp(&mut self, initSp: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_EnemyData_ESpData::VT_INITSP,
            initSp,
            0,
        );
    }
    #[inline]
    pub fn add_increment(&mut self, increment: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_EnemyData_ESpData::VT_INCREMENT,
            increment,
            0.0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_EnemyData_ESpDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_EnemyData_ESpDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESpData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_EnemyData_ESpData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_EnemyData_ESpData");
        ds.field("spType", &self.spType());
        ds.field("maxSp", &self.maxSp());
        ds.field("initSp", &self.initSp());
        ds.field("increment", &self.increment());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_EnemyData_ESpDataT {
    pub spType: enum__Torappu_SpType,
    pub maxSp: i32,
    pub initSp: i32,
    pub increment: f32,
}
impl Default for clz_Torappu_LevelData_EnemyData_ESpDataT {
    fn default() -> Self {
        Self {
            spType: enum__Torappu_SpType::NONE,
            maxSp: 0,
            initSp: 0,
            increment: 0.0,
        }
    }
}
impl clz_Torappu_LevelData_EnemyData_ESpDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESpData<'b>> {
        let spType = self.spType;
        let maxSp = self.maxSp;
        let initSp = self.initSp;
        let increment = self.increment;
        clz_Torappu_LevelData_EnemyData_ESpData::create(
            _fbb,
            &clz_Torappu_LevelData_EnemyData_ESpDataArgs {
                spType,
                maxSp,
                initSp,
                increment,
            },
        )
    }
}
pub enum clz_Torappu_LevelData_EnemyDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_EnemyData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_EnemyData<'a> {
    type Inner = clz_Torappu_LevelData_EnemyData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_EnemyData<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
    pub const VT_KEY: flatbuffers::VOffsetT = 8;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 10;
    pub const VT_APPLYWAY: flatbuffers::VOffsetT = 12;
    pub const VT_MOTION: flatbuffers::VOffsetT = 14;
    pub const VT_ENEMYTAGS: flatbuffers::VOffsetT = 16;
    pub const VT_NOTCOUNTINTOTAL: flatbuffers::VOffsetT = 18;
    pub const VT_ALIAS: flatbuffers::VOffsetT = 20;
    pub const VT_LIFEPOINTREDUCE: flatbuffers::VOffsetT = 22;
    pub const VT_RANGERADIUS: flatbuffers::VOffsetT = 24;
    pub const VT_NUMOFEXTRADROPS: flatbuffers::VOffsetT = 26;
    pub const VT_VIEWRADIUS: flatbuffers::VOffsetT = 28;
    pub const VT_LEVELTYPE: flatbuffers::VOffsetT = 30;
    pub const VT_TALENTBLACKBOARD: flatbuffers::VOffsetT = 32;
    pub const VT_SKILLS: flatbuffers::VOffsetT = 34;
    pub const VT_SPDATA: flatbuffers::VOffsetT = 36;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_EnemyData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_EnemyDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData<'bldr>> {
        let mut builder = clz_Torappu_LevelData_EnemyDataBuilder::new(_fbb);
        if let Some(x) = args.spData {
            builder.add_spData(x);
        }
        if let Some(x) = args.skills {
            builder.add_skills(x);
        }
        if let Some(x) = args.talentBlackboard {
            builder.add_talentBlackboard(x);
        }
        builder.add_levelType(args.levelType);
        builder.add_viewRadius(args.viewRadius);
        builder.add_numOfExtraDrops(args.numOfExtraDrops);
        builder.add_rangeRadius(args.rangeRadius);
        builder.add_lifePointReduce(args.lifePointReduce);
        if let Some(x) = args.alias {
            builder.add_alias(x);
        }
        if let Some(x) = args.enemyTags {
            builder.add_enemyTags(x);
        }
        builder.add_motion(args.motion);
        builder.add_applyWay(args.applyWay);
        if let Some(x) = args.attributes {
            builder.add_attributes(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_notCountInTotal(args.notCountInTotal);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_EnemyDataT {
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let key = self.key().map(|x| x.to_string());
        let attributes = self.attributes().map(|x| Box::new(x.unpack()));
        let applyWay = self.applyWay();
        let motion = self.motion();
        let enemyTags = self
            .enemyTags()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let notCountInTotal = self.notCountInTotal();
        let alias = self.alias().map(|x| x.to_string());
        let lifePointReduce = self.lifePointReduce();
        let rangeRadius = self.rangeRadius();
        let numOfExtraDrops = self.numOfExtraDrops();
        let viewRadius = self.viewRadius();
        let levelType = self.levelType();
        let talentBlackboard = self
            .talentBlackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let skills = self
            .skills()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let spData = self.spData().map(|x| Box::new(x.unpack()));
        clz_Torappu_LevelData_EnemyDataT {
            name,
            description,
            key,
            attributes,
            applyWay,
            motion,
            enemyTags,
            notCountInTotal,
            alias,
            lifePointReduce,
            rangeRadius,
            numOfExtraDrops,
            viewRadius,
            levelType,
            talentBlackboard,
            skills,
            spData,
        }
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_EnemyData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_EnemyData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_EnemyData::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn attributes(&self) -> Option<clz_Torappu_AttributesData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_AttributesData>>(
                    clz_Torappu_LevelData_EnemyData::VT_ATTRIBUTES,
                    None,
                )
        }
    }
    #[inline]
    pub fn applyWay(&self) -> enum__Torappu_SourceApplyWay {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SourceApplyWay>(
                    clz_Torappu_LevelData_EnemyData::VT_APPLYWAY,
                    Some(enum__Torappu_SourceApplyWay::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn motion(&self) -> enum__Torappu_MotionMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_MotionMode>(
                    clz_Torappu_LevelData_EnemyData::VT_MOTION,
                    Some(enum__Torappu_MotionMode::WALK),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn enemyTags(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_LevelData_EnemyData::VT_ENEMYTAGS, None)
        }
    }
    #[inline]
    pub fn notCountInTotal(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_EnemyData::VT_NOTCOUNTINTOTAL,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn alias(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_EnemyData::VT_ALIAS,
                None,
            )
        }
    }
    #[inline]
    pub fn lifePointReduce(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_LevelData_EnemyData::VT_LIFEPOINTREDUCE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn rangeRadius(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_LevelData_EnemyData::VT_RANGERADIUS, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn numOfExtraDrops(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_LevelData_EnemyData::VT_NUMOFEXTRADROPS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn viewRadius(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_LevelData_EnemyData::VT_VIEWRADIUS, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn levelType(&self) -> enum__Torappu_EnemyLevelType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EnemyLevelType>(
                    clz_Torappu_LevelData_EnemyData::VT_LEVELTYPE,
                    Some(enum__Torappu_EnemyLevelType::NORMAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn talentBlackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_LevelData_EnemyData::VT_TALENTBLACKBOARD, None)
        }
    }
    #[inline]
    pub fn skills(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESkillData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESkillData>,
                >,
            >>(clz_Torappu_LevelData_EnemyData::VT_SKILLS, None)
        }
    }
    #[inline]
    pub fn spData(&self) -> Option<clz_Torappu_LevelData_EnemyData_ESpData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESpData>>(
                    clz_Torappu_LevelData_EnemyData::VT_SPDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_EnemyData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_AttributesData>>(
                "attributes",
                Self::VT_ATTRIBUTES,
                false,
            )?
            .visit_field::<enum__Torappu_SourceApplyWay>("applyWay", Self::VT_APPLYWAY, false)?
            .visit_field::<enum__Torappu_MotionMode>("motion", Self::VT_MOTION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyTags", Self::VT_ENEMYTAGS, false)?
            .visit_field::<bool>("notCountInTotal", Self::VT_NOTCOUNTINTOTAL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alias", Self::VT_ALIAS, false)?
            .visit_field::<i32>("lifePointReduce", Self::VT_LIFEPOINTREDUCE, false)?
            .visit_field::<f32>("rangeRadius", Self::VT_RANGERADIUS, false)?
            .visit_field::<i32>("numOfExtraDrops", Self::VT_NUMOFEXTRADROPS, false)?
            .visit_field::<f32>("viewRadius", Self::VT_VIEWRADIUS, false)?
            .visit_field::<enum__Torappu_EnemyLevelType>("levelType", Self::VT_LEVELTYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("talentBlackboard", Self::VT_TALENTBLACKBOARD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESkillData>,
                >,
            >>("skills", Self::VT_SKILLS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESpData>>(
                "spData",
                Self::VT_SPDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_EnemyDataArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub attributes: Option<flatbuffers::WIPOffset<clz_Torappu_AttributesData<'a>>>,
    pub applyWay: enum__Torappu_SourceApplyWay,
    pub motion: enum__Torappu_MotionMode,
    pub enemyTags: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub notCountInTotal: bool,
    pub alias: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lifePointReduce: i32,
    pub rangeRadius: f32,
    pub numOfExtraDrops: i32,
    pub viewRadius: f32,
    pub levelType: enum__Torappu_EnemyLevelType,
    pub talentBlackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
    pub skills: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESkillData<'a>>,
            >,
        >,
    >,
    pub spData: Option<flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESpData<'a>>>,
}
impl<'a> Default for clz_Torappu_LevelData_EnemyDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_EnemyDataArgs {
            name: None,
            description: None,
            key: None,
            attributes: None,
            applyWay: enum__Torappu_SourceApplyWay::NONE,
            motion: enum__Torappu_MotionMode::WALK,
            enemyTags: None,
            notCountInTotal: false,
            alias: None,
            lifePointReduce: 0,
            rangeRadius: 0.0,
            numOfExtraDrops: 0,
            viewRadius: 0.0,
            levelType: enum__Torappu_EnemyLevelType::NORMAL,
            talentBlackboard: None,
            skills: None,
            spData: None,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_EnemyData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LevelData_EnemyData", 17)?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        if let Some(f) = self.attributes() {
            s.serialize_field("attributes", &f)?;
        } else {
            s.skip_field("attributes")?;
        }
        s.serialize_field("applyWay", &self.applyWay())?;
        s.serialize_field("motion", &self.motion())?;
        if let Some(f) = self.enemyTags() {
            s.serialize_field("enemyTags", &f)?;
        } else {
            s.skip_field("enemyTags")?;
        }
        s.serialize_field("notCountInTotal", &self.notCountInTotal())?;
        if let Some(f) = self.alias() {
            s.serialize_field("alias", &f)?;
        } else {
            s.skip_field("alias")?;
        }
        s.serialize_field("lifePointReduce", &self.lifePointReduce())?;
        s.serialize_field("rangeRadius", &self.rangeRadius())?;
        s.serialize_field("numOfExtraDrops", &self.numOfExtraDrops())?;
        s.serialize_field("viewRadius", &self.viewRadius())?;
        s.serialize_field("levelType", &self.levelType())?;
        if let Some(f) = self.talentBlackboard() {
            s.serialize_field("talentBlackboard", &f)?;
        } else {
            s.skip_field("talentBlackboard")?;
        }
        if let Some(f) = self.skills() {
            s.serialize_field("skills", &f)?;
        } else {
            s.skip_field("skills")?;
        }
        if let Some(f) = self.spData() {
            s.serialize_field("spData", &f)?;
        } else {
            s.skip_field("spData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LevelData_EnemyDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_LevelData_EnemyDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_EnemyData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_EnemyData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_EnemyData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_attributes(
        &mut self,
        attributes: flatbuffers::WIPOffset<clz_Torappu_AttributesData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_AttributesData>>(
                clz_Torappu_LevelData_EnemyData::VT_ATTRIBUTES,
                attributes,
            );
    }
    #[inline]
    pub fn add_applyWay(&mut self, applyWay: enum__Torappu_SourceApplyWay) {
        self.fbb_.push_slot::<enum__Torappu_SourceApplyWay>(
            clz_Torappu_LevelData_EnemyData::VT_APPLYWAY,
            applyWay,
            enum__Torappu_SourceApplyWay::NONE,
        );
    }
    #[inline]
    pub fn add_motion(&mut self, motion: enum__Torappu_MotionMode) {
        self.fbb_.push_slot::<enum__Torappu_MotionMode>(
            clz_Torappu_LevelData_EnemyData::VT_MOTION,
            motion,
            enum__Torappu_MotionMode::WALK,
        );
    }
    #[inline]
    pub fn add_enemyTags(
        &mut self,
        enemyTags: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_EnemyData::VT_ENEMYTAGS,
            enemyTags,
        );
    }
    #[inline]
    pub fn add_notCountInTotal(&mut self, notCountInTotal: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_EnemyData::VT_NOTCOUNTINTOTAL,
            notCountInTotal,
            false,
        );
    }
    #[inline]
    pub fn add_alias(&mut self, alias: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_EnemyData::VT_ALIAS,
            alias,
        );
    }
    #[inline]
    pub fn add_lifePointReduce(&mut self, lifePointReduce: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_EnemyData::VT_LIFEPOINTREDUCE,
            lifePointReduce,
            0,
        );
    }
    #[inline]
    pub fn add_rangeRadius(&mut self, rangeRadius: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_EnemyData::VT_RANGERADIUS,
            rangeRadius,
            0.0,
        );
    }
    #[inline]
    pub fn add_numOfExtraDrops(&mut self, numOfExtraDrops: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_EnemyData::VT_NUMOFEXTRADROPS,
            numOfExtraDrops,
            0,
        );
    }
    #[inline]
    pub fn add_viewRadius(&mut self, viewRadius: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_EnemyData::VT_VIEWRADIUS,
            viewRadius,
            0.0,
        );
    }
    #[inline]
    pub fn add_levelType(&mut self, levelType: enum__Torappu_EnemyLevelType) {
        self.fbb_.push_slot::<enum__Torappu_EnemyLevelType>(
            clz_Torappu_LevelData_EnemyData::VT_LEVELTYPE,
            levelType,
            enum__Torappu_EnemyLevelType::NORMAL,
        );
    }
    #[inline]
    pub fn add_talentBlackboard(
        &mut self,
        talentBlackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_EnemyData::VT_TALENTBLACKBOARD,
            talentBlackboard,
        );
    }
    #[inline]
    pub fn add_skills(
        &mut self,
        skills: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESkillData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_EnemyData::VT_SKILLS,
            skills,
        );
    }
    #[inline]
    pub fn add_spData(
        &mut self,
        spData: flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESpData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESpData>>(
                clz_Torappu_LevelData_EnemyData::VT_SPDATA,
                spData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_EnemyDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_EnemyDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_EnemyData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_EnemyData");
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("key", &self.key());
        ds.field("attributes", &self.attributes());
        ds.field("applyWay", &self.applyWay());
        ds.field("motion", &self.motion());
        ds.field("enemyTags", &self.enemyTags());
        ds.field("notCountInTotal", &self.notCountInTotal());
        ds.field("alias", &self.alias());
        ds.field("lifePointReduce", &self.lifePointReduce());
        ds.field("rangeRadius", &self.rangeRadius());
        ds.field("numOfExtraDrops", &self.numOfExtraDrops());
        ds.field("viewRadius", &self.viewRadius());
        ds.field("levelType", &self.levelType());
        ds.field("talentBlackboard", &self.talentBlackboard());
        ds.field("skills", &self.skills());
        ds.field("spData", &self.spData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_EnemyDataT {
    pub name: Option<String>,
    pub description: Option<String>,
    pub key: Option<String>,
    pub attributes: Option<Box<clz_Torappu_AttributesDataT>>,
    pub applyWay: enum__Torappu_SourceApplyWay,
    pub motion: enum__Torappu_MotionMode,
    pub enemyTags: Option<Vec<String>>,
    pub notCountInTotal: bool,
    pub alias: Option<String>,
    pub lifePointReduce: i32,
    pub rangeRadius: f32,
    pub numOfExtraDrops: i32,
    pub viewRadius: f32,
    pub levelType: enum__Torappu_EnemyLevelType,
    pub talentBlackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
    pub skills: Option<Vec<clz_Torappu_LevelData_EnemyData_ESkillDataT>>,
    pub spData: Option<Box<clz_Torappu_LevelData_EnemyData_ESpDataT>>,
}
impl Default for clz_Torappu_LevelData_EnemyDataT {
    fn default() -> Self {
        Self {
            name: None,
            description: None,
            key: None,
            attributes: None,
            applyWay: enum__Torappu_SourceApplyWay::NONE,
            motion: enum__Torappu_MotionMode::WALK,
            enemyTags: None,
            notCountInTotal: false,
            alias: None,
            lifePointReduce: 0,
            rangeRadius: 0.0,
            numOfExtraDrops: 0,
            viewRadius: 0.0,
            levelType: enum__Torappu_EnemyLevelType::NORMAL,
            talentBlackboard: None,
            skills: None,
            spData: None,
        }
    }
}
impl clz_Torappu_LevelData_EnemyDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData<'b>> {
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let attributes = self.attributes.as_ref().map(|x| x.pack(_fbb));
        let applyWay = self.applyWay;
        let motion = self.motion;
        let enemyTags = self.enemyTags.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let notCountInTotal = self.notCountInTotal;
        let alias = self.alias.as_ref().map(|x| _fbb.create_string(x));
        let lifePointReduce = self.lifePointReduce;
        let rangeRadius = self.rangeRadius;
        let numOfExtraDrops = self.numOfExtraDrops;
        let viewRadius = self.viewRadius;
        let levelType = self.levelType;
        let talentBlackboard = self.talentBlackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let skills = self.skills.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let spData = self.spData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_LevelData_EnemyData::create(
            _fbb,
            &clz_Torappu_LevelData_EnemyDataArgs {
                name,
                description,
                key,
                attributes,
                applyWay,
                motion,
                enemyTags,
                notCountInTotal,
                alias,
                lifePointReduce,
                rangeRadius,
                numOfExtraDrops,
                viewRadius,
                levelType,
                talentBlackboard,
                skills,
                spData,
            },
        )
    }
}
pub enum clz_Torappu_Undefinable_1_System_String_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_System_String_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_System_String_<'a> {
    type Inner = clz_Torappu_Undefinable_1_System_String_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_System_String_<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_System_String_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_System_String_Args<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_System_String_Builder::new(_fbb);
        if let Some(x) = args.m_value {
            builder.add_m_value(x);
        }
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_System_String_T {
        let m_defined = self.m_defined();
        let m_value = self.m_value().map(|x| x.to_string());
        clz_Torappu_Undefinable_1_System_String_T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_System_String_::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Undefinable_1_System_String_::VT_M_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_System_String_<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_System_String_Args<'a> {
    pub m_defined: bool,
    pub m_value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Undefinable_1_System_String_Args<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_System_String_Args {
            m_defined: false,
            m_value: None,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_System_String_<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Undefinable_1_System_String_", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        if let Some(f) = self.m_value() {
            s.serialize_field("m_value", &f)?;
        } else {
            s.skip_field("m_value")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_System_String_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_System_String_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_System_String_::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(&mut self, m_value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Undefinable_1_System_String_::VT_M_VALUE,
            m_value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_System_String_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_System_String_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_System_String_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_System_String_");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_System_String_T {
    pub m_defined: bool,
    pub m_value: Option<String>,
}
impl Default for clz_Torappu_Undefinable_1_System_String_T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: None,
        }
    }
}
impl clz_Torappu_Undefinable_1_System_String_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Undefinable_1_System_String_::create(
            _fbb,
            &clz_Torappu_Undefinable_1_System_String_Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_Undefinable_1_System_Int32_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_System_Int32_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_System_Int32_<'a> {
    type Inner = clz_Torappu_Undefinable_1_System_Int32_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_System_Int32_<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_System_Int32_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_System_Int32_Args,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_System_Int32_Builder::new(_fbb);
        builder.add_m_value(args.m_value);
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_System_Int32_T {
        let m_defined = self.m_defined();
        let m_value = self.m_value();
        clz_Torappu_Undefinable_1_System_Int32_T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_System_Int32_::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_Undefinable_1_System_Int32_::VT_M_VALUE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_System_Int32_<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<i32>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_System_Int32_Args {
    pub m_defined: bool,
    pub m_value: i32,
}
impl<'a> Default for clz_Torappu_Undefinable_1_System_Int32_Args {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_System_Int32_Args {
            m_defined: false,
            m_value: 0,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_System_Int32_<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Undefinable_1_System_Int32_", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        s.serialize_field("m_value", &self.m_value())?;
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_System_Int32_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_System_Int32_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_System_Int32_::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(&mut self, m_value: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Undefinable_1_System_Int32_::VT_M_VALUE,
            m_value,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_System_Int32_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_System_Int32_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_System_Int32_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_System_Int32_");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_System_Int32_T {
    pub m_defined: bool,
    pub m_value: i32,
}
impl Default for clz_Torappu_Undefinable_1_System_Int32_T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: 0,
        }
    }
}
impl clz_Torappu_Undefinable_1_System_Int32_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value;
        clz_Torappu_Undefinable_1_System_Int32_::create(
            _fbb,
            &clz_Torappu_Undefinable_1_System_Int32_Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_Undefinable_1_System_Single_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_System_Single_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_System_Single_<'a> {
    type Inner = clz_Torappu_Undefinable_1_System_Single_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_System_Single_<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_System_Single_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_System_Single_Args,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_System_Single_Builder::new(_fbb);
        builder.add_m_value(args.m_value);
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_System_Single_T {
        let m_defined = self.m_defined();
        let m_value = self.m_value();
        clz_Torappu_Undefinable_1_System_Single_T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_System_Single_::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_Undefinable_1_System_Single_::VT_M_VALUE,
                    Some(0.0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_System_Single_<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<f32>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_System_Single_Args {
    pub m_defined: bool,
    pub m_value: f32,
}
impl<'a> Default for clz_Torappu_Undefinable_1_System_Single_Args {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_System_Single_Args {
            m_defined: false,
            m_value: 0.0,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_System_Single_<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Undefinable_1_System_Single_", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        s.serialize_field("m_value", &self.m_value())?;
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_System_Single_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_System_Single_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_System_Single_::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(&mut self, m_value: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_Undefinable_1_System_Single_::VT_M_VALUE,
            m_value,
            0.0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_System_Single_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_System_Single_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_System_Single_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_System_Single_");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_System_Single_T {
    pub m_defined: bool,
    pub m_value: f32,
}
impl Default for clz_Torappu_Undefinable_1_System_Single_T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: 0.0,
        }
    }
}
impl clz_Torappu_Undefinable_1_System_Single_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value;
        clz_Torappu_Undefinable_1_System_Single_::create(
            _fbb,
            &clz_Torappu_Undefinable_1_System_Single_Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_Undefinable_1_System_Boolean_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_System_Boolean_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_System_Boolean_<'a> {
    type Inner = clz_Torappu_Undefinable_1_System_Boolean_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_System_Boolean_<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_System_Boolean_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_System_Boolean_Args,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_System_Boolean_Builder::new(_fbb);
        builder.add_m_value(args.m_value);
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_System_Boolean_T {
        let m_defined = self.m_defined();
        let m_value = self.m_value();
        clz_Torappu_Undefinable_1_System_Boolean_T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_System_Boolean_::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_System_Boolean_::VT_M_VALUE,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_System_Boolean_<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<bool>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_System_Boolean_Args {
    pub m_defined: bool,
    pub m_value: bool,
}
impl<'a> Default for clz_Torappu_Undefinable_1_System_Boolean_Args {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_System_Boolean_Args {
            m_defined: false,
            m_value: false,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_System_Boolean_<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Undefinable_1_System_Boolean_", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        s.serialize_field("m_value", &self.m_value())?;
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_System_Boolean_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_System_Boolean_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_System_Boolean_::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(&mut self, m_value: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_System_Boolean_::VT_M_VALUE,
            m_value,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_System_Boolean_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_System_Boolean_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_System_Boolean_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_System_Boolean_");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_System_Boolean_T {
    pub m_defined: bool,
    pub m_value: bool,
}
impl Default for clz_Torappu_Undefinable_1_System_Boolean_T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: false,
        }
    }
}
impl clz_Torappu_Undefinable_1_System_Boolean_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value;
        clz_Torappu_Undefinable_1_System_Boolean_::create(
            _fbb,
            &clz_Torappu_Undefinable_1_System_Boolean_Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_EnemyDatabase_AttributesDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_EnemyDatabase_AttributesData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_EnemyDatabase_AttributesData<'a> {
    type Inner = clz_Torappu_EnemyDatabase_AttributesData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_EnemyDatabase_AttributesData<'a> {
    pub const VT_MAXHP: flatbuffers::VOffsetT = 4;
    pub const VT_ATK: flatbuffers::VOffsetT = 6;
    pub const VT_DEF: flatbuffers::VOffsetT = 8;
    pub const VT_MAGICRESISTANCE: flatbuffers::VOffsetT = 10;
    pub const VT_COST: flatbuffers::VOffsetT = 12;
    pub const VT_BLOCKCNT: flatbuffers::VOffsetT = 14;
    pub const VT_MOVESPEED: flatbuffers::VOffsetT = 16;
    pub const VT_ATTACKSPEED: flatbuffers::VOffsetT = 18;
    pub const VT_BASEATTACKTIME: flatbuffers::VOffsetT = 20;
    pub const VT_RESPAWNTIME: flatbuffers::VOffsetT = 22;
    pub const VT_HPRECOVERYPERSEC: flatbuffers::VOffsetT = 24;
    pub const VT_SPRECOVERYPERSEC: flatbuffers::VOffsetT = 26;
    pub const VT_MAXDEPLOYCOUNT: flatbuffers::VOffsetT = 28;
    pub const VT_MASSLEVEL: flatbuffers::VOffsetT = 30;
    pub const VT_BASEFORCELEVEL: flatbuffers::VOffsetT = 32;
    pub const VT_TAUNTLEVEL: flatbuffers::VOffsetT = 34;
    pub const VT_EPDAMAGERESISTANCE: flatbuffers::VOffsetT = 36;
    pub const VT_EPRESISTANCE: flatbuffers::VOffsetT = 38;
    pub const VT_DAMAGEHITRATEPHYSICAL: flatbuffers::VOffsetT = 40;
    pub const VT_DAMAGEHITRATEMAGICAL: flatbuffers::VOffsetT = 42;
    pub const VT_EPBREAKRECOVERSPEED: flatbuffers::VOffsetT = 44;
    pub const VT_STUNIMMUNE: flatbuffers::VOffsetT = 46;
    pub const VT_SILENCEIMMUNE: flatbuffers::VOffsetT = 48;
    pub const VT_SLEEPIMMUNE: flatbuffers::VOffsetT = 50;
    pub const VT_FROZENIMMUNE: flatbuffers::VOffsetT = 52;
    pub const VT_LEVITATEIMMUNE: flatbuffers::VOffsetT = 54;
    pub const VT_DISARMEDCOMBATIMMUNE: flatbuffers::VOffsetT = 56;
    pub const VT_FEAREDIMMUNE: flatbuffers::VOffsetT = 58;
    pub const VT_PALSYIMMUNE: flatbuffers::VOffsetT = 60;
    pub const VT_ATTRACTIMMUNE: flatbuffers::VOffsetT = 62;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_EnemyDatabase_AttributesData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_EnemyDatabase_AttributesDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_AttributesData<'bldr>> {
        let mut builder = clz_Torappu_EnemyDatabase_AttributesDataBuilder::new(_fbb);
        if let Some(x) = args.attractImmune {
            builder.add_attractImmune(x);
        }
        if let Some(x) = args.palsyImmune {
            builder.add_palsyImmune(x);
        }
        if let Some(x) = args.fearedImmune {
            builder.add_fearedImmune(x);
        }
        if let Some(x) = args.disarmedCombatImmune {
            builder.add_disarmedCombatImmune(x);
        }
        if let Some(x) = args.levitateImmune {
            builder.add_levitateImmune(x);
        }
        if let Some(x) = args.frozenImmune {
            builder.add_frozenImmune(x);
        }
        if let Some(x) = args.sleepImmune {
            builder.add_sleepImmune(x);
        }
        if let Some(x) = args.silenceImmune {
            builder.add_silenceImmune(x);
        }
        if let Some(x) = args.stunImmune {
            builder.add_stunImmune(x);
        }
        if let Some(x) = args.epBreakRecoverSpeed {
            builder.add_epBreakRecoverSpeed(x);
        }
        if let Some(x) = args.damageHitrateMagical {
            builder.add_damageHitrateMagical(x);
        }
        if let Some(x) = args.damageHitratePhysical {
            builder.add_damageHitratePhysical(x);
        }
        if let Some(x) = args.epResistance {
            builder.add_epResistance(x);
        }
        if let Some(x) = args.epDamageResistance {
            builder.add_epDamageResistance(x);
        }
        if let Some(x) = args.tauntLevel {
            builder.add_tauntLevel(x);
        }
        if let Some(x) = args.baseForceLevel {
            builder.add_baseForceLevel(x);
        }
        if let Some(x) = args.massLevel {
            builder.add_massLevel(x);
        }
        if let Some(x) = args.maxDeployCount {
            builder.add_maxDeployCount(x);
        }
        if let Some(x) = args.spRecoveryPerSec {
            builder.add_spRecoveryPerSec(x);
        }
        if let Some(x) = args.hpRecoveryPerSec {
            builder.add_hpRecoveryPerSec(x);
        }
        if let Some(x) = args.respawnTime {
            builder.add_respawnTime(x);
        }
        if let Some(x) = args.baseAttackTime {
            builder.add_baseAttackTime(x);
        }
        if let Some(x) = args.attackSpeed {
            builder.add_attackSpeed(x);
        }
        if let Some(x) = args.moveSpeed {
            builder.add_moveSpeed(x);
        }
        if let Some(x) = args.blockCnt {
            builder.add_blockCnt(x);
        }
        if let Some(x) = args.cost {
            builder.add_cost(x);
        }
        if let Some(x) = args.magicResistance {
            builder.add_magicResistance(x);
        }
        if let Some(x) = args.def {
            builder.add_def(x);
        }
        if let Some(x) = args.atk {
            builder.add_atk(x);
        }
        if let Some(x) = args.maxHp {
            builder.add_maxHp(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_EnemyDatabase_AttributesDataT {
        let maxHp = self.maxHp().map(|x| Box::new(x.unpack()));
        let atk = self.atk().map(|x| Box::new(x.unpack()));
        let def = self.def().map(|x| Box::new(x.unpack()));
        let magicResistance = self.magicResistance().map(|x| Box::new(x.unpack()));
        let cost = self.cost().map(|x| Box::new(x.unpack()));
        let blockCnt = self.blockCnt().map(|x| Box::new(x.unpack()));
        let moveSpeed = self.moveSpeed().map(|x| Box::new(x.unpack()));
        let attackSpeed = self.attackSpeed().map(|x| Box::new(x.unpack()));
        let baseAttackTime = self.baseAttackTime().map(|x| Box::new(x.unpack()));
        let respawnTime = self.respawnTime().map(|x| Box::new(x.unpack()));
        let hpRecoveryPerSec = self.hpRecoveryPerSec().map(|x| Box::new(x.unpack()));
        let spRecoveryPerSec = self.spRecoveryPerSec().map(|x| Box::new(x.unpack()));
        let maxDeployCount = self.maxDeployCount().map(|x| Box::new(x.unpack()));
        let massLevel = self.massLevel().map(|x| Box::new(x.unpack()));
        let baseForceLevel = self.baseForceLevel().map(|x| Box::new(x.unpack()));
        let tauntLevel = self.tauntLevel().map(|x| Box::new(x.unpack()));
        let epDamageResistance = self.epDamageResistance().map(|x| Box::new(x.unpack()));
        let epResistance = self.epResistance().map(|x| Box::new(x.unpack()));
        let damageHitratePhysical = self.damageHitratePhysical().map(|x| Box::new(x.unpack()));
        let damageHitrateMagical = self.damageHitrateMagical().map(|x| Box::new(x.unpack()));
        let epBreakRecoverSpeed = self.epBreakRecoverSpeed().map(|x| Box::new(x.unpack()));
        let stunImmune = self.stunImmune().map(|x| Box::new(x.unpack()));
        let silenceImmune = self.silenceImmune().map(|x| Box::new(x.unpack()));
        let sleepImmune = self.sleepImmune().map(|x| Box::new(x.unpack()));
        let frozenImmune = self.frozenImmune().map(|x| Box::new(x.unpack()));
        let levitateImmune = self.levitateImmune().map(|x| Box::new(x.unpack()));
        let disarmedCombatImmune = self.disarmedCombatImmune().map(|x| Box::new(x.unpack()));
        let fearedImmune = self.fearedImmune().map(|x| Box::new(x.unpack()));
        let palsyImmune = self.palsyImmune().map(|x| Box::new(x.unpack()));
        let attractImmune = self.attractImmune().map(|x| Box::new(x.unpack()));
        clz_Torappu_EnemyDatabase_AttributesDataT {
            maxHp,
            atk,
            def,
            magicResistance,
            cost,
            blockCnt,
            moveSpeed,
            attackSpeed,
            baseAttackTime,
            respawnTime,
            hpRecoveryPerSec,
            spRecoveryPerSec,
            maxDeployCount,
            massLevel,
            baseForceLevel,
            tauntLevel,
            epDamageResistance,
            epResistance,
            damageHitratePhysical,
            damageHitrateMagical,
            epBreakRecoverSpeed,
            stunImmune,
            silenceImmune,
            sleepImmune,
            frozenImmune,
            levitateImmune,
            disarmedCombatImmune,
            fearedImmune,
            palsyImmune,
            attractImmune,
        }
    }

    #[inline]
    pub fn maxHp(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_MAXHP,
                    None,
                )
        }
    }
    #[inline]
    pub fn atk(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_ATK,
                    None,
                )
        }
    }
    #[inline]
    pub fn def(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_DEF,
                    None,
                )
        }
    }
    #[inline]
    pub fn magicResistance(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_MAGICRESISTANCE,
                    None,
                )
        }
    }
    #[inline]
    pub fn cost(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_COST,
                    None,
                )
        }
    }
    #[inline]
    pub fn blockCnt(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_BLOCKCNT,
                    None,
                )
        }
    }
    #[inline]
    pub fn moveSpeed(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_MOVESPEED,
                    None,
                )
        }
    }
    #[inline]
    pub fn attackSpeed(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_ATTACKSPEED,
                    None,
                )
        }
    }
    #[inline]
    pub fn baseAttackTime(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_BASEATTACKTIME,
                    None,
                )
        }
    }
    #[inline]
    pub fn respawnTime(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_RESPAWNTIME,
                    None,
                )
        }
    }
    #[inline]
    pub fn hpRecoveryPerSec(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_HPRECOVERYPERSEC,
                    None,
                )
        }
    }
    #[inline]
    pub fn spRecoveryPerSec(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_SPRECOVERYPERSEC,
                    None,
                )
        }
    }
    #[inline]
    pub fn maxDeployCount(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_MAXDEPLOYCOUNT,
                    None,
                )
        }
    }
    #[inline]
    pub fn massLevel(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_MASSLEVEL,
                    None,
                )
        }
    }
    #[inline]
    pub fn baseForceLevel(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_BASEFORCELEVEL,
                    None,
                )
        }
    }
    #[inline]
    pub fn tauntLevel(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_TAUNTLEVEL,
                    None,
                )
        }
    }
    #[inline]
    pub fn epDamageResistance(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_EPDAMAGERESISTANCE,
                    None,
                )
        }
    }
    #[inline]
    pub fn epResistance(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_EPRESISTANCE,
                    None,
                )
        }
    }
    #[inline]
    pub fn damageHitratePhysical(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_DAMAGEHITRATEPHYSICAL,
                    None,
                )
        }
    }
    #[inline]
    pub fn damageHitrateMagical(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_DAMAGEHITRATEMAGICAL,
                    None,
                )
        }
    }
    #[inline]
    pub fn epBreakRecoverSpeed(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_EPBREAKRECOVERSPEED,
                    None,
                )
        }
    }
    #[inline]
    pub fn stunImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_STUNIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn silenceImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_SILENCEIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn sleepImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_SLEEPIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn frozenImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_FROZENIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn levitateImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_LEVITATEIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn disarmedCombatImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_DISARMEDCOMBATIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn fearedImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_FEAREDIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn palsyImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_PALSYIMMUNE,
                    None,
                )
        }
    }
    #[inline]
    pub fn attractImmune(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_AttributesData::VT_ATTRACTIMMUNE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_EnemyDatabase_AttributesData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "maxHp",
                Self::VT_MAXHP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "atk",
                Self::VT_ATK,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "def",
                Self::VT_DEF,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "magicResistance",
                Self::VT_MAGICRESISTANCE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "cost",
                Self::VT_COST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "blockCnt",
                Self::VT_BLOCKCNT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "moveSpeed",
                Self::VT_MOVESPEED,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "attackSpeed",
                Self::VT_ATTACKSPEED,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "baseAttackTime",
                Self::VT_BASEATTACKTIME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "respawnTime",
                Self::VT_RESPAWNTIME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "hpRecoveryPerSec",
                Self::VT_HPRECOVERYPERSEC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "spRecoveryPerSec",
                Self::VT_SPRECOVERYPERSEC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "maxDeployCount",
                Self::VT_MAXDEPLOYCOUNT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "massLevel",
                Self::VT_MASSLEVEL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "baseForceLevel",
                Self::VT_BASEFORCELEVEL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                "tauntLevel",
                Self::VT_TAUNTLEVEL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "epDamageResistance",
                Self::VT_EPDAMAGERESISTANCE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "epResistance",
                Self::VT_EPRESISTANCE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "damageHitratePhysical",
                Self::VT_DAMAGEHITRATEPHYSICAL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "damageHitrateMagical",
                Self::VT_DAMAGEHITRATEMAGICAL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                "epBreakRecoverSpeed",
                Self::VT_EPBREAKRECOVERSPEED,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "stunImmune",
                Self::VT_STUNIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "silenceImmune",
                Self::VT_SILENCEIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "sleepImmune",
                Self::VT_SLEEPIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "frozenImmune",
                Self::VT_FROZENIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "levitateImmune",
                Self::VT_LEVITATEIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "disarmedCombatImmune",
                Self::VT_DISARMEDCOMBATIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "fearedImmune",
                Self::VT_FEAREDIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "palsyImmune",
                Self::VT_PALSYIMMUNE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                "attractImmune",
                Self::VT_ATTRACTIMMUNE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_EnemyDatabase_AttributesDataArgs<'a> {
    pub maxHp: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub atk: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub def: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub magicResistance:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub cost: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub blockCnt: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub moveSpeed: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub attackSpeed: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub baseAttackTime:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub respawnTime: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub hpRecoveryPerSec:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub spRecoveryPerSec:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub maxDeployCount: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub massLevel: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub baseForceLevel: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub tauntLevel: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub epDamageResistance:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub epResistance: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub damageHitratePhysical:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub damageHitrateMagical:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub epBreakRecoverSpeed:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub stunImmune: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub silenceImmune:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub sleepImmune: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub frozenImmune: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub levitateImmune:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub disarmedCombatImmune:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub fearedImmune: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub palsyImmune: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub attractImmune:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
}
impl<'a> Default for clz_Torappu_EnemyDatabase_AttributesDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_EnemyDatabase_AttributesDataArgs {
            maxHp: None,
            atk: None,
            def: None,
            magicResistance: None,
            cost: None,
            blockCnt: None,
            moveSpeed: None,
            attackSpeed: None,
            baseAttackTime: None,
            respawnTime: None,
            hpRecoveryPerSec: None,
            spRecoveryPerSec: None,
            maxDeployCount: None,
            massLevel: None,
            baseForceLevel: None,
            tauntLevel: None,
            epDamageResistance: None,
            epResistance: None,
            damageHitratePhysical: None,
            damageHitrateMagical: None,
            epBreakRecoverSpeed: None,
            stunImmune: None,
            silenceImmune: None,
            sleepImmune: None,
            frozenImmune: None,
            levitateImmune: None,
            disarmedCombatImmune: None,
            fearedImmune: None,
            palsyImmune: None,
            attractImmune: None,
        }
    }
}

impl Serialize for clz_Torappu_EnemyDatabase_AttributesData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_EnemyDatabase_AttributesData", 30)?;
        if let Some(f) = self.maxHp() {
            s.serialize_field("maxHp", &f)?;
        } else {
            s.skip_field("maxHp")?;
        }
        if let Some(f) = self.atk() {
            s.serialize_field("atk", &f)?;
        } else {
            s.skip_field("atk")?;
        }
        if let Some(f) = self.def() {
            s.serialize_field("def", &f)?;
        } else {
            s.skip_field("def")?;
        }
        if let Some(f) = self.magicResistance() {
            s.serialize_field("magicResistance", &f)?;
        } else {
            s.skip_field("magicResistance")?;
        }
        if let Some(f) = self.cost() {
            s.serialize_field("cost", &f)?;
        } else {
            s.skip_field("cost")?;
        }
        if let Some(f) = self.blockCnt() {
            s.serialize_field("blockCnt", &f)?;
        } else {
            s.skip_field("blockCnt")?;
        }
        if let Some(f) = self.moveSpeed() {
            s.serialize_field("moveSpeed", &f)?;
        } else {
            s.skip_field("moveSpeed")?;
        }
        if let Some(f) = self.attackSpeed() {
            s.serialize_field("attackSpeed", &f)?;
        } else {
            s.skip_field("attackSpeed")?;
        }
        if let Some(f) = self.baseAttackTime() {
            s.serialize_field("baseAttackTime", &f)?;
        } else {
            s.skip_field("baseAttackTime")?;
        }
        if let Some(f) = self.respawnTime() {
            s.serialize_field("respawnTime", &f)?;
        } else {
            s.skip_field("respawnTime")?;
        }
        if let Some(f) = self.hpRecoveryPerSec() {
            s.serialize_field("hpRecoveryPerSec", &f)?;
        } else {
            s.skip_field("hpRecoveryPerSec")?;
        }
        if let Some(f) = self.spRecoveryPerSec() {
            s.serialize_field("spRecoveryPerSec", &f)?;
        } else {
            s.skip_field("spRecoveryPerSec")?;
        }
        if let Some(f) = self.maxDeployCount() {
            s.serialize_field("maxDeployCount", &f)?;
        } else {
            s.skip_field("maxDeployCount")?;
        }
        if let Some(f) = self.massLevel() {
            s.serialize_field("massLevel", &f)?;
        } else {
            s.skip_field("massLevel")?;
        }
        if let Some(f) = self.baseForceLevel() {
            s.serialize_field("baseForceLevel", &f)?;
        } else {
            s.skip_field("baseForceLevel")?;
        }
        if let Some(f) = self.tauntLevel() {
            s.serialize_field("tauntLevel", &f)?;
        } else {
            s.skip_field("tauntLevel")?;
        }
        if let Some(f) = self.epDamageResistance() {
            s.serialize_field("epDamageResistance", &f)?;
        } else {
            s.skip_field("epDamageResistance")?;
        }
        if let Some(f) = self.epResistance() {
            s.serialize_field("epResistance", &f)?;
        } else {
            s.skip_field("epResistance")?;
        }
        if let Some(f) = self.damageHitratePhysical() {
            s.serialize_field("damageHitratePhysical", &f)?;
        } else {
            s.skip_field("damageHitratePhysical")?;
        }
        if let Some(f) = self.damageHitrateMagical() {
            s.serialize_field("damageHitrateMagical", &f)?;
        } else {
            s.skip_field("damageHitrateMagical")?;
        }
        if let Some(f) = self.epBreakRecoverSpeed() {
            s.serialize_field("epBreakRecoverSpeed", &f)?;
        } else {
            s.skip_field("epBreakRecoverSpeed")?;
        }
        if let Some(f) = self.stunImmune() {
            s.serialize_field("stunImmune", &f)?;
        } else {
            s.skip_field("stunImmune")?;
        }
        if let Some(f) = self.silenceImmune() {
            s.serialize_field("silenceImmune", &f)?;
        } else {
            s.skip_field("silenceImmune")?;
        }
        if let Some(f) = self.sleepImmune() {
            s.serialize_field("sleepImmune", &f)?;
        } else {
            s.skip_field("sleepImmune")?;
        }
        if let Some(f) = self.frozenImmune() {
            s.serialize_field("frozenImmune", &f)?;
        } else {
            s.skip_field("frozenImmune")?;
        }
        if let Some(f) = self.levitateImmune() {
            s.serialize_field("levitateImmune", &f)?;
        } else {
            s.skip_field("levitateImmune")?;
        }
        if let Some(f) = self.disarmedCombatImmune() {
            s.serialize_field("disarmedCombatImmune", &f)?;
        } else {
            s.skip_field("disarmedCombatImmune")?;
        }
        if let Some(f) = self.fearedImmune() {
            s.serialize_field("fearedImmune", &f)?;
        } else {
            s.skip_field("fearedImmune")?;
        }
        if let Some(f) = self.palsyImmune() {
            s.serialize_field("palsyImmune", &f)?;
        } else {
            s.skip_field("palsyImmune")?;
        }
        if let Some(f) = self.attractImmune() {
            s.serialize_field("attractImmune", &f)?;
        } else {
            s.skip_field("attractImmune")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_EnemyDatabase_AttributesDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_EnemyDatabase_AttributesDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_maxHp(
        &mut self,
        maxHp: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_MAXHP,
                maxHp,
            );
    }
    #[inline]
    pub fn add_atk(
        &mut self,
        atk: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_ATK,
                atk,
            );
    }
    #[inline]
    pub fn add_def(
        &mut self,
        def: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_DEF,
                def,
            );
    }
    #[inline]
    pub fn add_magicResistance(
        &mut self,
        magicResistance: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_MAGICRESISTANCE,
                magicResistance,
            );
    }
    #[inline]
    pub fn add_cost(
        &mut self,
        cost: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_COST,
                cost,
            );
    }
    #[inline]
    pub fn add_blockCnt(
        &mut self,
        blockCnt: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_BLOCKCNT,
                blockCnt,
            );
    }
    #[inline]
    pub fn add_moveSpeed(
        &mut self,
        moveSpeed: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_MOVESPEED,
                moveSpeed,
            );
    }
    #[inline]
    pub fn add_attackSpeed(
        &mut self,
        attackSpeed: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_ATTACKSPEED,
                attackSpeed,
            );
    }
    #[inline]
    pub fn add_baseAttackTime(
        &mut self,
        baseAttackTime: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_BASEATTACKTIME,
                baseAttackTime,
            );
    }
    #[inline]
    pub fn add_respawnTime(
        &mut self,
        respawnTime: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_RESPAWNTIME,
                respawnTime,
            );
    }
    #[inline]
    pub fn add_hpRecoveryPerSec(
        &mut self,
        hpRecoveryPerSec: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_HPRECOVERYPERSEC,
                hpRecoveryPerSec,
            );
    }
    #[inline]
    pub fn add_spRecoveryPerSec(
        &mut self,
        spRecoveryPerSec: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_SPRECOVERYPERSEC,
                spRecoveryPerSec,
            );
    }
    #[inline]
    pub fn add_maxDeployCount(
        &mut self,
        maxDeployCount: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_MAXDEPLOYCOUNT,
                maxDeployCount,
            );
    }
    #[inline]
    pub fn add_massLevel(
        &mut self,
        massLevel: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_MASSLEVEL,
                massLevel,
            );
    }
    #[inline]
    pub fn add_baseForceLevel(
        &mut self,
        baseForceLevel: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_BASEFORCELEVEL,
                baseForceLevel,
            );
    }
    #[inline]
    pub fn add_tauntLevel(
        &mut self,
        tauntLevel: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_TAUNTLEVEL,
                tauntLevel,
            );
    }
    #[inline]
    pub fn add_epDamageResistance(
        &mut self,
        epDamageResistance: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_EPDAMAGERESISTANCE,
                epDamageResistance,
            );
    }
    #[inline]
    pub fn add_epResistance(
        &mut self,
        epResistance: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_EPRESISTANCE,
                epResistance,
            );
    }
    #[inline]
    pub fn add_damageHitratePhysical(
        &mut self,
        damageHitratePhysical: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_DAMAGEHITRATEPHYSICAL,
                damageHitratePhysical,
            );
    }
    #[inline]
    pub fn add_damageHitrateMagical(
        &mut self,
        damageHitrateMagical: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_DAMAGEHITRATEMAGICAL,
                damageHitrateMagical,
            );
    }
    #[inline]
    pub fn add_epBreakRecoverSpeed(
        &mut self,
        epBreakRecoverSpeed: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_EPBREAKRECOVERSPEED,
                epBreakRecoverSpeed,
            );
    }
    #[inline]
    pub fn add_stunImmune(
        &mut self,
        stunImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_STUNIMMUNE,
                stunImmune,
            );
    }
    #[inline]
    pub fn add_silenceImmune(
        &mut self,
        silenceImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_SILENCEIMMUNE,
                silenceImmune,
            );
    }
    #[inline]
    pub fn add_sleepImmune(
        &mut self,
        sleepImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_SLEEPIMMUNE,
                sleepImmune,
            );
    }
    #[inline]
    pub fn add_frozenImmune(
        &mut self,
        frozenImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_FROZENIMMUNE,
                frozenImmune,
            );
    }
    #[inline]
    pub fn add_levitateImmune(
        &mut self,
        levitateImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_LEVITATEIMMUNE,
                levitateImmune,
            );
    }
    #[inline]
    pub fn add_disarmedCombatImmune(
        &mut self,
        disarmedCombatImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_DISARMEDCOMBATIMMUNE,
                disarmedCombatImmune,
            );
    }
    #[inline]
    pub fn add_fearedImmune(
        &mut self,
        fearedImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_FEAREDIMMUNE,
                fearedImmune,
            );
    }
    #[inline]
    pub fn add_palsyImmune(
        &mut self,
        palsyImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_PALSYIMMUNE,
                palsyImmune,
            );
    }
    #[inline]
    pub fn add_attractImmune(
        &mut self,
        attractImmune: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_AttributesData::VT_ATTRACTIMMUNE,
                attractImmune,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_EnemyDatabase_AttributesDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_EnemyDatabase_AttributesDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_AttributesData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_EnemyDatabase_AttributesData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_EnemyDatabase_AttributesData");
        ds.field("maxHp", &self.maxHp());
        ds.field("atk", &self.atk());
        ds.field("def", &self.def());
        ds.field("magicResistance", &self.magicResistance());
        ds.field("cost", &self.cost());
        ds.field("blockCnt", &self.blockCnt());
        ds.field("moveSpeed", &self.moveSpeed());
        ds.field("attackSpeed", &self.attackSpeed());
        ds.field("baseAttackTime", &self.baseAttackTime());
        ds.field("respawnTime", &self.respawnTime());
        ds.field("hpRecoveryPerSec", &self.hpRecoveryPerSec());
        ds.field("spRecoveryPerSec", &self.spRecoveryPerSec());
        ds.field("maxDeployCount", &self.maxDeployCount());
        ds.field("massLevel", &self.massLevel());
        ds.field("baseForceLevel", &self.baseForceLevel());
        ds.field("tauntLevel", &self.tauntLevel());
        ds.field("epDamageResistance", &self.epDamageResistance());
        ds.field("epResistance", &self.epResistance());
        ds.field("damageHitratePhysical", &self.damageHitratePhysical());
        ds.field("damageHitrateMagical", &self.damageHitrateMagical());
        ds.field("epBreakRecoverSpeed", &self.epBreakRecoverSpeed());
        ds.field("stunImmune", &self.stunImmune());
        ds.field("silenceImmune", &self.silenceImmune());
        ds.field("sleepImmune", &self.sleepImmune());
        ds.field("frozenImmune", &self.frozenImmune());
        ds.field("levitateImmune", &self.levitateImmune());
        ds.field("disarmedCombatImmune", &self.disarmedCombatImmune());
        ds.field("fearedImmune", &self.fearedImmune());
        ds.field("palsyImmune", &self.palsyImmune());
        ds.field("attractImmune", &self.attractImmune());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_EnemyDatabase_AttributesDataT {
    pub maxHp: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub atk: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub def: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub magicResistance: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub cost: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub blockCnt: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub moveSpeed: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub attackSpeed: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub baseAttackTime: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub respawnTime: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub hpRecoveryPerSec: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub spRecoveryPerSec: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub maxDeployCount: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub massLevel: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub baseForceLevel: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub tauntLevel: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub epDamageResistance: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub epResistance: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub damageHitratePhysical: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub damageHitrateMagical: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub epBreakRecoverSpeed: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub stunImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub silenceImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub sleepImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub frozenImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub levitateImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub disarmedCombatImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub fearedImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub palsyImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub attractImmune: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
}
impl Default for clz_Torappu_EnemyDatabase_AttributesDataT {
    fn default() -> Self {
        Self {
            maxHp: None,
            atk: None,
            def: None,
            magicResistance: None,
            cost: None,
            blockCnt: None,
            moveSpeed: None,
            attackSpeed: None,
            baseAttackTime: None,
            respawnTime: None,
            hpRecoveryPerSec: None,
            spRecoveryPerSec: None,
            maxDeployCount: None,
            massLevel: None,
            baseForceLevel: None,
            tauntLevel: None,
            epDamageResistance: None,
            epResistance: None,
            damageHitratePhysical: None,
            damageHitrateMagical: None,
            epBreakRecoverSpeed: None,
            stunImmune: None,
            silenceImmune: None,
            sleepImmune: None,
            frozenImmune: None,
            levitateImmune: None,
            disarmedCombatImmune: None,
            fearedImmune: None,
            palsyImmune: None,
            attractImmune: None,
        }
    }
}
impl clz_Torappu_EnemyDatabase_AttributesDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_AttributesData<'b>> {
        let maxHp = self.maxHp.as_ref().map(|x| x.pack(_fbb));
        let atk = self.atk.as_ref().map(|x| x.pack(_fbb));
        let def = self.def.as_ref().map(|x| x.pack(_fbb));
        let magicResistance = self.magicResistance.as_ref().map(|x| x.pack(_fbb));
        let cost = self.cost.as_ref().map(|x| x.pack(_fbb));
        let blockCnt = self.blockCnt.as_ref().map(|x| x.pack(_fbb));
        let moveSpeed = self.moveSpeed.as_ref().map(|x| x.pack(_fbb));
        let attackSpeed = self.attackSpeed.as_ref().map(|x| x.pack(_fbb));
        let baseAttackTime = self.baseAttackTime.as_ref().map(|x| x.pack(_fbb));
        let respawnTime = self.respawnTime.as_ref().map(|x| x.pack(_fbb));
        let hpRecoveryPerSec = self.hpRecoveryPerSec.as_ref().map(|x| x.pack(_fbb));
        let spRecoveryPerSec = self.spRecoveryPerSec.as_ref().map(|x| x.pack(_fbb));
        let maxDeployCount = self.maxDeployCount.as_ref().map(|x| x.pack(_fbb));
        let massLevel = self.massLevel.as_ref().map(|x| x.pack(_fbb));
        let baseForceLevel = self.baseForceLevel.as_ref().map(|x| x.pack(_fbb));
        let tauntLevel = self.tauntLevel.as_ref().map(|x| x.pack(_fbb));
        let epDamageResistance = self.epDamageResistance.as_ref().map(|x| x.pack(_fbb));
        let epResistance = self.epResistance.as_ref().map(|x| x.pack(_fbb));
        let damageHitratePhysical = self.damageHitratePhysical.as_ref().map(|x| x.pack(_fbb));
        let damageHitrateMagical = self.damageHitrateMagical.as_ref().map(|x| x.pack(_fbb));
        let epBreakRecoverSpeed = self.epBreakRecoverSpeed.as_ref().map(|x| x.pack(_fbb));
        let stunImmune = self.stunImmune.as_ref().map(|x| x.pack(_fbb));
        let silenceImmune = self.silenceImmune.as_ref().map(|x| x.pack(_fbb));
        let sleepImmune = self.sleepImmune.as_ref().map(|x| x.pack(_fbb));
        let frozenImmune = self.frozenImmune.as_ref().map(|x| x.pack(_fbb));
        let levitateImmune = self.levitateImmune.as_ref().map(|x| x.pack(_fbb));
        let disarmedCombatImmune = self.disarmedCombatImmune.as_ref().map(|x| x.pack(_fbb));
        let fearedImmune = self.fearedImmune.as_ref().map(|x| x.pack(_fbb));
        let palsyImmune = self.palsyImmune.as_ref().map(|x| x.pack(_fbb));
        let attractImmune = self.attractImmune.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_EnemyDatabase_AttributesData::create(
            _fbb,
            &clz_Torappu_EnemyDatabase_AttributesDataArgs {
                maxHp,
                atk,
                def,
                magicResistance,
                cost,
                blockCnt,
                moveSpeed,
                attackSpeed,
                baseAttackTime,
                respawnTime,
                hpRecoveryPerSec,
                spRecoveryPerSec,
                maxDeployCount,
                massLevel,
                baseForceLevel,
                tauntLevel,
                epDamageResistance,
                epResistance,
                damageHitratePhysical,
                damageHitrateMagical,
                epBreakRecoverSpeed,
                stunImmune,
                silenceImmune,
                sleepImmune,
                frozenImmune,
                levitateImmune,
                disarmedCombatImmune,
                fearedImmune,
                palsyImmune,
                attractImmune,
            },
        )
    }
}
pub enum clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'a> {
    type Inner = clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Args,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Builder::new(_fbb);
        builder.add_m_value(args.m_value);
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_T {
        let m_defined = self.m_defined();
        let m_value = self.m_value();
        clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(&self) -> enum__Torappu_SourceApplyWay {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SourceApplyWay>(
                    clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_::VT_M_VALUE,
                    Some(enum__Torappu_SourceApplyWay::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<enum__Torappu_SourceApplyWay>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Args {
    pub m_defined: bool,
    pub m_value: enum__Torappu_SourceApplyWay,
}
impl<'a> Default for clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Args {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Args {
            m_defined: false,
            m_value: enum__Torappu_SourceApplyWay::NONE,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        s.serialize_field("m_value", &self.m_value())?;
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(&mut self, m_value: enum__Torappu_SourceApplyWay) {
        self.fbb_.push_slot::<enum__Torappu_SourceApplyWay>(
            clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_::VT_M_VALUE,
            m_value,
            enum__Torappu_SourceApplyWay::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_T {
    pub m_defined: bool,
    pub m_value: enum__Torappu_SourceApplyWay,
}
impl Default for clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: enum__Torappu_SourceApplyWay::NONE,
        }
    }
}
impl clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value;
        clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_::create(
            _fbb,
            &clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_Undefinable_1_Torappu_MotionMode_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_Torappu_MotionMode_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_Torappu_MotionMode_<'a> {
    type Inner = clz_Torappu_Undefinable_1_Torappu_MotionMode_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_Torappu_MotionMode_<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_Torappu_MotionMode_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_Torappu_MotionMode_Args,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_Torappu_MotionMode_Builder::new(_fbb);
        builder.add_m_value(args.m_value);
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_Torappu_MotionMode_T {
        let m_defined = self.m_defined();
        let m_value = self.m_value();
        clz_Torappu_Undefinable_1_Torappu_MotionMode_T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_Torappu_MotionMode_::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(&self) -> enum__Torappu_MotionMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_MotionMode>(
                    clz_Torappu_Undefinable_1_Torappu_MotionMode_::VT_M_VALUE,
                    Some(enum__Torappu_MotionMode::WALK),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_Torappu_MotionMode_<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<enum__Torappu_MotionMode>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_Torappu_MotionMode_Args {
    pub m_defined: bool,
    pub m_value: enum__Torappu_MotionMode,
}
impl<'a> Default for clz_Torappu_Undefinable_1_Torappu_MotionMode_Args {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_Torappu_MotionMode_Args {
            m_defined: false,
            m_value: enum__Torappu_MotionMode::WALK,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_Torappu_MotionMode_<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Undefinable_1_Torappu_MotionMode_", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        s.serialize_field("m_value", &self.m_value())?;
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_Torappu_MotionMode_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_Torappu_MotionMode_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_Torappu_MotionMode_::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(&mut self, m_value: enum__Torappu_MotionMode) {
        self.fbb_.push_slot::<enum__Torappu_MotionMode>(
            clz_Torappu_Undefinable_1_Torappu_MotionMode_::VT_M_VALUE,
            m_value,
            enum__Torappu_MotionMode::WALK,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_Torappu_MotionMode_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_Torappu_MotionMode_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_Torappu_MotionMode_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_Torappu_MotionMode_");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_Torappu_MotionMode_T {
    pub m_defined: bool,
    pub m_value: enum__Torappu_MotionMode,
}
impl Default for clz_Torappu_Undefinable_1_Torappu_MotionMode_T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: enum__Torappu_MotionMode::WALK,
        }
    }
}
impl clz_Torappu_Undefinable_1_Torappu_MotionMode_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value;
        clz_Torappu_Undefinable_1_Torappu_MotionMode_::create(
            _fbb,
            &clz_Torappu_Undefinable_1_Torappu_MotionMode_Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_Undefinable_1_System_String___Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_System_String___<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_System_String___<'a> {
    type Inner = clz_Torappu_Undefinable_1_System_String___<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_System_String___<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_System_String___ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_System_String___Args<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String___<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_System_String___Builder::new(_fbb);
        if let Some(x) = args.m_value {
            builder.add_m_value(x);
        }
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_System_String___T {
        let m_defined = self.m_defined();
        let m_value = self
            .m_value()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_Undefinable_1_System_String___T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_System_String___::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_Undefinable_1_System_String___::VT_M_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_System_String___<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_System_String___Args<'a> {
    pub m_defined: bool,
    pub m_value: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_Undefinable_1_System_String___Args<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_System_String___Args {
            m_defined: false,
            m_value: None,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_System_String___<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Undefinable_1_System_String___", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        if let Some(f) = self.m_value() {
            s.serialize_field("m_value", &f)?;
        } else {
            s.skip_field("m_value")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_System_String___Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_System_String___Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_System_String___::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(
        &mut self,
        m_value: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Undefinable_1_System_String___::VT_M_VALUE,
            m_value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_System_String___Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_System_String___Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String___<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_System_String___<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_System_String___");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_System_String___T {
    pub m_defined: bool,
    pub m_value: Option<Vec<String>>,
}
impl Default for clz_Torappu_Undefinable_1_System_String___T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: None,
        }
    }
}
impl clz_Torappu_Undefinable_1_System_String___T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String___<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_Undefinable_1_System_String___::create(
            _fbb,
            &clz_Torappu_Undefinable_1_System_String___Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'a> {
    type Inner = clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'a> {
    pub const VT_M_DEFINED: flatbuffers::VOffsetT = 4;
    pub const VT_M_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Args,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'bldr>> {
        let mut builder = clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Builder::new(_fbb);
        builder.add_m_value(args.m_value);
        builder.add_m_defined(args.m_defined);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_T {
        let m_defined = self.m_defined();
        let m_value = self.m_value();
        clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_T { m_defined, m_value }
    }

    #[inline]
    pub fn m_defined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_::VT_M_DEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn m_value(&self) -> enum__Torappu_EnemyLevelType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EnemyLevelType>(
                    clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_::VT_M_VALUE,
                    Some(enum__Torappu_EnemyLevelType::NORMAL),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("m_defined", Self::VT_M_DEFINED, false)?
            .visit_field::<enum__Torappu_EnemyLevelType>("m_value", Self::VT_M_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Args {
    pub m_defined: bool,
    pub m_value: enum__Torappu_EnemyLevelType,
}
impl<'a> Default for clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Args {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Args {
            m_defined: false,
            m_value: enum__Torappu_EnemyLevelType::NORMAL,
        }
    }
}

impl Serialize for clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_", 2)?;
        s.serialize_field("m_defined", &self.m_defined())?;
        s.serialize_field("m_value", &self.m_value())?;
        s.end()
    }
}

pub struct clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_m_defined(&mut self, m_defined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_::VT_M_DEFINED,
            m_defined,
            false,
        );
    }
    #[inline]
    pub fn add_m_value(&mut self, m_value: enum__Torappu_EnemyLevelType) {
        self.fbb_.push_slot::<enum__Torappu_EnemyLevelType>(
            clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_::VT_M_VALUE,
            m_value,
            enum__Torappu_EnemyLevelType::NORMAL,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_");
        ds.field("m_defined", &self.m_defined());
        ds.field("m_value", &self.m_value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_T {
    pub m_defined: bool,
    pub m_value: enum__Torappu_EnemyLevelType,
}
impl Default for clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_T {
    fn default() -> Self {
        Self {
            m_defined: false,
            m_value: enum__Torappu_EnemyLevelType::NORMAL,
        }
    }
}
impl clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_T {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'b>> {
        let m_defined = self.m_defined;
        let m_value = self.m_value;
        clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_::create(
            _fbb,
            &clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_Args { m_defined, m_value },
        )
    }
}
pub enum clz_Torappu_EnemyDatabase_EnemyDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_EnemyDatabase_EnemyData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_EnemyDatabase_EnemyData<'a> {
    type Inner = clz_Torappu_EnemyDatabase_EnemyData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_EnemyDatabase_EnemyData<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
    pub const VT_PREFABKEY: flatbuffers::VOffsetT = 8;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 10;
    pub const VT_APPLYWAY: flatbuffers::VOffsetT = 12;
    pub const VT_MOTION: flatbuffers::VOffsetT = 14;
    pub const VT_ENEMYTAGS: flatbuffers::VOffsetT = 16;
    pub const VT_LIFEPOINTREDUCE: flatbuffers::VOffsetT = 18;
    pub const VT_LEVELTYPE: flatbuffers::VOffsetT = 20;
    pub const VT_RANGERADIUS: flatbuffers::VOffsetT = 22;
    pub const VT_NUMOFEXTRADROPS: flatbuffers::VOffsetT = 24;
    pub const VT_VIEWRADIUS: flatbuffers::VOffsetT = 26;
    pub const VT_NOTCOUNTINTOTAL: flatbuffers::VOffsetT = 28;
    pub const VT_TALENTBLACKBOARD: flatbuffers::VOffsetT = 30;
    pub const VT_SKILLS: flatbuffers::VOffsetT = 32;
    pub const VT_SPDATA: flatbuffers::VOffsetT = 34;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_EnemyDatabase_EnemyData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_EnemyDatabase_EnemyDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_EnemyData<'bldr>> {
        let mut builder = clz_Torappu_EnemyDatabase_EnemyDataBuilder::new(_fbb);
        if let Some(x) = args.spData {
            builder.add_spData(x);
        }
        if let Some(x) = args.skills {
            builder.add_skills(x);
        }
        if let Some(x) = args.talentBlackboard {
            builder.add_talentBlackboard(x);
        }
        if let Some(x) = args.notCountInTotal {
            builder.add_notCountInTotal(x);
        }
        if let Some(x) = args.viewRadius {
            builder.add_viewRadius(x);
        }
        if let Some(x) = args.numOfExtraDrops {
            builder.add_numOfExtraDrops(x);
        }
        if let Some(x) = args.rangeRadius {
            builder.add_rangeRadius(x);
        }
        if let Some(x) = args.levelType {
            builder.add_levelType(x);
        }
        if let Some(x) = args.lifePointReduce {
            builder.add_lifePointReduce(x);
        }
        if let Some(x) = args.enemyTags {
            builder.add_enemyTags(x);
        }
        if let Some(x) = args.motion {
            builder.add_motion(x);
        }
        if let Some(x) = args.applyWay {
            builder.add_applyWay(x);
        }
        if let Some(x) = args.attributes {
            builder.add_attributes(x);
        }
        if let Some(x) = args.prefabKey {
            builder.add_prefabKey(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_EnemyDatabase_EnemyDataT {
        let name = self.name().map(|x| Box::new(x.unpack()));
        let description = self.description().map(|x| Box::new(x.unpack()));
        let prefabKey = self.prefabKey().map(|x| Box::new(x.unpack()));
        let attributes = self.attributes().map(|x| Box::new(x.unpack()));
        let applyWay = self.applyWay().map(|x| Box::new(x.unpack()));
        let motion = self.motion().map(|x| Box::new(x.unpack()));
        let enemyTags = self.enemyTags().map(|x| Box::new(x.unpack()));
        let lifePointReduce = self.lifePointReduce().map(|x| Box::new(x.unpack()));
        let levelType = self.levelType().map(|x| Box::new(x.unpack()));
        let rangeRadius = self.rangeRadius().map(|x| Box::new(x.unpack()));
        let numOfExtraDrops = self.numOfExtraDrops().map(|x| Box::new(x.unpack()));
        let viewRadius = self.viewRadius().map(|x| Box::new(x.unpack()));
        let notCountInTotal = self.notCountInTotal().map(|x| Box::new(x.unpack()));
        let talentBlackboard = self
            .talentBlackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let skills = self
            .skills()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let spData = self.spData().map(|x| Box::new(x.unpack()));
        clz_Torappu_EnemyDatabase_EnemyDataT {
            name,
            description,
            prefabKey,
            attributes,
            applyWay,
            motion,
            enemyTags,
            lifePointReduce,
            levelType,
            rangeRadius,
            numOfExtraDrops,
            viewRadius,
            notCountInTotal,
            talentBlackboard,
            skills,
            spData,
        }
    }

    #[inline]
    pub fn name(&self) -> Option<clz_Torappu_Undefinable_1_System_String_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_NAME,
                    None,
                )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<clz_Torappu_Undefinable_1_System_String_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_DESCRIPTION,
                    None,
                )
        }
    }
    #[inline]
    pub fn prefabKey(&self) -> Option<clz_Torappu_Undefinable_1_System_String_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_PREFABKEY,
                    None,
                )
        }
    }
    #[inline]
    pub fn attributes(&self) -> Option<clz_Torappu_EnemyDatabase_AttributesData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyDatabase_AttributesData>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_ATTRIBUTES,
                    None,
                )
        }
    }
    #[inline]
    pub fn applyWay(&self) -> Option<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_>>(clz_Torappu_EnemyDatabase_EnemyData::VT_APPLYWAY, None)
        }
    }
    #[inline]
    pub fn motion(&self) -> Option<clz_Torappu_Undefinable_1_Torappu_MotionMode_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_MOTION,
                    None,
                )
        }
    }
    #[inline]
    pub fn enemyTags(&self) -> Option<clz_Torappu_Undefinable_1_System_String___<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String___>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_ENEMYTAGS,
                    None,
                )
        }
    }
    #[inline]
    pub fn lifePointReduce(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_LIFEPOINTREDUCE,
                    None,
                )
        }
    }
    #[inline]
    pub fn levelType(&self) -> Option<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_>>(clz_Torappu_EnemyDatabase_EnemyData::VT_LEVELTYPE, None)
        }
    }
    #[inline]
    pub fn rangeRadius(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_RANGERADIUS,
                    None,
                )
        }
    }
    #[inline]
    pub fn numOfExtraDrops(&self) -> Option<clz_Torappu_Undefinable_1_System_Int32_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_NUMOFEXTRADROPS,
                    None,
                )
        }
    }
    #[inline]
    pub fn viewRadius(&self) -> Option<clz_Torappu_Undefinable_1_System_Single_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_VIEWRADIUS,
                    None,
                )
        }
    }
    #[inline]
    pub fn notCountInTotal(&self) -> Option<clz_Torappu_Undefinable_1_System_Boolean_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_NOTCOUNTINTOTAL,
                    None,
                )
        }
    }
    #[inline]
    pub fn talentBlackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_TALENTBLACKBOARD,
                None,
            )
        }
    }
    #[inline]
    pub fn skills(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESkillData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESkillData>,
                >,
            >>(clz_Torappu_EnemyDatabase_EnemyData::VT_SKILLS, None)
        }
    }
    #[inline]
    pub fn spData(&self) -> Option<clz_Torappu_LevelData_EnemyData_ESpData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESpData>>(
                    clz_Torappu_EnemyDatabase_EnemyData::VT_SPDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_EnemyDatabase_EnemyData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String_>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String_>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String_>>("prefabKey", Self::VT_PREFABKEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyDatabase_AttributesData>>("attributes", Self::VT_ATTRIBUTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_>>("applyWay", Self::VT_APPLYWAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_>>("motion", Self::VT_MOTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_String___>>("enemyTags", Self::VT_ENEMYTAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>("lifePointReduce", Self::VT_LIFEPOINTREDUCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_>>("levelType", Self::VT_LEVELTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>("rangeRadius", Self::VT_RANGERADIUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Int32_>>("numOfExtraDrops", Self::VT_NUMOFEXTRADROPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Single_>>("viewRadius", Self::VT_VIEWRADIUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Undefinable_1_System_Boolean_>>("notCountInTotal", Self::VT_NOTCOUNTINTOTAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>>>>("talentBlackboard", Self::VT_TALENTBLACKBOARD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESkillData>>>>("skills", Self::VT_SKILLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESpData>>("spData", Self::VT_SPDATA, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_EnemyDatabase_EnemyDataArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'a>>>,
    pub description: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'a>>>,
    pub prefabKey: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'a>>>,
    pub attributes: Option<flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_AttributesData<'a>>>,
    pub applyWay:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'a>>>,
    pub motion: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_<'a>>>,
    pub enemyTags: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String___<'a>>>,
    pub lifePointReduce:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub levelType:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'a>>>,
    pub rangeRadius: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub numOfExtraDrops:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'a>>>,
    pub viewRadius: Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'a>>>,
    pub notCountInTotal:
        Option<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'a>>>,
    pub talentBlackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
    pub skills: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESkillData<'a>>,
            >,
        >,
    >,
    pub spData: Option<flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESpData<'a>>>,
}
impl<'a> Default for clz_Torappu_EnemyDatabase_EnemyDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_EnemyDatabase_EnemyDataArgs {
            name: None,
            description: None,
            prefabKey: None,
            attributes: None,
            applyWay: None,
            motion: None,
            enemyTags: None,
            lifePointReduce: None,
            levelType: None,
            rangeRadius: None,
            numOfExtraDrops: None,
            viewRadius: None,
            notCountInTotal: None,
            talentBlackboard: None,
            skills: None,
            spData: None,
        }
    }
}

impl Serialize for clz_Torappu_EnemyDatabase_EnemyData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_EnemyDatabase_EnemyData", 16)?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.prefabKey() {
            s.serialize_field("prefabKey", &f)?;
        } else {
            s.skip_field("prefabKey")?;
        }
        if let Some(f) = self.attributes() {
            s.serialize_field("attributes", &f)?;
        } else {
            s.skip_field("attributes")?;
        }
        if let Some(f) = self.applyWay() {
            s.serialize_field("applyWay", &f)?;
        } else {
            s.skip_field("applyWay")?;
        }
        if let Some(f) = self.motion() {
            s.serialize_field("motion", &f)?;
        } else {
            s.skip_field("motion")?;
        }
        if let Some(f) = self.enemyTags() {
            s.serialize_field("enemyTags", &f)?;
        } else {
            s.skip_field("enemyTags")?;
        }
        if let Some(f) = self.lifePointReduce() {
            s.serialize_field("lifePointReduce", &f)?;
        } else {
            s.skip_field("lifePointReduce")?;
        }
        if let Some(f) = self.levelType() {
            s.serialize_field("levelType", &f)?;
        } else {
            s.skip_field("levelType")?;
        }
        if let Some(f) = self.rangeRadius() {
            s.serialize_field("rangeRadius", &f)?;
        } else {
            s.skip_field("rangeRadius")?;
        }
        if let Some(f) = self.numOfExtraDrops() {
            s.serialize_field("numOfExtraDrops", &f)?;
        } else {
            s.skip_field("numOfExtraDrops")?;
        }
        if let Some(f) = self.viewRadius() {
            s.serialize_field("viewRadius", &f)?;
        } else {
            s.skip_field("viewRadius")?;
        }
        if let Some(f) = self.notCountInTotal() {
            s.serialize_field("notCountInTotal", &f)?;
        } else {
            s.skip_field("notCountInTotal")?;
        }
        if let Some(f) = self.talentBlackboard() {
            s.serialize_field("talentBlackboard", &f)?;
        } else {
            s.skip_field("talentBlackboard")?;
        }
        if let Some(f) = self.skills() {
            s.serialize_field("skills", &f)?;
        } else {
            s.skip_field("skills")?;
        }
        if let Some(f) = self.spData() {
            s.serialize_field("spData", &f)?;
        } else {
            s.skip_field("spData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_EnemyDatabase_EnemyDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_EnemyDatabase_EnemyDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_name(
        &mut self,
        name: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_NAME,
                name,
            );
    }
    #[inline]
    pub fn add_description(
        &mut self,
        description: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_DESCRIPTION,
                description,
            );
    }
    #[inline]
    pub fn add_prefabKey(
        &mut self,
        prefabKey: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_PREFABKEY,
                prefabKey,
            );
    }
    #[inline]
    pub fn add_attributes(
        &mut self,
        attributes: flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_AttributesData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_AttributesData>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_ATTRIBUTES,
                attributes,
            );
    }
    #[inline]
    pub fn add_applyWay(
        &mut self,
        applyWay: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_>>(clz_Torappu_EnemyDatabase_EnemyData::VT_APPLYWAY, applyWay);
    }
    #[inline]
    pub fn add_motion(
        &mut self,
        motion: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_MotionMode_>>(clz_Torappu_EnemyDatabase_EnemyData::VT_MOTION, motion);
    }
    #[inline]
    pub fn add_enemyTags(
        &mut self,
        enemyTags: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String___<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_String___>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_ENEMYTAGS,
                enemyTags,
            );
    }
    #[inline]
    pub fn add_lifePointReduce(
        &mut self,
        lifePointReduce: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_LIFEPOINTREDUCE,
                lifePointReduce,
            );
    }
    #[inline]
    pub fn add_levelType(
        &mut self,
        levelType: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_>>(clz_Torappu_EnemyDatabase_EnemyData::VT_LEVELTYPE, levelType);
    }
    #[inline]
    pub fn add_rangeRadius(
        &mut self,
        rangeRadius: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_RANGERADIUS,
                rangeRadius,
            );
    }
    #[inline]
    pub fn add_numOfExtraDrops(
        &mut self,
        numOfExtraDrops: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Int32_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_NUMOFEXTRADROPS,
                numOfExtraDrops,
            );
    }
    #[inline]
    pub fn add_viewRadius(
        &mut self,
        viewRadius: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Single_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_VIEWRADIUS,
                viewRadius,
            );
    }
    #[inline]
    pub fn add_notCountInTotal(
        &mut self,
        notCountInTotal: flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Undefinable_1_System_Boolean_>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_NOTCOUNTINTOTAL,
                notCountInTotal,
            );
    }
    #[inline]
    pub fn add_talentBlackboard(
        &mut self,
        talentBlackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyDatabase_EnemyData::VT_TALENTBLACKBOARD,
            talentBlackboard,
        );
    }
    #[inline]
    pub fn add_skills(
        &mut self,
        skills: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData_ESkillData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyDatabase_EnemyData::VT_SKILLS,
            skills,
        );
    }
    #[inline]
    pub fn add_spData(
        &mut self,
        spData: flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESpData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyData_ESpData>>(
                clz_Torappu_EnemyDatabase_EnemyData::VT_SPDATA,
                spData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_EnemyDatabase_EnemyDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_EnemyDatabase_EnemyDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_EnemyData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_EnemyDatabase_EnemyData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_EnemyDatabase_EnemyData");
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("prefabKey", &self.prefabKey());
        ds.field("attributes", &self.attributes());
        ds.field("applyWay", &self.applyWay());
        ds.field("motion", &self.motion());
        ds.field("enemyTags", &self.enemyTags());
        ds.field("lifePointReduce", &self.lifePointReduce());
        ds.field("levelType", &self.levelType());
        ds.field("rangeRadius", &self.rangeRadius());
        ds.field("numOfExtraDrops", &self.numOfExtraDrops());
        ds.field("viewRadius", &self.viewRadius());
        ds.field("notCountInTotal", &self.notCountInTotal());
        ds.field("talentBlackboard", &self.talentBlackboard());
        ds.field("skills", &self.skills());
        ds.field("spData", &self.spData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_EnemyDatabase_EnemyDataT {
    pub name: Option<Box<clz_Torappu_Undefinable_1_System_String_T>>,
    pub description: Option<Box<clz_Torappu_Undefinable_1_System_String_T>>,
    pub prefabKey: Option<Box<clz_Torappu_Undefinable_1_System_String_T>>,
    pub attributes: Option<Box<clz_Torappu_EnemyDatabase_AttributesDataT>>,
    pub applyWay: Option<Box<clz_Torappu_Undefinable_1_Torappu_SourceApplyWay_T>>,
    pub motion: Option<Box<clz_Torappu_Undefinable_1_Torappu_MotionMode_T>>,
    pub enemyTags: Option<Box<clz_Torappu_Undefinable_1_System_String___T>>,
    pub lifePointReduce: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub levelType: Option<Box<clz_Torappu_Undefinable_1_Torappu_EnemyLevelType_T>>,
    pub rangeRadius: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub numOfExtraDrops: Option<Box<clz_Torappu_Undefinable_1_System_Int32_T>>,
    pub viewRadius: Option<Box<clz_Torappu_Undefinable_1_System_Single_T>>,
    pub notCountInTotal: Option<Box<clz_Torappu_Undefinable_1_System_Boolean_T>>,
    pub talentBlackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
    pub skills: Option<Vec<clz_Torappu_LevelData_EnemyData_ESkillDataT>>,
    pub spData: Option<Box<clz_Torappu_LevelData_EnemyData_ESpDataT>>,
}
impl Default for clz_Torappu_EnemyDatabase_EnemyDataT {
    fn default() -> Self {
        Self {
            name: None,
            description: None,
            prefabKey: None,
            attributes: None,
            applyWay: None,
            motion: None,
            enemyTags: None,
            lifePointReduce: None,
            levelType: None,
            rangeRadius: None,
            numOfExtraDrops: None,
            viewRadius: None,
            notCountInTotal: None,
            talentBlackboard: None,
            skills: None,
            spData: None,
        }
    }
}
impl clz_Torappu_EnemyDatabase_EnemyDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_EnemyData<'b>> {
        let name = self.name.as_ref().map(|x| x.pack(_fbb));
        let description = self.description.as_ref().map(|x| x.pack(_fbb));
        let prefabKey = self.prefabKey.as_ref().map(|x| x.pack(_fbb));
        let attributes = self.attributes.as_ref().map(|x| x.pack(_fbb));
        let applyWay = self.applyWay.as_ref().map(|x| x.pack(_fbb));
        let motion = self.motion.as_ref().map(|x| x.pack(_fbb));
        let enemyTags = self.enemyTags.as_ref().map(|x| x.pack(_fbb));
        let lifePointReduce = self.lifePointReduce.as_ref().map(|x| x.pack(_fbb));
        let levelType = self.levelType.as_ref().map(|x| x.pack(_fbb));
        let rangeRadius = self.rangeRadius.as_ref().map(|x| x.pack(_fbb));
        let numOfExtraDrops = self.numOfExtraDrops.as_ref().map(|x| x.pack(_fbb));
        let viewRadius = self.viewRadius.as_ref().map(|x| x.pack(_fbb));
        let notCountInTotal = self.notCountInTotal.as_ref().map(|x| x.pack(_fbb));
        let talentBlackboard = self.talentBlackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let skills = self.skills.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let spData = self.spData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_EnemyDatabase_EnemyData::create(
            _fbb,
            &clz_Torappu_EnemyDatabase_EnemyDataArgs {
                name,
                description,
                prefabKey,
                attributes,
                applyWay,
                motion,
                enemyTags,
                lifePointReduce,
                levelType,
                rangeRadius,
                numOfExtraDrops,
                viewRadius,
                notCountInTotal,
                talentBlackboard,
                skills,
                spData,
            },
        )
    }
}
pub enum clz_Torappu_LevelData_EnemyDataDbReferenceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_EnemyDataDbReference<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_EnemyDataDbReference<'a> {
    type Inner = clz_Torappu_LevelData_EnemyDataDbReference<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_EnemyDataDbReference<'a> {
    pub const VT_USEDB: flatbuffers::VOffsetT = 4;
    pub const VT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 8;
    pub const VT_OVERWRITTENDATA: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_EnemyDataDbReference { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_EnemyDataDbReferenceArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyDataDbReference<'bldr>> {
        let mut builder = clz_Torappu_LevelData_EnemyDataDbReferenceBuilder::new(_fbb);
        if let Some(x) = args.overwrittenData {
            builder.add_overwrittenData(x);
        }
        builder.add_level(args.level);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_useDb(args.useDb);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_EnemyDataDbReferenceT {
        let useDb = self.useDb();
        let id = self.id().map(|x| x.to_string());
        let level = self.level();
        let overwrittenData = self.overwrittenData().map(|x| Box::new(x.unpack()));
        clz_Torappu_LevelData_EnemyDataDbReferenceT {
            useDb,
            id,
            level,
            overwrittenData,
        }
    }

    #[inline]
    pub fn useDb(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_EnemyDataDbReference::VT_USEDB,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_EnemyDataDbReference::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_LevelData_EnemyDataDbReference::VT_LEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn overwrittenData(&self) -> Option<clz_Torappu_EnemyDatabase_EnemyData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyDatabase_EnemyData>>(
                    clz_Torappu_LevelData_EnemyDataDbReference::VT_OVERWRITTENDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_EnemyDataDbReference<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("useDb", Self::VT_USEDB, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyDatabase_EnemyData>>(
                "overwrittenData",
                Self::VT_OVERWRITTENDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_EnemyDataDbReferenceArgs<'a> {
    pub useDb: bool,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub level: i32,
    pub overwrittenData: Option<flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_EnemyData<'a>>>,
}
impl<'a> Default for clz_Torappu_LevelData_EnemyDataDbReferenceArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_EnemyDataDbReferenceArgs {
            useDb: false,
            id: None,
            level: 0,
            overwrittenData: None,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_EnemyDataDbReference<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LevelData_EnemyDataDbReference", 4)?;
        s.serialize_field("useDb", &self.useDb())?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("level", &self.level())?;
        if let Some(f) = self.overwrittenData() {
            s.serialize_field("overwrittenData", &f)?;
        } else {
            s.skip_field("overwrittenData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LevelData_EnemyDataDbReferenceBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LevelData_EnemyDataDbReferenceBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_useDb(&mut self, useDb: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_EnemyDataDbReference::VT_USEDB,
            useDb,
            false,
        );
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_EnemyDataDbReference::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_EnemyDataDbReference::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn add_overwrittenData(
        &mut self,
        overwrittenData: flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_EnemyData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EnemyDatabase_EnemyData>>(
                clz_Torappu_LevelData_EnemyDataDbReference::VT_OVERWRITTENDATA,
                overwrittenData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_EnemyDataDbReferenceBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_EnemyDataDbReferenceBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyDataDbReference<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_EnemyDataDbReference<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_EnemyDataDbReference");
        ds.field("useDb", &self.useDb());
        ds.field("id", &self.id());
        ds.field("level", &self.level());
        ds.field("overwrittenData", &self.overwrittenData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_EnemyDataDbReferenceT {
    pub useDb: bool,
    pub id: Option<String>,
    pub level: i32,
    pub overwrittenData: Option<Box<clz_Torappu_EnemyDatabase_EnemyDataT>>,
}
impl Default for clz_Torappu_LevelData_EnemyDataDbReferenceT {
    fn default() -> Self {
        Self {
            useDb: false,
            id: None,
            level: 0,
            overwrittenData: None,
        }
    }
}
impl clz_Torappu_LevelData_EnemyDataDbReferenceT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_EnemyDataDbReference<'b>> {
        let useDb = self.useDb;
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let level = self.level;
        let overwrittenData = self.overwrittenData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_LevelData_EnemyDataDbReference::create(
            _fbb,
            &clz_Torappu_LevelData_EnemyDataDbReferenceArgs {
                useDb,
                id,
                level,
                overwrittenData,
            },
        )
    }
}
pub enum clz_Torappu_LevelData_WaveData_FragmentData_ActionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'a> {
    type Inner = clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'a> {
    pub const VT_ACTIONTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_MANAGEDBYSCHEDULER: flatbuffers::VOffsetT = 6;
    pub const VT_KEY: flatbuffers::VOffsetT = 8;
    pub const VT_COUNT: flatbuffers::VOffsetT = 10;
    pub const VT_PREDELAY: flatbuffers::VOffsetT = 12;
    pub const VT_INTERVAL: flatbuffers::VOffsetT = 14;
    pub const VT_ROUTEINDEX: flatbuffers::VOffsetT = 16;
    pub const VT_BLOCKFRAGMENT: flatbuffers::VOffsetT = 18;
    pub const VT_AUTOPREVIEWROUTE: flatbuffers::VOffsetT = 20;
    pub const VT_AUTODISPLAYENEMYINFO: flatbuffers::VOffsetT = 22;
    pub const VT_ISUNHARMFULANDALWAYSCOUNTASKILLED: flatbuffers::VOffsetT = 24;
    pub const VT_HIDDENGROUP: flatbuffers::VOffsetT = 26;
    pub const VT_RANDOMSPAWNGROUPKEY: flatbuffers::VOffsetT = 28;
    pub const VT_RANDOMSPAWNGROUPPACKKEY: flatbuffers::VOffsetT = 30;
    pub const VT_RANDOMTYPE: flatbuffers::VOffsetT = 32;
    pub const VT_REFRESHTYPE: flatbuffers::VOffsetT = 34;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 36;
    pub const VT_DONTBLOCKWAVE: flatbuffers::VOffsetT = 38;
    pub const VT_FORCEBLOCKWAVEINBRANCH: flatbuffers::VOffsetT = 40;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_WaveData_FragmentData_ActionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_WaveData_FragmentData_ActionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'bldr>> {
        let mut builder = clz_Torappu_LevelData_WaveData_FragmentData_ActionDataBuilder::new(_fbb);
        builder.add_weight(args.weight);
        builder.add_refreshType(args.refreshType);
        builder.add_randomType(args.randomType);
        if let Some(x) = args.randomSpawnGroupPackKey {
            builder.add_randomSpawnGroupPackKey(x);
        }
        if let Some(x) = args.randomSpawnGroupKey {
            builder.add_randomSpawnGroupKey(x);
        }
        if let Some(x) = args.hiddenGroup {
            builder.add_hiddenGroup(x);
        }
        builder.add_routeIndex(args.routeIndex);
        builder.add_interval(args.interval);
        builder.add_preDelay(args.preDelay);
        builder.add_count(args.count);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.add_actionType(args.actionType);
        builder.add_forceBlockWaveInBranch(args.forceBlockWaveInBranch);
        builder.add_dontBlockWave(args.dontBlockWave);
        builder.add_isUnharmfulAndAlwaysCountAsKilled(args.isUnharmfulAndAlwaysCountAsKilled);
        builder.add_autoDisplayEnemyInfo(args.autoDisplayEnemyInfo);
        builder.add_autoPreviewRoute(args.autoPreviewRoute);
        builder.add_blockFragment(args.blockFragment);
        builder.add_managedByScheduler(args.managedByScheduler);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_WaveData_FragmentData_ActionDataT {
        let actionType = self.actionType();
        let managedByScheduler = self.managedByScheduler();
        let key = self.key().map(|x| x.to_string());
        let count = self.count();
        let preDelay = self.preDelay();
        let interval = self.interval();
        let routeIndex = self.routeIndex();
        let blockFragment = self.blockFragment();
        let autoPreviewRoute = self.autoPreviewRoute();
        let autoDisplayEnemyInfo = self.autoDisplayEnemyInfo();
        let isUnharmfulAndAlwaysCountAsKilled = self.isUnharmfulAndAlwaysCountAsKilled();
        let hiddenGroup = self.hiddenGroup().map(|x| x.to_string());
        let randomSpawnGroupKey = self.randomSpawnGroupKey().map(|x| x.to_string());
        let randomSpawnGroupPackKey = self.randomSpawnGroupPackKey().map(|x| x.to_string());
        let randomType = self.randomType();
        let refreshType = self.refreshType();
        let weight = self.weight();
        let dontBlockWave = self.dontBlockWave();
        let forceBlockWaveInBranch = self.forceBlockWaveInBranch();
        clz_Torappu_LevelData_WaveData_FragmentData_ActionDataT {
            actionType,
            managedByScheduler,
            key,
            count,
            preDelay,
            interval,
            routeIndex,
            blockFragment,
            autoPreviewRoute,
            autoDisplayEnemyInfo,
            isUnharmfulAndAlwaysCountAsKilled,
            hiddenGroup,
            randomSpawnGroupKey,
            randomSpawnGroupPackKey,
            randomType,
            refreshType,
            weight,
            dontBlockWave,
            forceBlockWaveInBranch,
        }
    }

    #[inline]
    pub fn actionType(
        &self,
    ) -> enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType>(
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_ACTIONTYPE,
                    Some(
                        enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::SPAWN,
                    ),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn managedByScheduler(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_MANAGEDBYSCHEDULER,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_COUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn preDelay(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_PREDELAY,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn interval(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_INTERVAL,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn routeIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_ROUTEINDEX,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn blockFragment(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_BLOCKFRAGMENT,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn autoPreviewRoute(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_AUTOPREVIEWROUTE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn autoDisplayEnemyInfo(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_AUTODISPLAYENEMYINFO,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isUnharmfulAndAlwaysCountAsKilled(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<bool>(clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_ISUNHARMFULANDALWAYSCOUNTASKILLED, Some(false)).unwrap()
        }
    }
    #[inline]
    pub fn hiddenGroup(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_HIDDENGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn randomSpawnGroupKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_RANDOMSPAWNGROUPKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn randomSpawnGroupPackKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_RANDOMSPAWNGROUPPACKKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn randomType(
        &self,
    ) -> enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType>(
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_RANDOMTYPE,
                    Some(
                        enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType::ALWAYS,
                    ),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn refreshType(
        &self,
    ) -> enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType>(clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_REFRESHTYPE, Some(enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType::ALWAYS)).unwrap()
        }
    }
    #[inline]
    pub fn weight(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_WEIGHT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn dontBlockWave(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_DONTBLOCKWAVE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn forceBlockWaveInBranch(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<bool>(clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_FORCEBLOCKWAVEINBRANCH, Some(false)).unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType>(
                "actionType",
                Self::VT_ACTIONTYPE,
                false,
            )?
            .visit_field::<bool>("managedByScheduler", Self::VT_MANAGEDBYSCHEDULER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<f32>("preDelay", Self::VT_PREDELAY, false)?
            .visit_field::<f32>("interval", Self::VT_INTERVAL, false)?
            .visit_field::<i32>("routeIndex", Self::VT_ROUTEINDEX, false)?
            .visit_field::<bool>("blockFragment", Self::VT_BLOCKFRAGMENT, false)?
            .visit_field::<bool>("autoPreviewRoute", Self::VT_AUTOPREVIEWROUTE, false)?
            .visit_field::<bool>("autoDisplayEnemyInfo", Self::VT_AUTODISPLAYENEMYINFO, false)?
            .visit_field::<bool>(
                "isUnharmfulAndAlwaysCountAsKilled",
                Self::VT_ISUNHARMFULANDALWAYSCOUNTASKILLED,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "hiddenGroup",
                Self::VT_HIDDENGROUP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "randomSpawnGroupKey",
                Self::VT_RANDOMSPAWNGROUPKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "randomSpawnGroupPackKey",
                Self::VT_RANDOMSPAWNGROUPPACKKEY,
                false,
            )?
            .visit_field::<enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType>(
                "randomType",
                Self::VT_RANDOMTYPE,
                false,
            )?
            .visit_field::<enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType>(
                "refreshType",
                Self::VT_REFRESHTYPE,
                false,
            )?
            .visit_field::<i32>("weight", Self::VT_WEIGHT, false)?
            .visit_field::<bool>("dontBlockWave", Self::VT_DONTBLOCKWAVE, false)?
            .visit_field::<bool>(
                "forceBlockWaveInBranch",
                Self::VT_FORCEBLOCKWAVEINBRANCH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_WaveData_FragmentData_ActionDataArgs<'a> {
    pub actionType: enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType,
    pub managedByScheduler: bool,
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub preDelay: f32,
    pub interval: f32,
    pub routeIndex: i32,
    pub blockFragment: bool,
    pub autoPreviewRoute: bool,
    pub autoDisplayEnemyInfo: bool,
    pub isUnharmfulAndAlwaysCountAsKilled: bool,
    pub hiddenGroup: Option<flatbuffers::WIPOffset<&'a str>>,
    pub randomSpawnGroupKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub randomSpawnGroupPackKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub randomType: enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType,
    pub refreshType: enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType,
    pub weight: i32,
    pub dontBlockWave: bool,
    pub forceBlockWaveInBranch: bool,
}
impl<'a> Default for clz_Torappu_LevelData_WaveData_FragmentData_ActionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_WaveData_FragmentData_ActionDataArgs {
            actionType: enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::SPAWN,
            managedByScheduler: false,
            key: None,
            count: 0,
            preDelay: 0.0,
            interval: 0.0,
            routeIndex: 0,
            blockFragment: false,
            autoPreviewRoute: false,
            autoDisplayEnemyInfo: false,
            isUnharmfulAndAlwaysCountAsKilled: false,
            hiddenGroup: None,
            randomSpawnGroupKey: None,
            randomSpawnGroupPackKey: None,
            randomType: enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType::ALWAYS,
            refreshType:
                enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType::ALWAYS,
            weight: 0,
            dontBlockWave: false,
            forceBlockWaveInBranch: false,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("clz_Torappu_LevelData_WaveData_FragmentData_ActionData", 19)?;
        s.serialize_field("actionType", &self.actionType())?;
        s.serialize_field("managedByScheduler", &self.managedByScheduler())?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        s.serialize_field("count", &self.count())?;
        s.serialize_field("preDelay", &self.preDelay())?;
        s.serialize_field("interval", &self.interval())?;
        s.serialize_field("routeIndex", &self.routeIndex())?;
        s.serialize_field("blockFragment", &self.blockFragment())?;
        s.serialize_field("autoPreviewRoute", &self.autoPreviewRoute())?;
        s.serialize_field("autoDisplayEnemyInfo", &self.autoDisplayEnemyInfo())?;
        s.serialize_field(
            "isUnharmfulAndAlwaysCountAsKilled",
            &self.isUnharmfulAndAlwaysCountAsKilled(),
        )?;
        if let Some(f) = self.hiddenGroup() {
            s.serialize_field("hiddenGroup", &f)?;
        } else {
            s.skip_field("hiddenGroup")?;
        }
        if let Some(f) = self.randomSpawnGroupKey() {
            s.serialize_field("randomSpawnGroupKey", &f)?;
        } else {
            s.skip_field("randomSpawnGroupKey")?;
        }
        if let Some(f) = self.randomSpawnGroupPackKey() {
            s.serialize_field("randomSpawnGroupPackKey", &f)?;
        } else {
            s.skip_field("randomSpawnGroupPackKey")?;
        }
        s.serialize_field("randomType", &self.randomType())?;
        s.serialize_field("refreshType", &self.refreshType())?;
        s.serialize_field("weight", &self.weight())?;
        s.serialize_field("dontBlockWave", &self.dontBlockWave())?;
        s.serialize_field("forceBlockWaveInBranch", &self.forceBlockWaveInBranch())?;
        s.end()
    }
}

pub struct clz_Torappu_LevelData_WaveData_FragmentData_ActionDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LevelData_WaveData_FragmentData_ActionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_actionType(
        &mut self,
        actionType: enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType>(
                clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_ACTIONTYPE,
                actionType,
                enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::SPAWN,
            );
    }
    #[inline]
    pub fn add_managedByScheduler(&mut self, managedByScheduler: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_MANAGEDBYSCHEDULER,
            managedByScheduler,
            false,
        );
    }
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_COUNT,
            count,
            0,
        );
    }
    #[inline]
    pub fn add_preDelay(&mut self, preDelay: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_PREDELAY,
            preDelay,
            0.0,
        );
    }
    #[inline]
    pub fn add_interval(&mut self, interval: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_INTERVAL,
            interval,
            0.0,
        );
    }
    #[inline]
    pub fn add_routeIndex(&mut self, routeIndex: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_ROUTEINDEX,
            routeIndex,
            0,
        );
    }
    #[inline]
    pub fn add_blockFragment(&mut self, blockFragment: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_BLOCKFRAGMENT,
            blockFragment,
            false,
        );
    }
    #[inline]
    pub fn add_autoPreviewRoute(&mut self, autoPreviewRoute: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_AUTOPREVIEWROUTE,
            autoPreviewRoute,
            false,
        );
    }
    #[inline]
    pub fn add_autoDisplayEnemyInfo(&mut self, autoDisplayEnemyInfo: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_AUTODISPLAYENEMYINFO,
            autoDisplayEnemyInfo,
            false,
        );
    }
    #[inline]
    pub fn add_isUnharmfulAndAlwaysCountAsKilled(
        &mut self,
        isUnharmfulAndAlwaysCountAsKilled: bool,
    ) {
        self.fbb_.push_slot::<bool>(clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_ISUNHARMFULANDALWAYSCOUNTASKILLED, isUnharmfulAndAlwaysCountAsKilled, false);
    }
    #[inline]
    pub fn add_hiddenGroup(&mut self, hiddenGroup: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_HIDDENGROUP,
            hiddenGroup,
        );
    }
    #[inline]
    pub fn add_randomSpawnGroupKey(
        &mut self,
        randomSpawnGroupKey: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_RANDOMSPAWNGROUPKEY,
            randomSpawnGroupKey,
        );
    }
    #[inline]
    pub fn add_randomSpawnGroupPackKey(
        &mut self,
        randomSpawnGroupPackKey: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_RANDOMSPAWNGROUPPACKKEY,
            randomSpawnGroupPackKey,
        );
    }
    #[inline]
    pub fn add_randomType(
        &mut self,
        randomType: enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType>(
                clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_RANDOMTYPE,
                randomType,
                enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType::ALWAYS,
            );
    }
    #[inline]
    pub fn add_refreshType(
        &mut self,
        refreshType: enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType>(
                clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_REFRESHTYPE,
                refreshType,
                enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType::ALWAYS,
            );
    }
    #[inline]
    pub fn add_weight(&mut self, weight: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_WEIGHT,
            weight,
            0,
        );
    }
    #[inline]
    pub fn add_dontBlockWave(&mut self, dontBlockWave: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_DONTBLOCKWAVE,
            dontBlockWave,
            false,
        );
    }
    #[inline]
    pub fn add_forceBlockWaveInBranch(&mut self, forceBlockWaveInBranch: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_WaveData_FragmentData_ActionData::VT_FORCEBLOCKWAVEINBRANCH,
            forceBlockWaveInBranch,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_WaveData_FragmentData_ActionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_WaveData_FragmentData_ActionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_WaveData_FragmentData_ActionData");
        ds.field("actionType", &self.actionType());
        ds.field("managedByScheduler", &self.managedByScheduler());
        ds.field("key", &self.key());
        ds.field("count", &self.count());
        ds.field("preDelay", &self.preDelay());
        ds.field("interval", &self.interval());
        ds.field("routeIndex", &self.routeIndex());
        ds.field("blockFragment", &self.blockFragment());
        ds.field("autoPreviewRoute", &self.autoPreviewRoute());
        ds.field("autoDisplayEnemyInfo", &self.autoDisplayEnemyInfo());
        ds.field(
            "isUnharmfulAndAlwaysCountAsKilled",
            &self.isUnharmfulAndAlwaysCountAsKilled(),
        );
        ds.field("hiddenGroup", &self.hiddenGroup());
        ds.field("randomSpawnGroupKey", &self.randomSpawnGroupKey());
        ds.field("randomSpawnGroupPackKey", &self.randomSpawnGroupPackKey());
        ds.field("randomType", &self.randomType());
        ds.field("refreshType", &self.refreshType());
        ds.field("weight", &self.weight());
        ds.field("dontBlockWave", &self.dontBlockWave());
        ds.field("forceBlockWaveInBranch", &self.forceBlockWaveInBranch());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_WaveData_FragmentData_ActionDataT {
    pub actionType: enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType,
    pub managedByScheduler: bool,
    pub key: Option<String>,
    pub count: i32,
    pub preDelay: f32,
    pub interval: f32,
    pub routeIndex: i32,
    pub blockFragment: bool,
    pub autoPreviewRoute: bool,
    pub autoDisplayEnemyInfo: bool,
    pub isUnharmfulAndAlwaysCountAsKilled: bool,
    pub hiddenGroup: Option<String>,
    pub randomSpawnGroupKey: Option<String>,
    pub randomSpawnGroupPackKey: Option<String>,
    pub randomType: enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType,
    pub refreshType: enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType,
    pub weight: i32,
    pub dontBlockWave: bool,
    pub forceBlockWaveInBranch: bool,
}
impl Default for clz_Torappu_LevelData_WaveData_FragmentData_ActionDataT {
    fn default() -> Self {
        Self {
            actionType: enum__Torappu_LevelData_WaveData_FragmentData_ActionData_ActionType::SPAWN,
            managedByScheduler: false,
            key: None,
            count: 0,
            preDelay: 0.0,
            interval: 0.0,
            routeIndex: 0,
            blockFragment: false,
            autoPreviewRoute: false,
            autoDisplayEnemyInfo: false,
            isUnharmfulAndAlwaysCountAsKilled: false,
            hiddenGroup: None,
            randomSpawnGroupKey: None,
            randomSpawnGroupPackKey: None,
            randomType: enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RandomType::ALWAYS,
            refreshType:
                enum__Torappu_LevelData_WaveData_FragmentData_ActionData_RefreshType::ALWAYS,
            weight: 0,
            dontBlockWave: false,
            forceBlockWaveInBranch: false,
        }
    }
}
impl clz_Torappu_LevelData_WaveData_FragmentData_ActionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'b>> {
        let actionType = self.actionType;
        let managedByScheduler = self.managedByScheduler;
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        let preDelay = self.preDelay;
        let interval = self.interval;
        let routeIndex = self.routeIndex;
        let blockFragment = self.blockFragment;
        let autoPreviewRoute = self.autoPreviewRoute;
        let autoDisplayEnemyInfo = self.autoDisplayEnemyInfo;
        let isUnharmfulAndAlwaysCountAsKilled = self.isUnharmfulAndAlwaysCountAsKilled;
        let hiddenGroup = self.hiddenGroup.as_ref().map(|x| _fbb.create_string(x));
        let randomSpawnGroupKey = self
            .randomSpawnGroupKey
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let randomSpawnGroupPackKey = self
            .randomSpawnGroupPackKey
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let randomType = self.randomType;
        let refreshType = self.refreshType;
        let weight = self.weight;
        let dontBlockWave = self.dontBlockWave;
        let forceBlockWaveInBranch = self.forceBlockWaveInBranch;
        clz_Torappu_LevelData_WaveData_FragmentData_ActionData::create(
            _fbb,
            &clz_Torappu_LevelData_WaveData_FragmentData_ActionDataArgs {
                actionType,
                managedByScheduler,
                key,
                count,
                preDelay,
                interval,
                routeIndex,
                blockFragment,
                autoPreviewRoute,
                autoDisplayEnemyInfo,
                isUnharmfulAndAlwaysCountAsKilled,
                hiddenGroup,
                randomSpawnGroupKey,
                randomSpawnGroupPackKey,
                randomType,
                refreshType,
                weight,
                dontBlockWave,
                forceBlockWaveInBranch,
            },
        )
    }
}
pub enum clz_Torappu_LevelData_WaveData_FragmentDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_WaveData_FragmentData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_WaveData_FragmentData<'a> {
    type Inner = clz_Torappu_LevelData_WaveData_FragmentData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_WaveData_FragmentData<'a> {
    pub const VT_PREDELAY: flatbuffers::VOffsetT = 4;
    pub const VT_ACTIONS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_WaveData_FragmentData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_WaveData_FragmentDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_WaveData_FragmentData<'bldr>> {
        let mut builder = clz_Torappu_LevelData_WaveData_FragmentDataBuilder::new(_fbb);
        if let Some(x) = args.actions {
            builder.add_actions(x);
        }
        builder.add_preDelay(args.preDelay);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_WaveData_FragmentDataT {
        let preDelay = self.preDelay();
        let actions = self
            .actions()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_LevelData_WaveData_FragmentDataT { preDelay, actions }
    }

    #[inline]
    pub fn preDelay(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_LevelData_WaveData_FragmentData::VT_PREDELAY,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn actions(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_LevelData_WaveData_FragmentData_ActionData,
                    >,
                >,
            >>(
                clz_Torappu_LevelData_WaveData_FragmentData::VT_ACTIONS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_WaveData_FragmentData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("preDelay", Self::VT_PREDELAY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_LevelData_WaveData_FragmentData_ActionData,
                    >,
                >,
            >>("actions", Self::VT_ACTIONS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_WaveData_FragmentDataArgs<'a> {
    pub preDelay: f32,
    pub actions: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_LevelData_WaveData_FragmentDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_WaveData_FragmentDataArgs {
            preDelay: 0.0,
            actions: None,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_WaveData_FragmentData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_LevelData_WaveData_FragmentData", 2)?;
        s.serialize_field("preDelay", &self.preDelay())?;
        if let Some(f) = self.actions() {
            s.serialize_field("actions", &f)?;
        } else {
            s.skip_field("actions")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LevelData_WaveData_FragmentDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LevelData_WaveData_FragmentDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_preDelay(&mut self, preDelay: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_WaveData_FragmentData::VT_PREDELAY,
            preDelay,
            0.0,
        );
    }
    #[inline]
    pub fn add_actions(
        &mut self,
        actions: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_WaveData_FragmentData::VT_ACTIONS,
            actions,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_WaveData_FragmentDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_WaveData_FragmentDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_WaveData_FragmentData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_WaveData_FragmentData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_WaveData_FragmentData");
        ds.field("preDelay", &self.preDelay());
        ds.field("actions", &self.actions());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_WaveData_FragmentDataT {
    pub preDelay: f32,
    pub actions: Option<Vec<clz_Torappu_LevelData_WaveData_FragmentData_ActionDataT>>,
}
impl Default for clz_Torappu_LevelData_WaveData_FragmentDataT {
    fn default() -> Self {
        Self {
            preDelay: 0.0,
            actions: None,
        }
    }
}
impl clz_Torappu_LevelData_WaveData_FragmentDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_WaveData_FragmentData<'b>> {
        let preDelay = self.preDelay;
        let actions = self.actions.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_LevelData_WaveData_FragmentData::create(
            _fbb,
            &clz_Torappu_LevelData_WaveData_FragmentDataArgs { preDelay, actions },
        )
    }
}
pub enum clz_Torappu_LevelData_WaveDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_WaveData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_WaveData<'a> {
    type Inner = clz_Torappu_LevelData_WaveData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_WaveData<'a> {
    pub const VT_PREDELAY: flatbuffers::VOffsetT = 4;
    pub const VT_POSTDELAY: flatbuffers::VOffsetT = 6;
    pub const VT_MAXTIMEWAITINGFORNEXTWAVE: flatbuffers::VOffsetT = 8;
    pub const VT_FRAGMENTS: flatbuffers::VOffsetT = 10;
    pub const VT_ADVANCEDWAVETAG: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_WaveData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_WaveDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_WaveData<'bldr>> {
        let mut builder = clz_Torappu_LevelData_WaveDataBuilder::new(_fbb);
        if let Some(x) = args.advancedWaveTag {
            builder.add_advancedWaveTag(x);
        }
        if let Some(x) = args.fragments {
            builder.add_fragments(x);
        }
        builder.add_maxTimeWaitingForNextWave(args.maxTimeWaitingForNextWave);
        builder.add_postDelay(args.postDelay);
        builder.add_preDelay(args.preDelay);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_WaveDataT {
        let preDelay = self.preDelay();
        let postDelay = self.postDelay();
        let maxTimeWaitingForNextWave = self.maxTimeWaitingForNextWave();
        let fragments = self
            .fragments()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let advancedWaveTag = self.advancedWaveTag().map(|x| x.to_string());
        clz_Torappu_LevelData_WaveDataT {
            preDelay,
            postDelay,
            maxTimeWaitingForNextWave,
            fragments,
            advancedWaveTag,
        }
    }

    #[inline]
    pub fn preDelay(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_LevelData_WaveData::VT_PREDELAY, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn postDelay(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_LevelData_WaveData::VT_POSTDELAY, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn maxTimeWaitingForNextWave(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_LevelData_WaveData::VT_MAXTIMEWAITINGFORNEXTWAVE,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn fragments(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_WaveData_FragmentData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_WaveData_FragmentData>,
                >,
            >>(clz_Torappu_LevelData_WaveData::VT_FRAGMENTS, None)
        }
    }
    #[inline]
    pub fn advancedWaveTag(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_WaveData::VT_ADVANCEDWAVETAG,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_WaveData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("preDelay", Self::VT_PREDELAY, false)?
            .visit_field::<f32>("postDelay", Self::VT_POSTDELAY, false)?
            .visit_field::<f32>(
                "maxTimeWaitingForNextWave",
                Self::VT_MAXTIMEWAITINGFORNEXTWAVE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_WaveData_FragmentData>,
                >,
            >>("fragments", Self::VT_FRAGMENTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "advancedWaveTag",
                Self::VT_ADVANCEDWAVETAG,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_WaveDataArgs<'a> {
    pub preDelay: f32,
    pub postDelay: f32,
    pub maxTimeWaitingForNextWave: f32,
    pub fragments: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_WaveData_FragmentData<'a>>,
            >,
        >,
    >,
    pub advancedWaveTag: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_LevelData_WaveDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_WaveDataArgs {
            preDelay: 0.0,
            postDelay: 0.0,
            maxTimeWaitingForNextWave: 0.0,
            fragments: None,
            advancedWaveTag: None,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_WaveData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LevelData_WaveData", 5)?;
        s.serialize_field("preDelay", &self.preDelay())?;
        s.serialize_field("postDelay", &self.postDelay())?;
        s.serialize_field(
            "maxTimeWaitingForNextWave",
            &self.maxTimeWaitingForNextWave(),
        )?;
        if let Some(f) = self.fragments() {
            s.serialize_field("fragments", &f)?;
        } else {
            s.skip_field("fragments")?;
        }
        if let Some(f) = self.advancedWaveTag() {
            s.serialize_field("advancedWaveTag", &f)?;
        } else {
            s.skip_field("advancedWaveTag")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LevelData_WaveDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_LevelData_WaveDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_preDelay(&mut self, preDelay: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_LevelData_WaveData::VT_PREDELAY, preDelay, 0.0);
    }
    #[inline]
    pub fn add_postDelay(&mut self, postDelay: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_LevelData_WaveData::VT_POSTDELAY, postDelay, 0.0);
    }
    #[inline]
    pub fn add_maxTimeWaitingForNextWave(&mut self, maxTimeWaitingForNextWave: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_WaveData::VT_MAXTIMEWAITINGFORNEXTWAVE,
            maxTimeWaitingForNextWave,
            0.0,
        );
    }
    #[inline]
    pub fn add_fragments(
        &mut self,
        fragments: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_WaveData_FragmentData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_WaveData::VT_FRAGMENTS,
            fragments,
        );
    }
    #[inline]
    pub fn add_advancedWaveTag(&mut self, advancedWaveTag: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_WaveData::VT_ADVANCEDWAVETAG,
            advancedWaveTag,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_WaveDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_WaveDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_WaveData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_WaveData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_WaveData");
        ds.field("preDelay", &self.preDelay());
        ds.field("postDelay", &self.postDelay());
        ds.field(
            "maxTimeWaitingForNextWave",
            &self.maxTimeWaitingForNextWave(),
        );
        ds.field("fragments", &self.fragments());
        ds.field("advancedWaveTag", &self.advancedWaveTag());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_WaveDataT {
    pub preDelay: f32,
    pub postDelay: f32,
    pub maxTimeWaitingForNextWave: f32,
    pub fragments: Option<Vec<clz_Torappu_LevelData_WaveData_FragmentDataT>>,
    pub advancedWaveTag: Option<String>,
}
impl Default for clz_Torappu_LevelData_WaveDataT {
    fn default() -> Self {
        Self {
            preDelay: 0.0,
            postDelay: 0.0,
            maxTimeWaitingForNextWave: 0.0,
            fragments: None,
            advancedWaveTag: None,
        }
    }
}
impl clz_Torappu_LevelData_WaveDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_WaveData<'b>> {
        let preDelay = self.preDelay;
        let postDelay = self.postDelay;
        let maxTimeWaitingForNextWave = self.maxTimeWaitingForNextWave;
        let fragments = self.fragments.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let advancedWaveTag = self.advancedWaveTag.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_LevelData_WaveData::create(
            _fbb,
            &clz_Torappu_LevelData_WaveDataArgs {
                preDelay,
                postDelay,
                maxTimeWaitingForNextWave,
                fragments,
                advancedWaveTag,
            },
        )
    }
}
pub enum clz_Torappu_LevelData_BranchData_PhaseDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_BranchData_PhaseData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_BranchData_PhaseData<'a> {
    type Inner = clz_Torappu_LevelData_BranchData_PhaseData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_BranchData_PhaseData<'a> {
    pub const VT_PREDELAY: flatbuffers::VOffsetT = 4;
    pub const VT_ACTIONS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_BranchData_PhaseData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_BranchData_PhaseDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_BranchData_PhaseData<'bldr>> {
        let mut builder = clz_Torappu_LevelData_BranchData_PhaseDataBuilder::new(_fbb);
        if let Some(x) = args.actions {
            builder.add_actions(x);
        }
        builder.add_preDelay(args.preDelay);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_BranchData_PhaseDataT {
        let preDelay = self.preDelay();
        let actions = self
            .actions()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_LevelData_BranchData_PhaseDataT { preDelay, actions }
    }

    #[inline]
    pub fn preDelay(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_LevelData_BranchData_PhaseData::VT_PREDELAY,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn actions(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_LevelData_WaveData_FragmentData_ActionData,
                    >,
                >,
            >>(clz_Torappu_LevelData_BranchData_PhaseData::VT_ACTIONS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_BranchData_PhaseData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("preDelay", Self::VT_PREDELAY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_LevelData_WaveData_FragmentData_ActionData,
                    >,
                >,
            >>("actions", Self::VT_ACTIONS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_BranchData_PhaseDataArgs<'a> {
    pub preDelay: f32,
    pub actions: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_LevelData_BranchData_PhaseDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_BranchData_PhaseDataArgs {
            preDelay: 0.0,
            actions: None,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_BranchData_PhaseData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LevelData_BranchData_PhaseData", 2)?;
        s.serialize_field("preDelay", &self.preDelay())?;
        if let Some(f) = self.actions() {
            s.serialize_field("actions", &f)?;
        } else {
            s.skip_field("actions")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LevelData_BranchData_PhaseDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LevelData_BranchData_PhaseDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_preDelay(&mut self, preDelay: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_LevelData_BranchData_PhaseData::VT_PREDELAY,
            preDelay,
            0.0,
        );
    }
    #[inline]
    pub fn add_actions(
        &mut self,
        actions: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_LevelData_WaveData_FragmentData_ActionData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_BranchData_PhaseData::VT_ACTIONS,
            actions,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_BranchData_PhaseDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_BranchData_PhaseDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_BranchData_PhaseData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_BranchData_PhaseData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_BranchData_PhaseData");
        ds.field("preDelay", &self.preDelay());
        ds.field("actions", &self.actions());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_BranchData_PhaseDataT {
    pub preDelay: f32,
    pub actions: Option<Vec<clz_Torappu_LevelData_WaveData_FragmentData_ActionDataT>>,
}
impl Default for clz_Torappu_LevelData_BranchData_PhaseDataT {
    fn default() -> Self {
        Self {
            preDelay: 0.0,
            actions: None,
        }
    }
}
impl clz_Torappu_LevelData_BranchData_PhaseDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_BranchData_PhaseData<'b>> {
        let preDelay = self.preDelay;
        let actions = self.actions.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_LevelData_BranchData_PhaseData::create(
            _fbb,
            &clz_Torappu_LevelData_BranchData_PhaseDataArgs { preDelay, actions },
        )
    }
}
pub enum clz_Torappu_LevelData_BranchDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_BranchData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_BranchData<'a> {
    type Inner = clz_Torappu_LevelData_BranchData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_BranchData<'a> {
    pub const VT_PHASES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_BranchData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_BranchDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_BranchData<'bldr>> {
        let mut builder = clz_Torappu_LevelData_BranchDataBuilder::new(_fbb);
        if let Some(x) = args.phases {
            builder.add_phases(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_BranchDataT {
        let phases = self
            .phases()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_LevelData_BranchDataT { phases }
    }

    #[inline]
    pub fn phases(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_BranchData_PhaseData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_BranchData_PhaseData>,
                >,
            >>(clz_Torappu_LevelData_BranchData::VT_PHASES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_BranchData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_BranchData_PhaseData>,
                >,
            >>("phases", Self::VT_PHASES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_BranchDataArgs<'a> {
    pub phases: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_BranchData_PhaseData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_LevelData_BranchDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_BranchDataArgs { phases: None }
    }
}

impl Serialize for clz_Torappu_LevelData_BranchData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LevelData_BranchData", 1)?;
        if let Some(f) = self.phases() {
            s.serialize_field("phases", &f)?;
        } else {
            s.skip_field("phases")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LevelData_BranchDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LevelData_BranchDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_phases(
        &mut self,
        phases: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_BranchData_PhaseData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_BranchData::VT_PHASES,
            phases,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_BranchDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_BranchDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_BranchData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_BranchData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_BranchData");
        ds.field("phases", &self.phases());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_BranchDataT {
    pub phases: Option<Vec<clz_Torappu_LevelData_BranchData_PhaseDataT>>,
}
impl Default for clz_Torappu_LevelData_BranchDataT {
    fn default() -> Self {
        Self { phases: None }
    }
}
impl clz_Torappu_LevelData_BranchDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_BranchData<'b>> {
        let phases = self.phases.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_LevelData_BranchData::create(
            _fbb,
            &clz_Torappu_LevelData_BranchDataArgs { phases },
        )
    }
}
pub enum dict__string__clz_Torappu_LevelData_BranchDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_LevelData_BranchData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_LevelData_BranchData<'a> {
    type Inner = dict__string__clz_Torappu_LevelData_BranchData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_LevelData_BranchData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_LevelData_BranchData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_LevelData_BranchDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_LevelData_BranchData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_LevelData_BranchDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_LevelData_BranchDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_LevelData_BranchDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_LevelData_BranchData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_LevelData_BranchData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_LevelData_BranchData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_BranchData>>(
                    dict__string__clz_Torappu_LevelData_BranchData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_LevelData_BranchData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_BranchData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_LevelData_BranchDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_LevelData_BranchData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_LevelData_BranchDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_LevelData_BranchDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_LevelData_BranchData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_LevelData_BranchData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_LevelData_BranchDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_LevelData_BranchDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_LevelData_BranchData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_LevelData_BranchData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_LevelData_BranchData>>(
                dict__string__clz_Torappu_LevelData_BranchData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_LevelData_BranchDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_LevelData_BranchDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_LevelData_BranchData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_LevelData_BranchData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_LevelData_BranchData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_LevelData_BranchData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_LevelData_BranchDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_LevelData_BranchDataT>>,
}
impl Default for dict__string__clz_Torappu_LevelData_BranchDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_LevelData_BranchDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_LevelData_BranchData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_LevelData_BranchData::create(
            _fbb,
            &dict__string__clz_Torappu_LevelData_BranchDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_CharacterData_UniqueEquipPairOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_UniqueEquipPair<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_UniqueEquipPair<'a> {
    type Inner = clz_Torappu_CharacterData_UniqueEquipPair<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_UniqueEquipPair<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_UniqueEquipPair { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_UniqueEquipPairArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_UniqueEquipPair<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_UniqueEquipPairBuilder::new(_fbb);
        builder.add_level(args.level);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_UniqueEquipPairT {
        let key = self.key().map(|x| x.to_string());
        let level = self.level();
        clz_Torappu_CharacterData_UniqueEquipPairT { key, level }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_UniqueEquipPair::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CharacterData_UniqueEquipPair::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_UniqueEquipPair<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_UniqueEquipPairArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub level: i32,
}
impl<'a> Default for clz_Torappu_CharacterData_UniqueEquipPairArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_UniqueEquipPairArgs {
            key: None,
            level: 0,
        }
    }
}

impl Serialize for clz_Torappu_CharacterData_UniqueEquipPair<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterData_UniqueEquipPair", 2)?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        s.serialize_field("level", &self.level())?;
        s.end()
    }
}

pub struct clz_Torappu_CharacterData_UniqueEquipPairBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_UniqueEquipPairBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_UniqueEquipPair::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CharacterData_UniqueEquipPair::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_UniqueEquipPairBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_UniqueEquipPairBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_UniqueEquipPair<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_UniqueEquipPair<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_UniqueEquipPair");
        ds.field("key", &self.key());
        ds.field("level", &self.level());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_UniqueEquipPairT {
    pub key: Option<String>,
    pub level: i32,
}
impl Default for clz_Torappu_CharacterData_UniqueEquipPairT {
    fn default() -> Self {
        Self {
            key: None,
            level: 0,
        }
    }
}
impl clz_Torappu_CharacterData_UniqueEquipPairT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_UniqueEquipPair<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let level = self.level;
        clz_Torappu_CharacterData_UniqueEquipPair::create(
            _fbb,
            &clz_Torappu_CharacterData_UniqueEquipPairArgs { key, level },
        )
    }
}
pub enum clz_Torappu_CharacterData_MasterInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_MasterInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_MasterInfo<'a> {
    type Inner = clz_Torappu_CharacterData_MasterInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterData_MasterInfo<'a> {
    pub const VT_MASTERID: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_MasterInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_MasterInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_MasterInfo<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_MasterInfoBuilder::new(_fbb);
        builder.add_level(args.level);
        if let Some(x) = args.masterId {
            builder.add_masterId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterData_MasterInfoT {
        let masterId = self.masterId().map(|x| x.to_string());
        let level = self.level();
        clz_Torappu_CharacterData_MasterInfoT { masterId, level }
    }

    #[inline]
    pub fn masterId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterData_MasterInfo::VT_MASTERID,
                None,
            )
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CharacterData_MasterInfo::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_MasterInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "masterId",
                Self::VT_MASTERID,
                false,
            )?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_MasterInfoArgs<'a> {
    pub masterId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub level: i32,
}
impl<'a> Default for clz_Torappu_CharacterData_MasterInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_MasterInfoArgs {
            masterId: None,
            level: 0,
        }
    }
}

impl Serialize for clz_Torappu_CharacterData_MasterInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterData_MasterInfo", 2)?;
        if let Some(f) = self.masterId() {
            s.serialize_field("masterId", &f)?;
        } else {
            s.skip_field("masterId")?;
        }
        s.serialize_field("level", &self.level())?;
        s.end()
    }
}

pub struct clz_Torappu_CharacterData_MasterInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_MasterInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_masterId(&mut self, masterId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterData_MasterInfo::VT_MASTERID,
            masterId,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_CharacterData_MasterInfo::VT_LEVEL, level, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_MasterInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_MasterInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_MasterInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_MasterInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_MasterInfo");
        ds.field("masterId", &self.masterId());
        ds.field("level", &self.level());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterData_MasterInfoT {
    pub masterId: Option<String>,
    pub level: i32,
}
impl Default for clz_Torappu_CharacterData_MasterInfoT {
    fn default() -> Self {
        Self {
            masterId: None,
            level: 0,
        }
    }
}
impl clz_Torappu_CharacterData_MasterInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_MasterInfo<'b>> {
        let masterId = self.masterId.as_ref().map(|x| _fbb.create_string(x));
        let level = self.level;
        clz_Torappu_CharacterData_MasterInfo::create(
            _fbb,
            &clz_Torappu_CharacterData_MasterInfoArgs { masterId, level },
        )
    }
}
pub enum clz_Torappu_CharacterInst_MetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterInst_Metadata<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterInst_Metadata<'a> {
    type Inner = clz_Torappu_CharacterInst_Metadata<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_CharacterInst_Metadata<'a> {
    pub const VT_CHARACTERKEY: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;
    pub const VT_PHASE: flatbuffers::VOffsetT = 8;
    pub const VT_FAVORPOINT: flatbuffers::VOffsetT = 10;
    pub const VT_POTENTIALRANK: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterInst_Metadata { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterInst_MetadataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterInst_Metadata<'bldr>> {
        let mut builder = clz_Torappu_CharacterInst_MetadataBuilder::new(_fbb);
        builder.add_potentialRank(args.potentialRank);
        builder.add_favorPoint(args.favorPoint);
        builder.add_phase(args.phase);
        builder.add_level(args.level);
        if let Some(x) = args.characterKey {
            builder.add_characterKey(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_CharacterInst_MetadataT {
        let characterKey = self.characterKey().map(|x| x.to_string());
        let level = self.level();
        let phase = self.phase();
        let favorPoint = self.favorPoint();
        let potentialRank = self.potentialRank();
        clz_Torappu_CharacterInst_MetadataT {
            characterKey,
            level,
            phase,
            favorPoint,
            potentialRank,
        }
    }

    #[inline]
    pub fn characterKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_CharacterInst_Metadata::VT_CHARACTERKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CharacterInst_Metadata::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn phase(&self) -> enum__Torappu_EvolvePhase {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EvolvePhase>(
                    clz_Torappu_CharacterInst_Metadata::VT_PHASE,
                    Some(enum__Torappu_EvolvePhase::PHASE_0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn favorPoint(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CharacterInst_Metadata::VT_FAVORPOINT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn potentialRank(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_CharacterInst_Metadata::VT_POTENTIALRANK,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterInst_Metadata<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "characterKey",
                Self::VT_CHARACTERKEY,
                false,
            )?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .visit_field::<enum__Torappu_EvolvePhase>("phase", Self::VT_PHASE, false)?
            .visit_field::<i32>("favorPoint", Self::VT_FAVORPOINT, false)?
            .visit_field::<i32>("potentialRank", Self::VT_POTENTIALRANK, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterInst_MetadataArgs<'a> {
    pub characterKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub level: i32,
    pub phase: enum__Torappu_EvolvePhase,
    pub favorPoint: i32,
    pub potentialRank: i32,
}
impl<'a> Default for clz_Torappu_CharacterInst_MetadataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterInst_MetadataArgs {
            characterKey: None,
            level: 0,
            phase: enum__Torappu_EvolvePhase::PHASE_0,
            favorPoint: 0,
            potentialRank: 0,
        }
    }
}

impl Serialize for clz_Torappu_CharacterInst_Metadata<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_CharacterInst_Metadata", 5)?;
        if let Some(f) = self.characterKey() {
            s.serialize_field("characterKey", &f)?;
        } else {
            s.skip_field("characterKey")?;
        }
        s.serialize_field("level", &self.level())?;
        s.serialize_field("phase", &self.phase())?;
        s.serialize_field("favorPoint", &self.favorPoint())?;
        s.serialize_field("potentialRank", &self.potentialRank())?;
        s.end()
    }
}

pub struct clz_Torappu_CharacterInst_MetadataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterInst_MetadataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_characterKey(&mut self, characterKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_CharacterInst_Metadata::VT_CHARACTERKEY,
            characterKey,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_CharacterInst_Metadata::VT_LEVEL, level, 0);
    }
    #[inline]
    pub fn add_phase(&mut self, phase: enum__Torappu_EvolvePhase) {
        self.fbb_.push_slot::<enum__Torappu_EvolvePhase>(
            clz_Torappu_CharacterInst_Metadata::VT_PHASE,
            phase,
            enum__Torappu_EvolvePhase::PHASE_0,
        );
    }
    #[inline]
    pub fn add_favorPoint(&mut self, favorPoint: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CharacterInst_Metadata::VT_FAVORPOINT,
            favorPoint,
            0,
        );
    }
    #[inline]
    pub fn add_potentialRank(&mut self, potentialRank: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CharacterInst_Metadata::VT_POTENTIALRANK,
            potentialRank,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterInst_MetadataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterInst_MetadataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterInst_Metadata<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterInst_Metadata<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterInst_Metadata");
        ds.field("characterKey", &self.characterKey());
        ds.field("level", &self.level());
        ds.field("phase", &self.phase());
        ds.field("favorPoint", &self.favorPoint());
        ds.field("potentialRank", &self.potentialRank());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_CharacterInst_MetadataT {
    pub characterKey: Option<String>,
    pub level: i32,
    pub phase: enum__Torappu_EvolvePhase,
    pub favorPoint: i32,
    pub potentialRank: i32,
}
impl Default for clz_Torappu_CharacterInst_MetadataT {
    fn default() -> Self {
        Self {
            characterKey: None,
            level: 0,
            phase: enum__Torappu_EvolvePhase::PHASE_0,
            favorPoint: 0,
            potentialRank: 0,
        }
    }
}
impl clz_Torappu_CharacterInst_MetadataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterInst_Metadata<'b>> {
        let characterKey = self.characterKey.as_ref().map(|x| _fbb.create_string(x));
        let level = self.level;
        let phase = self.phase;
        let favorPoint = self.favorPoint;
        let potentialRank = self.potentialRank;
        clz_Torappu_CharacterInst_Metadata::create(
            _fbb,
            &clz_Torappu_CharacterInst_MetadataArgs {
                characterKey,
                level,
                phase,
                favorPoint,
                potentialRank,
            },
        )
    }
}
pub enum clz_Torappu_LevelData_PredefinedData_PredefinedCharacterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'a> {
    type Inner = clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'a> {
    pub const VT_POSITION: flatbuffers::VOffsetT = 4;
    pub const VT_DIRECTION: flatbuffers::VOffsetT = 6;
    pub const VT_HIDDEN: flatbuffers::VOffsetT = 8;
    pub const VT_ALIAS: flatbuffers::VOffsetT = 10;
    pub const VT_UNIEQUIPIDS: flatbuffers::VOffsetT = 12;
    pub const VT_SHOWSPILLUST: flatbuffers::VOffsetT = 14;
    pub const VT_MASTERINFOS: flatbuffers::VOffsetT = 16;
    pub const VT_INST: flatbuffers::VOffsetT = 18;
    pub const VT_SKILLINDEX: flatbuffers::VOffsetT = 20;
    pub const VT_MAINSKILLLVL: flatbuffers::VOffsetT = 22;
    pub const VT_SKINID: flatbuffers::VOffsetT = 24;
    pub const VT_TMPLID: flatbuffers::VOffsetT = 26;
    pub const VT_OVERRIDESKILLBLACKBOARD: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_PredefinedData_PredefinedCharacter { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_PredefinedData_PredefinedCharacterArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'bldr>>
    {
        let mut builder =
            clz_Torappu_LevelData_PredefinedData_PredefinedCharacterBuilder::new(_fbb);
        if let Some(x) = args.overrideSkillBlackboard {
            builder.add_overrideSkillBlackboard(x);
        }
        if let Some(x) = args.tmplId {
            builder.add_tmplId(x);
        }
        if let Some(x) = args.skinId {
            builder.add_skinId(x);
        }
        builder.add_mainSkillLvl(args.mainSkillLvl);
        builder.add_skillIndex(args.skillIndex);
        if let Some(x) = args.inst {
            builder.add_inst(x);
        }
        if let Some(x) = args.masterInfos {
            builder.add_masterInfos(x);
        }
        if let Some(x) = args.uniEquipIds {
            builder.add_uniEquipIds(x);
        }
        if let Some(x) = args.alias {
            builder.add_alias(x);
        }
        builder.add_direction(args.direction);
        if let Some(x) = args.position {
            builder.add_position(x);
        }
        builder.add_showSpIllust(args.showSpIllust);
        builder.add_hidden(args.hidden);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_PredefinedData_PredefinedCharacterT {
        let position = self.position().map(|x| Box::new(x.unpack()));
        let direction = self.direction();
        let hidden = self.hidden();
        let alias = self.alias().map(|x| x.to_string());
        let uniEquipIds = self
            .uniEquipIds()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let showSpIllust = self.showSpIllust();
        let masterInfos = self
            .masterInfos()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let inst = self.inst().map(|x| Box::new(x.unpack()));
        let skillIndex = self.skillIndex();
        let mainSkillLvl = self.mainSkillLvl();
        let skinId = self.skinId().map(|x| x.to_string());
        let tmplId = self.tmplId().map(|x| x.to_string());
        let overrideSkillBlackboard = self
            .overrideSkillBlackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_LevelData_PredefinedData_PredefinedCharacterT {
            position,
            direction,
            hidden,
            alias,
            uniEquipIds,
            showSpIllust,
            masterInfos,
            inst,
            skillIndex,
            mainSkillLvl,
            skinId,
            tmplId,
            overrideSkillBlackboard,
        }
    }

    #[inline]
    pub fn position(&self) -> Option<clz_Torappu_GridPosition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_POSITION,
                    None,
                )
        }
    }
    #[inline]
    pub fn direction(&self) -> enum__Torappu_SharedConsts_Direction {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_SharedConsts_Direction>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_DIRECTION,
                    Some(enum__Torappu_SharedConsts_Direction::UP),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn hidden(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_HIDDEN,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn alias(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_ALIAS,
                None,
            )
        }
    }
    #[inline]
    pub fn uniEquipIds(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UniqueEquipPair<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UniqueEquipPair>,
                >,
            >>(
                clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_UNIEQUIPIDS,
                None,
            )
        }
    }
    #[inline]
    pub fn showSpIllust(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_SHOWSPILLUST,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn masterInfos(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterInfo>,
                >,
            >>(
                clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_MASTERINFOS,
                None,
            )
        }
    }
    #[inline]
    pub fn inst(&self) -> Option<clz_Torappu_CharacterInst_Metadata<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterInst_Metadata>>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_INST,
                    None,
                )
        }
    }
    #[inline]
    pub fn skillIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_SKILLINDEX,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn mainSkillLvl(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_MAINSKILLLVL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn skinId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_SKINID,
                None,
            )
        }
    }
    #[inline]
    pub fn tmplId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_TMPLID,
                None,
            )
        }
    }
    #[inline]
    pub fn overrideSkillBlackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>>>>(clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_OVERRIDESKILLBLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                "position",
                Self::VT_POSITION,
                false,
            )?
            .visit_field::<enum__Torappu_SharedConsts_Direction>(
                "direction",
                Self::VT_DIRECTION,
                false,
            )?
            .visit_field::<bool>("hidden", Self::VT_HIDDEN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alias", Self::VT_ALIAS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UniqueEquipPair>,
                >,
            >>("uniEquipIds", Self::VT_UNIEQUIPIDS, false)?
            .visit_field::<bool>("showSpIllust", Self::VT_SHOWSPILLUST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterInfo>,
                >,
            >>("masterInfos", Self::VT_MASTERINFOS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterInst_Metadata>>(
                "inst",
                Self::VT_INST,
                false,
            )?
            .visit_field::<i32>("skillIndex", Self::VT_SKILLINDEX, false)?
            .visit_field::<i32>("mainSkillLvl", Self::VT_MAINSKILLLVL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("skinId", Self::VT_SKINID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tmplId", Self::VT_TMPLID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(
                "overrideSkillBlackboard",
                Self::VT_OVERRIDESKILLBLACKBOARD,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_PredefinedData_PredefinedCharacterArgs<'a> {
    pub position: Option<flatbuffers::WIPOffset<clz_Torappu_GridPosition<'a>>>,
    pub direction: enum__Torappu_SharedConsts_Direction,
    pub hidden: bool,
    pub alias: Option<flatbuffers::WIPOffset<&'a str>>,
    pub uniEquipIds: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UniqueEquipPair<'a>>,
            >,
        >,
    >,
    pub showSpIllust: bool,
    pub masterInfos: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterInfo<'a>>,
            >,
        >,
    >,
    pub inst: Option<flatbuffers::WIPOffset<clz_Torappu_CharacterInst_Metadata<'a>>>,
    pub skillIndex: i32,
    pub mainSkillLvl: i32,
    pub skinId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tmplId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub overrideSkillBlackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_LevelData_PredefinedData_PredefinedCharacterArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_PredefinedData_PredefinedCharacterArgs {
            position: None,
            direction: enum__Torappu_SharedConsts_Direction::UP,
            hidden: false,
            alias: None,
            uniEquipIds: None,
            showSpIllust: false,
            masterInfos: None,
            inst: None,
            skillIndex: 0,
            mainSkillLvl: 0,
            skinId: None,
            tmplId: None,
            overrideSkillBlackboard: None,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "clz_Torappu_LevelData_PredefinedData_PredefinedCharacter",
            13,
        )?;
        if let Some(f) = self.position() {
            s.serialize_field("position", &f)?;
        } else {
            s.skip_field("position")?;
        }
        s.serialize_field("direction", &self.direction())?;
        s.serialize_field("hidden", &self.hidden())?;
        if let Some(f) = self.alias() {
            s.serialize_field("alias", &f)?;
        } else {
            s.skip_field("alias")?;
        }
        if let Some(f) = self.uniEquipIds() {
            s.serialize_field("uniEquipIds", &f)?;
        } else {
            s.skip_field("uniEquipIds")?;
        }
        s.serialize_field("showSpIllust", &self.showSpIllust())?;
        if let Some(f) = self.masterInfos() {
            s.serialize_field("masterInfos", &f)?;
        } else {
            s.skip_field("masterInfos")?;
        }
        if let Some(f) = self.inst() {
            s.serialize_field("inst", &f)?;
        } else {
            s.skip_field("inst")?;
        }
        s.serialize_field("skillIndex", &self.skillIndex())?;
        s.serialize_field("mainSkillLvl", &self.mainSkillLvl())?;
        if let Some(f) = self.skinId() {
            s.serialize_field("skinId", &f)?;
        } else {
            s.skip_field("skinId")?;
        }
        if let Some(f) = self.tmplId() {
            s.serialize_field("tmplId", &f)?;
        } else {
            s.skip_field("tmplId")?;
        }
        if let Some(f) = self.overrideSkillBlackboard() {
            s.serialize_field("overrideSkillBlackboard", &f)?;
        } else {
            s.skip_field("overrideSkillBlackboard")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LevelData_PredefinedData_PredefinedCharacterBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LevelData_PredefinedData_PredefinedCharacterBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_position(&mut self, position: flatbuffers::WIPOffset<clz_Torappu_GridPosition<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_GridPosition>>(
                clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_POSITION,
                position,
            );
    }
    #[inline]
    pub fn add_direction(&mut self, direction: enum__Torappu_SharedConsts_Direction) {
        self.fbb_.push_slot::<enum__Torappu_SharedConsts_Direction>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_DIRECTION,
            direction,
            enum__Torappu_SharedConsts_Direction::UP,
        );
    }
    #[inline]
    pub fn add_hidden(&mut self, hidden: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_HIDDEN,
            hidden,
            false,
        );
    }
    #[inline]
    pub fn add_alias(&mut self, alias: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_ALIAS,
            alias,
        );
    }
    #[inline]
    pub fn add_uniEquipIds(
        &mut self,
        uniEquipIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UniqueEquipPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_UNIEQUIPIDS,
            uniEquipIds,
        );
    }
    #[inline]
    pub fn add_showSpIllust(&mut self, showSpIllust: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_SHOWSPILLUST,
            showSpIllust,
            false,
        );
    }
    #[inline]
    pub fn add_masterInfos(
        &mut self,
        masterInfos: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_MASTERINFOS,
            masterInfos,
        );
    }
    #[inline]
    pub fn add_inst(
        &mut self,
        inst: flatbuffers::WIPOffset<clz_Torappu_CharacterInst_Metadata<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterInst_Metadata>>(
                clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_INST,
                inst,
            );
    }
    #[inline]
    pub fn add_skillIndex(&mut self, skillIndex: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_SKILLINDEX,
            skillIndex,
            0,
        );
    }
    #[inline]
    pub fn add_mainSkillLvl(&mut self, mainSkillLvl: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_MAINSKILLLVL,
            mainSkillLvl,
            0,
        );
    }
    #[inline]
    pub fn add_skinId(&mut self, skinId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_SKINID,
            skinId,
        );
    }
    #[inline]
    pub fn add_tmplId(&mut self, tmplId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_TMPLID,
            tmplId,
        );
    }
    #[inline]
    pub fn add_overrideSkillBlackboard(
        &mut self,
        overrideSkillBlackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::VT_OVERRIDESKILLBLACKBOARD,
            overrideSkillBlackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_PredefinedData_PredefinedCharacterBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_PredefinedData_PredefinedCharacterBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_PredefinedData_PredefinedCharacter");
        ds.field("position", &self.position());
        ds.field("direction", &self.direction());
        ds.field("hidden", &self.hidden());
        ds.field("alias", &self.alias());
        ds.field("uniEquipIds", &self.uniEquipIds());
        ds.field("showSpIllust", &self.showSpIllust());
        ds.field("masterInfos", &self.masterInfos());
        ds.field("inst", &self.inst());
        ds.field("skillIndex", &self.skillIndex());
        ds.field("mainSkillLvl", &self.mainSkillLvl());
        ds.field("skinId", &self.skinId());
        ds.field("tmplId", &self.tmplId());
        ds.field("overrideSkillBlackboard", &self.overrideSkillBlackboard());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_PredefinedData_PredefinedCharacterT {
    pub position: Option<Box<clz_Torappu_GridPositionT>>,
    pub direction: enum__Torappu_SharedConsts_Direction,
    pub hidden: bool,
    pub alias: Option<String>,
    pub uniEquipIds: Option<Vec<clz_Torappu_CharacterData_UniqueEquipPairT>>,
    pub showSpIllust: bool,
    pub masterInfos: Option<Vec<clz_Torappu_CharacterData_MasterInfoT>>,
    pub inst: Option<Box<clz_Torappu_CharacterInst_MetadataT>>,
    pub skillIndex: i32,
    pub mainSkillLvl: i32,
    pub skinId: Option<String>,
    pub tmplId: Option<String>,
    pub overrideSkillBlackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for clz_Torappu_LevelData_PredefinedData_PredefinedCharacterT {
    fn default() -> Self {
        Self {
            position: None,
            direction: enum__Torappu_SharedConsts_Direction::UP,
            hidden: false,
            alias: None,
            uniEquipIds: None,
            showSpIllust: false,
            masterInfos: None,
            inst: None,
            skillIndex: 0,
            mainSkillLvl: 0,
            skinId: None,
            tmplId: None,
            overrideSkillBlackboard: None,
        }
    }
}
impl clz_Torappu_LevelData_PredefinedData_PredefinedCharacterT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'b>> {
        let position = self.position.as_ref().map(|x| x.pack(_fbb));
        let direction = self.direction;
        let hidden = self.hidden;
        let alias = self.alias.as_ref().map(|x| _fbb.create_string(x));
        let uniEquipIds = self.uniEquipIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let showSpIllust = self.showSpIllust;
        let masterInfos = self.masterInfos.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let inst = self.inst.as_ref().map(|x| x.pack(_fbb));
        let skillIndex = self.skillIndex;
        let mainSkillLvl = self.mainSkillLvl;
        let skinId = self.skinId.as_ref().map(|x| _fbb.create_string(x));
        let tmplId = self.tmplId.as_ref().map(|x| _fbb.create_string(x));
        let overrideSkillBlackboard = self.overrideSkillBlackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_LevelData_PredefinedData_PredefinedCharacter::create(
            _fbb,
            &clz_Torappu_LevelData_PredefinedData_PredefinedCharacterArgs {
                position,
                direction,
                hidden,
                alias,
                uniEquipIds,
                showSpIllust,
                masterInfos,
                inst,
                skillIndex,
                mainSkillLvl,
                skinId,
                tmplId,
                overrideSkillBlackboard,
            },
        )
    }
}
pub enum clz_Torappu_LevelData_PredefinedData_PredefinedCardOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_PredefinedData_PredefinedCard<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_PredefinedData_PredefinedCard<'a> {
    type Inner = clz_Torappu_LevelData_PredefinedData_PredefinedCard<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_PredefinedData_PredefinedCard<'a> {
    pub const VT_HIDDEN: flatbuffers::VOffsetT = 4;
    pub const VT_ALIAS: flatbuffers::VOffsetT = 6;
    pub const VT_UNIEQUIPIDS: flatbuffers::VOffsetT = 8;
    pub const VT_SHOWSPILLUST: flatbuffers::VOffsetT = 10;
    pub const VT_MASTERINFOS: flatbuffers::VOffsetT = 12;
    pub const VT_INST: flatbuffers::VOffsetT = 14;
    pub const VT_SKILLINDEX: flatbuffers::VOffsetT = 16;
    pub const VT_MAINSKILLLVL: flatbuffers::VOffsetT = 18;
    pub const VT_SKINID: flatbuffers::VOffsetT = 20;
    pub const VT_TMPLID: flatbuffers::VOffsetT = 22;
    pub const VT_OVERRIDESKILLBLACKBOARD: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_PredefinedData_PredefinedCard { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_PredefinedData_PredefinedCardArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData_PredefinedCard<'bldr>> {
        let mut builder = clz_Torappu_LevelData_PredefinedData_PredefinedCardBuilder::new(_fbb);
        if let Some(x) = args.overrideSkillBlackboard {
            builder.add_overrideSkillBlackboard(x);
        }
        if let Some(x) = args.tmplId {
            builder.add_tmplId(x);
        }
        if let Some(x) = args.skinId {
            builder.add_skinId(x);
        }
        builder.add_mainSkillLvl(args.mainSkillLvl);
        builder.add_skillIndex(args.skillIndex);
        if let Some(x) = args.inst {
            builder.add_inst(x);
        }
        if let Some(x) = args.masterInfos {
            builder.add_masterInfos(x);
        }
        if let Some(x) = args.uniEquipIds {
            builder.add_uniEquipIds(x);
        }
        if let Some(x) = args.alias {
            builder.add_alias(x);
        }
        builder.add_showSpIllust(args.showSpIllust);
        builder.add_hidden(args.hidden);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_PredefinedData_PredefinedCardT {
        let hidden = self.hidden();
        let alias = self.alias().map(|x| x.to_string());
        let uniEquipIds = self
            .uniEquipIds()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let showSpIllust = self.showSpIllust();
        let masterInfos = self
            .masterInfos()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let inst = self.inst().map(|x| Box::new(x.unpack()));
        let skillIndex = self.skillIndex();
        let mainSkillLvl = self.mainSkillLvl();
        let skinId = self.skinId().map(|x| x.to_string());
        let tmplId = self.tmplId().map(|x| x.to_string());
        let overrideSkillBlackboard = self
            .overrideSkillBlackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_LevelData_PredefinedData_PredefinedCardT {
            hidden,
            alias,
            uniEquipIds,
            showSpIllust,
            masterInfos,
            inst,
            skillIndex,
            mainSkillLvl,
            skinId,
            tmplId,
            overrideSkillBlackboard,
        }
    }

    #[inline]
    pub fn hidden(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_HIDDEN,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn alias(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_ALIAS,
                None,
            )
        }
    }
    #[inline]
    pub fn uniEquipIds(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UniqueEquipPair<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UniqueEquipPair>,
                >,
            >>(
                clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_UNIEQUIPIDS,
                None,
            )
        }
    }
    #[inline]
    pub fn showSpIllust(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_SHOWSPILLUST,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn masterInfos(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterInfo>,
                >,
            >>(
                clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_MASTERINFOS,
                None,
            )
        }
    }
    #[inline]
    pub fn inst(&self) -> Option<clz_Torappu_CharacterInst_Metadata<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterInst_Metadata>>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_INST,
                    None,
                )
        }
    }
    #[inline]
    pub fn skillIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_SKILLINDEX,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn mainSkillLvl(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_MAINSKILLLVL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn skinId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_SKINID,
                None,
            )
        }
    }
    #[inline]
    pub fn tmplId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_TMPLID,
                None,
            )
        }
    }
    #[inline]
    pub fn overrideSkillBlackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(
                clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_OVERRIDESKILLBLACKBOARD,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_PredefinedData_PredefinedCard<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("hidden", Self::VT_HIDDEN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alias", Self::VT_ALIAS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UniqueEquipPair>,
                >,
            >>("uniEquipIds", Self::VT_UNIEQUIPIDS, false)?
            .visit_field::<bool>("showSpIllust", Self::VT_SHOWSPILLUST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterInfo>,
                >,
            >>("masterInfos", Self::VT_MASTERINFOS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterInst_Metadata>>(
                "inst",
                Self::VT_INST,
                false,
            )?
            .visit_field::<i32>("skillIndex", Self::VT_SKILLINDEX, false)?
            .visit_field::<i32>("mainSkillLvl", Self::VT_MAINSKILLLVL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("skinId", Self::VT_SKINID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tmplId", Self::VT_TMPLID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(
                "overrideSkillBlackboard",
                Self::VT_OVERRIDESKILLBLACKBOARD,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_PredefinedData_PredefinedCardArgs<'a> {
    pub hidden: bool,
    pub alias: Option<flatbuffers::WIPOffset<&'a str>>,
    pub uniEquipIds: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UniqueEquipPair<'a>>,
            >,
        >,
    >,
    pub showSpIllust: bool,
    pub masterInfos: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterInfo<'a>>,
            >,
        >,
    >,
    pub inst: Option<flatbuffers::WIPOffset<clz_Torappu_CharacterInst_Metadata<'a>>>,
    pub skillIndex: i32,
    pub mainSkillLvl: i32,
    pub skinId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tmplId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub overrideSkillBlackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_LevelData_PredefinedData_PredefinedCardArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_PredefinedData_PredefinedCardArgs {
            hidden: false,
            alias: None,
            uniEquipIds: None,
            showSpIllust: false,
            masterInfos: None,
            inst: None,
            skillIndex: 0,
            mainSkillLvl: 0,
            skinId: None,
            tmplId: None,
            overrideSkillBlackboard: None,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_PredefinedData_PredefinedCard<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("clz_Torappu_LevelData_PredefinedData_PredefinedCard", 11)?;
        s.serialize_field("hidden", &self.hidden())?;
        if let Some(f) = self.alias() {
            s.serialize_field("alias", &f)?;
        } else {
            s.skip_field("alias")?;
        }
        if let Some(f) = self.uniEquipIds() {
            s.serialize_field("uniEquipIds", &f)?;
        } else {
            s.skip_field("uniEquipIds")?;
        }
        s.serialize_field("showSpIllust", &self.showSpIllust())?;
        if let Some(f) = self.masterInfos() {
            s.serialize_field("masterInfos", &f)?;
        } else {
            s.skip_field("masterInfos")?;
        }
        if let Some(f) = self.inst() {
            s.serialize_field("inst", &f)?;
        } else {
            s.skip_field("inst")?;
        }
        s.serialize_field("skillIndex", &self.skillIndex())?;
        s.serialize_field("mainSkillLvl", &self.mainSkillLvl())?;
        if let Some(f) = self.skinId() {
            s.serialize_field("skinId", &f)?;
        } else {
            s.skip_field("skinId")?;
        }
        if let Some(f) = self.tmplId() {
            s.serialize_field("tmplId", &f)?;
        } else {
            s.skip_field("tmplId")?;
        }
        if let Some(f) = self.overrideSkillBlackboard() {
            s.serialize_field("overrideSkillBlackboard", &f)?;
        } else {
            s.skip_field("overrideSkillBlackboard")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LevelData_PredefinedData_PredefinedCardBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LevelData_PredefinedData_PredefinedCardBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_hidden(&mut self, hidden: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_HIDDEN,
            hidden,
            false,
        );
    }
    #[inline]
    pub fn add_alias(&mut self, alias: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_ALIAS,
            alias,
        );
    }
    #[inline]
    pub fn add_uniEquipIds(
        &mut self,
        uniEquipIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UniqueEquipPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_UNIEQUIPIDS,
            uniEquipIds,
        );
    }
    #[inline]
    pub fn add_showSpIllust(&mut self, showSpIllust: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_SHOWSPILLUST,
            showSpIllust,
            false,
        );
    }
    #[inline]
    pub fn add_masterInfos(
        &mut self,
        masterInfos: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_MASTERINFOS,
            masterInfos,
        );
    }
    #[inline]
    pub fn add_inst(
        &mut self,
        inst: flatbuffers::WIPOffset<clz_Torappu_CharacterInst_Metadata<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterInst_Metadata>>(
                clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_INST,
                inst,
            );
    }
    #[inline]
    pub fn add_skillIndex(&mut self, skillIndex: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_SKILLINDEX,
            skillIndex,
            0,
        );
    }
    #[inline]
    pub fn add_mainSkillLvl(&mut self, mainSkillLvl: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_MAINSKILLLVL,
            mainSkillLvl,
            0,
        );
    }
    #[inline]
    pub fn add_skinId(&mut self, skinId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_SKINID,
            skinId,
        );
    }
    #[inline]
    pub fn add_tmplId(&mut self, tmplId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_TMPLID,
            tmplId,
        );
    }
    #[inline]
    pub fn add_overrideSkillBlackboard(
        &mut self,
        overrideSkillBlackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedCard::VT_OVERRIDESKILLBLACKBOARD,
            overrideSkillBlackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_PredefinedData_PredefinedCardBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_PredefinedData_PredefinedCardBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData_PredefinedCard<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_PredefinedData_PredefinedCard<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_PredefinedData_PredefinedCard");
        ds.field("hidden", &self.hidden());
        ds.field("alias", &self.alias());
        ds.field("uniEquipIds", &self.uniEquipIds());
        ds.field("showSpIllust", &self.showSpIllust());
        ds.field("masterInfos", &self.masterInfos());
        ds.field("inst", &self.inst());
        ds.field("skillIndex", &self.skillIndex());
        ds.field("mainSkillLvl", &self.mainSkillLvl());
        ds.field("skinId", &self.skinId());
        ds.field("tmplId", &self.tmplId());
        ds.field("overrideSkillBlackboard", &self.overrideSkillBlackboard());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_PredefinedData_PredefinedCardT {
    pub hidden: bool,
    pub alias: Option<String>,
    pub uniEquipIds: Option<Vec<clz_Torappu_CharacterData_UniqueEquipPairT>>,
    pub showSpIllust: bool,
    pub masterInfos: Option<Vec<clz_Torappu_CharacterData_MasterInfoT>>,
    pub inst: Option<Box<clz_Torappu_CharacterInst_MetadataT>>,
    pub skillIndex: i32,
    pub mainSkillLvl: i32,
    pub skinId: Option<String>,
    pub tmplId: Option<String>,
    pub overrideSkillBlackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for clz_Torappu_LevelData_PredefinedData_PredefinedCardT {
    fn default() -> Self {
        Self {
            hidden: false,
            alias: None,
            uniEquipIds: None,
            showSpIllust: false,
            masterInfos: None,
            inst: None,
            skillIndex: 0,
            mainSkillLvl: 0,
            skinId: None,
            tmplId: None,
            overrideSkillBlackboard: None,
        }
    }
}
impl clz_Torappu_LevelData_PredefinedData_PredefinedCardT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData_PredefinedCard<'b>> {
        let hidden = self.hidden;
        let alias = self.alias.as_ref().map(|x| _fbb.create_string(x));
        let uniEquipIds = self.uniEquipIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let showSpIllust = self.showSpIllust;
        let masterInfos = self.masterInfos.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let inst = self.inst.as_ref().map(|x| x.pack(_fbb));
        let skillIndex = self.skillIndex;
        let mainSkillLvl = self.mainSkillLvl;
        let skinId = self.skinId.as_ref().map(|x| _fbb.create_string(x));
        let tmplId = self.tmplId.as_ref().map(|x| _fbb.create_string(x));
        let overrideSkillBlackboard = self.overrideSkillBlackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_LevelData_PredefinedData_PredefinedCard::create(
            _fbb,
            &clz_Torappu_LevelData_PredefinedData_PredefinedCardArgs {
                hidden,
                alias,
                uniEquipIds,
                showSpIllust,
                masterInfos,
                inst,
                skillIndex,
                mainSkillLvl,
                skinId,
                tmplId,
                overrideSkillBlackboard,
            },
        )
    }
}
pub enum clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard<'a> {
    type Inner = clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard<'a> {
    pub const VT_INITIALCNT: flatbuffers::VOffsetT = 4;
    pub const VT_HIDDEN: flatbuffers::VOffsetT = 6;
    pub const VT_ALIAS: flatbuffers::VOffsetT = 8;
    pub const VT_UNIEQUIPIDS: flatbuffers::VOffsetT = 10;
    pub const VT_SHOWSPILLUST: flatbuffers::VOffsetT = 12;
    pub const VT_MASTERINFOS: flatbuffers::VOffsetT = 14;
    pub const VT_INST: flatbuffers::VOffsetT = 16;
    pub const VT_SKILLINDEX: flatbuffers::VOffsetT = 18;
    pub const VT_MAINSKILLLVL: flatbuffers::VOffsetT = 20;
    pub const VT_SKINID: flatbuffers::VOffsetT = 22;
    pub const VT_TMPLID: flatbuffers::VOffsetT = 24;
    pub const VT_OVERRIDESKILLBLACKBOARD: flatbuffers::VOffsetT = 26;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard<'bldr>>
    {
        let mut builder =
            clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardBuilder::new(_fbb);
        if let Some(x) = args.overrideSkillBlackboard {
            builder.add_overrideSkillBlackboard(x);
        }
        if let Some(x) = args.tmplId {
            builder.add_tmplId(x);
        }
        if let Some(x) = args.skinId {
            builder.add_skinId(x);
        }
        builder.add_mainSkillLvl(args.mainSkillLvl);
        builder.add_skillIndex(args.skillIndex);
        if let Some(x) = args.inst {
            builder.add_inst(x);
        }
        if let Some(x) = args.masterInfos {
            builder.add_masterInfos(x);
        }
        if let Some(x) = args.uniEquipIds {
            builder.add_uniEquipIds(x);
        }
        if let Some(x) = args.alias {
            builder.add_alias(x);
        }
        builder.add_initialCnt(args.initialCnt);
        builder.add_showSpIllust(args.showSpIllust);
        builder.add_hidden(args.hidden);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardT {
        let initialCnt = self.initialCnt();
        let hidden = self.hidden();
        let alias = self.alias().map(|x| x.to_string());
        let uniEquipIds = self
            .uniEquipIds()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let showSpIllust = self.showSpIllust();
        let masterInfos = self
            .masterInfos()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let inst = self.inst().map(|x| Box::new(x.unpack()));
        let skillIndex = self.skillIndex();
        let mainSkillLvl = self.mainSkillLvl();
        let skinId = self.skinId().map(|x| x.to_string());
        let tmplId = self.tmplId().map(|x| x.to_string());
        let overrideSkillBlackboard = self
            .overrideSkillBlackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardT {
            initialCnt,
            hidden,
            alias,
            uniEquipIds,
            showSpIllust,
            masterInfos,
            inst,
            skillIndex,
            mainSkillLvl,
            skinId,
            tmplId,
            overrideSkillBlackboard,
        }
    }

    #[inline]
    pub fn initialCnt(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_INITIALCNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn hidden(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_HIDDEN,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn alias(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_ALIAS,
                None,
            )
        }
    }
    #[inline]
    pub fn uniEquipIds(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UniqueEquipPair<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UniqueEquipPair>,
                >,
            >>(
                clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_UNIEQUIPIDS,
                None,
            )
        }
    }
    #[inline]
    pub fn showSpIllust(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_SHOWSPILLUST,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn masterInfos(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterInfo>,
                >,
            >>(
                clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_MASTERINFOS,
                None,
            )
        }
    }
    #[inline]
    pub fn inst(&self) -> Option<clz_Torappu_CharacterInst_Metadata<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterInst_Metadata>>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_INST,
                    None,
                )
        }
    }
    #[inline]
    pub fn skillIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_SKILLINDEX,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn mainSkillLvl(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_MAINSKILLLVL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn skinId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_SKINID,
                None,
            )
        }
    }
    #[inline]
    pub fn tmplId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_TMPLID,
                None,
            )
        }
    }
    #[inline]
    pub fn overrideSkillBlackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>>>>(clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_OVERRIDESKILLBLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("initialCnt", Self::VT_INITIALCNT, false)?
            .visit_field::<bool>("hidden", Self::VT_HIDDEN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alias", Self::VT_ALIAS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UniqueEquipPair>,
                >,
            >>("uniEquipIds", Self::VT_UNIEQUIPIDS, false)?
            .visit_field::<bool>("showSpIllust", Self::VT_SHOWSPILLUST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterInfo>,
                >,
            >>("masterInfos", Self::VT_MASTERINFOS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterInst_Metadata>>(
                "inst",
                Self::VT_INST,
                false,
            )?
            .visit_field::<i32>("skillIndex", Self::VT_SKILLINDEX, false)?
            .visit_field::<i32>("mainSkillLvl", Self::VT_MAINSKILLLVL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("skinId", Self::VT_SKINID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tmplId", Self::VT_TMPLID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(
                "overrideSkillBlackboard",
                Self::VT_OVERRIDESKILLBLACKBOARD,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardArgs<'a> {
    pub initialCnt: i32,
    pub hidden: bool,
    pub alias: Option<flatbuffers::WIPOffset<&'a str>>,
    pub uniEquipIds: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UniqueEquipPair<'a>>,
            >,
        >,
    >,
    pub showSpIllust: bool,
    pub masterInfos: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterInfo<'a>>,
            >,
        >,
    >,
    pub inst: Option<flatbuffers::WIPOffset<clz_Torappu_CharacterInst_Metadata<'a>>>,
    pub skillIndex: i32,
    pub mainSkillLvl: i32,
    pub skinId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tmplId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub overrideSkillBlackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardArgs {
            initialCnt: 0,
            hidden: false,
            alias: None,
            uniEquipIds: None,
            showSpIllust: false,
            masterInfos: None,
            inst: None,
            skillIndex: 0,
            mainSkillLvl: 0,
            skinId: None,
            tmplId: None,
            overrideSkillBlackboard: None,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard",
            12,
        )?;
        s.serialize_field("initialCnt", &self.initialCnt())?;
        s.serialize_field("hidden", &self.hidden())?;
        if let Some(f) = self.alias() {
            s.serialize_field("alias", &f)?;
        } else {
            s.skip_field("alias")?;
        }
        if let Some(f) = self.uniEquipIds() {
            s.serialize_field("uniEquipIds", &f)?;
        } else {
            s.skip_field("uniEquipIds")?;
        }
        s.serialize_field("showSpIllust", &self.showSpIllust())?;
        if let Some(f) = self.masterInfos() {
            s.serialize_field("masterInfos", &f)?;
        } else {
            s.skip_field("masterInfos")?;
        }
        if let Some(f) = self.inst() {
            s.serialize_field("inst", &f)?;
        } else {
            s.skip_field("inst")?;
        }
        s.serialize_field("skillIndex", &self.skillIndex())?;
        s.serialize_field("mainSkillLvl", &self.mainSkillLvl())?;
        if let Some(f) = self.skinId() {
            s.serialize_field("skinId", &f)?;
        } else {
            s.skip_field("skinId")?;
        }
        if let Some(f) = self.tmplId() {
            s.serialize_field("tmplId", &f)?;
        } else {
            s.skip_field("tmplId")?;
        }
        if let Some(f) = self.overrideSkillBlackboard() {
            s.serialize_field("overrideSkillBlackboard", &f)?;
        } else {
            s.skip_field("overrideSkillBlackboard")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_initialCnt(&mut self, initialCnt: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_INITIALCNT,
            initialCnt,
            0,
        );
    }
    #[inline]
    pub fn add_hidden(&mut self, hidden: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_HIDDEN,
            hidden,
            false,
        );
    }
    #[inline]
    pub fn add_alias(&mut self, alias: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_ALIAS,
            alias,
        );
    }
    #[inline]
    pub fn add_uniEquipIds(
        &mut self,
        uniEquipIds: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UniqueEquipPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_UNIEQUIPIDS,
            uniEquipIds,
        );
    }
    #[inline]
    pub fn add_showSpIllust(&mut self, showSpIllust: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_SHOWSPILLUST,
            showSpIllust,
            false,
        );
    }
    #[inline]
    pub fn add_masterInfos(
        &mut self,
        masterInfos: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_MasterInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_MASTERINFOS,
            masterInfos,
        );
    }
    #[inline]
    pub fn add_inst(
        &mut self,
        inst: flatbuffers::WIPOffset<clz_Torappu_CharacterInst_Metadata<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterInst_Metadata>>(
                clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_INST,
                inst,
            );
    }
    #[inline]
    pub fn add_skillIndex(&mut self, skillIndex: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_SKILLINDEX,
            skillIndex,
            0,
        );
    }
    #[inline]
    pub fn add_mainSkillLvl(&mut self, mainSkillLvl: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_MAINSKILLLVL,
            mainSkillLvl,
            0,
        );
    }
    #[inline]
    pub fn add_skinId(&mut self, skinId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_SKINID,
            skinId,
        );
    }
    #[inline]
    pub fn add_tmplId(&mut self, tmplId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_TMPLID,
            tmplId,
        );
    }
    #[inline]
    pub fn add_overrideSkillBlackboard(
        &mut self,
        overrideSkillBlackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::VT_OVERRIDESKILLBLACKBOARD,
            overrideSkillBlackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard");
        ds.field("initialCnt", &self.initialCnt());
        ds.field("hidden", &self.hidden());
        ds.field("alias", &self.alias());
        ds.field("uniEquipIds", &self.uniEquipIds());
        ds.field("showSpIllust", &self.showSpIllust());
        ds.field("masterInfos", &self.masterInfos());
        ds.field("inst", &self.inst());
        ds.field("skillIndex", &self.skillIndex());
        ds.field("mainSkillLvl", &self.mainSkillLvl());
        ds.field("skinId", &self.skinId());
        ds.field("tmplId", &self.tmplId());
        ds.field("overrideSkillBlackboard", &self.overrideSkillBlackboard());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardT {
    pub initialCnt: i32,
    pub hidden: bool,
    pub alias: Option<String>,
    pub uniEquipIds: Option<Vec<clz_Torappu_CharacterData_UniqueEquipPairT>>,
    pub showSpIllust: bool,
    pub masterInfos: Option<Vec<clz_Torappu_CharacterData_MasterInfoT>>,
    pub inst: Option<Box<clz_Torappu_CharacterInst_MetadataT>>,
    pub skillIndex: i32,
    pub mainSkillLvl: i32,
    pub skinId: Option<String>,
    pub tmplId: Option<String>,
    pub overrideSkillBlackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardT {
    fn default() -> Self {
        Self {
            initialCnt: 0,
            hidden: false,
            alias: None,
            uniEquipIds: None,
            showSpIllust: false,
            masterInfos: None,
            inst: None,
            skillIndex: 0,
            mainSkillLvl: 0,
            skinId: None,
            tmplId: None,
            overrideSkillBlackboard: None,
        }
    }
}
impl clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard<'b>> {
        let initialCnt = self.initialCnt;
        let hidden = self.hidden;
        let alias = self.alias.as_ref().map(|x| _fbb.create_string(x));
        let uniEquipIds = self.uniEquipIds.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let showSpIllust = self.showSpIllust;
        let masterInfos = self.masterInfos.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let inst = self.inst.as_ref().map(|x| x.pack(_fbb));
        let skillIndex = self.skillIndex;
        let mainSkillLvl = self.mainSkillLvl;
        let skinId = self.skinId.as_ref().map(|x| _fbb.create_string(x));
        let tmplId = self.tmplId.as_ref().map(|x| _fbb.create_string(x));
        let overrideSkillBlackboard = self.overrideSkillBlackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard::create(
            _fbb,
            &clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardArgs {
                initialCnt,
                hidden,
                alias,
                uniEquipIds,
                showSpIllust,
                masterInfos,
                inst,
                skillIndex,
                mainSkillLvl,
                skinId,
                tmplId,
                overrideSkillBlackboard,
            },
        )
    }
}
pub enum clz_Torappu_LevelData_PredefinedDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData_PredefinedData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData_PredefinedData<'a> {
    type Inner = clz_Torappu_LevelData_PredefinedData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData_PredefinedData<'a> {
    pub const VT_CHARACTERINSTS: flatbuffers::VOffsetT = 4;
    pub const VT_TOKENINSTS: flatbuffers::VOffsetT = 6;
    pub const VT_CHARACTERCARDS: flatbuffers::VOffsetT = 8;
    pub const VT_TOKENCARDS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData_PredefinedData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelData_PredefinedDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData<'bldr>> {
        let mut builder = clz_Torappu_LevelData_PredefinedDataBuilder::new(_fbb);
        if let Some(x) = args.tokenCards {
            builder.add_tokenCards(x);
        }
        if let Some(x) = args.characterCards {
            builder.add_characterCards(x);
        }
        if let Some(x) = args.tokenInsts {
            builder.add_tokenInsts(x);
        }
        if let Some(x) = args.characterInsts {
            builder.add_characterInsts(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelData_PredefinedDataT {
        let characterInsts = self
            .characterInsts()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let tokenInsts = self
            .tokenInsts()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let characterCards = self
            .characterCards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let tokenCards = self
            .tokenCards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_LevelData_PredefinedDataT {
            characterInsts,
            tokenInsts,
            characterCards,
            tokenCards,
        }
    }

    #[inline]
    pub fn characterInsts(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_LevelData_PredefinedData_PredefinedCharacter,
                    >,
                >,
            >>(
                clz_Torappu_LevelData_PredefinedData::VT_CHARACTERINSTS,
                None,
            )
        }
    }
    #[inline]
    pub fn tokenInsts(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_LevelData_PredefinedData_PredefinedCharacter,
                    >,
                >,
            >>(clz_Torappu_LevelData_PredefinedData::VT_TOKENINSTS, None)
        }
    }
    #[inline]
    pub fn characterCards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_PredefinedData_PredefinedCard<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_LevelData_PredefinedData_PredefinedCard,
                    >,
                >,
            >>(
                clz_Torappu_LevelData_PredefinedData::VT_CHARACTERCARDS,
                None,
            )
        }
    }
    #[inline]
    pub fn tokenCards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard,
                    >,
                >,
            >>(clz_Torappu_LevelData_PredefinedData::VT_TOKENCARDS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData_PredefinedData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_LevelData_PredefinedData_PredefinedCharacter,
                    >,
                >,
            >>("characterInsts", Self::VT_CHARACTERINSTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_LevelData_PredefinedData_PredefinedCharacter,
                    >,
                >,
            >>("tokenInsts", Self::VT_TOKENINSTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_LevelData_PredefinedData_PredefinedCard,
                    >,
                >,
            >>("characterCards", Self::VT_CHARACTERCARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard,
                    >,
                >,
            >>("tokenCards", Self::VT_TOKENCARDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelData_PredefinedDataArgs<'a> {
    pub characterInsts: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'a>,
                >,
            >,
        >,
    >,
    pub tokenInsts: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'a>,
                >,
            >,
        >,
    >,
    pub characterCards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_LevelData_PredefinedData_PredefinedCard<'a>,
                >,
            >,
        >,
    >,
    pub tokenCards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_LevelData_PredefinedDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelData_PredefinedDataArgs {
            characterInsts: None,
            tokenInsts: None,
            characterCards: None,
            tokenCards: None,
        }
    }
}

impl Serialize for clz_Torappu_LevelData_PredefinedData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LevelData_PredefinedData", 4)?;
        if let Some(f) = self.characterInsts() {
            s.serialize_field("characterInsts", &f)?;
        } else {
            s.skip_field("characterInsts")?;
        }
        if let Some(f) = self.tokenInsts() {
            s.serialize_field("tokenInsts", &f)?;
        } else {
            s.skip_field("tokenInsts")?;
        }
        if let Some(f) = self.characterCards() {
            s.serialize_field("characterCards", &f)?;
        } else {
            s.skip_field("characterCards")?;
        }
        if let Some(f) = self.tokenCards() {
            s.serialize_field("tokenCards", &f)?;
        } else {
            s.skip_field("tokenCards")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LevelData_PredefinedDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_LevelData_PredefinedDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_characterInsts(
        &mut self,
        characterInsts: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData::VT_CHARACTERINSTS,
            characterInsts,
        );
    }
    #[inline]
    pub fn add_tokenInsts(
        &mut self,
        tokenInsts: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_LevelData_PredefinedData_PredefinedCharacter<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData::VT_TOKENINSTS,
            tokenInsts,
        );
    }
    #[inline]
    pub fn add_characterCards(
        &mut self,
        characterCards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_LevelData_PredefinedData_PredefinedCard<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData::VT_CHARACTERCARDS,
            characterCards,
        );
    }
    #[inline]
    pub fn add_tokenCards(
        &mut self,
        tokenCards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_LevelData_PredefinedData_PredefinedTokenCard<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData_PredefinedData::VT_TOKENCARDS,
            tokenCards,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelData_PredefinedDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelData_PredefinedDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData_PredefinedData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData_PredefinedData");
        ds.field("characterInsts", &self.characterInsts());
        ds.field("tokenInsts", &self.tokenInsts());
        ds.field("characterCards", &self.characterCards());
        ds.field("tokenCards", &self.tokenCards());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelData_PredefinedDataT {
    pub characterInsts: Option<Vec<clz_Torappu_LevelData_PredefinedData_PredefinedCharacterT>>,
    pub tokenInsts: Option<Vec<clz_Torappu_LevelData_PredefinedData_PredefinedCharacterT>>,
    pub characterCards: Option<Vec<clz_Torappu_LevelData_PredefinedData_PredefinedCardT>>,
    pub tokenCards: Option<Vec<clz_Torappu_LevelData_PredefinedData_PredefinedTokenCardT>>,
}
impl Default for clz_Torappu_LevelData_PredefinedDataT {
    fn default() -> Self {
        Self {
            characterInsts: None,
            tokenInsts: None,
            characterCards: None,
            tokenCards: None,
        }
    }
}
impl clz_Torappu_LevelData_PredefinedDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData<'b>> {
        let characterInsts = self.characterInsts.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let tokenInsts = self.tokenInsts.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let characterCards = self.characterCards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let tokenCards = self.tokenCards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_LevelData_PredefinedData::create(
            _fbb,
            &clz_Torappu_LevelData_PredefinedDataArgs {
                characterInsts,
                tokenInsts,
                characterCards,
                tokenCards,
            },
        )
    }
}
pub enum clz_Torappu_LevelDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_LevelData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_LevelData<'a> {
    type Inner = clz_Torappu_LevelData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_LevelData<'a> {
    pub const VT_OPTIONS: flatbuffers::VOffsetT = 4;
    pub const VT_LEVELID: flatbuffers::VOffsetT = 6;
    pub const VT_MAPID: flatbuffers::VOffsetT = 8;
    pub const VT_BGMEVENT: flatbuffers::VOffsetT = 10;
    pub const VT_ENVIRONMENTSE: flatbuffers::VOffsetT = 12;
    pub const VT_MAPDATA: flatbuffers::VOffsetT = 14;
    pub const VT_TILESDISALLOWTOLOCATE: flatbuffers::VOffsetT = 16;
    pub const VT_RUNES: flatbuffers::VOffsetT = 18;
    pub const VT_OPTIONALRUNES: flatbuffers::VOffsetT = 20;
    pub const VT_GLOBALBUFFS: flatbuffers::VOffsetT = 22;
    pub const VT_ROUTES: flatbuffers::VOffsetT = 24;
    pub const VT_EXTRAROUTES: flatbuffers::VOffsetT = 26;
    pub const VT_ENEMIES: flatbuffers::VOffsetT = 28;
    pub const VT_ENEMYDBREFS: flatbuffers::VOffsetT = 30;
    pub const VT_WAVES: flatbuffers::VOffsetT = 32;
    pub const VT_BRANCHES: flatbuffers::VOffsetT = 34;
    pub const VT_PREDEFINES: flatbuffers::VOffsetT = 36;
    pub const VT_HARDPREDEFINES: flatbuffers::VOffsetT = 38;
    pub const VT_EXCLUDECHARIDLIST: flatbuffers::VOffsetT = 40;
    pub const VT_RANDOMSEED: flatbuffers::VOffsetT = 42;
    pub const VT_OPERACONFIG: flatbuffers::VOffsetT = 44;
    pub const VT_CAMERAPLUGIN: flatbuffers::VOffsetT = 46;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_LevelData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_LevelDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData<'bldr>> {
        let mut builder = clz_Torappu_LevelDataBuilder::new(_fbb);
        if let Some(x) = args.cameraPlugin {
            builder.add_cameraPlugin(x);
        }
        if let Some(x) = args.operaConfig {
            builder.add_operaConfig(x);
        }
        builder.add_randomSeed(args.randomSeed);
        if let Some(x) = args.excludeCharIdList {
            builder.add_excludeCharIdList(x);
        }
        if let Some(x) = args.hardPredefines {
            builder.add_hardPredefines(x);
        }
        if let Some(x) = args.predefines {
            builder.add_predefines(x);
        }
        if let Some(x) = args.branches {
            builder.add_branches(x);
        }
        if let Some(x) = args.waves {
            builder.add_waves(x);
        }
        if let Some(x) = args.enemyDbRefs {
            builder.add_enemyDbRefs(x);
        }
        if let Some(x) = args.enemies {
            builder.add_enemies(x);
        }
        if let Some(x) = args.extraRoutes {
            builder.add_extraRoutes(x);
        }
        if let Some(x) = args.routes {
            builder.add_routes(x);
        }
        if let Some(x) = args.globalBuffs {
            builder.add_globalBuffs(x);
        }
        if let Some(x) = args.optionalRunes {
            builder.add_optionalRunes(x);
        }
        if let Some(x) = args.runes {
            builder.add_runes(x);
        }
        if let Some(x) = args.tilesDisallowToLocate {
            builder.add_tilesDisallowToLocate(x);
        }
        if let Some(x) = args.mapData {
            builder.add_mapData(x);
        }
        if let Some(x) = args.environmentSe {
            builder.add_environmentSe(x);
        }
        if let Some(x) = args.bgmEvent {
            builder.add_bgmEvent(x);
        }
        if let Some(x) = args.mapId {
            builder.add_mapId(x);
        }
        if let Some(x) = args.levelId {
            builder.add_levelId(x);
        }
        if let Some(x) = args.options {
            builder.add_options(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_LevelDataT {
        let options = self.options().map(|x| Box::new(x.unpack()));
        let levelId = self.levelId().map(|x| x.to_string());
        let mapId = self.mapId().map(|x| x.to_string());
        let bgmEvent = self.bgmEvent().map(|x| x.to_string());
        let environmentSe = self.environmentSe().map(|x| x.to_string());
        let mapData = self.mapData().map(|x| Box::new(x.unpack()));
        let tilesDisallowToLocate = self
            .tilesDisallowToLocate()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let runes = self.runes().map(|x| x.iter().map(|t| t.unpack()).collect());
        let optionalRunes = self
            .optionalRunes()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let globalBuffs = self
            .globalBuffs()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let routes = self
            .routes()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let extraRoutes = self
            .extraRoutes()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let enemies = self
            .enemies()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let enemyDbRefs = self
            .enemyDbRefs()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let waves = self.waves().map(|x| x.iter().map(|t| t.unpack()).collect());
        let branches = self
            .branches()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let predefines = self.predefines().map(|x| Box::new(x.unpack()));
        let hardPredefines = self.hardPredefines().map(|x| Box::new(x.unpack()));
        let excludeCharIdList = self
            .excludeCharIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let randomSeed = self.randomSeed();
        let operaConfig = self.operaConfig().map(|x| x.to_string());
        let cameraPlugin = self.cameraPlugin().map(|x| x.to_string());
        clz_Torappu_LevelDataT {
            options,
            levelId,
            mapId,
            bgmEvent,
            environmentSe,
            mapData,
            tilesDisallowToLocate,
            runes,
            optionalRunes,
            globalBuffs,
            routes,
            extraRoutes,
            enemies,
            enemyDbRefs,
            waves,
            branches,
            predefines,
            hardPredefines,
            excludeCharIdList,
            randomSeed,
            operaConfig,
            cameraPlugin,
        }
    }

    #[inline]
    pub fn options(&self) -> Option<clz_Torappu_LevelData_Options<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_Options>>(
                    clz_Torappu_LevelData::VT_OPTIONS,
                    None,
                )
        }
    }
    #[inline]
    pub fn levelId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_LevelData::VT_LEVELID, None)
        }
    }
    #[inline]
    pub fn mapId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_LevelData::VT_MAPID, None)
        }
    }
    #[inline]
    pub fn bgmEvent(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_LevelData::VT_BGMEVENT, None)
        }
    }
    #[inline]
    pub fn environmentSe(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData::VT_ENVIRONMENTSE,
                None,
            )
        }
    }
    #[inline]
    pub fn mapData(&self) -> Option<clz_Torappu_MapData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_MapData>>(
                    clz_Torappu_LevelData::VT_MAPDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn tilesDisallowToLocate(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>,
            >>(clz_Torappu_LevelData::VT_TILESDISALLOWTOLOCATE, None)
        }
    }
    #[inline]
    pub fn runes(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData>,
                >,
            >>(clz_Torappu_LevelData::VT_RUNES, None)
        }
    }
    #[inline]
    pub fn optionalRunes(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_clz_Torappu_LegacyInLevelRuneData,
                    >,
                >,
            >>(clz_Torappu_LevelData::VT_OPTIONALRUNES, None)
        }
    }
    #[inline]
    pub fn globalBuffs(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_GlobalBuffData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_GlobalBuffData>,
                >,
            >>(clz_Torappu_LevelData::VT_GLOBALBUFFS, None)
        }
    }
    #[inline]
    pub fn routes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RouteData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RouteData>>,
            >>(clz_Torappu_LevelData::VT_ROUTES, None)
        }
    }
    #[inline]
    pub fn extraRoutes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RouteData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RouteData>>,
            >>(clz_Torappu_LevelData::VT_EXTRAROUTES, None)
        }
    }
    #[inline]
    pub fn enemies(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData>,
                >,
            >>(clz_Torappu_LevelData::VT_ENEMIES, None)
        }
    }
    #[inline]
    pub fn enemyDbRefs(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyDataDbReference<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyDataDbReference>,
                >,
            >>(clz_Torappu_LevelData::VT_ENEMYDBREFS, None)
        }
    }
    #[inline]
    pub fn waves(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_WaveData<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_WaveData>,
                >,
            >>(clz_Torappu_LevelData::VT_WAVES, None)
        }
    }
    #[inline]
    pub fn branches(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_LevelData_BranchData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_LevelData_BranchData>,
                >,
            >>(clz_Torappu_LevelData::VT_BRANCHES, None)
        }
    }
    #[inline]
    pub fn predefines(&self) -> Option<clz_Torappu_LevelData_PredefinedData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_PredefinedData>>(
                    clz_Torappu_LevelData::VT_PREDEFINES,
                    None,
                )
        }
    }
    #[inline]
    pub fn hardPredefines(&self) -> Option<clz_Torappu_LevelData_PredefinedData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_PredefinedData>>(
                    clz_Torappu_LevelData::VT_HARDPREDEFINES,
                    None,
                )
        }
    }
    #[inline]
    pub fn excludeCharIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_LevelData::VT_EXCLUDECHARIDLIST, None)
        }
    }
    #[inline]
    pub fn randomSeed(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_LevelData::VT_RANDOMSEED, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn operaConfig(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData::VT_OPERACONFIG,
                None,
            )
        }
    }
    #[inline]
    pub fn cameraPlugin(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_LevelData::VT_CAMERAPLUGIN,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_LevelData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_Options>>(
                "options",
                Self::VT_OPTIONS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("levelId", Self::VT_LEVELID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mapId", Self::VT_MAPID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bgmEvent",
                Self::VT_BGMEVENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "environmentSe",
                Self::VT_ENVIRONMENTSE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_MapData>>(
                "mapData",
                Self::VT_MAPDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>,
            >>(
                "tilesDisallowToLocate",
                Self::VT_TILESDISALLOWTOLOCATE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData>,
                >,
            >>("runes", Self::VT_RUNES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_clz_Torappu_LegacyInLevelRuneData,
                    >,
                >,
            >>("optionalRunes", Self::VT_OPTIONALRUNES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_GlobalBuffData>,
                >,
            >>("globalBuffs", Self::VT_GLOBALBUFFS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RouteData>>,
            >>("routes", Self::VT_ROUTES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RouteData>>,
            >>("extraRoutes", Self::VT_EXTRAROUTES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData>,
                >,
            >>("enemies", Self::VT_ENEMIES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyDataDbReference>,
                >,
            >>("enemyDbRefs", Self::VT_ENEMYDBREFS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_WaveData>,
                >,
            >>("waves", Self::VT_WAVES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_LevelData_BranchData>,
                >,
            >>("branches", Self::VT_BRANCHES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_PredefinedData>>(
                "predefines",
                Self::VT_PREDEFINES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_PredefinedData>>(
                "hardPredefines",
                Self::VT_HARDPREDEFINES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("excludeCharIdList", Self::VT_EXCLUDECHARIDLIST, false)?
            .visit_field::<i32>("randomSeed", Self::VT_RANDOMSEED, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "operaConfig",
                Self::VT_OPERACONFIG,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "cameraPlugin",
                Self::VT_CAMERAPLUGIN,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_LevelDataArgs<'a> {
    pub options: Option<flatbuffers::WIPOffset<clz_Torappu_LevelData_Options<'a>>>,
    pub levelId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mapId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bgmEvent: Option<flatbuffers::WIPOffset<&'a str>>,
    pub environmentSe: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mapData: Option<flatbuffers::WIPOffset<clz_Torappu_MapData<'a>>>,
    pub tilesDisallowToLocate: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition<'a>>>,
        >,
    >,
    pub runes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData<'a>>,
            >,
        >,
    >,
    pub optionalRunes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_LegacyInLevelRuneData<'a>,
                >,
            >,
        >,
    >,
    pub globalBuffs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_GlobalBuffData<'a>>,
            >,
        >,
    >,
    pub routes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RouteData<'a>>>,
        >,
    >,
    pub extraRoutes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RouteData<'a>>>,
        >,
    >,
    pub enemies: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData<'a>>,
            >,
        >,
    >,
    pub enemyDbRefs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyDataDbReference<'a>>,
            >,
        >,
    >,
    pub waves: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_WaveData<'a>>,
            >,
        >,
    >,
    pub branches: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_LevelData_BranchData<'a>>,
            >,
        >,
    >,
    pub predefines: Option<flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData<'a>>>,
    pub hardPredefines: Option<flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData<'a>>>,
    pub excludeCharIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub randomSeed: i32,
    pub operaConfig: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cameraPlugin: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_LevelDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_LevelDataArgs {
            options: None,
            levelId: None,
            mapId: None,
            bgmEvent: None,
            environmentSe: None,
            mapData: None,
            tilesDisallowToLocate: None,
            runes: None,
            optionalRunes: None,
            globalBuffs: None,
            routes: None,
            extraRoutes: None,
            enemies: None,
            enemyDbRefs: None,
            waves: None,
            branches: None,
            predefines: None,
            hardPredefines: None,
            excludeCharIdList: None,
            randomSeed: 0,
            operaConfig: None,
            cameraPlugin: None,
        }
    }
}

impl Serialize for clz_Torappu_LevelData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_LevelData", 22)?;
        if let Some(f) = self.options() {
            s.serialize_field("options", &f)?;
        } else {
            s.skip_field("options")?;
        }
        if let Some(f) = self.levelId() {
            s.serialize_field("levelId", &f)?;
        } else {
            s.skip_field("levelId")?;
        }
        if let Some(f) = self.mapId() {
            s.serialize_field("mapId", &f)?;
        } else {
            s.skip_field("mapId")?;
        }
        if let Some(f) = self.bgmEvent() {
            s.serialize_field("bgmEvent", &f)?;
        } else {
            s.skip_field("bgmEvent")?;
        }
        if let Some(f) = self.environmentSe() {
            s.serialize_field("environmentSe", &f)?;
        } else {
            s.skip_field("environmentSe")?;
        }
        if let Some(f) = self.mapData() {
            s.serialize_field("mapData", &f)?;
        } else {
            s.skip_field("mapData")?;
        }
        if let Some(f) = self.tilesDisallowToLocate() {
            s.serialize_field("tilesDisallowToLocate", &f)?;
        } else {
            s.skip_field("tilesDisallowToLocate")?;
        }
        if let Some(f) = self.runes() {
            s.serialize_field("runes", &f)?;
        } else {
            s.skip_field("runes")?;
        }
        if let Some(f) = self.optionalRunes() {
            s.serialize_field("optionalRunes", &f)?;
        } else {
            s.skip_field("optionalRunes")?;
        }
        if let Some(f) = self.globalBuffs() {
            s.serialize_field("globalBuffs", &f)?;
        } else {
            s.skip_field("globalBuffs")?;
        }
        if let Some(f) = self.routes() {
            s.serialize_field("routes", &f)?;
        } else {
            s.skip_field("routes")?;
        }
        if let Some(f) = self.extraRoutes() {
            s.serialize_field("extraRoutes", &f)?;
        } else {
            s.skip_field("extraRoutes")?;
        }
        if let Some(f) = self.enemies() {
            s.serialize_field("enemies", &f)?;
        } else {
            s.skip_field("enemies")?;
        }
        if let Some(f) = self.enemyDbRefs() {
            s.serialize_field("enemyDbRefs", &f)?;
        } else {
            s.skip_field("enemyDbRefs")?;
        }
        if let Some(f) = self.waves() {
            s.serialize_field("waves", &f)?;
        } else {
            s.skip_field("waves")?;
        }
        if let Some(f) = self.branches() {
            s.serialize_field("branches", &f)?;
        } else {
            s.skip_field("branches")?;
        }
        if let Some(f) = self.predefines() {
            s.serialize_field("predefines", &f)?;
        } else {
            s.skip_field("predefines")?;
        }
        if let Some(f) = self.hardPredefines() {
            s.serialize_field("hardPredefines", &f)?;
        } else {
            s.skip_field("hardPredefines")?;
        }
        if let Some(f) = self.excludeCharIdList() {
            s.serialize_field("excludeCharIdList", &f)?;
        } else {
            s.skip_field("excludeCharIdList")?;
        }
        s.serialize_field("randomSeed", &self.randomSeed())?;
        if let Some(f) = self.operaConfig() {
            s.serialize_field("operaConfig", &f)?;
        } else {
            s.skip_field("operaConfig")?;
        }
        if let Some(f) = self.cameraPlugin() {
            s.serialize_field("cameraPlugin", &f)?;
        } else {
            s.skip_field("cameraPlugin")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_LevelDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_LevelDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_options(
        &mut self,
        options: flatbuffers::WIPOffset<clz_Torappu_LevelData_Options<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_LevelData_Options>>(
                clz_Torappu_LevelData::VT_OPTIONS,
                options,
            );
    }
    #[inline]
    pub fn add_levelId(&mut self, levelId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData::VT_LEVELID,
            levelId,
        );
    }
    #[inline]
    pub fn add_mapId(&mut self, mapId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_LevelData::VT_MAPID, mapId);
    }
    #[inline]
    pub fn add_bgmEvent(&mut self, bgmEvent: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData::VT_BGMEVENT,
            bgmEvent,
        );
    }
    #[inline]
    pub fn add_environmentSe(&mut self, environmentSe: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData::VT_ENVIRONMENTSE,
            environmentSe,
        );
    }
    #[inline]
    pub fn add_mapData(&mut self, mapData: flatbuffers::WIPOffset<clz_Torappu_MapData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_MapData>>(
                clz_Torappu_LevelData::VT_MAPDATA,
                mapData,
            );
    }
    #[inline]
    pub fn add_tilesDisallowToLocate(
        &mut self,
        tilesDisallowToLocate: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData::VT_TILESDISALLOWTOLOCATE,
            tilesDisallowToLocate,
        );
    }
    #[inline]
    pub fn add_runes(
        &mut self,
        runes: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LegacyInLevelRuneData<'b>>,
            >,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_LevelData::VT_RUNES, runes);
    }
    #[inline]
    pub fn add_optionalRunes(
        &mut self,
        optionalRunes: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_LegacyInLevelRuneData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData::VT_OPTIONALRUNES,
            optionalRunes,
        );
    }
    #[inline]
    pub fn add_globalBuffs(
        &mut self,
        globalBuffs: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_GlobalBuffData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData::VT_GLOBALBUFFS,
            globalBuffs,
        );
    }
    #[inline]
    pub fn add_routes(
        &mut self,
        routes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_RouteData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData::VT_ROUTES,
            routes,
        );
    }
    #[inline]
    pub fn add_extraRoutes(
        &mut self,
        extraRoutes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_RouteData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData::VT_EXTRAROUTES,
            extraRoutes,
        );
    }
    #[inline]
    pub fn add_enemies(
        &mut self,
        enemies: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData::VT_ENEMIES,
            enemies,
        );
    }
    #[inline]
    pub fn add_enemyDbRefs(
        &mut self,
        enemyDbRefs: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_EnemyDataDbReference<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData::VT_ENEMYDBREFS,
            enemyDbRefs,
        );
    }
    #[inline]
    pub fn add_waves(
        &mut self,
        waves: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_LevelData_WaveData<'b>>,
            >,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_LevelData::VT_WAVES, waves);
    }
    #[inline]
    pub fn add_branches(
        &mut self,
        branches: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_LevelData_BranchData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData::VT_BRANCHES,
            branches,
        );
    }
    #[inline]
    pub fn add_predefines(
        &mut self,
        predefines: flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData>>(
                clz_Torappu_LevelData::VT_PREDEFINES,
                predefines,
            );
    }
    #[inline]
    pub fn add_hardPredefines(
        &mut self,
        hardPredefines: flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_LevelData_PredefinedData>>(
                clz_Torappu_LevelData::VT_HARDPREDEFINES,
                hardPredefines,
            );
    }
    #[inline]
    pub fn add_excludeCharIdList(
        &mut self,
        excludeCharIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData::VT_EXCLUDECHARIDLIST,
            excludeCharIdList,
        );
    }
    #[inline]
    pub fn add_randomSeed(&mut self, randomSeed: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_LevelData::VT_RANDOMSEED, randomSeed, 0);
    }
    #[inline]
    pub fn add_operaConfig(&mut self, operaConfig: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData::VT_OPERACONFIG,
            operaConfig,
        );
    }
    #[inline]
    pub fn add_cameraPlugin(&mut self, cameraPlugin: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_LevelData::VT_CAMERAPLUGIN,
            cameraPlugin,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_LevelDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_LevelDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_LevelData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_LevelData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_LevelData");
        ds.field("options", &self.options());
        ds.field("levelId", &self.levelId());
        ds.field("mapId", &self.mapId());
        ds.field("bgmEvent", &self.bgmEvent());
        ds.field("environmentSe", &self.environmentSe());
        ds.field("mapData", &self.mapData());
        ds.field("tilesDisallowToLocate", &self.tilesDisallowToLocate());
        ds.field("runes", &self.runes());
        ds.field("optionalRunes", &self.optionalRunes());
        ds.field("globalBuffs", &self.globalBuffs());
        ds.field("routes", &self.routes());
        ds.field("extraRoutes", &self.extraRoutes());
        ds.field("enemies", &self.enemies());
        ds.field("enemyDbRefs", &self.enemyDbRefs());
        ds.field("waves", &self.waves());
        ds.field("branches", &self.branches());
        ds.field("predefines", &self.predefines());
        ds.field("hardPredefines", &self.hardPredefines());
        ds.field("excludeCharIdList", &self.excludeCharIdList());
        ds.field("randomSeed", &self.randomSeed());
        ds.field("operaConfig", &self.operaConfig());
        ds.field("cameraPlugin", &self.cameraPlugin());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_LevelDataT {
    pub options: Option<Box<clz_Torappu_LevelData_OptionsT>>,
    pub levelId: Option<String>,
    pub mapId: Option<String>,
    pub bgmEvent: Option<String>,
    pub environmentSe: Option<String>,
    pub mapData: Option<Box<clz_Torappu_MapDataT>>,
    pub tilesDisallowToLocate: Option<Vec<clz_Torappu_GridPositionT>>,
    pub runes: Option<Vec<clz_Torappu_LegacyInLevelRuneDataT>>,
    pub optionalRunes: Option<Vec<dict__string__list_clz_Torappu_LegacyInLevelRuneDataT>>,
    pub globalBuffs: Option<Vec<clz_Torappu_LevelData_GlobalBuffDataT>>,
    pub routes: Option<Vec<clz_Torappu_RouteDataT>>,
    pub extraRoutes: Option<Vec<clz_Torappu_RouteDataT>>,
    pub enemies: Option<Vec<clz_Torappu_LevelData_EnemyDataT>>,
    pub enemyDbRefs: Option<Vec<clz_Torappu_LevelData_EnemyDataDbReferenceT>>,
    pub waves: Option<Vec<clz_Torappu_LevelData_WaveDataT>>,
    pub branches: Option<Vec<dict__string__clz_Torappu_LevelData_BranchDataT>>,
    pub predefines: Option<Box<clz_Torappu_LevelData_PredefinedDataT>>,
    pub hardPredefines: Option<Box<clz_Torappu_LevelData_PredefinedDataT>>,
    pub excludeCharIdList: Option<Vec<String>>,
    pub randomSeed: i32,
    pub operaConfig: Option<String>,
    pub cameraPlugin: Option<String>,
}
impl Default for clz_Torappu_LevelDataT {
    fn default() -> Self {
        Self {
            options: None,
            levelId: None,
            mapId: None,
            bgmEvent: None,
            environmentSe: None,
            mapData: None,
            tilesDisallowToLocate: None,
            runes: None,
            optionalRunes: None,
            globalBuffs: None,
            routes: None,
            extraRoutes: None,
            enemies: None,
            enemyDbRefs: None,
            waves: None,
            branches: None,
            predefines: None,
            hardPredefines: None,
            excludeCharIdList: None,
            randomSeed: 0,
            operaConfig: None,
            cameraPlugin: None,
        }
    }
}
impl clz_Torappu_LevelDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_LevelData<'b>> {
        let options = self.options.as_ref().map(|x| x.pack(_fbb));
        let levelId = self.levelId.as_ref().map(|x| _fbb.create_string(x));
        let mapId = self.mapId.as_ref().map(|x| _fbb.create_string(x));
        let bgmEvent = self.bgmEvent.as_ref().map(|x| _fbb.create_string(x));
        let environmentSe = self.environmentSe.as_ref().map(|x| _fbb.create_string(x));
        let mapData = self.mapData.as_ref().map(|x| x.pack(_fbb));
        let tilesDisallowToLocate = self.tilesDisallowToLocate.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let runes = self.runes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let optionalRunes = self.optionalRunes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let globalBuffs = self.globalBuffs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let routes = self.routes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let extraRoutes = self.extraRoutes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let enemies = self.enemies.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let enemyDbRefs = self.enemyDbRefs.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let waves = self.waves.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let branches = self.branches.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let predefines = self.predefines.as_ref().map(|x| x.pack(_fbb));
        let hardPredefines = self.hardPredefines.as_ref().map(|x| x.pack(_fbb));
        let excludeCharIdList = self.excludeCharIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let randomSeed = self.randomSeed;
        let operaConfig = self.operaConfig.as_ref().map(|x| _fbb.create_string(x));
        let cameraPlugin = self.cameraPlugin.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_LevelData::create(
            _fbb,
            &clz_Torappu_LevelDataArgs {
                options,
                levelId,
                mapId,
                bgmEvent,
                environmentSe,
                mapData,
                tilesDisallowToLocate,
                runes,
                optionalRunes,
                globalBuffs,
                routes,
                extraRoutes,
                enemies,
                enemyDbRefs,
                waves,
                branches,
                predefines,
                hardPredefines,
                excludeCharIdList,
                randomSeed,
                operaConfig,
                cameraPlugin,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_LevelData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_level_data_unchecked`.
pub fn root_as_clz_torappu_level_data(
    buf: &[u8],
) -> Result<clz_Torappu_LevelData<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_LevelData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_LevelData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_level_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_level_data(
    buf: &[u8],
) -> Result<clz_Torappu_LevelData<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_LevelData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_LevelData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_level_data_unchecked`.
pub fn root_as_clz_torappu_level_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_LevelData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_LevelData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_LevelData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_level_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_level_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_LevelData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_LevelData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_LevelData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_LevelData`.
pub unsafe fn root_as_clz_torappu_level_data_unchecked(buf: &[u8]) -> clz_Torappu_LevelData<'_> {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_LevelData>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_LevelData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_LevelData`.
pub unsafe fn size_prefixed_root_as_clz_torappu_level_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_LevelData<'_> {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_LevelData>(buf) }
}
#[inline]
pub fn finish_clz_torappu_level_data_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_LevelData<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_level_data_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_LevelData<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
