// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ENEMY_LEVEL_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ENEMY_LEVEL_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ENEMY_LEVEL_TYPE: [enum__Torappu_EnemyLevelType; 4] = [
    enum__Torappu_EnemyLevelType::NORMAL,
    enum__Torappu_EnemyLevelType::ELITE,
    enum__Torappu_EnemyLevelType::BOSS,
    enum__Torappu_EnemyLevelType::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EnemyLevelType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EnemyLevelType {
    pub const NORMAL: Self = Self(0);
    pub const ELITE: Self = Self(1);
    pub const BOSS: Self = Self(2);
    pub const E_NUM: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NORMAL, Self::ELITE, Self::BOSS, Self::E_NUM];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::ELITE => Some("ELITE"),
            Self::BOSS => Some("BOSS"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EnemyLevelType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_EnemyLevelType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_EnemyLevelType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EnemyLevelType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EnemyLevelType {
    type Output = enum__Torappu_EnemyLevelType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EnemyLevelType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EnemyLevelType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EnemyLevelType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ENEMY_HAND_BOOK_DATA_TEXT_FORMAT: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ENEMY_HAND_BOOK_DATA_TEXT_FORMAT: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ENEMY_HAND_BOOK_DATA_TEXT_FORMAT:
    [enum__Torappu_EnemyHandBookData_TextFormat; 3] = [
    enum__Torappu_EnemyHandBookData_TextFormat::NORMAL,
    enum__Torappu_EnemyHandBookData_TextFormat::TITLE,
    enum__Torappu_EnemyHandBookData_TextFormat::SILENCE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EnemyHandBookData_TextFormat(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EnemyHandBookData_TextFormat {
    pub const NORMAL: Self = Self(0);
    pub const TITLE: Self = Self(1);
    pub const SILENCE: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NORMAL, Self::TITLE, Self::SILENCE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::TITLE => Some("TITLE"),
            Self::SILENCE => Some("SILENCE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EnemyHandBookData_TextFormat {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_EnemyHandBookData_TextFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_EnemyHandBookData_TextFormat",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EnemyHandBookData_TextFormat {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EnemyHandBookData_TextFormat {
    type Output = enum__Torappu_EnemyHandBookData_TextFormat;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EnemyHandBookData_TextFormat {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EnemyHandBookData_TextFormat {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EnemyHandBookData_TextFormat {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ENEMY_HAND_BOOK_DAMAGE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ENEMY_HAND_BOOK_DAMAGE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ENEMY_HAND_BOOK_DAMAGE_TYPE:
    [enum__Torappu_EnemyHandBookDamageType; 4] = [
    enum__Torappu_EnemyHandBookDamageType::PHYSIC,
    enum__Torappu_EnemyHandBookDamageType::MAGIC,
    enum__Torappu_EnemyHandBookDamageType::HEAL,
    enum__Torappu_EnemyHandBookDamageType::NO_DAMAGE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EnemyHandBookDamageType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EnemyHandBookDamageType {
    pub const PHYSIC: Self = Self(0);
    pub const MAGIC: Self = Self(1);
    pub const HEAL: Self = Self(2);
    pub const NO_DAMAGE: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::PHYSIC, Self::MAGIC, Self::HEAL, Self::NO_DAMAGE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::PHYSIC => Some("PHYSIC"),
            Self::MAGIC => Some("MAGIC"),
            Self::HEAL => Some("HEAL"),
            Self::NO_DAMAGE => Some("NO_DAMAGE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EnemyHandBookDamageType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_EnemyHandBookDamageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_EnemyHandBookDamageType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EnemyHandBookDamageType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EnemyHandBookDamageType {
    type Output = enum__Torappu_EnemyHandBookDamageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EnemyHandBookDamageType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EnemyHandBookDamageType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EnemyHandBookDamageType {}
pub enum clz_Torappu_EnemyHandbookLevelInfoData_RangePairOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a> {
    type Inner = clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a> {
    pub const VT_MIN: flatbuffers::VOffsetT = 4;
    pub const VT_MAX: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_EnemyHandbookLevelInfoData_RangePair { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_EnemyHandbookLevelInfoData_RangePairArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'bldr>> {
        let mut builder = clz_Torappu_EnemyHandbookLevelInfoData_RangePairBuilder::new(_fbb);
        builder.add_max(args.max);
        builder.add_min(args.min);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_EnemyHandbookLevelInfoData_RangePairT {
        let min = self.min();
        let max = self.max();
        clz_Torappu_EnemyHandbookLevelInfoData_RangePairT { min, max }
    }

    #[inline]
    pub fn min(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_EnemyHandbookLevelInfoData_RangePair::VT_MIN,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn max(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_EnemyHandbookLevelInfoData_RangePair::VT_MAX,
                    Some(0.0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("min", Self::VT_MIN, false)?
            .visit_field::<f32>("max", Self::VT_MAX, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_EnemyHandbookLevelInfoData_RangePairArgs {
    pub min: f32,
    pub max: f32,
}
impl<'a> Default for clz_Torappu_EnemyHandbookLevelInfoData_RangePairArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_EnemyHandbookLevelInfoData_RangePairArgs { min: 0.0, max: 0.0 }
    }
}

impl Serialize for clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_EnemyHandbookLevelInfoData_RangePair", 2)?;
        s.serialize_field("min", &self.min())?;
        s.serialize_field("max", &self.max())?;
        s.end()
    }
}

pub struct clz_Torappu_EnemyHandbookLevelInfoData_RangePairBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_EnemyHandbookLevelInfoData_RangePairBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_min(&mut self, min: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_EnemyHandbookLevelInfoData_RangePair::VT_MIN,
            min,
            0.0,
        );
    }
    #[inline]
    pub fn add_max(&mut self, max: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_EnemyHandbookLevelInfoData_RangePair::VT_MAX,
            max,
            0.0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_EnemyHandbookLevelInfoData_RangePairBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_EnemyHandbookLevelInfoData_RangePairBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_EnemyHandbookLevelInfoData_RangePair");
        ds.field("min", &self.min());
        ds.field("max", &self.max());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_EnemyHandbookLevelInfoData_RangePairT {
    pub min: f32,
    pub max: f32,
}
impl Default for clz_Torappu_EnemyHandbookLevelInfoData_RangePairT {
    fn default() -> Self {
        Self { min: 0.0, max: 0.0 }
    }
}
impl clz_Torappu_EnemyHandbookLevelInfoData_RangePairT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'b>> {
        let min = self.min;
        let max = self.max;
        clz_Torappu_EnemyHandbookLevelInfoData_RangePair::create(
            _fbb,
            &clz_Torappu_EnemyHandbookLevelInfoData_RangePairArgs { min, max },
        )
    }
}
pub enum clz_Torappu_EnemyHandbookLevelInfoDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_EnemyHandbookLevelInfoData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_EnemyHandbookLevelInfoData<'a> {
    type Inner = clz_Torappu_EnemyHandbookLevelInfoData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_EnemyHandbookLevelInfoData<'a> {
    pub const VT_CLASSLEVEL: flatbuffers::VOffsetT = 4;
    pub const VT_ATTACK: flatbuffers::VOffsetT = 6;
    pub const VT_DEF: flatbuffers::VOffsetT = 8;
    pub const VT_MAGICRES: flatbuffers::VOffsetT = 10;
    pub const VT_MAXHP: flatbuffers::VOffsetT = 12;
    pub const VT_MOVESPEED: flatbuffers::VOffsetT = 14;
    pub const VT_ATTACKSPEED: flatbuffers::VOffsetT = 16;
    pub const VT_ENEMYDAMAGERES: flatbuffers::VOffsetT = 18;
    pub const VT_ENEMYRES: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_EnemyHandbookLevelInfoData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_EnemyHandbookLevelInfoDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData<'bldr>> {
        let mut builder = clz_Torappu_EnemyHandbookLevelInfoDataBuilder::new(_fbb);
        if let Some(x) = args.enemyRes {
            builder.add_enemyRes(x);
        }
        if let Some(x) = args.enemyDamageRes {
            builder.add_enemyDamageRes(x);
        }
        if let Some(x) = args.attackSpeed {
            builder.add_attackSpeed(x);
        }
        if let Some(x) = args.moveSpeed {
            builder.add_moveSpeed(x);
        }
        if let Some(x) = args.maxHP {
            builder.add_maxHP(x);
        }
        if let Some(x) = args.magicRes {
            builder.add_magicRes(x);
        }
        if let Some(x) = args.def {
            builder.add_def(x);
        }
        if let Some(x) = args.attack {
            builder.add_attack(x);
        }
        if let Some(x) = args.classLevel {
            builder.add_classLevel(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_EnemyHandbookLevelInfoDataT {
        let classLevel = self.classLevel().map(|x| x.to_string());
        let attack = self.attack().map(|x| Box::new(x.unpack()));
        let def = self.def().map(|x| Box::new(x.unpack()));
        let magicRes = self.magicRes().map(|x| Box::new(x.unpack()));
        let maxHP = self.maxHP().map(|x| Box::new(x.unpack()));
        let moveSpeed = self.moveSpeed().map(|x| Box::new(x.unpack()));
        let attackSpeed = self.attackSpeed().map(|x| Box::new(x.unpack()));
        let enemyDamageRes = self.enemyDamageRes().map(|x| Box::new(x.unpack()));
        let enemyRes = self.enemyRes().map(|x| Box::new(x.unpack()));
        clz_Torappu_EnemyHandbookLevelInfoDataT {
            classLevel,
            attack,
            def,
            magicRes,
            maxHP,
            moveSpeed,
            attackSpeed,
            enemyDamageRes,
            enemyRes,
        }
    }

    #[inline]
    pub fn classLevel(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EnemyHandbookLevelInfoData::VT_CLASSLEVEL,
                None,
            )
        }
    }
    #[inline]
    pub fn attack(&self) -> Option<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_ATTACK, None)
        }
    }
    #[inline]
    pub fn def(&self) -> Option<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_DEF, None)
        }
    }
    #[inline]
    pub fn magicRes(&self) -> Option<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_MAGICRES, None)
        }
    }
    #[inline]
    pub fn maxHP(&self) -> Option<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_MAXHP, None)
        }
    }
    #[inline]
    pub fn moveSpeed(&self) -> Option<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_MOVESPEED, None)
        }
    }
    #[inline]
    pub fn attackSpeed(&self) -> Option<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_ATTACKSPEED, None)
        }
    }
    #[inline]
    pub fn enemyDamageRes(&self) -> Option<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_ENEMYDAMAGERES, None)
        }
    }
    #[inline]
    pub fn enemyRes(&self) -> Option<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_ENEMYRES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_EnemyHandbookLevelInfoData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("classLevel", Self::VT_CLASSLEVEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>("attack", Self::VT_ATTACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>("def", Self::VT_DEF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>("magicRes", Self::VT_MAGICRES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>("maxHP", Self::VT_MAXHP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>("moveSpeed", Self::VT_MOVESPEED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>("attackSpeed", Self::VT_ATTACKSPEED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>("enemyDamageRes", Self::VT_ENEMYDAMAGERES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>("enemyRes", Self::VT_ENEMYRES, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_EnemyHandbookLevelInfoDataArgs<'a> {
    pub classLevel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub attack:
        Option<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>>>,
    pub def: Option<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>>>,
    pub magicRes:
        Option<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>>>,
    pub maxHP: Option<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>>>,
    pub moveSpeed:
        Option<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>>>,
    pub attackSpeed:
        Option<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>>>,
    pub enemyDamageRes:
        Option<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>>>,
    pub enemyRes:
        Option<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'a>>>,
}
impl<'a> Default for clz_Torappu_EnemyHandbookLevelInfoDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_EnemyHandbookLevelInfoDataArgs {
            classLevel: None,
            attack: None,
            def: None,
            magicRes: None,
            maxHP: None,
            moveSpeed: None,
            attackSpeed: None,
            enemyDamageRes: None,
            enemyRes: None,
        }
    }
}

impl Serialize for clz_Torappu_EnemyHandbookLevelInfoData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_EnemyHandbookLevelInfoData", 9)?;
        if let Some(f) = self.classLevel() {
            s.serialize_field("classLevel", &f)?;
        } else {
            s.skip_field("classLevel")?;
        }
        if let Some(f) = self.attack() {
            s.serialize_field("attack", &f)?;
        } else {
            s.skip_field("attack")?;
        }
        if let Some(f) = self.def() {
            s.serialize_field("def", &f)?;
        } else {
            s.skip_field("def")?;
        }
        if let Some(f) = self.magicRes() {
            s.serialize_field("magicRes", &f)?;
        } else {
            s.skip_field("magicRes")?;
        }
        if let Some(f) = self.maxHP() {
            s.serialize_field("maxHP", &f)?;
        } else {
            s.skip_field("maxHP")?;
        }
        if let Some(f) = self.moveSpeed() {
            s.serialize_field("moveSpeed", &f)?;
        } else {
            s.skip_field("moveSpeed")?;
        }
        if let Some(f) = self.attackSpeed() {
            s.serialize_field("attackSpeed", &f)?;
        } else {
            s.skip_field("attackSpeed")?;
        }
        if let Some(f) = self.enemyDamageRes() {
            s.serialize_field("enemyDamageRes", &f)?;
        } else {
            s.skip_field("enemyDamageRes")?;
        }
        if let Some(f) = self.enemyRes() {
            s.serialize_field("enemyRes", &f)?;
        } else {
            s.skip_field("enemyRes")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_EnemyHandbookLevelInfoDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_EnemyHandbookLevelInfoDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_classLevel(&mut self, classLevel: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandbookLevelInfoData::VT_CLASSLEVEL,
            classLevel,
        );
    }
    #[inline]
    pub fn add_attack(
        &mut self,
        attack: flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_ATTACK, attack);
    }
    #[inline]
    pub fn add_def(
        &mut self,
        def: flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_DEF, def);
    }
    #[inline]
    pub fn add_magicRes(
        &mut self,
        magicRes: flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_MAGICRES, magicRes);
    }
    #[inline]
    pub fn add_maxHP(
        &mut self,
        maxHP: flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_MAXHP, maxHP);
    }
    #[inline]
    pub fn add_moveSpeed(
        &mut self,
        moveSpeed: flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_MOVESPEED, moveSpeed);
    }
    #[inline]
    pub fn add_attackSpeed(
        &mut self,
        attackSpeed: flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_ATTACKSPEED, attackSpeed);
    }
    #[inline]
    pub fn add_enemyDamageRes(
        &mut self,
        enemyDamageRes: flatbuffers::WIPOffset<
            clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_ENEMYDAMAGERES, enemyDamageRes);
    }
    #[inline]
    pub fn add_enemyRes(
        &mut self,
        enemyRes: flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData_RangePair>>(clz_Torappu_EnemyHandbookLevelInfoData::VT_ENEMYRES, enemyRes);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_EnemyHandbookLevelInfoDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_EnemyHandbookLevelInfoDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_EnemyHandbookLevelInfoData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_EnemyHandbookLevelInfoData");
        ds.field("classLevel", &self.classLevel());
        ds.field("attack", &self.attack());
        ds.field("def", &self.def());
        ds.field("magicRes", &self.magicRes());
        ds.field("maxHP", &self.maxHP());
        ds.field("moveSpeed", &self.moveSpeed());
        ds.field("attackSpeed", &self.attackSpeed());
        ds.field("enemyDamageRes", &self.enemyDamageRes());
        ds.field("enemyRes", &self.enemyRes());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_EnemyHandbookLevelInfoDataT {
    pub classLevel: Option<String>,
    pub attack: Option<Box<clz_Torappu_EnemyHandbookLevelInfoData_RangePairT>>,
    pub def: Option<Box<clz_Torappu_EnemyHandbookLevelInfoData_RangePairT>>,
    pub magicRes: Option<Box<clz_Torappu_EnemyHandbookLevelInfoData_RangePairT>>,
    pub maxHP: Option<Box<clz_Torappu_EnemyHandbookLevelInfoData_RangePairT>>,
    pub moveSpeed: Option<Box<clz_Torappu_EnemyHandbookLevelInfoData_RangePairT>>,
    pub attackSpeed: Option<Box<clz_Torappu_EnemyHandbookLevelInfoData_RangePairT>>,
    pub enemyDamageRes: Option<Box<clz_Torappu_EnemyHandbookLevelInfoData_RangePairT>>,
    pub enemyRes: Option<Box<clz_Torappu_EnemyHandbookLevelInfoData_RangePairT>>,
}
impl Default for clz_Torappu_EnemyHandbookLevelInfoDataT {
    fn default() -> Self {
        Self {
            classLevel: None,
            attack: None,
            def: None,
            magicRes: None,
            maxHP: None,
            moveSpeed: None,
            attackSpeed: None,
            enemyDamageRes: None,
            enemyRes: None,
        }
    }
}
impl clz_Torappu_EnemyHandbookLevelInfoDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookLevelInfoData<'b>> {
        let classLevel = self.classLevel.as_ref().map(|x| _fbb.create_string(x));
        let attack = self.attack.as_ref().map(|x| x.pack(_fbb));
        let def = self.def.as_ref().map(|x| x.pack(_fbb));
        let magicRes = self.magicRes.as_ref().map(|x| x.pack(_fbb));
        let maxHP = self.maxHP.as_ref().map(|x| x.pack(_fbb));
        let moveSpeed = self.moveSpeed.as_ref().map(|x| x.pack(_fbb));
        let attackSpeed = self.attackSpeed.as_ref().map(|x| x.pack(_fbb));
        let enemyDamageRes = self.enemyDamageRes.as_ref().map(|x| x.pack(_fbb));
        let enemyRes = self.enemyRes.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_EnemyHandbookLevelInfoData::create(
            _fbb,
            &clz_Torappu_EnemyHandbookLevelInfoDataArgs {
                classLevel,
                attack,
                def,
                magicRes,
                maxHP,
                moveSpeed,
                attackSpeed,
                enemyDamageRes,
                enemyRes,
            },
        )
    }
}
pub enum dict__string__intOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__int<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__int<'a> {
    type Inner = dict__string__int<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__int<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__int { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__intArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__int<'bldr>> {
        let mut builder = dict__string__intBuilder::new(_fbb);
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__intT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value();
        dict__string__intT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__int::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__int) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(dict__string__int::VT_VALUE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for dict__string__int<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__intArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: i32,
}
impl<'a> Default for dict__string__intArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__intArgs {
            key: None, // required field
            value: 0,
        }
    }
}

impl Serialize for dict__string__int<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__int", 2)?;
        s.serialize_field("key", &self.key())?;
        s.serialize_field("value", &self.value())?;
        s.end()
    }
}

pub struct dict__string__intBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__intBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__int::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_
            .push_slot::<i32>(dict__string__int::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__intBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__intBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__int<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__int::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__int<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__int");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__intT {
    pub key: String,
    pub value: i32,
}
impl Default for dict__string__intT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: 0,
        }
    }
}
impl dict__string__intT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__int<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value;
        dict__string__int::create(_fbb, &dict__string__intArgs { key, value })
    }
}
pub enum clz_Torappu_EnemyHandBookData_AbiltyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_EnemyHandBookData_Abilty<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_EnemyHandBookData_Abilty<'a> {
    type Inner = clz_Torappu_EnemyHandBookData_Abilty<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_EnemyHandBookData_Abilty<'a> {
    pub const VT_TEXT: flatbuffers::VOffsetT = 4;
    pub const VT_TEXTFORMAT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_EnemyHandBookData_Abilty { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_EnemyHandBookData_AbiltyArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandBookData_Abilty<'bldr>> {
        let mut builder = clz_Torappu_EnemyHandBookData_AbiltyBuilder::new(_fbb);
        builder.add_textFormat(args.textFormat);
        if let Some(x) = args.text {
            builder.add_text(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_EnemyHandBookData_AbiltyT {
        let text = self.text().map(|x| x.to_string());
        let textFormat = self.textFormat();
        clz_Torappu_EnemyHandBookData_AbiltyT { text, textFormat }
    }

    #[inline]
    pub fn text(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EnemyHandBookData_Abilty::VT_TEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn textFormat(&self) -> enum__Torappu_EnemyHandBookData_TextFormat {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EnemyHandBookData_TextFormat>(
                    clz_Torappu_EnemyHandBookData_Abilty::VT_TEXTFORMAT,
                    Some(enum__Torappu_EnemyHandBookData_TextFormat::NORMAL),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_EnemyHandBookData_Abilty<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
            .visit_field::<enum__Torappu_EnemyHandBookData_TextFormat>(
                "textFormat",
                Self::VT_TEXTFORMAT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_EnemyHandBookData_AbiltyArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub textFormat: enum__Torappu_EnemyHandBookData_TextFormat,
}
impl<'a> Default for clz_Torappu_EnemyHandBookData_AbiltyArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_EnemyHandBookData_AbiltyArgs {
            text: None,
            textFormat: enum__Torappu_EnemyHandBookData_TextFormat::NORMAL,
        }
    }
}

impl Serialize for clz_Torappu_EnemyHandBookData_Abilty<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_EnemyHandBookData_Abilty", 2)?;
        if let Some(f) = self.text() {
            s.serialize_field("text", &f)?;
        } else {
            s.skip_field("text")?;
        }
        s.serialize_field("textFormat", &self.textFormat())?;
        s.end()
    }
}

pub struct clz_Torappu_EnemyHandBookData_AbiltyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_EnemyHandBookData_AbiltyBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandBookData_Abilty::VT_TEXT,
            text,
        );
    }
    #[inline]
    pub fn add_textFormat(&mut self, textFormat: enum__Torappu_EnemyHandBookData_TextFormat) {
        self.fbb_
            .push_slot::<enum__Torappu_EnemyHandBookData_TextFormat>(
                clz_Torappu_EnemyHandBookData_Abilty::VT_TEXTFORMAT,
                textFormat,
                enum__Torappu_EnemyHandBookData_TextFormat::NORMAL,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_EnemyHandBookData_AbiltyBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_EnemyHandBookData_AbiltyBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandBookData_Abilty<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_EnemyHandBookData_Abilty<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_EnemyHandBookData_Abilty");
        ds.field("text", &self.text());
        ds.field("textFormat", &self.textFormat());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_EnemyHandBookData_AbiltyT {
    pub text: Option<String>,
    pub textFormat: enum__Torappu_EnemyHandBookData_TextFormat,
}
impl Default for clz_Torappu_EnemyHandBookData_AbiltyT {
    fn default() -> Self {
        Self {
            text: None,
            textFormat: enum__Torappu_EnemyHandBookData_TextFormat::NORMAL,
        }
    }
}
impl clz_Torappu_EnemyHandBookData_AbiltyT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandBookData_Abilty<'b>> {
        let text = self.text.as_ref().map(|x| _fbb.create_string(x));
        let textFormat = self.textFormat;
        clz_Torappu_EnemyHandBookData_Abilty::create(
            _fbb,
            &clz_Torappu_EnemyHandBookData_AbiltyArgs { text, textFormat },
        )
    }
}
pub enum clz_Torappu_EnemyHandBookDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_EnemyHandBookData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_EnemyHandBookData<'a> {
    type Inner = clz_Torappu_EnemyHandBookData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_EnemyHandBookData<'a> {
    pub const VT_ENEMYID: flatbuffers::VOffsetT = 4;
    pub const VT_ENEMYINDEX: flatbuffers::VOffsetT = 6;
    pub const VT_ENEMYTAGS: flatbuffers::VOffsetT = 8;
    pub const VT_SORTID: flatbuffers::VOffsetT = 10;
    pub const VT_NAME: flatbuffers::VOffsetT = 12;
    pub const VT_ENEMYLEVEL: flatbuffers::VOffsetT = 14;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 16;
    pub const VT_ATTACKTYPE: flatbuffers::VOffsetT = 18;
    pub const VT_ABILITY: flatbuffers::VOffsetT = 20;
    pub const VT_ISINVALIDKILLED: flatbuffers::VOffsetT = 22;
    pub const VT_OVERRIDEKILLCNTINFOS: flatbuffers::VOffsetT = 24;
    pub const VT_HIDEINHANDBOOK: flatbuffers::VOffsetT = 26;
    pub const VT_HIDEINSTAGE: flatbuffers::VOffsetT = 28;
    pub const VT_ABILITYLIST: flatbuffers::VOffsetT = 30;
    pub const VT_LINKENEMIES: flatbuffers::VOffsetT = 32;
    pub const VT_DAMAGETYPE: flatbuffers::VOffsetT = 34;
    pub const VT_INVISIBLEDETAIL: flatbuffers::VOffsetT = 36;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_EnemyHandBookData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_EnemyHandBookDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandBookData<'bldr>> {
        let mut builder = clz_Torappu_EnemyHandBookDataBuilder::new(_fbb);
        if let Some(x) = args.damageType {
            builder.add_damageType(x);
        }
        if let Some(x) = args.linkEnemies {
            builder.add_linkEnemies(x);
        }
        if let Some(x) = args.abilityList {
            builder.add_abilityList(x);
        }
        if let Some(x) = args.overrideKillCntInfos {
            builder.add_overrideKillCntInfos(x);
        }
        if let Some(x) = args.ability {
            builder.add_ability(x);
        }
        if let Some(x) = args.attackType {
            builder.add_attackType(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        builder.add_enemyLevel(args.enemyLevel);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.enemyTags {
            builder.add_enemyTags(x);
        }
        if let Some(x) = args.enemyIndex {
            builder.add_enemyIndex(x);
        }
        if let Some(x) = args.enemyId {
            builder.add_enemyId(x);
        }
        builder.add_invisibleDetail(args.invisibleDetail);
        builder.add_hideInStage(args.hideInStage);
        builder.add_hideInHandbook(args.hideInHandbook);
        builder.add_isInvalidKilled(args.isInvalidKilled);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_EnemyHandBookDataT {
        let enemyId = self.enemyId().map(|x| x.to_string());
        let enemyIndex = self.enemyIndex().map(|x| x.to_string());
        let enemyTags = self
            .enemyTags()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let sortId = self.sortId();
        let name = self.name().map(|x| x.to_string());
        let enemyLevel = self.enemyLevel();
        let description = self.description().map(|x| x.to_string());
        let attackType = self.attackType().map(|x| x.to_string());
        let ability = self.ability().map(|x| x.to_string());
        let isInvalidKilled = self.isInvalidKilled();
        let overrideKillCntInfos = self
            .overrideKillCntInfos()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let hideInHandbook = self.hideInHandbook();
        let hideInStage = self.hideInStage();
        let abilityList = self
            .abilityList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let linkEnemies = self
            .linkEnemies()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let damageType = self.damageType().map(|x| x.into_iter().collect());
        let invisibleDetail = self.invisibleDetail();
        clz_Torappu_EnemyHandBookDataT {
            enemyId,
            enemyIndex,
            enemyTags,
            sortId,
            name,
            enemyLevel,
            description,
            attackType,
            ability,
            isInvalidKilled,
            overrideKillCntInfos,
            hideInHandbook,
            hideInStage,
            abilityList,
            linkEnemies,
            damageType,
            invisibleDetail,
        }
    }

    #[inline]
    pub fn enemyId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EnemyHandBookData::VT_ENEMYID,
                None,
            )
        }
    }
    #[inline]
    pub fn enemyIndex(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EnemyHandBookData::VT_ENEMYINDEX,
                None,
            )
        }
    }
    #[inline]
    pub fn enemyTags(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_EnemyHandBookData::VT_ENEMYTAGS, None)
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_EnemyHandBookData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EnemyHandBookData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn enemyLevel(&self) -> enum__Torappu_EnemyLevelType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EnemyLevelType>(
                    clz_Torappu_EnemyHandBookData::VT_ENEMYLEVEL,
                    Some(enum__Torappu_EnemyLevelType::NORMAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EnemyHandBookData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn attackType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EnemyHandBookData::VT_ATTACKTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn ability(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EnemyHandBookData::VT_ABILITY,
                None,
            )
        }
    }
    #[inline]
    pub fn isInvalidKilled(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_EnemyHandBookData::VT_ISINVALIDKILLED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn overrideKillCntInfos(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_EnemyHandBookData::VT_OVERRIDEKILLCNTINFOS, None)
        }
    }
    #[inline]
    pub fn hideInHandbook(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_EnemyHandBookData::VT_HIDEINHANDBOOK,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn hideInStage(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_EnemyHandBookData::VT_HIDEINSTAGE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn abilityList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandBookData_Abilty<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandBookData_Abilty>,
                >,
            >>(clz_Torappu_EnemyHandBookData::VT_ABILITYLIST, None)
        }
    }
    #[inline]
    pub fn linkEnemies(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_EnemyHandBookData::VT_LINKENEMIES, None)
        }
    }
    #[inline]
    pub fn damageType(
        &self,
    ) -> Option<flatbuffers::Vector<'a, enum__Torappu_EnemyHandBookDamageType>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, enum__Torappu_EnemyHandBookDamageType>,
            >>(clz_Torappu_EnemyHandBookData::VT_DAMAGETYPE, None)
        }
    }
    #[inline]
    pub fn invisibleDetail(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_EnemyHandBookData::VT_INVISIBLEDETAIL,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_EnemyHandBookData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("enemyId", Self::VT_ENEMYID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "enemyIndex",
                Self::VT_ENEMYINDEX,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyTags", Self::VT_ENEMYTAGS, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<enum__Torappu_EnemyLevelType>("enemyLevel", Self::VT_ENEMYLEVEL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "attackType",
                Self::VT_ATTACKTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ability", Self::VT_ABILITY, false)?
            .visit_field::<bool>("isInvalidKilled", Self::VT_ISINVALIDKILLED, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>("overrideKillCntInfos", Self::VT_OVERRIDEKILLCNTINFOS, false)?
            .visit_field::<bool>("hideInHandbook", Self::VT_HIDEINHANDBOOK, false)?
            .visit_field::<bool>("hideInStage", Self::VT_HIDEINSTAGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandBookData_Abilty>,
                >,
            >>("abilityList", Self::VT_ABILITYLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("linkEnemies", Self::VT_LINKENEMIES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, enum__Torappu_EnemyHandBookDamageType>,
            >>("damageType", Self::VT_DAMAGETYPE, false)?
            .visit_field::<bool>("invisibleDetail", Self::VT_INVISIBLEDETAIL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_EnemyHandBookDataArgs<'a> {
    pub enemyId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enemyIndex: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enemyTags: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub sortId: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enemyLevel: enum__Torappu_EnemyLevelType,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub attackType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ability: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isInvalidKilled: bool,
    pub overrideKillCntInfos: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>,
        >,
    >,
    pub hideInHandbook: bool,
    pub hideInStage: bool,
    pub abilityList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandBookData_Abilty<'a>>,
            >,
        >,
    >,
    pub linkEnemies: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub damageType: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_EnemyHandBookDamageType>>,
    >,
    pub invisibleDetail: bool,
}
impl<'a> Default for clz_Torappu_EnemyHandBookDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_EnemyHandBookDataArgs {
            enemyId: None,
            enemyIndex: None,
            enemyTags: None,
            sortId: 0,
            name: None,
            enemyLevel: enum__Torappu_EnemyLevelType::NORMAL,
            description: None,
            attackType: None,
            ability: None,
            isInvalidKilled: false,
            overrideKillCntInfos: None,
            hideInHandbook: false,
            hideInStage: false,
            abilityList: None,
            linkEnemies: None,
            damageType: None,
            invisibleDetail: false,
        }
    }
}

impl Serialize for clz_Torappu_EnemyHandBookData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_EnemyHandBookData", 17)?;
        if let Some(f) = self.enemyId() {
            s.serialize_field("enemyId", &f)?;
        } else {
            s.skip_field("enemyId")?;
        }
        if let Some(f) = self.enemyIndex() {
            s.serialize_field("enemyIndex", &f)?;
        } else {
            s.skip_field("enemyIndex")?;
        }
        if let Some(f) = self.enemyTags() {
            s.serialize_field("enemyTags", &f)?;
        } else {
            s.skip_field("enemyTags")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        s.serialize_field("enemyLevel", &self.enemyLevel())?;
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.attackType() {
            s.serialize_field("attackType", &f)?;
        } else {
            s.skip_field("attackType")?;
        }
        if let Some(f) = self.ability() {
            s.serialize_field("ability", &f)?;
        } else {
            s.skip_field("ability")?;
        }
        s.serialize_field("isInvalidKilled", &self.isInvalidKilled())?;
        if let Some(f) = self.overrideKillCntInfos() {
            s.serialize_field("overrideKillCntInfos", &f)?;
        } else {
            s.skip_field("overrideKillCntInfos")?;
        }
        s.serialize_field("hideInHandbook", &self.hideInHandbook())?;
        s.serialize_field("hideInStage", &self.hideInStage())?;
        if let Some(f) = self.abilityList() {
            s.serialize_field("abilityList", &f)?;
        } else {
            s.skip_field("abilityList")?;
        }
        if let Some(f) = self.linkEnemies() {
            s.serialize_field("linkEnemies", &f)?;
        } else {
            s.skip_field("linkEnemies")?;
        }
        if let Some(f) = self.damageType() {
            s.serialize_field("damageType", &f)?;
        } else {
            s.skip_field("damageType")?;
        }
        s.serialize_field("invisibleDetail", &self.invisibleDetail())?;
        s.end()
    }
}

pub struct clz_Torappu_EnemyHandBookDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_EnemyHandBookDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_enemyId(&mut self, enemyId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandBookData::VT_ENEMYID,
            enemyId,
        );
    }
    #[inline]
    pub fn add_enemyIndex(&mut self, enemyIndex: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandBookData::VT_ENEMYINDEX,
            enemyIndex,
        );
    }
    #[inline]
    pub fn add_enemyTags(
        &mut self,
        enemyTags: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandBookData::VT_ENEMYTAGS,
            enemyTags,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_EnemyHandBookData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandBookData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_enemyLevel(&mut self, enemyLevel: enum__Torappu_EnemyLevelType) {
        self.fbb_.push_slot::<enum__Torappu_EnemyLevelType>(
            clz_Torappu_EnemyHandBookData::VT_ENEMYLEVEL,
            enemyLevel,
            enum__Torappu_EnemyLevelType::NORMAL,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandBookData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_attackType(&mut self, attackType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandBookData::VT_ATTACKTYPE,
            attackType,
        );
    }
    #[inline]
    pub fn add_ability(&mut self, ability: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandBookData::VT_ABILITY,
            ability,
        );
    }
    #[inline]
    pub fn add_isInvalidKilled(&mut self, isInvalidKilled: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_EnemyHandBookData::VT_ISINVALIDKILLED,
            isInvalidKilled,
            false,
        );
    }
    #[inline]
    pub fn add_overrideKillCntInfos(
        &mut self,
        overrideKillCntInfos: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandBookData::VT_OVERRIDEKILLCNTINFOS,
            overrideKillCntInfos,
        );
    }
    #[inline]
    pub fn add_hideInHandbook(&mut self, hideInHandbook: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_EnemyHandBookData::VT_HIDEINHANDBOOK,
            hideInHandbook,
            false,
        );
    }
    #[inline]
    pub fn add_hideInStage(&mut self, hideInStage: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_EnemyHandBookData::VT_HIDEINSTAGE,
            hideInStage,
            false,
        );
    }
    #[inline]
    pub fn add_abilityList(
        &mut self,
        abilityList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandBookData_Abilty<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandBookData::VT_ABILITYLIST,
            abilityList,
        );
    }
    #[inline]
    pub fn add_linkEnemies(
        &mut self,
        linkEnemies: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandBookData::VT_LINKENEMIES,
            linkEnemies,
        );
    }
    #[inline]
    pub fn add_damageType(
        &mut self,
        damageType: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, enum__Torappu_EnemyHandBookDamageType>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandBookData::VT_DAMAGETYPE,
            damageType,
        );
    }
    #[inline]
    pub fn add_invisibleDetail(&mut self, invisibleDetail: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_EnemyHandBookData::VT_INVISIBLEDETAIL,
            invisibleDetail,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_EnemyHandBookDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_EnemyHandBookDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandBookData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_EnemyHandBookData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_EnemyHandBookData");
        ds.field("enemyId", &self.enemyId());
        ds.field("enemyIndex", &self.enemyIndex());
        ds.field("enemyTags", &self.enemyTags());
        ds.field("sortId", &self.sortId());
        ds.field("name", &self.name());
        ds.field("enemyLevel", &self.enemyLevel());
        ds.field("description", &self.description());
        ds.field("attackType", &self.attackType());
        ds.field("ability", &self.ability());
        ds.field("isInvalidKilled", &self.isInvalidKilled());
        ds.field("overrideKillCntInfos", &self.overrideKillCntInfos());
        ds.field("hideInHandbook", &self.hideInHandbook());
        ds.field("hideInStage", &self.hideInStage());
        ds.field("abilityList", &self.abilityList());
        ds.field("linkEnemies", &self.linkEnemies());
        ds.field("damageType", &self.damageType());
        ds.field("invisibleDetail", &self.invisibleDetail());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_EnemyHandBookDataT {
    pub enemyId: Option<String>,
    pub enemyIndex: Option<String>,
    pub enemyTags: Option<Vec<String>>,
    pub sortId: i32,
    pub name: Option<String>,
    pub enemyLevel: enum__Torappu_EnemyLevelType,
    pub description: Option<String>,
    pub attackType: Option<String>,
    pub ability: Option<String>,
    pub isInvalidKilled: bool,
    pub overrideKillCntInfos: Option<Vec<dict__string__intT>>,
    pub hideInHandbook: bool,
    pub hideInStage: bool,
    pub abilityList: Option<Vec<clz_Torappu_EnemyHandBookData_AbiltyT>>,
    pub linkEnemies: Option<Vec<String>>,
    pub damageType: Option<Vec<enum__Torappu_EnemyHandBookDamageType>>,
    pub invisibleDetail: bool,
}
impl Default for clz_Torappu_EnemyHandBookDataT {
    fn default() -> Self {
        Self {
            enemyId: None,
            enemyIndex: None,
            enemyTags: None,
            sortId: 0,
            name: None,
            enemyLevel: enum__Torappu_EnemyLevelType::NORMAL,
            description: None,
            attackType: None,
            ability: None,
            isInvalidKilled: false,
            overrideKillCntInfos: None,
            hideInHandbook: false,
            hideInStage: false,
            abilityList: None,
            linkEnemies: None,
            damageType: None,
            invisibleDetail: false,
        }
    }
}
impl clz_Torappu_EnemyHandBookDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandBookData<'b>> {
        let enemyId = self.enemyId.as_ref().map(|x| _fbb.create_string(x));
        let enemyIndex = self.enemyIndex.as_ref().map(|x| _fbb.create_string(x));
        let enemyTags = self.enemyTags.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let sortId = self.sortId;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let enemyLevel = self.enemyLevel;
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let attackType = self.attackType.as_ref().map(|x| _fbb.create_string(x));
        let ability = self.ability.as_ref().map(|x| _fbb.create_string(x));
        let isInvalidKilled = self.isInvalidKilled;
        let overrideKillCntInfos = self.overrideKillCntInfos.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let hideInHandbook = self.hideInHandbook;
        let hideInStage = self.hideInStage;
        let abilityList = self.abilityList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let linkEnemies = self.linkEnemies.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let damageType = self.damageType.as_ref().map(|x| _fbb.create_vector(x));
        let invisibleDetail = self.invisibleDetail;
        clz_Torappu_EnemyHandBookData::create(
            _fbb,
            &clz_Torappu_EnemyHandBookDataArgs {
                enemyId,
                enemyIndex,
                enemyTags,
                sortId,
                name,
                enemyLevel,
                description,
                attackType,
                ability,
                isInvalidKilled,
                overrideKillCntInfos,
                hideInHandbook,
                hideInStage,
                abilityList,
                linkEnemies,
                damageType,
                invisibleDetail,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_EnemyHandBookDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_EnemyHandBookData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_EnemyHandBookData<'a> {
    type Inner = dict__string__clz_Torappu_EnemyHandBookData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_EnemyHandBookData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_EnemyHandBookData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_EnemyHandBookDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_EnemyHandBookData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_EnemyHandBookDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_EnemyHandBookDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_EnemyHandBookDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_EnemyHandBookData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_EnemyHandBookData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_EnemyHandBookData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandBookData>>(
                    dict__string__clz_Torappu_EnemyHandBookData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_EnemyHandBookData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandBookData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_EnemyHandBookDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_EnemyHandBookData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_EnemyHandBookDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_EnemyHandBookDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_EnemyHandBookData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_EnemyHandBookData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_EnemyHandBookDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_EnemyHandBookDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_EnemyHandBookData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_EnemyHandBookData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EnemyHandBookData>>(
                dict__string__clz_Torappu_EnemyHandBookData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_EnemyHandBookDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_EnemyHandBookDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_EnemyHandBookData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_EnemyHandBookData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_EnemyHandBookData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_EnemyHandBookData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_EnemyHandBookDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_EnemyHandBookDataT>>,
}
impl Default for dict__string__clz_Torappu_EnemyHandBookDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_EnemyHandBookDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_EnemyHandBookData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_EnemyHandBookData::create(
            _fbb,
            &dict__string__clz_Torappu_EnemyHandBookDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_EnemyHandbookRaceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_EnemyHandbookRaceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_EnemyHandbookRaceData<'a> {
    type Inner = clz_Torappu_EnemyHandbookRaceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_EnemyHandbookRaceData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_RACENAME: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_EnemyHandbookRaceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_EnemyHandbookRaceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookRaceData<'bldr>> {
        let mut builder = clz_Torappu_EnemyHandbookRaceDataBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.raceName {
            builder.add_raceName(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_EnemyHandbookRaceDataT {
        let id = self.id().map(|x| x.to_string());
        let raceName = self.raceName().map(|x| x.to_string());
        let sortId = self.sortId();
        clz_Torappu_EnemyHandbookRaceDataT {
            id,
            raceName,
            sortId,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EnemyHandbookRaceData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn raceName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_EnemyHandbookRaceData::VT_RACENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_EnemyHandbookRaceData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_EnemyHandbookRaceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "raceName",
                Self::VT_RACENAME,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_EnemyHandbookRaceDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub raceName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_EnemyHandbookRaceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_EnemyHandbookRaceDataArgs {
            id: None,
            raceName: None,
            sortId: 0,
        }
    }
}

impl Serialize for clz_Torappu_EnemyHandbookRaceData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_EnemyHandbookRaceData", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        if let Some(f) = self.raceName() {
            s.serialize_field("raceName", &f)?;
        } else {
            s.skip_field("raceName")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        s.end()
    }
}

pub struct clz_Torappu_EnemyHandbookRaceDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_EnemyHandbookRaceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandbookRaceData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_raceName(&mut self, raceName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandbookRaceData::VT_RACENAME,
            raceName,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_EnemyHandbookRaceData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_EnemyHandbookRaceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_EnemyHandbookRaceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookRaceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_EnemyHandbookRaceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_EnemyHandbookRaceData");
        ds.field("id", &self.id());
        ds.field("raceName", &self.raceName());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_EnemyHandbookRaceDataT {
    pub id: Option<String>,
    pub raceName: Option<String>,
    pub sortId: i32,
}
impl Default for clz_Torappu_EnemyHandbookRaceDataT {
    fn default() -> Self {
        Self {
            id: None,
            raceName: None,
            sortId: 0,
        }
    }
}
impl clz_Torappu_EnemyHandbookRaceDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookRaceData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let raceName = self.raceName.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        clz_Torappu_EnemyHandbookRaceData::create(
            _fbb,
            &clz_Torappu_EnemyHandbookRaceDataArgs {
                id,
                raceName,
                sortId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_EnemyHandbookRaceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_EnemyHandbookRaceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_EnemyHandbookRaceData<'a> {
    type Inner = dict__string__clz_Torappu_EnemyHandbookRaceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_EnemyHandbookRaceData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_EnemyHandbookRaceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_EnemyHandbookRaceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_EnemyHandbookRaceData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_EnemyHandbookRaceDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_EnemyHandbookRaceDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_EnemyHandbookRaceDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_EnemyHandbookRaceData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_EnemyHandbookRaceData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_EnemyHandbookRaceData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookRaceData>>(
                    dict__string__clz_Torappu_EnemyHandbookRaceData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_EnemyHandbookRaceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookRaceData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_EnemyHandbookRaceDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookRaceData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_EnemyHandbookRaceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_EnemyHandbookRaceDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_EnemyHandbookRaceData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_EnemyHandbookRaceData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_EnemyHandbookRaceDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_EnemyHandbookRaceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_EnemyHandbookRaceData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookRaceData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_EnemyHandbookRaceData>>(
                dict__string__clz_Torappu_EnemyHandbookRaceData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_EnemyHandbookRaceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_EnemyHandbookRaceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_EnemyHandbookRaceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_EnemyHandbookRaceData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_EnemyHandbookRaceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_EnemyHandbookRaceData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_EnemyHandbookRaceDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_EnemyHandbookRaceDataT>>,
}
impl Default for dict__string__clz_Torappu_EnemyHandbookRaceDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_EnemyHandbookRaceDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_EnemyHandbookRaceData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_EnemyHandbookRaceData::create(
            _fbb,
            &dict__string__clz_Torappu_EnemyHandbookRaceDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_EnemyHandBookDataGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_EnemyHandBookDataGroup<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_EnemyHandBookDataGroup<'a> {
    type Inner = clz_Torappu_EnemyHandBookDataGroup<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_EnemyHandBookDataGroup<'a> {
    pub const VT_LEVELINFOLIST: flatbuffers::VOffsetT = 4;
    pub const VT_ENEMYDATA: flatbuffers::VOffsetT = 6;
    pub const VT_RACEDATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_EnemyHandBookDataGroup { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_EnemyHandBookDataGroupArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandBookDataGroup<'bldr>> {
        let mut builder = clz_Torappu_EnemyHandBookDataGroupBuilder::new(_fbb);
        if let Some(x) = args.raceData {
            builder.add_raceData(x);
        }
        if let Some(x) = args.enemyData {
            builder.add_enemyData(x);
        }
        if let Some(x) = args.levelInfoList {
            builder.add_levelInfoList(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_EnemyHandBookDataGroupT {
        let levelInfoList = self
            .levelInfoList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let enemyData = self
            .enemyData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let raceData = self
            .raceData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_EnemyHandBookDataGroupT {
            levelInfoList,
            enemyData,
            raceData,
        }
    }

    #[inline]
    pub fn levelInfoList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData>,
                >,
            >>(clz_Torappu_EnemyHandBookDataGroup::VT_LEVELINFOLIST, None)
        }
    }
    #[inline]
    pub fn enemyData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_EnemyHandBookData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_EnemyHandBookData>,
                >,
            >>(clz_Torappu_EnemyHandBookDataGroup::VT_ENEMYDATA, None)
        }
    }
    #[inline]
    pub fn raceData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_EnemyHandbookRaceData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_EnemyHandbookRaceData>,
                >,
            >>(clz_Torappu_EnemyHandBookDataGroup::VT_RACEDATA, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_EnemyHandBookDataGroup<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData>,
                >,
            >>("levelInfoList", Self::VT_LEVELINFOLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_EnemyHandBookData>,
                >,
            >>("enemyData", Self::VT_ENEMYDATA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_EnemyHandbookRaceData>,
                >,
            >>("raceData", Self::VT_RACEDATA, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_EnemyHandBookDataGroupArgs<'a> {
    pub levelInfoList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData<'a>>,
            >,
        >,
    >,
    pub enemyData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_EnemyHandBookData<'a>>,
            >,
        >,
    >,
    pub raceData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_EnemyHandbookRaceData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_EnemyHandBookDataGroupArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_EnemyHandBookDataGroupArgs {
            levelInfoList: None,
            enemyData: None,
            raceData: None,
        }
    }
}

impl Serialize for clz_Torappu_EnemyHandBookDataGroup<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_EnemyHandBookDataGroup", 3)?;
        if let Some(f) = self.levelInfoList() {
            s.serialize_field("levelInfoList", &f)?;
        } else {
            s.skip_field("levelInfoList")?;
        }
        if let Some(f) = self.enemyData() {
            s.serialize_field("enemyData", &f)?;
        } else {
            s.skip_field("enemyData")?;
        }
        if let Some(f) = self.raceData() {
            s.serialize_field("raceData", &f)?;
        } else {
            s.skip_field("raceData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_EnemyHandBookDataGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_EnemyHandBookDataGroupBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_levelInfoList(
        &mut self,
        levelInfoList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_EnemyHandbookLevelInfoData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandBookDataGroup::VT_LEVELINFOLIST,
            levelInfoList,
        );
    }
    #[inline]
    pub fn add_enemyData(
        &mut self,
        enemyData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_EnemyHandBookData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandBookDataGroup::VT_ENEMYDATA,
            enemyData,
        );
    }
    #[inline]
    pub fn add_raceData(
        &mut self,
        raceData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_EnemyHandbookRaceData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_EnemyHandBookDataGroup::VT_RACEDATA,
            raceData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_EnemyHandBookDataGroupBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_EnemyHandBookDataGroupBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandBookDataGroup<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_EnemyHandBookDataGroup<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_EnemyHandBookDataGroup");
        ds.field("levelInfoList", &self.levelInfoList());
        ds.field("enemyData", &self.enemyData());
        ds.field("raceData", &self.raceData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_EnemyHandBookDataGroupT {
    pub levelInfoList: Option<Vec<clz_Torappu_EnemyHandbookLevelInfoDataT>>,
    pub enemyData: Option<Vec<dict__string__clz_Torappu_EnemyHandBookDataT>>,
    pub raceData: Option<Vec<dict__string__clz_Torappu_EnemyHandbookRaceDataT>>,
}
impl Default for clz_Torappu_EnemyHandBookDataGroupT {
    fn default() -> Self {
        Self {
            levelInfoList: None,
            enemyData: None,
            raceData: None,
        }
    }
}
impl clz_Torappu_EnemyHandBookDataGroupT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_EnemyHandBookDataGroup<'b>> {
        let levelInfoList = self.levelInfoList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let enemyData = self.enemyData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let raceData = self.raceData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_EnemyHandBookDataGroup::create(
            _fbb,
            &clz_Torappu_EnemyHandBookDataGroupArgs {
                levelInfoList,
                enemyData,
                raceData,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_EnemyHandBookDataGroup`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_enemy_hand_book_data_group_unchecked`.
pub fn root_as_clz_torappu_enemy_hand_book_data_group(
    buf: &[u8],
) -> Result<clz_Torappu_EnemyHandBookDataGroup<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_EnemyHandBookDataGroup>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_EnemyHandBookDataGroup` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_enemy_hand_book_data_group_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_enemy_hand_book_data_group(
    buf: &[u8],
) -> Result<clz_Torappu_EnemyHandBookDataGroup<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_EnemyHandBookDataGroup>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_EnemyHandBookDataGroup` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_enemy_hand_book_data_group_unchecked`.
pub fn root_as_clz_torappu_enemy_hand_book_data_group_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_EnemyHandBookDataGroup<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_EnemyHandBookDataGroup<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_EnemyHandBookDataGroup` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_enemy_hand_book_data_group_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_enemy_hand_book_data_group_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_EnemyHandBookDataGroup<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_EnemyHandBookDataGroup<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_EnemyHandBookDataGroup and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_EnemyHandBookDataGroup`.
pub unsafe fn root_as_clz_torappu_enemy_hand_book_data_group_unchecked(
    buf: &[u8],
) -> clz_Torappu_EnemyHandBookDataGroup<'_> {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_EnemyHandBookDataGroup>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_EnemyHandBookDataGroup and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_EnemyHandBookDataGroup`.
pub unsafe fn size_prefixed_root_as_clz_torappu_enemy_hand_book_data_group_unchecked(
    buf: &[u8],
) -> clz_Torappu_EnemyHandBookDataGroup<'_> {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_EnemyHandBookDataGroup>(buf) }
}
#[inline]
pub fn finish_clz_torappu_enemy_hand_book_data_group_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_EnemyHandBookDataGroup<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_enemy_hand_book_data_group_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_EnemyHandBookDataGroup<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
