// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_TYPE: i32 = 90;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_TYPE: [enum__Torappu_ItemType; 91] = [
    enum__Torappu_ItemType::NONE,
    enum__Torappu_ItemType::CHAR,
    enum__Torappu_ItemType::CARD_EXP,
    enum__Torappu_ItemType::MATERIAL,
    enum__Torappu_ItemType::GOLD,
    enum__Torappu_ItemType::EXP_PLAYER,
    enum__Torappu_ItemType::TKT_TRY,
    enum__Torappu_ItemType::TKT_RECRUIT,
    enum__Torappu_ItemType::TKT_INST_FIN,
    enum__Torappu_ItemType::TKT_GACHA,
    enum__Torappu_ItemType::ACTIVITY_COIN,
    enum__Torappu_ItemType::DIAMOND,
    enum__Torappu_ItemType::DIAMOND_SHD,
    enum__Torappu_ItemType::HGG_SHD,
    enum__Torappu_ItemType::LGG_SHD,
    enum__Torappu_ItemType::FURN,
    enum__Torappu_ItemType::AP_GAMEPLAY,
    enum__Torappu_ItemType::AP_BASE,
    enum__Torappu_ItemType::SOCIAL_PT,
    enum__Torappu_ItemType::CHAR_SKIN,
    enum__Torappu_ItemType::TKT_GACHA_10,
    enum__Torappu_ItemType::TKT_GACHA_PRSV,
    enum__Torappu_ItemType::AP_ITEM,
    enum__Torappu_ItemType::AP_SUPPLY,
    enum__Torappu_ItemType::RENAMING_CARD,
    enum__Torappu_ItemType::RENAMING_CARD_2,
    enum__Torappu_ItemType::ET_STAGE,
    enum__Torappu_ItemType::ACTIVITY_ITEM,
    enum__Torappu_ItemType::VOUCHER_PICK,
    enum__Torappu_ItemType::VOUCHER_CGACHA,
    enum__Torappu_ItemType::VOUCHER_MGACHA,
    enum__Torappu_ItemType::CRS_SHOP_COIN,
    enum__Torappu_ItemType::CRS_RUNE_COIN,
    enum__Torappu_ItemType::LMTGS_COIN,
    enum__Torappu_ItemType::EPGS_COIN,
    enum__Torappu_ItemType::LIMITED_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_FREE_GACHA,
    enum__Torappu_ItemType::REP_COIN,
    enum__Torappu_ItemType::ROGUELIKE,
    enum__Torappu_ItemType::LINKAGE_TKT_GACHA_10,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_4,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_5,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_6,
    enum__Torappu_ItemType::VOUCHER_SKIN,
    enum__Torappu_ItemType::RETRO_COIN,
    enum__Torappu_ItemType::PLAYER_AVATAR,
    enum__Torappu_ItemType::UNI_COLLECTION,
    enum__Torappu_ItemType::VOUCHER_FULL_POTENTIAL,
    enum__Torappu_ItemType::RL_COIN,
    enum__Torappu_ItemType::RETURN_CREDIT,
    enum__Torappu_ItemType::MEDAL,
    enum__Torappu_ItemType::CHARM,
    enum__Torappu_ItemType::HOME_BACKGROUND,
    enum__Torappu_ItemType::EXTERMINATION_AGENT,
    enum__Torappu_ItemType::OPTIONAL_VOUCHER_PICK,
    enum__Torappu_ItemType::ACT_CART_COMPONENT,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_4,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_4,
    enum__Torappu_ItemType::ACTIVITY_POTENTIAL,
    enum__Torappu_ItemType::ITEM_PACK,
    enum__Torappu_ItemType::SANDBOX,
    enum__Torappu_ItemType::FAVOR_ADD_ITEM,
    enum__Torappu_ItemType::CLASSIC_SHD,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_BUFF,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_5,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_6,
    enum__Torappu_ItemType::RETURN_PROGRESS,
    enum__Torappu_ItemType::NEW_PROGRESS,
    enum__Torappu_ItemType::MCARD_VOUCHER,
    enum__Torappu_ItemType::MATERIAL_ISSUE_VOUCHER,
    enum__Torappu_ItemType::CRS_SHOP_COIN_V2,
    enum__Torappu_ItemType::HOME_THEME,
    enum__Torappu_ItemType::SANDBOX_PERM,
    enum__Torappu_ItemType::SANDBOX_TOKEN,
    enum__Torappu_ItemType::TEMPLATE_TRAP,
    enum__Torappu_ItemType::NAME_CARD_SKIN,
    enum__Torappu_ItemType::EMOTICON_SET,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA_10,
    enum__Torappu_ItemType::SO_CHAR_EXP,
    enum__Torappu_ItemType::GIFTPACKAGE_TKT,
    enum__Torappu_ItemType::VOUCHER_SKIN_V2,
    enum__Torappu_ItemType::RANDOM_VOUCHER_SKIN,
    enum__Torappu_ItemType::ACT1VHALFIDLE_ITEM,
    enum__Torappu_ItemType::PLOT_ITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemType {
    pub const NONE: Self = Self(0);
    pub const CHAR: Self = Self(1);
    pub const CARD_EXP: Self = Self(2);
    pub const MATERIAL: Self = Self(3);
    pub const GOLD: Self = Self(4);
    pub const EXP_PLAYER: Self = Self(5);
    pub const TKT_TRY: Self = Self(6);
    pub const TKT_RECRUIT: Self = Self(7);
    pub const TKT_INST_FIN: Self = Self(8);
    pub const TKT_GACHA: Self = Self(9);
    pub const ACTIVITY_COIN: Self = Self(10);
    pub const DIAMOND: Self = Self(11);
    pub const DIAMOND_SHD: Self = Self(12);
    pub const HGG_SHD: Self = Self(13);
    pub const LGG_SHD: Self = Self(14);
    pub const FURN: Self = Self(15);
    pub const AP_GAMEPLAY: Self = Self(16);
    pub const AP_BASE: Self = Self(17);
    pub const SOCIAL_PT: Self = Self(18);
    pub const CHAR_SKIN: Self = Self(19);
    pub const TKT_GACHA_10: Self = Self(20);
    pub const TKT_GACHA_PRSV: Self = Self(21);
    pub const AP_ITEM: Self = Self(22);
    pub const AP_SUPPLY: Self = Self(23);
    pub const RENAMING_CARD: Self = Self(24);
    pub const RENAMING_CARD_2: Self = Self(25);
    pub const ET_STAGE: Self = Self(26);
    pub const ACTIVITY_ITEM: Self = Self(27);
    pub const VOUCHER_PICK: Self = Self(28);
    pub const VOUCHER_CGACHA: Self = Self(29);
    pub const VOUCHER_MGACHA: Self = Self(30);
    pub const CRS_SHOP_COIN: Self = Self(31);
    pub const CRS_RUNE_COIN: Self = Self(32);
    pub const LMTGS_COIN: Self = Self(33);
    pub const EPGS_COIN: Self = Self(34);
    pub const LIMITED_TKT_GACHA_10: Self = Self(35);
    pub const LIMITED_FREE_GACHA: Self = Self(36);
    pub const REP_COIN: Self = Self(37);
    pub const ROGUELIKE: Self = Self(38);
    pub const LINKAGE_TKT_GACHA_10: Self = Self(39);
    pub const VOUCHER_ELITE_II_4: Self = Self(40);
    pub const VOUCHER_ELITE_II_5: Self = Self(41);
    pub const VOUCHER_ELITE_II_6: Self = Self(42);
    pub const VOUCHER_SKIN: Self = Self(43);
    pub const RETRO_COIN: Self = Self(44);
    pub const PLAYER_AVATAR: Self = Self(45);
    pub const UNI_COLLECTION: Self = Self(46);
    pub const VOUCHER_FULL_POTENTIAL: Self = Self(47);
    pub const RL_COIN: Self = Self(48);
    pub const RETURN_CREDIT: Self = Self(49);
    pub const MEDAL: Self = Self(50);
    pub const CHARM: Self = Self(51);
    pub const HOME_BACKGROUND: Self = Self(52);
    pub const EXTERMINATION_AGENT: Self = Self(53);
    pub const OPTIONAL_VOUCHER_PICK: Self = Self(54);
    pub const ACT_CART_COMPONENT: Self = Self(55);
    pub const VOUCHER_LEVELMAX_6: Self = Self(56);
    pub const VOUCHER_LEVELMAX_5: Self = Self(57);
    pub const VOUCHER_LEVELMAX_4: Self = Self(58);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_6: Self = Self(59);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_5: Self = Self(60);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_4: Self = Self(61);
    pub const ACTIVITY_POTENTIAL: Self = Self(62);
    pub const ITEM_PACK: Self = Self(63);
    pub const SANDBOX: Self = Self(64);
    pub const FAVOR_ADD_ITEM: Self = Self(65);
    pub const CLASSIC_SHD: Self = Self(66);
    pub const CLASSIC_TKT_GACHA: Self = Self(67);
    pub const CLASSIC_TKT_GACHA_10: Self = Self(68);
    pub const LIMITED_BUFF: Self = Self(69);
    pub const CLASSIC_FES_PICK_TIER_5: Self = Self(70);
    pub const CLASSIC_FES_PICK_TIER_6: Self = Self(71);
    pub const RETURN_PROGRESS: Self = Self(72);
    pub const NEW_PROGRESS: Self = Self(73);
    pub const MCARD_VOUCHER: Self = Self(74);
    pub const MATERIAL_ISSUE_VOUCHER: Self = Self(75);
    pub const CRS_SHOP_COIN_V2: Self = Self(76);
    pub const HOME_THEME: Self = Self(77);
    pub const SANDBOX_PERM: Self = Self(78);
    pub const SANDBOX_TOKEN: Self = Self(79);
    pub const TEMPLATE_TRAP: Self = Self(80);
    pub const NAME_CARD_SKIN: Self = Self(81);
    pub const EMOTICON_SET: Self = Self(82);
    pub const EXCLUSIVE_TKT_GACHA: Self = Self(83);
    pub const EXCLUSIVE_TKT_GACHA_10: Self = Self(84);
    pub const SO_CHAR_EXP: Self = Self(85);
    pub const GIFTPACKAGE_TKT: Self = Self(86);
    pub const VOUCHER_SKIN_V2: Self = Self(87);
    pub const RANDOM_VOUCHER_SKIN: Self = Self(88);
    pub const ACT1VHALFIDLE_ITEM: Self = Self(89);
    pub const PLOT_ITEM: Self = Self(90);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 90;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CHAR,
        Self::CARD_EXP,
        Self::MATERIAL,
        Self::GOLD,
        Self::EXP_PLAYER,
        Self::TKT_TRY,
        Self::TKT_RECRUIT,
        Self::TKT_INST_FIN,
        Self::TKT_GACHA,
        Self::ACTIVITY_COIN,
        Self::DIAMOND,
        Self::DIAMOND_SHD,
        Self::HGG_SHD,
        Self::LGG_SHD,
        Self::FURN,
        Self::AP_GAMEPLAY,
        Self::AP_BASE,
        Self::SOCIAL_PT,
        Self::CHAR_SKIN,
        Self::TKT_GACHA_10,
        Self::TKT_GACHA_PRSV,
        Self::AP_ITEM,
        Self::AP_SUPPLY,
        Self::RENAMING_CARD,
        Self::RENAMING_CARD_2,
        Self::ET_STAGE,
        Self::ACTIVITY_ITEM,
        Self::VOUCHER_PICK,
        Self::VOUCHER_CGACHA,
        Self::VOUCHER_MGACHA,
        Self::CRS_SHOP_COIN,
        Self::CRS_RUNE_COIN,
        Self::LMTGS_COIN,
        Self::EPGS_COIN,
        Self::LIMITED_TKT_GACHA_10,
        Self::LIMITED_FREE_GACHA,
        Self::REP_COIN,
        Self::ROGUELIKE,
        Self::LINKAGE_TKT_GACHA_10,
        Self::VOUCHER_ELITE_II_4,
        Self::VOUCHER_ELITE_II_5,
        Self::VOUCHER_ELITE_II_6,
        Self::VOUCHER_SKIN,
        Self::RETRO_COIN,
        Self::PLAYER_AVATAR,
        Self::UNI_COLLECTION,
        Self::VOUCHER_FULL_POTENTIAL,
        Self::RL_COIN,
        Self::RETURN_CREDIT,
        Self::MEDAL,
        Self::CHARM,
        Self::HOME_BACKGROUND,
        Self::EXTERMINATION_AGENT,
        Self::OPTIONAL_VOUCHER_PICK,
        Self::ACT_CART_COMPONENT,
        Self::VOUCHER_LEVELMAX_6,
        Self::VOUCHER_LEVELMAX_5,
        Self::VOUCHER_LEVELMAX_4,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_6,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_5,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_4,
        Self::ACTIVITY_POTENTIAL,
        Self::ITEM_PACK,
        Self::SANDBOX,
        Self::FAVOR_ADD_ITEM,
        Self::CLASSIC_SHD,
        Self::CLASSIC_TKT_GACHA,
        Self::CLASSIC_TKT_GACHA_10,
        Self::LIMITED_BUFF,
        Self::CLASSIC_FES_PICK_TIER_5,
        Self::CLASSIC_FES_PICK_TIER_6,
        Self::RETURN_PROGRESS,
        Self::NEW_PROGRESS,
        Self::MCARD_VOUCHER,
        Self::MATERIAL_ISSUE_VOUCHER,
        Self::CRS_SHOP_COIN_V2,
        Self::HOME_THEME,
        Self::SANDBOX_PERM,
        Self::SANDBOX_TOKEN,
        Self::TEMPLATE_TRAP,
        Self::NAME_CARD_SKIN,
        Self::EMOTICON_SET,
        Self::EXCLUSIVE_TKT_GACHA,
        Self::EXCLUSIVE_TKT_GACHA_10,
        Self::SO_CHAR_EXP,
        Self::GIFTPACKAGE_TKT,
        Self::VOUCHER_SKIN_V2,
        Self::RANDOM_VOUCHER_SKIN,
        Self::ACT1VHALFIDLE_ITEM,
        Self::PLOT_ITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CHAR => Some("CHAR"),
            Self::CARD_EXP => Some("CARD_EXP"),
            Self::MATERIAL => Some("MATERIAL"),
            Self::GOLD => Some("GOLD"),
            Self::EXP_PLAYER => Some("EXP_PLAYER"),
            Self::TKT_TRY => Some("TKT_TRY"),
            Self::TKT_RECRUIT => Some("TKT_RECRUIT"),
            Self::TKT_INST_FIN => Some("TKT_INST_FIN"),
            Self::TKT_GACHA => Some("TKT_GACHA"),
            Self::ACTIVITY_COIN => Some("ACTIVITY_COIN"),
            Self::DIAMOND => Some("DIAMOND"),
            Self::DIAMOND_SHD => Some("DIAMOND_SHD"),
            Self::HGG_SHD => Some("HGG_SHD"),
            Self::LGG_SHD => Some("LGG_SHD"),
            Self::FURN => Some("FURN"),
            Self::AP_GAMEPLAY => Some("AP_GAMEPLAY"),
            Self::AP_BASE => Some("AP_BASE"),
            Self::SOCIAL_PT => Some("SOCIAL_PT"),
            Self::CHAR_SKIN => Some("CHAR_SKIN"),
            Self::TKT_GACHA_10 => Some("TKT_GACHA_10"),
            Self::TKT_GACHA_PRSV => Some("TKT_GACHA_PRSV"),
            Self::AP_ITEM => Some("AP_ITEM"),
            Self::AP_SUPPLY => Some("AP_SUPPLY"),
            Self::RENAMING_CARD => Some("RENAMING_CARD"),
            Self::RENAMING_CARD_2 => Some("RENAMING_CARD_2"),
            Self::ET_STAGE => Some("ET_STAGE"),
            Self::ACTIVITY_ITEM => Some("ACTIVITY_ITEM"),
            Self::VOUCHER_PICK => Some("VOUCHER_PICK"),
            Self::VOUCHER_CGACHA => Some("VOUCHER_CGACHA"),
            Self::VOUCHER_MGACHA => Some("VOUCHER_MGACHA"),
            Self::CRS_SHOP_COIN => Some("CRS_SHOP_COIN"),
            Self::CRS_RUNE_COIN => Some("CRS_RUNE_COIN"),
            Self::LMTGS_COIN => Some("LMTGS_COIN"),
            Self::EPGS_COIN => Some("EPGS_COIN"),
            Self::LIMITED_TKT_GACHA_10 => Some("LIMITED_TKT_GACHA_10"),
            Self::LIMITED_FREE_GACHA => Some("LIMITED_FREE_GACHA"),
            Self::REP_COIN => Some("REP_COIN"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::LINKAGE_TKT_GACHA_10 => Some("LINKAGE_TKT_GACHA_10"),
            Self::VOUCHER_ELITE_II_4 => Some("VOUCHER_ELITE_II_4"),
            Self::VOUCHER_ELITE_II_5 => Some("VOUCHER_ELITE_II_5"),
            Self::VOUCHER_ELITE_II_6 => Some("VOUCHER_ELITE_II_6"),
            Self::VOUCHER_SKIN => Some("VOUCHER_SKIN"),
            Self::RETRO_COIN => Some("RETRO_COIN"),
            Self::PLAYER_AVATAR => Some("PLAYER_AVATAR"),
            Self::UNI_COLLECTION => Some("UNI_COLLECTION"),
            Self::VOUCHER_FULL_POTENTIAL => Some("VOUCHER_FULL_POTENTIAL"),
            Self::RL_COIN => Some("RL_COIN"),
            Self::RETURN_CREDIT => Some("RETURN_CREDIT"),
            Self::MEDAL => Some("MEDAL"),
            Self::CHARM => Some("CHARM"),
            Self::HOME_BACKGROUND => Some("HOME_BACKGROUND"),
            Self::EXTERMINATION_AGENT => Some("EXTERMINATION_AGENT"),
            Self::OPTIONAL_VOUCHER_PICK => Some("OPTIONAL_VOUCHER_PICK"),
            Self::ACT_CART_COMPONENT => Some("ACT_CART_COMPONENT"),
            Self::VOUCHER_LEVELMAX_6 => Some("VOUCHER_LEVELMAX_6"),
            Self::VOUCHER_LEVELMAX_5 => Some("VOUCHER_LEVELMAX_5"),
            Self::VOUCHER_LEVELMAX_4 => Some("VOUCHER_LEVELMAX_4"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_6 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_6"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_5 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_5"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_4 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_4"),
            Self::ACTIVITY_POTENTIAL => Some("ACTIVITY_POTENTIAL"),
            Self::ITEM_PACK => Some("ITEM_PACK"),
            Self::SANDBOX => Some("SANDBOX"),
            Self::FAVOR_ADD_ITEM => Some("FAVOR_ADD_ITEM"),
            Self::CLASSIC_SHD => Some("CLASSIC_SHD"),
            Self::CLASSIC_TKT_GACHA => Some("CLASSIC_TKT_GACHA"),
            Self::CLASSIC_TKT_GACHA_10 => Some("CLASSIC_TKT_GACHA_10"),
            Self::LIMITED_BUFF => Some("LIMITED_BUFF"),
            Self::CLASSIC_FES_PICK_TIER_5 => Some("CLASSIC_FES_PICK_TIER_5"),
            Self::CLASSIC_FES_PICK_TIER_6 => Some("CLASSIC_FES_PICK_TIER_6"),
            Self::RETURN_PROGRESS => Some("RETURN_PROGRESS"),
            Self::NEW_PROGRESS => Some("NEW_PROGRESS"),
            Self::MCARD_VOUCHER => Some("MCARD_VOUCHER"),
            Self::MATERIAL_ISSUE_VOUCHER => Some("MATERIAL_ISSUE_VOUCHER"),
            Self::CRS_SHOP_COIN_V2 => Some("CRS_SHOP_COIN_V2"),
            Self::HOME_THEME => Some("HOME_THEME"),
            Self::SANDBOX_PERM => Some("SANDBOX_PERM"),
            Self::SANDBOX_TOKEN => Some("SANDBOX_TOKEN"),
            Self::TEMPLATE_TRAP => Some("TEMPLATE_TRAP"),
            Self::NAME_CARD_SKIN => Some("NAME_CARD_SKIN"),
            Self::EMOTICON_SET => Some("EMOTICON_SET"),
            Self::EXCLUSIVE_TKT_GACHA => Some("EXCLUSIVE_TKT_GACHA"),
            Self::EXCLUSIVE_TKT_GACHA_10 => Some("EXCLUSIVE_TKT_GACHA_10"),
            Self::SO_CHAR_EXP => Some("SO_CHAR_EXP"),
            Self::GIFTPACKAGE_TKT => Some("GIFTPACKAGE_TKT"),
            Self::VOUCHER_SKIN_V2 => Some("VOUCHER_SKIN_V2"),
            Self::RANDOM_VOUCHER_SKIN => Some("RANDOM_VOUCHER_SKIN"),
            Self::ACT1VHALFIDLE_ITEM => Some("ACT1VHALFIDLE_ITEM"),
            Self::PLOT_ITEM => Some("PLOT_ITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ItemType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemType {
    type Output = enum__Torappu_ItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STAGE_DROP_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STAGE_DROP_TYPE: i32 = 12;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STAGE_DROP_TYPE: [enum__Torappu_StageDropType; 13] = [
    enum__Torappu_StageDropType::NONE,
    enum__Torappu_StageDropType::ONCE,
    enum__Torappu_StageDropType::NORMAL,
    enum__Torappu_StageDropType::SPECIAL,
    enum__Torappu_StageDropType::ADDITIONAL,
    enum__Torappu_StageDropType::APRETURN,
    enum__Torappu_StageDropType::DIAMOND_MATERIAL,
    enum__Torappu_StageDropType::FUNITURE_DROP,
    enum__Torappu_StageDropType::COMPLETE,
    enum__Torappu_StageDropType::CHARM_DROP,
    enum__Torappu_StageDropType::OVERRIDE_DROP,
    enum__Torappu_StageDropType::ITEM_RETURN,
    enum__Torappu_StageDropType::CONDITION_DROP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StageDropType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StageDropType {
    pub const NONE: Self = Self(0);
    pub const ONCE: Self = Self(1);
    pub const NORMAL: Self = Self(2);
    pub const SPECIAL: Self = Self(3);
    pub const ADDITIONAL: Self = Self(4);
    pub const APRETURN: Self = Self(5);
    pub const DIAMOND_MATERIAL: Self = Self(6);
    pub const FUNITURE_DROP: Self = Self(7);
    pub const COMPLETE: Self = Self(8);
    pub const CHARM_DROP: Self = Self(9);
    pub const OVERRIDE_DROP: Self = Self(10);
    pub const ITEM_RETURN: Self = Self(11);
    pub const CONDITION_DROP: Self = Self(12);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 12;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ONCE,
        Self::NORMAL,
        Self::SPECIAL,
        Self::ADDITIONAL,
        Self::APRETURN,
        Self::DIAMOND_MATERIAL,
        Self::FUNITURE_DROP,
        Self::COMPLETE,
        Self::CHARM_DROP,
        Self::OVERRIDE_DROP,
        Self::ITEM_RETURN,
        Self::CONDITION_DROP,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ONCE => Some("ONCE"),
            Self::NORMAL => Some("NORMAL"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::ADDITIONAL => Some("ADDITIONAL"),
            Self::APRETURN => Some("APRETURN"),
            Self::DIAMOND_MATERIAL => Some("DIAMOND_MATERIAL"),
            Self::FUNITURE_DROP => Some("FUNITURE_DROP"),
            Self::COMPLETE => Some("COMPLETE"),
            Self::CHARM_DROP => Some("CHARM_DROP"),
            Self::OVERRIDE_DROP => Some("OVERRIDE_DROP"),
            Self::ITEM_RETURN => Some("ITEM_RETURN"),
            Self::CONDITION_DROP => Some("CONDITION_DROP"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StageDropType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StageDropType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StageDropType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StageDropType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StageDropType {
    type Output = enum__Torappu_StageDropType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StageDropType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StageDropType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StageDropType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_OCC_PER: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_OCC_PER: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_OCC_PER: [enum__Torappu_OccPer; 7] = [
    enum__Torappu_OccPer::ALWAYS,
    enum__Torappu_OccPer::ALMOST,
    enum__Torappu_OccPer::USUAL,
    enum__Torappu_OccPer::OFTEN,
    enum__Torappu_OccPer::SOMETIMES,
    enum__Torappu_OccPer::NEVER,
    enum__Torappu_OccPer::DEFINITELY_BUFF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_OccPer(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_OccPer {
    pub const ALWAYS: Self = Self(0);
    pub const ALMOST: Self = Self(1);
    pub const USUAL: Self = Self(2);
    pub const OFTEN: Self = Self(3);
    pub const SOMETIMES: Self = Self(4);
    pub const NEVER: Self = Self(5);
    pub const DEFINITELY_BUFF: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::ALWAYS,
        Self::ALMOST,
        Self::USUAL,
        Self::OFTEN,
        Self::SOMETIMES,
        Self::NEVER,
        Self::DEFINITELY_BUFF,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ALWAYS => Some("ALWAYS"),
            Self::ALMOST => Some("ALMOST"),
            Self::USUAL => Some("USUAL"),
            Self::OFTEN => Some("OFTEN"),
            Self::SOMETIMES => Some("SOMETIMES"),
            Self::NEVER => Some("NEVER"),
            Self::DEFINITELY_BUFF => Some("DEFINITELY_BUFF"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_OccPer {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_OccPer {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_OccPer",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_OccPer {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_OccPer {
    type Output = enum__Torappu_OccPer;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_OccPer {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_OccPer {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_OccPer {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_RETRO_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_RETRO_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_RETRO_TYPE: [enum__Torappu_RetroType; 2] = [
    enum__Torappu_RetroType::SIDESTORY,
    enum__Torappu_RetroType::BRANCHLINE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_RetroType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_RetroType {
    pub const SIDESTORY: Self = Self(0);
    pub const BRANCHLINE: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::SIDESTORY, Self::BRANCHLINE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::SIDESTORY => Some("SIDESTORY"),
            Self::BRANCHLINE => Some("BRANCHLINE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_RetroType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_RetroType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_RetroType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_RetroType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_RetroType {
    type Output = enum__Torappu_RetroType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_RetroType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_RetroType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_RetroType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ACTIVITY_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ACTIVITY_TYPE: i32 = 62;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ACTIVITY_TYPE: [enum__Torappu_ActivityType; 63] = [
    enum__Torappu_ActivityType::DEFAULT,
    enum__Torappu_ActivityType::MISSION_ONLY,
    enum__Torappu_ActivityType::CHECKIN_ONLY,
    enum__Torappu_ActivityType::CHECKIN_ALL_PLAYER,
    enum__Torappu_ActivityType::TYPE_ACT3D0,
    enum__Torappu_ActivityType::TYPE_ACT4D0,
    enum__Torappu_ActivityType::TYPE_ACT5D0,
    enum__Torappu_ActivityType::TYPE_ACT5D1,
    enum__Torappu_ActivityType::COLLECTION,
    enum__Torappu_ActivityType::AVG_ONLY,
    enum__Torappu_ActivityType::TYPE_ACT9D0,
    enum__Torappu_ActivityType::TYPE_ACT12SIDE,
    enum__Torappu_ActivityType::TYPE_ACT13SIDE,
    enum__Torappu_ActivityType::TYPE_ACT17SIDE,
    enum__Torappu_ActivityType::LOGIN_ONLY,
    enum__Torappu_ActivityType::MINISTORY,
    enum__Torappu_ActivityType::ROGUELIKE,
    enum__Torappu_ActivityType::PRAY_ONLY,
    enum__Torappu_ActivityType::MULTIPLAY,
    enum__Torappu_ActivityType::MULTIPLAY_VERIFY2,
    enum__Torappu_ActivityType::TYPE_ACT17D7,
    enum__Torappu_ActivityType::GRID_GACHA,
    enum__Torappu_ActivityType::GRID_GACHA_V2,
    enum__Torappu_ActivityType::INTERLOCK,
    enum__Torappu_ActivityType::APRIL_FOOL,
    enum__Torappu_ActivityType::BOSS_RUSH,
    enum__Torappu_ActivityType::TYPE_ACT20SIDE,
    enum__Torappu_ActivityType::FLOAT_PARADE,
    enum__Torappu_ActivityType::TYPE_ACT21SIDE,
    enum__Torappu_ActivityType::MAIN_BUFF,
    enum__Torappu_ActivityType::TYPE_ACT24SIDE,
    enum__Torappu_ActivityType::FLIP_ONLY,
    enum__Torappu_ActivityType::TYPE_ACT25SIDE,
    enum__Torappu_ActivityType::CHECKIN_VS,
    enum__Torappu_ActivityType::SWITCH_ONLY,
    enum__Torappu_ActivityType::TYPE_ACT27SIDE,
    enum__Torappu_ActivityType::UNIQUE_ONLY,
    enum__Torappu_ActivityType::MAINLINE_BP,
    enum__Torappu_ActivityType::TYPE_ACT42D0,
    enum__Torappu_ActivityType::TYPE_ACT29SIDE,
    enum__Torappu_ActivityType::BLESS_ONLY,
    enum__Torappu_ActivityType::CHECKIN_ACCESS,
    enum__Torappu_ActivityType::YEAR_5_GENERAL,
    enum__Torappu_ActivityType::TYPE_ACT35SIDE,
    enum__Torappu_ActivityType::VEC_BREAK,
    enum__Torappu_ActivityType::TYPE_ACT36SIDE,
    enum__Torappu_ActivityType::TYPE_ACT38SIDE,
    enum__Torappu_ActivityType::AUTOCHESS_VERIFY1,
    enum__Torappu_ActivityType::CHECKIN_VIDEO,
    enum__Torappu_ActivityType::ARCADE,
    enum__Torappu_ActivityType::MULTIPLAY_V3,
    enum__Torappu_ActivityType::TYPE_MAINSS,
    enum__Torappu_ActivityType::ENEMY_DUEL,
    enum__Torappu_ActivityType::VEC_BREAK_V2,
    enum__Torappu_ActivityType::TYPE_ACT42SIDE,
    enum__Torappu_ActivityType::TYPE_ACT44SIDE,
    enum__Torappu_ActivityType::HALFIDLE_VERIFY1,
    enum__Torappu_ActivityType::TYPE_ACT45SIDE,
    enum__Torappu_ActivityType::TEAM_QUEST,
    enum__Torappu_ActivityType::RECRUIT_ONLY,
    enum__Torappu_ActivityType::TYPE_ACT46SIDE,
    enum__Torappu_ActivityType::AUTOCHESS_SEASON,
    enum__Torappu_ActivityType::ENUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ActivityType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ActivityType {
    pub const DEFAULT: Self = Self(0);
    pub const MISSION_ONLY: Self = Self(1);
    pub const CHECKIN_ONLY: Self = Self(2);
    pub const CHECKIN_ALL_PLAYER: Self = Self(3);
    pub const TYPE_ACT3D0: Self = Self(4);
    pub const TYPE_ACT4D0: Self = Self(5);
    pub const TYPE_ACT5D0: Self = Self(6);
    pub const TYPE_ACT5D1: Self = Self(7);
    pub const COLLECTION: Self = Self(8);
    pub const AVG_ONLY: Self = Self(9);
    pub const TYPE_ACT9D0: Self = Self(10);
    pub const TYPE_ACT12SIDE: Self = Self(11);
    pub const TYPE_ACT13SIDE: Self = Self(12);
    pub const TYPE_ACT17SIDE: Self = Self(13);
    pub const LOGIN_ONLY: Self = Self(14);
    pub const MINISTORY: Self = Self(15);
    pub const ROGUELIKE: Self = Self(16);
    pub const PRAY_ONLY: Self = Self(17);
    pub const MULTIPLAY: Self = Self(18);
    pub const MULTIPLAY_VERIFY2: Self = Self(19);
    pub const TYPE_ACT17D7: Self = Self(20);
    pub const GRID_GACHA: Self = Self(21);
    pub const GRID_GACHA_V2: Self = Self(22);
    pub const INTERLOCK: Self = Self(23);
    pub const APRIL_FOOL: Self = Self(24);
    pub const BOSS_RUSH: Self = Self(25);
    pub const TYPE_ACT20SIDE: Self = Self(26);
    pub const FLOAT_PARADE: Self = Self(27);
    pub const TYPE_ACT21SIDE: Self = Self(28);
    pub const MAIN_BUFF: Self = Self(29);
    pub const TYPE_ACT24SIDE: Self = Self(30);
    pub const FLIP_ONLY: Self = Self(31);
    pub const TYPE_ACT25SIDE: Self = Self(32);
    pub const CHECKIN_VS: Self = Self(33);
    pub const SWITCH_ONLY: Self = Self(34);
    pub const TYPE_ACT27SIDE: Self = Self(35);
    pub const UNIQUE_ONLY: Self = Self(36);
    pub const MAINLINE_BP: Self = Self(37);
    pub const TYPE_ACT42D0: Self = Self(38);
    pub const TYPE_ACT29SIDE: Self = Self(39);
    pub const BLESS_ONLY: Self = Self(40);
    pub const CHECKIN_ACCESS: Self = Self(41);
    pub const YEAR_5_GENERAL: Self = Self(42);
    pub const TYPE_ACT35SIDE: Self = Self(43);
    pub const VEC_BREAK: Self = Self(44);
    pub const TYPE_ACT36SIDE: Self = Self(45);
    pub const TYPE_ACT38SIDE: Self = Self(46);
    pub const AUTOCHESS_VERIFY1: Self = Self(47);
    pub const CHECKIN_VIDEO: Self = Self(48);
    pub const ARCADE: Self = Self(49);
    pub const MULTIPLAY_V3: Self = Self(50);
    pub const TYPE_MAINSS: Self = Self(51);
    pub const ENEMY_DUEL: Self = Self(52);
    pub const VEC_BREAK_V2: Self = Self(53);
    pub const TYPE_ACT42SIDE: Self = Self(54);
    pub const TYPE_ACT44SIDE: Self = Self(55);
    pub const HALFIDLE_VERIFY1: Self = Self(56);
    pub const TYPE_ACT45SIDE: Self = Self(57);
    pub const TEAM_QUEST: Self = Self(58);
    pub const RECRUIT_ONLY: Self = Self(59);
    pub const TYPE_ACT46SIDE: Self = Self(60);
    pub const AUTOCHESS_SEASON: Self = Self(61);
    pub const ENUM: Self = Self(62);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 62;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::DEFAULT,
        Self::MISSION_ONLY,
        Self::CHECKIN_ONLY,
        Self::CHECKIN_ALL_PLAYER,
        Self::TYPE_ACT3D0,
        Self::TYPE_ACT4D0,
        Self::TYPE_ACT5D0,
        Self::TYPE_ACT5D1,
        Self::COLLECTION,
        Self::AVG_ONLY,
        Self::TYPE_ACT9D0,
        Self::TYPE_ACT12SIDE,
        Self::TYPE_ACT13SIDE,
        Self::TYPE_ACT17SIDE,
        Self::LOGIN_ONLY,
        Self::MINISTORY,
        Self::ROGUELIKE,
        Self::PRAY_ONLY,
        Self::MULTIPLAY,
        Self::MULTIPLAY_VERIFY2,
        Self::TYPE_ACT17D7,
        Self::GRID_GACHA,
        Self::GRID_GACHA_V2,
        Self::INTERLOCK,
        Self::APRIL_FOOL,
        Self::BOSS_RUSH,
        Self::TYPE_ACT20SIDE,
        Self::FLOAT_PARADE,
        Self::TYPE_ACT21SIDE,
        Self::MAIN_BUFF,
        Self::TYPE_ACT24SIDE,
        Self::FLIP_ONLY,
        Self::TYPE_ACT25SIDE,
        Self::CHECKIN_VS,
        Self::SWITCH_ONLY,
        Self::TYPE_ACT27SIDE,
        Self::UNIQUE_ONLY,
        Self::MAINLINE_BP,
        Self::TYPE_ACT42D0,
        Self::TYPE_ACT29SIDE,
        Self::BLESS_ONLY,
        Self::CHECKIN_ACCESS,
        Self::YEAR_5_GENERAL,
        Self::TYPE_ACT35SIDE,
        Self::VEC_BREAK,
        Self::TYPE_ACT36SIDE,
        Self::TYPE_ACT38SIDE,
        Self::AUTOCHESS_VERIFY1,
        Self::CHECKIN_VIDEO,
        Self::ARCADE,
        Self::MULTIPLAY_V3,
        Self::TYPE_MAINSS,
        Self::ENEMY_DUEL,
        Self::VEC_BREAK_V2,
        Self::TYPE_ACT42SIDE,
        Self::TYPE_ACT44SIDE,
        Self::HALFIDLE_VERIFY1,
        Self::TYPE_ACT45SIDE,
        Self::TEAM_QUEST,
        Self::RECRUIT_ONLY,
        Self::TYPE_ACT46SIDE,
        Self::AUTOCHESS_SEASON,
        Self::ENUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::DEFAULT => Some("DEFAULT"),
            Self::MISSION_ONLY => Some("MISSION_ONLY"),
            Self::CHECKIN_ONLY => Some("CHECKIN_ONLY"),
            Self::CHECKIN_ALL_PLAYER => Some("CHECKIN_ALL_PLAYER"),
            Self::TYPE_ACT3D0 => Some("TYPE_ACT3D0"),
            Self::TYPE_ACT4D0 => Some("TYPE_ACT4D0"),
            Self::TYPE_ACT5D0 => Some("TYPE_ACT5D0"),
            Self::TYPE_ACT5D1 => Some("TYPE_ACT5D1"),
            Self::COLLECTION => Some("COLLECTION"),
            Self::AVG_ONLY => Some("AVG_ONLY"),
            Self::TYPE_ACT9D0 => Some("TYPE_ACT9D0"),
            Self::TYPE_ACT12SIDE => Some("TYPE_ACT12SIDE"),
            Self::TYPE_ACT13SIDE => Some("TYPE_ACT13SIDE"),
            Self::TYPE_ACT17SIDE => Some("TYPE_ACT17SIDE"),
            Self::LOGIN_ONLY => Some("LOGIN_ONLY"),
            Self::MINISTORY => Some("MINISTORY"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::PRAY_ONLY => Some("PRAY_ONLY"),
            Self::MULTIPLAY => Some("MULTIPLAY"),
            Self::MULTIPLAY_VERIFY2 => Some("MULTIPLAY_VERIFY2"),
            Self::TYPE_ACT17D7 => Some("TYPE_ACT17D7"),
            Self::GRID_GACHA => Some("GRID_GACHA"),
            Self::GRID_GACHA_V2 => Some("GRID_GACHA_V2"),
            Self::INTERLOCK => Some("INTERLOCK"),
            Self::APRIL_FOOL => Some("APRIL_FOOL"),
            Self::BOSS_RUSH => Some("BOSS_RUSH"),
            Self::TYPE_ACT20SIDE => Some("TYPE_ACT20SIDE"),
            Self::FLOAT_PARADE => Some("FLOAT_PARADE"),
            Self::TYPE_ACT21SIDE => Some("TYPE_ACT21SIDE"),
            Self::MAIN_BUFF => Some("MAIN_BUFF"),
            Self::TYPE_ACT24SIDE => Some("TYPE_ACT24SIDE"),
            Self::FLIP_ONLY => Some("FLIP_ONLY"),
            Self::TYPE_ACT25SIDE => Some("TYPE_ACT25SIDE"),
            Self::CHECKIN_VS => Some("CHECKIN_VS"),
            Self::SWITCH_ONLY => Some("SWITCH_ONLY"),
            Self::TYPE_ACT27SIDE => Some("TYPE_ACT27SIDE"),
            Self::UNIQUE_ONLY => Some("UNIQUE_ONLY"),
            Self::MAINLINE_BP => Some("MAINLINE_BP"),
            Self::TYPE_ACT42D0 => Some("TYPE_ACT42D0"),
            Self::TYPE_ACT29SIDE => Some("TYPE_ACT29SIDE"),
            Self::BLESS_ONLY => Some("BLESS_ONLY"),
            Self::CHECKIN_ACCESS => Some("CHECKIN_ACCESS"),
            Self::YEAR_5_GENERAL => Some("YEAR_5_GENERAL"),
            Self::TYPE_ACT35SIDE => Some("TYPE_ACT35SIDE"),
            Self::VEC_BREAK => Some("VEC_BREAK"),
            Self::TYPE_ACT36SIDE => Some("TYPE_ACT36SIDE"),
            Self::TYPE_ACT38SIDE => Some("TYPE_ACT38SIDE"),
            Self::AUTOCHESS_VERIFY1 => Some("AUTOCHESS_VERIFY1"),
            Self::CHECKIN_VIDEO => Some("CHECKIN_VIDEO"),
            Self::ARCADE => Some("ARCADE"),
            Self::MULTIPLAY_V3 => Some("MULTIPLAY_V3"),
            Self::TYPE_MAINSS => Some("TYPE_MAINSS"),
            Self::ENEMY_DUEL => Some("ENEMY_DUEL"),
            Self::VEC_BREAK_V2 => Some("VEC_BREAK_V2"),
            Self::TYPE_ACT42SIDE => Some("TYPE_ACT42SIDE"),
            Self::TYPE_ACT44SIDE => Some("TYPE_ACT44SIDE"),
            Self::HALFIDLE_VERIFY1 => Some("HALFIDLE_VERIFY1"),
            Self::TYPE_ACT45SIDE => Some("TYPE_ACT45SIDE"),
            Self::TEAM_QUEST => Some("TEAM_QUEST"),
            Self::RECRUIT_ONLY => Some("RECRUIT_ONLY"),
            Self::TYPE_ACT46SIDE => Some("TYPE_ACT46SIDE"),
            Self::AUTOCHESS_SEASON => Some("AUTOCHESS_SEASON"),
            Self::ENUM => Some("ENUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ActivityType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ActivityType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ActivityType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ActivityType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ActivityType {
    type Output = enum__Torappu_ActivityType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ActivityType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ActivityType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ActivityType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STAGE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STAGE_TYPE: i32 = 10;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STAGE_TYPE: [enum__Torappu_StageType; 11] = [
    enum__Torappu_StageType::MAIN,
    enum__Torappu_StageType::DAILY,
    enum__Torappu_StageType::TRAINING,
    enum__Torappu_StageType::ACTIVITY,
    enum__Torappu_StageType::GUIDE,
    enum__Torappu_StageType::SUB,
    enum__Torappu_StageType::CAMPAIGN,
    enum__Torappu_StageType::SPECIAL_STORY,
    enum__Torappu_StageType::HANDBOOK_BATTLE,
    enum__Torappu_StageType::CLIMB_TOWER,
    enum__Torappu_StageType::ENUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StageType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StageType {
    pub const MAIN: Self = Self(0);
    pub const DAILY: Self = Self(1);
    pub const TRAINING: Self = Self(2);
    pub const ACTIVITY: Self = Self(3);
    pub const GUIDE: Self = Self(4);
    pub const SUB: Self = Self(5);
    pub const CAMPAIGN: Self = Self(6);
    pub const SPECIAL_STORY: Self = Self(7);
    pub const HANDBOOK_BATTLE: Self = Self(8);
    pub const CLIMB_TOWER: Self = Self(9);
    pub const ENUM: Self = Self(10);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 10;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::MAIN,
        Self::DAILY,
        Self::TRAINING,
        Self::ACTIVITY,
        Self::GUIDE,
        Self::SUB,
        Self::CAMPAIGN,
        Self::SPECIAL_STORY,
        Self::HANDBOOK_BATTLE,
        Self::CLIMB_TOWER,
        Self::ENUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MAIN => Some("MAIN"),
            Self::DAILY => Some("DAILY"),
            Self::TRAINING => Some("TRAINING"),
            Self::ACTIVITY => Some("ACTIVITY"),
            Self::GUIDE => Some("GUIDE"),
            Self::SUB => Some("SUB"),
            Self::CAMPAIGN => Some("CAMPAIGN"),
            Self::SPECIAL_STORY => Some("SPECIAL_STORY"),
            Self::HANDBOOK_BATTLE => Some("HANDBOOK_BATTLE"),
            Self::CLIMB_TOWER => Some("CLIMB_TOWER"),
            Self::ENUM => Some("ENUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StageType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StageType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StageType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StageType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StageType {
    type Output = enum__Torappu_StageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StageType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StageType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StageType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: i32 = 15;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_LEVEL_DATA_DIFFICULTY: [enum__Torappu_LevelData_Difficulty; 6] = [
    enum__Torappu_LevelData_Difficulty::NONE,
    enum__Torappu_LevelData_Difficulty::NORMAL,
    enum__Torappu_LevelData_Difficulty::FOUR_STAR,
    enum__Torappu_LevelData_Difficulty::EASY,
    enum__Torappu_LevelData_Difficulty::SIX_STAR,
    enum__Torappu_LevelData_Difficulty::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_LevelData_Difficulty(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_LevelData_Difficulty {
    pub const NONE: Self = Self(0);
    pub const NORMAL: Self = Self(1);
    pub const FOUR_STAR: Self = Self(2);
    pub const EASY: Self = Self(4);
    pub const SIX_STAR: Self = Self(8);
    pub const ALL: Self = Self(15);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 15;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::NORMAL,
        Self::FOUR_STAR,
        Self::EASY,
        Self::SIX_STAR,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::NORMAL => Some("NORMAL"),
            Self::FOUR_STAR => Some("FOUR_STAR"),
            Self::EASY => Some("EASY"),
            Self::SIX_STAR => Some("SIX_STAR"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_LevelData_Difficulty {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_LevelData_Difficulty {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_LevelData_Difficulty",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_LevelData_Difficulty {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_LevelData_Difficulty {
    type Output = enum__Torappu_LevelData_Difficulty;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_LevelData_Difficulty {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_LevelData_Difficulty {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_LevelData_Difficulty {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STAGE_DATA_PERFORMANCE_STAGE_FLAG: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STAGE_DATA_PERFORMANCE_STAGE_FLAG: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STAGE_DATA_PERFORMANCE_STAGE_FLAG:
    [enum__Torappu_StageData_PerformanceStageFlag; 2] = [
    enum__Torappu_StageData_PerformanceStageFlag::NORMAL_STAGE,
    enum__Torappu_StageData_PerformanceStageFlag::PERFORMANCE_STAGE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StageData_PerformanceStageFlag(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StageData_PerformanceStageFlag {
    pub const NORMAL_STAGE: Self = Self(0);
    pub const PERFORMANCE_STAGE: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NORMAL_STAGE, Self::PERFORMANCE_STAGE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL_STAGE => Some("NORMAL_STAGE"),
            Self::PERFORMANCE_STAGE => Some("PERFORMANCE_STAGE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StageData_PerformanceStageFlag {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StageData_PerformanceStageFlag {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StageData_PerformanceStageFlag",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StageData_PerformanceStageFlag {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StageData_PerformanceStageFlag {
    type Output = enum__Torappu_StageData_PerformanceStageFlag;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StageData_PerformanceStageFlag {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StageData_PerformanceStageFlag {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StageData_PerformanceStageFlag {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STAGE_DIFF_GROUP: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STAGE_DIFF_GROUP: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STAGE_DIFF_GROUP: [enum__Torappu_StageDiffGroup; 5] = [
    enum__Torappu_StageDiffGroup::NONE,
    enum__Torappu_StageDiffGroup::EASY,
    enum__Torappu_StageDiffGroup::NORMAL,
    enum__Torappu_StageDiffGroup::TOUGH,
    enum__Torappu_StageDiffGroup::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StageDiffGroup(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StageDiffGroup {
    pub const NONE: Self = Self(0);
    pub const EASY: Self = Self(1);
    pub const NORMAL: Self = Self(2);
    pub const TOUGH: Self = Self(4);
    pub const ALL: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::EASY, Self::NORMAL, Self::TOUGH, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::EASY => Some("EASY"),
            Self::NORMAL => Some("NORMAL"),
            Self::TOUGH => Some("TOUGH"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StageDiffGroup {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StageDiffGroup {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StageDiffGroup",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StageDiffGroup {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StageDiffGroup {
    type Output = enum__Torappu_StageDiffGroup;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StageDiffGroup {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StageDiffGroup {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StageDiffGroup {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PLAYER_BATTLE_RANK: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PLAYER_BATTLE_RANK: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PLAYER_BATTLE_RANK: [enum__Torappu_PlayerBattleRank; 4] = [
    enum__Torappu_PlayerBattleRank::ERR_ZERO,
    enum__Torappu_PlayerBattleRank::FAIL,
    enum__Torappu_PlayerBattleRank::PASS,
    enum__Torappu_PlayerBattleRank::COMPLETE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_PlayerBattleRank(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_PlayerBattleRank {
    pub const ERR_ZERO: Self = Self(0);
    pub const FAIL: Self = Self(1);
    pub const PASS: Self = Self(2);
    pub const COMPLETE: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::ERR_ZERO, Self::FAIL, Self::PASS, Self::COMPLETE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ERR_ZERO => Some("ERR_ZERO"),
            Self::FAIL => Some("FAIL"),
            Self::PASS => Some("PASS"),
            Self::COMPLETE => Some("COMPLETE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_PlayerBattleRank {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_PlayerBattleRank {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_PlayerBattleRank",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_PlayerBattleRank {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_PlayerBattleRank {
    type Output = enum__Torappu_PlayerBattleRank;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_PlayerBattleRank {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_PlayerBattleRank {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_PlayerBattleRank {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_APPEARANCE_STYLE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_APPEARANCE_STYLE: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_APPEARANCE_STYLE: [enum__Torappu_AppearanceStyle; 7] = [
    enum__Torappu_AppearanceStyle::MAIN_NORMAL,
    enum__Torappu_AppearanceStyle::MAIN_PREDEFINED,
    enum__Torappu_AppearanceStyle::SUB,
    enum__Torappu_AppearanceStyle::TRAINING,
    enum__Torappu_AppearanceStyle::HIGH_DIFFICULTY,
    enum__Torappu_AppearanceStyle::MIST_OPS,
    enum__Torappu_AppearanceStyle::SPECIAL_STORY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_AppearanceStyle(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_AppearanceStyle {
    pub const MAIN_NORMAL: Self = Self(0);
    pub const MAIN_PREDEFINED: Self = Self(1);
    pub const SUB: Self = Self(2);
    pub const TRAINING: Self = Self(3);
    pub const HIGH_DIFFICULTY: Self = Self(4);
    pub const MIST_OPS: Self = Self(5);
    pub const SPECIAL_STORY: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::MAIN_NORMAL,
        Self::MAIN_PREDEFINED,
        Self::SUB,
        Self::TRAINING,
        Self::HIGH_DIFFICULTY,
        Self::MIST_OPS,
        Self::SPECIAL_STORY,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MAIN_NORMAL => Some("MAIN_NORMAL"),
            Self::MAIN_PREDEFINED => Some("MAIN_PREDEFINED"),
            Self::SUB => Some("SUB"),
            Self::TRAINING => Some("TRAINING"),
            Self::HIGH_DIFFICULTY => Some("HIGH_DIFFICULTY"),
            Self::MIST_OPS => Some("MIST_OPS"),
            Self::SPECIAL_STORY => Some("SPECIAL_STORY"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_AppearanceStyle {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_AppearanceStyle {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_AppearanceStyle",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_AppearanceStyle {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_AppearanceStyle {
    type Output = enum__Torappu_AppearanceStyle;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_AppearanceStyle {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_AppearanceStyle {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_AppearanceStyle {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_STAGE_DATA_SPECIAL_STAGE_UNLOCK_PROGRESS_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_STAGE_DATA_SPECIAL_STAGE_UNLOCK_PROGRESS_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_STAGE_DATA_SPECIAL_STAGE_UNLOCK_PROGRESS_TYPE:
    [enum__Torappu_StageData_SpecialStageUnlockProgressType; 2] = [
    enum__Torappu_StageData_SpecialStageUnlockProgressType::ONCE,
    enum__Torappu_StageData_SpecialStageUnlockProgressType::PROGRESS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_StageData_SpecialStageUnlockProgressType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_StageData_SpecialStageUnlockProgressType {
    pub const ONCE: Self = Self(0);
    pub const PROGRESS: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::ONCE, Self::PROGRESS];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ONCE => Some("ONCE"),
            Self::PROGRESS => Some("PROGRESS"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_StageData_SpecialStageUnlockProgressType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_StageData_SpecialStageUnlockProgressType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_StageData_SpecialStageUnlockProgressType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_StageData_SpecialStageUnlockProgressType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_StageData_SpecialStageUnlockProgressType {
    type Output = enum__Torappu_StageData_SpecialStageUnlockProgressType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_StageData_SpecialStageUnlockProgressType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_StageData_SpecialStageUnlockProgressType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_StageData_SpecialStageUnlockProgressType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ACT_17SIDE_DATA_NODE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ACT_17SIDE_DATA_NODE_TYPE: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ACT_17SIDE_DATA_NODE_TYPE:
    [enum__Torappu_Act17sideData_NodeType; 8] = [
    enum__Torappu_Act17sideData_NodeType::LANDMARK,
    enum__Torappu_Act17sideData_NodeType::STORY,
    enum__Torappu_Act17sideData_NodeType::BATTLE,
    enum__Torappu_Act17sideData_NodeType::ENDING,
    enum__Torappu_Act17sideData_NodeType::TREASURE,
    enum__Torappu_Act17sideData_NodeType::EVENT,
    enum__Torappu_Act17sideData_NodeType::TECH,
    enum__Torappu_Act17sideData_NodeType::CHOICE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Act17sideData_NodeType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Act17sideData_NodeType {
    pub const LANDMARK: Self = Self(0);
    pub const STORY: Self = Self(1);
    pub const BATTLE: Self = Self(2);
    pub const ENDING: Self = Self(3);
    pub const TREASURE: Self = Self(4);
    pub const EVENT: Self = Self(5);
    pub const TECH: Self = Self(6);
    pub const CHOICE: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::LANDMARK,
        Self::STORY,
        Self::BATTLE,
        Self::ENDING,
        Self::TREASURE,
        Self::EVENT,
        Self::TECH,
        Self::CHOICE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::LANDMARK => Some("LANDMARK"),
            Self::STORY => Some("STORY"),
            Self::BATTLE => Some("BATTLE"),
            Self::ENDING => Some("ENDING"),
            Self::TREASURE => Some("TREASURE"),
            Self::EVENT => Some("EVENT"),
            Self::TECH => Some("TECH"),
            Self::CHOICE => Some("CHOICE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Act17sideData_NodeType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_Act17sideData_NodeType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_Act17sideData_NodeType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Act17sideData_NodeType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Act17sideData_NodeType {
    type Output = enum__Torappu_Act17sideData_NodeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Act17sideData_NodeType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Act17sideData_NodeType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_Act17sideData_NodeType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ACT_17SIDE_DATA_TRACK_POINT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ACT_17SIDE_DATA_TRACK_POINT_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ACT_17SIDE_DATA_TRACK_POINT_TYPE:
    [enum__Torappu_Act17sideData_TrackPointType; 3] = [
    enum__Torappu_Act17sideData_TrackPointType::NONE,
    enum__Torappu_Act17sideData_TrackPointType::MAIN,
    enum__Torappu_Act17sideData_TrackPointType::SUB,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Act17sideData_TrackPointType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Act17sideData_TrackPointType {
    pub const NONE: Self = Self(0);
    pub const MAIN: Self = Self(1);
    pub const SUB: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::MAIN, Self::SUB];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MAIN => Some("MAIN"),
            Self::SUB => Some("SUB"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Act17sideData_TrackPointType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_Act17sideData_TrackPointType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_Act17sideData_TrackPointType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Act17sideData_TrackPointType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Act17sideData_TrackPointType {
    type Output = enum__Torappu_Act17sideData_TrackPointType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Act17sideData_TrackPointType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Act17sideData_TrackPointType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_Act17sideData_TrackPointType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ACT_17SIDE_DATA_TREASURE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ACT_17SIDE_DATA_TREASURE_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ACT_17SIDE_DATA_TREASURE_TYPE:
    [enum__Torappu_Act17sideData_TreasureType; 2] = [
    enum__Torappu_Act17sideData_TreasureType::SMALL,
    enum__Torappu_Act17sideData_TreasureType::SPECIAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Act17sideData_TreasureType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Act17sideData_TreasureType {
    pub const SMALL: Self = Self(0);
    pub const SPECIAL: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::SMALL, Self::SPECIAL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::SMALL => Some("SMALL"),
            Self::SPECIAL => Some("SPECIAL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Act17sideData_TreasureType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_Act17sideData_TreasureType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_Act17sideData_TreasureType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Act17sideData_TreasureType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Act17sideData_TreasureType {
    type Output = enum__Torappu_Act17sideData_TreasureType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Act17sideData_TreasureType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Act17sideData_TreasureType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_Act17sideData_TreasureType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ACT_ARCHIVE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ACT_ARCHIVE_TYPE: i32 = 27;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ACT_ARCHIVE_TYPE: [enum__Torappu_ActArchiveType; 28] = [
    enum__Torappu_ActArchiveType::NONE,
    enum__Torappu_ActArchiveType::TIMELINE,
    enum__Torappu_ActArchiveType::MUSIC,
    enum__Torappu_ActArchiveType::PIC,
    enum__Torappu_ActArchiveType::AVG,
    enum__Torappu_ActArchiveType::STORY,
    enum__Torappu_ActArchiveType::NEWS,
    enum__Torappu_ActArchiveType::BUFF,
    enum__Torappu_ActArchiveType::RELIC,
    enum__Torappu_ActArchiveType::CAPSULE,
    enum__Torappu_ActArchiveType::TRAP,
    enum__Torappu_ActArchiveType::CHAT,
    enum__Torappu_ActArchiveType::LANDMARK,
    enum__Torappu_ActArchiveType::LOG,
    enum__Torappu_ActArchiveType::ACTIVITY_ENTRY,
    enum__Torappu_ActArchiveType::DYNAMIC_MUSIC,
    enum__Torappu_ActArchiveType::DYNAMIC_PIC,
    enum__Torappu_ActArchiveType::ENDBOOK,
    enum__Torappu_ActArchiveType::DYNAMIC_STORY,
    enum__Torappu_ActArchiveType::TOTEM,
    enum__Torappu_ActArchiveType::CHAOS,
    enum__Torappu_ActArchiveType::CHALLENGE_BOOK,
    enum__Torappu_ActArchiveType::ACHIEVEMENT,
    enum__Torappu_ActArchiveType::QUEST,
    enum__Torappu_ActArchiveType::FRAGMENT,
    enum__Torappu_ActArchiveType::DISASTER,
    enum__Torappu_ActArchiveType::COPPER,
    enum__Torappu_ActArchiveType::WRATH,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ActArchiveType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ActArchiveType {
    pub const NONE: Self = Self(0);
    pub const TIMELINE: Self = Self(1);
    pub const MUSIC: Self = Self(2);
    pub const PIC: Self = Self(3);
    pub const AVG: Self = Self(4);
    pub const STORY: Self = Self(5);
    pub const NEWS: Self = Self(6);
    pub const BUFF: Self = Self(7);
    pub const RELIC: Self = Self(8);
    pub const CAPSULE: Self = Self(9);
    pub const TRAP: Self = Self(10);
    pub const CHAT: Self = Self(11);
    pub const LANDMARK: Self = Self(12);
    pub const LOG: Self = Self(13);
    pub const ACTIVITY_ENTRY: Self = Self(14);
    pub const DYNAMIC_MUSIC: Self = Self(15);
    pub const DYNAMIC_PIC: Self = Self(16);
    pub const ENDBOOK: Self = Self(17);
    pub const DYNAMIC_STORY: Self = Self(18);
    pub const TOTEM: Self = Self(19);
    pub const CHAOS: Self = Self(20);
    pub const CHALLENGE_BOOK: Self = Self(21);
    pub const ACHIEVEMENT: Self = Self(22);
    pub const QUEST: Self = Self(23);
    pub const FRAGMENT: Self = Self(24);
    pub const DISASTER: Self = Self(25);
    pub const COPPER: Self = Self(26);
    pub const WRATH: Self = Self(27);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 27;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::TIMELINE,
        Self::MUSIC,
        Self::PIC,
        Self::AVG,
        Self::STORY,
        Self::NEWS,
        Self::BUFF,
        Self::RELIC,
        Self::CAPSULE,
        Self::TRAP,
        Self::CHAT,
        Self::LANDMARK,
        Self::LOG,
        Self::ACTIVITY_ENTRY,
        Self::DYNAMIC_MUSIC,
        Self::DYNAMIC_PIC,
        Self::ENDBOOK,
        Self::DYNAMIC_STORY,
        Self::TOTEM,
        Self::CHAOS,
        Self::CHALLENGE_BOOK,
        Self::ACHIEVEMENT,
        Self::QUEST,
        Self::FRAGMENT,
        Self::DISASTER,
        Self::COPPER,
        Self::WRATH,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TIMELINE => Some("TIMELINE"),
            Self::MUSIC => Some("MUSIC"),
            Self::PIC => Some("PIC"),
            Self::AVG => Some("AVG"),
            Self::STORY => Some("STORY"),
            Self::NEWS => Some("NEWS"),
            Self::BUFF => Some("BUFF"),
            Self::RELIC => Some("RELIC"),
            Self::CAPSULE => Some("CAPSULE"),
            Self::TRAP => Some("TRAP"),
            Self::CHAT => Some("CHAT"),
            Self::LANDMARK => Some("LANDMARK"),
            Self::LOG => Some("LOG"),
            Self::ACTIVITY_ENTRY => Some("ACTIVITY_ENTRY"),
            Self::DYNAMIC_MUSIC => Some("DYNAMIC_MUSIC"),
            Self::DYNAMIC_PIC => Some("DYNAMIC_PIC"),
            Self::ENDBOOK => Some("ENDBOOK"),
            Self::DYNAMIC_STORY => Some("DYNAMIC_STORY"),
            Self::TOTEM => Some("TOTEM"),
            Self::CHAOS => Some("CHAOS"),
            Self::CHALLENGE_BOOK => Some("CHALLENGE_BOOK"),
            Self::ACHIEVEMENT => Some("ACHIEVEMENT"),
            Self::QUEST => Some("QUEST"),
            Self::FRAGMENT => Some("FRAGMENT"),
            Self::DISASTER => Some("DISASTER"),
            Self::COPPER => Some("COPPER"),
            Self::WRATH => Some("WRATH"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ActArchiveType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ActArchiveType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ActArchiveType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ActArchiveType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ActArchiveType {
    type Output = enum__Torappu_ActArchiveType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ActArchiveType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ActArchiveType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ActArchiveType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ACT_17SIDE_DATA_ARCHIVE_ITEM_UNLOCK_CONDITION: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ACT_17SIDE_DATA_ARCHIVE_ITEM_UNLOCK_CONDITION: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ACT_17SIDE_DATA_ARCHIVE_ITEM_UNLOCK_CONDITION:
    [enum__Torappu_Act17sideData_ArchiveItemUnlockCondition; 3] = [
    enum__Torappu_Act17sideData_ArchiveItemUnlockCondition::NONE,
    enum__Torappu_Act17sideData_ArchiveItemUnlockCondition::STAGE,
    enum__Torappu_Act17sideData_ArchiveItemUnlockCondition::NODE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Act17sideData_ArchiveItemUnlockCondition(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Act17sideData_ArchiveItemUnlockCondition {
    pub const NONE: Self = Self(0);
    pub const STAGE: Self = Self(1);
    pub const NODE: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::STAGE, Self::NODE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::STAGE => Some("STAGE"),
            Self::NODE => Some("NODE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Act17sideData_ArchiveItemUnlockCondition {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_Act17sideData_ArchiveItemUnlockCondition {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_Act17sideData_ArchiveItemUnlockCondition",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Act17sideData_ArchiveItemUnlockCondition {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Act17sideData_ArchiveItemUnlockCondition {
    type Output = enum__Torappu_Act17sideData_ArchiveItemUnlockCondition;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Act17sideData_ArchiveItemUnlockCondition {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Act17sideData_ArchiveItemUnlockCondition {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_Act17sideData_ArchiveItemUnlockCondition {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ACT_17SIDE_DATA_ARCHIVE_ITEM_STAGE_UNLOCK_PARAM: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ACT_17SIDE_DATA_ARCHIVE_ITEM_STAGE_UNLOCK_PARAM: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ACT_17SIDE_DATA_ARCHIVE_ITEM_STAGE_UNLOCK_PARAM:
    [enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam; 4] = [
    enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam::NONE,
    enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam::PLAYED,
    enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam::PASS,
    enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam::COMPLETE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam {
    pub const NONE: Self = Self(0);
    pub const PLAYED: Self = Self(1);
    pub const PASS: Self = Self(2);
    pub const COMPLETE: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::PLAYED, Self::PASS, Self::COMPLETE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::PLAYED => Some("PLAYED"),
            Self::PASS => Some("PASS"),
            Self::COMPLETE => Some("COMPLETE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam {
    type Output = enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice
    for enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam
{
}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PROFESSION_CATEGORY: i32 = 512;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PROFESSION_CATEGORY: [enum__Torappu_ProfessionCategory; 11] = [
    enum__Torappu_ProfessionCategory::NONE,
    enum__Torappu_ProfessionCategory::WARRIOR,
    enum__Torappu_ProfessionCategory::SNIPER,
    enum__Torappu_ProfessionCategory::TANK,
    enum__Torappu_ProfessionCategory::MEDIC,
    enum__Torappu_ProfessionCategory::SUPPORT,
    enum__Torappu_ProfessionCategory::CASTER,
    enum__Torappu_ProfessionCategory::SPECIAL,
    enum__Torappu_ProfessionCategory::TOKEN,
    enum__Torappu_ProfessionCategory::TRAP,
    enum__Torappu_ProfessionCategory::PIONEER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ProfessionCategory(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ProfessionCategory {
    pub const NONE: Self = Self(0);
    pub const WARRIOR: Self = Self(1);
    pub const SNIPER: Self = Self(2);
    pub const TANK: Self = Self(4);
    pub const MEDIC: Self = Self(8);
    pub const SUPPORT: Self = Self(16);
    pub const CASTER: Self = Self(32);
    pub const SPECIAL: Self = Self(64);
    pub const TOKEN: Self = Self(128);
    pub const TRAP: Self = Self(256);
    pub const PIONEER: Self = Self(512);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 512;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::WARRIOR,
        Self::SNIPER,
        Self::TANK,
        Self::MEDIC,
        Self::SUPPORT,
        Self::CASTER,
        Self::SPECIAL,
        Self::TOKEN,
        Self::TRAP,
        Self::PIONEER,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::WARRIOR => Some("WARRIOR"),
            Self::SNIPER => Some("SNIPER"),
            Self::TANK => Some("TANK"),
            Self::MEDIC => Some("MEDIC"),
            Self::SUPPORT => Some("SUPPORT"),
            Self::CASTER => Some("CASTER"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::TOKEN => Some("TOKEN"),
            Self::TRAP => Some("TRAP"),
            Self::PIONEER => Some("PIONEER"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ProfessionCategory {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_ProfessionCategory {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_ProfessionCategory",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ProfessionCategory {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ProfessionCategory {
    type Output = enum__Torappu_ProfessionCategory;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ProfessionCategory {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ProfessionCategory {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ProfessionCategory {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDABLE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDABLE_TYPE: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDABLE_TYPE: [enum__Torappu_BuildableType; 4] = [
    enum__Torappu_BuildableType::NONE,
    enum__Torappu_BuildableType::MELEE,
    enum__Torappu_BuildableType::RANGED,
    enum__Torappu_BuildableType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildableType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildableType {
    pub const NONE: Self = Self(0);
    pub const MELEE: Self = Self(1);
    pub const RANGED: Self = Self(2);
    pub const ALL: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::MELEE, Self::RANGED, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MELEE => Some("MELEE"),
            Self::RANGED => Some("RANGED"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildableType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_BuildableType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_BuildableType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildableType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildableType {
    type Output = enum__Torappu_BuildableType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildableType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildableType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildableType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_PLAYER_SIDE_MASK: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_PLAYER_SIDE_MASK: u8 = 255;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_PLAYER_SIDE_MASK: [enum__Torappu_PlayerSideMask; 4] = [
    enum__Torappu_PlayerSideMask::ALL,
    enum__Torappu_PlayerSideMask::SIDE_A,
    enum__Torappu_PlayerSideMask::SIDE_B,
    enum__Torappu_PlayerSideMask::NONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_PlayerSideMask(pub u8);
#[allow(non_upper_case_globals)]
impl enum__Torappu_PlayerSideMask {
    pub const ALL: Self = Self(0);
    pub const SIDE_A: Self = Self(2);
    pub const SIDE_B: Self = Self(4);
    pub const NONE: Self = Self(255);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 255;
    pub const ENUM_VALUES: &'static [Self] = &[Self::ALL, Self::SIDE_A, Self::SIDE_B, Self::NONE];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ALL => Some("ALL"),
            Self::SIDE_A => Some("SIDE_A"),
            Self::SIDE_B => Some("SIDE_B"),
            Self::NONE => Some("NONE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_PlayerSideMask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_PlayerSideMask {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_PlayerSideMask",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_PlayerSideMask {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_PlayerSideMask {
    type Output = enum__Torappu_PlayerSideMask;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_PlayerSideMask {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_PlayerSideMask {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_PlayerSideMask {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BATTLE_SIDE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BATTLE_SIDE_TYPE: i32 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BATTLE_SIDE_TYPE: [enum__Torappu_Battle_SideType; 6] = [
    enum__Torappu_Battle_SideType::NONE,
    enum__Torappu_Battle_SideType::ALLY,
    enum__Torappu_Battle_SideType::ENEMY,
    enum__Torappu_Battle_SideType::BOTH_ALLY_AND_ENEMY,
    enum__Torappu_Battle_SideType::NEUTRAL,
    enum__Torappu_Battle_SideType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Battle_SideType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Battle_SideType {
    pub const NONE: Self = Self(0);
    pub const ALLY: Self = Self(1);
    pub const ENEMY: Self = Self(2);
    pub const BOTH_ALLY_AND_ENEMY: Self = Self(3);
    pub const NEUTRAL: Self = Self(4);
    pub const ALL: Self = Self(7);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ALLY,
        Self::ENEMY,
        Self::BOTH_ALLY_AND_ENEMY,
        Self::NEUTRAL,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ALLY => Some("ALLY"),
            Self::ENEMY => Some("ENEMY"),
            Self::BOTH_ALLY_AND_ENEMY => Some("BOTH_ALLY_AND_ENEMY"),
            Self::NEUTRAL => Some("NEUTRAL"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Battle_SideType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_Battle_SideType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_Battle_SideType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Battle_SideType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Battle_SideType {
    type Output = enum__Torappu_Battle_SideType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Battle_SideType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Battle_SideType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_Battle_SideType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_TILE_DATA_HEIGHT_TYPE_MASK: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_TILE_DATA_HEIGHT_TYPE_MASK: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_TILE_DATA_HEIGHT_TYPE_MASK:
    [enum__Torappu_TileData_HeightTypeMask; 4] = [
    enum__Torappu_TileData_HeightTypeMask::NONE,
    enum__Torappu_TileData_HeightTypeMask::LOWLAND,
    enum__Torappu_TileData_HeightTypeMask::HIGHLAND,
    enum__Torappu_TileData_HeightTypeMask::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_TileData_HeightTypeMask(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_TileData_HeightTypeMask {
    pub const NONE: Self = Self(0);
    pub const LOWLAND: Self = Self(1);
    pub const HIGHLAND: Self = Self(2);
    pub const ALL: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::LOWLAND, Self::HIGHLAND, Self::ALL];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::LOWLAND => Some("LOWLAND"),
            Self::HIGHLAND => Some("HIGHLAND"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_TileData_HeightTypeMask {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_TileData_HeightTypeMask {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_TileData_HeightTypeMask",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_TileData_HeightTypeMask {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_TileData_HeightTypeMask {
    type Output = enum__Torappu_TileData_HeightTypeMask;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_TileData_HeightTypeMask {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_TileData_HeightTypeMask {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_TileData_HeightTypeMask {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ACT_17SIDE_DATA_CHAPTER_ICON_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ACT_17SIDE_DATA_CHAPTER_ICON_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ACT_17SIDE_DATA_CHAPTER_ICON_TYPE:
    [enum__Torappu_Act17sideData_ChapterIconType; 3] = [
    enum__Torappu_Act17sideData_ChapterIconType::NORMAL,
    enum__Torappu_Act17sideData_ChapterIconType::EX,
    enum__Torappu_Act17sideData_ChapterIconType::HARD,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Act17sideData_ChapterIconType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Act17sideData_ChapterIconType {
    pub const NORMAL: Self = Self(0);
    pub const EX: Self = Self(1);
    pub const HARD: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NORMAL, Self::EX, Self::HARD];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NORMAL => Some("NORMAL"),
            Self::EX => Some("EX"),
            Self::HARD => Some("HARD"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Act17sideData_ChapterIconType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_Act17sideData_ChapterIconType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_Act17sideData_ChapterIconType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Act17sideData_ChapterIconType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Act17sideData_ChapterIconType {
    type Output = enum__Torappu_Act17sideData_ChapterIconType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Act17sideData_ChapterIconType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Act17sideData_ChapterIconType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_Act17sideData_ChapterIconType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ACT_25_SIDE_DATA_ACT_25SIDE_TECH_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ACT_25_SIDE_DATA_ACT_25SIDE_TECH_TYPE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ACT_25_SIDE_DATA_ACT_25SIDE_TECH_TYPE:
    [enum__Torappu_Act25SideData_Act25sideTechType; 5] = [
    enum__Torappu_Act25SideData_Act25sideTechType::TECH_1,
    enum__Torappu_Act25SideData_Act25sideTechType::TECH_2,
    enum__Torappu_Act25SideData_Act25sideTechType::TECH_3,
    enum__Torappu_Act25SideData_Act25sideTechType::TECH_4,
    enum__Torappu_Act25SideData_Act25sideTechType::TECH_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_Act25SideData_Act25sideTechType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_Act25SideData_Act25sideTechType {
    pub const TECH_1: Self = Self(0);
    pub const TECH_2: Self = Self(1);
    pub const TECH_3: Self = Self(2);
    pub const TECH_4: Self = Self(3);
    pub const TECH_NUM: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::TECH_1,
        Self::TECH_2,
        Self::TECH_3,
        Self::TECH_4,
        Self::TECH_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::TECH_1 => Some("TECH_1"),
            Self::TECH_2 => Some("TECH_2"),
            Self::TECH_3 => Some("TECH_3"),
            Self::TECH_4 => Some("TECH_4"),
            Self::TECH_NUM => Some("TECH_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_Act25SideData_Act25sideTechType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_Act25SideData_Act25sideTechType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_Act25SideData_Act25sideTechType",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_Act25SideData_Act25sideTechType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_Act25SideData_Act25sideTechType {
    type Output = enum__Torappu_Act25SideData_Act25sideTechType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_Act25SideData_Act25sideTechType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_Act25SideData_Act25sideTechType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_Act25SideData_Act25sideTechType {}
pub enum dict__string__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__string<'a> {
    type Inner = dict__string__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__string<'bldr>> {
        let mut builder = dict__string__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__stringT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| x.to_string());
        dict__string__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__string__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__stringT {
    pub key: String,
    pub value: Option<String>,
}
impl Default for dict__string__stringT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__string<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| _fbb.create_string(x));
        dict__string__string::create(_fbb, &dict__string__stringArgs { key, value })
    }
}
pub enum clz_Torappu_StageValidInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageValidInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageValidInfo<'a> {
    type Inner = clz_Torappu_StageValidInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageValidInfo<'a> {
    pub const VT_STARTTS: flatbuffers::VOffsetT = 4;
    pub const VT_ENDTS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageValidInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageValidInfoArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageValidInfo<'bldr>> {
        let mut builder = clz_Torappu_StageValidInfoBuilder::new(_fbb);
        builder.add_endTs(args.endTs);
        builder.add_startTs(args.startTs);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageValidInfoT {
        let startTs = self.startTs();
        let endTs = self.endTs();
        clz_Torappu_StageValidInfoT { startTs, endTs }
    }

    #[inline]
    pub fn startTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_StageValidInfo::VT_STARTTS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn endTs(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_StageValidInfo::VT_ENDTS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageValidInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("startTs", Self::VT_STARTTS, false)?
            .visit_field::<i64>("endTs", Self::VT_ENDTS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageValidInfoArgs {
    pub startTs: i64,
    pub endTs: i64,
}
impl<'a> Default for clz_Torappu_StageValidInfoArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageValidInfoArgs {
            startTs: 0,
            endTs: 0,
        }
    }
}

impl Serialize for clz_Torappu_StageValidInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageValidInfo", 2)?;
        s.serialize_field("startTs", &self.startTs())?;
        s.serialize_field("endTs", &self.endTs())?;
        s.end()
    }
}

pub struct clz_Torappu_StageValidInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_StageValidInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_startTs(&mut self, startTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_StageValidInfo::VT_STARTTS, startTs, 0);
    }
    #[inline]
    pub fn add_endTs(&mut self, endTs: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_StageValidInfo::VT_ENDTS, endTs, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageValidInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageValidInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageValidInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageValidInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageValidInfo");
        ds.field("startTs", &self.startTs());
        ds.field("endTs", &self.endTs());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageValidInfoT {
    pub startTs: i64,
    pub endTs: i64,
}
impl Default for clz_Torappu_StageValidInfoT {
    fn default() -> Self {
        Self {
            startTs: 0,
            endTs: 0,
        }
    }
}
impl clz_Torappu_StageValidInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageValidInfo<'b>> {
        let startTs = self.startTs;
        let endTs = self.endTs;
        clz_Torappu_StageValidInfo::create(_fbb, &clz_Torappu_StageValidInfoArgs { startTs, endTs })
    }
}
pub enum dict__string__clz_Torappu_StageValidInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_StageValidInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_StageValidInfo<'a> {
    type Inner = dict__string__clz_Torappu_StageValidInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_StageValidInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_StageValidInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_StageValidInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageValidInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_StageValidInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_StageValidInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_StageValidInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_StageValidInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_StageValidInfo) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_StageValidInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StageValidInfo>>(
                    dict__string__clz_Torappu_StageValidInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_StageValidInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StageValidInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_StageValidInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_StageValidInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_StageValidInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_StageValidInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_StageValidInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_StageValidInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_StageValidInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_StageValidInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_StageValidInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_StageValidInfo<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StageValidInfo>>(
                dict__string__clz_Torappu_StageValidInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_StageValidInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_StageValidInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageValidInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_StageValidInfo::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_StageValidInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_StageValidInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_StageValidInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_StageValidInfoT>>,
}
impl Default for dict__string__clz_Torappu_StageValidInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_StageValidInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageValidInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_StageValidInfo::create(
            _fbb,
            &dict__string__clz_Torappu_StageValidInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemBundle<'a> {
    type Inner = clz_Torappu_ItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'bldr>> {
        let mut builder = clz_Torappu_ItemBundleBuilder::new(_fbb);
        builder.add_type_(args.type_);
        builder.add_count(args.count);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ItemBundleT {
        let id = self.id().map(|x| x.to_string());
        let count = self.count();
        let type_ = self.type_();
        clz_Torappu_ItemBundleT { id, count, type_ }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemBundle::VT_ID, None)
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl<'a> Default for clz_Torappu_ItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemBundleArgs {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_ItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ItemBundle", 3)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("count", &self.count())?;
        s.serialize_field("type_", &self.type_())?;
        s.end()
    }
}

pub struct clz_Torappu_ItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemBundle");
        ds.field("id", &self.id());
        ds.field("count", &self.count());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ItemBundleT {
    pub id: Option<String>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl Default for clz_Torappu_ItemBundleT {
    fn default() -> Self {
        Self {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}
impl clz_Torappu_ItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let count = self.count;
        let type_ = self.type_;
        clz_Torappu_ItemBundle::create(_fbb, &clz_Torappu_ItemBundleArgs { id, count, type_ })
    }
}
pub enum clz_Torappu_WeightItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_WeightItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_WeightItemBundle<'a> {
    type Inner = clz_Torappu_WeightItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_WeightItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_DROPTYPE: flatbuffers::VOffsetT = 8;
    pub const VT_COUNT: flatbuffers::VOffsetT = 10;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_WeightItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_WeightItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_WeightItemBundle<'bldr>> {
        let mut builder = clz_Torappu_WeightItemBundleBuilder::new(_fbb);
        builder.add_weight(args.weight);
        builder.add_count(args.count);
        builder.add_dropType(args.dropType);
        builder.add_type_(args.type_);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_WeightItemBundleT {
        let id = self.id().map(|x| x.to_string());
        let type_ = self.type_();
        let dropType = self.dropType();
        let count = self.count();
        let weight = self.weight();
        clz_Torappu_WeightItemBundleT {
            id,
            type_,
            dropType,
            count,
            weight,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_WeightItemBundle::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_WeightItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn dropType(&self) -> enum__Torappu_StageDropType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDropType>(
                    clz_Torappu_WeightItemBundle::VT_DROPTYPE,
                    Some(enum__Torappu_StageDropType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_WeightItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn weight(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_WeightItemBundle::VT_WEIGHT, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_WeightItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<enum__Torappu_StageDropType>("dropType", Self::VT_DROPTYPE, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<i32>("weight", Self::VT_WEIGHT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_WeightItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_ItemType,
    pub dropType: enum__Torappu_StageDropType,
    pub count: i32,
    pub weight: i32,
}
impl<'a> Default for clz_Torappu_WeightItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_WeightItemBundleArgs {
            id: None,
            type_: enum__Torappu_ItemType::NONE,
            dropType: enum__Torappu_StageDropType::NONE,
            count: 0,
            weight: 0,
        }
    }
}

impl Serialize for clz_Torappu_WeightItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_WeightItemBundle", 5)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("type_", &self.type_())?;
        s.serialize_field("dropType", &self.dropType())?;
        s.serialize_field("count", &self.count())?;
        s.serialize_field("weight", &self.weight())?;
        s.end()
    }
}

pub struct clz_Torappu_WeightItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_WeightItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_WeightItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_WeightItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_dropType(&mut self, dropType: enum__Torappu_StageDropType) {
        self.fbb_.push_slot::<enum__Torappu_StageDropType>(
            clz_Torappu_WeightItemBundle::VT_DROPTYPE,
            dropType,
            enum__Torappu_StageDropType::NONE,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_WeightItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_weight(&mut self, weight: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_WeightItemBundle::VT_WEIGHT, weight, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_WeightItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_WeightItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_WeightItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_WeightItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_WeightItemBundle");
        ds.field("id", &self.id());
        ds.field("type_", &self.type_());
        ds.field("dropType", &self.dropType());
        ds.field("count", &self.count());
        ds.field("weight", &self.weight());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_WeightItemBundleT {
    pub id: Option<String>,
    pub type_: enum__Torappu_ItemType,
    pub dropType: enum__Torappu_StageDropType,
    pub count: i32,
    pub weight: i32,
}
impl Default for clz_Torappu_WeightItemBundleT {
    fn default() -> Self {
        Self {
            id: None,
            type_: enum__Torappu_ItemType::NONE,
            dropType: enum__Torappu_StageDropType::NONE,
            count: 0,
            weight: 0,
        }
    }
}
impl clz_Torappu_WeightItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_WeightItemBundle<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let dropType = self.dropType;
        let count = self.count;
        let weight = self.weight;
        clz_Torappu_WeightItemBundle::create(
            _fbb,
            &clz_Torappu_WeightItemBundleArgs {
                id,
                type_,
                dropType,
                count,
                weight,
            },
        )
    }
}
pub enum list_clz_Torappu_WeightItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct list_clz_Torappu_WeightItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for list_clz_Torappu_WeightItemBundle<'a> {
    type Inner = list_clz_Torappu_WeightItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> list_clz_Torappu_WeightItemBundle<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        list_clz_Torappu_WeightItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args list_clz_Torappu_WeightItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<list_clz_Torappu_WeightItemBundle<'bldr>> {
        let mut builder = list_clz_Torappu_WeightItemBundleBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> list_clz_Torappu_WeightItemBundleT {
        let values = self
            .values()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        list_clz_Torappu_WeightItemBundleT { values }
    }

    #[inline]
    pub fn values(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle>>,
            >>(list_clz_Torappu_WeightItemBundle::VT_VALUES, None)
        }
    }
}

impl flatbuffers::Verifiable for list_clz_Torappu_WeightItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle>>,
            >>("values", Self::VT_VALUES, false)?
            .finish();
        Ok(())
    }
}
pub struct list_clz_Torappu_WeightItemBundleArgs<'a> {
    pub values: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for list_clz_Torappu_WeightItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        list_clz_Torappu_WeightItemBundleArgs { values: None }
    }
}

impl Serialize for list_clz_Torappu_WeightItemBundle<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("list_clz_Torappu_WeightItemBundle", 1)?;
        if let Some(f) = self.values() {
            s.serialize_field("values", &f)?;
        } else {
            s.skip_field("values")?;
        }
        s.end()
    }
}

pub struct list_clz_Torappu_WeightItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    list_clz_Torappu_WeightItemBundleBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_values(
        &mut self,
        values: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_WeightItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            list_clz_Torappu_WeightItemBundle::VT_VALUES,
            values,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> list_clz_Torappu_WeightItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        list_clz_Torappu_WeightItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<list_clz_Torappu_WeightItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for list_clz_Torappu_WeightItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("list_clz_Torappu_WeightItemBundle");
        ds.field("values", &self.values());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct list_clz_Torappu_WeightItemBundleT {
    pub values: Option<Vec<clz_Torappu_WeightItemBundleT>>,
}
impl Default for list_clz_Torappu_WeightItemBundleT {
    fn default() -> Self {
        Self { values: None }
    }
}
impl list_clz_Torappu_WeightItemBundleT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<list_clz_Torappu_WeightItemBundle<'b>> {
        let values = self.values.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        list_clz_Torappu_WeightItemBundle::create(
            _fbb,
            &list_clz_Torappu_WeightItemBundleArgs { values },
        )
    }
}
pub enum clz_Torappu_StageData_DisplayRewardsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_DisplayRewards<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_DisplayRewards<'a> {
    type Inner = clz_Torappu_StageData_DisplayRewards<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_DisplayRewards<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_DROPTYPE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_DisplayRewards { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_DisplayRewardsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayRewards<'bldr>> {
        let mut builder = clz_Torappu_StageData_DisplayRewardsBuilder::new(_fbb);
        builder.add_dropType(args.dropType);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_DisplayRewardsT {
        let type_ = self.type_();
        let id = self.id().map(|x| x.to_string());
        let dropType = self.dropType();
        clz_Torappu_StageData_DisplayRewardsT {
            type_,
            id,
            dropType,
        }
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_StageData_DisplayRewards::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_DisplayRewards::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn dropType(&self) -> enum__Torappu_StageDropType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDropType>(
                    clz_Torappu_StageData_DisplayRewards::VT_DROPTYPE,
                    Some(enum__Torappu_StageDropType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_DisplayRewards<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_StageDropType>("dropType", Self::VT_DROPTYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_DisplayRewardsArgs<'a> {
    pub type_: enum__Torappu_ItemType,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dropType: enum__Torappu_StageDropType,
}
impl<'a> Default for clz_Torappu_StageData_DisplayRewardsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_DisplayRewardsArgs {
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_StageData_DisplayRewards<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_DisplayRewards", 3)?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("dropType", &self.dropType())?;
        s.end()
    }
}

pub struct clz_Torappu_StageData_DisplayRewardsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_DisplayRewardsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_StageData_DisplayRewards::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_DisplayRewards::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_dropType(&mut self, dropType: enum__Torappu_StageDropType) {
        self.fbb_.push_slot::<enum__Torappu_StageDropType>(
            clz_Torappu_StageData_DisplayRewards::VT_DROPTYPE,
            dropType,
            enum__Torappu_StageDropType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_DisplayRewardsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_DisplayRewardsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayRewards<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_DisplayRewards<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_DisplayRewards");
        ds.field("type_", &self.type_());
        ds.field("id", &self.id());
        ds.field("dropType", &self.dropType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_DisplayRewardsT {
    pub type_: enum__Torappu_ItemType,
    pub id: Option<String>,
    pub dropType: enum__Torappu_StageDropType,
}
impl Default for clz_Torappu_StageData_DisplayRewardsT {
    fn default() -> Self {
        Self {
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}
impl clz_Torappu_StageData_DisplayRewardsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayRewards<'b>> {
        let type_ = self.type_;
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let dropType = self.dropType;
        clz_Torappu_StageData_DisplayRewards::create(
            _fbb,
            &clz_Torappu_StageData_DisplayRewardsArgs {
                type_,
                id,
                dropType,
            },
        )
    }
}
pub enum clz_Torappu_StageData_DisplayDetailRewardsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_DisplayDetailRewards<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_DisplayDetailRewards<'a> {
    type Inner = clz_Torappu_StageData_DisplayDetailRewards<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_DisplayDetailRewards<'a> {
    pub const VT_OCCPERCENT: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_ID: flatbuffers::VOffsetT = 8;
    pub const VT_DROPTYPE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_DisplayDetailRewards { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_DisplayDetailRewardsArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayDetailRewards<'bldr>> {
        let mut builder = clz_Torappu_StageData_DisplayDetailRewardsBuilder::new(_fbb);
        builder.add_dropType(args.dropType);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_type_(args.type_);
        builder.add_occPercent(args.occPercent);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_DisplayDetailRewardsT {
        let occPercent = self.occPercent();
        let type_ = self.type_();
        let id = self.id().map(|x| x.to_string());
        let dropType = self.dropType();
        clz_Torappu_StageData_DisplayDetailRewardsT {
            occPercent,
            type_,
            id,
            dropType,
        }
    }

    #[inline]
    pub fn occPercent(&self) -> enum__Torappu_OccPer {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_OccPer>(
                    clz_Torappu_StageData_DisplayDetailRewards::VT_OCCPERCENT,
                    Some(enum__Torappu_OccPer::ALWAYS),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_StageData_DisplayDetailRewards::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_DisplayDetailRewards::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn dropType(&self) -> enum__Torappu_StageDropType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDropType>(
                    clz_Torappu_StageData_DisplayDetailRewards::VT_DROPTYPE,
                    Some(enum__Torappu_StageDropType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_DisplayDetailRewards<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_OccPer>("occPercent", Self::VT_OCCPERCENT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<enum__Torappu_StageDropType>("dropType", Self::VT_DROPTYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_DisplayDetailRewardsArgs<'a> {
    pub occPercent: enum__Torappu_OccPer,
    pub type_: enum__Torappu_ItemType,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dropType: enum__Torappu_StageDropType,
}
impl<'a> Default for clz_Torappu_StageData_DisplayDetailRewardsArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_DisplayDetailRewardsArgs {
            occPercent: enum__Torappu_OccPer::ALWAYS,
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}

impl Serialize for clz_Torappu_StageData_DisplayDetailRewards<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_DisplayDetailRewards", 4)?;
        s.serialize_field("occPercent", &self.occPercent())?;
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("dropType", &self.dropType())?;
        s.end()
    }
}

pub struct clz_Torappu_StageData_DisplayDetailRewardsBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_DisplayDetailRewardsBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_occPercent(&mut self, occPercent: enum__Torappu_OccPer) {
        self.fbb_.push_slot::<enum__Torappu_OccPer>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_OCCPERCENT,
            occPercent,
            enum__Torappu_OccPer::ALWAYS,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_dropType(&mut self, dropType: enum__Torappu_StageDropType) {
        self.fbb_.push_slot::<enum__Torappu_StageDropType>(
            clz_Torappu_StageData_DisplayDetailRewards::VT_DROPTYPE,
            dropType,
            enum__Torappu_StageDropType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_DisplayDetailRewardsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_DisplayDetailRewardsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayDetailRewards<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_DisplayDetailRewards<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_DisplayDetailRewards");
        ds.field("occPercent", &self.occPercent());
        ds.field("type_", &self.type_());
        ds.field("id", &self.id());
        ds.field("dropType", &self.dropType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_DisplayDetailRewardsT {
    pub occPercent: enum__Torappu_OccPer,
    pub type_: enum__Torappu_ItemType,
    pub id: Option<String>,
    pub dropType: enum__Torappu_StageDropType,
}
impl Default for clz_Torappu_StageData_DisplayDetailRewardsT {
    fn default() -> Self {
        Self {
            occPercent: enum__Torappu_OccPer::ALWAYS,
            type_: enum__Torappu_ItemType::NONE,
            id: None,
            dropType: enum__Torappu_StageDropType::NONE,
        }
    }
}
impl clz_Torappu_StageData_DisplayDetailRewardsT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_DisplayDetailRewards<'b>> {
        let occPercent = self.occPercent;
        let type_ = self.type_;
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let dropType = self.dropType;
        clz_Torappu_StageData_DisplayDetailRewards::create(
            _fbb,
            &clz_Torappu_StageData_DisplayDetailRewardsArgs {
                occPercent,
                type_,
                id,
                dropType,
            },
        )
    }
}
pub enum clz_Torappu_StageData_StageDropInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_StageDropInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_StageDropInfo<'a> {
    type Inner = clz_Torappu_StageData_StageDropInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_StageDropInfo<'a> {
    pub const VT_FIRSTPASSREWARDS: flatbuffers::VOffsetT = 4;
    pub const VT_FIRSTCOMPLETEREWARDS: flatbuffers::VOffsetT = 6;
    pub const VT_PASSREWARDS: flatbuffers::VOffsetT = 8;
    pub const VT_COMPLETEREWARDS: flatbuffers::VOffsetT = 10;
    pub const VT_DISPLAYREWARDS: flatbuffers::VOffsetT = 12;
    pub const VT_DISPLAYDETAILREWARDS: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_StageDropInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_StageDropInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo<'bldr>> {
        let mut builder = clz_Torappu_StageData_StageDropInfoBuilder::new(_fbb);
        if let Some(x) = args.displayDetailRewards {
            builder.add_displayDetailRewards(x);
        }
        if let Some(x) = args.displayRewards {
            builder.add_displayRewards(x);
        }
        if let Some(x) = args.completeRewards {
            builder.add_completeRewards(x);
        }
        if let Some(x) = args.passRewards {
            builder.add_passRewards(x);
        }
        if let Some(x) = args.firstCompleteRewards {
            builder.add_firstCompleteRewards(x);
        }
        if let Some(x) = args.firstPassRewards {
            builder.add_firstPassRewards(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_StageDropInfoT {
        let firstPassRewards = self
            .firstPassRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let firstCompleteRewards = self
            .firstCompleteRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let passRewards = self
            .passRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let completeRewards = self
            .completeRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let displayRewards = self
            .displayRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let displayDetailRewards = self
            .displayDetailRewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_StageData_StageDropInfoT {
            firstPassRewards,
            firstCompleteRewards,
            passRewards,
            completeRewards,
            displayRewards,
            displayDetailRewards,
        }
    }

    #[inline]
    pub fn firstPassRewards(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(
                clz_Torappu_StageData_StageDropInfo::VT_FIRSTPASSREWARDS,
                None,
            )
        }
    }
    #[inline]
    pub fn firstCompleteRewards(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(
                clz_Torappu_StageData_StageDropInfo::VT_FIRSTCOMPLETEREWARDS,
                None,
            )
        }
    }
    #[inline]
    pub fn passRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle>,
                >,
            >>(clz_Torappu_StageData_StageDropInfo::VT_PASSREWARDS, None)
        }
    }
    #[inline]
    pub fn completeRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle>,
                >,
            >>(
                clz_Torappu_StageData_StageDropInfo::VT_COMPLETEREWARDS,
                None,
            )
        }
    }
    #[inline]
    pub fn displayRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards>,
                >,
            >>(clz_Torappu_StageData_StageDropInfo::VT_DISPLAYREWARDS, None)
        }
    }
    #[inline]
    pub fn displayDetailRewards(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards>,
                >,
            >>(
                clz_Torappu_StageData_StageDropInfo::VT_DISPLAYDETAILREWARDS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_StageDropInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("firstPassRewards", Self::VT_FIRSTPASSREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("firstCompleteRewards", Self::VT_FIRSTCOMPLETEREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle>,
                >,
            >>("passRewards", Self::VT_PASSREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle>,
                >,
            >>("completeRewards", Self::VT_COMPLETEREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards>,
                >,
            >>("displayRewards", Self::VT_DISPLAYREWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards>,
                >,
            >>("displayDetailRewards", Self::VT_DISPLAYDETAILREWARDS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_StageDropInfoArgs<'a> {
    pub firstPassRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
    pub firstCompleteRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
    pub passRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'a>>,
            >,
        >,
    >,
    pub completeRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'a>>,
            >,
        >,
    >,
    pub displayRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards<'a>>,
            >,
        >,
    >,
    pub displayDetailRewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_StageData_StageDropInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_StageDropInfoArgs {
            firstPassRewards: None,
            firstCompleteRewards: None,
            passRewards: None,
            completeRewards: None,
            displayRewards: None,
            displayDetailRewards: None,
        }
    }
}

impl Serialize for clz_Torappu_StageData_StageDropInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_StageDropInfo", 6)?;
        if let Some(f) = self.firstPassRewards() {
            s.serialize_field("firstPassRewards", &f)?;
        } else {
            s.skip_field("firstPassRewards")?;
        }
        if let Some(f) = self.firstCompleteRewards() {
            s.serialize_field("firstCompleteRewards", &f)?;
        } else {
            s.skip_field("firstCompleteRewards")?;
        }
        if let Some(f) = self.passRewards() {
            s.serialize_field("passRewards", &f)?;
        } else {
            s.skip_field("passRewards")?;
        }
        if let Some(f) = self.completeRewards() {
            s.serialize_field("completeRewards", &f)?;
        } else {
            s.skip_field("completeRewards")?;
        }
        if let Some(f) = self.displayRewards() {
            s.serialize_field("displayRewards", &f)?;
        } else {
            s.skip_field("displayRewards")?;
        }
        if let Some(f) = self.displayDetailRewards() {
            s.serialize_field("displayDetailRewards", &f)?;
        } else {
            s.skip_field("displayDetailRewards")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StageData_StageDropInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_StageDropInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_firstPassRewards(
        &mut self,
        firstPassRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_StageDropInfo::VT_FIRSTPASSREWARDS,
            firstPassRewards,
        );
    }
    #[inline]
    pub fn add_firstCompleteRewards(
        &mut self,
        firstCompleteRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_StageDropInfo::VT_FIRSTCOMPLETEREWARDS,
            firstCompleteRewards,
        );
    }
    #[inline]
    pub fn add_passRewards(
        &mut self,
        passRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_StageDropInfo::VT_PASSREWARDS,
            passRewards,
        );
    }
    #[inline]
    pub fn add_completeRewards(
        &mut self,
        completeRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<list_clz_Torappu_WeightItemBundle<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_StageDropInfo::VT_COMPLETEREWARDS,
            completeRewards,
        );
    }
    #[inline]
    pub fn add_displayRewards(
        &mut self,
        displayRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayRewards<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_StageDropInfo::VT_DISPLAYREWARDS,
            displayRewards,
        );
    }
    #[inline]
    pub fn add_displayDetailRewards(
        &mut self,
        displayDetailRewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_DisplayDetailRewards<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_StageDropInfo::VT_DISPLAYDETAILREWARDS,
            displayDetailRewards,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_StageDropInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_StageDropInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_StageDropInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_StageDropInfo");
        ds.field("firstPassRewards", &self.firstPassRewards());
        ds.field("firstCompleteRewards", &self.firstCompleteRewards());
        ds.field("passRewards", &self.passRewards());
        ds.field("completeRewards", &self.completeRewards());
        ds.field("displayRewards", &self.displayRewards());
        ds.field("displayDetailRewards", &self.displayDetailRewards());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_StageDropInfoT {
    pub firstPassRewards: Option<Vec<clz_Torappu_ItemBundleT>>,
    pub firstCompleteRewards: Option<Vec<clz_Torappu_ItemBundleT>>,
    pub passRewards: Option<Vec<list_clz_Torappu_WeightItemBundleT>>,
    pub completeRewards: Option<Vec<list_clz_Torappu_WeightItemBundleT>>,
    pub displayRewards: Option<Vec<clz_Torappu_StageData_DisplayRewardsT>>,
    pub displayDetailRewards: Option<Vec<clz_Torappu_StageData_DisplayDetailRewardsT>>,
}
impl Default for clz_Torappu_StageData_StageDropInfoT {
    fn default() -> Self {
        Self {
            firstPassRewards: None,
            firstCompleteRewards: None,
            passRewards: None,
            completeRewards: None,
            displayRewards: None,
            displayDetailRewards: None,
        }
    }
}
impl clz_Torappu_StageData_StageDropInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo<'b>> {
        let firstPassRewards = self.firstPassRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let firstCompleteRewards = self.firstCompleteRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let passRewards = self.passRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let completeRewards = self.completeRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let displayRewards = self.displayRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let displayDetailRewards = self.displayDetailRewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_StageData_StageDropInfo::create(
            _fbb,
            &clz_Torappu_StageData_StageDropInfoArgs {
                firstPassRewards,
                firstCompleteRewards,
                passRewards,
                completeRewards,
                displayRewards,
                displayDetailRewards,
            },
        )
    }
}
pub enum clz_Torappu_RetroStageOverrideInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RetroStageOverrideInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RetroStageOverrideInfo<'a> {
    type Inner = clz_Torappu_RetroStageOverrideInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RetroStageOverrideInfo<'a> {
    pub const VT_DROPINFO: flatbuffers::VOffsetT = 4;
    pub const VT_ZONEID: flatbuffers::VOffsetT = 6;
    pub const VT_APCOST: flatbuffers::VOffsetT = 8;
    pub const VT_APFAILRETURN: flatbuffers::VOffsetT = 10;
    pub const VT_EXPGAIN: flatbuffers::VOffsetT = 12;
    pub const VT_GOLDGAIN: flatbuffers::VOffsetT = 14;
    pub const VT_PASSFAVOR: flatbuffers::VOffsetT = 16;
    pub const VT_COMPLETEFAVOR: flatbuffers::VOffsetT = 18;
    pub const VT_CANMULTIPLEBATTLE: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RetroStageOverrideInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RetroStageOverrideInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RetroStageOverrideInfo<'bldr>> {
        let mut builder = clz_Torappu_RetroStageOverrideInfoBuilder::new(_fbb);
        builder.add_completeFavor(args.completeFavor);
        builder.add_passFavor(args.passFavor);
        builder.add_goldGain(args.goldGain);
        builder.add_expGain(args.expGain);
        builder.add_apFailReturn(args.apFailReturn);
        builder.add_apCost(args.apCost);
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        if let Some(x) = args.dropInfo {
            builder.add_dropInfo(x);
        }
        builder.add_canMultipleBattle(args.canMultipleBattle);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RetroStageOverrideInfoT {
        let dropInfo = self.dropInfo().map(|x| Box::new(x.unpack()));
        let zoneId = self.zoneId().map(|x| x.to_string());
        let apCost = self.apCost();
        let apFailReturn = self.apFailReturn();
        let expGain = self.expGain();
        let goldGain = self.goldGain();
        let passFavor = self.passFavor();
        let completeFavor = self.completeFavor();
        let canMultipleBattle = self.canMultipleBattle();
        clz_Torappu_RetroStageOverrideInfoT {
            dropInfo,
            zoneId,
            apCost,
            apFailReturn,
            expGain,
            goldGain,
            passFavor,
            completeFavor,
            canMultipleBattle,
        }
    }

    #[inline]
    pub fn dropInfo(&self) -> Option<clz_Torappu_StageData_StageDropInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData_StageDropInfo>>(
                    clz_Torappu_RetroStageOverrideInfo::VT_DROPINFO,
                    None,
                )
        }
    }
    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RetroStageOverrideInfo::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn apCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RetroStageOverrideInfo::VT_APCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn apFailReturn(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RetroStageOverrideInfo::VT_APFAILRETURN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn expGain(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RetroStageOverrideInfo::VT_EXPGAIN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn goldGain(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RetroStageOverrideInfo::VT_GOLDGAIN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn passFavor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RetroStageOverrideInfo::VT_PASSFAVOR, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn completeFavor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_RetroStageOverrideInfo::VT_COMPLETEFAVOR,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn canMultipleBattle(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_RetroStageOverrideInfo::VT_CANMULTIPLEBATTLE,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RetroStageOverrideInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData_StageDropInfo>>(
                "dropInfo",
                Self::VT_DROPINFO,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<i32>("apCost", Self::VT_APCOST, false)?
            .visit_field::<i32>("apFailReturn", Self::VT_APFAILRETURN, false)?
            .visit_field::<i32>("expGain", Self::VT_EXPGAIN, false)?
            .visit_field::<i32>("goldGain", Self::VT_GOLDGAIN, false)?
            .visit_field::<i32>("passFavor", Self::VT_PASSFAVOR, false)?
            .visit_field::<i32>("completeFavor", Self::VT_COMPLETEFAVOR, false)?
            .visit_field::<bool>("canMultipleBattle", Self::VT_CANMULTIPLEBATTLE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RetroStageOverrideInfoArgs<'a> {
    pub dropInfo: Option<flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo<'a>>>,
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub apCost: i32,
    pub apFailReturn: i32,
    pub expGain: i32,
    pub goldGain: i32,
    pub passFavor: i32,
    pub completeFavor: i32,
    pub canMultipleBattle: bool,
}
impl<'a> Default for clz_Torappu_RetroStageOverrideInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RetroStageOverrideInfoArgs {
            dropInfo: None,
            zoneId: None,
            apCost: 0,
            apFailReturn: 0,
            expGain: 0,
            goldGain: 0,
            passFavor: 0,
            completeFavor: 0,
            canMultipleBattle: false,
        }
    }
}

impl Serialize for clz_Torappu_RetroStageOverrideInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RetroStageOverrideInfo", 9)?;
        if let Some(f) = self.dropInfo() {
            s.serialize_field("dropInfo", &f)?;
        } else {
            s.skip_field("dropInfo")?;
        }
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        s.serialize_field("apCost", &self.apCost())?;
        s.serialize_field("apFailReturn", &self.apFailReturn())?;
        s.serialize_field("expGain", &self.expGain())?;
        s.serialize_field("goldGain", &self.goldGain())?;
        s.serialize_field("passFavor", &self.passFavor())?;
        s.serialize_field("completeFavor", &self.completeFavor())?;
        s.serialize_field("canMultipleBattle", &self.canMultipleBattle())?;
        s.end()
    }
}

pub struct clz_Torappu_RetroStageOverrideInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RetroStageOverrideInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_dropInfo(
        &mut self,
        dropInfo: flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo>>(
                clz_Torappu_RetroStageOverrideInfo::VT_DROPINFO,
                dropInfo,
            );
    }
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroStageOverrideInfo::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_apCost(&mut self, apCost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RetroStageOverrideInfo::VT_APCOST, apCost, 0);
    }
    #[inline]
    pub fn add_apFailReturn(&mut self, apFailReturn: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RetroStageOverrideInfo::VT_APFAILRETURN,
            apFailReturn,
            0,
        );
    }
    #[inline]
    pub fn add_expGain(&mut self, expGain: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RetroStageOverrideInfo::VT_EXPGAIN, expGain, 0);
    }
    #[inline]
    pub fn add_goldGain(&mut self, goldGain: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RetroStageOverrideInfo::VT_GOLDGAIN, goldGain, 0);
    }
    #[inline]
    pub fn add_passFavor(&mut self, passFavor: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RetroStageOverrideInfo::VT_PASSFAVOR,
            passFavor,
            0,
        );
    }
    #[inline]
    pub fn add_completeFavor(&mut self, completeFavor: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RetroStageOverrideInfo::VT_COMPLETEFAVOR,
            completeFavor,
            0,
        );
    }
    #[inline]
    pub fn add_canMultipleBattle(&mut self, canMultipleBattle: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_RetroStageOverrideInfo::VT_CANMULTIPLEBATTLE,
            canMultipleBattle,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RetroStageOverrideInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RetroStageOverrideInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RetroStageOverrideInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RetroStageOverrideInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RetroStageOverrideInfo");
        ds.field("dropInfo", &self.dropInfo());
        ds.field("zoneId", &self.zoneId());
        ds.field("apCost", &self.apCost());
        ds.field("apFailReturn", &self.apFailReturn());
        ds.field("expGain", &self.expGain());
        ds.field("goldGain", &self.goldGain());
        ds.field("passFavor", &self.passFavor());
        ds.field("completeFavor", &self.completeFavor());
        ds.field("canMultipleBattle", &self.canMultipleBattle());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RetroStageOverrideInfoT {
    pub dropInfo: Option<Box<clz_Torappu_StageData_StageDropInfoT>>,
    pub zoneId: Option<String>,
    pub apCost: i32,
    pub apFailReturn: i32,
    pub expGain: i32,
    pub goldGain: i32,
    pub passFavor: i32,
    pub completeFavor: i32,
    pub canMultipleBattle: bool,
}
impl Default for clz_Torappu_RetroStageOverrideInfoT {
    fn default() -> Self {
        Self {
            dropInfo: None,
            zoneId: None,
            apCost: 0,
            apFailReturn: 0,
            expGain: 0,
            goldGain: 0,
            passFavor: 0,
            completeFavor: 0,
            canMultipleBattle: false,
        }
    }
}
impl clz_Torappu_RetroStageOverrideInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RetroStageOverrideInfo<'b>> {
        let dropInfo = self.dropInfo.as_ref().map(|x| x.pack(_fbb));
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let apCost = self.apCost;
        let apFailReturn = self.apFailReturn;
        let expGain = self.expGain;
        let goldGain = self.goldGain;
        let passFavor = self.passFavor;
        let completeFavor = self.completeFavor;
        let canMultipleBattle = self.canMultipleBattle;
        clz_Torappu_RetroStageOverrideInfo::create(
            _fbb,
            &clz_Torappu_RetroStageOverrideInfoArgs {
                dropInfo,
                zoneId,
                apCost,
                apFailReturn,
                expGain,
                goldGain,
                passFavor,
                completeFavor,
                canMultipleBattle,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RetroStageOverrideInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RetroStageOverrideInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RetroStageOverrideInfo<'a> {
    type Inner = dict__string__clz_Torappu_RetroStageOverrideInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RetroStageOverrideInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RetroStageOverrideInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RetroStageOverrideInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RetroStageOverrideInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RetroStageOverrideInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RetroStageOverrideInfoT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RetroStageOverrideInfoT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RetroStageOverrideInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_RetroStageOverrideInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RetroStageOverrideInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RetroStageOverrideInfo>>(
                    dict__string__clz_Torappu_RetroStageOverrideInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RetroStageOverrideInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RetroStageOverrideInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RetroStageOverrideInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RetroStageOverrideInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RetroStageOverrideInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RetroStageOverrideInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RetroStageOverrideInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_RetroStageOverrideInfo", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RetroStageOverrideInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RetroStageOverrideInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RetroStageOverrideInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_RetroStageOverrideInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RetroStageOverrideInfo>>(
                dict__string__clz_Torappu_RetroStageOverrideInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RetroStageOverrideInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RetroStageOverrideInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RetroStageOverrideInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_RetroStageOverrideInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RetroStageOverrideInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RetroStageOverrideInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RetroStageOverrideInfoT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RetroStageOverrideInfoT>>,
}
impl Default for dict__string__clz_Torappu_RetroStageOverrideInfoT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RetroStageOverrideInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RetroStageOverrideInfo<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RetroStageOverrideInfo::create(
            _fbb,
            &dict__string__clz_Torappu_RetroStageOverrideInfoArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RetroActDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RetroActData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RetroActData<'a> {
    type Inner = clz_Torappu_RetroActData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RetroActData<'a> {
    pub const VT_RETROID: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
    pub const VT_LINKEDACTID: flatbuffers::VOffsetT = 8;
    pub const VT_STARTTIME: flatbuffers::VOffsetT = 10;
    pub const VT_TRAILSTARTTIME: flatbuffers::VOffsetT = 12;
    pub const VT_INDEX: flatbuffers::VOffsetT = 14;
    pub const VT_NAME: flatbuffers::VOffsetT = 16;
    pub const VT_HAVETRAIL: flatbuffers::VOffsetT = 18;
    pub const VT_CUSTOMACTID: flatbuffers::VOffsetT = 20;
    pub const VT_CUSTOMACTTYPE: flatbuffers::VOffsetT = 22;
    pub const VT_TRAPDOMAINID: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RetroActData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RetroActDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RetroActData<'bldr>> {
        let mut builder = clz_Torappu_RetroActDataBuilder::new(_fbb);
        builder.add_trailStartTime(args.trailStartTime);
        builder.add_startTime(args.startTime);
        if let Some(x) = args.trapDomainId {
            builder.add_trapDomainId(x);
        }
        builder.add_customActType(args.customActType);
        if let Some(x) = args.customActId {
            builder.add_customActId(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_index(args.index);
        if let Some(x) = args.linkedActId {
            builder.add_linkedActId(x);
        }
        builder.add_type_(args.type_);
        if let Some(x) = args.retroId {
            builder.add_retroId(x);
        }
        builder.add_haveTrail(args.haveTrail);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RetroActDataT {
        let retroId = self.retroId().map(|x| x.to_string());
        let type_ = self.type_();
        let linkedActId = self
            .linkedActId()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let startTime = self.startTime();
        let trailStartTime = self.trailStartTime();
        let index = self.index();
        let name = self.name().map(|x| x.to_string());
        let haveTrail = self.haveTrail();
        let customActId = self.customActId().map(|x| x.to_string());
        let customActType = self.customActType();
        let trapDomainId = self.trapDomainId().map(|x| x.to_string());
        clz_Torappu_RetroActDataT {
            retroId,
            type_,
            linkedActId,
            startTime,
            trailStartTime,
            index,
            name,
            haveTrail,
            customActId,
            customActType,
            trapDomainId,
        }
    }

    #[inline]
    pub fn retroId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RetroActData::VT_RETROID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_RetroType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_RetroType>(
                    clz_Torappu_RetroActData::VT_TYPE_,
                    Some(enum__Torappu_RetroType::SIDESTORY),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn linkedActId(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RetroActData::VT_LINKEDACTID, None)
        }
    }
    #[inline]
    pub fn startTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_RetroActData::VT_STARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn trailStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_RetroActData::VT_TRAILSTARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn index(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RetroActData::VT_INDEX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RetroActData::VT_NAME, None)
        }
    }
    #[inline]
    pub fn haveTrail(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_RetroActData::VT_HAVETRAIL, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn customActId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RetroActData::VT_CUSTOMACTID,
                None,
            )
        }
    }
    #[inline]
    pub fn customActType(&self) -> enum__Torappu_ActivityType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ActivityType>(
                    clz_Torappu_RetroActData::VT_CUSTOMACTTYPE,
                    Some(enum__Torappu_ActivityType::DEFAULT),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn trapDomainId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RetroActData::VT_TRAPDOMAINID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RetroActData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("retroId", Self::VT_RETROID, false)?
            .visit_field::<enum__Torappu_RetroType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("linkedActId", Self::VT_LINKEDACTID, false)?
            .visit_field::<i64>("startTime", Self::VT_STARTTIME, false)?
            .visit_field::<i64>("trailStartTime", Self::VT_TRAILSTARTTIME, false)?
            .visit_field::<i32>("index", Self::VT_INDEX, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<bool>("haveTrail", Self::VT_HAVETRAIL, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "customActId",
                Self::VT_CUSTOMACTID,
                false,
            )?
            .visit_field::<enum__Torappu_ActivityType>(
                "customActType",
                Self::VT_CUSTOMACTTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "trapDomainId",
                Self::VT_TRAPDOMAINID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RetroActDataArgs<'a> {
    pub retroId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_RetroType,
    pub linkedActId: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub startTime: i64,
    pub trailStartTime: i64,
    pub index: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub haveTrail: bool,
    pub customActId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub customActType: enum__Torappu_ActivityType,
    pub trapDomainId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RetroActDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RetroActDataArgs {
            retroId: None,
            type_: enum__Torappu_RetroType::SIDESTORY,
            linkedActId: None,
            startTime: 0,
            trailStartTime: 0,
            index: 0,
            name: None,
            haveTrail: false,
            customActId: None,
            customActType: enum__Torappu_ActivityType::DEFAULT,
            trapDomainId: None,
        }
    }
}

impl Serialize for clz_Torappu_RetroActData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RetroActData", 11)?;
        if let Some(f) = self.retroId() {
            s.serialize_field("retroId", &f)?;
        } else {
            s.skip_field("retroId")?;
        }
        s.serialize_field("type_", &self.type_())?;
        if let Some(f) = self.linkedActId() {
            s.serialize_field("linkedActId", &f)?;
        } else {
            s.skip_field("linkedActId")?;
        }
        s.serialize_field("startTime", &self.startTime())?;
        s.serialize_field("trailStartTime", &self.trailStartTime())?;
        s.serialize_field("index", &self.index())?;
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        s.serialize_field("haveTrail", &self.haveTrail())?;
        if let Some(f) = self.customActId() {
            s.serialize_field("customActId", &f)?;
        } else {
            s.skip_field("customActId")?;
        }
        s.serialize_field("customActType", &self.customActType())?;
        if let Some(f) = self.trapDomainId() {
            s.serialize_field("trapDomainId", &f)?;
        } else {
            s.skip_field("trapDomainId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RetroActDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RetroActDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_retroId(&mut self, retroId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroActData::VT_RETROID,
            retroId,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_RetroType) {
        self.fbb_.push_slot::<enum__Torappu_RetroType>(
            clz_Torappu_RetroActData::VT_TYPE_,
            type_,
            enum__Torappu_RetroType::SIDESTORY,
        );
    }
    #[inline]
    pub fn add_linkedActId(
        &mut self,
        linkedActId: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroActData::VT_LINKEDACTID,
            linkedActId,
        );
    }
    #[inline]
    pub fn add_startTime(&mut self, startTime: i64) {
        self.fbb_
            .push_slot::<i64>(clz_Torappu_RetroActData::VT_STARTTIME, startTime, 0);
    }
    #[inline]
    pub fn add_trailStartTime(&mut self, trailStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RetroActData::VT_TRAILSTARTTIME,
            trailStartTime,
            0,
        );
    }
    #[inline]
    pub fn add_index(&mut self, index: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RetroActData::VT_INDEX, index, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RetroActData::VT_NAME, name);
    }
    #[inline]
    pub fn add_haveTrail(&mut self, haveTrail: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_RetroActData::VT_HAVETRAIL, haveTrail, false);
    }
    #[inline]
    pub fn add_customActId(&mut self, customActId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroActData::VT_CUSTOMACTID,
            customActId,
        );
    }
    #[inline]
    pub fn add_customActType(&mut self, customActType: enum__Torappu_ActivityType) {
        self.fbb_.push_slot::<enum__Torappu_ActivityType>(
            clz_Torappu_RetroActData::VT_CUSTOMACTTYPE,
            customActType,
            enum__Torappu_ActivityType::DEFAULT,
        );
    }
    #[inline]
    pub fn add_trapDomainId(&mut self, trapDomainId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroActData::VT_TRAPDOMAINID,
            trapDomainId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RetroActDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RetroActDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RetroActData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RetroActData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RetroActData");
        ds.field("retroId", &self.retroId());
        ds.field("type_", &self.type_());
        ds.field("linkedActId", &self.linkedActId());
        ds.field("startTime", &self.startTime());
        ds.field("trailStartTime", &self.trailStartTime());
        ds.field("index", &self.index());
        ds.field("name", &self.name());
        ds.field("haveTrail", &self.haveTrail());
        ds.field("customActId", &self.customActId());
        ds.field("customActType", &self.customActType());
        ds.field("trapDomainId", &self.trapDomainId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RetroActDataT {
    pub retroId: Option<String>,
    pub type_: enum__Torappu_RetroType,
    pub linkedActId: Option<Vec<String>>,
    pub startTime: i64,
    pub trailStartTime: i64,
    pub index: i32,
    pub name: Option<String>,
    pub haveTrail: bool,
    pub customActId: Option<String>,
    pub customActType: enum__Torappu_ActivityType,
    pub trapDomainId: Option<String>,
}
impl Default for clz_Torappu_RetroActDataT {
    fn default() -> Self {
        Self {
            retroId: None,
            type_: enum__Torappu_RetroType::SIDESTORY,
            linkedActId: None,
            startTime: 0,
            trailStartTime: 0,
            index: 0,
            name: None,
            haveTrail: false,
            customActId: None,
            customActType: enum__Torappu_ActivityType::DEFAULT,
            trapDomainId: None,
        }
    }
}
impl clz_Torappu_RetroActDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RetroActData<'b>> {
        let retroId = self.retroId.as_ref().map(|x| _fbb.create_string(x));
        let type_ = self.type_;
        let linkedActId = self.linkedActId.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let startTime = self.startTime;
        let trailStartTime = self.trailStartTime;
        let index = self.index;
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let haveTrail = self.haveTrail;
        let customActId = self.customActId.as_ref().map(|x| _fbb.create_string(x));
        let customActType = self.customActType;
        let trapDomainId = self.trapDomainId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_RetroActData::create(
            _fbb,
            &clz_Torappu_RetroActDataArgs {
                retroId,
                type_,
                linkedActId,
                startTime,
                trailStartTime,
                index,
                name,
                haveTrail,
                customActId,
                customActType,
                trapDomainId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RetroActDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RetroActData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RetroActData<'a> {
    type Inner = dict__string__clz_Torappu_RetroActData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RetroActData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RetroActData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RetroActDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RetroActData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RetroActDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RetroActDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RetroActDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RetroActData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_RetroActData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RetroActData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RetroActData>>(
                    dict__string__clz_Torappu_RetroActData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RetroActData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RetroActData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RetroActDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RetroActData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RetroActDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RetroActDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RetroActData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_RetroActData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RetroActDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RetroActDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RetroActData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_RetroActData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RetroActData>>(
                dict__string__clz_Torappu_RetroActData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RetroActDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RetroActDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RetroActData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_RetroActData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RetroActData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RetroActData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RetroActDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RetroActDataT>>,
}
impl Default for dict__string__clz_Torappu_RetroActDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RetroActDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RetroActData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RetroActData::create(
            _fbb,
            &dict__string__clz_Torappu_RetroActDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RetroTrailRewardItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RetroTrailRewardItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RetroTrailRewardItem<'a> {
    type Inner = clz_Torappu_RetroTrailRewardItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RetroTrailRewardItem<'a> {
    pub const VT_TRAILREWARDID: flatbuffers::VOffsetT = 4;
    pub const VT_STARCOUNT: flatbuffers::VOffsetT = 6;
    pub const VT_REWARDITEM: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RetroTrailRewardItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RetroTrailRewardItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RetroTrailRewardItem<'bldr>> {
        let mut builder = clz_Torappu_RetroTrailRewardItemBuilder::new(_fbb);
        if let Some(x) = args.rewardItem {
            builder.add_rewardItem(x);
        }
        builder.add_starCount(args.starCount);
        if let Some(x) = args.trailRewardId {
            builder.add_trailRewardId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RetroTrailRewardItemT {
        let trailRewardId = self.trailRewardId().map(|x| x.to_string());
        let starCount = self.starCount();
        let rewardItem = self.rewardItem().map(|x| Box::new(x.unpack()));
        clz_Torappu_RetroTrailRewardItemT {
            trailRewardId,
            starCount,
            rewardItem,
        }
    }

    #[inline]
    pub fn trailRewardId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RetroTrailRewardItem::VT_TRAILREWARDID,
                None,
            )
        }
    }
    #[inline]
    pub fn starCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RetroTrailRewardItem::VT_STARCOUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn rewardItem(&self) -> Option<clz_Torappu_ItemBundle<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>(
                    clz_Torappu_RetroTrailRewardItem::VT_REWARDITEM,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RetroTrailRewardItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "trailRewardId",
                Self::VT_TRAILREWARDID,
                false,
            )?
            .visit_field::<i32>("starCount", Self::VT_STARCOUNT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>(
                "rewardItem",
                Self::VT_REWARDITEM,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RetroTrailRewardItemArgs<'a> {
    pub trailRewardId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub starCount: i32,
    pub rewardItem: Option<flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>>>,
}
impl<'a> Default for clz_Torappu_RetroTrailRewardItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RetroTrailRewardItemArgs {
            trailRewardId: None,
            starCount: 0,
            rewardItem: None,
        }
    }
}

impl Serialize for clz_Torappu_RetroTrailRewardItem<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RetroTrailRewardItem", 3)?;
        if let Some(f) = self.trailRewardId() {
            s.serialize_field("trailRewardId", &f)?;
        } else {
            s.skip_field("trailRewardId")?;
        }
        s.serialize_field("starCount", &self.starCount())?;
        if let Some(f) = self.rewardItem() {
            s.serialize_field("rewardItem", &f)?;
        } else {
            s.skip_field("rewardItem")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RetroTrailRewardItemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RetroTrailRewardItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_trailRewardId(&mut self, trailRewardId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroTrailRewardItem::VT_TRAILREWARDID,
            trailRewardId,
        );
    }
    #[inline]
    pub fn add_starCount(&mut self, starCount: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_RetroTrailRewardItem::VT_STARCOUNT, starCount, 0);
    }
    #[inline]
    pub fn add_rewardItem(
        &mut self,
        rewardItem: flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ItemBundle>>(
                clz_Torappu_RetroTrailRewardItem::VT_REWARDITEM,
                rewardItem,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RetroTrailRewardItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RetroTrailRewardItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RetroTrailRewardItem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RetroTrailRewardItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RetroTrailRewardItem");
        ds.field("trailRewardId", &self.trailRewardId());
        ds.field("starCount", &self.starCount());
        ds.field("rewardItem", &self.rewardItem());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RetroTrailRewardItemT {
    pub trailRewardId: Option<String>,
    pub starCount: i32,
    pub rewardItem: Option<Box<clz_Torappu_ItemBundleT>>,
}
impl Default for clz_Torappu_RetroTrailRewardItemT {
    fn default() -> Self {
        Self {
            trailRewardId: None,
            starCount: 0,
            rewardItem: None,
        }
    }
}
impl clz_Torappu_RetroTrailRewardItemT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RetroTrailRewardItem<'b>> {
        let trailRewardId = self.trailRewardId.as_ref().map(|x| _fbb.create_string(x));
        let starCount = self.starCount;
        let rewardItem = self.rewardItem.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_RetroTrailRewardItem::create(
            _fbb,
            &clz_Torappu_RetroTrailRewardItemArgs {
                trailRewardId,
                starCount,
                rewardItem,
            },
        )
    }
}
pub enum clz_Torappu_RetroTrailDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RetroTrailData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RetroTrailData<'a> {
    type Inner = clz_Torappu_RetroTrailData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RetroTrailData<'a> {
    pub const VT_RETROID: flatbuffers::VOffsetT = 4;
    pub const VT_TRAILSTARTTIME: flatbuffers::VOffsetT = 6;
    pub const VT_TRAILREWARDLIST: flatbuffers::VOffsetT = 8;
    pub const VT_STAGELIST: flatbuffers::VOffsetT = 10;
    pub const VT_RELATEDCHAR: flatbuffers::VOffsetT = 12;
    pub const VT_RELATEDFULLPOTENTIALITEMID: flatbuffers::VOffsetT = 14;
    pub const VT_THEMECOLOR: flatbuffers::VOffsetT = 16;
    pub const VT_FULLPOTENTIALITEMID: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RetroTrailData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RetroTrailDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RetroTrailData<'bldr>> {
        let mut builder = clz_Torappu_RetroTrailDataBuilder::new(_fbb);
        builder.add_trailStartTime(args.trailStartTime);
        if let Some(x) = args.fullPotentialItemId {
            builder.add_fullPotentialItemId(x);
        }
        if let Some(x) = args.themeColor {
            builder.add_themeColor(x);
        }
        if let Some(x) = args.relatedFullPotentialItemId {
            builder.add_relatedFullPotentialItemId(x);
        }
        if let Some(x) = args.relatedChar {
            builder.add_relatedChar(x);
        }
        if let Some(x) = args.stageList {
            builder.add_stageList(x);
        }
        if let Some(x) = args.trailRewardList {
            builder.add_trailRewardList(x);
        }
        if let Some(x) = args.retroId {
            builder.add_retroId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RetroTrailDataT {
        let retroId = self.retroId().map(|x| x.to_string());
        let trailStartTime = self.trailStartTime();
        let trailRewardList = self
            .trailRewardList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let stageList = self
            .stageList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let relatedChar = self.relatedChar().map(|x| x.to_string());
        let relatedFullPotentialItemId = self.relatedFullPotentialItemId().map(|x| x.to_string());
        let themeColor = self.themeColor().map(|x| x.to_string());
        let fullPotentialItemId = self.fullPotentialItemId().map(|x| x.to_string());
        clz_Torappu_RetroTrailDataT {
            retroId,
            trailStartTime,
            trailRewardList,
            stageList,
            relatedChar,
            relatedFullPotentialItemId,
            themeColor,
            fullPotentialItemId,
        }
    }

    #[inline]
    pub fn retroId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RetroTrailData::VT_RETROID,
                None,
            )
        }
    }
    #[inline]
    pub fn trailStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_RetroTrailData::VT_TRAILSTARTTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn trailRewardList(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RetroTrailRewardItem<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RetroTrailRewardItem>,
                >,
            >>(clz_Torappu_RetroTrailData::VT_TRAILREWARDLIST, None)
        }
    }
    #[inline]
    pub fn stageList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RetroTrailData::VT_STAGELIST, None)
        }
    }
    #[inline]
    pub fn relatedChar(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RetroTrailData::VT_RELATEDCHAR,
                None,
            )
        }
    }
    #[inline]
    pub fn relatedFullPotentialItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RetroTrailData::VT_RELATEDFULLPOTENTIALITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn themeColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RetroTrailData::VT_THEMECOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn fullPotentialItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RetroTrailData::VT_FULLPOTENTIALITEMID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RetroTrailData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("retroId", Self::VT_RETROID, false)?
            .visit_field::<i64>("trailStartTime", Self::VT_TRAILSTARTTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_RetroTrailRewardItem>,
                >,
            >>("trailRewardList", Self::VT_TRAILREWARDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("stageList", Self::VT_STAGELIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "relatedChar",
                Self::VT_RELATEDCHAR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "relatedFullPotentialItemId",
                Self::VT_RELATEDFULLPOTENTIALITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "themeColor",
                Self::VT_THEMECOLOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "fullPotentialItemId",
                Self::VT_FULLPOTENTIALITEMID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RetroTrailDataArgs<'a> {
    pub retroId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trailStartTime: i64,
    pub trailRewardList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_RetroTrailRewardItem<'a>>,
            >,
        >,
    >,
    pub stageList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub relatedChar: Option<flatbuffers::WIPOffset<&'a str>>,
    pub relatedFullPotentialItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub themeColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fullPotentialItemId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_RetroTrailDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RetroTrailDataArgs {
            retroId: None,
            trailStartTime: 0,
            trailRewardList: None,
            stageList: None,
            relatedChar: None,
            relatedFullPotentialItemId: None,
            themeColor: None,
            fullPotentialItemId: None,
        }
    }
}

impl Serialize for clz_Torappu_RetroTrailData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RetroTrailData", 8)?;
        if let Some(f) = self.retroId() {
            s.serialize_field("retroId", &f)?;
        } else {
            s.skip_field("retroId")?;
        }
        s.serialize_field("trailStartTime", &self.trailStartTime())?;
        if let Some(f) = self.trailRewardList() {
            s.serialize_field("trailRewardList", &f)?;
        } else {
            s.skip_field("trailRewardList")?;
        }
        if let Some(f) = self.stageList() {
            s.serialize_field("stageList", &f)?;
        } else {
            s.skip_field("stageList")?;
        }
        if let Some(f) = self.relatedChar() {
            s.serialize_field("relatedChar", &f)?;
        } else {
            s.skip_field("relatedChar")?;
        }
        if let Some(f) = self.relatedFullPotentialItemId() {
            s.serialize_field("relatedFullPotentialItemId", &f)?;
        } else {
            s.skip_field("relatedFullPotentialItemId")?;
        }
        if let Some(f) = self.themeColor() {
            s.serialize_field("themeColor", &f)?;
        } else {
            s.skip_field("themeColor")?;
        }
        if let Some(f) = self.fullPotentialItemId() {
            s.serialize_field("fullPotentialItemId", &f)?;
        } else {
            s.skip_field("fullPotentialItemId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RetroTrailDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RetroTrailDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_retroId(&mut self, retroId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroTrailData::VT_RETROID,
            retroId,
        );
    }
    #[inline]
    pub fn add_trailStartTime(&mut self, trailStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RetroTrailData::VT_TRAILSTARTTIME,
            trailStartTime,
            0,
        );
    }
    #[inline]
    pub fn add_trailRewardList(
        &mut self,
        trailRewardList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_RetroTrailRewardItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroTrailData::VT_TRAILREWARDLIST,
            trailRewardList,
        );
    }
    #[inline]
    pub fn add_stageList(
        &mut self,
        stageList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroTrailData::VT_STAGELIST,
            stageList,
        );
    }
    #[inline]
    pub fn add_relatedChar(&mut self, relatedChar: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroTrailData::VT_RELATEDCHAR,
            relatedChar,
        );
    }
    #[inline]
    pub fn add_relatedFullPotentialItemId(
        &mut self,
        relatedFullPotentialItemId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroTrailData::VT_RELATEDFULLPOTENTIALITEMID,
            relatedFullPotentialItemId,
        );
    }
    #[inline]
    pub fn add_themeColor(&mut self, themeColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroTrailData::VT_THEMECOLOR,
            themeColor,
        );
    }
    #[inline]
    pub fn add_fullPotentialItemId(
        &mut self,
        fullPotentialItemId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroTrailData::VT_FULLPOTENTIALITEMID,
            fullPotentialItemId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RetroTrailDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RetroTrailDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RetroTrailData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RetroTrailData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RetroTrailData");
        ds.field("retroId", &self.retroId());
        ds.field("trailStartTime", &self.trailStartTime());
        ds.field("trailRewardList", &self.trailRewardList());
        ds.field("stageList", &self.stageList());
        ds.field("relatedChar", &self.relatedChar());
        ds.field(
            "relatedFullPotentialItemId",
            &self.relatedFullPotentialItemId(),
        );
        ds.field("themeColor", &self.themeColor());
        ds.field("fullPotentialItemId", &self.fullPotentialItemId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RetroTrailDataT {
    pub retroId: Option<String>,
    pub trailStartTime: i64,
    pub trailRewardList: Option<Vec<clz_Torappu_RetroTrailRewardItemT>>,
    pub stageList: Option<Vec<String>>,
    pub relatedChar: Option<String>,
    pub relatedFullPotentialItemId: Option<String>,
    pub themeColor: Option<String>,
    pub fullPotentialItemId: Option<String>,
}
impl Default for clz_Torappu_RetroTrailDataT {
    fn default() -> Self {
        Self {
            retroId: None,
            trailStartTime: 0,
            trailRewardList: None,
            stageList: None,
            relatedChar: None,
            relatedFullPotentialItemId: None,
            themeColor: None,
            fullPotentialItemId: None,
        }
    }
}
impl clz_Torappu_RetroTrailDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RetroTrailData<'b>> {
        let retroId = self.retroId.as_ref().map(|x| _fbb.create_string(x));
        let trailStartTime = self.trailStartTime;
        let trailRewardList = self.trailRewardList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let stageList = self.stageList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let relatedChar = self.relatedChar.as_ref().map(|x| _fbb.create_string(x));
        let relatedFullPotentialItemId = self
            .relatedFullPotentialItemId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let themeColor = self.themeColor.as_ref().map(|x| _fbb.create_string(x));
        let fullPotentialItemId = self
            .fullPotentialItemId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_RetroTrailData::create(
            _fbb,
            &clz_Torappu_RetroTrailDataArgs {
                retroId,
                trailStartTime,
                trailRewardList,
                stageList,
                relatedChar,
                relatedFullPotentialItemId,
                themeColor,
                fullPotentialItemId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_RetroTrailDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_RetroTrailData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_RetroTrailData<'a> {
    type Inner = dict__string__clz_Torappu_RetroTrailData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_RetroTrailData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_RetroTrailData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_RetroTrailDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RetroTrailData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_RetroTrailDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_RetroTrailDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_RetroTrailDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_RetroTrailData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_RetroTrailData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_RetroTrailData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RetroTrailData>>(
                    dict__string__clz_Torappu_RetroTrailData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_RetroTrailData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RetroTrailData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_RetroTrailDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_RetroTrailData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_RetroTrailDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_RetroTrailDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_RetroTrailData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_RetroTrailData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_RetroTrailDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_RetroTrailDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_RetroTrailData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_RetroTrailData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RetroTrailData>>(
                dict__string__clz_Torappu_RetroTrailData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_RetroTrailDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_RetroTrailDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RetroTrailData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_RetroTrailData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_RetroTrailData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_RetroTrailData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_RetroTrailDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_RetroTrailDataT>>,
}
impl Default for dict__string__clz_Torappu_RetroTrailDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_RetroTrailDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_RetroTrailData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_RetroTrailData::create(
            _fbb,
            &dict__string__clz_Torappu_RetroTrailDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_StageData_ConditionDescOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_ConditionDesc<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_ConditionDesc<'a> {
    type Inner = clz_Torappu_StageData_ConditionDesc<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_ConditionDesc<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_COMPLETESTATE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_ConditionDesc { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_ConditionDescArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_ConditionDesc<'bldr>> {
        let mut builder = clz_Torappu_StageData_ConditionDescBuilder::new(_fbb);
        builder.add_completeState(args.completeState);
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_ConditionDescT {
        let stageId = self.stageId().map(|x| x.to_string());
        let completeState = self.completeState();
        clz_Torappu_StageData_ConditionDescT {
            stageId,
            completeState,
        }
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_ConditionDesc::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn completeState(&self) -> enum__Torappu_PlayerBattleRank {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_PlayerBattleRank>(
                    clz_Torappu_StageData_ConditionDesc::VT_COMPLETESTATE,
                    Some(enum__Torappu_PlayerBattleRank::ERR_ZERO),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_ConditionDesc<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<enum__Torappu_PlayerBattleRank>(
                "completeState",
                Self::VT_COMPLETESTATE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_ConditionDescArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub completeState: enum__Torappu_PlayerBattleRank,
}
impl<'a> Default for clz_Torappu_StageData_ConditionDescArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_ConditionDescArgs {
            stageId: None,
            completeState: enum__Torappu_PlayerBattleRank::ERR_ZERO,
        }
    }
}

impl Serialize for clz_Torappu_StageData_ConditionDesc<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_ConditionDesc", 2)?;
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        s.serialize_field("completeState", &self.completeState())?;
        s.end()
    }
}

pub struct clz_Torappu_StageData_ConditionDescBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_ConditionDescBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_ConditionDesc::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_completeState(&mut self, completeState: enum__Torappu_PlayerBattleRank) {
        self.fbb_.push_slot::<enum__Torappu_PlayerBattleRank>(
            clz_Torappu_StageData_ConditionDesc::VT_COMPLETESTATE,
            completeState,
            enum__Torappu_PlayerBattleRank::ERR_ZERO,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_ConditionDescBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_ConditionDescBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_ConditionDesc<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_ConditionDesc<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_ConditionDesc");
        ds.field("stageId", &self.stageId());
        ds.field("completeState", &self.completeState());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_ConditionDescT {
    pub stageId: Option<String>,
    pub completeState: enum__Torappu_PlayerBattleRank,
}
impl Default for clz_Torappu_StageData_ConditionDescT {
    fn default() -> Self {
        Self {
            stageId: None,
            completeState: enum__Torappu_PlayerBattleRank::ERR_ZERO,
        }
    }
}
impl clz_Torappu_StageData_ConditionDescT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_ConditionDesc<'b>> {
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let completeState = self.completeState;
        clz_Torappu_StageData_ConditionDesc::create(
            _fbb,
            &clz_Torappu_StageData_ConditionDescArgs {
                stageId,
                completeState,
            },
        )
    }
}
pub enum clz_Torappu_StageData_ExtraConditionDescOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_ExtraConditionDesc<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_ExtraConditionDesc<'a> {
    type Inner = clz_Torappu_StageData_ExtraConditionDesc<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_ExtraConditionDesc<'a> {
    pub const VT_INDEX: flatbuffers::VOffsetT = 4;
    pub const VT_TEMPLATE: flatbuffers::VOffsetT = 6;
    pub const VT_UNLOCKPARAM: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_ExtraConditionDesc { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_ExtraConditionDescArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_ExtraConditionDesc<'bldr>> {
        let mut builder = clz_Torappu_StageData_ExtraConditionDescBuilder::new(_fbb);
        if let Some(x) = args.unlockParam {
            builder.add_unlockParam(x);
        }
        if let Some(x) = args.template {
            builder.add_template(x);
        }
        builder.add_index(args.index);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_ExtraConditionDescT {
        let index = self.index();
        let template = self.template().map(|x| x.to_string());
        let unlockParam = self
            .unlockParam()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_StageData_ExtraConditionDescT {
            index,
            template,
            unlockParam,
        }
    }

    #[inline]
    pub fn index(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData_ExtraConditionDesc::VT_INDEX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn template(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_ExtraConditionDesc::VT_TEMPLATE,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockParam(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_StageData_ExtraConditionDesc::VT_UNLOCKPARAM,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_ExtraConditionDesc<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("index", Self::VT_INDEX, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "template",
                Self::VT_TEMPLATE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("unlockParam", Self::VT_UNLOCKPARAM, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_ExtraConditionDescArgs<'a> {
    pub index: i32,
    pub template: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockParam: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_StageData_ExtraConditionDescArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_ExtraConditionDescArgs {
            index: 0,
            template: None,
            unlockParam: None,
        }
    }
}

impl Serialize for clz_Torappu_StageData_ExtraConditionDesc<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_ExtraConditionDesc", 3)?;
        s.serialize_field("index", &self.index())?;
        if let Some(f) = self.template() {
            s.serialize_field("template", &f)?;
        } else {
            s.skip_field("template")?;
        }
        if let Some(f) = self.unlockParam() {
            s.serialize_field("unlockParam", &f)?;
        } else {
            s.skip_field("unlockParam")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StageData_ExtraConditionDescBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_ExtraConditionDescBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_index(&mut self, index: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData_ExtraConditionDesc::VT_INDEX, index, 0);
    }
    #[inline]
    pub fn add_template(&mut self, template: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_ExtraConditionDesc::VT_TEMPLATE,
            template,
        );
    }
    #[inline]
    pub fn add_unlockParam(
        &mut self,
        unlockParam: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_ExtraConditionDesc::VT_UNLOCKPARAM,
            unlockParam,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_ExtraConditionDescBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_ExtraConditionDescBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_ExtraConditionDesc<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_ExtraConditionDesc<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_ExtraConditionDesc");
        ds.field("index", &self.index());
        ds.field("template", &self.template());
        ds.field("unlockParam", &self.unlockParam());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_ExtraConditionDescT {
    pub index: i32,
    pub template: Option<String>,
    pub unlockParam: Option<Vec<String>>,
}
impl Default for clz_Torappu_StageData_ExtraConditionDescT {
    fn default() -> Self {
        Self {
            index: 0,
            template: None,
            unlockParam: None,
        }
    }
}
impl clz_Torappu_StageData_ExtraConditionDescT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_ExtraConditionDesc<'b>> {
        let index = self.index;
        let template = self.template.as_ref().map(|x| _fbb.create_string(x));
        let unlockParam = self.unlockParam.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_StageData_ExtraConditionDesc::create(
            _fbb,
            &clz_Torappu_StageData_ExtraConditionDescArgs {
                index,
                template,
                unlockParam,
            },
        )
    }
}
pub enum dict__int__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__int__string<'a> {
    type Inner = dict__int__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__int__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__string<'bldr>> {
        let mut builder = dict__int__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__int__stringT {
        let key = self.key();
        let value = self.value().map(|x| x.to_string());
        dict__int__stringT { key, value }
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(dict__int__string::VT_KEY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__int__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__int__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__int__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__int__stringArgs<'a> {
    pub key: i32,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__int__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__stringArgs {
            key: 0,
            value: None,
        }
    }
}

impl Serialize for dict__int__string<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__int__string", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__int__stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__int__stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_
            .push_slot::<i32>(dict__int__string::VT_KEY, key, 0);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__int__string::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__int__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__int__stringT {
    pub key: i32,
    pub value: Option<String>,
}
impl Default for dict__int__stringT {
    fn default() -> Self {
        Self {
            key: 0,
            value: None,
        }
    }
}
impl dict__int__stringT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__int__string<'b>> {
        let key = self.key;
        let value = self.value.as_ref().map(|x| _fbb.create_string(x));
        dict__int__string::create(_fbb, &dict__int__stringArgs { key, value })
    }
}
pub enum clz_Torappu_StageData_SpecialProgressInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_SpecialProgressInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_SpecialProgressInfo<'a> {
    type Inner = clz_Torappu_StageData_SpecialProgressInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_SpecialProgressInfo<'a> {
    pub const VT_PROGRESSTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_DESCLIST: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_SpecialProgressInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_SpecialProgressInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialProgressInfo<'bldr>> {
        let mut builder = clz_Torappu_StageData_SpecialProgressInfoBuilder::new(_fbb);
        if let Some(x) = args.descList {
            builder.add_descList(x);
        }
        builder.add_progressType(args.progressType);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_SpecialProgressInfoT {
        let progressType = self.progressType();
        let descList = self
            .descList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_StageData_SpecialProgressInfoT {
            progressType,
            descList,
        }
    }

    #[inline]
    pub fn progressType(&self) -> enum__Torappu_StageData_SpecialStageUnlockProgressType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageData_SpecialStageUnlockProgressType>(
                    clz_Torappu_StageData_SpecialProgressInfo::VT_PROGRESSTYPE,
                    Some(enum__Torappu_StageData_SpecialStageUnlockProgressType::ONCE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn descList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__int__string<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__int__string>>,
            >>(clz_Torappu_StageData_SpecialProgressInfo::VT_DESCLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_SpecialProgressInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_StageData_SpecialStageUnlockProgressType>(
                "progressType",
                Self::VT_PROGRESSTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__int__string>>,
            >>("descList", Self::VT_DESCLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_SpecialProgressInfoArgs<'a> {
    pub progressType: enum__Torappu_StageData_SpecialStageUnlockProgressType,
    pub descList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__int__string<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_StageData_SpecialProgressInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_SpecialProgressInfoArgs {
            progressType: enum__Torappu_StageData_SpecialStageUnlockProgressType::ONCE,
            descList: None,
        }
    }
}

impl Serialize for clz_Torappu_StageData_SpecialProgressInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_SpecialProgressInfo", 2)?;
        s.serialize_field("progressType", &self.progressType())?;
        if let Some(f) = self.descList() {
            s.serialize_field("descList", &f)?;
        } else {
            s.skip_field("descList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StageData_SpecialProgressInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_SpecialProgressInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_progressType(
        &mut self,
        progressType: enum__Torappu_StageData_SpecialStageUnlockProgressType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_StageData_SpecialStageUnlockProgressType>(
                clz_Torappu_StageData_SpecialProgressInfo::VT_PROGRESSTYPE,
                progressType,
                enum__Torappu_StageData_SpecialStageUnlockProgressType::ONCE,
            );
    }
    #[inline]
    pub fn add_descList(
        &mut self,
        descList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__int__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_SpecialProgressInfo::VT_DESCLIST,
            descList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_SpecialProgressInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_SpecialProgressInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialProgressInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_SpecialProgressInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_SpecialProgressInfo");
        ds.field("progressType", &self.progressType());
        ds.field("descList", &self.descList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_SpecialProgressInfoT {
    pub progressType: enum__Torappu_StageData_SpecialStageUnlockProgressType,
    pub descList: Option<Vec<dict__int__stringT>>,
}
impl Default for clz_Torappu_StageData_SpecialProgressInfoT {
    fn default() -> Self {
        Self {
            progressType: enum__Torappu_StageData_SpecialStageUnlockProgressType::ONCE,
            descList: None,
        }
    }
}
impl clz_Torappu_StageData_SpecialProgressInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialProgressInfo<'b>> {
        let progressType = self.progressType;
        let descList = self.descList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_StageData_SpecialProgressInfo::create(
            _fbb,
            &clz_Torappu_StageData_SpecialProgressInfoArgs {
                progressType,
                descList,
            },
        )
    }
}
pub enum clz_Torappu_StageData_SpecialStoryInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData_SpecialStoryInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData_SpecialStoryInfo<'a> {
    type Inner = clz_Torappu_StageData_SpecialStoryInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData_SpecialStoryInfo<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_REWARDS: flatbuffers::VOffsetT = 6;
    pub const VT_PROGRESSINFO: flatbuffers::VOffsetT = 8;
    pub const VT_IMAGEID: flatbuffers::VOffsetT = 10;
    pub const VT_KEYITEMID: flatbuffers::VOffsetT = 12;
    pub const VT_UNLOCKDESC: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData_SpecialStoryInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageData_SpecialStoryInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialStoryInfo<'bldr>> {
        let mut builder = clz_Torappu_StageData_SpecialStoryInfoBuilder::new(_fbb);
        if let Some(x) = args.unlockDesc {
            builder.add_unlockDesc(x);
        }
        if let Some(x) = args.keyItemId {
            builder.add_keyItemId(x);
        }
        if let Some(x) = args.imageId {
            builder.add_imageId(x);
        }
        if let Some(x) = args.progressInfo {
            builder.add_progressInfo(x);
        }
        if let Some(x) = args.rewards {
            builder.add_rewards(x);
        }
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageData_SpecialStoryInfoT {
        let stageId = self.stageId().map(|x| x.to_string());
        let rewards = self
            .rewards()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let progressInfo = self.progressInfo().map(|x| Box::new(x.unpack()));
        let imageId = self.imageId().map(|x| x.to_string());
        let keyItemId = self.keyItemId().map(|x| x.to_string());
        let unlockDesc = self.unlockDesc().map(|x| x.to_string());
        clz_Torappu_StageData_SpecialStoryInfoT {
            stageId,
            rewards,
            progressInfo,
            imageId,
            keyItemId,
            unlockDesc,
        }
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_SpecialStoryInfo::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn rewards(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_StageData_SpecialStoryInfo::VT_REWARDS, None)
        }
    }
    #[inline]
    pub fn progressInfo(&self) -> Option<clz_Torappu_StageData_SpecialProgressInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData_SpecialProgressInfo>>(
                    clz_Torappu_StageData_SpecialStoryInfo::VT_PROGRESSINFO,
                    None,
                )
        }
    }
    #[inline]
    pub fn imageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_SpecialStoryInfo::VT_IMAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn keyItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_SpecialStoryInfo::VT_KEYITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData_SpecialStoryInfo::VT_UNLOCKDESC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData_SpecialStoryInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("rewards", Self::VT_REWARDS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData_SpecialProgressInfo>>(
                "progressInfo",
                Self::VT_PROGRESSINFO,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("imageId", Self::VT_IMAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "keyItemId",
                Self::VT_KEYITEMID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockDesc",
                Self::VT_UNLOCKDESC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageData_SpecialStoryInfoArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rewards: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
    pub progressInfo: Option<flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialProgressInfo<'a>>>,
    pub imageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub keyItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockDesc: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_StageData_SpecialStoryInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageData_SpecialStoryInfoArgs {
            stageId: None,
            rewards: None,
            progressInfo: None,
            imageId: None,
            keyItemId: None,
            unlockDesc: None,
        }
    }
}

impl Serialize for clz_Torappu_StageData_SpecialStoryInfo<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData_SpecialStoryInfo", 6)?;
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        if let Some(f) = self.rewards() {
            s.serialize_field("rewards", &f)?;
        } else {
            s.skip_field("rewards")?;
        }
        if let Some(f) = self.progressInfo() {
            s.serialize_field("progressInfo", &f)?;
        } else {
            s.skip_field("progressInfo")?;
        }
        if let Some(f) = self.imageId() {
            s.serialize_field("imageId", &f)?;
        } else {
            s.skip_field("imageId")?;
        }
        if let Some(f) = self.keyItemId() {
            s.serialize_field("keyItemId", &f)?;
        } else {
            s.skip_field("keyItemId")?;
        }
        if let Some(f) = self.unlockDesc() {
            s.serialize_field("unlockDesc", &f)?;
        } else {
            s.skip_field("unlockDesc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_StageData_SpecialStoryInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_StageData_SpecialStoryInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_SpecialStoryInfo::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_rewards(
        &mut self,
        rewards: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_SpecialStoryInfo::VT_REWARDS,
            rewards,
        );
    }
    #[inline]
    pub fn add_progressInfo(
        &mut self,
        progressInfo: flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialProgressInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialProgressInfo>>(
                clz_Torappu_StageData_SpecialStoryInfo::VT_PROGRESSINFO,
                progressInfo,
            );
    }
    #[inline]
    pub fn add_imageId(&mut self, imageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_SpecialStoryInfo::VT_IMAGEID,
            imageId,
        );
    }
    #[inline]
    pub fn add_keyItemId(&mut self, keyItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_SpecialStoryInfo::VT_KEYITEMID,
            keyItemId,
        );
    }
    #[inline]
    pub fn add_unlockDesc(&mut self, unlockDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData_SpecialStoryInfo::VT_UNLOCKDESC,
            unlockDesc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageData_SpecialStoryInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageData_SpecialStoryInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialStoryInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData_SpecialStoryInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData_SpecialStoryInfo");
        ds.field("stageId", &self.stageId());
        ds.field("rewards", &self.rewards());
        ds.field("progressInfo", &self.progressInfo());
        ds.field("imageId", &self.imageId());
        ds.field("keyItemId", &self.keyItemId());
        ds.field("unlockDesc", &self.unlockDesc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageData_SpecialStoryInfoT {
    pub stageId: Option<String>,
    pub rewards: Option<Vec<clz_Torappu_ItemBundleT>>,
    pub progressInfo: Option<Box<clz_Torappu_StageData_SpecialProgressInfoT>>,
    pub imageId: Option<String>,
    pub keyItemId: Option<String>,
    pub unlockDesc: Option<String>,
}
impl Default for clz_Torappu_StageData_SpecialStoryInfoT {
    fn default() -> Self {
        Self {
            stageId: None,
            rewards: None,
            progressInfo: None,
            imageId: None,
            keyItemId: None,
            unlockDesc: None,
        }
    }
}
impl clz_Torappu_StageData_SpecialStoryInfoT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData_SpecialStoryInfo<'b>> {
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let rewards = self.rewards.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let progressInfo = self.progressInfo.as_ref().map(|x| x.pack(_fbb));
        let imageId = self.imageId.as_ref().map(|x| _fbb.create_string(x));
        let keyItemId = self.keyItemId.as_ref().map(|x| _fbb.create_string(x));
        let unlockDesc = self.unlockDesc.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_StageData_SpecialStoryInfo::create(
            _fbb,
            &clz_Torappu_StageData_SpecialStoryInfoArgs {
                stageId,
                rewards,
                progressInfo,
                imageId,
                keyItemId,
                unlockDesc,
            },
        )
    }
}
pub enum clz_Torappu_StageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_StageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_StageData<'a> {
    type Inner = clz_Torappu_StageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_StageData<'a> {
    pub const VT_STAGETYPE: flatbuffers::VOffsetT = 4;
    pub const VT_DIFFICULTY: flatbuffers::VOffsetT = 6;
    pub const VT_PERFORMANCESTAGEFLAG: flatbuffers::VOffsetT = 8;
    pub const VT_DIFFGROUP: flatbuffers::VOffsetT = 10;
    pub const VT_UNLOCKCONDITION: flatbuffers::VOffsetT = 12;
    pub const VT_STAGEID: flatbuffers::VOffsetT = 14;
    pub const VT_LEVELID: flatbuffers::VOffsetT = 16;
    pub const VT_ZONEID: flatbuffers::VOffsetT = 18;
    pub const VT_CODE: flatbuffers::VOffsetT = 20;
    pub const VT_NAME: flatbuffers::VOffsetT = 22;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 24;
    pub const VT_HARDSTAGEDID: flatbuffers::VOffsetT = 26;
    pub const VT_SIXSTARSTAGEID: flatbuffers::VOffsetT = 28;
    pub const VT_DANGERLEVEL: flatbuffers::VOffsetT = 30;
    pub const VT_DANGERPOINT: flatbuffers::VOffsetT = 32;
    pub const VT_LOADINGPICID: flatbuffers::VOffsetT = 34;
    pub const VT_CANPRACTICE: flatbuffers::VOffsetT = 36;
    pub const VT_CANBATTLEREPLAY: flatbuffers::VOffsetT = 38;
    pub const VT_APCOST: flatbuffers::VOffsetT = 40;
    pub const VT_APFAILRETURN: flatbuffers::VOffsetT = 42;
    pub const VT_MAXSLOT: flatbuffers::VOffsetT = 44;
    pub const VT_ETITEMID: flatbuffers::VOffsetT = 46;
    pub const VT_ETCOST: flatbuffers::VOffsetT = 48;
    pub const VT_ETFAILRETURN: flatbuffers::VOffsetT = 50;
    pub const VT_ETBUTTONSTYLE: flatbuffers::VOffsetT = 52;
    pub const VT_APPROTECTTIMES: flatbuffers::VOffsetT = 54;
    pub const VT_DIAMONDONCEDROP: flatbuffers::VOffsetT = 56;
    pub const VT_PRACTICETICKETCOST: flatbuffers::VOffsetT = 58;
    pub const VT_DAILYSTAGEDIFFICULTY: flatbuffers::VOffsetT = 60;
    pub const VT_EXPGAIN: flatbuffers::VOffsetT = 62;
    pub const VT_GOLDGAIN: flatbuffers::VOffsetT = 64;
    pub const VT_LOSEEXPGAIN: flatbuffers::VOffsetT = 66;
    pub const VT_LOSEGOLDGAIN: flatbuffers::VOffsetT = 68;
    pub const VT_PASSFAVOR: flatbuffers::VOffsetT = 70;
    pub const VT_COMPLETEFAVOR: flatbuffers::VOffsetT = 72;
    pub const VT_SLPROGRESS: flatbuffers::VOffsetT = 74;
    pub const VT_DISPLAYMAINITEM: flatbuffers::VOffsetT = 76;
    pub const VT_HILIGHTMARK: flatbuffers::VOffsetT = 78;
    pub const VT_BOSSMARK: flatbuffers::VOffsetT = 80;
    pub const VT_ISPREDEFINED: flatbuffers::VOffsetT = 82;
    pub const VT_ISHARDPREDEFINED: flatbuffers::VOffsetT = 84;
    pub const VT_ISSKILLSELECTABLEPREDEFINED: flatbuffers::VOffsetT = 86;
    pub const VT_ISSTORYONLY: flatbuffers::VOffsetT = 88;
    pub const VT_APPEARANCESTYLE: flatbuffers::VOffsetT = 90;
    pub const VT_STAGEDROPINFO: flatbuffers::VOffsetT = 92;
    pub const VT_CANUSECHARM: flatbuffers::VOffsetT = 94;
    pub const VT_CANUSETECH: flatbuffers::VOffsetT = 96;
    pub const VT_CANUSETRAPTOOL: flatbuffers::VOffsetT = 98;
    pub const VT_CANUSEBATTLEPERFORMANCE: flatbuffers::VOffsetT = 100;
    pub const VT_CANUSEFIREWORK: flatbuffers::VOffsetT = 102;
    pub const VT_CANMULTIPLEBATTLE: flatbuffers::VOffsetT = 104;
    pub const VT_STARTBUTTONOVERRIDEID: flatbuffers::VOffsetT = 106;
    pub const VT_ISSTAGEPATCH: flatbuffers::VOffsetT = 108;
    pub const VT_MAINSTAGEID: flatbuffers::VOffsetT = 110;
    pub const VT_EXTRACONDITION: flatbuffers::VOffsetT = 112;
    pub const VT_EXTRAINFO: flatbuffers::VOffsetT = 114;
    pub const VT_SIXSTARBASEDESC: flatbuffers::VOffsetT = 116;
    pub const VT_SIXSTARDISPLAYREWARDLIST: flatbuffers::VOffsetT = 118;
    pub const VT_ADVANCEDRUNEIDLIST1: flatbuffers::VOffsetT = 120;
    pub const VT_ADVANCEDRUNEIDLIST2: flatbuffers::VOffsetT = 122;
    pub const VT_USESPECIALSIZEMAPPREVIEW: flatbuffers::VOffsetT = 124;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_StageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_StageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData<'bldr>> {
        let mut builder = clz_Torappu_StageDataBuilder::new(_fbb);
        if let Some(x) = args.advancedRuneIdList2 {
            builder.add_advancedRuneIdList2(x);
        }
        if let Some(x) = args.advancedRuneIdList1 {
            builder.add_advancedRuneIdList1(x);
        }
        if let Some(x) = args.sixStarDisplayRewardList {
            builder.add_sixStarDisplayRewardList(x);
        }
        if let Some(x) = args.sixStarBaseDesc {
            builder.add_sixStarBaseDesc(x);
        }
        if let Some(x) = args.extraInfo {
            builder.add_extraInfo(x);
        }
        if let Some(x) = args.extraCondition {
            builder.add_extraCondition(x);
        }
        if let Some(x) = args.mainStageId {
            builder.add_mainStageId(x);
        }
        if let Some(x) = args.startButtonOverrideId {
            builder.add_startButtonOverrideId(x);
        }
        if let Some(x) = args.stageDropInfo {
            builder.add_stageDropInfo(x);
        }
        builder.add_appearanceStyle(args.appearanceStyle);
        if let Some(x) = args.displayMainItem {
            builder.add_displayMainItem(x);
        }
        builder.add_slProgress(args.slProgress);
        builder.add_completeFavor(args.completeFavor);
        builder.add_passFavor(args.passFavor);
        builder.add_loseGoldGain(args.loseGoldGain);
        builder.add_loseExpGain(args.loseExpGain);
        builder.add_goldGain(args.goldGain);
        builder.add_expGain(args.expGain);
        builder.add_dailyStageDifficulty(args.dailyStageDifficulty);
        builder.add_practiceTicketCost(args.practiceTicketCost);
        builder.add_diamondOnceDrop(args.diamondOnceDrop);
        builder.add_apProtectTimes(args.apProtectTimes);
        if let Some(x) = args.etButtonStyle {
            builder.add_etButtonStyle(x);
        }
        builder.add_etFailReturn(args.etFailReturn);
        builder.add_etCost(args.etCost);
        if let Some(x) = args.etItemId {
            builder.add_etItemId(x);
        }
        builder.add_maxSlot(args.maxSlot);
        builder.add_apFailReturn(args.apFailReturn);
        builder.add_apCost(args.apCost);
        if let Some(x) = args.loadingPicId {
            builder.add_loadingPicId(x);
        }
        builder.add_dangerPoint(args.dangerPoint);
        if let Some(x) = args.dangerLevel {
            builder.add_dangerLevel(x);
        }
        if let Some(x) = args.sixStarStageId {
            builder.add_sixStarStageId(x);
        }
        if let Some(x) = args.hardStagedId {
            builder.add_hardStagedId(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.code {
            builder.add_code(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        if let Some(x) = args.levelId {
            builder.add_levelId(x);
        }
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        if let Some(x) = args.unlockCondition {
            builder.add_unlockCondition(x);
        }
        builder.add_diffGroup(args.diffGroup);
        builder.add_performanceStageFlag(args.performanceStageFlag);
        builder.add_difficulty(args.difficulty);
        builder.add_stageType(args.stageType);
        builder.add_useSpecialSizeMapPreview(args.useSpecialSizeMapPreview);
        builder.add_isStagePatch(args.isStagePatch);
        builder.add_canMultipleBattle(args.canMultipleBattle);
        builder.add_canUseFirework(args.canUseFirework);
        builder.add_canUseBattlePerformance(args.canUseBattlePerformance);
        builder.add_canUseTrapTool(args.canUseTrapTool);
        builder.add_canUseTech(args.canUseTech);
        builder.add_canUseCharm(args.canUseCharm);
        builder.add_isStoryOnly(args.isStoryOnly);
        builder.add_isSkillSelectablePredefined(args.isSkillSelectablePredefined);
        builder.add_isHardPredefined(args.isHardPredefined);
        builder.add_isPredefined(args.isPredefined);
        builder.add_bossMark(args.bossMark);
        builder.add_hilightMark(args.hilightMark);
        builder.add_canBattleReplay(args.canBattleReplay);
        builder.add_canPractice(args.canPractice);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_StageDataT {
        let stageType = self.stageType();
        let difficulty = self.difficulty();
        let performanceStageFlag = self.performanceStageFlag();
        let diffGroup = self.diffGroup();
        let unlockCondition = self
            .unlockCondition()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let stageId = self.stageId().map(|x| x.to_string());
        let levelId = self.levelId().map(|x| x.to_string());
        let zoneId = self.zoneId().map(|x| x.to_string());
        let code = self.code().map(|x| x.to_string());
        let name = self.name().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let hardStagedId = self.hardStagedId().map(|x| x.to_string());
        let sixStarStageId = self.sixStarStageId().map(|x| x.to_string());
        let dangerLevel = self.dangerLevel().map(|x| x.to_string());
        let dangerPoint = self.dangerPoint();
        let loadingPicId = self.loadingPicId().map(|x| x.to_string());
        let canPractice = self.canPractice();
        let canBattleReplay = self.canBattleReplay();
        let apCost = self.apCost();
        let apFailReturn = self.apFailReturn();
        let maxSlot = self.maxSlot();
        let etItemId = self.etItemId().map(|x| x.to_string());
        let etCost = self.etCost();
        let etFailReturn = self.etFailReturn();
        let etButtonStyle = self.etButtonStyle().map(|x| x.to_string());
        let apProtectTimes = self.apProtectTimes();
        let diamondOnceDrop = self.diamondOnceDrop();
        let practiceTicketCost = self.practiceTicketCost();
        let dailyStageDifficulty = self.dailyStageDifficulty();
        let expGain = self.expGain();
        let goldGain = self.goldGain();
        let loseExpGain = self.loseExpGain();
        let loseGoldGain = self.loseGoldGain();
        let passFavor = self.passFavor();
        let completeFavor = self.completeFavor();
        let slProgress = self.slProgress();
        let displayMainItem = self.displayMainItem().map(|x| x.to_string());
        let hilightMark = self.hilightMark();
        let bossMark = self.bossMark();
        let isPredefined = self.isPredefined();
        let isHardPredefined = self.isHardPredefined();
        let isSkillSelectablePredefined = self.isSkillSelectablePredefined();
        let isStoryOnly = self.isStoryOnly();
        let appearanceStyle = self.appearanceStyle();
        let stageDropInfo = self.stageDropInfo().map(|x| Box::new(x.unpack()));
        let canUseCharm = self.canUseCharm();
        let canUseTech = self.canUseTech();
        let canUseTrapTool = self.canUseTrapTool();
        let canUseBattlePerformance = self.canUseBattlePerformance();
        let canUseFirework = self.canUseFirework();
        let canMultipleBattle = self.canMultipleBattle();
        let startButtonOverrideId = self.startButtonOverrideId().map(|x| x.to_string());
        let isStagePatch = self.isStagePatch();
        let mainStageId = self.mainStageId().map(|x| x.to_string());
        let extraCondition = self
            .extraCondition()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let extraInfo = self
            .extraInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let sixStarBaseDesc = self.sixStarBaseDesc().map(|x| x.to_string());
        let sixStarDisplayRewardList = self
            .sixStarDisplayRewardList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let advancedRuneIdList1 = self
            .advancedRuneIdList1()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let advancedRuneIdList2 = self
            .advancedRuneIdList2()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let useSpecialSizeMapPreview = self.useSpecialSizeMapPreview();
        clz_Torappu_StageDataT {
            stageType,
            difficulty,
            performanceStageFlag,
            diffGroup,
            unlockCondition,
            stageId,
            levelId,
            zoneId,
            code,
            name,
            description,
            hardStagedId,
            sixStarStageId,
            dangerLevel,
            dangerPoint,
            loadingPicId,
            canPractice,
            canBattleReplay,
            apCost,
            apFailReturn,
            maxSlot,
            etItemId,
            etCost,
            etFailReturn,
            etButtonStyle,
            apProtectTimes,
            diamondOnceDrop,
            practiceTicketCost,
            dailyStageDifficulty,
            expGain,
            goldGain,
            loseExpGain,
            loseGoldGain,
            passFavor,
            completeFavor,
            slProgress,
            displayMainItem,
            hilightMark,
            bossMark,
            isPredefined,
            isHardPredefined,
            isSkillSelectablePredefined,
            isStoryOnly,
            appearanceStyle,
            stageDropInfo,
            canUseCharm,
            canUseTech,
            canUseTrapTool,
            canUseBattlePerformance,
            canUseFirework,
            canMultipleBattle,
            startButtonOverrideId,
            isStagePatch,
            mainStageId,
            extraCondition,
            extraInfo,
            sixStarBaseDesc,
            sixStarDisplayRewardList,
            advancedRuneIdList1,
            advancedRuneIdList2,
            useSpecialSizeMapPreview,
        }
    }

    #[inline]
    pub fn stageType(&self) -> enum__Torappu_StageType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageType>(
                    clz_Torappu_StageData::VT_STAGETYPE,
                    Some(enum__Torappu_StageType::MAIN),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn difficulty(&self) -> enum__Torappu_LevelData_Difficulty {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_LevelData_Difficulty>(
                    clz_Torappu_StageData::VT_DIFFICULTY,
                    Some(enum__Torappu_LevelData_Difficulty::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn performanceStageFlag(&self) -> enum__Torappu_StageData_PerformanceStageFlag {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageData_PerformanceStageFlag>(
                    clz_Torappu_StageData::VT_PERFORMANCESTAGEFLAG,
                    Some(enum__Torappu_StageData_PerformanceStageFlag::NORMAL_STAGE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn diffGroup(&self) -> enum__Torappu_StageDiffGroup {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_StageDiffGroup>(
                    clz_Torappu_StageData::VT_DIFFGROUP,
                    Some(enum__Torappu_StageDiffGroup::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockCondition(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ConditionDesc<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ConditionDesc>,
                >,
            >>(clz_Torappu_StageData::VT_UNLOCKCONDITION, None)
        }
    }
    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_StageData::VT_STAGEID, None)
        }
    }
    #[inline]
    pub fn levelId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_StageData::VT_LEVELID, None)
        }
    }
    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_StageData::VT_ZONEID, None)
        }
    }
    #[inline]
    pub fn code(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_StageData::VT_CODE, None)
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_StageData::VT_NAME, None)
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn hardStagedId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_HARDSTAGEDID,
                None,
            )
        }
    }
    #[inline]
    pub fn sixStarStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_SIXSTARSTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn dangerLevel(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_DANGERLEVEL,
                None,
            )
        }
    }
    #[inline]
    pub fn dangerPoint(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_StageData::VT_DANGERPOINT, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn loadingPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_LOADINGPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn canPractice(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_CANPRACTICE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn canBattleReplay(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_CANBATTLEREPLAY, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn apCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_APCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn apFailReturn(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_APFAILRETURN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn maxSlot(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_MAXSLOT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn etItemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_StageData::VT_ETITEMID, None)
        }
    }
    #[inline]
    pub fn etCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_ETCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn etFailReturn(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_ETFAILRETURN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn etButtonStyle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_ETBUTTONSTYLE,
                None,
            )
        }
    }
    #[inline]
    pub fn apProtectTimes(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_APPROTECTTIMES, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn diamondOnceDrop(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_DIAMONDONCEDROP, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn practiceTicketCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_PRACTICETICKETCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn dailyStageDifficulty(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_DAILYSTAGEDIFFICULTY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn expGain(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_EXPGAIN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn goldGain(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_GOLDGAIN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn loseExpGain(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_LOSEEXPGAIN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn loseGoldGain(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_LOSEGOLDGAIN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn passFavor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_PASSFAVOR, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn completeFavor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_COMPLETEFAVOR, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn slProgress(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_StageData::VT_SLPROGRESS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn displayMainItem(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_DISPLAYMAINITEM,
                None,
            )
        }
    }
    #[inline]
    pub fn hilightMark(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_HILIGHTMARK, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn bossMark(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_BOSSMARK, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isPredefined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_ISPREDEFINED, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isHardPredefined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_ISHARDPREDEFINED, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn isSkillSelectablePredefined(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_StageData::VT_ISSKILLSELECTABLEPREDEFINED,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isStoryOnly(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_ISSTORYONLY, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn appearanceStyle(&self) -> enum__Torappu_AppearanceStyle {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_AppearanceStyle>(
                    clz_Torappu_StageData::VT_APPEARANCESTYLE,
                    Some(enum__Torappu_AppearanceStyle::MAIN_NORMAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn stageDropInfo(&self) -> Option<clz_Torappu_StageData_StageDropInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData_StageDropInfo>>(
                    clz_Torappu_StageData::VT_STAGEDROPINFO,
                    None,
                )
        }
    }
    #[inline]
    pub fn canUseCharm(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_CANUSECHARM, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn canUseTech(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_CANUSETECH, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn canUseTrapTool(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_CANUSETRAPTOOL, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn canUseBattlePerformance(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_StageData::VT_CANUSEBATTLEPERFORMANCE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn canUseFirework(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_CANUSEFIREWORK, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn canMultipleBattle(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_CANMULTIPLEBATTLE, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn startButtonOverrideId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_STARTBUTTONOVERRIDEID,
                None,
            )
        }
    }
    #[inline]
    pub fn isStagePatch(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(clz_Torappu_StageData::VT_ISSTAGEPATCH, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn mainStageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_MAINSTAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn extraCondition(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ExtraConditionDesc<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ExtraConditionDesc>,
                >,
            >>(clz_Torappu_StageData::VT_EXTRACONDITION, None)
        }
    }
    #[inline]
    pub fn extraInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_StageData_SpecialStoryInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_SpecialStoryInfo>,
                >,
            >>(clz_Torappu_StageData::VT_EXTRAINFO, None)
        }
    }
    #[inline]
    pub fn sixStarBaseDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_StageData::VT_SIXSTARBASEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn sixStarDisplayRewardList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_StageData::VT_SIXSTARDISPLAYREWARDLIST, None)
        }
    }
    #[inline]
    pub fn advancedRuneIdList1(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_StageData::VT_ADVANCEDRUNEIDLIST1, None)
        }
    }
    #[inline]
    pub fn advancedRuneIdList2(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_StageData::VT_ADVANCEDRUNEIDLIST2, None)
        }
    }
    #[inline]
    pub fn useSpecialSizeMapPreview(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_StageData::VT_USESPECIALSIZEMAPPREVIEW,
                    Some(false),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_StageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_StageType>("stageType", Self::VT_STAGETYPE, false)?
            .visit_field::<enum__Torappu_LevelData_Difficulty>(
                "difficulty",
                Self::VT_DIFFICULTY,
                false,
            )?
            .visit_field::<enum__Torappu_StageData_PerformanceStageFlag>(
                "performanceStageFlag",
                Self::VT_PERFORMANCESTAGEFLAG,
                false,
            )?
            .visit_field::<enum__Torappu_StageDiffGroup>("diffGroup", Self::VT_DIFFGROUP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ConditionDesc>,
                >,
            >>("unlockCondition", Self::VT_UNLOCKCONDITION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("levelId", Self::VT_LEVELID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("code", Self::VT_CODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "hardStagedId",
                Self::VT_HARDSTAGEDID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "sixStarStageId",
                Self::VT_SIXSTARSTAGEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dangerLevel",
                Self::VT_DANGERLEVEL,
                false,
            )?
            .visit_field::<f32>("dangerPoint", Self::VT_DANGERPOINT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "loadingPicId",
                Self::VT_LOADINGPICID,
                false,
            )?
            .visit_field::<bool>("canPractice", Self::VT_CANPRACTICE, false)?
            .visit_field::<bool>("canBattleReplay", Self::VT_CANBATTLEREPLAY, false)?
            .visit_field::<i32>("apCost", Self::VT_APCOST, false)?
            .visit_field::<i32>("apFailReturn", Self::VT_APFAILRETURN, false)?
            .visit_field::<i32>("maxSlot", Self::VT_MAXSLOT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "etItemId",
                Self::VT_ETITEMID,
                false,
            )?
            .visit_field::<i32>("etCost", Self::VT_ETCOST, false)?
            .visit_field::<i32>("etFailReturn", Self::VT_ETFAILRETURN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "etButtonStyle",
                Self::VT_ETBUTTONSTYLE,
                false,
            )?
            .visit_field::<i32>("apProtectTimes", Self::VT_APPROTECTTIMES, false)?
            .visit_field::<i32>("diamondOnceDrop", Self::VT_DIAMONDONCEDROP, false)?
            .visit_field::<i32>("practiceTicketCost", Self::VT_PRACTICETICKETCOST, false)?
            .visit_field::<i32>("dailyStageDifficulty", Self::VT_DAILYSTAGEDIFFICULTY, false)?
            .visit_field::<i32>("expGain", Self::VT_EXPGAIN, false)?
            .visit_field::<i32>("goldGain", Self::VT_GOLDGAIN, false)?
            .visit_field::<i32>("loseExpGain", Self::VT_LOSEEXPGAIN, false)?
            .visit_field::<i32>("loseGoldGain", Self::VT_LOSEGOLDGAIN, false)?
            .visit_field::<i32>("passFavor", Self::VT_PASSFAVOR, false)?
            .visit_field::<i32>("completeFavor", Self::VT_COMPLETEFAVOR, false)?
            .visit_field::<i32>("slProgress", Self::VT_SLPROGRESS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "displayMainItem",
                Self::VT_DISPLAYMAINITEM,
                false,
            )?
            .visit_field::<bool>("hilightMark", Self::VT_HILIGHTMARK, false)?
            .visit_field::<bool>("bossMark", Self::VT_BOSSMARK, false)?
            .visit_field::<bool>("isPredefined", Self::VT_ISPREDEFINED, false)?
            .visit_field::<bool>("isHardPredefined", Self::VT_ISHARDPREDEFINED, false)?
            .visit_field::<bool>(
                "isSkillSelectablePredefined",
                Self::VT_ISSKILLSELECTABLEPREDEFINED,
                false,
            )?
            .visit_field::<bool>("isStoryOnly", Self::VT_ISSTORYONLY, false)?
            .visit_field::<enum__Torappu_AppearanceStyle>(
                "appearanceStyle",
                Self::VT_APPEARANCESTYLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData_StageDropInfo>>(
                "stageDropInfo",
                Self::VT_STAGEDROPINFO,
                false,
            )?
            .visit_field::<bool>("canUseCharm", Self::VT_CANUSECHARM, false)?
            .visit_field::<bool>("canUseTech", Self::VT_CANUSETECH, false)?
            .visit_field::<bool>("canUseTrapTool", Self::VT_CANUSETRAPTOOL, false)?
            .visit_field::<bool>(
                "canUseBattlePerformance",
                Self::VT_CANUSEBATTLEPERFORMANCE,
                false,
            )?
            .visit_field::<bool>("canUseFirework", Self::VT_CANUSEFIREWORK, false)?
            .visit_field::<bool>("canMultipleBattle", Self::VT_CANMULTIPLEBATTLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "startButtonOverrideId",
                Self::VT_STARTBUTTONOVERRIDEID,
                false,
            )?
            .visit_field::<bool>("isStagePatch", Self::VT_ISSTAGEPATCH, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mainStageId",
                Self::VT_MAINSTAGEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ExtraConditionDesc>,
                >,
            >>("extraCondition", Self::VT_EXTRACONDITION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_StageData_SpecialStoryInfo>,
                >,
            >>("extraInfo", Self::VT_EXTRAINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "sixStarBaseDesc",
                Self::VT_SIXSTARBASEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(
                "sixStarDisplayRewardList",
                Self::VT_SIXSTARDISPLAYREWARDLIST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("advancedRuneIdList1", Self::VT_ADVANCEDRUNEIDLIST1, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("advancedRuneIdList2", Self::VT_ADVANCEDRUNEIDLIST2, false)?
            .visit_field::<bool>(
                "useSpecialSizeMapPreview",
                Self::VT_USESPECIALSIZEMAPPREVIEW,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_StageDataArgs<'a> {
    pub stageType: enum__Torappu_StageType,
    pub difficulty: enum__Torappu_LevelData_Difficulty,
    pub performanceStageFlag: enum__Torappu_StageData_PerformanceStageFlag,
    pub diffGroup: enum__Torappu_StageDiffGroup,
    pub unlockCondition: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ConditionDesc<'a>>,
            >,
        >,
    >,
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub levelId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub code: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hardStagedId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sixStarStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dangerLevel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dangerPoint: f32,
    pub loadingPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub canPractice: bool,
    pub canBattleReplay: bool,
    pub apCost: i32,
    pub apFailReturn: i32,
    pub maxSlot: i32,
    pub etItemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub etCost: i32,
    pub etFailReturn: i32,
    pub etButtonStyle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub apProtectTimes: i32,
    pub diamondOnceDrop: i32,
    pub practiceTicketCost: i32,
    pub dailyStageDifficulty: i32,
    pub expGain: i32,
    pub goldGain: i32,
    pub loseExpGain: i32,
    pub loseGoldGain: i32,
    pub passFavor: i32,
    pub completeFavor: i32,
    pub slProgress: i32,
    pub displayMainItem: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hilightMark: bool,
    pub bossMark: bool,
    pub isPredefined: bool,
    pub isHardPredefined: bool,
    pub isSkillSelectablePredefined: bool,
    pub isStoryOnly: bool,
    pub appearanceStyle: enum__Torappu_AppearanceStyle,
    pub stageDropInfo: Option<flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo<'a>>>,
    pub canUseCharm: bool,
    pub canUseTech: bool,
    pub canUseTrapTool: bool,
    pub canUseBattlePerformance: bool,
    pub canUseFirework: bool,
    pub canMultipleBattle: bool,
    pub startButtonOverrideId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isStagePatch: bool,
    pub mainStageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub extraCondition: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ExtraConditionDesc<'a>>,
            >,
        >,
    >,
    pub extraInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_SpecialStoryInfo<'a>>,
            >,
        >,
    >,
    pub sixStarBaseDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sixStarDisplayRewardList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
    pub advancedRuneIdList1: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub advancedRuneIdList2: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub useSpecialSizeMapPreview: bool,
}
impl<'a> Default for clz_Torappu_StageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_StageDataArgs {
            stageType: enum__Torappu_StageType::MAIN,
            difficulty: enum__Torappu_LevelData_Difficulty::NONE,
            performanceStageFlag: enum__Torappu_StageData_PerformanceStageFlag::NORMAL_STAGE,
            diffGroup: enum__Torappu_StageDiffGroup::NONE,
            unlockCondition: None,
            stageId: None,
            levelId: None,
            zoneId: None,
            code: None,
            name: None,
            description: None,
            hardStagedId: None,
            sixStarStageId: None,
            dangerLevel: None,
            dangerPoint: 0.0,
            loadingPicId: None,
            canPractice: false,
            canBattleReplay: false,
            apCost: 0,
            apFailReturn: 0,
            maxSlot: 0,
            etItemId: None,
            etCost: 0,
            etFailReturn: 0,
            etButtonStyle: None,
            apProtectTimes: 0,
            diamondOnceDrop: 0,
            practiceTicketCost: 0,
            dailyStageDifficulty: 0,
            expGain: 0,
            goldGain: 0,
            loseExpGain: 0,
            loseGoldGain: 0,
            passFavor: 0,
            completeFavor: 0,
            slProgress: 0,
            displayMainItem: None,
            hilightMark: false,
            bossMark: false,
            isPredefined: false,
            isHardPredefined: false,
            isSkillSelectablePredefined: false,
            isStoryOnly: false,
            appearanceStyle: enum__Torappu_AppearanceStyle::MAIN_NORMAL,
            stageDropInfo: None,
            canUseCharm: false,
            canUseTech: false,
            canUseTrapTool: false,
            canUseBattlePerformance: false,
            canUseFirework: false,
            canMultipleBattle: false,
            startButtonOverrideId: None,
            isStagePatch: false,
            mainStageId: None,
            extraCondition: None,
            extraInfo: None,
            sixStarBaseDesc: None,
            sixStarDisplayRewardList: None,
            advancedRuneIdList1: None,
            advancedRuneIdList2: None,
            useSpecialSizeMapPreview: false,
        }
    }
}

impl Serialize for clz_Torappu_StageData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_StageData", 61)?;
        s.serialize_field("stageType", &self.stageType())?;
        s.serialize_field("difficulty", &self.difficulty())?;
        s.serialize_field("performanceStageFlag", &self.performanceStageFlag())?;
        s.serialize_field("diffGroup", &self.diffGroup())?;
        if let Some(f) = self.unlockCondition() {
            s.serialize_field("unlockCondition", &f)?;
        } else {
            s.skip_field("unlockCondition")?;
        }
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        if let Some(f) = self.levelId() {
            s.serialize_field("levelId", &f)?;
        } else {
            s.skip_field("levelId")?;
        }
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.code() {
            s.serialize_field("code", &f)?;
        } else {
            s.skip_field("code")?;
        }
        if let Some(f) = self.name() {
            s.serialize_field("name", &f)?;
        } else {
            s.skip_field("name")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.hardStagedId() {
            s.serialize_field("hardStagedId", &f)?;
        } else {
            s.skip_field("hardStagedId")?;
        }
        if let Some(f) = self.sixStarStageId() {
            s.serialize_field("sixStarStageId", &f)?;
        } else {
            s.skip_field("sixStarStageId")?;
        }
        if let Some(f) = self.dangerLevel() {
            s.serialize_field("dangerLevel", &f)?;
        } else {
            s.skip_field("dangerLevel")?;
        }
        s.serialize_field("dangerPoint", &self.dangerPoint())?;
        if let Some(f) = self.loadingPicId() {
            s.serialize_field("loadingPicId", &f)?;
        } else {
            s.skip_field("loadingPicId")?;
        }
        s.serialize_field("canPractice", &self.canPractice())?;
        s.serialize_field("canBattleReplay", &self.canBattleReplay())?;
        s.serialize_field("apCost", &self.apCost())?;
        s.serialize_field("apFailReturn", &self.apFailReturn())?;
        s.serialize_field("maxSlot", &self.maxSlot())?;
        if let Some(f) = self.etItemId() {
            s.serialize_field("etItemId", &f)?;
        } else {
            s.skip_field("etItemId")?;
        }
        s.serialize_field("etCost", &self.etCost())?;
        s.serialize_field("etFailReturn", &self.etFailReturn())?;
        if let Some(f) = self.etButtonStyle() {
            s.serialize_field("etButtonStyle", &f)?;
        } else {
            s.skip_field("etButtonStyle")?;
        }
        s.serialize_field("apProtectTimes", &self.apProtectTimes())?;
        s.serialize_field("diamondOnceDrop", &self.diamondOnceDrop())?;
        s.serialize_field("practiceTicketCost", &self.practiceTicketCost())?;
        s.serialize_field("dailyStageDifficulty", &self.dailyStageDifficulty())?;
        s.serialize_field("expGain", &self.expGain())?;
        s.serialize_field("goldGain", &self.goldGain())?;
        s.serialize_field("loseExpGain", &self.loseExpGain())?;
        s.serialize_field("loseGoldGain", &self.loseGoldGain())?;
        s.serialize_field("passFavor", &self.passFavor())?;
        s.serialize_field("completeFavor", &self.completeFavor())?;
        s.serialize_field("slProgress", &self.slProgress())?;
        if let Some(f) = self.displayMainItem() {
            s.serialize_field("displayMainItem", &f)?;
        } else {
            s.skip_field("displayMainItem")?;
        }
        s.serialize_field("hilightMark", &self.hilightMark())?;
        s.serialize_field("bossMark", &self.bossMark())?;
        s.serialize_field("isPredefined", &self.isPredefined())?;
        s.serialize_field("isHardPredefined", &self.isHardPredefined())?;
        s.serialize_field(
            "isSkillSelectablePredefined",
            &self.isSkillSelectablePredefined(),
        )?;
        s.serialize_field("isStoryOnly", &self.isStoryOnly())?;
        s.serialize_field("appearanceStyle", &self.appearanceStyle())?;
        if let Some(f) = self.stageDropInfo() {
            s.serialize_field("stageDropInfo", &f)?;
        } else {
            s.skip_field("stageDropInfo")?;
        }
        s.serialize_field("canUseCharm", &self.canUseCharm())?;
        s.serialize_field("canUseTech", &self.canUseTech())?;
        s.serialize_field("canUseTrapTool", &self.canUseTrapTool())?;
        s.serialize_field("canUseBattlePerformance", &self.canUseBattlePerformance())?;
        s.serialize_field("canUseFirework", &self.canUseFirework())?;
        s.serialize_field("canMultipleBattle", &self.canMultipleBattle())?;
        if let Some(f) = self.startButtonOverrideId() {
            s.serialize_field("startButtonOverrideId", &f)?;
        } else {
            s.skip_field("startButtonOverrideId")?;
        }
        s.serialize_field("isStagePatch", &self.isStagePatch())?;
        if let Some(f) = self.mainStageId() {
            s.serialize_field("mainStageId", &f)?;
        } else {
            s.skip_field("mainStageId")?;
        }
        if let Some(f) = self.extraCondition() {
            s.serialize_field("extraCondition", &f)?;
        } else {
            s.skip_field("extraCondition")?;
        }
        if let Some(f) = self.extraInfo() {
            s.serialize_field("extraInfo", &f)?;
        } else {
            s.skip_field("extraInfo")?;
        }
        if let Some(f) = self.sixStarBaseDesc() {
            s.serialize_field("sixStarBaseDesc", &f)?;
        } else {
            s.skip_field("sixStarBaseDesc")?;
        }
        if let Some(f) = self.sixStarDisplayRewardList() {
            s.serialize_field("sixStarDisplayRewardList", &f)?;
        } else {
            s.skip_field("sixStarDisplayRewardList")?;
        }
        if let Some(f) = self.advancedRuneIdList1() {
            s.serialize_field("advancedRuneIdList1", &f)?;
        } else {
            s.skip_field("advancedRuneIdList1")?;
        }
        if let Some(f) = self.advancedRuneIdList2() {
            s.serialize_field("advancedRuneIdList2", &f)?;
        } else {
            s.skip_field("advancedRuneIdList2")?;
        }
        s.serialize_field("useSpecialSizeMapPreview", &self.useSpecialSizeMapPreview())?;
        s.end()
    }
}

pub struct clz_Torappu_StageDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_StageDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_stageType(&mut self, stageType: enum__Torappu_StageType) {
        self.fbb_.push_slot::<enum__Torappu_StageType>(
            clz_Torappu_StageData::VT_STAGETYPE,
            stageType,
            enum__Torappu_StageType::MAIN,
        );
    }
    #[inline]
    pub fn add_difficulty(&mut self, difficulty: enum__Torappu_LevelData_Difficulty) {
        self.fbb_.push_slot::<enum__Torappu_LevelData_Difficulty>(
            clz_Torappu_StageData::VT_DIFFICULTY,
            difficulty,
            enum__Torappu_LevelData_Difficulty::NONE,
        );
    }
    #[inline]
    pub fn add_performanceStageFlag(
        &mut self,
        performanceStageFlag: enum__Torappu_StageData_PerformanceStageFlag,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_StageData_PerformanceStageFlag>(
                clz_Torappu_StageData::VT_PERFORMANCESTAGEFLAG,
                performanceStageFlag,
                enum__Torappu_StageData_PerformanceStageFlag::NORMAL_STAGE,
            );
    }
    #[inline]
    pub fn add_diffGroup(&mut self, diffGroup: enum__Torappu_StageDiffGroup) {
        self.fbb_.push_slot::<enum__Torappu_StageDiffGroup>(
            clz_Torappu_StageData::VT_DIFFGROUP,
            diffGroup,
            enum__Torappu_StageDiffGroup::NONE,
        );
    }
    #[inline]
    pub fn add_unlockCondition(
        &mut self,
        unlockCondition: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ConditionDesc<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_UNLOCKCONDITION,
            unlockCondition,
        );
    }
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_levelId(&mut self, levelId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_LEVELID,
            levelId,
        );
    }
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_code(&mut self, code: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_StageData::VT_CODE, code);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_StageData::VT_NAME, name);
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_hardStagedId(&mut self, hardStagedId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_HARDSTAGEDID,
            hardStagedId,
        );
    }
    #[inline]
    pub fn add_sixStarStageId(&mut self, sixStarStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_SIXSTARSTAGEID,
            sixStarStageId,
        );
    }
    #[inline]
    pub fn add_dangerLevel(&mut self, dangerLevel: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_DANGERLEVEL,
            dangerLevel,
        );
    }
    #[inline]
    pub fn add_dangerPoint(&mut self, dangerPoint: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_StageData::VT_DANGERPOINT, dangerPoint, 0.0);
    }
    #[inline]
    pub fn add_loadingPicId(&mut self, loadingPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_LOADINGPICID,
            loadingPicId,
        );
    }
    #[inline]
    pub fn add_canPractice(&mut self, canPractice: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_CANPRACTICE, canPractice, false);
    }
    #[inline]
    pub fn add_canBattleReplay(&mut self, canBattleReplay: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_CANBATTLEREPLAY,
            canBattleReplay,
            false,
        );
    }
    #[inline]
    pub fn add_apCost(&mut self, apCost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_APCOST, apCost, 0);
    }
    #[inline]
    pub fn add_apFailReturn(&mut self, apFailReturn: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_APFAILRETURN, apFailReturn, 0);
    }
    #[inline]
    pub fn add_maxSlot(&mut self, maxSlot: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_MAXSLOT, maxSlot, 0);
    }
    #[inline]
    pub fn add_etItemId(&mut self, etItemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_ETITEMID,
            etItemId,
        );
    }
    #[inline]
    pub fn add_etCost(&mut self, etCost: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_ETCOST, etCost, 0);
    }
    #[inline]
    pub fn add_etFailReturn(&mut self, etFailReturn: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_ETFAILRETURN, etFailReturn, 0);
    }
    #[inline]
    pub fn add_etButtonStyle(&mut self, etButtonStyle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_ETBUTTONSTYLE,
            etButtonStyle,
        );
    }
    #[inline]
    pub fn add_apProtectTimes(&mut self, apProtectTimes: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_APPROTECTTIMES, apProtectTimes, 0);
    }
    #[inline]
    pub fn add_diamondOnceDrop(&mut self, diamondOnceDrop: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_StageData::VT_DIAMONDONCEDROP,
            diamondOnceDrop,
            0,
        );
    }
    #[inline]
    pub fn add_practiceTicketCost(&mut self, practiceTicketCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_StageData::VT_PRACTICETICKETCOST,
            practiceTicketCost,
            0,
        );
    }
    #[inline]
    pub fn add_dailyStageDifficulty(&mut self, dailyStageDifficulty: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_StageData::VT_DAILYSTAGEDIFFICULTY,
            dailyStageDifficulty,
            0,
        );
    }
    #[inline]
    pub fn add_expGain(&mut self, expGain: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_EXPGAIN, expGain, 0);
    }
    #[inline]
    pub fn add_goldGain(&mut self, goldGain: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_GOLDGAIN, goldGain, 0);
    }
    #[inline]
    pub fn add_loseExpGain(&mut self, loseExpGain: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_LOSEEXPGAIN, loseExpGain, 0);
    }
    #[inline]
    pub fn add_loseGoldGain(&mut self, loseGoldGain: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_LOSEGOLDGAIN, loseGoldGain, 0);
    }
    #[inline]
    pub fn add_passFavor(&mut self, passFavor: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_PASSFAVOR, passFavor, 0);
    }
    #[inline]
    pub fn add_completeFavor(&mut self, completeFavor: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_COMPLETEFAVOR, completeFavor, 0);
    }
    #[inline]
    pub fn add_slProgress(&mut self, slProgress: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_StageData::VT_SLPROGRESS, slProgress, 0);
    }
    #[inline]
    pub fn add_displayMainItem(&mut self, displayMainItem: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_DISPLAYMAINITEM,
            displayMainItem,
        );
    }
    #[inline]
    pub fn add_hilightMark(&mut self, hilightMark: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_HILIGHTMARK, hilightMark, false);
    }
    #[inline]
    pub fn add_bossMark(&mut self, bossMark: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_BOSSMARK, bossMark, false);
    }
    #[inline]
    pub fn add_isPredefined(&mut self, isPredefined: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_ISPREDEFINED, isPredefined, false);
    }
    #[inline]
    pub fn add_isHardPredefined(&mut self, isHardPredefined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_ISHARDPREDEFINED,
            isHardPredefined,
            false,
        );
    }
    #[inline]
    pub fn add_isSkillSelectablePredefined(&mut self, isSkillSelectablePredefined: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_ISSKILLSELECTABLEPREDEFINED,
            isSkillSelectablePredefined,
            false,
        );
    }
    #[inline]
    pub fn add_isStoryOnly(&mut self, isStoryOnly: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_ISSTORYONLY, isStoryOnly, false);
    }
    #[inline]
    pub fn add_appearanceStyle(&mut self, appearanceStyle: enum__Torappu_AppearanceStyle) {
        self.fbb_.push_slot::<enum__Torappu_AppearanceStyle>(
            clz_Torappu_StageData::VT_APPEARANCESTYLE,
            appearanceStyle,
            enum__Torappu_AppearanceStyle::MAIN_NORMAL,
        );
    }
    #[inline]
    pub fn add_stageDropInfo(
        &mut self,
        stageDropInfo: flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StageData_StageDropInfo>>(
                clz_Torappu_StageData::VT_STAGEDROPINFO,
                stageDropInfo,
            );
    }
    #[inline]
    pub fn add_canUseCharm(&mut self, canUseCharm: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_CANUSECHARM, canUseCharm, false);
    }
    #[inline]
    pub fn add_canUseTech(&mut self, canUseTech: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_CANUSETECH, canUseTech, false);
    }
    #[inline]
    pub fn add_canUseTrapTool(&mut self, canUseTrapTool: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_CANUSETRAPTOOL,
            canUseTrapTool,
            false,
        );
    }
    #[inline]
    pub fn add_canUseBattlePerformance(&mut self, canUseBattlePerformance: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_CANUSEBATTLEPERFORMANCE,
            canUseBattlePerformance,
            false,
        );
    }
    #[inline]
    pub fn add_canUseFirework(&mut self, canUseFirework: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_CANUSEFIREWORK,
            canUseFirework,
            false,
        );
    }
    #[inline]
    pub fn add_canMultipleBattle(&mut self, canMultipleBattle: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_CANMULTIPLEBATTLE,
            canMultipleBattle,
            false,
        );
    }
    #[inline]
    pub fn add_startButtonOverrideId(
        &mut self,
        startButtonOverrideId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_STARTBUTTONOVERRIDEID,
            startButtonOverrideId,
        );
    }
    #[inline]
    pub fn add_isStagePatch(&mut self, isStagePatch: bool) {
        self.fbb_
            .push_slot::<bool>(clz_Torappu_StageData::VT_ISSTAGEPATCH, isStagePatch, false);
    }
    #[inline]
    pub fn add_mainStageId(&mut self, mainStageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_MAINSTAGEID,
            mainStageId,
        );
    }
    #[inline]
    pub fn add_extraCondition(
        &mut self,
        extraCondition: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_ExtraConditionDesc<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_EXTRACONDITION,
            extraCondition,
        );
    }
    #[inline]
    pub fn add_extraInfo(
        &mut self,
        extraInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_StageData_SpecialStoryInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_EXTRAINFO,
            extraInfo,
        );
    }
    #[inline]
    pub fn add_sixStarBaseDesc(&mut self, sixStarBaseDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_SIXSTARBASEDESC,
            sixStarBaseDesc,
        );
    }
    #[inline]
    pub fn add_sixStarDisplayRewardList(
        &mut self,
        sixStarDisplayRewardList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_SIXSTARDISPLAYREWARDLIST,
            sixStarDisplayRewardList,
        );
    }
    #[inline]
    pub fn add_advancedRuneIdList1(
        &mut self,
        advancedRuneIdList1: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_ADVANCEDRUNEIDLIST1,
            advancedRuneIdList1,
        );
    }
    #[inline]
    pub fn add_advancedRuneIdList2(
        &mut self,
        advancedRuneIdList2: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_StageData::VT_ADVANCEDRUNEIDLIST2,
            advancedRuneIdList2,
        );
    }
    #[inline]
    pub fn add_useSpecialSizeMapPreview(&mut self, useSpecialSizeMapPreview: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_StageData::VT_USESPECIALSIZEMAPPREVIEW,
            useSpecialSizeMapPreview,
            false,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_StageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_StageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_StageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_StageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_StageData");
        ds.field("stageType", &self.stageType());
        ds.field("difficulty", &self.difficulty());
        ds.field("performanceStageFlag", &self.performanceStageFlag());
        ds.field("diffGroup", &self.diffGroup());
        ds.field("unlockCondition", &self.unlockCondition());
        ds.field("stageId", &self.stageId());
        ds.field("levelId", &self.levelId());
        ds.field("zoneId", &self.zoneId());
        ds.field("code", &self.code());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("hardStagedId", &self.hardStagedId());
        ds.field("sixStarStageId", &self.sixStarStageId());
        ds.field("dangerLevel", &self.dangerLevel());
        ds.field("dangerPoint", &self.dangerPoint());
        ds.field("loadingPicId", &self.loadingPicId());
        ds.field("canPractice", &self.canPractice());
        ds.field("canBattleReplay", &self.canBattleReplay());
        ds.field("apCost", &self.apCost());
        ds.field("apFailReturn", &self.apFailReturn());
        ds.field("maxSlot", &self.maxSlot());
        ds.field("etItemId", &self.etItemId());
        ds.field("etCost", &self.etCost());
        ds.field("etFailReturn", &self.etFailReturn());
        ds.field("etButtonStyle", &self.etButtonStyle());
        ds.field("apProtectTimes", &self.apProtectTimes());
        ds.field("diamondOnceDrop", &self.diamondOnceDrop());
        ds.field("practiceTicketCost", &self.practiceTicketCost());
        ds.field("dailyStageDifficulty", &self.dailyStageDifficulty());
        ds.field("expGain", &self.expGain());
        ds.field("goldGain", &self.goldGain());
        ds.field("loseExpGain", &self.loseExpGain());
        ds.field("loseGoldGain", &self.loseGoldGain());
        ds.field("passFavor", &self.passFavor());
        ds.field("completeFavor", &self.completeFavor());
        ds.field("slProgress", &self.slProgress());
        ds.field("displayMainItem", &self.displayMainItem());
        ds.field("hilightMark", &self.hilightMark());
        ds.field("bossMark", &self.bossMark());
        ds.field("isPredefined", &self.isPredefined());
        ds.field("isHardPredefined", &self.isHardPredefined());
        ds.field(
            "isSkillSelectablePredefined",
            &self.isSkillSelectablePredefined(),
        );
        ds.field("isStoryOnly", &self.isStoryOnly());
        ds.field("appearanceStyle", &self.appearanceStyle());
        ds.field("stageDropInfo", &self.stageDropInfo());
        ds.field("canUseCharm", &self.canUseCharm());
        ds.field("canUseTech", &self.canUseTech());
        ds.field("canUseTrapTool", &self.canUseTrapTool());
        ds.field("canUseBattlePerformance", &self.canUseBattlePerformance());
        ds.field("canUseFirework", &self.canUseFirework());
        ds.field("canMultipleBattle", &self.canMultipleBattle());
        ds.field("startButtonOverrideId", &self.startButtonOverrideId());
        ds.field("isStagePatch", &self.isStagePatch());
        ds.field("mainStageId", &self.mainStageId());
        ds.field("extraCondition", &self.extraCondition());
        ds.field("extraInfo", &self.extraInfo());
        ds.field("sixStarBaseDesc", &self.sixStarBaseDesc());
        ds.field("sixStarDisplayRewardList", &self.sixStarDisplayRewardList());
        ds.field("advancedRuneIdList1", &self.advancedRuneIdList1());
        ds.field("advancedRuneIdList2", &self.advancedRuneIdList2());
        ds.field("useSpecialSizeMapPreview", &self.useSpecialSizeMapPreview());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_StageDataT {
    pub stageType: enum__Torappu_StageType,
    pub difficulty: enum__Torappu_LevelData_Difficulty,
    pub performanceStageFlag: enum__Torappu_StageData_PerformanceStageFlag,
    pub diffGroup: enum__Torappu_StageDiffGroup,
    pub unlockCondition: Option<Vec<clz_Torappu_StageData_ConditionDescT>>,
    pub stageId: Option<String>,
    pub levelId: Option<String>,
    pub zoneId: Option<String>,
    pub code: Option<String>,
    pub name: Option<String>,
    pub description: Option<String>,
    pub hardStagedId: Option<String>,
    pub sixStarStageId: Option<String>,
    pub dangerLevel: Option<String>,
    pub dangerPoint: f32,
    pub loadingPicId: Option<String>,
    pub canPractice: bool,
    pub canBattleReplay: bool,
    pub apCost: i32,
    pub apFailReturn: i32,
    pub maxSlot: i32,
    pub etItemId: Option<String>,
    pub etCost: i32,
    pub etFailReturn: i32,
    pub etButtonStyle: Option<String>,
    pub apProtectTimes: i32,
    pub diamondOnceDrop: i32,
    pub practiceTicketCost: i32,
    pub dailyStageDifficulty: i32,
    pub expGain: i32,
    pub goldGain: i32,
    pub loseExpGain: i32,
    pub loseGoldGain: i32,
    pub passFavor: i32,
    pub completeFavor: i32,
    pub slProgress: i32,
    pub displayMainItem: Option<String>,
    pub hilightMark: bool,
    pub bossMark: bool,
    pub isPredefined: bool,
    pub isHardPredefined: bool,
    pub isSkillSelectablePredefined: bool,
    pub isStoryOnly: bool,
    pub appearanceStyle: enum__Torappu_AppearanceStyle,
    pub stageDropInfo: Option<Box<clz_Torappu_StageData_StageDropInfoT>>,
    pub canUseCharm: bool,
    pub canUseTech: bool,
    pub canUseTrapTool: bool,
    pub canUseBattlePerformance: bool,
    pub canUseFirework: bool,
    pub canMultipleBattle: bool,
    pub startButtonOverrideId: Option<String>,
    pub isStagePatch: bool,
    pub mainStageId: Option<String>,
    pub extraCondition: Option<Vec<clz_Torappu_StageData_ExtraConditionDescT>>,
    pub extraInfo: Option<Vec<clz_Torappu_StageData_SpecialStoryInfoT>>,
    pub sixStarBaseDesc: Option<String>,
    pub sixStarDisplayRewardList: Option<Vec<clz_Torappu_ItemBundleT>>,
    pub advancedRuneIdList1: Option<Vec<String>>,
    pub advancedRuneIdList2: Option<Vec<String>>,
    pub useSpecialSizeMapPreview: bool,
}
impl Default for clz_Torappu_StageDataT {
    fn default() -> Self {
        Self {
            stageType: enum__Torappu_StageType::MAIN,
            difficulty: enum__Torappu_LevelData_Difficulty::NONE,
            performanceStageFlag: enum__Torappu_StageData_PerformanceStageFlag::NORMAL_STAGE,
            diffGroup: enum__Torappu_StageDiffGroup::NONE,
            unlockCondition: None,
            stageId: None,
            levelId: None,
            zoneId: None,
            code: None,
            name: None,
            description: None,
            hardStagedId: None,
            sixStarStageId: None,
            dangerLevel: None,
            dangerPoint: 0.0,
            loadingPicId: None,
            canPractice: false,
            canBattleReplay: false,
            apCost: 0,
            apFailReturn: 0,
            maxSlot: 0,
            etItemId: None,
            etCost: 0,
            etFailReturn: 0,
            etButtonStyle: None,
            apProtectTimes: 0,
            diamondOnceDrop: 0,
            practiceTicketCost: 0,
            dailyStageDifficulty: 0,
            expGain: 0,
            goldGain: 0,
            loseExpGain: 0,
            loseGoldGain: 0,
            passFavor: 0,
            completeFavor: 0,
            slProgress: 0,
            displayMainItem: None,
            hilightMark: false,
            bossMark: false,
            isPredefined: false,
            isHardPredefined: false,
            isSkillSelectablePredefined: false,
            isStoryOnly: false,
            appearanceStyle: enum__Torappu_AppearanceStyle::MAIN_NORMAL,
            stageDropInfo: None,
            canUseCharm: false,
            canUseTech: false,
            canUseTrapTool: false,
            canUseBattlePerformance: false,
            canUseFirework: false,
            canMultipleBattle: false,
            startButtonOverrideId: None,
            isStagePatch: false,
            mainStageId: None,
            extraCondition: None,
            extraInfo: None,
            sixStarBaseDesc: None,
            sixStarDisplayRewardList: None,
            advancedRuneIdList1: None,
            advancedRuneIdList2: None,
            useSpecialSizeMapPreview: false,
        }
    }
}
impl clz_Torappu_StageDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_StageData<'b>> {
        let stageType = self.stageType;
        let difficulty = self.difficulty;
        let performanceStageFlag = self.performanceStageFlag;
        let diffGroup = self.diffGroup;
        let unlockCondition = self.unlockCondition.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        let levelId = self.levelId.as_ref().map(|x| _fbb.create_string(x));
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let code = self.code.as_ref().map(|x| _fbb.create_string(x));
        let name = self.name.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let hardStagedId = self.hardStagedId.as_ref().map(|x| _fbb.create_string(x));
        let sixStarStageId = self.sixStarStageId.as_ref().map(|x| _fbb.create_string(x));
        let dangerLevel = self.dangerLevel.as_ref().map(|x| _fbb.create_string(x));
        let dangerPoint = self.dangerPoint;
        let loadingPicId = self.loadingPicId.as_ref().map(|x| _fbb.create_string(x));
        let canPractice = self.canPractice;
        let canBattleReplay = self.canBattleReplay;
        let apCost = self.apCost;
        let apFailReturn = self.apFailReturn;
        let maxSlot = self.maxSlot;
        let etItemId = self.etItemId.as_ref().map(|x| _fbb.create_string(x));
        let etCost = self.etCost;
        let etFailReturn = self.etFailReturn;
        let etButtonStyle = self.etButtonStyle.as_ref().map(|x| _fbb.create_string(x));
        let apProtectTimes = self.apProtectTimes;
        let diamondOnceDrop = self.diamondOnceDrop;
        let practiceTicketCost = self.practiceTicketCost;
        let dailyStageDifficulty = self.dailyStageDifficulty;
        let expGain = self.expGain;
        let goldGain = self.goldGain;
        let loseExpGain = self.loseExpGain;
        let loseGoldGain = self.loseGoldGain;
        let passFavor = self.passFavor;
        let completeFavor = self.completeFavor;
        let slProgress = self.slProgress;
        let displayMainItem = self.displayMainItem.as_ref().map(|x| _fbb.create_string(x));
        let hilightMark = self.hilightMark;
        let bossMark = self.bossMark;
        let isPredefined = self.isPredefined;
        let isHardPredefined = self.isHardPredefined;
        let isSkillSelectablePredefined = self.isSkillSelectablePredefined;
        let isStoryOnly = self.isStoryOnly;
        let appearanceStyle = self.appearanceStyle;
        let stageDropInfo = self.stageDropInfo.as_ref().map(|x| x.pack(_fbb));
        let canUseCharm = self.canUseCharm;
        let canUseTech = self.canUseTech;
        let canUseTrapTool = self.canUseTrapTool;
        let canUseBattlePerformance = self.canUseBattlePerformance;
        let canUseFirework = self.canUseFirework;
        let canMultipleBattle = self.canMultipleBattle;
        let startButtonOverrideId = self
            .startButtonOverrideId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let isStagePatch = self.isStagePatch;
        let mainStageId = self.mainStageId.as_ref().map(|x| _fbb.create_string(x));
        let extraCondition = self.extraCondition.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let extraInfo = self.extraInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let sixStarBaseDesc = self.sixStarBaseDesc.as_ref().map(|x| _fbb.create_string(x));
        let sixStarDisplayRewardList = self.sixStarDisplayRewardList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let advancedRuneIdList1 = self.advancedRuneIdList1.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let advancedRuneIdList2 = self.advancedRuneIdList2.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let useSpecialSizeMapPreview = self.useSpecialSizeMapPreview;
        clz_Torappu_StageData::create(
            _fbb,
            &clz_Torappu_StageDataArgs {
                stageType,
                difficulty,
                performanceStageFlag,
                diffGroup,
                unlockCondition,
                stageId,
                levelId,
                zoneId,
                code,
                name,
                description,
                hardStagedId,
                sixStarStageId,
                dangerLevel,
                dangerPoint,
                loadingPicId,
                canPractice,
                canBattleReplay,
                apCost,
                apFailReturn,
                maxSlot,
                etItemId,
                etCost,
                etFailReturn,
                etButtonStyle,
                apProtectTimes,
                diamondOnceDrop,
                practiceTicketCost,
                dailyStageDifficulty,
                expGain,
                goldGain,
                loseExpGain,
                loseGoldGain,
                passFavor,
                completeFavor,
                slProgress,
                displayMainItem,
                hilightMark,
                bossMark,
                isPredefined,
                isHardPredefined,
                isSkillSelectablePredefined,
                isStoryOnly,
                appearanceStyle,
                stageDropInfo,
                canUseCharm,
                canUseTech,
                canUseTrapTool,
                canUseBattlePerformance,
                canUseFirework,
                canMultipleBattle,
                startButtonOverrideId,
                isStagePatch,
                mainStageId,
                extraCondition,
                extraInfo,
                sixStarBaseDesc,
                sixStarDisplayRewardList,
                advancedRuneIdList1,
                advancedRuneIdList2,
                useSpecialSizeMapPreview,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_StageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_StageData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_StageData<'a> {
    type Inner = dict__string__clz_Torappu_StageData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_StageData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_StageData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_StageDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_StageDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_StageDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_StageDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_StageData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_StageData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_StageData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData>>(
                    dict__string__clz_Torappu_StageData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_StageData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_StageData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_StageDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_StageData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_StageDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_StageDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_StageData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_StageData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_StageDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_StageDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_StageData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_StageData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_StageData>>(
                dict__string__clz_Torappu_StageData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_StageDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_StageDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_StageData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_StageData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_StageData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_StageDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_StageDataT>>,
}
impl Default for dict__string__clz_Torappu_StageDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_StageDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_StageData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_StageData::create(
            _fbb,
            &dict__string__clz_Torappu_StageDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RetroTrailRuleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RetroTrailRuleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RetroTrailRuleData<'a> {
    type Inner = clz_Torappu_RetroTrailRuleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RetroTrailRuleData<'a> {
    pub const VT_TITLE: flatbuffers::VOffsetT = 4;
    pub const VT_DESC: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RetroTrailRuleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RetroTrailRuleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RetroTrailRuleData<'bldr>> {
        let mut builder = clz_Torappu_RetroTrailRuleDataBuilder::new(_fbb);
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RetroTrailRuleDataT {
        let title = self
            .title()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let desc = self
            .desc()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_RetroTrailRuleDataT { title, desc }
    }

    #[inline]
    pub fn title(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RetroTrailRuleData::VT_TITLE, None)
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RetroTrailRuleData::VT_DESC, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RetroTrailRuleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("desc", Self::VT_DESC, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RetroTrailRuleDataArgs<'a> {
    pub title: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub desc: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_RetroTrailRuleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RetroTrailRuleDataArgs {
            title: None,
            desc: None,
        }
    }
}

impl Serialize for clz_Torappu_RetroTrailRuleData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RetroTrailRuleData", 2)?;
        if let Some(f) = self.title() {
            s.serialize_field("title", &f)?;
        } else {
            s.skip_field("title")?;
        }
        if let Some(f) = self.desc() {
            s.serialize_field("desc", &f)?;
        } else {
            s.skip_field("desc")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RetroTrailRuleDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RetroTrailRuleDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_title(
        &mut self,
        title: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroTrailRuleData::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_desc(
        &mut self,
        desc: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroTrailRuleData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RetroTrailRuleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RetroTrailRuleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RetroTrailRuleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RetroTrailRuleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RetroTrailRuleData");
        ds.field("title", &self.title());
        ds.field("desc", &self.desc());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RetroTrailRuleDataT {
    pub title: Option<Vec<String>>,
    pub desc: Option<Vec<String>>,
}
impl Default for clz_Torappu_RetroTrailRuleDataT {
    fn default() -> Self {
        Self {
            title: None,
            desc: None,
        }
    }
}
impl clz_Torappu_RetroTrailRuleDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RetroTrailRuleData<'b>> {
        let title = self.title.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let desc = self.desc.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RetroTrailRuleData::create(
            _fbb,
            &clz_Torappu_RetroTrailRuleDataArgs { title, desc },
        )
    }
}
pub enum clz_Torappu_Act17sideData_PlaceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_PlaceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_PlaceData<'a> {
    type Inner = clz_Torappu_Act17sideData_PlaceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_PlaceData<'a> {
    pub const VT_PLACEID: flatbuffers::VOffsetT = 4;
    pub const VT_PLACEDESC: flatbuffers::VOffsetT = 6;
    pub const VT_LOCKEVENTID: flatbuffers::VOffsetT = 8;
    pub const VT_ZONEID: flatbuffers::VOffsetT = 10;
    pub const VT_VISIBLECONDTYPE: flatbuffers::VOffsetT = 12;
    pub const VT_VISIBLEPARAMS: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_PlaceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_PlaceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_PlaceData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_PlaceDataBuilder::new(_fbb);
        if let Some(x) = args.visibleParams {
            builder.add_visibleParams(x);
        }
        if let Some(x) = args.visibleCondType {
            builder.add_visibleCondType(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        if let Some(x) = args.lockEventId {
            builder.add_lockEventId(x);
        }
        if let Some(x) = args.placeDesc {
            builder.add_placeDesc(x);
        }
        if let Some(x) = args.placeId {
            builder.add_placeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_PlaceDataT {
        let placeId = self.placeId().map(|x| x.to_string());
        let placeDesc = self.placeDesc().map(|x| x.to_string());
        let lockEventId = self.lockEventId().map(|x| x.to_string());
        let zoneId = self.zoneId().map(|x| x.to_string());
        let visibleCondType = self.visibleCondType().map(|x| x.to_string());
        let visibleParams = self
            .visibleParams()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_Act17sideData_PlaceDataT {
            placeId,
            placeDesc,
            lockEventId,
            zoneId,
            visibleCondType,
            visibleParams,
        }
    }

    #[inline]
    pub fn placeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_PlaceData::VT_PLACEID,
                None,
            )
        }
    }
    #[inline]
    pub fn placeDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_PlaceData::VT_PLACEDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn lockEventId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_PlaceData::VT_LOCKEVENTID,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_PlaceData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn visibleCondType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_PlaceData::VT_VISIBLECONDTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn visibleParams(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_Act17sideData_PlaceData::VT_VISIBLEPARAMS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_PlaceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("placeId", Self::VT_PLACEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "placeDesc",
                Self::VT_PLACEDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "lockEventId",
                Self::VT_LOCKEVENTID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "visibleCondType",
                Self::VT_VISIBLECONDTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("visibleParams", Self::VT_VISIBLEPARAMS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_PlaceDataArgs<'a> {
    pub placeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub placeDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lockEventId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub visibleCondType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub visibleParams: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_Act17sideData_PlaceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_PlaceDataArgs {
            placeId: None,
            placeDesc: None,
            lockEventId: None,
            zoneId: None,
            visibleCondType: None,
            visibleParams: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_PlaceData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act17sideData_PlaceData", 6)?;
        if let Some(f) = self.placeId() {
            s.serialize_field("placeId", &f)?;
        } else {
            s.skip_field("placeId")?;
        }
        if let Some(f) = self.placeDesc() {
            s.serialize_field("placeDesc", &f)?;
        } else {
            s.skip_field("placeDesc")?;
        }
        if let Some(f) = self.lockEventId() {
            s.serialize_field("lockEventId", &f)?;
        } else {
            s.skip_field("lockEventId")?;
        }
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.visibleCondType() {
            s.serialize_field("visibleCondType", &f)?;
        } else {
            s.skip_field("visibleCondType")?;
        }
        if let Some(f) = self.visibleParams() {
            s.serialize_field("visibleParams", &f)?;
        } else {
            s.skip_field("visibleParams")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_PlaceDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_PlaceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_placeId(&mut self, placeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_PlaceData::VT_PLACEID,
            placeId,
        );
    }
    #[inline]
    pub fn add_placeDesc(&mut self, placeDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_PlaceData::VT_PLACEDESC,
            placeDesc,
        );
    }
    #[inline]
    pub fn add_lockEventId(&mut self, lockEventId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_PlaceData::VT_LOCKEVENTID,
            lockEventId,
        );
    }
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_PlaceData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_visibleCondType(&mut self, visibleCondType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_PlaceData::VT_VISIBLECONDTYPE,
            visibleCondType,
        );
    }
    #[inline]
    pub fn add_visibleParams(
        &mut self,
        visibleParams: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_PlaceData::VT_VISIBLEPARAMS,
            visibleParams,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_PlaceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_PlaceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_PlaceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_PlaceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_PlaceData");
        ds.field("placeId", &self.placeId());
        ds.field("placeDesc", &self.placeDesc());
        ds.field("lockEventId", &self.lockEventId());
        ds.field("zoneId", &self.zoneId());
        ds.field("visibleCondType", &self.visibleCondType());
        ds.field("visibleParams", &self.visibleParams());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_PlaceDataT {
    pub placeId: Option<String>,
    pub placeDesc: Option<String>,
    pub lockEventId: Option<String>,
    pub zoneId: Option<String>,
    pub visibleCondType: Option<String>,
    pub visibleParams: Option<Vec<String>>,
}
impl Default for clz_Torappu_Act17sideData_PlaceDataT {
    fn default() -> Self {
        Self {
            placeId: None,
            placeDesc: None,
            lockEventId: None,
            zoneId: None,
            visibleCondType: None,
            visibleParams: None,
        }
    }
}
impl clz_Torappu_Act17sideData_PlaceDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_PlaceData<'b>> {
        let placeId = self.placeId.as_ref().map(|x| _fbb.create_string(x));
        let placeDesc = self.placeDesc.as_ref().map(|x| _fbb.create_string(x));
        let lockEventId = self.lockEventId.as_ref().map(|x| _fbb.create_string(x));
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let visibleCondType = self.visibleCondType.as_ref().map(|x| _fbb.create_string(x));
        let visibleParams = self.visibleParams.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_Act17sideData_PlaceData::create(
            _fbb,
            &clz_Torappu_Act17sideData_PlaceDataArgs {
                placeId,
                placeDesc,
                lockEventId,
                zoneId,
                visibleCondType,
                visibleParams,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideData_PlaceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData_PlaceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act17sideData_PlaceData<'a> {
    type Inner = dict__string__clz_Torappu_Act17sideData_PlaceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData_PlaceData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData_PlaceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideData_PlaceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_PlaceData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_Act17sideData_PlaceDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideData_PlaceDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideData_PlaceDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData_PlaceData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act17sideData_PlaceData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData_PlaceData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_PlaceData>>(
                    dict__string__clz_Torappu_Act17sideData_PlaceData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData_PlaceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_PlaceData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideData_PlaceDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_PlaceData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideData_PlaceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideData_PlaceDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData_PlaceData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_Act17sideData_PlaceData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideData_PlaceDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideData_PlaceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData_PlaceData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_PlaceData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_PlaceData>>(
                dict__string__clz_Torappu_Act17sideData_PlaceData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideData_PlaceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideData_PlaceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_PlaceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act17sideData_PlaceData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData_PlaceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act17sideData_PlaceData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideData_PlaceDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideData_PlaceDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideData_PlaceDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideData_PlaceDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_PlaceData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData_PlaceData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideData_PlaceDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act17sideData_NodeInfoDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_NodeInfoData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_NodeInfoData<'a> {
    type Inner = clz_Torappu_Act17sideData_NodeInfoData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_NodeInfoData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_NODETYPE: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;
    pub const VT_PLACEID: flatbuffers::VOffsetT = 10;
    pub const VT_ISPOINTPLACE: flatbuffers::VOffsetT = 12;
    pub const VT_CHAPTERID: flatbuffers::VOffsetT = 14;
    pub const VT_TRACKPOINTTYPE: flatbuffers::VOffsetT = 16;
    pub const VT_UNLOCKCONDTYPE: flatbuffers::VOffsetT = 18;
    pub const VT_UNLOCKPARAMS: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_NodeInfoData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_NodeInfoDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_NodeInfoData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_NodeInfoDataBuilder::new(_fbb);
        if let Some(x) = args.unlockParams {
            builder.add_unlockParams(x);
        }
        if let Some(x) = args.unlockCondType {
            builder.add_unlockCondType(x);
        }
        builder.add_trackPointType(args.trackPointType);
        if let Some(x) = args.chapterId {
            builder.add_chapterId(x);
        }
        if let Some(x) = args.placeId {
            builder.add_placeId(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_nodeType(args.nodeType);
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.add_isPointPlace(args.isPointPlace);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_NodeInfoDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        let nodeType = self.nodeType();
        let sortId = self.sortId();
        let placeId = self.placeId().map(|x| x.to_string());
        let isPointPlace = self.isPointPlace();
        let chapterId = self.chapterId().map(|x| x.to_string());
        let trackPointType = self.trackPointType();
        let unlockCondType = self.unlockCondType().map(|x| x.to_string());
        let unlockParams = self
            .unlockParams()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_Act17sideData_NodeInfoDataT {
            nodeId,
            nodeType,
            sortId,
            placeId,
            isPointPlace,
            chapterId,
            trackPointType,
            unlockCondType,
            unlockParams,
        }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_NodeInfoData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeType(&self) -> enum__Torappu_Act17sideData_NodeType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Act17sideData_NodeType>(
                    clz_Torappu_Act17sideData_NodeInfoData::VT_NODETYPE,
                    Some(enum__Torappu_Act17sideData_NodeType::LANDMARK),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_Act17sideData_NodeInfoData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn placeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_NodeInfoData::VT_PLACEID,
                None,
            )
        }
    }
    #[inline]
    pub fn isPointPlace(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Act17sideData_NodeInfoData::VT_ISPOINTPLACE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn chapterId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_NodeInfoData::VT_CHAPTERID,
                None,
            )
        }
    }
    #[inline]
    pub fn trackPointType(&self) -> enum__Torappu_Act17sideData_TrackPointType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Act17sideData_TrackPointType>(
                    clz_Torappu_Act17sideData_NodeInfoData::VT_TRACKPOINTTYPE,
                    Some(enum__Torappu_Act17sideData_TrackPointType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockCondType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_NodeInfoData::VT_UNLOCKCONDTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockParams(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_Act17sideData_NodeInfoData::VT_UNLOCKPARAMS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_NodeInfoData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<enum__Torappu_Act17sideData_NodeType>(
                "nodeType",
                Self::VT_NODETYPE,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("placeId", Self::VT_PLACEID, false)?
            .visit_field::<bool>("isPointPlace", Self::VT_ISPOINTPLACE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "chapterId",
                Self::VT_CHAPTERID,
                false,
            )?
            .visit_field::<enum__Torappu_Act17sideData_TrackPointType>(
                "trackPointType",
                Self::VT_TRACKPOINTTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockCondType",
                Self::VT_UNLOCKCONDTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("unlockParams", Self::VT_UNLOCKPARAMS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_NodeInfoDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeType: enum__Torappu_Act17sideData_NodeType,
    pub sortId: i32,
    pub placeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isPointPlace: bool,
    pub chapterId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub trackPointType: enum__Torappu_Act17sideData_TrackPointType,
    pub unlockCondType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockParams: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_Act17sideData_NodeInfoDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_NodeInfoDataArgs {
            nodeId: None,
            nodeType: enum__Torappu_Act17sideData_NodeType::LANDMARK,
            sortId: 0,
            placeId: None,
            isPointPlace: false,
            chapterId: None,
            trackPointType: enum__Torappu_Act17sideData_TrackPointType::NONE,
            unlockCondType: None,
            unlockParams: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_NodeInfoData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act17sideData_NodeInfoData", 9)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        s.serialize_field("nodeType", &self.nodeType())?;
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.placeId() {
            s.serialize_field("placeId", &f)?;
        } else {
            s.skip_field("placeId")?;
        }
        s.serialize_field("isPointPlace", &self.isPointPlace())?;
        if let Some(f) = self.chapterId() {
            s.serialize_field("chapterId", &f)?;
        } else {
            s.skip_field("chapterId")?;
        }
        s.serialize_field("trackPointType", &self.trackPointType())?;
        if let Some(f) = self.unlockCondType() {
            s.serialize_field("unlockCondType", &f)?;
        } else {
            s.skip_field("unlockCondType")?;
        }
        if let Some(f) = self.unlockParams() {
            s.serialize_field("unlockParams", &f)?;
        } else {
            s.skip_field("unlockParams")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_NodeInfoDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_NodeInfoDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_NodeInfoData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_nodeType(&mut self, nodeType: enum__Torappu_Act17sideData_NodeType) {
        self.fbb_.push_slot::<enum__Torappu_Act17sideData_NodeType>(
            clz_Torappu_Act17sideData_NodeInfoData::VT_NODETYPE,
            nodeType,
            enum__Torappu_Act17sideData_NodeType::LANDMARK,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_Act17sideData_NodeInfoData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_placeId(&mut self, placeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_NodeInfoData::VT_PLACEID,
            placeId,
        );
    }
    #[inline]
    pub fn add_isPointPlace(&mut self, isPointPlace: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Act17sideData_NodeInfoData::VT_ISPOINTPLACE,
            isPointPlace,
            false,
        );
    }
    #[inline]
    pub fn add_chapterId(&mut self, chapterId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_NodeInfoData::VT_CHAPTERID,
            chapterId,
        );
    }
    #[inline]
    pub fn add_trackPointType(
        &mut self,
        trackPointType: enum__Torappu_Act17sideData_TrackPointType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_Act17sideData_TrackPointType>(
                clz_Torappu_Act17sideData_NodeInfoData::VT_TRACKPOINTTYPE,
                trackPointType,
                enum__Torappu_Act17sideData_TrackPointType::NONE,
            );
    }
    #[inline]
    pub fn add_unlockCondType(&mut self, unlockCondType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_NodeInfoData::VT_UNLOCKCONDTYPE,
            unlockCondType,
        );
    }
    #[inline]
    pub fn add_unlockParams(
        &mut self,
        unlockParams: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_NodeInfoData::VT_UNLOCKPARAMS,
            unlockParams,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_NodeInfoDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_NodeInfoDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_NodeInfoData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_NodeInfoData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_NodeInfoData");
        ds.field("nodeId", &self.nodeId());
        ds.field("nodeType", &self.nodeType());
        ds.field("sortId", &self.sortId());
        ds.field("placeId", &self.placeId());
        ds.field("isPointPlace", &self.isPointPlace());
        ds.field("chapterId", &self.chapterId());
        ds.field("trackPointType", &self.trackPointType());
        ds.field("unlockCondType", &self.unlockCondType());
        ds.field("unlockParams", &self.unlockParams());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_NodeInfoDataT {
    pub nodeId: Option<String>,
    pub nodeType: enum__Torappu_Act17sideData_NodeType,
    pub sortId: i32,
    pub placeId: Option<String>,
    pub isPointPlace: bool,
    pub chapterId: Option<String>,
    pub trackPointType: enum__Torappu_Act17sideData_TrackPointType,
    pub unlockCondType: Option<String>,
    pub unlockParams: Option<Vec<String>>,
}
impl Default for clz_Torappu_Act17sideData_NodeInfoDataT {
    fn default() -> Self {
        Self {
            nodeId: None,
            nodeType: enum__Torappu_Act17sideData_NodeType::LANDMARK,
            sortId: 0,
            placeId: None,
            isPointPlace: false,
            chapterId: None,
            trackPointType: enum__Torappu_Act17sideData_TrackPointType::NONE,
            unlockCondType: None,
            unlockParams: None,
        }
    }
}
impl clz_Torappu_Act17sideData_NodeInfoDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_NodeInfoData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let nodeType = self.nodeType;
        let sortId = self.sortId;
        let placeId = self.placeId.as_ref().map(|x| _fbb.create_string(x));
        let isPointPlace = self.isPointPlace;
        let chapterId = self.chapterId.as_ref().map(|x| _fbb.create_string(x));
        let trackPointType = self.trackPointType;
        let unlockCondType = self.unlockCondType.as_ref().map(|x| _fbb.create_string(x));
        let unlockParams = self.unlockParams.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_Act17sideData_NodeInfoData::create(
            _fbb,
            &clz_Torappu_Act17sideData_NodeInfoDataArgs {
                nodeId,
                nodeType,
                sortId,
                placeId,
                isPointPlace,
                chapterId,
                trackPointType,
                unlockCondType,
                unlockParams,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideData_NodeInfoDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData_NodeInfoData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act17sideData_NodeInfoData<'a> {
    type Inner = dict__string__clz_Torappu_Act17sideData_NodeInfoData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData_NodeInfoData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData_NodeInfoData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideData_NodeInfoDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_NodeInfoData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_Act17sideData_NodeInfoDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideData_NodeInfoDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideData_NodeInfoDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData_NodeInfoData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act17sideData_NodeInfoData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData_NodeInfoData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_NodeInfoData>>(
                    dict__string__clz_Torappu_Act17sideData_NodeInfoData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData_NodeInfoData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_NodeInfoData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideData_NodeInfoDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_NodeInfoData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideData_NodeInfoDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideData_NodeInfoDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData_NodeInfoData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_Act17sideData_NodeInfoData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideData_NodeInfoDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideData_NodeInfoDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData_NodeInfoData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_NodeInfoData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_NodeInfoData>>(
                dict__string__clz_Torappu_Act17sideData_NodeInfoData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideData_NodeInfoDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideData_NodeInfoDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_NodeInfoData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act17sideData_NodeInfoData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData_NodeInfoData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act17sideData_NodeInfoData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideData_NodeInfoDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideData_NodeInfoDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideData_NodeInfoDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideData_NodeInfoDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_NodeInfoData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData_NodeInfoData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideData_NodeInfoDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act17sideData_LandmarkNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_LandmarkNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_LandmarkNodeData<'a> {
    type Inner = clz_Torappu_Act17sideData_LandmarkNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_LandmarkNodeData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_LANDMARKID: flatbuffers::VOffsetT = 6;
    pub const VT_LANDMARKNAME: flatbuffers::VOffsetT = 8;
    pub const VT_LANDMARKPIC: flatbuffers::VOffsetT = 10;
    pub const VT_LANDMARKSPECIALPIC: flatbuffers::VOffsetT = 12;
    pub const VT_LANDMARKDESLIST: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_LandmarkNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_LandmarkNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_LandmarkNodeData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_LandmarkNodeDataBuilder::new(_fbb);
        if let Some(x) = args.landmarkDesList {
            builder.add_landmarkDesList(x);
        }
        if let Some(x) = args.landmarkSpecialPic {
            builder.add_landmarkSpecialPic(x);
        }
        if let Some(x) = args.landmarkPic {
            builder.add_landmarkPic(x);
        }
        if let Some(x) = args.landmarkName {
            builder.add_landmarkName(x);
        }
        if let Some(x) = args.landmarkId {
            builder.add_landmarkId(x);
        }
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_LandmarkNodeDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        let landmarkId = self.landmarkId().map(|x| x.to_string());
        let landmarkName = self.landmarkName().map(|x| x.to_string());
        let landmarkPic = self.landmarkPic().map(|x| x.to_string());
        let landmarkSpecialPic = self.landmarkSpecialPic().map(|x| x.to_string());
        let landmarkDesList = self
            .landmarkDesList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_Act17sideData_LandmarkNodeDataT {
            nodeId,
            landmarkId,
            landmarkName,
            landmarkPic,
            landmarkSpecialPic,
            landmarkDesList,
        }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_LandmarkNodeData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn landmarkId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_LandmarkNodeData::VT_LANDMARKID,
                None,
            )
        }
    }
    #[inline]
    pub fn landmarkName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_LandmarkNodeData::VT_LANDMARKNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn landmarkPic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_LandmarkNodeData::VT_LANDMARKPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn landmarkSpecialPic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_LandmarkNodeData::VT_LANDMARKSPECIALPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn landmarkDesList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_Act17sideData_LandmarkNodeData::VT_LANDMARKDESLIST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_LandmarkNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "landmarkId",
                Self::VT_LANDMARKID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "landmarkName",
                Self::VT_LANDMARKNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "landmarkPic",
                Self::VT_LANDMARKPIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "landmarkSpecialPic",
                Self::VT_LANDMARKSPECIALPIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("landmarkDesList", Self::VT_LANDMARKDESLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_LandmarkNodeDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub landmarkId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub landmarkName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub landmarkPic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub landmarkSpecialPic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub landmarkDesList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_Act17sideData_LandmarkNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_LandmarkNodeDataArgs {
            nodeId: None,
            landmarkId: None,
            landmarkName: None,
            landmarkPic: None,
            landmarkSpecialPic: None,
            landmarkDesList: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_LandmarkNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act17sideData_LandmarkNodeData", 6)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        if let Some(f) = self.landmarkId() {
            s.serialize_field("landmarkId", &f)?;
        } else {
            s.skip_field("landmarkId")?;
        }
        if let Some(f) = self.landmarkName() {
            s.serialize_field("landmarkName", &f)?;
        } else {
            s.skip_field("landmarkName")?;
        }
        if let Some(f) = self.landmarkPic() {
            s.serialize_field("landmarkPic", &f)?;
        } else {
            s.skip_field("landmarkPic")?;
        }
        if let Some(f) = self.landmarkSpecialPic() {
            s.serialize_field("landmarkSpecialPic", &f)?;
        } else {
            s.skip_field("landmarkSpecialPic")?;
        }
        if let Some(f) = self.landmarkDesList() {
            s.serialize_field("landmarkDesList", &f)?;
        } else {
            s.skip_field("landmarkDesList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_LandmarkNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_LandmarkNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_LandmarkNodeData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_landmarkId(&mut self, landmarkId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_LandmarkNodeData::VT_LANDMARKID,
            landmarkId,
        );
    }
    #[inline]
    pub fn add_landmarkName(&mut self, landmarkName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_LandmarkNodeData::VT_LANDMARKNAME,
            landmarkName,
        );
    }
    #[inline]
    pub fn add_landmarkPic(&mut self, landmarkPic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_LandmarkNodeData::VT_LANDMARKPIC,
            landmarkPic,
        );
    }
    #[inline]
    pub fn add_landmarkSpecialPic(&mut self, landmarkSpecialPic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_LandmarkNodeData::VT_LANDMARKSPECIALPIC,
            landmarkSpecialPic,
        );
    }
    #[inline]
    pub fn add_landmarkDesList(
        &mut self,
        landmarkDesList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_LandmarkNodeData::VT_LANDMARKDESLIST,
            landmarkDesList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_LandmarkNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_LandmarkNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_LandmarkNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_LandmarkNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_LandmarkNodeData");
        ds.field("nodeId", &self.nodeId());
        ds.field("landmarkId", &self.landmarkId());
        ds.field("landmarkName", &self.landmarkName());
        ds.field("landmarkPic", &self.landmarkPic());
        ds.field("landmarkSpecialPic", &self.landmarkSpecialPic());
        ds.field("landmarkDesList", &self.landmarkDesList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_LandmarkNodeDataT {
    pub nodeId: Option<String>,
    pub landmarkId: Option<String>,
    pub landmarkName: Option<String>,
    pub landmarkPic: Option<String>,
    pub landmarkSpecialPic: Option<String>,
    pub landmarkDesList: Option<Vec<String>>,
}
impl Default for clz_Torappu_Act17sideData_LandmarkNodeDataT {
    fn default() -> Self {
        Self {
            nodeId: None,
            landmarkId: None,
            landmarkName: None,
            landmarkPic: None,
            landmarkSpecialPic: None,
            landmarkDesList: None,
        }
    }
}
impl clz_Torappu_Act17sideData_LandmarkNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_LandmarkNodeData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let landmarkId = self.landmarkId.as_ref().map(|x| _fbb.create_string(x));
        let landmarkName = self.landmarkName.as_ref().map(|x| _fbb.create_string(x));
        let landmarkPic = self.landmarkPic.as_ref().map(|x| _fbb.create_string(x));
        let landmarkSpecialPic = self
            .landmarkSpecialPic
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let landmarkDesList = self.landmarkDesList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_Act17sideData_LandmarkNodeData::create(
            _fbb,
            &clz_Torappu_Act17sideData_LandmarkNodeDataArgs {
                nodeId,
                landmarkId,
                landmarkName,
                landmarkPic,
                landmarkSpecialPic,
                landmarkDesList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData_LandmarkNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act17sideData_LandmarkNodeData<'a> {
    type Inner = dict__string__clz_Torappu_Act17sideData_LandmarkNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData_LandmarkNodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData_LandmarkNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_LandmarkNodeData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData_LandmarkNodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act17sideData_LandmarkNodeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData_LandmarkNodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_LandmarkNodeData>>(
                    dict__string__clz_Torappu_Act17sideData_LandmarkNodeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData_LandmarkNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_LandmarkNodeData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_LandmarkNodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData_LandmarkNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_Act17sideData_LandmarkNodeData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData_LandmarkNodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_LandmarkNodeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_LandmarkNodeData>>(
                dict__string__clz_Torappu_Act17sideData_LandmarkNodeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_LandmarkNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act17sideData_LandmarkNodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData_LandmarkNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act17sideData_LandmarkNodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideData_LandmarkNodeDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_LandmarkNodeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData_LandmarkNodeData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act17sideData_StoryNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_StoryNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_StoryNodeData<'a> {
    type Inner = clz_Torappu_Act17sideData_StoryNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_StoryNodeData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_STORYID: flatbuffers::VOffsetT = 6;
    pub const VT_STORYKEY: flatbuffers::VOffsetT = 8;
    pub const VT_STORYNAME: flatbuffers::VOffsetT = 10;
    pub const VT_STORYPIC: flatbuffers::VOffsetT = 12;
    pub const VT_CONFIRMDES: flatbuffers::VOffsetT = 14;
    pub const VT_STORYDESLIST: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_StoryNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_StoryNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_StoryNodeData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_StoryNodeDataBuilder::new(_fbb);
        if let Some(x) = args.storyDesList {
            builder.add_storyDesList(x);
        }
        if let Some(x) = args.confirmDes {
            builder.add_confirmDes(x);
        }
        if let Some(x) = args.storyPic {
            builder.add_storyPic(x);
        }
        if let Some(x) = args.storyName {
            builder.add_storyName(x);
        }
        if let Some(x) = args.storyKey {
            builder.add_storyKey(x);
        }
        if let Some(x) = args.storyId {
            builder.add_storyId(x);
        }
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_StoryNodeDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        let storyId = self.storyId().map(|x| x.to_string());
        let storyKey = self.storyKey().map(|x| x.to_string());
        let storyName = self.storyName().map(|x| x.to_string());
        let storyPic = self.storyPic().map(|x| x.to_string());
        let confirmDes = self.confirmDes().map(|x| x.to_string());
        let storyDesList = self
            .storyDesList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_Act17sideData_StoryNodeDataT {
            nodeId,
            storyId,
            storyKey,
            storyName,
            storyPic,
            confirmDes,
            storyDesList,
        }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_StoryNodeData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn storyId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_StoryNodeData::VT_STORYID,
                None,
            )
        }
    }
    #[inline]
    pub fn storyKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_StoryNodeData::VT_STORYKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn storyName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_StoryNodeData::VT_STORYNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn storyPic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_StoryNodeData::VT_STORYPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn confirmDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_StoryNodeData::VT_CONFIRMDES,
                None,
            )
        }
    }
    #[inline]
    pub fn storyDesList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_Act17sideData_StoryNodeData::VT_STORYDESLIST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_StoryNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("storyId", Self::VT_STORYID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "storyKey",
                Self::VT_STORYKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "storyName",
                Self::VT_STORYNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "storyPic",
                Self::VT_STORYPIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "confirmDes",
                Self::VT_CONFIRMDES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("storyDesList", Self::VT_STORYDESLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_StoryNodeDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storyId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storyKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storyName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storyPic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub confirmDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub storyDesList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_Act17sideData_StoryNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_StoryNodeDataArgs {
            nodeId: None,
            storyId: None,
            storyKey: None,
            storyName: None,
            storyPic: None,
            confirmDes: None,
            storyDesList: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_StoryNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act17sideData_StoryNodeData", 7)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        if let Some(f) = self.storyId() {
            s.serialize_field("storyId", &f)?;
        } else {
            s.skip_field("storyId")?;
        }
        if let Some(f) = self.storyKey() {
            s.serialize_field("storyKey", &f)?;
        } else {
            s.skip_field("storyKey")?;
        }
        if let Some(f) = self.storyName() {
            s.serialize_field("storyName", &f)?;
        } else {
            s.skip_field("storyName")?;
        }
        if let Some(f) = self.storyPic() {
            s.serialize_field("storyPic", &f)?;
        } else {
            s.skip_field("storyPic")?;
        }
        if let Some(f) = self.confirmDes() {
            s.serialize_field("confirmDes", &f)?;
        } else {
            s.skip_field("confirmDes")?;
        }
        if let Some(f) = self.storyDesList() {
            s.serialize_field("storyDesList", &f)?;
        } else {
            s.skip_field("storyDesList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_StoryNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_StoryNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_StoryNodeData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_storyId(&mut self, storyId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_StoryNodeData::VT_STORYID,
            storyId,
        );
    }
    #[inline]
    pub fn add_storyKey(&mut self, storyKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_StoryNodeData::VT_STORYKEY,
            storyKey,
        );
    }
    #[inline]
    pub fn add_storyName(&mut self, storyName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_StoryNodeData::VT_STORYNAME,
            storyName,
        );
    }
    #[inline]
    pub fn add_storyPic(&mut self, storyPic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_StoryNodeData::VT_STORYPIC,
            storyPic,
        );
    }
    #[inline]
    pub fn add_confirmDes(&mut self, confirmDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_StoryNodeData::VT_CONFIRMDES,
            confirmDes,
        );
    }
    #[inline]
    pub fn add_storyDesList(
        &mut self,
        storyDesList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_StoryNodeData::VT_STORYDESLIST,
            storyDesList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_StoryNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_StoryNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_StoryNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_StoryNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_StoryNodeData");
        ds.field("nodeId", &self.nodeId());
        ds.field("storyId", &self.storyId());
        ds.field("storyKey", &self.storyKey());
        ds.field("storyName", &self.storyName());
        ds.field("storyPic", &self.storyPic());
        ds.field("confirmDes", &self.confirmDes());
        ds.field("storyDesList", &self.storyDesList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_StoryNodeDataT {
    pub nodeId: Option<String>,
    pub storyId: Option<String>,
    pub storyKey: Option<String>,
    pub storyName: Option<String>,
    pub storyPic: Option<String>,
    pub confirmDes: Option<String>,
    pub storyDesList: Option<Vec<String>>,
}
impl Default for clz_Torappu_Act17sideData_StoryNodeDataT {
    fn default() -> Self {
        Self {
            nodeId: None,
            storyId: None,
            storyKey: None,
            storyName: None,
            storyPic: None,
            confirmDes: None,
            storyDesList: None,
        }
    }
}
impl clz_Torappu_Act17sideData_StoryNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_StoryNodeData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let storyId = self.storyId.as_ref().map(|x| _fbb.create_string(x));
        let storyKey = self.storyKey.as_ref().map(|x| _fbb.create_string(x));
        let storyName = self.storyName.as_ref().map(|x| _fbb.create_string(x));
        let storyPic = self.storyPic.as_ref().map(|x| _fbb.create_string(x));
        let confirmDes = self.confirmDes.as_ref().map(|x| _fbb.create_string(x));
        let storyDesList = self.storyDesList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_Act17sideData_StoryNodeData::create(
            _fbb,
            &clz_Torappu_Act17sideData_StoryNodeDataArgs {
                nodeId,
                storyId,
                storyKey,
                storyName,
                storyPic,
                confirmDes,
                storyDesList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideData_StoryNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData_StoryNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act17sideData_StoryNodeData<'a> {
    type Inner = dict__string__clz_Torappu_Act17sideData_StoryNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData_StoryNodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData_StoryNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideData_StoryNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_StoryNodeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_Act17sideData_StoryNodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideData_StoryNodeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideData_StoryNodeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData_StoryNodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act17sideData_StoryNodeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData_StoryNodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_StoryNodeData>>(
                    dict__string__clz_Torappu_Act17sideData_StoryNodeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData_StoryNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_StoryNodeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideData_StoryNodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_StoryNodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideData_StoryNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideData_StoryNodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData_StoryNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_Act17sideData_StoryNodeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideData_StoryNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideData_StoryNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData_StoryNodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_StoryNodeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_StoryNodeData>>(
                dict__string__clz_Torappu_Act17sideData_StoryNodeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideData_StoryNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideData_StoryNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_StoryNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act17sideData_StoryNodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData_StoryNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act17sideData_StoryNodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideData_StoryNodeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideData_StoryNodeDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideData_StoryNodeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideData_StoryNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_StoryNodeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData_StoryNodeData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideData_StoryNodeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act17sideData_BattleNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_BattleNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_BattleNodeData<'a> {
    type Inner = clz_Torappu_Act17sideData_BattleNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_BattleNodeData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_STAGEID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_BattleNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_BattleNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_BattleNodeData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_BattleNodeDataBuilder::new(_fbb);
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_BattleNodeDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        let stageId = self.stageId().map(|x| x.to_string());
        clz_Torappu_Act17sideData_BattleNodeDataT { nodeId, stageId }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_BattleNodeData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_BattleNodeData::VT_STAGEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_BattleNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_BattleNodeDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Act17sideData_BattleNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_BattleNodeDataArgs {
            nodeId: None,
            stageId: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_BattleNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act17sideData_BattleNodeData", 2)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        if let Some(f) = self.stageId() {
            s.serialize_field("stageId", &f)?;
        } else {
            s.skip_field("stageId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_BattleNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_BattleNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_BattleNodeData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_BattleNodeData::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_BattleNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_BattleNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_BattleNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_BattleNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_BattleNodeData");
        ds.field("nodeId", &self.nodeId());
        ds.field("stageId", &self.stageId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_BattleNodeDataT {
    pub nodeId: Option<String>,
    pub stageId: Option<String>,
}
impl Default for clz_Torappu_Act17sideData_BattleNodeDataT {
    fn default() -> Self {
        Self {
            nodeId: None,
            stageId: None,
        }
    }
}
impl clz_Torappu_Act17sideData_BattleNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_BattleNodeData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let stageId = self.stageId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Act17sideData_BattleNodeData::create(
            _fbb,
            &clz_Torappu_Act17sideData_BattleNodeDataArgs { nodeId, stageId },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideData_BattleNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData_BattleNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act17sideData_BattleNodeData<'a> {
    type Inner = dict__string__clz_Torappu_Act17sideData_BattleNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData_BattleNodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData_BattleNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideData_BattleNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_BattleNodeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_Act17sideData_BattleNodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideData_BattleNodeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideData_BattleNodeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData_BattleNodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act17sideData_BattleNodeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData_BattleNodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_BattleNodeData>>(
                    dict__string__clz_Torappu_Act17sideData_BattleNodeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData_BattleNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_BattleNodeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideData_BattleNodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_BattleNodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideData_BattleNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideData_BattleNodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData_BattleNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_Act17sideData_BattleNodeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideData_BattleNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideData_BattleNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData_BattleNodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_BattleNodeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_BattleNodeData>>(
                dict__string__clz_Torappu_Act17sideData_BattleNodeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideData_BattleNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideData_BattleNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_BattleNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act17sideData_BattleNodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData_BattleNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act17sideData_BattleNodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideData_BattleNodeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideData_BattleNodeDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideData_BattleNodeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideData_BattleNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_BattleNodeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData_BattleNodeData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideData_BattleNodeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act17sideData_TreasureNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_TreasureNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_TreasureNodeData<'a> {
    type Inner = clz_Torappu_Act17sideData_TreasureNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_TreasureNodeData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_TREASUREID: flatbuffers::VOffsetT = 6;
    pub const VT_TREASURENAME: flatbuffers::VOffsetT = 8;
    pub const VT_TREASUREPIC: flatbuffers::VOffsetT = 10;
    pub const VT_TREASURESPECIALPIC: flatbuffers::VOffsetT = 12;
    pub const VT_ENDEVENTID: flatbuffers::VOffsetT = 14;
    pub const VT_CONFIRMDES: flatbuffers::VOffsetT = 16;
    pub const VT_TREASUREDESLIST: flatbuffers::VOffsetT = 18;
    pub const VT_MISSIONIDLIST: flatbuffers::VOffsetT = 20;
    pub const VT_REWARDLIST: flatbuffers::VOffsetT = 22;
    pub const VT_TREASURETYPE: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_TreasureNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_TreasureNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TreasureNodeData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_TreasureNodeDataBuilder::new(_fbb);
        builder.add_treasureType(args.treasureType);
        if let Some(x) = args.rewardList {
            builder.add_rewardList(x);
        }
        if let Some(x) = args.missionIdList {
            builder.add_missionIdList(x);
        }
        if let Some(x) = args.treasureDesList {
            builder.add_treasureDesList(x);
        }
        if let Some(x) = args.confirmDes {
            builder.add_confirmDes(x);
        }
        if let Some(x) = args.endEventId {
            builder.add_endEventId(x);
        }
        if let Some(x) = args.treasureSpecialPic {
            builder.add_treasureSpecialPic(x);
        }
        if let Some(x) = args.treasurePic {
            builder.add_treasurePic(x);
        }
        if let Some(x) = args.treasureName {
            builder.add_treasureName(x);
        }
        if let Some(x) = args.treasureId {
            builder.add_treasureId(x);
        }
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_TreasureNodeDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        let treasureId = self.treasureId().map(|x| x.to_string());
        let treasureName = self.treasureName().map(|x| x.to_string());
        let treasurePic = self.treasurePic().map(|x| x.to_string());
        let treasureSpecialPic = self.treasureSpecialPic().map(|x| x.to_string());
        let endEventId = self.endEventId().map(|x| x.to_string());
        let confirmDes = self.confirmDes().map(|x| x.to_string());
        let treasureDesList = self
            .treasureDesList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let missionIdList = self
            .missionIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let rewardList = self
            .rewardList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let treasureType = self.treasureType();
        clz_Torappu_Act17sideData_TreasureNodeDataT {
            nodeId,
            treasureId,
            treasureName,
            treasurePic,
            treasureSpecialPic,
            endEventId,
            confirmDes,
            treasureDesList,
            missionIdList,
            rewardList,
            treasureType,
        }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TreasureNodeData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn treasureId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TreasureNodeData::VT_TREASUREID,
                None,
            )
        }
    }
    #[inline]
    pub fn treasureName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TreasureNodeData::VT_TREASURENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn treasurePic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TreasureNodeData::VT_TREASUREPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn treasureSpecialPic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TreasureNodeData::VT_TREASURESPECIALPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn endEventId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TreasureNodeData::VT_ENDEVENTID,
                None,
            )
        }
    }
    #[inline]
    pub fn confirmDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TreasureNodeData::VT_CONFIRMDES,
                None,
            )
        }
    }
    #[inline]
    pub fn treasureDesList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_Act17sideData_TreasureNodeData::VT_TREASUREDESLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn missionIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_Act17sideData_TreasureNodeData::VT_MISSIONIDLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn rewardList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(
                clz_Torappu_Act17sideData_TreasureNodeData::VT_REWARDLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn treasureType(&self) -> enum__Torappu_Act17sideData_TreasureType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Act17sideData_TreasureType>(
                    clz_Torappu_Act17sideData_TreasureNodeData::VT_TREASURETYPE,
                    Some(enum__Torappu_Act17sideData_TreasureType::SMALL),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_TreasureNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "treasureId",
                Self::VT_TREASUREID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "treasureName",
                Self::VT_TREASURENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "treasurePic",
                Self::VT_TREASUREPIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "treasureSpecialPic",
                Self::VT_TREASURESPECIALPIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "endEventId",
                Self::VT_ENDEVENTID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "confirmDes",
                Self::VT_CONFIRMDES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("treasureDesList", Self::VT_TREASUREDESLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("missionIdList", Self::VT_MISSIONIDLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("rewardList", Self::VT_REWARDLIST, false)?
            .visit_field::<enum__Torappu_Act17sideData_TreasureType>(
                "treasureType",
                Self::VT_TREASURETYPE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_TreasureNodeDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub treasureId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub treasureName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub treasurePic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub treasureSpecialPic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endEventId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub confirmDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub treasureDesList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub missionIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub rewardList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
    pub treasureType: enum__Torappu_Act17sideData_TreasureType,
}
impl<'a> Default for clz_Torappu_Act17sideData_TreasureNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_TreasureNodeDataArgs {
            nodeId: None,
            treasureId: None,
            treasureName: None,
            treasurePic: None,
            treasureSpecialPic: None,
            endEventId: None,
            confirmDes: None,
            treasureDesList: None,
            missionIdList: None,
            rewardList: None,
            treasureType: enum__Torappu_Act17sideData_TreasureType::SMALL,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_TreasureNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Act17sideData_TreasureNodeData", 11)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        if let Some(f) = self.treasureId() {
            s.serialize_field("treasureId", &f)?;
        } else {
            s.skip_field("treasureId")?;
        }
        if let Some(f) = self.treasureName() {
            s.serialize_field("treasureName", &f)?;
        } else {
            s.skip_field("treasureName")?;
        }
        if let Some(f) = self.treasurePic() {
            s.serialize_field("treasurePic", &f)?;
        } else {
            s.skip_field("treasurePic")?;
        }
        if let Some(f) = self.treasureSpecialPic() {
            s.serialize_field("treasureSpecialPic", &f)?;
        } else {
            s.skip_field("treasureSpecialPic")?;
        }
        if let Some(f) = self.endEventId() {
            s.serialize_field("endEventId", &f)?;
        } else {
            s.skip_field("endEventId")?;
        }
        if let Some(f) = self.confirmDes() {
            s.serialize_field("confirmDes", &f)?;
        } else {
            s.skip_field("confirmDes")?;
        }
        if let Some(f) = self.treasureDesList() {
            s.serialize_field("treasureDesList", &f)?;
        } else {
            s.skip_field("treasureDesList")?;
        }
        if let Some(f) = self.missionIdList() {
            s.serialize_field("missionIdList", &f)?;
        } else {
            s.skip_field("missionIdList")?;
        }
        if let Some(f) = self.rewardList() {
            s.serialize_field("rewardList", &f)?;
        } else {
            s.skip_field("rewardList")?;
        }
        s.serialize_field("treasureType", &self.treasureType())?;
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_TreasureNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_TreasureNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TreasureNodeData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_treasureId(&mut self, treasureId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TreasureNodeData::VT_TREASUREID,
            treasureId,
        );
    }
    #[inline]
    pub fn add_treasureName(&mut self, treasureName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TreasureNodeData::VT_TREASURENAME,
            treasureName,
        );
    }
    #[inline]
    pub fn add_treasurePic(&mut self, treasurePic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TreasureNodeData::VT_TREASUREPIC,
            treasurePic,
        );
    }
    #[inline]
    pub fn add_treasureSpecialPic(&mut self, treasureSpecialPic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TreasureNodeData::VT_TREASURESPECIALPIC,
            treasureSpecialPic,
        );
    }
    #[inline]
    pub fn add_endEventId(&mut self, endEventId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TreasureNodeData::VT_ENDEVENTID,
            endEventId,
        );
    }
    #[inline]
    pub fn add_confirmDes(&mut self, confirmDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TreasureNodeData::VT_CONFIRMDES,
            confirmDes,
        );
    }
    #[inline]
    pub fn add_treasureDesList(
        &mut self,
        treasureDesList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TreasureNodeData::VT_TREASUREDESLIST,
            treasureDesList,
        );
    }
    #[inline]
    pub fn add_missionIdList(
        &mut self,
        missionIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TreasureNodeData::VT_MISSIONIDLIST,
            missionIdList,
        );
    }
    #[inline]
    pub fn add_rewardList(
        &mut self,
        rewardList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TreasureNodeData::VT_REWARDLIST,
            rewardList,
        );
    }
    #[inline]
    pub fn add_treasureType(&mut self, treasureType: enum__Torappu_Act17sideData_TreasureType) {
        self.fbb_
            .push_slot::<enum__Torappu_Act17sideData_TreasureType>(
                clz_Torappu_Act17sideData_TreasureNodeData::VT_TREASURETYPE,
                treasureType,
                enum__Torappu_Act17sideData_TreasureType::SMALL,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_TreasureNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_TreasureNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TreasureNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_TreasureNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_TreasureNodeData");
        ds.field("nodeId", &self.nodeId());
        ds.field("treasureId", &self.treasureId());
        ds.field("treasureName", &self.treasureName());
        ds.field("treasurePic", &self.treasurePic());
        ds.field("treasureSpecialPic", &self.treasureSpecialPic());
        ds.field("endEventId", &self.endEventId());
        ds.field("confirmDes", &self.confirmDes());
        ds.field("treasureDesList", &self.treasureDesList());
        ds.field("missionIdList", &self.missionIdList());
        ds.field("rewardList", &self.rewardList());
        ds.field("treasureType", &self.treasureType());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_TreasureNodeDataT {
    pub nodeId: Option<String>,
    pub treasureId: Option<String>,
    pub treasureName: Option<String>,
    pub treasurePic: Option<String>,
    pub treasureSpecialPic: Option<String>,
    pub endEventId: Option<String>,
    pub confirmDes: Option<String>,
    pub treasureDesList: Option<Vec<String>>,
    pub missionIdList: Option<Vec<String>>,
    pub rewardList: Option<Vec<clz_Torappu_ItemBundleT>>,
    pub treasureType: enum__Torappu_Act17sideData_TreasureType,
}
impl Default for clz_Torappu_Act17sideData_TreasureNodeDataT {
    fn default() -> Self {
        Self {
            nodeId: None,
            treasureId: None,
            treasureName: None,
            treasurePic: None,
            treasureSpecialPic: None,
            endEventId: None,
            confirmDes: None,
            treasureDesList: None,
            missionIdList: None,
            rewardList: None,
            treasureType: enum__Torappu_Act17sideData_TreasureType::SMALL,
        }
    }
}
impl clz_Torappu_Act17sideData_TreasureNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TreasureNodeData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let treasureId = self.treasureId.as_ref().map(|x| _fbb.create_string(x));
        let treasureName = self.treasureName.as_ref().map(|x| _fbb.create_string(x));
        let treasurePic = self.treasurePic.as_ref().map(|x| _fbb.create_string(x));
        let treasureSpecialPic = self
            .treasureSpecialPic
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let endEventId = self.endEventId.as_ref().map(|x| _fbb.create_string(x));
        let confirmDes = self.confirmDes.as_ref().map(|x| _fbb.create_string(x));
        let treasureDesList = self.treasureDesList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let missionIdList = self.missionIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let rewardList = self.rewardList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let treasureType = self.treasureType;
        clz_Torappu_Act17sideData_TreasureNodeData::create(
            _fbb,
            &clz_Torappu_Act17sideData_TreasureNodeDataArgs {
                nodeId,
                treasureId,
                treasureName,
                treasurePic,
                treasureSpecialPic,
                endEventId,
                confirmDes,
                treasureDesList,
                missionIdList,
                rewardList,
                treasureType,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideData_TreasureNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData_TreasureNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act17sideData_TreasureNodeData<'a> {
    type Inner = dict__string__clz_Torappu_Act17sideData_TreasureNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData_TreasureNodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData_TreasureNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideData_TreasureNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_TreasureNodeData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_Act17sideData_TreasureNodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideData_TreasureNodeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideData_TreasureNodeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData_TreasureNodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act17sideData_TreasureNodeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData_TreasureNodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_TreasureNodeData>>(
                    dict__string__clz_Torappu_Act17sideData_TreasureNodeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData_TreasureNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_TreasureNodeData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideData_TreasureNodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TreasureNodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideData_TreasureNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideData_TreasureNodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData_TreasureNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_Act17sideData_TreasureNodeData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideData_TreasureNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideData_TreasureNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData_TreasureNodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TreasureNodeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TreasureNodeData>>(
                dict__string__clz_Torappu_Act17sideData_TreasureNodeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideData_TreasureNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideData_TreasureNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_TreasureNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act17sideData_TreasureNodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData_TreasureNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act17sideData_TreasureNodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideData_TreasureNodeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideData_TreasureNodeDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideData_TreasureNodeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideData_TreasureNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_TreasureNodeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData_TreasureNodeData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideData_TreasureNodeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act17sideData_EventNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_EventNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_EventNodeData<'a> {
    type Inner = clz_Torappu_Act17sideData_EventNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_EventNodeData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_EVENTID: flatbuffers::VOffsetT = 6;
    pub const VT_ENDEVENTID: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_EventNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_EventNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_EventNodeData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_EventNodeDataBuilder::new(_fbb);
        if let Some(x) = args.endEventId {
            builder.add_endEventId(x);
        }
        if let Some(x) = args.eventId {
            builder.add_eventId(x);
        }
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_EventNodeDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        let eventId = self.eventId().map(|x| x.to_string());
        let endEventId = self.endEventId().map(|x| x.to_string());
        clz_Torappu_Act17sideData_EventNodeDataT {
            nodeId,
            eventId,
            endEventId,
        }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_EventNodeData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn eventId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_EventNodeData::VT_EVENTID,
                None,
            )
        }
    }
    #[inline]
    pub fn endEventId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_EventNodeData::VT_ENDEVENTID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_EventNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eventId", Self::VT_EVENTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "endEventId",
                Self::VT_ENDEVENTID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_EventNodeDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eventId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endEventId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Act17sideData_EventNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_EventNodeDataArgs {
            nodeId: None,
            eventId: None,
            endEventId: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_EventNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act17sideData_EventNodeData", 3)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        if let Some(f) = self.eventId() {
            s.serialize_field("eventId", &f)?;
        } else {
            s.skip_field("eventId")?;
        }
        if let Some(f) = self.endEventId() {
            s.serialize_field("endEventId", &f)?;
        } else {
            s.skip_field("endEventId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_EventNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_EventNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_EventNodeData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_eventId(&mut self, eventId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_EventNodeData::VT_EVENTID,
            eventId,
        );
    }
    #[inline]
    pub fn add_endEventId(&mut self, endEventId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_EventNodeData::VT_ENDEVENTID,
            endEventId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_EventNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_EventNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_EventNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_EventNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_EventNodeData");
        ds.field("nodeId", &self.nodeId());
        ds.field("eventId", &self.eventId());
        ds.field("endEventId", &self.endEventId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_EventNodeDataT {
    pub nodeId: Option<String>,
    pub eventId: Option<String>,
    pub endEventId: Option<String>,
}
impl Default for clz_Torappu_Act17sideData_EventNodeDataT {
    fn default() -> Self {
        Self {
            nodeId: None,
            eventId: None,
            endEventId: None,
        }
    }
}
impl clz_Torappu_Act17sideData_EventNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_EventNodeData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let eventId = self.eventId.as_ref().map(|x| _fbb.create_string(x));
        let endEventId = self.endEventId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Act17sideData_EventNodeData::create(
            _fbb,
            &clz_Torappu_Act17sideData_EventNodeDataArgs {
                nodeId,
                eventId,
                endEventId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideData_EventNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData_EventNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act17sideData_EventNodeData<'a> {
    type Inner = dict__string__clz_Torappu_Act17sideData_EventNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData_EventNodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData_EventNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideData_EventNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_EventNodeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_Act17sideData_EventNodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideData_EventNodeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideData_EventNodeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData_EventNodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act17sideData_EventNodeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData_EventNodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_EventNodeData>>(
                    dict__string__clz_Torappu_Act17sideData_EventNodeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData_EventNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_EventNodeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideData_EventNodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_EventNodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideData_EventNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideData_EventNodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData_EventNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_Act17sideData_EventNodeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideData_EventNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideData_EventNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData_EventNodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_EventNodeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_EventNodeData>>(
                dict__string__clz_Torappu_Act17sideData_EventNodeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideData_EventNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideData_EventNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_EventNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act17sideData_EventNodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData_EventNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act17sideData_EventNodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideData_EventNodeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideData_EventNodeDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideData_EventNodeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideData_EventNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_EventNodeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData_EventNodeData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideData_EventNodeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act17sideData_TechNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_TechNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_TechNodeData<'a> {
    type Inner = clz_Torappu_Act17sideData_TechNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_TechNodeData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_TECHTREEID: flatbuffers::VOffsetT = 6;
    pub const VT_TECHTREENAME: flatbuffers::VOffsetT = 8;
    pub const VT_TECHPIC: flatbuffers::VOffsetT = 10;
    pub const VT_TECHSPECIALPIC: flatbuffers::VOffsetT = 12;
    pub const VT_ENDEVENTID: flatbuffers::VOffsetT = 14;
    pub const VT_CONFIRMDES: flatbuffers::VOffsetT = 16;
    pub const VT_TECHDESLIST: flatbuffers::VOffsetT = 18;
    pub const VT_MISSIONIDLIST: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_TechNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_TechNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechNodeData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_TechNodeDataBuilder::new(_fbb);
        if let Some(x) = args.missionIdList {
            builder.add_missionIdList(x);
        }
        if let Some(x) = args.techDesList {
            builder.add_techDesList(x);
        }
        if let Some(x) = args.confirmDes {
            builder.add_confirmDes(x);
        }
        if let Some(x) = args.endEventId {
            builder.add_endEventId(x);
        }
        if let Some(x) = args.techSpecialPic {
            builder.add_techSpecialPic(x);
        }
        if let Some(x) = args.techPic {
            builder.add_techPic(x);
        }
        if let Some(x) = args.techTreeName {
            builder.add_techTreeName(x);
        }
        if let Some(x) = args.techTreeId {
            builder.add_techTreeId(x);
        }
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_TechNodeDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        let techTreeId = self.techTreeId().map(|x| x.to_string());
        let techTreeName = self.techTreeName().map(|x| x.to_string());
        let techPic = self.techPic().map(|x| x.to_string());
        let techSpecialPic = self.techSpecialPic().map(|x| x.to_string());
        let endEventId = self.endEventId().map(|x| x.to_string());
        let confirmDes = self.confirmDes().map(|x| x.to_string());
        let techDesList = self
            .techDesList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let missionIdList = self
            .missionIdList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_Act17sideData_TechNodeDataT {
            nodeId,
            techTreeId,
            techTreeName,
            techPic,
            techSpecialPic,
            endEventId,
            confirmDes,
            techDesList,
            missionIdList,
        }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechNodeData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn techTreeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechNodeData::VT_TECHTREEID,
                None,
            )
        }
    }
    #[inline]
    pub fn techTreeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechNodeData::VT_TECHTREENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn techPic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechNodeData::VT_TECHPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn techSpecialPic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechNodeData::VT_TECHSPECIALPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn endEventId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechNodeData::VT_ENDEVENTID,
                None,
            )
        }
    }
    #[inline]
    pub fn confirmDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechNodeData::VT_CONFIRMDES,
                None,
            )
        }
    }
    #[inline]
    pub fn techDesList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_Act17sideData_TechNodeData::VT_TECHDESLIST, None)
        }
    }
    #[inline]
    pub fn missionIdList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_Act17sideData_TechNodeData::VT_MISSIONIDLIST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_TechNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "techTreeId",
                Self::VT_TECHTREEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "techTreeName",
                Self::VT_TECHTREENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("techPic", Self::VT_TECHPIC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "techSpecialPic",
                Self::VT_TECHSPECIALPIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "endEventId",
                Self::VT_ENDEVENTID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "confirmDes",
                Self::VT_CONFIRMDES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("techDesList", Self::VT_TECHDESLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("missionIdList", Self::VT_MISSIONIDLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_TechNodeDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub techTreeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub techTreeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub techPic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub techSpecialPic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endEventId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub confirmDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub techDesList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub missionIdList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_Act17sideData_TechNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_TechNodeDataArgs {
            nodeId: None,
            techTreeId: None,
            techTreeName: None,
            techPic: None,
            techSpecialPic: None,
            endEventId: None,
            confirmDes: None,
            techDesList: None,
            missionIdList: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_TechNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act17sideData_TechNodeData", 9)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        if let Some(f) = self.techTreeId() {
            s.serialize_field("techTreeId", &f)?;
        } else {
            s.skip_field("techTreeId")?;
        }
        if let Some(f) = self.techTreeName() {
            s.serialize_field("techTreeName", &f)?;
        } else {
            s.skip_field("techTreeName")?;
        }
        if let Some(f) = self.techPic() {
            s.serialize_field("techPic", &f)?;
        } else {
            s.skip_field("techPic")?;
        }
        if let Some(f) = self.techSpecialPic() {
            s.serialize_field("techSpecialPic", &f)?;
        } else {
            s.skip_field("techSpecialPic")?;
        }
        if let Some(f) = self.endEventId() {
            s.serialize_field("endEventId", &f)?;
        } else {
            s.skip_field("endEventId")?;
        }
        if let Some(f) = self.confirmDes() {
            s.serialize_field("confirmDes", &f)?;
        } else {
            s.skip_field("confirmDes")?;
        }
        if let Some(f) = self.techDesList() {
            s.serialize_field("techDesList", &f)?;
        } else {
            s.skip_field("techDesList")?;
        }
        if let Some(f) = self.missionIdList() {
            s.serialize_field("missionIdList", &f)?;
        } else {
            s.skip_field("missionIdList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_TechNodeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_TechNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechNodeData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_techTreeId(&mut self, techTreeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechNodeData::VT_TECHTREEID,
            techTreeId,
        );
    }
    #[inline]
    pub fn add_techTreeName(&mut self, techTreeName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechNodeData::VT_TECHTREENAME,
            techTreeName,
        );
    }
    #[inline]
    pub fn add_techPic(&mut self, techPic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechNodeData::VT_TECHPIC,
            techPic,
        );
    }
    #[inline]
    pub fn add_techSpecialPic(&mut self, techSpecialPic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechNodeData::VT_TECHSPECIALPIC,
            techSpecialPic,
        );
    }
    #[inline]
    pub fn add_endEventId(&mut self, endEventId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechNodeData::VT_ENDEVENTID,
            endEventId,
        );
    }
    #[inline]
    pub fn add_confirmDes(&mut self, confirmDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechNodeData::VT_CONFIRMDES,
            confirmDes,
        );
    }
    #[inline]
    pub fn add_techDesList(
        &mut self,
        techDesList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechNodeData::VT_TECHDESLIST,
            techDesList,
        );
    }
    #[inline]
    pub fn add_missionIdList(
        &mut self,
        missionIdList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechNodeData::VT_MISSIONIDLIST,
            missionIdList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_TechNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_TechNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_TechNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_TechNodeData");
        ds.field("nodeId", &self.nodeId());
        ds.field("techTreeId", &self.techTreeId());
        ds.field("techTreeName", &self.techTreeName());
        ds.field("techPic", &self.techPic());
        ds.field("techSpecialPic", &self.techSpecialPic());
        ds.field("endEventId", &self.endEventId());
        ds.field("confirmDes", &self.confirmDes());
        ds.field("techDesList", &self.techDesList());
        ds.field("missionIdList", &self.missionIdList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_TechNodeDataT {
    pub nodeId: Option<String>,
    pub techTreeId: Option<String>,
    pub techTreeName: Option<String>,
    pub techPic: Option<String>,
    pub techSpecialPic: Option<String>,
    pub endEventId: Option<String>,
    pub confirmDes: Option<String>,
    pub techDesList: Option<Vec<String>>,
    pub missionIdList: Option<Vec<String>>,
}
impl Default for clz_Torappu_Act17sideData_TechNodeDataT {
    fn default() -> Self {
        Self {
            nodeId: None,
            techTreeId: None,
            techTreeName: None,
            techPic: None,
            techSpecialPic: None,
            endEventId: None,
            confirmDes: None,
            techDesList: None,
            missionIdList: None,
        }
    }
}
impl clz_Torappu_Act17sideData_TechNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechNodeData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let techTreeId = self.techTreeId.as_ref().map(|x| _fbb.create_string(x));
        let techTreeName = self.techTreeName.as_ref().map(|x| _fbb.create_string(x));
        let techPic = self.techPic.as_ref().map(|x| _fbb.create_string(x));
        let techSpecialPic = self.techSpecialPic.as_ref().map(|x| _fbb.create_string(x));
        let endEventId = self.endEventId.as_ref().map(|x| _fbb.create_string(x));
        let confirmDes = self.confirmDes.as_ref().map(|x| _fbb.create_string(x));
        let techDesList = self.techDesList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let missionIdList = self.missionIdList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_Act17sideData_TechNodeData::create(
            _fbb,
            &clz_Torappu_Act17sideData_TechNodeDataArgs {
                nodeId,
                techTreeId,
                techTreeName,
                techPic,
                techSpecialPic,
                endEventId,
                confirmDes,
                techDesList,
                missionIdList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideData_TechNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData_TechNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act17sideData_TechNodeData<'a> {
    type Inner = dict__string__clz_Torappu_Act17sideData_TechNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData_TechNodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData_TechNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideData_TechNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_TechNodeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_Act17sideData_TechNodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideData_TechNodeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideData_TechNodeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData_TechNodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act17sideData_TechNodeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData_TechNodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_TechNodeData>>(
                    dict__string__clz_Torappu_Act17sideData_TechNodeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData_TechNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_TechNodeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideData_TechNodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechNodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideData_TechNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideData_TechNodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData_TechNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_Act17sideData_TechNodeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideData_TechNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideData_TechNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData_TechNodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechNodeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechNodeData>>(
                dict__string__clz_Torappu_Act17sideData_TechNodeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideData_TechNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideData_TechNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_TechNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act17sideData_TechNodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData_TechNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act17sideData_TechNodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideData_TechNodeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideData_TechNodeDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideData_TechNodeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideData_TechNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_TechNodeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData_TechNodeData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideData_TechNodeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act17sideData_ChoiceNodeOptionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_ChoiceNodeOptionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_ChoiceNodeOptionData<'a> {
    type Inner = clz_Torappu_Act17sideData_ChoiceNodeOptionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_ChoiceNodeOptionData<'a> {
    pub const VT_CANREPEAT: flatbuffers::VOffsetT = 4;
    pub const VT_EVENTID: flatbuffers::VOffsetT = 6;
    pub const VT_DES: flatbuffers::VOffsetT = 8;
    pub const VT_UNLOCKDES: flatbuffers::VOffsetT = 10;
    pub const VT_UNLOCKCONDTYPE: flatbuffers::VOffsetT = 12;
    pub const VT_UNLOCKPARAMS: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_ChoiceNodeOptionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_ChoiceNodeOptionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ChoiceNodeOptionData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_ChoiceNodeOptionDataBuilder::new(_fbb);
        if let Some(x) = args.unlockParams {
            builder.add_unlockParams(x);
        }
        if let Some(x) = args.unlockCondType {
            builder.add_unlockCondType(x);
        }
        if let Some(x) = args.unlockDes {
            builder.add_unlockDes(x);
        }
        if let Some(x) = args.des {
            builder.add_des(x);
        }
        if let Some(x) = args.eventId {
            builder.add_eventId(x);
        }
        builder.add_canRepeat(args.canRepeat);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_ChoiceNodeOptionDataT {
        let canRepeat = self.canRepeat();
        let eventId = self.eventId().map(|x| x.to_string());
        let des = self.des().map(|x| x.to_string());
        let unlockDes = self.unlockDes().map(|x| x.to_string());
        let unlockCondType = self.unlockCondType().map(|x| x.to_string());
        let unlockParams = self
            .unlockParams()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_Act17sideData_ChoiceNodeOptionDataT {
            canRepeat,
            eventId,
            des,
            unlockDes,
            unlockCondType,
            unlockParams,
        }
    }

    #[inline]
    pub fn canRepeat(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Act17sideData_ChoiceNodeOptionData::VT_CANREPEAT,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn eventId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ChoiceNodeOptionData::VT_EVENTID,
                None,
            )
        }
    }
    #[inline]
    pub fn des(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ChoiceNodeOptionData::VT_DES,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ChoiceNodeOptionData::VT_UNLOCKDES,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockCondType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ChoiceNodeOptionData::VT_UNLOCKCONDTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockParams(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_Act17sideData_ChoiceNodeOptionData::VT_UNLOCKPARAMS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_ChoiceNodeOptionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("canRepeat", Self::VT_CANREPEAT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eventId", Self::VT_EVENTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("des", Self::VT_DES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockDes",
                Self::VT_UNLOCKDES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockCondType",
                Self::VT_UNLOCKCONDTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("unlockParams", Self::VT_UNLOCKPARAMS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_ChoiceNodeOptionDataArgs<'a> {
    pub canRepeat: bool,
    pub eventId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub des: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockCondType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockParams: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_Act17sideData_ChoiceNodeOptionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_ChoiceNodeOptionDataArgs {
            canRepeat: false,
            eventId: None,
            des: None,
            unlockDes: None,
            unlockCondType: None,
            unlockParams: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_ChoiceNodeOptionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Act17sideData_ChoiceNodeOptionData", 6)?;
        s.serialize_field("canRepeat", &self.canRepeat())?;
        if let Some(f) = self.eventId() {
            s.serialize_field("eventId", &f)?;
        } else {
            s.skip_field("eventId")?;
        }
        if let Some(f) = self.des() {
            s.serialize_field("des", &f)?;
        } else {
            s.skip_field("des")?;
        }
        if let Some(f) = self.unlockDes() {
            s.serialize_field("unlockDes", &f)?;
        } else {
            s.skip_field("unlockDes")?;
        }
        if let Some(f) = self.unlockCondType() {
            s.serialize_field("unlockCondType", &f)?;
        } else {
            s.skip_field("unlockCondType")?;
        }
        if let Some(f) = self.unlockParams() {
            s.serialize_field("unlockParams", &f)?;
        } else {
            s.skip_field("unlockParams")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_ChoiceNodeOptionDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_ChoiceNodeOptionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_canRepeat(&mut self, canRepeat: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Act17sideData_ChoiceNodeOptionData::VT_CANREPEAT,
            canRepeat,
            false,
        );
    }
    #[inline]
    pub fn add_eventId(&mut self, eventId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ChoiceNodeOptionData::VT_EVENTID,
            eventId,
        );
    }
    #[inline]
    pub fn add_des(&mut self, des: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ChoiceNodeOptionData::VT_DES,
            des,
        );
    }
    #[inline]
    pub fn add_unlockDes(&mut self, unlockDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ChoiceNodeOptionData::VT_UNLOCKDES,
            unlockDes,
        );
    }
    #[inline]
    pub fn add_unlockCondType(&mut self, unlockCondType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ChoiceNodeOptionData::VT_UNLOCKCONDTYPE,
            unlockCondType,
        );
    }
    #[inline]
    pub fn add_unlockParams(
        &mut self,
        unlockParams: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ChoiceNodeOptionData::VT_UNLOCKPARAMS,
            unlockParams,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_ChoiceNodeOptionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_ChoiceNodeOptionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ChoiceNodeOptionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_ChoiceNodeOptionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_ChoiceNodeOptionData");
        ds.field("canRepeat", &self.canRepeat());
        ds.field("eventId", &self.eventId());
        ds.field("des", &self.des());
        ds.field("unlockDes", &self.unlockDes());
        ds.field("unlockCondType", &self.unlockCondType());
        ds.field("unlockParams", &self.unlockParams());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_ChoiceNodeOptionDataT {
    pub canRepeat: bool,
    pub eventId: Option<String>,
    pub des: Option<String>,
    pub unlockDes: Option<String>,
    pub unlockCondType: Option<String>,
    pub unlockParams: Option<Vec<String>>,
}
impl Default for clz_Torappu_Act17sideData_ChoiceNodeOptionDataT {
    fn default() -> Self {
        Self {
            canRepeat: false,
            eventId: None,
            des: None,
            unlockDes: None,
            unlockCondType: None,
            unlockParams: None,
        }
    }
}
impl clz_Torappu_Act17sideData_ChoiceNodeOptionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ChoiceNodeOptionData<'b>> {
        let canRepeat = self.canRepeat;
        let eventId = self.eventId.as_ref().map(|x| _fbb.create_string(x));
        let des = self.des.as_ref().map(|x| _fbb.create_string(x));
        let unlockDes = self.unlockDes.as_ref().map(|x| _fbb.create_string(x));
        let unlockCondType = self.unlockCondType.as_ref().map(|x| _fbb.create_string(x));
        let unlockParams = self.unlockParams.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_Act17sideData_ChoiceNodeOptionData::create(
            _fbb,
            &clz_Torappu_Act17sideData_ChoiceNodeOptionDataArgs {
                canRepeat,
                eventId,
                des,
                unlockDes,
                unlockCondType,
                unlockParams,
            },
        )
    }
}
pub enum clz_Torappu_Act17sideData_ChoiceNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_ChoiceNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_ChoiceNodeData<'a> {
    type Inner = clz_Torappu_Act17sideData_ChoiceNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_ChoiceNodeData<'a> {
    pub const VT_NODEID: flatbuffers::VOffsetT = 4;
    pub const VT_CHOICEPIC: flatbuffers::VOffsetT = 6;
    pub const VT_ISDISPOSABLE: flatbuffers::VOffsetT = 8;
    pub const VT_CHOICESPECIALPIC: flatbuffers::VOffsetT = 10;
    pub const VT_CHOICENAME: flatbuffers::VOffsetT = 12;
    pub const VT_CHOICEDESLIST: flatbuffers::VOffsetT = 14;
    pub const VT_CANCELDES: flatbuffers::VOffsetT = 16;
    pub const VT_CHOICENUM: flatbuffers::VOffsetT = 18;
    pub const VT_OPTIONLIST: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_ChoiceNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_ChoiceNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ChoiceNodeData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_ChoiceNodeDataBuilder::new(_fbb);
        if let Some(x) = args.optionList {
            builder.add_optionList(x);
        }
        builder.add_choiceNum(args.choiceNum);
        if let Some(x) = args.cancelDes {
            builder.add_cancelDes(x);
        }
        if let Some(x) = args.choiceDesList {
            builder.add_choiceDesList(x);
        }
        if let Some(x) = args.choiceName {
            builder.add_choiceName(x);
        }
        if let Some(x) = args.choiceSpecialPic {
            builder.add_choiceSpecialPic(x);
        }
        if let Some(x) = args.choicePic {
            builder.add_choicePic(x);
        }
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.add_isDisposable(args.isDisposable);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_ChoiceNodeDataT {
        let nodeId = self.nodeId().map(|x| x.to_string());
        let choicePic = self.choicePic().map(|x| x.to_string());
        let isDisposable = self.isDisposable();
        let choiceSpecialPic = self.choiceSpecialPic().map(|x| x.to_string());
        let choiceName = self.choiceName().map(|x| x.to_string());
        let choiceDesList = self
            .choiceDesList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let cancelDes = self.cancelDes().map(|x| x.to_string());
        let choiceNum = self.choiceNum();
        let optionList = self
            .optionList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_Act17sideData_ChoiceNodeDataT {
            nodeId,
            choicePic,
            isDisposable,
            choiceSpecialPic,
            choiceName,
            choiceDesList,
            cancelDes,
            choiceNum,
            optionList,
        }
    }

    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ChoiceNodeData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn choicePic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ChoiceNodeData::VT_CHOICEPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn isDisposable(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_Act17sideData_ChoiceNodeData::VT_ISDISPOSABLE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn choiceSpecialPic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ChoiceNodeData::VT_CHOICESPECIALPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn choiceName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ChoiceNodeData::VT_CHOICENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn choiceDesList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_Act17sideData_ChoiceNodeData::VT_CHOICEDESLIST,
                None,
            )
        }
    }
    #[inline]
    pub fn cancelDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ChoiceNodeData::VT_CANCELDES,
                None,
            )
        }
    }
    #[inline]
    pub fn choiceNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_Act17sideData_ChoiceNodeData::VT_CHOICENUM,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn optionList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ChoiceNodeOptionData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ChoiceNodeOptionData>,
                >,
            >>(
                clz_Torappu_Act17sideData_ChoiceNodeData::VT_OPTIONLIST,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_ChoiceNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "choicePic",
                Self::VT_CHOICEPIC,
                false,
            )?
            .visit_field::<bool>("isDisposable", Self::VT_ISDISPOSABLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "choiceSpecialPic",
                Self::VT_CHOICESPECIALPIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "choiceName",
                Self::VT_CHOICENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("choiceDesList", Self::VT_CHOICEDESLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "cancelDes",
                Self::VT_CANCELDES,
                false,
            )?
            .visit_field::<i32>("choiceNum", Self::VT_CHOICENUM, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ChoiceNodeOptionData>,
                >,
            >>("optionList", Self::VT_OPTIONLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_ChoiceNodeDataArgs<'a> {
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub choicePic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isDisposable: bool,
    pub choiceSpecialPic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub choiceName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub choiceDesList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub cancelDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub choiceNum: i32,
    pub optionList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ChoiceNodeOptionData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_Act17sideData_ChoiceNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_ChoiceNodeDataArgs {
            nodeId: None,
            choicePic: None,
            isDisposable: false,
            choiceSpecialPic: None,
            choiceName: None,
            choiceDesList: None,
            cancelDes: None,
            choiceNum: 0,
            optionList: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_ChoiceNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act17sideData_ChoiceNodeData", 9)?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        if let Some(f) = self.choicePic() {
            s.serialize_field("choicePic", &f)?;
        } else {
            s.skip_field("choicePic")?;
        }
        s.serialize_field("isDisposable", &self.isDisposable())?;
        if let Some(f) = self.choiceSpecialPic() {
            s.serialize_field("choiceSpecialPic", &f)?;
        } else {
            s.skip_field("choiceSpecialPic")?;
        }
        if let Some(f) = self.choiceName() {
            s.serialize_field("choiceName", &f)?;
        } else {
            s.skip_field("choiceName")?;
        }
        if let Some(f) = self.choiceDesList() {
            s.serialize_field("choiceDesList", &f)?;
        } else {
            s.skip_field("choiceDesList")?;
        }
        if let Some(f) = self.cancelDes() {
            s.serialize_field("cancelDes", &f)?;
        } else {
            s.skip_field("cancelDes")?;
        }
        s.serialize_field("choiceNum", &self.choiceNum())?;
        if let Some(f) = self.optionList() {
            s.serialize_field("optionList", &f)?;
        } else {
            s.skip_field("optionList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_ChoiceNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_ChoiceNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ChoiceNodeData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_choicePic(&mut self, choicePic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ChoiceNodeData::VT_CHOICEPIC,
            choicePic,
        );
    }
    #[inline]
    pub fn add_isDisposable(&mut self, isDisposable: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_Act17sideData_ChoiceNodeData::VT_ISDISPOSABLE,
            isDisposable,
            false,
        );
    }
    #[inline]
    pub fn add_choiceSpecialPic(&mut self, choiceSpecialPic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ChoiceNodeData::VT_CHOICESPECIALPIC,
            choiceSpecialPic,
        );
    }
    #[inline]
    pub fn add_choiceName(&mut self, choiceName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ChoiceNodeData::VT_CHOICENAME,
            choiceName,
        );
    }
    #[inline]
    pub fn add_choiceDesList(
        &mut self,
        choiceDesList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ChoiceNodeData::VT_CHOICEDESLIST,
            choiceDesList,
        );
    }
    #[inline]
    pub fn add_cancelDes(&mut self, cancelDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ChoiceNodeData::VT_CANCELDES,
            cancelDes,
        );
    }
    #[inline]
    pub fn add_choiceNum(&mut self, choiceNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Act17sideData_ChoiceNodeData::VT_CHOICENUM,
            choiceNum,
            0,
        );
    }
    #[inline]
    pub fn add_optionList(
        &mut self,
        optionList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ChoiceNodeOptionData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ChoiceNodeData::VT_OPTIONLIST,
            optionList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_ChoiceNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_ChoiceNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ChoiceNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_ChoiceNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_ChoiceNodeData");
        ds.field("nodeId", &self.nodeId());
        ds.field("choicePic", &self.choicePic());
        ds.field("isDisposable", &self.isDisposable());
        ds.field("choiceSpecialPic", &self.choiceSpecialPic());
        ds.field("choiceName", &self.choiceName());
        ds.field("choiceDesList", &self.choiceDesList());
        ds.field("cancelDes", &self.cancelDes());
        ds.field("choiceNum", &self.choiceNum());
        ds.field("optionList", &self.optionList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_ChoiceNodeDataT {
    pub nodeId: Option<String>,
    pub choicePic: Option<String>,
    pub isDisposable: bool,
    pub choiceSpecialPic: Option<String>,
    pub choiceName: Option<String>,
    pub choiceDesList: Option<Vec<String>>,
    pub cancelDes: Option<String>,
    pub choiceNum: i32,
    pub optionList: Option<Vec<clz_Torappu_Act17sideData_ChoiceNodeOptionDataT>>,
}
impl Default for clz_Torappu_Act17sideData_ChoiceNodeDataT {
    fn default() -> Self {
        Self {
            nodeId: None,
            choicePic: None,
            isDisposable: false,
            choiceSpecialPic: None,
            choiceName: None,
            choiceDesList: None,
            cancelDes: None,
            choiceNum: 0,
            optionList: None,
        }
    }
}
impl clz_Torappu_Act17sideData_ChoiceNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ChoiceNodeData<'b>> {
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let choicePic = self.choicePic.as_ref().map(|x| _fbb.create_string(x));
        let isDisposable = self.isDisposable;
        let choiceSpecialPic = self
            .choiceSpecialPic
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let choiceName = self.choiceName.as_ref().map(|x| _fbb.create_string(x));
        let choiceDesList = self.choiceDesList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let cancelDes = self.cancelDes.as_ref().map(|x| _fbb.create_string(x));
        let choiceNum = self.choiceNum;
        let optionList = self.optionList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_Act17sideData_ChoiceNodeData::create(
            _fbb,
            &clz_Torappu_Act17sideData_ChoiceNodeDataArgs {
                nodeId,
                choicePic,
                isDisposable,
                choiceSpecialPic,
                choiceName,
                choiceDesList,
                cancelDes,
                choiceNum,
                optionList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData_ChoiceNodeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act17sideData_ChoiceNodeData<'a> {
    type Inner = dict__string__clz_Torappu_Act17sideData_ChoiceNodeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData_ChoiceNodeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData_ChoiceNodeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_ChoiceNodeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData_ChoiceNodeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act17sideData_ChoiceNodeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData_ChoiceNodeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ChoiceNodeData>>(
                    dict__string__clz_Torappu_Act17sideData_ChoiceNodeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData_ChoiceNodeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ChoiceNodeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ChoiceNodeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData_ChoiceNodeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_Act17sideData_ChoiceNodeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData_ChoiceNodeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ChoiceNodeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ChoiceNodeData>>(
                dict__string__clz_Torappu_Act17sideData_ChoiceNodeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_ChoiceNodeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act17sideData_ChoiceNodeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData_ChoiceNodeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act17sideData_ChoiceNodeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideData_ChoiceNodeDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_ChoiceNodeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData_ChoiceNodeData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act17sideData_EventDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_EventData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_EventData<'a> {
    type Inner = clz_Torappu_Act17sideData_EventData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_EventData<'a> {
    pub const VT_EVENTID: flatbuffers::VOffsetT = 4;
    pub const VT_EVENTPIC: flatbuffers::VOffsetT = 6;
    pub const VT_EVENTSPECIALPIC: flatbuffers::VOffsetT = 8;
    pub const VT_EVENTTITLE: flatbuffers::VOffsetT = 10;
    pub const VT_EVENTDESLIST: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_EventData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_EventDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_EventData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_EventDataBuilder::new(_fbb);
        if let Some(x) = args.eventDesList {
            builder.add_eventDesList(x);
        }
        if let Some(x) = args.eventTitle {
            builder.add_eventTitle(x);
        }
        if let Some(x) = args.eventSpecialPic {
            builder.add_eventSpecialPic(x);
        }
        if let Some(x) = args.eventPic {
            builder.add_eventPic(x);
        }
        if let Some(x) = args.eventId {
            builder.add_eventId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_EventDataT {
        let eventId = self.eventId().map(|x| x.to_string());
        let eventPic = self.eventPic().map(|x| x.to_string());
        let eventSpecialPic = self.eventSpecialPic().map(|x| x.to_string());
        let eventTitle = self.eventTitle().map(|x| x.to_string());
        let eventDesList = self
            .eventDesList()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        clz_Torappu_Act17sideData_EventDataT {
            eventId,
            eventPic,
            eventSpecialPic,
            eventTitle,
            eventDesList,
        }
    }

    #[inline]
    pub fn eventId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_EventData::VT_EVENTID,
                None,
            )
        }
    }
    #[inline]
    pub fn eventPic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_EventData::VT_EVENTPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn eventSpecialPic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_EventData::VT_EVENTSPECIALPIC,
                None,
            )
        }
    }
    #[inline]
    pub fn eventTitle(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_EventData::VT_EVENTTITLE,
                None,
            )
        }
    }
    #[inline]
    pub fn eventDesList(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_Act17sideData_EventData::VT_EVENTDESLIST, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_EventData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("eventId", Self::VT_EVENTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "eventPic",
                Self::VT_EVENTPIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "eventSpecialPic",
                Self::VT_EVENTSPECIALPIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "eventTitle",
                Self::VT_EVENTTITLE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("eventDesList", Self::VT_EVENTDESLIST, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_EventDataArgs<'a> {
    pub eventId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eventPic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eventSpecialPic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eventTitle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub eventDesList: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_Act17sideData_EventDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_EventDataArgs {
            eventId: None,
            eventPic: None,
            eventSpecialPic: None,
            eventTitle: None,
            eventDesList: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_EventData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act17sideData_EventData", 5)?;
        if let Some(f) = self.eventId() {
            s.serialize_field("eventId", &f)?;
        } else {
            s.skip_field("eventId")?;
        }
        if let Some(f) = self.eventPic() {
            s.serialize_field("eventPic", &f)?;
        } else {
            s.skip_field("eventPic")?;
        }
        if let Some(f) = self.eventSpecialPic() {
            s.serialize_field("eventSpecialPic", &f)?;
        } else {
            s.skip_field("eventSpecialPic")?;
        }
        if let Some(f) = self.eventTitle() {
            s.serialize_field("eventTitle", &f)?;
        } else {
            s.skip_field("eventTitle")?;
        }
        if let Some(f) = self.eventDesList() {
            s.serialize_field("eventDesList", &f)?;
        } else {
            s.skip_field("eventDesList")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_EventDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_EventDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_eventId(&mut self, eventId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_EventData::VT_EVENTID,
            eventId,
        );
    }
    #[inline]
    pub fn add_eventPic(&mut self, eventPic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_EventData::VT_EVENTPIC,
            eventPic,
        );
    }
    #[inline]
    pub fn add_eventSpecialPic(&mut self, eventSpecialPic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_EventData::VT_EVENTSPECIALPIC,
            eventSpecialPic,
        );
    }
    #[inline]
    pub fn add_eventTitle(&mut self, eventTitle: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_EventData::VT_EVENTTITLE,
            eventTitle,
        );
    }
    #[inline]
    pub fn add_eventDesList(
        &mut self,
        eventDesList: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_EventData::VT_EVENTDESLIST,
            eventDesList,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_EventDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_EventDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_EventData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_EventData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_EventData");
        ds.field("eventId", &self.eventId());
        ds.field("eventPic", &self.eventPic());
        ds.field("eventSpecialPic", &self.eventSpecialPic());
        ds.field("eventTitle", &self.eventTitle());
        ds.field("eventDesList", &self.eventDesList());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_EventDataT {
    pub eventId: Option<String>,
    pub eventPic: Option<String>,
    pub eventSpecialPic: Option<String>,
    pub eventTitle: Option<String>,
    pub eventDesList: Option<Vec<String>>,
}
impl Default for clz_Torappu_Act17sideData_EventDataT {
    fn default() -> Self {
        Self {
            eventId: None,
            eventPic: None,
            eventSpecialPic: None,
            eventTitle: None,
            eventDesList: None,
        }
    }
}
impl clz_Torappu_Act17sideData_EventDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_EventData<'b>> {
        let eventId = self.eventId.as_ref().map(|x| _fbb.create_string(x));
        let eventPic = self.eventPic.as_ref().map(|x| _fbb.create_string(x));
        let eventSpecialPic = self.eventSpecialPic.as_ref().map(|x| _fbb.create_string(x));
        let eventTitle = self.eventTitle.as_ref().map(|x| _fbb.create_string(x));
        let eventDesList = self.eventDesList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_Act17sideData_EventData::create(
            _fbb,
            &clz_Torappu_Act17sideData_EventDataArgs {
                eventId,
                eventPic,
                eventSpecialPic,
                eventTitle,
                eventDesList,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideData_EventDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData_EventData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act17sideData_EventData<'a> {
    type Inner = dict__string__clz_Torappu_Act17sideData_EventData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData_EventData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData_EventData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideData_EventDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_EventData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_Act17sideData_EventDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideData_EventDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideData_EventDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData_EventData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act17sideData_EventData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData_EventData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_EventData>>(
                    dict__string__clz_Torappu_Act17sideData_EventData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData_EventData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_EventData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideData_EventDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_EventData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideData_EventDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideData_EventDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData_EventData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("dict__string__clz_Torappu_Act17sideData_EventData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideData_EventDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideData_EventDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData_EventData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_EventData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_EventData>>(
                dict__string__clz_Torappu_Act17sideData_EventData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideData_EventDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideData_EventDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_EventData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act17sideData_EventData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData_EventData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act17sideData_EventData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideData_EventDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideData_EventDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideData_EventDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideData_EventDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_EventData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData_EventData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideData_EventDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act17sideData_ArchiveItemUnlockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_ArchiveItemUnlockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_ArchiveItemUnlockData<'a> {
    type Inner = clz_Torappu_Act17sideData_ArchiveItemUnlockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_ArchiveItemUnlockData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_UNLOCKCONDITION: flatbuffers::VOffsetT = 8;
    pub const VT_NODEID: flatbuffers::VOffsetT = 10;
    pub const VT_STAGEPARAM: flatbuffers::VOffsetT = 12;
    pub const VT_CHAPTERID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_ArchiveItemUnlockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_ArchiveItemUnlockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ArchiveItemUnlockData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_ArchiveItemUnlockDataBuilder::new(_fbb);
        if let Some(x) = args.chapterId {
            builder.add_chapterId(x);
        }
        builder.add_stageParam(args.stageParam);
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        builder.add_unlockCondition(args.unlockCondition);
        builder.add_itemType(args.itemType);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_ArchiveItemUnlockDataT {
        let itemId = self.itemId().map(|x| x.to_string());
        let itemType = self.itemType();
        let unlockCondition = self.unlockCondition();
        let nodeId = self.nodeId().map(|x| x.to_string());
        let stageParam = self.stageParam();
        let chapterId = self.chapterId().map(|x| x.to_string());
        clz_Torappu_Act17sideData_ArchiveItemUnlockDataT {
            itemId,
            itemType,
            unlockCondition,
            nodeId,
            stageParam,
            chapterId,
        }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemType(&self) -> enum__Torappu_ActArchiveType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ActArchiveType>(
                    clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_ITEMTYPE,
                    Some(enum__Torappu_ActArchiveType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockCondition(&self) -> enum__Torappu_Act17sideData_ArchiveItemUnlockCondition {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Act17sideData_ArchiveItemUnlockCondition>(
                    clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_UNLOCKCONDITION,
                    Some(enum__Torappu_Act17sideData_ArchiveItemUnlockCondition::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn stageParam(&self) -> enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam>(
                    clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_STAGEPARAM,
                    Some(enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn chapterId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_CHAPTERID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_ArchiveItemUnlockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<enum__Torappu_ActArchiveType>("itemType", Self::VT_ITEMTYPE, false)?
            .visit_field::<enum__Torappu_Act17sideData_ArchiveItemUnlockCondition>(
                "unlockCondition",
                Self::VT_UNLOCKCONDITION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam>(
                "stageParam",
                Self::VT_STAGEPARAM,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "chapterId",
                Self::VT_CHAPTERID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_ArchiveItemUnlockDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemType: enum__Torappu_ActArchiveType,
    pub unlockCondition: enum__Torappu_Act17sideData_ArchiveItemUnlockCondition,
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stageParam: enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam,
    pub chapterId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Act17sideData_ArchiveItemUnlockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_ArchiveItemUnlockDataArgs {
            itemId: None,
            itemType: enum__Torappu_ActArchiveType::NONE,
            unlockCondition: enum__Torappu_Act17sideData_ArchiveItemUnlockCondition::NONE,
            nodeId: None,
            stageParam: enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam::NONE,
            chapterId: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_ArchiveItemUnlockData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Act17sideData_ArchiveItemUnlockData", 6)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        s.serialize_field("itemType", &self.itemType())?;
        s.serialize_field("unlockCondition", &self.unlockCondition())?;
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        s.serialize_field("stageParam", &self.stageParam())?;
        if let Some(f) = self.chapterId() {
            s.serialize_field("chapterId", &f)?;
        } else {
            s.skip_field("chapterId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_ArchiveItemUnlockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_ArchiveItemUnlockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_itemType(&mut self, itemType: enum__Torappu_ActArchiveType) {
        self.fbb_.push_slot::<enum__Torappu_ActArchiveType>(
            clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_ITEMTYPE,
            itemType,
            enum__Torappu_ActArchiveType::NONE,
        );
    }
    #[inline]
    pub fn add_unlockCondition(
        &mut self,
        unlockCondition: enum__Torappu_Act17sideData_ArchiveItemUnlockCondition,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_Act17sideData_ArchiveItemUnlockCondition>(
                clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_UNLOCKCONDITION,
                unlockCondition,
                enum__Torappu_Act17sideData_ArchiveItemUnlockCondition::NONE,
            );
    }
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_stageParam(
        &mut self,
        stageParam: enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam>(
                clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_STAGEPARAM,
                stageParam,
                enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam::NONE,
            );
    }
    #[inline]
    pub fn add_chapterId(&mut self, chapterId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_CHAPTERID,
            chapterId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_ArchiveItemUnlockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_ArchiveItemUnlockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ArchiveItemUnlockData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_ArchiveItemUnlockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_ArchiveItemUnlockData");
        ds.field("itemId", &self.itemId());
        ds.field("itemType", &self.itemType());
        ds.field("unlockCondition", &self.unlockCondition());
        ds.field("nodeId", &self.nodeId());
        ds.field("stageParam", &self.stageParam());
        ds.field("chapterId", &self.chapterId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_ArchiveItemUnlockDataT {
    pub itemId: Option<String>,
    pub itemType: enum__Torappu_ActArchiveType,
    pub unlockCondition: enum__Torappu_Act17sideData_ArchiveItemUnlockCondition,
    pub nodeId: Option<String>,
    pub stageParam: enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam,
    pub chapterId: Option<String>,
}
impl Default for clz_Torappu_Act17sideData_ArchiveItemUnlockDataT {
    fn default() -> Self {
        Self {
            itemId: None,
            itemType: enum__Torappu_ActArchiveType::NONE,
            unlockCondition: enum__Torappu_Act17sideData_ArchiveItemUnlockCondition::NONE,
            nodeId: None,
            stageParam: enum__Torappu_Act17sideData_ArchiveItemStageUnlockParam::NONE,
            chapterId: None,
        }
    }
}
impl clz_Torappu_Act17sideData_ArchiveItemUnlockDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ArchiveItemUnlockData<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let itemType = self.itemType;
        let unlockCondition = self.unlockCondition;
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let stageParam = self.stageParam;
        let chapterId = self.chapterId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Act17sideData_ArchiveItemUnlockData::create(
            _fbb,
            &clz_Torappu_Act17sideData_ArchiveItemUnlockDataArgs {
                itemId,
                itemType,
                unlockCondition,
                nodeId,
                stageParam,
                chapterId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData<'a>
{
    type Inner = dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData_ArchiveItemUnlockData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ArchiveItemUnlockData>>(dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ArchiveItemUnlockData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ArchiveItemUnlockData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ArchiveItemUnlockData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ArchiveItemUnlockData>>(dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideData_ArchiveItemUnlockDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act17sideData_TechTreeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_TechTreeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_TechTreeData<'a> {
    type Inner = clz_Torappu_Act17sideData_TechTreeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_TechTreeData<'a> {
    pub const VT_TECHTREEID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_TECHTREENAME: flatbuffers::VOffsetT = 8;
    pub const VT_DEFAULTBRANCHID: flatbuffers::VOffsetT = 10;
    pub const VT_LOCKDES: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_TechTreeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_TechTreeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechTreeData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_TechTreeDataBuilder::new(_fbb);
        if let Some(x) = args.lockDes {
            builder.add_lockDes(x);
        }
        if let Some(x) = args.defaultBranchId {
            builder.add_defaultBranchId(x);
        }
        if let Some(x) = args.techTreeName {
            builder.add_techTreeName(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.techTreeId {
            builder.add_techTreeId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_TechTreeDataT {
        let techTreeId = self.techTreeId().map(|x| x.to_string());
        let sortId = self.sortId();
        let techTreeName = self.techTreeName().map(|x| x.to_string());
        let defaultBranchId = self.defaultBranchId().map(|x| x.to_string());
        let lockDes = self.lockDes().map(|x| x.to_string());
        clz_Torappu_Act17sideData_TechTreeDataT {
            techTreeId,
            sortId,
            techTreeName,
            defaultBranchId,
            lockDes,
        }
    }

    #[inline]
    pub fn techTreeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechTreeData::VT_TECHTREEID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_Act17sideData_TechTreeData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn techTreeName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechTreeData::VT_TECHTREENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn defaultBranchId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechTreeData::VT_DEFAULTBRANCHID,
                None,
            )
        }
    }
    #[inline]
    pub fn lockDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechTreeData::VT_LOCKDES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_TechTreeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "techTreeId",
                Self::VT_TECHTREEID,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "techTreeName",
                Self::VT_TECHTREENAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "defaultBranchId",
                Self::VT_DEFAULTBRANCHID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lockDes", Self::VT_LOCKDES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_TechTreeDataArgs<'a> {
    pub techTreeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub techTreeName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub defaultBranchId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lockDes: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Act17sideData_TechTreeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_TechTreeDataArgs {
            techTreeId: None,
            sortId: 0,
            techTreeName: None,
            defaultBranchId: None,
            lockDes: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_TechTreeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act17sideData_TechTreeData", 5)?;
        if let Some(f) = self.techTreeId() {
            s.serialize_field("techTreeId", &f)?;
        } else {
            s.skip_field("techTreeId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.techTreeName() {
            s.serialize_field("techTreeName", &f)?;
        } else {
            s.skip_field("techTreeName")?;
        }
        if let Some(f) = self.defaultBranchId() {
            s.serialize_field("defaultBranchId", &f)?;
        } else {
            s.skip_field("defaultBranchId")?;
        }
        if let Some(f) = self.lockDes() {
            s.serialize_field("lockDes", &f)?;
        } else {
            s.skip_field("lockDes")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_TechTreeDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_TechTreeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_techTreeId(&mut self, techTreeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechTreeData::VT_TECHTREEID,
            techTreeId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_Act17sideData_TechTreeData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_techTreeName(&mut self, techTreeName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechTreeData::VT_TECHTREENAME,
            techTreeName,
        );
    }
    #[inline]
    pub fn add_defaultBranchId(&mut self, defaultBranchId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechTreeData::VT_DEFAULTBRANCHID,
            defaultBranchId,
        );
    }
    #[inline]
    pub fn add_lockDes(&mut self, lockDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechTreeData::VT_LOCKDES,
            lockDes,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_TechTreeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_TechTreeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechTreeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_TechTreeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_TechTreeData");
        ds.field("techTreeId", &self.techTreeId());
        ds.field("sortId", &self.sortId());
        ds.field("techTreeName", &self.techTreeName());
        ds.field("defaultBranchId", &self.defaultBranchId());
        ds.field("lockDes", &self.lockDes());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_TechTreeDataT {
    pub techTreeId: Option<String>,
    pub sortId: i32,
    pub techTreeName: Option<String>,
    pub defaultBranchId: Option<String>,
    pub lockDes: Option<String>,
}
impl Default for clz_Torappu_Act17sideData_TechTreeDataT {
    fn default() -> Self {
        Self {
            techTreeId: None,
            sortId: 0,
            techTreeName: None,
            defaultBranchId: None,
            lockDes: None,
        }
    }
}
impl clz_Torappu_Act17sideData_TechTreeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechTreeData<'b>> {
        let techTreeId = self.techTreeId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let techTreeName = self.techTreeName.as_ref().map(|x| _fbb.create_string(x));
        let defaultBranchId = self.defaultBranchId.as_ref().map(|x| _fbb.create_string(x));
        let lockDes = self.lockDes.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Act17sideData_TechTreeData::create(
            _fbb,
            &clz_Torappu_Act17sideData_TechTreeDataArgs {
                techTreeId,
                sortId,
                techTreeName,
                defaultBranchId,
                lockDes,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideData_TechTreeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData_TechTreeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act17sideData_TechTreeData<'a> {
    type Inner = dict__string__clz_Torappu_Act17sideData_TechTreeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData_TechTreeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData_TechTreeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideData_TechTreeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_TechTreeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_Act17sideData_TechTreeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideData_TechTreeDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideData_TechTreeDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData_TechTreeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act17sideData_TechTreeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData_TechTreeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_TechTreeData>>(
                    dict__string__clz_Torappu_Act17sideData_TechTreeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData_TechTreeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_TechTreeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideData_TechTreeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechTreeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideData_TechTreeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideData_TechTreeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData_TechTreeData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_Act17sideData_TechTreeData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideData_TechTreeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideData_TechTreeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData_TechTreeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechTreeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechTreeData>>(
                dict__string__clz_Torappu_Act17sideData_TechTreeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideData_TechTreeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideData_TechTreeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_TechTreeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act17sideData_TechTreeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData_TechTreeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act17sideData_TechTreeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideData_TechTreeDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideData_TechTreeDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideData_TechTreeDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideData_TechTreeDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_TechTreeData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData_TechTreeData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideData_TechTreeDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_RuneData_SelectorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneData_Selector<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneData_Selector<'a> {
    type Inner = clz_Torappu_RuneData_Selector<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RuneData_Selector<'a> {
    pub const VT_PROFESSIONMASK: flatbuffers::VOffsetT = 4;
    pub const VT_BUILDABLEMASK: flatbuffers::VOffsetT = 6;
    pub const VT_PLAYERSIDEMASK: flatbuffers::VOffsetT = 8;
    pub const VT_SIDETYPE: flatbuffers::VOffsetT = 10;
    pub const VT_CHARIDFILTER: flatbuffers::VOffsetT = 12;
    pub const VT_ENEMYIDFILTER: flatbuffers::VOffsetT = 14;
    pub const VT_ENEMYIDEXCLUDEFILTER: flatbuffers::VOffsetT = 16;
    pub const VT_ENEMYLEVELTYPEFILTER: flatbuffers::VOffsetT = 18;
    pub const VT_ENEMYACTIONHIDDENGROUPFILTER: flatbuffers::VOffsetT = 20;
    pub const VT_SKILLIDFILTER: flatbuffers::VOffsetT = 22;
    pub const VT_TILEKEYFILTER: flatbuffers::VOffsetT = 24;
    pub const VT_GROUPTAGFILTER: flatbuffers::VOffsetT = 26;
    pub const VT_FILTERTAGFILTER: flatbuffers::VOffsetT = 28;
    pub const VT_FILTERTAGEXCLUDEFILTER: flatbuffers::VOffsetT = 30;
    pub const VT_SUBPROFESSIONEXCLUDEFILTER: flatbuffers::VOffsetT = 32;
    pub const VT_MAPTAGFILTER: flatbuffers::VOffsetT = 34;
    pub const VT_HEIGHTTYPEMASK: flatbuffers::VOffsetT = 36;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneData_Selector { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneData_SelectorArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'bldr>> {
        let mut builder = clz_Torappu_RuneData_SelectorBuilder::new(_fbb);
        builder.add_heightTypeMask(args.heightTypeMask);
        if let Some(x) = args.mapTagFilter {
            builder.add_mapTagFilter(x);
        }
        if let Some(x) = args.subProfessionExcludeFilter {
            builder.add_subProfessionExcludeFilter(x);
        }
        if let Some(x) = args.filterTagExcludeFilter {
            builder.add_filterTagExcludeFilter(x);
        }
        if let Some(x) = args.filterTagFilter {
            builder.add_filterTagFilter(x);
        }
        if let Some(x) = args.groupTagFilter {
            builder.add_groupTagFilter(x);
        }
        if let Some(x) = args.tileKeyFilter {
            builder.add_tileKeyFilter(x);
        }
        if let Some(x) = args.skillIdFilter {
            builder.add_skillIdFilter(x);
        }
        if let Some(x) = args.enemyActionHiddenGroupFilter {
            builder.add_enemyActionHiddenGroupFilter(x);
        }
        if let Some(x) = args.enemyLevelTypeFilter {
            builder.add_enemyLevelTypeFilter(x);
        }
        if let Some(x) = args.enemyIdExcludeFilter {
            builder.add_enemyIdExcludeFilter(x);
        }
        if let Some(x) = args.enemyIdFilter {
            builder.add_enemyIdFilter(x);
        }
        if let Some(x) = args.charIdFilter {
            builder.add_charIdFilter(x);
        }
        builder.add_sideType(args.sideType);
        builder.add_buildableMask(args.buildableMask);
        builder.add_professionMask(args.professionMask);
        builder.add_playerSideMask(args.playerSideMask);
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RuneData_SelectorT {
        let professionMask = self.professionMask();
        let buildableMask = self.buildableMask();
        let playerSideMask = self.playerSideMask();
        let sideType = self.sideType();
        let charIdFilter = self
            .charIdFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let enemyIdFilter = self
            .enemyIdFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let enemyIdExcludeFilter = self
            .enemyIdExcludeFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let enemyLevelTypeFilter = self
            .enemyLevelTypeFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let enemyActionHiddenGroupFilter = self
            .enemyActionHiddenGroupFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let skillIdFilter = self
            .skillIdFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let tileKeyFilter = self
            .tileKeyFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let groupTagFilter = self
            .groupTagFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let filterTagFilter = self
            .filterTagFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let filterTagExcludeFilter = self
            .filterTagExcludeFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let subProfessionExcludeFilter = self
            .subProfessionExcludeFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let mapTagFilter = self
            .mapTagFilter()
            .map(|x| x.iter().map(|s| s.to_string()).collect());
        let heightTypeMask = self.heightTypeMask();
        clz_Torappu_RuneData_SelectorT {
            professionMask,
            buildableMask,
            playerSideMask,
            sideType,
            charIdFilter,
            enemyIdFilter,
            enemyIdExcludeFilter,
            enemyLevelTypeFilter,
            enemyActionHiddenGroupFilter,
            skillIdFilter,
            tileKeyFilter,
            groupTagFilter,
            filterTagFilter,
            filterTagExcludeFilter,
            subProfessionExcludeFilter,
            mapTagFilter,
            heightTypeMask,
        }
    }

    #[inline]
    pub fn professionMask(&self) -> enum__Torappu_ProfessionCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ProfessionCategory>(
                    clz_Torappu_RuneData_Selector::VT_PROFESSIONMASK,
                    Some(enum__Torappu_ProfessionCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buildableMask(&self) -> enum__Torappu_BuildableType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildableType>(
                    clz_Torappu_RuneData_Selector::VT_BUILDABLEMASK,
                    Some(enum__Torappu_BuildableType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn playerSideMask(&self) -> enum__Torappu_PlayerSideMask {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_PlayerSideMask>(
                    clz_Torappu_RuneData_Selector::VT_PLAYERSIDEMASK,
                    Some(enum__Torappu_PlayerSideMask::ALL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sideType(&self) -> enum__Torappu_Battle_SideType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Battle_SideType>(
                    clz_Torappu_RuneData_Selector::VT_SIDETYPE,
                    Some(enum__Torappu_Battle_SideType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn charIdFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_CHARIDFILTER, None)
        }
    }
    #[inline]
    pub fn enemyIdFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_ENEMYIDFILTER, None)
        }
    }
    #[inline]
    pub fn enemyIdExcludeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_ENEMYIDEXCLUDEFILTER, None)
        }
    }
    #[inline]
    pub fn enemyLevelTypeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_ENEMYLEVELTYPEFILTER, None)
        }
    }
    #[inline]
    pub fn enemyActionHiddenGroupFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RuneData_Selector::VT_ENEMYACTIONHIDDENGROUPFILTER,
                None,
            )
        }
    }
    #[inline]
    pub fn skillIdFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_SKILLIDFILTER, None)
        }
    }
    #[inline]
    pub fn tileKeyFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_TILEKEYFILTER, None)
        }
    }
    #[inline]
    pub fn groupTagFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_GROUPTAGFILTER, None)
        }
    }
    #[inline]
    pub fn filterTagFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_FILTERTAGFILTER, None)
        }
    }
    #[inline]
    pub fn filterTagExcludeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RuneData_Selector::VT_FILTERTAGEXCLUDEFILTER,
                None,
            )
        }
    }
    #[inline]
    pub fn subProfessionExcludeFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_RuneData_Selector::VT_SUBPROFESSIONEXCLUDEFILTER,
                None,
            )
        }
    }
    #[inline]
    pub fn mapTagFilter(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_RuneData_Selector::VT_MAPTAGFILTER, None)
        }
    }
    #[inline]
    pub fn heightTypeMask(&self) -> enum__Torappu_TileData_HeightTypeMask {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_TileData_HeightTypeMask>(
                    clz_Torappu_RuneData_Selector::VT_HEIGHTTYPEMASK,
                    Some(enum__Torappu_TileData_HeightTypeMask::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneData_Selector<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_ProfessionCategory>(
                "professionMask",
                Self::VT_PROFESSIONMASK,
                false,
            )?
            .visit_field::<enum__Torappu_BuildableType>(
                "buildableMask",
                Self::VT_BUILDABLEMASK,
                false,
            )?
            .visit_field::<enum__Torappu_PlayerSideMask>(
                "playerSideMask",
                Self::VT_PLAYERSIDEMASK,
                false,
            )?
            .visit_field::<enum__Torappu_Battle_SideType>("sideType", Self::VT_SIDETYPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("charIdFilter", Self::VT_CHARIDFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyIdFilter", Self::VT_ENEMYIDFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyIdExcludeFilter", Self::VT_ENEMYIDEXCLUDEFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("enemyLevelTypeFilter", Self::VT_ENEMYLEVELTYPEFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "enemyActionHiddenGroupFilter",
                Self::VT_ENEMYACTIONHIDDENGROUPFILTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("skillIdFilter", Self::VT_SKILLIDFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("tileKeyFilter", Self::VT_TILEKEYFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("groupTagFilter", Self::VT_GROUPTAGFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("filterTagFilter", Self::VT_FILTERTAGFILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "filterTagExcludeFilter",
                Self::VT_FILTERTAGEXCLUDEFILTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>(
                "subProfessionExcludeFilter",
                Self::VT_SUBPROFESSIONEXCLUDEFILTER,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("mapTagFilter", Self::VT_MAPTAGFILTER, false)?
            .visit_field::<enum__Torappu_TileData_HeightTypeMask>(
                "heightTypeMask",
                Self::VT_HEIGHTTYPEMASK,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneData_SelectorArgs<'a> {
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub buildableMask: enum__Torappu_BuildableType,
    pub playerSideMask: enum__Torappu_PlayerSideMask,
    pub sideType: enum__Torappu_Battle_SideType,
    pub charIdFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyIdFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyIdExcludeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyLevelTypeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub enemyActionHiddenGroupFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub skillIdFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub tileKeyFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub groupTagFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub filterTagFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub filterTagExcludeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub subProfessionExcludeFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub mapTagFilter: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub heightTypeMask: enum__Torappu_TileData_HeightTypeMask,
}
impl<'a> Default for clz_Torappu_RuneData_SelectorArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneData_SelectorArgs {
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            buildableMask: enum__Torappu_BuildableType::NONE,
            playerSideMask: enum__Torappu_PlayerSideMask::ALL,
            sideType: enum__Torappu_Battle_SideType::NONE,
            charIdFilter: None,
            enemyIdFilter: None,
            enemyIdExcludeFilter: None,
            enemyLevelTypeFilter: None,
            enemyActionHiddenGroupFilter: None,
            skillIdFilter: None,
            tileKeyFilter: None,
            groupTagFilter: None,
            filterTagFilter: None,
            filterTagExcludeFilter: None,
            subProfessionExcludeFilter: None,
            mapTagFilter: None,
            heightTypeMask: enum__Torappu_TileData_HeightTypeMask::NONE,
        }
    }
}

impl Serialize for clz_Torappu_RuneData_Selector<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RuneData_Selector", 17)?;
        s.serialize_field("professionMask", &self.professionMask())?;
        s.serialize_field("buildableMask", &self.buildableMask())?;
        s.serialize_field("playerSideMask", &self.playerSideMask())?;
        s.serialize_field("sideType", &self.sideType())?;
        if let Some(f) = self.charIdFilter() {
            s.serialize_field("charIdFilter", &f)?;
        } else {
            s.skip_field("charIdFilter")?;
        }
        if let Some(f) = self.enemyIdFilter() {
            s.serialize_field("enemyIdFilter", &f)?;
        } else {
            s.skip_field("enemyIdFilter")?;
        }
        if let Some(f) = self.enemyIdExcludeFilter() {
            s.serialize_field("enemyIdExcludeFilter", &f)?;
        } else {
            s.skip_field("enemyIdExcludeFilter")?;
        }
        if let Some(f) = self.enemyLevelTypeFilter() {
            s.serialize_field("enemyLevelTypeFilter", &f)?;
        } else {
            s.skip_field("enemyLevelTypeFilter")?;
        }
        if let Some(f) = self.enemyActionHiddenGroupFilter() {
            s.serialize_field("enemyActionHiddenGroupFilter", &f)?;
        } else {
            s.skip_field("enemyActionHiddenGroupFilter")?;
        }
        if let Some(f) = self.skillIdFilter() {
            s.serialize_field("skillIdFilter", &f)?;
        } else {
            s.skip_field("skillIdFilter")?;
        }
        if let Some(f) = self.tileKeyFilter() {
            s.serialize_field("tileKeyFilter", &f)?;
        } else {
            s.skip_field("tileKeyFilter")?;
        }
        if let Some(f) = self.groupTagFilter() {
            s.serialize_field("groupTagFilter", &f)?;
        } else {
            s.skip_field("groupTagFilter")?;
        }
        if let Some(f) = self.filterTagFilter() {
            s.serialize_field("filterTagFilter", &f)?;
        } else {
            s.skip_field("filterTagFilter")?;
        }
        if let Some(f) = self.filterTagExcludeFilter() {
            s.serialize_field("filterTagExcludeFilter", &f)?;
        } else {
            s.skip_field("filterTagExcludeFilter")?;
        }
        if let Some(f) = self.subProfessionExcludeFilter() {
            s.serialize_field("subProfessionExcludeFilter", &f)?;
        } else {
            s.skip_field("subProfessionExcludeFilter")?;
        }
        if let Some(f) = self.mapTagFilter() {
            s.serialize_field("mapTagFilter", &f)?;
        } else {
            s.skip_field("mapTagFilter")?;
        }
        s.serialize_field("heightTypeMask", &self.heightTypeMask())?;
        s.end()
    }
}

pub struct clz_Torappu_RuneData_SelectorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RuneData_SelectorBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_professionMask(&mut self, professionMask: enum__Torappu_ProfessionCategory) {
        self.fbb_.push_slot::<enum__Torappu_ProfessionCategory>(
            clz_Torappu_RuneData_Selector::VT_PROFESSIONMASK,
            professionMask,
            enum__Torappu_ProfessionCategory::NONE,
        );
    }
    #[inline]
    pub fn add_buildableMask(&mut self, buildableMask: enum__Torappu_BuildableType) {
        self.fbb_.push_slot::<enum__Torappu_BuildableType>(
            clz_Torappu_RuneData_Selector::VT_BUILDABLEMASK,
            buildableMask,
            enum__Torappu_BuildableType::NONE,
        );
    }
    #[inline]
    pub fn add_playerSideMask(&mut self, playerSideMask: enum__Torappu_PlayerSideMask) {
        self.fbb_.push_slot::<enum__Torappu_PlayerSideMask>(
            clz_Torappu_RuneData_Selector::VT_PLAYERSIDEMASK,
            playerSideMask,
            enum__Torappu_PlayerSideMask::ALL,
        );
    }
    #[inline]
    pub fn add_sideType(&mut self, sideType: enum__Torappu_Battle_SideType) {
        self.fbb_.push_slot::<enum__Torappu_Battle_SideType>(
            clz_Torappu_RuneData_Selector::VT_SIDETYPE,
            sideType,
            enum__Torappu_Battle_SideType::NONE,
        );
    }
    #[inline]
    pub fn add_charIdFilter(
        &mut self,
        charIdFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_CHARIDFILTER,
            charIdFilter,
        );
    }
    #[inline]
    pub fn add_enemyIdFilter(
        &mut self,
        enemyIdFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYIDFILTER,
            enemyIdFilter,
        );
    }
    #[inline]
    pub fn add_enemyIdExcludeFilter(
        &mut self,
        enemyIdExcludeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYIDEXCLUDEFILTER,
            enemyIdExcludeFilter,
        );
    }
    #[inline]
    pub fn add_enemyLevelTypeFilter(
        &mut self,
        enemyLevelTypeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYLEVELTYPEFILTER,
            enemyLevelTypeFilter,
        );
    }
    #[inline]
    pub fn add_enemyActionHiddenGroupFilter(
        &mut self,
        enemyActionHiddenGroupFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_ENEMYACTIONHIDDENGROUPFILTER,
            enemyActionHiddenGroupFilter,
        );
    }
    #[inline]
    pub fn add_skillIdFilter(
        &mut self,
        skillIdFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_SKILLIDFILTER,
            skillIdFilter,
        );
    }
    #[inline]
    pub fn add_tileKeyFilter(
        &mut self,
        tileKeyFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_TILEKEYFILTER,
            tileKeyFilter,
        );
    }
    #[inline]
    pub fn add_groupTagFilter(
        &mut self,
        groupTagFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_GROUPTAGFILTER,
            groupTagFilter,
        );
    }
    #[inline]
    pub fn add_filterTagFilter(
        &mut self,
        filterTagFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_FILTERTAGFILTER,
            filterTagFilter,
        );
    }
    #[inline]
    pub fn add_filterTagExcludeFilter(
        &mut self,
        filterTagExcludeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_FILTERTAGEXCLUDEFILTER,
            filterTagExcludeFilter,
        );
    }
    #[inline]
    pub fn add_subProfessionExcludeFilter(
        &mut self,
        subProfessionExcludeFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_SUBPROFESSIONEXCLUDEFILTER,
            subProfessionExcludeFilter,
        );
    }
    #[inline]
    pub fn add_mapTagFilter(
        &mut self,
        mapTagFilter: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData_Selector::VT_MAPTAGFILTER,
            mapTagFilter,
        );
    }
    #[inline]
    pub fn add_heightTypeMask(&mut self, heightTypeMask: enum__Torappu_TileData_HeightTypeMask) {
        self.fbb_
            .push_slot::<enum__Torappu_TileData_HeightTypeMask>(
                clz_Torappu_RuneData_Selector::VT_HEIGHTTYPEMASK,
                heightTypeMask,
                enum__Torappu_TileData_HeightTypeMask::NONE,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneData_SelectorBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneData_SelectorBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneData_Selector<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneData_Selector");
        ds.field("professionMask", &self.professionMask());
        ds.field("buildableMask", &self.buildableMask());
        ds.field("playerSideMask", &self.playerSideMask());
        ds.field("sideType", &self.sideType());
        ds.field("charIdFilter", &self.charIdFilter());
        ds.field("enemyIdFilter", &self.enemyIdFilter());
        ds.field("enemyIdExcludeFilter", &self.enemyIdExcludeFilter());
        ds.field("enemyLevelTypeFilter", &self.enemyLevelTypeFilter());
        ds.field(
            "enemyActionHiddenGroupFilter",
            &self.enemyActionHiddenGroupFilter(),
        );
        ds.field("skillIdFilter", &self.skillIdFilter());
        ds.field("tileKeyFilter", &self.tileKeyFilter());
        ds.field("groupTagFilter", &self.groupTagFilter());
        ds.field("filterTagFilter", &self.filterTagFilter());
        ds.field("filterTagExcludeFilter", &self.filterTagExcludeFilter());
        ds.field(
            "subProfessionExcludeFilter",
            &self.subProfessionExcludeFilter(),
        );
        ds.field("mapTagFilter", &self.mapTagFilter());
        ds.field("heightTypeMask", &self.heightTypeMask());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RuneData_SelectorT {
    pub professionMask: enum__Torappu_ProfessionCategory,
    pub buildableMask: enum__Torappu_BuildableType,
    pub playerSideMask: enum__Torappu_PlayerSideMask,
    pub sideType: enum__Torappu_Battle_SideType,
    pub charIdFilter: Option<Vec<String>>,
    pub enemyIdFilter: Option<Vec<String>>,
    pub enemyIdExcludeFilter: Option<Vec<String>>,
    pub enemyLevelTypeFilter: Option<Vec<String>>,
    pub enemyActionHiddenGroupFilter: Option<Vec<String>>,
    pub skillIdFilter: Option<Vec<String>>,
    pub tileKeyFilter: Option<Vec<String>>,
    pub groupTagFilter: Option<Vec<String>>,
    pub filterTagFilter: Option<Vec<String>>,
    pub filterTagExcludeFilter: Option<Vec<String>>,
    pub subProfessionExcludeFilter: Option<Vec<String>>,
    pub mapTagFilter: Option<Vec<String>>,
    pub heightTypeMask: enum__Torappu_TileData_HeightTypeMask,
}
impl Default for clz_Torappu_RuneData_SelectorT {
    fn default() -> Self {
        Self {
            professionMask: enum__Torappu_ProfessionCategory::NONE,
            buildableMask: enum__Torappu_BuildableType::NONE,
            playerSideMask: enum__Torappu_PlayerSideMask::ALL,
            sideType: enum__Torappu_Battle_SideType::NONE,
            charIdFilter: None,
            enemyIdFilter: None,
            enemyIdExcludeFilter: None,
            enemyLevelTypeFilter: None,
            enemyActionHiddenGroupFilter: None,
            skillIdFilter: None,
            tileKeyFilter: None,
            groupTagFilter: None,
            filterTagFilter: None,
            filterTagExcludeFilter: None,
            subProfessionExcludeFilter: None,
            mapTagFilter: None,
            heightTypeMask: enum__Torappu_TileData_HeightTypeMask::NONE,
        }
    }
}
impl clz_Torappu_RuneData_SelectorT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'b>> {
        let professionMask = self.professionMask;
        let buildableMask = self.buildableMask;
        let playerSideMask = self.playerSideMask;
        let sideType = self.sideType;
        let charIdFilter = self.charIdFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let enemyIdFilter = self.enemyIdFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let enemyIdExcludeFilter = self.enemyIdExcludeFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let enemyLevelTypeFilter = self.enemyLevelTypeFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let enemyActionHiddenGroupFilter = self.enemyActionHiddenGroupFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let skillIdFilter = self.skillIdFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let tileKeyFilter = self.tileKeyFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let groupTagFilter = self.groupTagFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let filterTagFilter = self.filterTagFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let filterTagExcludeFilter = self.filterTagExcludeFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let subProfessionExcludeFilter = self.subProfessionExcludeFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let mapTagFilter = self.mapTagFilter.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();
            _fbb.create_vector(&w)
        });
        let heightTypeMask = self.heightTypeMask;
        clz_Torappu_RuneData_Selector::create(
            _fbb,
            &clz_Torappu_RuneData_SelectorArgs {
                professionMask,
                buildableMask,
                playerSideMask,
                sideType,
                charIdFilter,
                enemyIdFilter,
                enemyIdExcludeFilter,
                enemyLevelTypeFilter,
                enemyActionHiddenGroupFilter,
                skillIdFilter,
                tileKeyFilter,
                groupTagFilter,
                filterTagFilter,
                filterTagExcludeFilter,
                subProfessionExcludeFilter,
                mapTagFilter,
                heightTypeMask,
            },
        )
    }
}
pub enum clz_Torappu_Blackboard_DataPairOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Blackboard_DataPair<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Blackboard_DataPair<'a> {
    type Inner = clz_Torappu_Blackboard_DataPair<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Blackboard_DataPair<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
    pub const VT_VALUESTR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Blackboard_DataPair { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Blackboard_DataPairArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'bldr>> {
        let mut builder = clz_Torappu_Blackboard_DataPairBuilder::new(_fbb);
        if let Some(x) = args.valueStr {
            builder.add_valueStr(x);
        }
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Blackboard_DataPairT {
        let key = self.key().map(|x| x.to_string());
        let value = self.value();
        let valueStr = self.valueStr().map(|x| x.to_string());
        clz_Torappu_Blackboard_DataPairT {
            key,
            value,
            valueStr,
        }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_KEY,
                None,
            )
        }
    }
    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn valueStr(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Blackboard_DataPair<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "valueStr",
                Self::VT_VALUESTR,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Blackboard_DataPairArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: f32,
    pub valueStr: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Blackboard_DataPairArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Blackboard_DataPairArgs {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}

impl Serialize for clz_Torappu_Blackboard_DataPair<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Blackboard_DataPair", 3)?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        s.serialize_field("value", &self.value())?;
        if let Some(f) = self.valueStr() {
            s.serialize_field("valueStr", &f)?;
        } else {
            s.skip_field("valueStr")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Blackboard_DataPairBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_Blackboard_DataPair::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn add_valueStr(&mut self, valueStr: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Blackboard_DataPair::VT_VALUESTR,
            valueStr,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Blackboard_DataPairBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Blackboard_DataPairBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Blackboard_DataPair<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Blackboard_DataPair");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.field("valueStr", &self.valueStr());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Blackboard_DataPairT {
    pub key: Option<String>,
    pub value: f32,
    pub valueStr: Option<String>,
}
impl Default for clz_Torappu_Blackboard_DataPairT {
    fn default() -> Self {
        Self {
            key: None,
            value: 0.0,
            valueStr: None,
        }
    }
}
impl clz_Torappu_Blackboard_DataPairT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Blackboard_DataPair<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let value = self.value;
        let valueStr = self.valueStr.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Blackboard_DataPair::create(
            _fbb,
            &clz_Torappu_Blackboard_DataPairArgs {
                key,
                value,
                valueStr,
            },
        )
    }
}
pub enum clz_Torappu_RuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneData<'a> {
    type Inner = clz_Torappu_RuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RuneData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_SELECTOR: flatbuffers::VOffsetT = 6;
    pub const VT_BLACKBOARD: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData<'bldr>> {
        let mut builder = clz_Torappu_RuneDataBuilder::new(_fbb);
        if let Some(x) = args.blackboard {
            builder.add_blackboard(x);
        }
        if let Some(x) = args.selector {
            builder.add_selector(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RuneDataT {
        let key = self.key().map(|x| x.to_string());
        let selector = self.selector().map(|x| Box::new(x.unpack()));
        let blackboard = self
            .blackboard()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RuneDataT {
            key,
            selector,
            blackboard,
        }
    }

    #[inline]
    pub fn key(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_RuneData::VT_KEY, None)
        }
    }
    #[inline]
    pub fn selector(&self) -> Option<clz_Torappu_RuneData_Selector<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneData_Selector>>(
                    clz_Torappu_RuneData::VT_SELECTOR,
                    None,
                )
        }
    }
    #[inline]
    pub fn blackboard(
        &self,
    ) -> Option<
        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>>,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>(clz_Torappu_RuneData::VT_BLACKBOARD, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneData_Selector>>(
                "selector",
                Self::VT_SELECTOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair>,
                >,
            >>("blackboard", Self::VT_BLACKBOARD, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub selector: Option<flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'a>>>,
    pub blackboard: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneDataArgs {
            key: None,
            selector: None,
            blackboard: None,
        }
    }
}

impl Serialize for clz_Torappu_RuneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RuneData", 3)?;
        if let Some(f) = self.key() {
            s.serialize_field("key", &f)?;
        } else {
            s.skip_field("key")?;
        }
        if let Some(f) = self.selector() {
            s.serialize_field("selector", &f)?;
        } else {
            s.skip_field("selector")?;
        }
        if let Some(f) = self.blackboard() {
            s.serialize_field("blackboard", &f)?;
        } else {
            s.skip_field("blackboard")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RuneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RuneDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_RuneData::VT_KEY, key);
    }
    #[inline]
    pub fn add_selector(
        &mut self,
        selector: flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RuneData_Selector>>(
                clz_Torappu_RuneData::VT_SELECTOR,
                selector,
            );
    }
    #[inline]
    pub fn add_blackboard(
        &mut self,
        blackboard: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Blackboard_DataPair<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneData::VT_BLACKBOARD,
            blackboard,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneData");
        ds.field("key", &self.key());
        ds.field("selector", &self.selector());
        ds.field("blackboard", &self.blackboard());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RuneDataT {
    pub key: Option<String>,
    pub selector: Option<Box<clz_Torappu_RuneData_SelectorT>>,
    pub blackboard: Option<Vec<clz_Torappu_Blackboard_DataPairT>>,
}
impl Default for clz_Torappu_RuneDataT {
    fn default() -> Self {
        Self {
            key: None,
            selector: None,
            blackboard: None,
        }
    }
}
impl clz_Torappu_RuneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneData<'b>> {
        let key = self.key.as_ref().map(|x| _fbb.create_string(x));
        let selector = self.selector.as_ref().map(|x| x.pack(_fbb));
        let blackboard = self.blackboard.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RuneData::create(
            _fbb,
            &clz_Torappu_RuneDataArgs {
                key,
                selector,
                blackboard,
            },
        )
    }
}
pub enum clz_Torappu_RuneTable_PackedRuneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RuneTable_PackedRuneData<'a> {
    type Inner = clz_Torappu_RuneTable_PackedRuneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RuneTable_PackedRuneData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_POINTS: flatbuffers::VOffsetT = 6;
    pub const VT_MUTEXGROUPKEY: flatbuffers::VOffsetT = 8;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
    pub const VT_RUNES: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RuneTable_PackedRuneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RuneTable_PackedRuneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'bldr>> {
        let mut builder = clz_Torappu_RuneTable_PackedRuneDataBuilder::new(_fbb);
        if let Some(x) = args.runes {
            builder.add_runes(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.mutexGroupKey {
            builder.add_mutexGroupKey(x);
        }
        builder.add_points(args.points);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RuneTable_PackedRuneDataT {
        let id = self.id().map(|x| x.to_string());
        let points = self.points();
        let mutexGroupKey = self.mutexGroupKey().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let runes = self.runes().map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_RuneTable_PackedRuneDataT {
            id,
            points,
            mutexGroupKey,
            description,
            runes,
        }
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneTable_PackedRuneData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn points(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_RuneTable_PackedRuneData::VT_POINTS, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn mutexGroupKey(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneTable_PackedRuneData::VT_MUTEXGROUPKEY,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RuneTable_PackedRuneData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn runes(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData>>,
            >>(clz_Torappu_RuneTable_PackedRuneData::VT_RUNES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RuneTable_PackedRuneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<f32>("points", Self::VT_POINTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mutexGroupKey",
                Self::VT_MUTEXGROUPKEY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData>>,
            >>("runes", Self::VT_RUNES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub points: f32,
    pub mutexGroupKey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub runes: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_RuneTable_PackedRuneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RuneTable_PackedRuneDataArgs {
            id: None,
            points: 0.0,
            mutexGroupKey: None,
            description: None,
            runes: None,
        }
    }
}

impl Serialize for clz_Torappu_RuneTable_PackedRuneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RuneTable_PackedRuneData", 5)?;
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.serialize_field("points", &self.points())?;
        if let Some(f) = self.mutexGroupKey() {
            s.serialize_field("mutexGroupKey", &f)?;
        } else {
            s.skip_field("mutexGroupKey")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.runes() {
            s.serialize_field("runes", &f)?;
        } else {
            s.skip_field("runes")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_RuneTable_PackedRuneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_points(&mut self, points: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_RuneTable_PackedRuneData::VT_POINTS, points, 0.0);
    }
    #[inline]
    pub fn add_mutexGroupKey(&mut self, mutexGroupKey: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_MUTEXGROUPKEY,
            mutexGroupKey,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_runes(
        &mut self,
        runes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_RuneData<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RuneTable_PackedRuneData::VT_RUNES,
            runes,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RuneTable_PackedRuneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RuneTable_PackedRuneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RuneTable_PackedRuneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RuneTable_PackedRuneData");
        ds.field("id", &self.id());
        ds.field("points", &self.points());
        ds.field("mutexGroupKey", &self.mutexGroupKey());
        ds.field("description", &self.description());
        ds.field("runes", &self.runes());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RuneTable_PackedRuneDataT {
    pub id: Option<String>,
    pub points: f32,
    pub mutexGroupKey: Option<String>,
    pub description: Option<String>,
    pub runes: Option<Vec<clz_Torappu_RuneDataT>>,
}
impl Default for clz_Torappu_RuneTable_PackedRuneDataT {
    fn default() -> Self {
        Self {
            id: None,
            points: 0.0,
            mutexGroupKey: None,
            description: None,
            runes: None,
        }
    }
}
impl clz_Torappu_RuneTable_PackedRuneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'b>> {
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        let points = self.points;
        let mutexGroupKey = self.mutexGroupKey.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let runes = self.runes.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_RuneTable_PackedRuneData::create(
            _fbb,
            &clz_Torappu_RuneTable_PackedRuneDataArgs {
                id,
                points,
                mutexGroupKey,
                description,
                runes,
            },
        )
    }
}
pub enum clz_Torappu_Act17sideData_TechTreeBranchDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_TechTreeBranchData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_TechTreeBranchData<'a> {
    type Inner = clz_Torappu_Act17sideData_TechTreeBranchData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_TechTreeBranchData<'a> {
    pub const VT_TECHTREEBRANCHID: flatbuffers::VOffsetT = 4;
    pub const VT_TECHTREEID: flatbuffers::VOffsetT = 6;
    pub const VT_TECHTREEBRANCHNAME: flatbuffers::VOffsetT = 8;
    pub const VT_TECHTREEBRANCHICON: flatbuffers::VOffsetT = 10;
    pub const VT_TECHTREEBRANCHDESC: flatbuffers::VOffsetT = 12;
    pub const VT_RUNEDATA: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_TechTreeBranchData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_TechTreeBranchDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechTreeBranchData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_TechTreeBranchDataBuilder::new(_fbb);
        if let Some(x) = args.runeData {
            builder.add_runeData(x);
        }
        if let Some(x) = args.techTreeBranchDesc {
            builder.add_techTreeBranchDesc(x);
        }
        if let Some(x) = args.techTreeBranchIcon {
            builder.add_techTreeBranchIcon(x);
        }
        if let Some(x) = args.techTreeBranchName {
            builder.add_techTreeBranchName(x);
        }
        if let Some(x) = args.techTreeId {
            builder.add_techTreeId(x);
        }
        if let Some(x) = args.techTreeBranchId {
            builder.add_techTreeBranchId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_TechTreeBranchDataT {
        let techTreeBranchId = self.techTreeBranchId().map(|x| x.to_string());
        let techTreeId = self.techTreeId().map(|x| x.to_string());
        let techTreeBranchName = self.techTreeBranchName().map(|x| x.to_string());
        let techTreeBranchIcon = self.techTreeBranchIcon().map(|x| x.to_string());
        let techTreeBranchDesc = self.techTreeBranchDesc().map(|x| x.to_string());
        let runeData = self.runeData().map(|x| Box::new(x.unpack()));
        clz_Torappu_Act17sideData_TechTreeBranchDataT {
            techTreeBranchId,
            techTreeId,
            techTreeBranchName,
            techTreeBranchIcon,
            techTreeBranchDesc,
            runeData,
        }
    }

    #[inline]
    pub fn techTreeBranchId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechTreeBranchData::VT_TECHTREEBRANCHID,
                None,
            )
        }
    }
    #[inline]
    pub fn techTreeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechTreeBranchData::VT_TECHTREEID,
                None,
            )
        }
    }
    #[inline]
    pub fn techTreeBranchName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechTreeBranchData::VT_TECHTREEBRANCHNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn techTreeBranchIcon(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechTreeBranchData::VT_TECHTREEBRANCHICON,
                None,
            )
        }
    }
    #[inline]
    pub fn techTreeBranchDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_TechTreeBranchData::VT_TECHTREEBRANCHDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn runeData(&self) -> Option<clz_Torappu_RuneTable_PackedRuneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                    clz_Torappu_Act17sideData_TechTreeBranchData::VT_RUNEDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_TechTreeBranchData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "techTreeBranchId",
                Self::VT_TECHTREEBRANCHID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "techTreeId",
                Self::VT_TECHTREEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "techTreeBranchName",
                Self::VT_TECHTREEBRANCHNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "techTreeBranchIcon",
                Self::VT_TECHTREEBRANCHICON,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "techTreeBranchDesc",
                Self::VT_TECHTREEBRANCHDESC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                "runeData",
                Self::VT_RUNEDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_TechTreeBranchDataArgs<'a> {
    pub techTreeBranchId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub techTreeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub techTreeBranchName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub techTreeBranchIcon: Option<flatbuffers::WIPOffset<&'a str>>,
    pub techTreeBranchDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub runeData: Option<flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'a>>>,
}
impl<'a> Default for clz_Torappu_Act17sideData_TechTreeBranchDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_TechTreeBranchDataArgs {
            techTreeBranchId: None,
            techTreeId: None,
            techTreeBranchName: None,
            techTreeBranchIcon: None,
            techTreeBranchDesc: None,
            runeData: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_TechTreeBranchData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Act17sideData_TechTreeBranchData", 6)?;
        if let Some(f) = self.techTreeBranchId() {
            s.serialize_field("techTreeBranchId", &f)?;
        } else {
            s.skip_field("techTreeBranchId")?;
        }
        if let Some(f) = self.techTreeId() {
            s.serialize_field("techTreeId", &f)?;
        } else {
            s.skip_field("techTreeId")?;
        }
        if let Some(f) = self.techTreeBranchName() {
            s.serialize_field("techTreeBranchName", &f)?;
        } else {
            s.skip_field("techTreeBranchName")?;
        }
        if let Some(f) = self.techTreeBranchIcon() {
            s.serialize_field("techTreeBranchIcon", &f)?;
        } else {
            s.skip_field("techTreeBranchIcon")?;
        }
        if let Some(f) = self.techTreeBranchDesc() {
            s.serialize_field("techTreeBranchDesc", &f)?;
        } else {
            s.skip_field("techTreeBranchDesc")?;
        }
        if let Some(f) = self.runeData() {
            s.serialize_field("runeData", &f)?;
        } else {
            s.skip_field("runeData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_TechTreeBranchDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_TechTreeBranchDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_techTreeBranchId(&mut self, techTreeBranchId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechTreeBranchData::VT_TECHTREEBRANCHID,
            techTreeBranchId,
        );
    }
    #[inline]
    pub fn add_techTreeId(&mut self, techTreeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechTreeBranchData::VT_TECHTREEID,
            techTreeId,
        );
    }
    #[inline]
    pub fn add_techTreeBranchName(&mut self, techTreeBranchName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechTreeBranchData::VT_TECHTREEBRANCHNAME,
            techTreeBranchName,
        );
    }
    #[inline]
    pub fn add_techTreeBranchIcon(&mut self, techTreeBranchIcon: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechTreeBranchData::VT_TECHTREEBRANCHICON,
            techTreeBranchIcon,
        );
    }
    #[inline]
    pub fn add_techTreeBranchDesc(&mut self, techTreeBranchDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_TechTreeBranchData::VT_TECHTREEBRANCHDESC,
            techTreeBranchDesc,
        );
    }
    #[inline]
    pub fn add_runeData(
        &mut self,
        runeData: flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                clz_Torappu_Act17sideData_TechTreeBranchData::VT_RUNEDATA,
                runeData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_TechTreeBranchDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_TechTreeBranchDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechTreeBranchData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_TechTreeBranchData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_TechTreeBranchData");
        ds.field("techTreeBranchId", &self.techTreeBranchId());
        ds.field("techTreeId", &self.techTreeId());
        ds.field("techTreeBranchName", &self.techTreeBranchName());
        ds.field("techTreeBranchIcon", &self.techTreeBranchIcon());
        ds.field("techTreeBranchDesc", &self.techTreeBranchDesc());
        ds.field("runeData", &self.runeData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_TechTreeBranchDataT {
    pub techTreeBranchId: Option<String>,
    pub techTreeId: Option<String>,
    pub techTreeBranchName: Option<String>,
    pub techTreeBranchIcon: Option<String>,
    pub techTreeBranchDesc: Option<String>,
    pub runeData: Option<Box<clz_Torappu_RuneTable_PackedRuneDataT>>,
}
impl Default for clz_Torappu_Act17sideData_TechTreeBranchDataT {
    fn default() -> Self {
        Self {
            techTreeBranchId: None,
            techTreeId: None,
            techTreeBranchName: None,
            techTreeBranchIcon: None,
            techTreeBranchDesc: None,
            runeData: None,
        }
    }
}
impl clz_Torappu_Act17sideData_TechTreeBranchDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechTreeBranchData<'b>> {
        let techTreeBranchId = self
            .techTreeBranchId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let techTreeId = self.techTreeId.as_ref().map(|x| _fbb.create_string(x));
        let techTreeBranchName = self
            .techTreeBranchName
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let techTreeBranchIcon = self
            .techTreeBranchIcon
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let techTreeBranchDesc = self
            .techTreeBranchDesc
            .as_ref()
            .map(|x| _fbb.create_string(x));
        let runeData = self.runeData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_Act17sideData_TechTreeBranchData::create(
            _fbb,
            &clz_Torappu_Act17sideData_TechTreeBranchDataArgs {
                techTreeBranchId,
                techTreeId,
                techTreeBranchName,
                techTreeBranchIcon,
                techTreeBranchDesc,
                runeData,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData_TechTreeBranchData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_Act17sideData_TechTreeBranchData<'a>
{
    type Inner = dict__string__clz_Torappu_Act17sideData_TechTreeBranchData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData_TechTreeBranchData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData_TechTreeBranchData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_TechTreeBranchData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData_TechTreeBranchData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act17sideData_TechTreeBranchData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData_TechTreeBranchData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_TechTreeBranchData>>(
                    dict__string__clz_Torappu_Act17sideData_TechTreeBranchData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData_TechTreeBranchData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_TechTreeBranchData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechTreeBranchData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData_TechTreeBranchData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_Act17sideData_TechTreeBranchData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData_TechTreeBranchData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechTreeBranchData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_TechTreeBranchData>>(dict__string__clz_Torappu_Act17sideData_TechTreeBranchData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_TechTreeBranchData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act17sideData_TechTreeBranchData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData_TechTreeBranchData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act17sideData_TechTreeBranchData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideData_TechTreeBranchDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_TechTreeBranchData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData_TechTreeBranchData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act17sideData_MainlineChapterDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_MainlineChapterData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_MainlineChapterData<'a> {
    type Inner = clz_Torappu_Act17sideData_MainlineChapterData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_MainlineChapterData<'a> {
    pub const VT_CHAPTERID: flatbuffers::VOffsetT = 4;
    pub const VT_CHAPTERDES: flatbuffers::VOffsetT = 6;
    pub const VT_CHAPTERICON: flatbuffers::VOffsetT = 8;
    pub const VT_UNLOCKDES: flatbuffers::VOffsetT = 10;
    pub const VT_ID: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_MainlineChapterData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_MainlineChapterDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_MainlineChapterData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_MainlineChapterDataBuilder::new(_fbb);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        if let Some(x) = args.unlockDes {
            builder.add_unlockDes(x);
        }
        builder.add_chapterIcon(args.chapterIcon);
        if let Some(x) = args.chapterDes {
            builder.add_chapterDes(x);
        }
        if let Some(x) = args.chapterId {
            builder.add_chapterId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_MainlineChapterDataT {
        let chapterId = self.chapterId().map(|x| x.to_string());
        let chapterDes = self.chapterDes().map(|x| x.to_string());
        let chapterIcon = self.chapterIcon();
        let unlockDes = self.unlockDes().map(|x| x.to_string());
        let id = self.id().map(|x| x.to_string());
        clz_Torappu_Act17sideData_MainlineChapterDataT {
            chapterId,
            chapterDes,
            chapterIcon,
            unlockDes,
            id,
        }
    }

    #[inline]
    pub fn chapterId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_MainlineChapterData::VT_CHAPTERID,
                None,
            )
        }
    }
    #[inline]
    pub fn chapterDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_MainlineChapterData::VT_CHAPTERDES,
                None,
            )
        }
    }
    #[inline]
    pub fn chapterIcon(&self) -> enum__Torappu_Act17sideData_ChapterIconType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Act17sideData_ChapterIconType>(
                    clz_Torappu_Act17sideData_MainlineChapterData::VT_CHAPTERICON,
                    Some(enum__Torappu_Act17sideData_ChapterIconType::NORMAL),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_MainlineChapterData::VT_UNLOCKDES,
                None,
            )
        }
    }
    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_MainlineChapterData::VT_ID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_MainlineChapterData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "chapterId",
                Self::VT_CHAPTERID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "chapterDes",
                Self::VT_CHAPTERDES,
                false,
            )?
            .visit_field::<enum__Torappu_Act17sideData_ChapterIconType>(
                "chapterIcon",
                Self::VT_CHAPTERICON,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockDes",
                Self::VT_UNLOCKDES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_MainlineChapterDataArgs<'a> {
    pub chapterId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub chapterDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub chapterIcon: enum__Torappu_Act17sideData_ChapterIconType,
    pub unlockDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Act17sideData_MainlineChapterDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_MainlineChapterDataArgs {
            chapterId: None,
            chapterDes: None,
            chapterIcon: enum__Torappu_Act17sideData_ChapterIconType::NORMAL,
            unlockDes: None,
            id: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_MainlineChapterData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Act17sideData_MainlineChapterData", 5)?;
        if let Some(f) = self.chapterId() {
            s.serialize_field("chapterId", &f)?;
        } else {
            s.skip_field("chapterId")?;
        }
        if let Some(f) = self.chapterDes() {
            s.serialize_field("chapterDes", &f)?;
        } else {
            s.skip_field("chapterDes")?;
        }
        s.serialize_field("chapterIcon", &self.chapterIcon())?;
        if let Some(f) = self.unlockDes() {
            s.serialize_field("unlockDes", &f)?;
        } else {
            s.skip_field("unlockDes")?;
        }
        if let Some(f) = self.id() {
            s.serialize_field("id", &f)?;
        } else {
            s.skip_field("id")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_MainlineChapterDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_MainlineChapterDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_chapterId(&mut self, chapterId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_MainlineChapterData::VT_CHAPTERID,
            chapterId,
        );
    }
    #[inline]
    pub fn add_chapterDes(&mut self, chapterDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_MainlineChapterData::VT_CHAPTERDES,
            chapterDes,
        );
    }
    #[inline]
    pub fn add_chapterIcon(&mut self, chapterIcon: enum__Torappu_Act17sideData_ChapterIconType) {
        self.fbb_
            .push_slot::<enum__Torappu_Act17sideData_ChapterIconType>(
                clz_Torappu_Act17sideData_MainlineChapterData::VT_CHAPTERICON,
                chapterIcon,
                enum__Torappu_Act17sideData_ChapterIconType::NORMAL,
            );
    }
    #[inline]
    pub fn add_unlockDes(&mut self, unlockDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_MainlineChapterData::VT_UNLOCKDES,
            unlockDes,
        );
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_MainlineChapterData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_MainlineChapterDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_MainlineChapterDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_MainlineChapterData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_MainlineChapterData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_MainlineChapterData");
        ds.field("chapterId", &self.chapterId());
        ds.field("chapterDes", &self.chapterDes());
        ds.field("chapterIcon", &self.chapterIcon());
        ds.field("unlockDes", &self.unlockDes());
        ds.field("id", &self.id());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_MainlineChapterDataT {
    pub chapterId: Option<String>,
    pub chapterDes: Option<String>,
    pub chapterIcon: enum__Torappu_Act17sideData_ChapterIconType,
    pub unlockDes: Option<String>,
    pub id: Option<String>,
}
impl Default for clz_Torappu_Act17sideData_MainlineChapterDataT {
    fn default() -> Self {
        Self {
            chapterId: None,
            chapterDes: None,
            chapterIcon: enum__Torappu_Act17sideData_ChapterIconType::NORMAL,
            unlockDes: None,
            id: None,
        }
    }
}
impl clz_Torappu_Act17sideData_MainlineChapterDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_MainlineChapterData<'b>> {
        let chapterId = self.chapterId.as_ref().map(|x| _fbb.create_string(x));
        let chapterDes = self.chapterDes.as_ref().map(|x| _fbb.create_string(x));
        let chapterIcon = self.chapterIcon;
        let unlockDes = self.unlockDes.as_ref().map(|x| _fbb.create_string(x));
        let id = self.id.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Act17sideData_MainlineChapterData::create(
            _fbb,
            &clz_Torappu_Act17sideData_MainlineChapterDataArgs {
                chapterId,
                chapterDes,
                chapterIcon,
                unlockDes,
                id,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideData_MainlineChapterDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData_MainlineChapterData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_Act17sideData_MainlineChapterData<'a>
{
    type Inner = dict__string__clz_Torappu_Act17sideData_MainlineChapterData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData_MainlineChapterData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData_MainlineChapterData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideData_MainlineChapterDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_MainlineChapterData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_Act17sideData_MainlineChapterDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideData_MainlineChapterDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideData_MainlineChapterDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData_MainlineChapterData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act17sideData_MainlineChapterData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData_MainlineChapterData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_MainlineChapterData>>(
                    dict__string__clz_Torappu_Act17sideData_MainlineChapterData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData_MainlineChapterData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_MainlineChapterData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideData_MainlineChapterDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_MainlineChapterData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideData_MainlineChapterDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideData_MainlineChapterDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData_MainlineChapterData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_Act17sideData_MainlineChapterData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideData_MainlineChapterDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideData_MainlineChapterDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData_MainlineChapterData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_MainlineChapterData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_MainlineChapterData>>(dict__string__clz_Torappu_Act17sideData_MainlineChapterData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideData_MainlineChapterDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideData_MainlineChapterDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_MainlineChapterData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act17sideData_MainlineChapterData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData_MainlineChapterData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act17sideData_MainlineChapterData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideData_MainlineChapterDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideData_MainlineChapterDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideData_MainlineChapterDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideData_MainlineChapterDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_MainlineChapterData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData_MainlineChapterData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideData_MainlineChapterDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act17sideData_MainlineDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_MainlineData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_MainlineData<'a> {
    type Inner = clz_Torappu_Act17sideData_MainlineData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_MainlineData<'a> {
    pub const VT_MAINLINEID: flatbuffers::VOffsetT = 4;
    pub const VT_NODEID: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;
    pub const VT_MISSIONSORT: flatbuffers::VOffsetT = 10;
    pub const VT_ZONEID: flatbuffers::VOffsetT = 12;
    pub const VT_MAINLINEDES: flatbuffers::VOffsetT = 14;
    pub const VT_FOCUSNODEID: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_MainlineData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_MainlineDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_MainlineData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_MainlineDataBuilder::new(_fbb);
        if let Some(x) = args.focusNodeId {
            builder.add_focusNodeId(x);
        }
        if let Some(x) = args.mainlineDes {
            builder.add_mainlineDes(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        if let Some(x) = args.missionSort {
            builder.add_missionSort(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.nodeId {
            builder.add_nodeId(x);
        }
        if let Some(x) = args.mainlineId {
            builder.add_mainlineId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_MainlineDataT {
        let mainlineId = self.mainlineId().map(|x| x.to_string());
        let nodeId = self.nodeId().map(|x| x.to_string());
        let sortId = self.sortId();
        let missionSort = self.missionSort().map(|x| x.to_string());
        let zoneId = self.zoneId().map(|x| x.to_string());
        let mainlineDes = self.mainlineDes().map(|x| x.to_string());
        let focusNodeId = self.focusNodeId().map(|x| x.to_string());
        clz_Torappu_Act17sideData_MainlineDataT {
            mainlineId,
            nodeId,
            sortId,
            missionSort,
            zoneId,
            mainlineDes,
            focusNodeId,
        }
    }

    #[inline]
    pub fn mainlineId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_MainlineData::VT_MAINLINEID,
                None,
            )
        }
    }
    #[inline]
    pub fn nodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_MainlineData::VT_NODEID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_Act17sideData_MainlineData::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn missionSort(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_MainlineData::VT_MISSIONSORT,
                None,
            )
        }
    }
    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_MainlineData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn mainlineDes(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_MainlineData::VT_MAINLINEDES,
                None,
            )
        }
    }
    #[inline]
    pub fn focusNodeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_MainlineData::VT_FOCUSNODEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_MainlineData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mainlineId",
                Self::VT_MAINLINEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nodeId", Self::VT_NODEID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "missionSort",
                Self::VT_MISSIONSORT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "mainlineDes",
                Self::VT_MAINLINEDES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "focusNodeId",
                Self::VT_FOCUSNODEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_MainlineDataArgs<'a> {
    pub mainlineId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nodeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub missionSort: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub mainlineDes: Option<flatbuffers::WIPOffset<&'a str>>,
    pub focusNodeId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Act17sideData_MainlineDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_MainlineDataArgs {
            mainlineId: None,
            nodeId: None,
            sortId: 0,
            missionSort: None,
            zoneId: None,
            mainlineDes: None,
            focusNodeId: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_MainlineData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act17sideData_MainlineData", 7)?;
        if let Some(f) = self.mainlineId() {
            s.serialize_field("mainlineId", &f)?;
        } else {
            s.skip_field("mainlineId")?;
        }
        if let Some(f) = self.nodeId() {
            s.serialize_field("nodeId", &f)?;
        } else {
            s.skip_field("nodeId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.missionSort() {
            s.serialize_field("missionSort", &f)?;
        } else {
            s.skip_field("missionSort")?;
        }
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.mainlineDes() {
            s.serialize_field("mainlineDes", &f)?;
        } else {
            s.skip_field("mainlineDes")?;
        }
        if let Some(f) = self.focusNodeId() {
            s.serialize_field("focusNodeId", &f)?;
        } else {
            s.skip_field("focusNodeId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_MainlineDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_MainlineDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_mainlineId(&mut self, mainlineId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_MainlineData::VT_MAINLINEID,
            mainlineId,
        );
    }
    #[inline]
    pub fn add_nodeId(&mut self, nodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_MainlineData::VT_NODEID,
            nodeId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_Act17sideData_MainlineData::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_missionSort(&mut self, missionSort: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_MainlineData::VT_MISSIONSORT,
            missionSort,
        );
    }
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_MainlineData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_mainlineDes(&mut self, mainlineDes: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_MainlineData::VT_MAINLINEDES,
            mainlineDes,
        );
    }
    #[inline]
    pub fn add_focusNodeId(&mut self, focusNodeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_MainlineData::VT_FOCUSNODEID,
            focusNodeId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_MainlineDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_MainlineDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_MainlineData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_MainlineData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_MainlineData");
        ds.field("mainlineId", &self.mainlineId());
        ds.field("nodeId", &self.nodeId());
        ds.field("sortId", &self.sortId());
        ds.field("missionSort", &self.missionSort());
        ds.field("zoneId", &self.zoneId());
        ds.field("mainlineDes", &self.mainlineDes());
        ds.field("focusNodeId", &self.focusNodeId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_MainlineDataT {
    pub mainlineId: Option<String>,
    pub nodeId: Option<String>,
    pub sortId: i32,
    pub missionSort: Option<String>,
    pub zoneId: Option<String>,
    pub mainlineDes: Option<String>,
    pub focusNodeId: Option<String>,
}
impl Default for clz_Torappu_Act17sideData_MainlineDataT {
    fn default() -> Self {
        Self {
            mainlineId: None,
            nodeId: None,
            sortId: 0,
            missionSort: None,
            zoneId: None,
            mainlineDes: None,
            focusNodeId: None,
        }
    }
}
impl clz_Torappu_Act17sideData_MainlineDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_MainlineData<'b>> {
        let mainlineId = self.mainlineId.as_ref().map(|x| _fbb.create_string(x));
        let nodeId = self.nodeId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let missionSort = self.missionSort.as_ref().map(|x| _fbb.create_string(x));
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let mainlineDes = self.mainlineDes.as_ref().map(|x| _fbb.create_string(x));
        let focusNodeId = self.focusNodeId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Act17sideData_MainlineData::create(
            _fbb,
            &clz_Torappu_Act17sideData_MainlineDataArgs {
                mainlineId,
                nodeId,
                sortId,
                missionSort,
                zoneId,
                mainlineDes,
                focusNodeId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideData_MainlineDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData_MainlineData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act17sideData_MainlineData<'a> {
    type Inner = dict__string__clz_Torappu_Act17sideData_MainlineData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData_MainlineData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData_MainlineData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideData_MainlineDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_MainlineData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_Act17sideData_MainlineDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideData_MainlineDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideData_MainlineDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData_MainlineData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act17sideData_MainlineData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData_MainlineData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_MainlineData>>(
                    dict__string__clz_Torappu_Act17sideData_MainlineData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData_MainlineData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_MainlineData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideData_MainlineDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_MainlineData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideData_MainlineDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideData_MainlineDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData_MainlineData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_Act17sideData_MainlineData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideData_MainlineDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideData_MainlineDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData_MainlineData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_MainlineData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_MainlineData>>(
                dict__string__clz_Torappu_Act17sideData_MainlineData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideData_MainlineDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideData_MainlineDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_MainlineData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act17sideData_MainlineData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData_MainlineData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act17sideData_MainlineData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideData_MainlineDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideData_MainlineDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideData_MainlineDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideData_MainlineDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData_MainlineData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData_MainlineData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideData_MainlineDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act17sideData_ZoneDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_ZoneData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_ZoneData<'a> {
    type Inner = clz_Torappu_Act17sideData_ZoneData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_ZoneData<'a> {
    pub const VT_ZONEID: flatbuffers::VOffsetT = 4;
    pub const VT_UNLOCKPLACEID: flatbuffers::VOffsetT = 6;
    pub const VT_UNLOCKTEXT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_ZoneData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_ZoneDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ZoneData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_ZoneDataBuilder::new(_fbb);
        if let Some(x) = args.unlockText {
            builder.add_unlockText(x);
        }
        if let Some(x) = args.unlockPlaceId {
            builder.add_unlockPlaceId(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_ZoneDataT {
        let zoneId = self.zoneId().map(|x| x.to_string());
        let unlockPlaceId = self.unlockPlaceId().map(|x| x.to_string());
        let unlockText = self.unlockText().map(|x| x.to_string());
        clz_Torappu_Act17sideData_ZoneDataT {
            zoneId,
            unlockPlaceId,
            unlockText,
        }
    }

    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ZoneData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockPlaceId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ZoneData::VT_UNLOCKPLACEID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ZoneData::VT_UNLOCKTEXT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_ZoneData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockPlaceId",
                Self::VT_UNLOCKPLACEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockText",
                Self::VT_UNLOCKTEXT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_ZoneDataArgs<'a> {
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockPlaceId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockText: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Act17sideData_ZoneDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_ZoneDataArgs {
            zoneId: None,
            unlockPlaceId: None,
            unlockText: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_ZoneData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act17sideData_ZoneData", 3)?;
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.unlockPlaceId() {
            s.serialize_field("unlockPlaceId", &f)?;
        } else {
            s.skip_field("unlockPlaceId")?;
        }
        if let Some(f) = self.unlockText() {
            s.serialize_field("unlockText", &f)?;
        } else {
            s.skip_field("unlockText")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_ZoneDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_ZoneDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ZoneData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_unlockPlaceId(&mut self, unlockPlaceId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ZoneData::VT_UNLOCKPLACEID,
            unlockPlaceId,
        );
    }
    #[inline]
    pub fn add_unlockText(&mut self, unlockText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ZoneData::VT_UNLOCKTEXT,
            unlockText,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_ZoneDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_ZoneDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ZoneData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_ZoneData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_ZoneData");
        ds.field("zoneId", &self.zoneId());
        ds.field("unlockPlaceId", &self.unlockPlaceId());
        ds.field("unlockText", &self.unlockText());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_ZoneDataT {
    pub zoneId: Option<String>,
    pub unlockPlaceId: Option<String>,
    pub unlockText: Option<String>,
}
impl Default for clz_Torappu_Act17sideData_ZoneDataT {
    fn default() -> Self {
        Self {
            zoneId: None,
            unlockPlaceId: None,
            unlockText: None,
        }
    }
}
impl clz_Torappu_Act17sideData_ZoneDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ZoneData<'b>> {
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let unlockPlaceId = self.unlockPlaceId.as_ref().map(|x| _fbb.create_string(x));
        let unlockText = self.unlockText.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Act17sideData_ZoneData::create(
            _fbb,
            &clz_Torappu_Act17sideData_ZoneDataArgs {
                zoneId,
                unlockPlaceId,
                unlockText,
            },
        )
    }
}
pub enum clz_Torappu_Act17sideData_ConstDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData_ConstData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData_ConstData<'a> {
    type Inner = clz_Torappu_Act17sideData_ConstData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData_ConstData<'a> {
    pub const VT_TECHTREEUNLOCKEVENTID: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData_ConstData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideData_ConstDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ConstData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideData_ConstDataBuilder::new(_fbb);
        if let Some(x) = args.techTreeUnlockEventId {
            builder.add_techTreeUnlockEventId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideData_ConstDataT {
        let techTreeUnlockEventId = self.techTreeUnlockEventId().map(|x| x.to_string());
        clz_Torappu_Act17sideData_ConstDataT {
            techTreeUnlockEventId,
        }
    }

    #[inline]
    pub fn techTreeUnlockEventId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act17sideData_ConstData::VT_TECHTREEUNLOCKEVENTID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData_ConstData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "techTreeUnlockEventId",
                Self::VT_TECHTREEUNLOCKEVENTID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideData_ConstDataArgs<'a> {
    pub techTreeUnlockEventId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Act17sideData_ConstDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideData_ConstDataArgs {
            techTreeUnlockEventId: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData_ConstData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act17sideData_ConstData", 1)?;
        if let Some(f) = self.techTreeUnlockEventId() {
            s.serialize_field("techTreeUnlockEventId", &f)?;
        } else {
            s.skip_field("techTreeUnlockEventId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideData_ConstDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act17sideData_ConstDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_techTreeUnlockEventId(
        &mut self,
        techTreeUnlockEventId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData_ConstData::VT_TECHTREEUNLOCKEVENTID,
            techTreeUnlockEventId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideData_ConstDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideData_ConstDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ConstData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData_ConstData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData_ConstData");
        ds.field("techTreeUnlockEventId", &self.techTreeUnlockEventId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideData_ConstDataT {
    pub techTreeUnlockEventId: Option<String>,
}
impl Default for clz_Torappu_Act17sideData_ConstDataT {
    fn default() -> Self {
        Self {
            techTreeUnlockEventId: None,
        }
    }
}
impl clz_Torappu_Act17sideData_ConstDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ConstData<'b>> {
        let techTreeUnlockEventId = self
            .techTreeUnlockEventId
            .as_ref()
            .map(|x| _fbb.create_string(x));
        clz_Torappu_Act17sideData_ConstData::create(
            _fbb,
            &clz_Torappu_Act17sideData_ConstDataArgs {
                techTreeUnlockEventId,
            },
        )
    }
}
pub enum clz_Torappu_Act17sideDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act17sideData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act17sideData<'a> {
    type Inner = clz_Torappu_Act17sideData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act17sideData<'a> {
    pub const VT_PLACEDATAMAP: flatbuffers::VOffsetT = 4;
    pub const VT_NODEINFODATAMAP: flatbuffers::VOffsetT = 6;
    pub const VT_LANDMARKNODEDATAMAP: flatbuffers::VOffsetT = 8;
    pub const VT_STORYNODEDATAMAP: flatbuffers::VOffsetT = 10;
    pub const VT_BATTLENODEDATAMAP: flatbuffers::VOffsetT = 12;
    pub const VT_TREASURENODEDATAMAP: flatbuffers::VOffsetT = 14;
    pub const VT_EVENTNODEDATAMAP: flatbuffers::VOffsetT = 16;
    pub const VT_TECHNODEDATAMAP: flatbuffers::VOffsetT = 18;
    pub const VT_CHOICENODEDATAMAP: flatbuffers::VOffsetT = 20;
    pub const VT_EVENTDATAMAP: flatbuffers::VOffsetT = 22;
    pub const VT_ARCHIVEITEMUNLOCKDATAMAP: flatbuffers::VOffsetT = 24;
    pub const VT_TECHTREEDATAMAP: flatbuffers::VOffsetT = 26;
    pub const VT_TECHTREEBRANCHDATAMAP: flatbuffers::VOffsetT = 28;
    pub const VT_MAINLINECHAPTERDATAMAP: flatbuffers::VOffsetT = 30;
    pub const VT_MAINLINEDATAMAP: flatbuffers::VOffsetT = 32;
    pub const VT_ZONEDATALIST: flatbuffers::VOffsetT = 34;
    pub const VT_CONSTDATA: flatbuffers::VOffsetT = 36;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act17sideData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act17sideDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData<'bldr>> {
        let mut builder = clz_Torappu_Act17sideDataBuilder::new(_fbb);
        if let Some(x) = args.constData {
            builder.add_constData(x);
        }
        if let Some(x) = args.zoneDataList {
            builder.add_zoneDataList(x);
        }
        if let Some(x) = args.mainlineDataMap {
            builder.add_mainlineDataMap(x);
        }
        if let Some(x) = args.mainlineChapterDataMap {
            builder.add_mainlineChapterDataMap(x);
        }
        if let Some(x) = args.techTreeBranchDataMap {
            builder.add_techTreeBranchDataMap(x);
        }
        if let Some(x) = args.techTreeDataMap {
            builder.add_techTreeDataMap(x);
        }
        if let Some(x) = args.archiveItemUnlockDataMap {
            builder.add_archiveItemUnlockDataMap(x);
        }
        if let Some(x) = args.eventDataMap {
            builder.add_eventDataMap(x);
        }
        if let Some(x) = args.choiceNodeDataMap {
            builder.add_choiceNodeDataMap(x);
        }
        if let Some(x) = args.techNodeDataMap {
            builder.add_techNodeDataMap(x);
        }
        if let Some(x) = args.eventNodeDataMap {
            builder.add_eventNodeDataMap(x);
        }
        if let Some(x) = args.treasureNodeDataMap {
            builder.add_treasureNodeDataMap(x);
        }
        if let Some(x) = args.battleNodeDataMap {
            builder.add_battleNodeDataMap(x);
        }
        if let Some(x) = args.storyNodeDataMap {
            builder.add_storyNodeDataMap(x);
        }
        if let Some(x) = args.landmarkNodeDataMap {
            builder.add_landmarkNodeDataMap(x);
        }
        if let Some(x) = args.nodeInfoDataMap {
            builder.add_nodeInfoDataMap(x);
        }
        if let Some(x) = args.placeDataMap {
            builder.add_placeDataMap(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act17sideDataT {
        let placeDataMap = self
            .placeDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let nodeInfoDataMap = self
            .nodeInfoDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let landmarkNodeDataMap = self
            .landmarkNodeDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let storyNodeDataMap = self
            .storyNodeDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let battleNodeDataMap = self
            .battleNodeDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let treasureNodeDataMap = self
            .treasureNodeDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let eventNodeDataMap = self
            .eventNodeDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let techNodeDataMap = self
            .techNodeDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let choiceNodeDataMap = self
            .choiceNodeDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let eventDataMap = self
            .eventDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let archiveItemUnlockDataMap = self
            .archiveItemUnlockDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let techTreeDataMap = self
            .techTreeDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let techTreeBranchDataMap = self
            .techTreeBranchDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let mainlineChapterDataMap = self
            .mainlineChapterDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let mainlineDataMap = self
            .mainlineDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let zoneDataList = self
            .zoneDataList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let constData = self.constData().map(|x| Box::new(x.unpack()));
        clz_Torappu_Act17sideDataT {
            placeDataMap,
            nodeInfoDataMap,
            landmarkNodeDataMap,
            storyNodeDataMap,
            battleNodeDataMap,
            treasureNodeDataMap,
            eventNodeDataMap,
            techNodeDataMap,
            choiceNodeDataMap,
            eventDataMap,
            archiveItemUnlockDataMap,
            techTreeDataMap,
            techTreeBranchDataMap,
            mainlineChapterDataMap,
            mainlineDataMap,
            zoneDataList,
            constData,
        }
    }

    #[inline]
    pub fn placeDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_PlaceData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_PlaceData>,
                >,
            >>(clz_Torappu_Act17sideData::VT_PLACEDATAMAP, None)
        }
    }
    #[inline]
    pub fn nodeInfoDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_NodeInfoData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_NodeInfoData,
                    >,
                >,
            >>(clz_Torappu_Act17sideData::VT_NODEINFODATAMAP, None)
        }
    }
    #[inline]
    pub fn landmarkNodeDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_Act17sideData_LandmarkNodeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_LandmarkNodeData,
                    >,
                >,
            >>(clz_Torappu_Act17sideData::VT_LANDMARKNODEDATAMAP, None)
        }
    }
    #[inline]
    pub fn storyNodeDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_StoryNodeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_StoryNodeData,
                    >,
                >,
            >>(clz_Torappu_Act17sideData::VT_STORYNODEDATAMAP, None)
        }
    }
    #[inline]
    pub fn battleNodeDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_Act17sideData_BattleNodeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_BattleNodeData,
                    >,
                >,
            >>(clz_Torappu_Act17sideData::VT_BATTLENODEDATAMAP, None)
        }
    }
    #[inline]
    pub fn treasureNodeDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_Act17sideData_TreasureNodeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_TreasureNodeData,
                    >,
                >,
            >>(clz_Torappu_Act17sideData::VT_TREASURENODEDATAMAP, None)
        }
    }
    #[inline]
    pub fn eventNodeDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_EventNodeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_EventNodeData,
                    >,
                >,
            >>(clz_Torappu_Act17sideData::VT_EVENTNODEDATAMAP, None)
        }
    }
    #[inline]
    pub fn techNodeDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_TechNodeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_TechNodeData,
                    >,
                >,
            >>(clz_Torappu_Act17sideData::VT_TECHNODEDATAMAP, None)
        }
    }
    #[inline]
    pub fn choiceNodeDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_Act17sideData_ChoiceNodeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_ChoiceNodeData,
                    >,
                >,
            >>(clz_Torappu_Act17sideData::VT_CHOICENODEDATAMAP, None)
        }
    }
    #[inline]
    pub fn eventDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_EventData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_EventData>,
                >,
            >>(clz_Torappu_Act17sideData::VT_EVENTDATAMAP, None)
        }
    }
    #[inline]
    pub fn archiveItemUnlockDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData,
                    >,
                >,
            >>(clz_Torappu_Act17sideData::VT_ARCHIVEITEMUNLOCKDATAMAP, None)
        }
    }
    #[inline]
    pub fn techTreeDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_TechTreeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_TechTreeData,
                    >,
                >,
            >>(clz_Torappu_Act17sideData::VT_TECHTREEDATAMAP, None)
        }
    }
    #[inline]
    pub fn techTreeBranchDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_Act17sideData_TechTreeBranchData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_TechTreeBranchData,
                    >,
                >,
            >>(clz_Torappu_Act17sideData::VT_TECHTREEBRANCHDATAMAP, None)
        }
    }
    #[inline]
    pub fn mainlineChapterDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_Act17sideData_MainlineChapterData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_MainlineChapterData,
                    >,
                >,
            >>(clz_Torappu_Act17sideData::VT_MAINLINECHAPTERDATAMAP, None)
        }
    }
    #[inline]
    pub fn mainlineDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_MainlineData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_MainlineData,
                    >,
                >,
            >>(clz_Torappu_Act17sideData::VT_MAINLINEDATAMAP, None)
        }
    }
    #[inline]
    pub fn zoneDataList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ZoneData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ZoneData>,
                >,
            >>(clz_Torappu_Act17sideData::VT_ZONEDATALIST, None)
        }
    }
    #[inline]
    pub fn constData(&self) -> Option<clz_Torappu_Act17sideData_ConstData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ConstData>>(
                    clz_Torappu_Act17sideData::VT_CONSTDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act17sideData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_PlaceData>,
                >,
            >>("placeDataMap", Self::VT_PLACEDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_NodeInfoData,
                    >,
                >,
            >>("nodeInfoDataMap", Self::VT_NODEINFODATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_LandmarkNodeData,
                    >,
                >,
            >>("landmarkNodeDataMap", Self::VT_LANDMARKNODEDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_StoryNodeData,
                    >,
                >,
            >>("storyNodeDataMap", Self::VT_STORYNODEDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_BattleNodeData,
                    >,
                >,
            >>("battleNodeDataMap", Self::VT_BATTLENODEDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_TreasureNodeData,
                    >,
                >,
            >>("treasureNodeDataMap", Self::VT_TREASURENODEDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_EventNodeData,
                    >,
                >,
            >>("eventNodeDataMap", Self::VT_EVENTNODEDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_TechNodeData,
                    >,
                >,
            >>("techNodeDataMap", Self::VT_TECHNODEDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_ChoiceNodeData,
                    >,
                >,
            >>("choiceNodeDataMap", Self::VT_CHOICENODEDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_EventData>,
                >,
            >>("eventDataMap", Self::VT_EVENTDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData,
                    >,
                >,
            >>(
                "archiveItemUnlockDataMap",
                Self::VT_ARCHIVEITEMUNLOCKDATAMAP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_TechTreeData,
                    >,
                >,
            >>("techTreeDataMap", Self::VT_TECHTREEDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_TechTreeBranchData,
                    >,
                >,
            >>(
                "techTreeBranchDataMap",
                Self::VT_TECHTREEBRANCHDATAMAP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_MainlineChapterData,
                    >,
                >,
            >>(
                "mainlineChapterDataMap",
                Self::VT_MAINLINECHAPTERDATAMAP,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act17sideData_MainlineData,
                    >,
                >,
            >>("mainlineDataMap", Self::VT_MAINLINEDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ZoneData>,
                >,
            >>("zoneDataList", Self::VT_ZONEDATALIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ConstData>>(
                "constData",
                Self::VT_CONSTDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act17sideDataArgs<'a> {
    pub placeDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_PlaceData<'a>>,
            >,
        >,
    >,
    pub nodeInfoDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_NodeInfoData<'a>,
                >,
            >,
        >,
    >,
    pub landmarkNodeDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_LandmarkNodeData<'a>,
                >,
            >,
        >,
    >,
    pub storyNodeDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_StoryNodeData<'a>,
                >,
            >,
        >,
    >,
    pub battleNodeDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_BattleNodeData<'a>,
                >,
            >,
        >,
    >,
    pub treasureNodeDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_TreasureNodeData<'a>,
                >,
            >,
        >,
    >,
    pub eventNodeDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_EventNodeData<'a>,
                >,
            >,
        >,
    >,
    pub techNodeDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_TechNodeData<'a>,
                >,
            >,
        >,
    >,
    pub choiceNodeDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_ChoiceNodeData<'a>,
                >,
            >,
        >,
    >,
    pub eventDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_EventData<'a>>,
            >,
        >,
    >,
    pub archiveItemUnlockDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData<'a>,
                >,
            >,
        >,
    >,
    pub techTreeDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_TechTreeData<'a>,
                >,
            >,
        >,
    >,
    pub techTreeBranchDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_TechTreeBranchData<'a>,
                >,
            >,
        >,
    >,
    pub mainlineChapterDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_MainlineChapterData<'a>,
                >,
            >,
        >,
    >,
    pub mainlineDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_MainlineData<'a>,
                >,
            >,
        >,
    >,
    pub zoneDataList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ZoneData<'a>>,
            >,
        >,
    >,
    pub constData: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ConstData<'a>>>,
}
impl<'a> Default for clz_Torappu_Act17sideDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act17sideDataArgs {
            placeDataMap: None,
            nodeInfoDataMap: None,
            landmarkNodeDataMap: None,
            storyNodeDataMap: None,
            battleNodeDataMap: None,
            treasureNodeDataMap: None,
            eventNodeDataMap: None,
            techNodeDataMap: None,
            choiceNodeDataMap: None,
            eventDataMap: None,
            archiveItemUnlockDataMap: None,
            techTreeDataMap: None,
            techTreeBranchDataMap: None,
            mainlineChapterDataMap: None,
            mainlineDataMap: None,
            zoneDataList: None,
            constData: None,
        }
    }
}

impl Serialize for clz_Torappu_Act17sideData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act17sideData", 17)?;
        if let Some(f) = self.placeDataMap() {
            s.serialize_field("placeDataMap", &f)?;
        } else {
            s.skip_field("placeDataMap")?;
        }
        if let Some(f) = self.nodeInfoDataMap() {
            s.serialize_field("nodeInfoDataMap", &f)?;
        } else {
            s.skip_field("nodeInfoDataMap")?;
        }
        if let Some(f) = self.landmarkNodeDataMap() {
            s.serialize_field("landmarkNodeDataMap", &f)?;
        } else {
            s.skip_field("landmarkNodeDataMap")?;
        }
        if let Some(f) = self.storyNodeDataMap() {
            s.serialize_field("storyNodeDataMap", &f)?;
        } else {
            s.skip_field("storyNodeDataMap")?;
        }
        if let Some(f) = self.battleNodeDataMap() {
            s.serialize_field("battleNodeDataMap", &f)?;
        } else {
            s.skip_field("battleNodeDataMap")?;
        }
        if let Some(f) = self.treasureNodeDataMap() {
            s.serialize_field("treasureNodeDataMap", &f)?;
        } else {
            s.skip_field("treasureNodeDataMap")?;
        }
        if let Some(f) = self.eventNodeDataMap() {
            s.serialize_field("eventNodeDataMap", &f)?;
        } else {
            s.skip_field("eventNodeDataMap")?;
        }
        if let Some(f) = self.techNodeDataMap() {
            s.serialize_field("techNodeDataMap", &f)?;
        } else {
            s.skip_field("techNodeDataMap")?;
        }
        if let Some(f) = self.choiceNodeDataMap() {
            s.serialize_field("choiceNodeDataMap", &f)?;
        } else {
            s.skip_field("choiceNodeDataMap")?;
        }
        if let Some(f) = self.eventDataMap() {
            s.serialize_field("eventDataMap", &f)?;
        } else {
            s.skip_field("eventDataMap")?;
        }
        if let Some(f) = self.archiveItemUnlockDataMap() {
            s.serialize_field("archiveItemUnlockDataMap", &f)?;
        } else {
            s.skip_field("archiveItemUnlockDataMap")?;
        }
        if let Some(f) = self.techTreeDataMap() {
            s.serialize_field("techTreeDataMap", &f)?;
        } else {
            s.skip_field("techTreeDataMap")?;
        }
        if let Some(f) = self.techTreeBranchDataMap() {
            s.serialize_field("techTreeBranchDataMap", &f)?;
        } else {
            s.skip_field("techTreeBranchDataMap")?;
        }
        if let Some(f) = self.mainlineChapterDataMap() {
            s.serialize_field("mainlineChapterDataMap", &f)?;
        } else {
            s.skip_field("mainlineChapterDataMap")?;
        }
        if let Some(f) = self.mainlineDataMap() {
            s.serialize_field("mainlineDataMap", &f)?;
        } else {
            s.skip_field("mainlineDataMap")?;
        }
        if let Some(f) = self.zoneDataList() {
            s.serialize_field("zoneDataList", &f)?;
        } else {
            s.skip_field("zoneDataList")?;
        }
        if let Some(f) = self.constData() {
            s.serialize_field("constData", &f)?;
        } else {
            s.skip_field("constData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act17sideDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Act17sideDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_placeDataMap(
        &mut self,
        placeDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_PlaceData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_PLACEDATAMAP,
            placeDataMap,
        );
    }
    #[inline]
    pub fn add_nodeInfoDataMap(
        &mut self,
        nodeInfoDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_NodeInfoData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_NODEINFODATAMAP,
            nodeInfoDataMap,
        );
    }
    #[inline]
    pub fn add_landmarkNodeDataMap(
        &mut self,
        landmarkNodeDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_LandmarkNodeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_LANDMARKNODEDATAMAP,
            landmarkNodeDataMap,
        );
    }
    #[inline]
    pub fn add_storyNodeDataMap(
        &mut self,
        storyNodeDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_StoryNodeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_STORYNODEDATAMAP,
            storyNodeDataMap,
        );
    }
    #[inline]
    pub fn add_battleNodeDataMap(
        &mut self,
        battleNodeDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_BattleNodeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_BATTLENODEDATAMAP,
            battleNodeDataMap,
        );
    }
    #[inline]
    pub fn add_treasureNodeDataMap(
        &mut self,
        treasureNodeDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_TreasureNodeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_TREASURENODEDATAMAP,
            treasureNodeDataMap,
        );
    }
    #[inline]
    pub fn add_eventNodeDataMap(
        &mut self,
        eventNodeDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_EventNodeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_EVENTNODEDATAMAP,
            eventNodeDataMap,
        );
    }
    #[inline]
    pub fn add_techNodeDataMap(
        &mut self,
        techNodeDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_TechNodeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_TECHNODEDATAMAP,
            techNodeDataMap,
        );
    }
    #[inline]
    pub fn add_choiceNodeDataMap(
        &mut self,
        choiceNodeDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_ChoiceNodeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_CHOICENODEDATAMAP,
            choiceNodeDataMap,
        );
    }
    #[inline]
    pub fn add_eventDataMap(
        &mut self,
        eventDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData_EventData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_EVENTDATAMAP,
            eventDataMap,
        );
    }
    #[inline]
    pub fn add_archiveItemUnlockDataMap(
        &mut self,
        archiveItemUnlockDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_ARCHIVEITEMUNLOCKDATAMAP,
            archiveItemUnlockDataMap,
        );
    }
    #[inline]
    pub fn add_techTreeDataMap(
        &mut self,
        techTreeDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_TechTreeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_TECHTREEDATAMAP,
            techTreeDataMap,
        );
    }
    #[inline]
    pub fn add_techTreeBranchDataMap(
        &mut self,
        techTreeBranchDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_TechTreeBranchData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_TECHTREEBRANCHDATAMAP,
            techTreeBranchDataMap,
        );
    }
    #[inline]
    pub fn add_mainlineChapterDataMap(
        &mut self,
        mainlineChapterDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_MainlineChapterData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_MAINLINECHAPTERDATAMAP,
            mainlineChapterDataMap,
        );
    }
    #[inline]
    pub fn add_mainlineDataMap(
        &mut self,
        mainlineDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act17sideData_MainlineData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_MAINLINEDATAMAP,
            mainlineDataMap,
        );
    }
    #[inline]
    pub fn add_zoneDataList(
        &mut self,
        zoneDataList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData_ZoneData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act17sideData::VT_ZONEDATALIST,
            zoneDataList,
        );
    }
    #[inline]
    pub fn add_constData(
        &mut self,
        constData: flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ConstData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData_ConstData>>(
                clz_Torappu_Act17sideData::VT_CONSTDATA,
                constData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act17sideDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act17sideDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act17sideData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act17sideData");
        ds.field("placeDataMap", &self.placeDataMap());
        ds.field("nodeInfoDataMap", &self.nodeInfoDataMap());
        ds.field("landmarkNodeDataMap", &self.landmarkNodeDataMap());
        ds.field("storyNodeDataMap", &self.storyNodeDataMap());
        ds.field("battleNodeDataMap", &self.battleNodeDataMap());
        ds.field("treasureNodeDataMap", &self.treasureNodeDataMap());
        ds.field("eventNodeDataMap", &self.eventNodeDataMap());
        ds.field("techNodeDataMap", &self.techNodeDataMap());
        ds.field("choiceNodeDataMap", &self.choiceNodeDataMap());
        ds.field("eventDataMap", &self.eventDataMap());
        ds.field("archiveItemUnlockDataMap", &self.archiveItemUnlockDataMap());
        ds.field("techTreeDataMap", &self.techTreeDataMap());
        ds.field("techTreeBranchDataMap", &self.techTreeBranchDataMap());
        ds.field("mainlineChapterDataMap", &self.mainlineChapterDataMap());
        ds.field("mainlineDataMap", &self.mainlineDataMap());
        ds.field("zoneDataList", &self.zoneDataList());
        ds.field("constData", &self.constData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act17sideDataT {
    pub placeDataMap: Option<Vec<dict__string__clz_Torappu_Act17sideData_PlaceDataT>>,
    pub nodeInfoDataMap: Option<Vec<dict__string__clz_Torappu_Act17sideData_NodeInfoDataT>>,
    pub landmarkNodeDataMap: Option<Vec<dict__string__clz_Torappu_Act17sideData_LandmarkNodeDataT>>,
    pub storyNodeDataMap: Option<Vec<dict__string__clz_Torappu_Act17sideData_StoryNodeDataT>>,
    pub battleNodeDataMap: Option<Vec<dict__string__clz_Torappu_Act17sideData_BattleNodeDataT>>,
    pub treasureNodeDataMap: Option<Vec<dict__string__clz_Torappu_Act17sideData_TreasureNodeDataT>>,
    pub eventNodeDataMap: Option<Vec<dict__string__clz_Torappu_Act17sideData_EventNodeDataT>>,
    pub techNodeDataMap: Option<Vec<dict__string__clz_Torappu_Act17sideData_TechNodeDataT>>,
    pub choiceNodeDataMap: Option<Vec<dict__string__clz_Torappu_Act17sideData_ChoiceNodeDataT>>,
    pub eventDataMap: Option<Vec<dict__string__clz_Torappu_Act17sideData_EventDataT>>,
    pub archiveItemUnlockDataMap:
        Option<Vec<dict__string__clz_Torappu_Act17sideData_ArchiveItemUnlockDataT>>,
    pub techTreeDataMap: Option<Vec<dict__string__clz_Torappu_Act17sideData_TechTreeDataT>>,
    pub techTreeBranchDataMap:
        Option<Vec<dict__string__clz_Torappu_Act17sideData_TechTreeBranchDataT>>,
    pub mainlineChapterDataMap:
        Option<Vec<dict__string__clz_Torappu_Act17sideData_MainlineChapterDataT>>,
    pub mainlineDataMap: Option<Vec<dict__string__clz_Torappu_Act17sideData_MainlineDataT>>,
    pub zoneDataList: Option<Vec<clz_Torappu_Act17sideData_ZoneDataT>>,
    pub constData: Option<Box<clz_Torappu_Act17sideData_ConstDataT>>,
}
impl Default for clz_Torappu_Act17sideDataT {
    fn default() -> Self {
        Self {
            placeDataMap: None,
            nodeInfoDataMap: None,
            landmarkNodeDataMap: None,
            storyNodeDataMap: None,
            battleNodeDataMap: None,
            treasureNodeDataMap: None,
            eventNodeDataMap: None,
            techNodeDataMap: None,
            choiceNodeDataMap: None,
            eventDataMap: None,
            archiveItemUnlockDataMap: None,
            techTreeDataMap: None,
            techTreeBranchDataMap: None,
            mainlineChapterDataMap: None,
            mainlineDataMap: None,
            zoneDataList: None,
            constData: None,
        }
    }
}
impl clz_Torappu_Act17sideDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act17sideData<'b>> {
        let placeDataMap = self.placeDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let nodeInfoDataMap = self.nodeInfoDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let landmarkNodeDataMap = self.landmarkNodeDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let storyNodeDataMap = self.storyNodeDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let battleNodeDataMap = self.battleNodeDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let treasureNodeDataMap = self.treasureNodeDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let eventNodeDataMap = self.eventNodeDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let techNodeDataMap = self.techNodeDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let choiceNodeDataMap = self.choiceNodeDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let eventDataMap = self.eventDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let archiveItemUnlockDataMap = self.archiveItemUnlockDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let techTreeDataMap = self.techTreeDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let techTreeBranchDataMap = self.techTreeBranchDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let mainlineChapterDataMap = self.mainlineChapterDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let mainlineDataMap = self.mainlineDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let zoneDataList = self.zoneDataList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let constData = self.constData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_Act17sideData::create(
            _fbb,
            &clz_Torappu_Act17sideDataArgs {
                placeDataMap,
                nodeInfoDataMap,
                landmarkNodeDataMap,
                storyNodeDataMap,
                battleNodeDataMap,
                treasureNodeDataMap,
                eventNodeDataMap,
                techNodeDataMap,
                choiceNodeDataMap,
                eventDataMap,
                archiveItemUnlockDataMap,
                techTreeDataMap,
                techTreeBranchDataMap,
                mainlineChapterDataMap,
                mainlineDataMap,
                zoneDataList,
                constData,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act17sideDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act17sideData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act17sideData<'a> {
    type Inner = dict__string__clz_Torappu_Act17sideData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act17sideData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act17sideData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act17sideDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_Act17sideDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act17sideDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act17sideDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act17sideData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_Act17sideData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act17sideData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData>>(
                    dict__string__clz_Torappu_Act17sideData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act17sideData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act17sideData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act17sideDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act17sideData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act17sideDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act17sideDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act17sideData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_Act17sideData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act17sideDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act17sideDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act17sideData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_Act17sideData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act17sideData>>(
                dict__string__clz_Torappu_Act17sideData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act17sideDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act17sideDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_Act17sideData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act17sideData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act17sideData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act17sideDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act17sideDataT>>,
}
impl Default for dict__string__clz_Torappu_Act17sideDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act17sideDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act17sideData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act17sideData::create(
            _fbb,
            &dict__string__clz_Torappu_Act17sideDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act25SideData_BattlePerformanceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act25SideData_BattlePerformanceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act25SideData_BattlePerformanceData<'a> {
    type Inner = clz_Torappu_Act25SideData_BattlePerformanceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act25SideData_BattlePerformanceData<'a> {
    pub const VT_ITEMID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_ITEMNAME: flatbuffers::VOffsetT = 8;
    pub const VT_ITEMICON: flatbuffers::VOffsetT = 10;
    pub const VT_ITEMDESC: flatbuffers::VOffsetT = 12;
    pub const VT_ITEMTECHTYPE: flatbuffers::VOffsetT = 14;
    pub const VT_RUNEDATA: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act25SideData_BattlePerformanceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act25SideData_BattlePerformanceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act25SideData_BattlePerformanceData<'bldr>> {
        let mut builder = clz_Torappu_Act25SideData_BattlePerformanceDataBuilder::new(_fbb);
        if let Some(x) = args.runeData {
            builder.add_runeData(x);
        }
        builder.add_itemTechType(args.itemTechType);
        if let Some(x) = args.itemDesc {
            builder.add_itemDesc(x);
        }
        if let Some(x) = args.itemIcon {
            builder.add_itemIcon(x);
        }
        if let Some(x) = args.itemName {
            builder.add_itemName(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act25SideData_BattlePerformanceDataT {
        let itemId = self.itemId().map(|x| x.to_string());
        let sortId = self.sortId();
        let itemName = self.itemName().map(|x| x.to_string());
        let itemIcon = self.itemIcon().map(|x| x.to_string());
        let itemDesc = self.itemDesc().map(|x| x.to_string());
        let itemTechType = self.itemTechType();
        let runeData = self.runeData().map(|x| Box::new(x.unpack()));
        clz_Torappu_Act25SideData_BattlePerformanceDataT {
            itemId,
            sortId,
            itemName,
            itemIcon,
            itemDesc,
            itemTechType,
            runeData,
        }
    }

    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act25SideData_BattlePerformanceData::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_Act25SideData_BattlePerformanceData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act25SideData_BattlePerformanceData::VT_ITEMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn itemIcon(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act25SideData_BattlePerformanceData::VT_ITEMICON,
                None,
            )
        }
    }
    #[inline]
    pub fn itemDesc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act25SideData_BattlePerformanceData::VT_ITEMDESC,
                None,
            )
        }
    }
    #[inline]
    pub fn itemTechType(&self) -> enum__Torappu_Act25SideData_Act25sideTechType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_Act25SideData_Act25sideTechType>(
                    clz_Torappu_Act25SideData_BattlePerformanceData::VT_ITEMTECHTYPE,
                    Some(enum__Torappu_Act25SideData_Act25sideTechType::TECH_1),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn runeData(&self) -> Option<clz_Torappu_RuneTable_PackedRuneData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                    clz_Torappu_Act25SideData_BattlePerformanceData::VT_RUNEDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act25SideData_BattlePerformanceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "itemName",
                Self::VT_ITEMNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "itemIcon",
                Self::VT_ITEMICON,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "itemDesc",
                Self::VT_ITEMDESC,
                false,
            )?
            .visit_field::<enum__Torappu_Act25SideData_Act25sideTechType>(
                "itemTechType",
                Self::VT_ITEMTECHTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                "runeData",
                Self::VT_RUNEDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act25SideData_BattlePerformanceDataArgs<'a> {
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub itemName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemIcon: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemDesc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemTechType: enum__Torappu_Act25SideData_Act25sideTechType,
    pub runeData: Option<flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'a>>>,
}
impl<'a> Default for clz_Torappu_Act25SideData_BattlePerformanceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act25SideData_BattlePerformanceDataArgs {
            itemId: None,
            sortId: 0,
            itemName: None,
            itemIcon: None,
            itemDesc: None,
            itemTechType: enum__Torappu_Act25SideData_Act25sideTechType::TECH_1,
            runeData: None,
        }
    }
}

impl Serialize for clz_Torappu_Act25SideData_BattlePerformanceData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_Act25SideData_BattlePerformanceData", 7)?;
        if let Some(f) = self.itemId() {
            s.serialize_field("itemId", &f)?;
        } else {
            s.skip_field("itemId")?;
        }
        s.serialize_field("sortId", &self.sortId())?;
        if let Some(f) = self.itemName() {
            s.serialize_field("itemName", &f)?;
        } else {
            s.skip_field("itemName")?;
        }
        if let Some(f) = self.itemIcon() {
            s.serialize_field("itemIcon", &f)?;
        } else {
            s.skip_field("itemIcon")?;
        }
        if let Some(f) = self.itemDesc() {
            s.serialize_field("itemDesc", &f)?;
        } else {
            s.skip_field("itemDesc")?;
        }
        s.serialize_field("itemTechType", &self.itemTechType())?;
        if let Some(f) = self.runeData() {
            s.serialize_field("runeData", &f)?;
        } else {
            s.skip_field("runeData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act25SideData_BattlePerformanceDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act25SideData_BattlePerformanceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act25SideData_BattlePerformanceData::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_Act25SideData_BattlePerformanceData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_itemName(&mut self, itemName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act25SideData_BattlePerformanceData::VT_ITEMNAME,
            itemName,
        );
    }
    #[inline]
    pub fn add_itemIcon(&mut self, itemIcon: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act25SideData_BattlePerformanceData::VT_ITEMICON,
            itemIcon,
        );
    }
    #[inline]
    pub fn add_itemDesc(&mut self, itemDesc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act25SideData_BattlePerformanceData::VT_ITEMDESC,
            itemDesc,
        );
    }
    #[inline]
    pub fn add_itemTechType(
        &mut self,
        itemTechType: enum__Torappu_Act25SideData_Act25sideTechType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_Act25SideData_Act25sideTechType>(
                clz_Torappu_Act25SideData_BattlePerformanceData::VT_ITEMTECHTYPE,
                itemTechType,
                enum__Torappu_Act25SideData_Act25sideTechType::TECH_1,
            );
    }
    #[inline]
    pub fn add_runeData(
        &mut self,
        runeData: flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RuneTable_PackedRuneData>>(
                clz_Torappu_Act25SideData_BattlePerformanceData::VT_RUNEDATA,
                runeData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act25SideData_BattlePerformanceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act25SideData_BattlePerformanceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act25SideData_BattlePerformanceData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act25SideData_BattlePerformanceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act25SideData_BattlePerformanceData");
        ds.field("itemId", &self.itemId());
        ds.field("sortId", &self.sortId());
        ds.field("itemName", &self.itemName());
        ds.field("itemIcon", &self.itemIcon());
        ds.field("itemDesc", &self.itemDesc());
        ds.field("itemTechType", &self.itemTechType());
        ds.field("runeData", &self.runeData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act25SideData_BattlePerformanceDataT {
    pub itemId: Option<String>,
    pub sortId: i32,
    pub itemName: Option<String>,
    pub itemIcon: Option<String>,
    pub itemDesc: Option<String>,
    pub itemTechType: enum__Torappu_Act25SideData_Act25sideTechType,
    pub runeData: Option<Box<clz_Torappu_RuneTable_PackedRuneDataT>>,
}
impl Default for clz_Torappu_Act25SideData_BattlePerformanceDataT {
    fn default() -> Self {
        Self {
            itemId: None,
            sortId: 0,
            itemName: None,
            itemIcon: None,
            itemDesc: None,
            itemTechType: enum__Torappu_Act25SideData_Act25sideTechType::TECH_1,
            runeData: None,
        }
    }
}
impl clz_Torappu_Act25SideData_BattlePerformanceDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act25SideData_BattlePerformanceData<'b>> {
        let itemId = self.itemId.as_ref().map(|x| _fbb.create_string(x));
        let sortId = self.sortId;
        let itemName = self.itemName.as_ref().map(|x| _fbb.create_string(x));
        let itemIcon = self.itemIcon.as_ref().map(|x| _fbb.create_string(x));
        let itemDesc = self.itemDesc.as_ref().map(|x| _fbb.create_string(x));
        let itemTechType = self.itemTechType;
        let runeData = self.runeData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_Act25SideData_BattlePerformanceData::create(
            _fbb,
            &clz_Torappu_Act25SideData_BattlePerformanceDataArgs {
                itemId,
                sortId,
                itemName,
                itemIcon,
                itemDesc,
                itemTechType,
                runeData,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act25SideData_BattlePerformanceData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_Act25SideData_BattlePerformanceData<'a>
{
    type Inner = dict__string__clz_Torappu_Act25SideData_BattlePerformanceData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act25SideData_BattlePerformanceData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act25SideData_BattlePerformanceData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act25SideData_BattlePerformanceData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act25SideData_BattlePerformanceData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act25SideData_BattlePerformanceData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act25SideData_BattlePerformanceData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act25SideData_BattlePerformanceData>>(dict__string__clz_Torappu_Act25SideData_BattlePerformanceData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act25SideData_BattlePerformanceData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act25SideData_BattlePerformanceData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act25SideData_BattlePerformanceData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act25SideData_BattlePerformanceData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_Act25SideData_BattlePerformanceData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act25SideData_BattlePerformanceData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act25SideData_BattlePerformanceData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act25SideData_BattlePerformanceData>>(dict__string__clz_Torappu_Act25SideData_BattlePerformanceData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act25SideData_BattlePerformanceData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act25SideData_BattlePerformanceData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act25SideData_BattlePerformanceData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_Act25SideData_BattlePerformanceData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act25SideData_BattlePerformanceDataT>>,
}
impl Default for dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act25SideData_BattlePerformanceData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act25SideData_BattlePerformanceData::create(
            _fbb,
            &dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActivityCustomData_Act25sideCustomDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActivityCustomData_Act25sideCustomData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActivityCustomData_Act25sideCustomData<'a> {
    type Inner = clz_Torappu_ActivityCustomData_Act25sideCustomData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActivityCustomData_Act25sideCustomData<'a> {
    pub const VT_BATTLEPERFORMANCEDATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActivityCustomData_Act25sideCustomData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActivityCustomData_Act25sideCustomDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActivityCustomData_Act25sideCustomData<'bldr>> {
        let mut builder = clz_Torappu_ActivityCustomData_Act25sideCustomDataBuilder::new(_fbb);
        if let Some(x) = args.battlePerformanceData {
            builder.add_battlePerformanceData(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActivityCustomData_Act25sideCustomDataT {
        let battlePerformanceData = self
            .battlePerformanceData()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActivityCustomData_Act25sideCustomDataT {
            battlePerformanceData,
        }
    }

    #[inline]
    pub fn battlePerformanceData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_Act25SideData_BattlePerformanceData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act25SideData_BattlePerformanceData,
                    >,
                >,
            >>(
                clz_Torappu_ActivityCustomData_Act25sideCustomData::VT_BATTLEPERFORMANCEDATA,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActivityCustomData_Act25sideCustomData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act25SideData_BattlePerformanceData,
                    >,
                >,
            >>(
                "battlePerformanceData",
                Self::VT_BATTLEPERFORMANCEDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActivityCustomData_Act25sideCustomDataArgs<'a> {
    pub battlePerformanceData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act25SideData_BattlePerformanceData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActivityCustomData_Act25sideCustomDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActivityCustomData_Act25sideCustomDataArgs {
            battlePerformanceData: None,
        }
    }
}

impl Serialize for clz_Torappu_ActivityCustomData_Act25sideCustomData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s =
            serializer.serialize_struct("clz_Torappu_ActivityCustomData_Act25sideCustomData", 1)?;
        if let Some(f) = self.battlePerformanceData() {
            s.serialize_field("battlePerformanceData", &f)?;
        } else {
            s.skip_field("battlePerformanceData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActivityCustomData_Act25sideCustomDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_ActivityCustomData_Act25sideCustomDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_battlePerformanceData(
        &mut self,
        battlePerformanceData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act25SideData_BattlePerformanceData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActivityCustomData_Act25sideCustomData::VT_BATTLEPERFORMANCEDATA,
            battlePerformanceData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActivityCustomData_Act25sideCustomDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActivityCustomData_Act25sideCustomDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActivityCustomData_Act25sideCustomData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActivityCustomData_Act25sideCustomData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActivityCustomData_Act25sideCustomData");
        ds.field("battlePerformanceData", &self.battlePerformanceData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActivityCustomData_Act25sideCustomDataT {
    pub battlePerformanceData:
        Option<Vec<dict__string__clz_Torappu_Act25SideData_BattlePerformanceDataT>>,
}
impl Default for clz_Torappu_ActivityCustomData_Act25sideCustomDataT {
    fn default() -> Self {
        Self {
            battlePerformanceData: None,
        }
    }
}
impl clz_Torappu_ActivityCustomData_Act25sideCustomDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActivityCustomData_Act25sideCustomData<'b>> {
        let battlePerformanceData = self.battlePerformanceData.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActivityCustomData_Act25sideCustomData::create(
            _fbb,
            &clz_Torappu_ActivityCustomData_Act25sideCustomDataArgs {
                battlePerformanceData,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData<'a>
{
    type Inner = dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_ActivityCustomData_Act25sideCustomData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_ActivityCustomData_Act25sideCustomData,
            >>(
                dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActivityCustomData_Act25sideCustomData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_ActivityCustomData_Act25sideCustomData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_ActivityCustomData_Act25sideCustomData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActivityCustomData_Act25sideCustomData>>(dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_ActivityCustomData_Act25sideCustomDataT>>,
}
impl Default for dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData<'b>>
    {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData::create(
            _fbb,
            &dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act20SideData_ResidentCartDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act20SideData_ResidentCartData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act20SideData_ResidentCartData<'a> {
    type Inner = clz_Torappu_Act20SideData_ResidentCartData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act20SideData_ResidentCartData<'a> {
    pub const VT_RESIDENTPIC: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act20SideData_ResidentCartData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act20SideData_ResidentCartDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act20SideData_ResidentCartData<'bldr>> {
        let mut builder = clz_Torappu_Act20SideData_ResidentCartDataBuilder::new(_fbb);
        if let Some(x) = args.residentPic {
            builder.add_residentPic(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act20SideData_ResidentCartDataT {
        let residentPic = self.residentPic().map(|x| x.to_string());
        clz_Torappu_Act20SideData_ResidentCartDataT { residentPic }
    }

    #[inline]
    pub fn residentPic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act20SideData_ResidentCartData::VT_RESIDENTPIC,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act20SideData_ResidentCartData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "residentPic",
                Self::VT_RESIDENTPIC,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act20SideData_ResidentCartDataArgs<'a> {
    pub residentPic: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Act20SideData_ResidentCartDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act20SideData_ResidentCartDataArgs { residentPic: None }
    }
}

impl Serialize for clz_Torappu_Act20SideData_ResidentCartData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act20SideData_ResidentCartData", 1)?;
        if let Some(f) = self.residentPic() {
            s.serialize_field("residentPic", &f)?;
        } else {
            s.skip_field("residentPic")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act20SideData_ResidentCartDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act20SideData_ResidentCartDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_residentPic(&mut self, residentPic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act20SideData_ResidentCartData::VT_RESIDENTPIC,
            residentPic,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act20SideData_ResidentCartDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act20SideData_ResidentCartDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act20SideData_ResidentCartData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act20SideData_ResidentCartData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act20SideData_ResidentCartData");
        ds.field("residentPic", &self.residentPic());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act20SideData_ResidentCartDataT {
    pub residentPic: Option<String>,
}
impl Default for clz_Torappu_Act20SideData_ResidentCartDataT {
    fn default() -> Self {
        Self { residentPic: None }
    }
}
impl clz_Torappu_Act20SideData_ResidentCartDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act20SideData_ResidentCartData<'b>> {
        let residentPic = self.residentPic.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Act20SideData_ResidentCartData::create(
            _fbb,
            &clz_Torappu_Act20SideData_ResidentCartDataArgs { residentPic },
        )
    }
}
pub enum dict__string__clz_Torappu_Act20SideData_ResidentCartDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act20SideData_ResidentCartData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act20SideData_ResidentCartData<'a> {
    type Inner = dict__string__clz_Torappu_Act20SideData_ResidentCartData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act20SideData_ResidentCartData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act20SideData_ResidentCartData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act20SideData_ResidentCartDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act20SideData_ResidentCartData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_Act20SideData_ResidentCartDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act20SideData_ResidentCartDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act20SideData_ResidentCartDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act20SideData_ResidentCartData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act20SideData_ResidentCartData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act20SideData_ResidentCartData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act20SideData_ResidentCartData>>(
                    dict__string__clz_Torappu_Act20SideData_ResidentCartData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act20SideData_ResidentCartData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act20SideData_ResidentCartData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act20SideData_ResidentCartDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act20SideData_ResidentCartData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act20SideData_ResidentCartDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act20SideData_ResidentCartDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act20SideData_ResidentCartData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct(
            "dict__string__clz_Torappu_Act20SideData_ResidentCartData",
            2,
        )?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act20SideData_ResidentCartDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act20SideData_ResidentCartDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act20SideData_ResidentCartData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act20SideData_ResidentCartData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act20SideData_ResidentCartData>>(
                dict__string__clz_Torappu_Act20SideData_ResidentCartData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act20SideData_ResidentCartDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act20SideData_ResidentCartDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act20SideData_ResidentCartData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act20SideData_ResidentCartData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act20SideData_ResidentCartData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act20SideData_ResidentCartData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act20SideData_ResidentCartDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act20SideData_ResidentCartDataT>>,
}
impl Default for dict__string__clz_Torappu_Act20SideData_ResidentCartDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act20SideData_ResidentCartDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act20SideData_ResidentCartData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act20SideData_ResidentCartData::create(
            _fbb,
            &dict__string__clz_Torappu_Act20SideData_ResidentCartDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act20SideDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act20SideData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act20SideData<'a> {
    type Inner = clz_Torappu_Act20SideData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act20SideData<'a> {
    pub const VT_ZONEADDITIONDATAMAP: flatbuffers::VOffsetT = 4;
    pub const VT_RESIDENTCARTDATAS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act20SideData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act20SideDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act20SideData<'bldr>> {
        let mut builder = clz_Torappu_Act20SideDataBuilder::new(_fbb);
        if let Some(x) = args.residentCartDatas {
            builder.add_residentCartDatas(x);
        }
        if let Some(x) = args.zoneAdditionDataMap {
            builder.add_zoneAdditionDataMap(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act20SideDataT {
        let zoneAdditionDataMap = self
            .zoneAdditionDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let residentCartDatas = self
            .residentCartDatas()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_Act20SideDataT {
            zoneAdditionDataMap,
            residentCartDatas,
        }
    }

    #[inline]
    pub fn zoneAdditionDataMap(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_Act20SideData::VT_ZONEADDITIONDATAMAP, None)
        }
    }
    #[inline]
    pub fn residentCartDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_Act20SideData_ResidentCartData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act20SideData_ResidentCartData,
                    >,
                >,
            >>(clz_Torappu_Act20SideData::VT_RESIDENTCARTDATAS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act20SideData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>("zoneAdditionDataMap", Self::VT_ZONEADDITIONDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act20SideData_ResidentCartData,
                    >,
                >,
            >>("residentCartDatas", Self::VT_RESIDENTCARTDATAS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act20SideDataArgs<'a> {
    pub zoneAdditionDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
    pub residentCartDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act20SideData_ResidentCartData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_Act20SideDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act20SideDataArgs {
            zoneAdditionDataMap: None,
            residentCartDatas: None,
        }
    }
}

impl Serialize for clz_Torappu_Act20SideData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act20SideData", 2)?;
        if let Some(f) = self.zoneAdditionDataMap() {
            s.serialize_field("zoneAdditionDataMap", &f)?;
        } else {
            s.skip_field("zoneAdditionDataMap")?;
        }
        if let Some(f) = self.residentCartDatas() {
            s.serialize_field("residentCartDatas", &f)?;
        } else {
            s.skip_field("residentCartDatas")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act20SideDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Act20SideDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_zoneAdditionDataMap(
        &mut self,
        zoneAdditionDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act20SideData::VT_ZONEADDITIONDATAMAP,
            zoneAdditionDataMap,
        );
    }
    #[inline]
    pub fn add_residentCartDatas(
        &mut self,
        residentCartDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act20SideData_ResidentCartData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act20SideData::VT_RESIDENTCARTDATAS,
            residentCartDatas,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act20SideDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act20SideDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act20SideData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act20SideData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act20SideData");
        ds.field("zoneAdditionDataMap", &self.zoneAdditionDataMap());
        ds.field("residentCartDatas", &self.residentCartDatas());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act20SideDataT {
    pub zoneAdditionDataMap: Option<Vec<dict__string__stringT>>,
    pub residentCartDatas: Option<Vec<dict__string__clz_Torappu_Act20SideData_ResidentCartDataT>>,
}
impl Default for clz_Torappu_Act20SideDataT {
    fn default() -> Self {
        Self {
            zoneAdditionDataMap: None,
            residentCartDatas: None,
        }
    }
}
impl clz_Torappu_Act20SideDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act20SideData<'b>> {
        let zoneAdditionDataMap = self.zoneAdditionDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let residentCartDatas = self.residentCartDatas.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_Act20SideData::create(
            _fbb,
            &clz_Torappu_Act20SideDataArgs {
                zoneAdditionDataMap,
                residentCartDatas,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act20SideDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act20SideData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act20SideData<'a> {
    type Inner = dict__string__clz_Torappu_Act20SideData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act20SideData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act20SideData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act20SideDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act20SideData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_Act20SideDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act20SideDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act20SideDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act20SideData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_Act20SideData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act20SideData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act20SideData>>(
                    dict__string__clz_Torappu_Act20SideData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act20SideData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act20SideData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act20SideDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act20SideData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act20SideDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act20SideDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act20SideData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_Act20SideData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act20SideDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act20SideDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act20SideData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_Act20SideData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act20SideData>>(
                dict__string__clz_Torappu_Act20SideData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act20SideDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act20SideDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act20SideData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_Act20SideData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act20SideData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act20SideData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act20SideDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act20SideDataT>>,
}
impl Default for dict__string__clz_Torappu_Act20SideDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act20SideDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act20SideData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act20SideData::create(
            _fbb,
            &dict__string__clz_Torappu_Act20SideDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act21SideData_ZoneAddtionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act21SideData_ZoneAddtionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act21SideData_ZoneAddtionData<'a> {
    type Inner = clz_Torappu_Act21SideData_ZoneAddtionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act21SideData_ZoneAddtionData<'a> {
    pub const VT_ZONEID: flatbuffers::VOffsetT = 4;
    pub const VT_UNLOCKTEXT: flatbuffers::VOffsetT = 6;
    pub const VT_STAGEUNLOCKTEXT: flatbuffers::VOffsetT = 8;
    pub const VT_ENTRYID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act21SideData_ZoneAddtionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act21SideData_ZoneAddtionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act21SideData_ZoneAddtionData<'bldr>> {
        let mut builder = clz_Torappu_Act21SideData_ZoneAddtionDataBuilder::new(_fbb);
        if let Some(x) = args.entryId {
            builder.add_entryId(x);
        }
        if let Some(x) = args.stageUnlockText {
            builder.add_stageUnlockText(x);
        }
        if let Some(x) = args.unlockText {
            builder.add_unlockText(x);
        }
        if let Some(x) = args.zoneId {
            builder.add_zoneId(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act21SideData_ZoneAddtionDataT {
        let zoneId = self.zoneId().map(|x| x.to_string());
        let unlockText = self.unlockText().map(|x| x.to_string());
        let stageUnlockText = self.stageUnlockText().map(|x| x.to_string());
        let entryId = self.entryId().map(|x| x.to_string());
        clz_Torappu_Act21SideData_ZoneAddtionDataT {
            zoneId,
            unlockText,
            stageUnlockText,
            entryId,
        }
    }

    #[inline]
    pub fn zoneId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act21SideData_ZoneAddtionData::VT_ZONEID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act21SideData_ZoneAddtionData::VT_UNLOCKTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn stageUnlockText(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act21SideData_ZoneAddtionData::VT_STAGEUNLOCKTEXT,
                None,
            )
        }
    }
    #[inline]
    pub fn entryId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act21SideData_ZoneAddtionData::VT_ENTRYID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act21SideData_ZoneAddtionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("zoneId", Self::VT_ZONEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockText",
                Self::VT_UNLOCKTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "stageUnlockText",
                Self::VT_STAGEUNLOCKTEXT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("entryId", Self::VT_ENTRYID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act21SideData_ZoneAddtionDataArgs<'a> {
    pub zoneId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stageUnlockText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub entryId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Act21SideData_ZoneAddtionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act21SideData_ZoneAddtionDataArgs {
            zoneId: None,
            unlockText: None,
            stageUnlockText: None,
            entryId: None,
        }
    }
}

impl Serialize for clz_Torappu_Act21SideData_ZoneAddtionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act21SideData_ZoneAddtionData", 4)?;
        if let Some(f) = self.zoneId() {
            s.serialize_field("zoneId", &f)?;
        } else {
            s.skip_field("zoneId")?;
        }
        if let Some(f) = self.unlockText() {
            s.serialize_field("unlockText", &f)?;
        } else {
            s.skip_field("unlockText")?;
        }
        if let Some(f) = self.stageUnlockText() {
            s.serialize_field("stageUnlockText", &f)?;
        } else {
            s.skip_field("stageUnlockText")?;
        }
        if let Some(f) = self.entryId() {
            s.serialize_field("entryId", &f)?;
        } else {
            s.skip_field("entryId")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act21SideData_ZoneAddtionDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act21SideData_ZoneAddtionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_zoneId(&mut self, zoneId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act21SideData_ZoneAddtionData::VT_ZONEID,
            zoneId,
        );
    }
    #[inline]
    pub fn add_unlockText(&mut self, unlockText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act21SideData_ZoneAddtionData::VT_UNLOCKTEXT,
            unlockText,
        );
    }
    #[inline]
    pub fn add_stageUnlockText(&mut self, stageUnlockText: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act21SideData_ZoneAddtionData::VT_STAGEUNLOCKTEXT,
            stageUnlockText,
        );
    }
    #[inline]
    pub fn add_entryId(&mut self, entryId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act21SideData_ZoneAddtionData::VT_ENTRYID,
            entryId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act21SideData_ZoneAddtionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act21SideData_ZoneAddtionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act21SideData_ZoneAddtionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act21SideData_ZoneAddtionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act21SideData_ZoneAddtionData");
        ds.field("zoneId", &self.zoneId());
        ds.field("unlockText", &self.unlockText());
        ds.field("stageUnlockText", &self.stageUnlockText());
        ds.field("entryId", &self.entryId());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act21SideData_ZoneAddtionDataT {
    pub zoneId: Option<String>,
    pub unlockText: Option<String>,
    pub stageUnlockText: Option<String>,
    pub entryId: Option<String>,
}
impl Default for clz_Torappu_Act21SideData_ZoneAddtionDataT {
    fn default() -> Self {
        Self {
            zoneId: None,
            unlockText: None,
            stageUnlockText: None,
            entryId: None,
        }
    }
}
impl clz_Torappu_Act21SideData_ZoneAddtionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act21SideData_ZoneAddtionData<'b>> {
        let zoneId = self.zoneId.as_ref().map(|x| _fbb.create_string(x));
        let unlockText = self.unlockText.as_ref().map(|x| _fbb.create_string(x));
        let stageUnlockText = self.stageUnlockText.as_ref().map(|x| _fbb.create_string(x));
        let entryId = self.entryId.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Act21SideData_ZoneAddtionData::create(
            _fbb,
            &clz_Torappu_Act21SideData_ZoneAddtionDataArgs {
                zoneId,
                unlockText,
                stageUnlockText,
                entryId,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act21SideData_ZoneAddtionData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act21SideData_ZoneAddtionData<'a> {
    type Inner = dict__string__clz_Torappu_Act21SideData_ZoneAddtionData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act21SideData_ZoneAddtionData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act21SideData_ZoneAddtionData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act21SideData_ZoneAddtionData<'bldr>>
    {
        let mut builder = dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act21SideData_ZoneAddtionData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_Act21SideData_ZoneAddtionData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act21SideData_ZoneAddtionData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act21SideData_ZoneAddtionData>>(
                    dict__string__clz_Torappu_Act21SideData_ZoneAddtionData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act21SideData_ZoneAddtionData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act21SideData_ZoneAddtionData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act21SideData_ZoneAddtionData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act21SideData_ZoneAddtionData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer
            .serialize_struct("dict__string__clz_Torappu_Act21SideData_ZoneAddtionData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act21SideData_ZoneAddtionData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_Act21SideData_ZoneAddtionData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act21SideData_ZoneAddtionData>>(
                dict__string__clz_Torappu_Act21SideData_ZoneAddtionData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act21SideData_ZoneAddtionData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_Act21SideData_ZoneAddtionData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act21SideData_ZoneAddtionData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act21SideData_ZoneAddtionData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act21SideData_ZoneAddtionDataT>>,
}
impl Default for dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act21SideData_ZoneAddtionData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act21SideData_ZoneAddtionData::create(
            _fbb,
            &dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_Act21SideData_ConstDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act21SideData_ConstData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act21SideData_ConstData<'a> {
    type Inner = clz_Torappu_Act21SideData_ConstData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act21SideData_ConstData<'a> {
    pub const VT_LINECONNECTZONE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act21SideData_ConstData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act21SideData_ConstDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act21SideData_ConstData<'bldr>> {
        let mut builder = clz_Torappu_Act21SideData_ConstDataBuilder::new(_fbb);
        if let Some(x) = args.lineConnectZone {
            builder.add_lineConnectZone(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act21SideData_ConstDataT {
        let lineConnectZone = self.lineConnectZone().map(|x| x.to_string());
        clz_Torappu_Act21SideData_ConstDataT { lineConnectZone }
    }

    #[inline]
    pub fn lineConnectZone(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_Act21SideData_ConstData::VT_LINECONNECTZONE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act21SideData_ConstData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "lineConnectZone",
                Self::VT_LINECONNECTZONE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act21SideData_ConstDataArgs<'a> {
    pub lineConnectZone: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_Act21SideData_ConstDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act21SideData_ConstDataArgs {
            lineConnectZone: None,
        }
    }
}

impl Serialize for clz_Torappu_Act21SideData_ConstData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act21SideData_ConstData", 1)?;
        if let Some(f) = self.lineConnectZone() {
            s.serialize_field("lineConnectZone", &f)?;
        } else {
            s.skip_field("lineConnectZone")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act21SideData_ConstDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_Act21SideData_ConstDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_lineConnectZone(&mut self, lineConnectZone: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act21SideData_ConstData::VT_LINECONNECTZONE,
            lineConnectZone,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act21SideData_ConstDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act21SideData_ConstDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act21SideData_ConstData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act21SideData_ConstData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act21SideData_ConstData");
        ds.field("lineConnectZone", &self.lineConnectZone());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act21SideData_ConstDataT {
    pub lineConnectZone: Option<String>,
}
impl Default for clz_Torappu_Act21SideData_ConstDataT {
    fn default() -> Self {
        Self {
            lineConnectZone: None,
        }
    }
}
impl clz_Torappu_Act21SideData_ConstDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act21SideData_ConstData<'b>> {
        let lineConnectZone = self.lineConnectZone.as_ref().map(|x| _fbb.create_string(x));
        clz_Torappu_Act21SideData_ConstData::create(
            _fbb,
            &clz_Torappu_Act21SideData_ConstDataArgs { lineConnectZone },
        )
    }
}
pub enum clz_Torappu_Act21SideDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_Act21SideData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_Act21SideData<'a> {
    type Inner = clz_Torappu_Act21SideData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_Act21SideData<'a> {
    pub const VT_ZONEADDITIONDATAMAP: flatbuffers::VOffsetT = 4;
    pub const VT_CONSTDATA: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_Act21SideData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_Act21SideDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act21SideData<'bldr>> {
        let mut builder = clz_Torappu_Act21SideDataBuilder::new(_fbb);
        if let Some(x) = args.constData {
            builder.add_constData(x);
        }
        if let Some(x) = args.zoneAdditionDataMap {
            builder.add_zoneAdditionDataMap(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_Act21SideDataT {
        let zoneAdditionDataMap = self
            .zoneAdditionDataMap()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let constData = self.constData().map(|x| Box::new(x.unpack()));
        clz_Torappu_Act21SideDataT {
            zoneAdditionDataMap,
            constData,
        }
    }

    #[inline]
    pub fn zoneAdditionDataMap(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_Act21SideData_ZoneAddtionData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act21SideData_ZoneAddtionData,
                    >,
                >,
            >>(clz_Torappu_Act21SideData::VT_ZONEADDITIONDATAMAP, None)
        }
    }
    #[inline]
    pub fn constData(&self) -> Option<clz_Torappu_Act21SideData_ConstData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act21SideData_ConstData>>(
                    clz_Torappu_Act21SideData::VT_CONSTDATA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_Act21SideData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_Act21SideData_ZoneAddtionData,
                    >,
                >,
            >>("zoneAdditionDataMap", Self::VT_ZONEADDITIONDATAMAP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act21SideData_ConstData>>(
                "constData",
                Self::VT_CONSTDATA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_Act21SideDataArgs<'a> {
    pub zoneAdditionDataMap: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act21SideData_ZoneAddtionData<'a>,
                >,
            >,
        >,
    >,
    pub constData: Option<flatbuffers::WIPOffset<clz_Torappu_Act21SideData_ConstData<'a>>>,
}
impl<'a> Default for clz_Torappu_Act21SideDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_Act21SideDataArgs {
            zoneAdditionDataMap: None,
            constData: None,
        }
    }
}

impl Serialize for clz_Torappu_Act21SideData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_Act21SideData", 2)?;
        if let Some(f) = self.zoneAdditionDataMap() {
            s.serialize_field("zoneAdditionDataMap", &f)?;
        } else {
            s.skip_field("zoneAdditionDataMap")?;
        }
        if let Some(f) = self.constData() {
            s.serialize_field("constData", &f)?;
        } else {
            s.skip_field("constData")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_Act21SideDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_Act21SideDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_zoneAdditionDataMap(
        &mut self,
        zoneAdditionDataMap: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_Act21SideData_ZoneAddtionData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_Act21SideData::VT_ZONEADDITIONDATAMAP,
            zoneAdditionDataMap,
        );
    }
    #[inline]
    pub fn add_constData(
        &mut self,
        constData: flatbuffers::WIPOffset<clz_Torappu_Act21SideData_ConstData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act21SideData_ConstData>>(
                clz_Torappu_Act21SideData::VT_CONSTDATA,
                constData,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_Act21SideDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_Act21SideDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_Act21SideData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_Act21SideData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_Act21SideData");
        ds.field("zoneAdditionDataMap", &self.zoneAdditionDataMap());
        ds.field("constData", &self.constData());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_Act21SideDataT {
    pub zoneAdditionDataMap: Option<Vec<dict__string__clz_Torappu_Act21SideData_ZoneAddtionDataT>>,
    pub constData: Option<Box<clz_Torappu_Act21SideData_ConstDataT>>,
}
impl Default for clz_Torappu_Act21SideDataT {
    fn default() -> Self {
        Self {
            zoneAdditionDataMap: None,
            constData: None,
        }
    }
}
impl clz_Torappu_Act21SideDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_Act21SideData<'b>> {
        let zoneAdditionDataMap = self.zoneAdditionDataMap.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let constData = self.constData.as_ref().map(|x| x.pack(_fbb));
        clz_Torappu_Act21SideData::create(
            _fbb,
            &clz_Torappu_Act21SideDataArgs {
                zoneAdditionDataMap,
                constData,
            },
        )
    }
}
pub enum dict__string__clz_Torappu_Act21SideDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_Act21SideData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_Act21SideData<'a> {
    type Inner = dict__string__clz_Torappu_Act21SideData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__string__clz_Torappu_Act21SideData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_Act21SideData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_Act21SideDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act21SideData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_Act21SideDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> dict__string__clz_Torappu_Act21SideDataT {
        let key = {
            let x = self.key();
            x.to_string()
        };
        let value = self.value().map(|x| Box::new(x.unpack()));
        dict__string__clz_Torappu_Act21SideDataT { key, value }
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_Act21SideData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__clz_Torappu_Act21SideData) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_Act21SideData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_Act21SideData>>(
                    dict__string__clz_Torappu_Act21SideData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_Act21SideData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_Act21SideData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_Act21SideDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_Act21SideData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_Act21SideDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_Act21SideDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

impl Serialize for dict__string__clz_Torappu_Act21SideData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__string__clz_Torappu_Act21SideData", 2)?;
        s.serialize_field("key", &self.key())?;
        if let Some(f) = self.value() {
            s.serialize_field("value", &f)?;
        } else {
            s.skip_field("value")?;
        }
        s.end()
    }
}

pub struct dict__string__clz_Torappu_Act21SideDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_Act21SideDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_Act21SideData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_Act21SideData<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_Act21SideData>>(
                dict__string__clz_Torappu_Act21SideData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_Act21SideDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_Act21SideDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act21SideData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__clz_Torappu_Act21SideData::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_Act21SideData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_Act21SideData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__string__clz_Torappu_Act21SideDataT {
    pub key: String,
    pub value: Option<Box<clz_Torappu_Act21SideDataT>>,
}
impl Default for dict__string__clz_Torappu_Act21SideDataT {
    fn default() -> Self {
        Self {
            key: "".to_string(),
            value: None,
        }
    }
}
impl dict__string__clz_Torappu_Act21SideDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_Act21SideData<'b>> {
        let key = Some({
            let x = &self.key;
            _fbb.create_string(x)
        });
        let value = self.value.as_ref().map(|x| x.pack(_fbb));
        dict__string__clz_Torappu_Act21SideData::create(
            _fbb,
            &dict__string__clz_Torappu_Act21SideDataArgs { key, value },
        )
    }
}
pub enum clz_Torappu_ActivityCustomDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ActivityCustomData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ActivityCustomData<'a> {
    type Inner = clz_Torappu_ActivityCustomData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_ActivityCustomData<'a> {
    pub const VT_TYPE_ACT17SIDE: flatbuffers::VOffsetT = 4;
    pub const VT_TYPE_ACT25SIDE: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_ACT20SIDE: flatbuffers::VOffsetT = 8;
    pub const VT_TYPE_ACT21SIDE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ActivityCustomData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ActivityCustomDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActivityCustomData<'bldr>> {
        let mut builder = clz_Torappu_ActivityCustomDataBuilder::new(_fbb);
        if let Some(x) = args.TYPE_ACT21SIDE {
            builder.add_TYPE_ACT21SIDE(x);
        }
        if let Some(x) = args.TYPE_ACT20SIDE {
            builder.add_TYPE_ACT20SIDE(x);
        }
        if let Some(x) = args.TYPE_ACT25SIDE {
            builder.add_TYPE_ACT25SIDE(x);
        }
        if let Some(x) = args.TYPE_ACT17SIDE {
            builder.add_TYPE_ACT17SIDE(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_ActivityCustomDataT {
        let TYPE_ACT17SIDE = self
            .TYPE_ACT17SIDE()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let TYPE_ACT25SIDE = self
            .TYPE_ACT25SIDE()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let TYPE_ACT20SIDE = self
            .TYPE_ACT20SIDE()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let TYPE_ACT21SIDE = self
            .TYPE_ACT21SIDE()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_ActivityCustomDataT {
            TYPE_ACT17SIDE,
            TYPE_ACT25SIDE,
            TYPE_ACT20SIDE,
            TYPE_ACT21SIDE,
        }
    }

    #[inline]
    pub fn TYPE_ACT17SIDE(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData>,
                >,
            >>(clz_Torappu_ActivityCustomData::VT_TYPE_ACT17SIDE, None)
        }
    }
    #[inline]
    pub fn TYPE_ACT25SIDE(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData,
                    >,
                >,
            >>(clz_Torappu_ActivityCustomData::VT_TYPE_ACT25SIDE, None)
        }
    }
    #[inline]
    pub fn TYPE_ACT20SIDE(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act20SideData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act20SideData>,
                >,
            >>(clz_Torappu_ActivityCustomData::VT_TYPE_ACT20SIDE, None)
        }
    }
    #[inline]
    pub fn TYPE_ACT21SIDE(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act21SideData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act21SideData>,
                >,
            >>(clz_Torappu_ActivityCustomData::VT_TYPE_ACT21SIDE, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ActivityCustomData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData>,
                >,
            >>("TYPE_ACT17SIDE", Self::VT_TYPE_ACT17SIDE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData,
                    >,
                >,
            >>("TYPE_ACT25SIDE", Self::VT_TYPE_ACT25SIDE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act20SideData>,
                >,
            >>("TYPE_ACT20SIDE", Self::VT_TYPE_ACT20SIDE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act21SideData>,
                >,
            >>("TYPE_ACT21SIDE", Self::VT_TYPE_ACT21SIDE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ActivityCustomDataArgs<'a> {
    pub TYPE_ACT17SIDE: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData<'a>>,
            >,
        >,
    >,
    pub TYPE_ACT25SIDE: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData<'a>,
                >,
            >,
        >,
    >,
    pub TYPE_ACT20SIDE: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act20SideData<'a>>,
            >,
        >,
    >,
    pub TYPE_ACT21SIDE: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act21SideData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_ActivityCustomDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ActivityCustomDataArgs {
            TYPE_ACT17SIDE: None,
            TYPE_ACT25SIDE: None,
            TYPE_ACT20SIDE: None,
            TYPE_ACT21SIDE: None,
        }
    }
}

impl Serialize for clz_Torappu_ActivityCustomData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_ActivityCustomData", 4)?;
        if let Some(f) = self.TYPE_ACT17SIDE() {
            s.serialize_field("TYPE_ACT17SIDE", &f)?;
        } else {
            s.skip_field("TYPE_ACT17SIDE")?;
        }
        if let Some(f) = self.TYPE_ACT25SIDE() {
            s.serialize_field("TYPE_ACT25SIDE", &f)?;
        } else {
            s.skip_field("TYPE_ACT25SIDE")?;
        }
        if let Some(f) = self.TYPE_ACT20SIDE() {
            s.serialize_field("TYPE_ACT20SIDE", &f)?;
        } else {
            s.skip_field("TYPE_ACT20SIDE")?;
        }
        if let Some(f) = self.TYPE_ACT21SIDE() {
            s.serialize_field("TYPE_ACT21SIDE", &f)?;
        } else {
            s.skip_field("TYPE_ACT21SIDE")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_ActivityCustomDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ActivityCustomDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_TYPE_ACT17SIDE(
        &mut self,
        TYPE_ACT17SIDE: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act17sideData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActivityCustomData::VT_TYPE_ACT17SIDE,
            TYPE_ACT17SIDE,
        );
    }
    #[inline]
    pub fn add_TYPE_ACT25SIDE(
        &mut self,
        TYPE_ACT25SIDE: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActivityCustomData::VT_TYPE_ACT25SIDE,
            TYPE_ACT25SIDE,
        );
    }
    #[inline]
    pub fn add_TYPE_ACT20SIDE(
        &mut self,
        TYPE_ACT20SIDE: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act20SideData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActivityCustomData::VT_TYPE_ACT20SIDE,
            TYPE_ACT20SIDE,
        );
    }
    #[inline]
    pub fn add_TYPE_ACT21SIDE(
        &mut self,
        TYPE_ACT21SIDE: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_Act21SideData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_ActivityCustomData::VT_TYPE_ACT21SIDE,
            TYPE_ACT21SIDE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ActivityCustomDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ActivityCustomDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ActivityCustomData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ActivityCustomData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ActivityCustomData");
        ds.field("TYPE_ACT17SIDE", &self.TYPE_ACT17SIDE());
        ds.field("TYPE_ACT25SIDE", &self.TYPE_ACT25SIDE());
        ds.field("TYPE_ACT20SIDE", &self.TYPE_ACT20SIDE());
        ds.field("TYPE_ACT21SIDE", &self.TYPE_ACT21SIDE());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_ActivityCustomDataT {
    pub TYPE_ACT17SIDE: Option<Vec<dict__string__clz_Torappu_Act17sideDataT>>,
    pub TYPE_ACT25SIDE:
        Option<Vec<dict__string__clz_Torappu_ActivityCustomData_Act25sideCustomDataT>>,
    pub TYPE_ACT20SIDE: Option<Vec<dict__string__clz_Torappu_Act20SideDataT>>,
    pub TYPE_ACT21SIDE: Option<Vec<dict__string__clz_Torappu_Act21SideDataT>>,
}
impl Default for clz_Torappu_ActivityCustomDataT {
    fn default() -> Self {
        Self {
            TYPE_ACT17SIDE: None,
            TYPE_ACT25SIDE: None,
            TYPE_ACT20SIDE: None,
            TYPE_ACT21SIDE: None,
        }
    }
}
impl clz_Torappu_ActivityCustomDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ActivityCustomData<'b>> {
        let TYPE_ACT17SIDE = self.TYPE_ACT17SIDE.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let TYPE_ACT25SIDE = self.TYPE_ACT25SIDE.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let TYPE_ACT20SIDE = self.TYPE_ACT20SIDE.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let TYPE_ACT21SIDE = self.TYPE_ACT21SIDE.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_ActivityCustomData::create(
            _fbb,
            &clz_Torappu_ActivityCustomDataArgs {
                TYPE_ACT17SIDE,
                TYPE_ACT25SIDE,
                TYPE_ACT20SIDE,
                TYPE_ACT21SIDE,
            },
        )
    }
}
pub enum dict__int__intOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__int<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__int__int<'a> {
    type Inner = dict__int__int<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> dict__int__int<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__int { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__intArgs,
    ) -> flatbuffers::WIPOffset<dict__int__int<'bldr>> {
        let mut builder = dict__int__intBuilder::new(_fbb);
        builder.add_value(args.value);
        builder.add_key(args.key);
        builder.finish()
    }

    pub fn unpack(&self) -> dict__int__intT {
        let key = self.key();
        let value = self.value();
        dict__int__intT { key, value }
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(dict__int__int::VT_KEY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__int__int) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(dict__int__int::VT_VALUE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for dict__int__int<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__int__intArgs {
    pub key: i32,
    pub value: i32,
}
impl<'a> Default for dict__int__intArgs {
    #[inline]
    fn default() -> Self {
        dict__int__intArgs { key: 0, value: 0 }
    }
}

impl Serialize for dict__int__int<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("dict__int__int", 2)?;
        s.serialize_field("key", &self.key())?;
        s.serialize_field("value", &self.value())?;
        s.end()
    }
}

pub struct dict__int__intBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__int__intBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(dict__int__int::VT_KEY, key, 0);
    }
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_
            .push_slot::<i32>(dict__int__int::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__intBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__intBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__int__int<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__int<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__int");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct dict__int__intT {
    pub key: i32,
    pub value: i32,
}
impl Default for dict__int__intT {
    fn default() -> Self {
        Self { key: 0, value: 0 }
    }
}
impl dict__int__intT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<dict__int__int<'b>> {
        let key = self.key;
        let value = self.value;
        dict__int__int::create(_fbb, &dict__int__intArgs { key, value })
    }
}
pub enum clz_Torappu_RetroStageTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_RetroStageTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_RetroStageTable<'a> {
    type Inner = clz_Torappu_RetroStageTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_RetroStageTable<'a> {
    pub const VT_ZONETORETRO: flatbuffers::VOffsetT = 4;
    pub const VT_STAGEVALIDINFO: flatbuffers::VOffsetT = 6;
    pub const VT_STAGES: flatbuffers::VOffsetT = 8;
    pub const VT_RETROACTLIST: flatbuffers::VOffsetT = 10;
    pub const VT_RETROTRAILLIST: flatbuffers::VOffsetT = 12;
    pub const VT_STAGELIST: flatbuffers::VOffsetT = 14;
    pub const VT_RULEDATA: flatbuffers::VOffsetT = 16;
    pub const VT_CUSTOMDATA: flatbuffers::VOffsetT = 18;
    pub const VT_INITRETROCOIN: flatbuffers::VOffsetT = 20;
    pub const VT_RETROCOINPERWEEK: flatbuffers::VOffsetT = 22;
    pub const VT_RETROCOINMAXOFLEVELS: flatbuffers::VOffsetT = 24;
    pub const VT_RETROUNLOCKCOST: flatbuffers::VOffsetT = 26;
    pub const VT_RETRODETAIL: flatbuffers::VOffsetT = 28;
    pub const VT_RETROPRESHOWTIME: flatbuffers::VOffsetT = 30;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_RetroStageTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_RetroStageTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RetroStageTable<'bldr>> {
        let mut builder = clz_Torappu_RetroStageTableBuilder::new(_fbb);
        builder.add_retroPreShowTime(args.retroPreShowTime);
        if let Some(x) = args.retroDetail {
            builder.add_retroDetail(x);
        }
        builder.add_retroUnlockCost(args.retroUnlockCost);
        if let Some(x) = args.retroCoinMaxOfLevels {
            builder.add_retroCoinMaxOfLevels(x);
        }
        builder.add_retroCoinPerWeek(args.retroCoinPerWeek);
        builder.add_initRetroCoin(args.initRetroCoin);
        if let Some(x) = args.customData {
            builder.add_customData(x);
        }
        if let Some(x) = args.ruleData {
            builder.add_ruleData(x);
        }
        if let Some(x) = args.stageList {
            builder.add_stageList(x);
        }
        if let Some(x) = args.retroTrailList {
            builder.add_retroTrailList(x);
        }
        if let Some(x) = args.retroActList {
            builder.add_retroActList(x);
        }
        if let Some(x) = args.stages {
            builder.add_stages(x);
        }
        if let Some(x) = args.stageValidInfo {
            builder.add_stageValidInfo(x);
        }
        if let Some(x) = args.zoneToRetro {
            builder.add_zoneToRetro(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_RetroStageTableT {
        let zoneToRetro = self
            .zoneToRetro()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let stageValidInfo = self
            .stageValidInfo()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let stages = self
            .stages()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let retroActList = self
            .retroActList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let retroTrailList = self
            .retroTrailList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let stageList = self
            .stageList()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let ruleData = self.ruleData().map(|x| Box::new(x.unpack()));
        let customData = self.customData().map(|x| Box::new(x.unpack()));
        let initRetroCoin = self.initRetroCoin();
        let retroCoinPerWeek = self.retroCoinPerWeek();
        let retroCoinMaxOfLevels = self
            .retroCoinMaxOfLevels()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        let retroUnlockCost = self.retroUnlockCost();
        let retroDetail = self.retroDetail().map(|x| x.to_string());
        let retroPreShowTime = self.retroPreShowTime();
        clz_Torappu_RetroStageTableT {
            zoneToRetro,
            stageValidInfo,
            stages,
            retroActList,
            retroTrailList,
            stageList,
            ruleData,
            customData,
            initRetroCoin,
            retroCoinPerWeek,
            retroCoinMaxOfLevels,
            retroUnlockCost,
            retroDetail,
            retroPreShowTime,
        }
    }

    #[inline]
    pub fn zoneToRetro(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_RetroStageTable::VT_ZONETORETRO, None)
        }
    }
    #[inline]
    pub fn stageValidInfo(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageValidInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageValidInfo>,
                >,
            >>(clz_Torappu_RetroStageTable::VT_STAGEVALIDINFO, None)
        }
    }
    #[inline]
    pub fn stages(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RetroStageOverrideInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RetroStageOverrideInfo>,
                >,
            >>(clz_Torappu_RetroStageTable::VT_STAGES, None)
        }
    }
    #[inline]
    pub fn retroActList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RetroActData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RetroActData>,
                >,
            >>(clz_Torappu_RetroStageTable::VT_RETROACTLIST, None)
        }
    }
    #[inline]
    pub fn retroTrailList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RetroTrailData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RetroTrailData>,
                >,
            >>(clz_Torappu_RetroStageTable::VT_RETROTRAILLIST, None)
        }
    }
    #[inline]
    pub fn stageList(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData>,
                >,
            >>(clz_Torappu_RetroStageTable::VT_STAGELIST, None)
        }
    }
    #[inline]
    pub fn ruleData(&self) -> Option<clz_Torappu_RetroTrailRuleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_RetroTrailRuleData>>(
                    clz_Torappu_RetroStageTable::VT_RULEDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn customData(&self) -> Option<clz_Torappu_ActivityCustomData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ActivityCustomData>>(
                    clz_Torappu_RetroStageTable::VT_CUSTOMDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn initRetroCoin(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RetroStageTable::VT_INITRETROCOIN, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn retroCoinPerWeek(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RetroStageTable::VT_RETROCOINPERWEEK, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn retroCoinMaxOfLevels(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__int__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__int__int>>,
            >>(clz_Torappu_RetroStageTable::VT_RETROCOINMAXOFLEVELS, None)
        }
    }
    #[inline]
    pub fn retroUnlockCost(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_RetroStageTable::VT_RETROUNLOCKCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn retroDetail(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_RetroStageTable::VT_RETRODETAIL,
                None,
            )
        }
    }
    #[inline]
    pub fn retroPreShowTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_RetroStageTable::VT_RETROPRESHOWTIME, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_RetroStageTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>("zoneToRetro", Self::VT_ZONETORETRO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageValidInfo>,
                >,
            >>("stageValidInfo", Self::VT_STAGEVALIDINFO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RetroStageOverrideInfo>,
                >,
            >>("stages", Self::VT_STAGES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RetroActData>,
                >,
            >>("retroActList", Self::VT_RETROACTLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RetroTrailData>,
                >,
            >>("retroTrailList", Self::VT_RETROTRAILLIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData>,
                >,
            >>("stageList", Self::VT_STAGELIST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_RetroTrailRuleData>>(
                "ruleData",
                Self::VT_RULEDATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ActivityCustomData>>(
                "customData",
                Self::VT_CUSTOMDATA,
                false,
            )?
            .visit_field::<i32>("initRetroCoin", Self::VT_INITRETROCOIN, false)?
            .visit_field::<i32>("retroCoinPerWeek", Self::VT_RETROCOINPERWEEK, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__int__int>>,
            >>("retroCoinMaxOfLevels", Self::VT_RETROCOINMAXOFLEVELS, false)?
            .visit_field::<i32>("retroUnlockCost", Self::VT_RETROUNLOCKCOST, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "retroDetail",
                Self::VT_RETRODETAIL,
                false,
            )?
            .visit_field::<i64>("retroPreShowTime", Self::VT_RETROPRESHOWTIME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_RetroStageTableArgs<'a> {
    pub zoneToRetro: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
    pub stageValidInfo: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageValidInfo<'a>>,
            >,
        >,
    >,
    pub stages: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RetroStageOverrideInfo<'a>>,
            >,
        >,
    >,
    pub retroActList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RetroActData<'a>>,
            >,
        >,
    >,
    pub retroTrailList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RetroTrailData<'a>>,
            >,
        >,
    >,
    pub stageList: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData<'a>>,
            >,
        >,
    >,
    pub ruleData: Option<flatbuffers::WIPOffset<clz_Torappu_RetroTrailRuleData<'a>>>,
    pub customData: Option<flatbuffers::WIPOffset<clz_Torappu_ActivityCustomData<'a>>>,
    pub initRetroCoin: i32,
    pub retroCoinPerWeek: i32,
    pub retroCoinMaxOfLevels: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__int__int<'a>>>,
        >,
    >,
    pub retroUnlockCost: i32,
    pub retroDetail: Option<flatbuffers::WIPOffset<&'a str>>,
    pub retroPreShowTime: i64,
}
impl<'a> Default for clz_Torappu_RetroStageTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_RetroStageTableArgs {
            zoneToRetro: None,
            stageValidInfo: None,
            stages: None,
            retroActList: None,
            retroTrailList: None,
            stageList: None,
            ruleData: None,
            customData: None,
            initRetroCoin: 0,
            retroCoinPerWeek: 0,
            retroCoinMaxOfLevels: None,
            retroUnlockCost: 0,
            retroDetail: None,
            retroPreShowTime: 0,
        }
    }
}

impl Serialize for clz_Torappu_RetroStageTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_RetroStageTable", 14)?;
        if let Some(f) = self.zoneToRetro() {
            s.serialize_field("zoneToRetro", &f)?;
        } else {
            s.skip_field("zoneToRetro")?;
        }
        if let Some(f) = self.stageValidInfo() {
            s.serialize_field("stageValidInfo", &f)?;
        } else {
            s.skip_field("stageValidInfo")?;
        }
        if let Some(f) = self.stages() {
            s.serialize_field("stages", &f)?;
        } else {
            s.skip_field("stages")?;
        }
        if let Some(f) = self.retroActList() {
            s.serialize_field("retroActList", &f)?;
        } else {
            s.skip_field("retroActList")?;
        }
        if let Some(f) = self.retroTrailList() {
            s.serialize_field("retroTrailList", &f)?;
        } else {
            s.skip_field("retroTrailList")?;
        }
        if let Some(f) = self.stageList() {
            s.serialize_field("stageList", &f)?;
        } else {
            s.skip_field("stageList")?;
        }
        if let Some(f) = self.ruleData() {
            s.serialize_field("ruleData", &f)?;
        } else {
            s.skip_field("ruleData")?;
        }
        if let Some(f) = self.customData() {
            s.serialize_field("customData", &f)?;
        } else {
            s.skip_field("customData")?;
        }
        s.serialize_field("initRetroCoin", &self.initRetroCoin())?;
        s.serialize_field("retroCoinPerWeek", &self.retroCoinPerWeek())?;
        if let Some(f) = self.retroCoinMaxOfLevels() {
            s.serialize_field("retroCoinMaxOfLevels", &f)?;
        } else {
            s.skip_field("retroCoinMaxOfLevels")?;
        }
        s.serialize_field("retroUnlockCost", &self.retroUnlockCost())?;
        if let Some(f) = self.retroDetail() {
            s.serialize_field("retroDetail", &f)?;
        } else {
            s.skip_field("retroDetail")?;
        }
        s.serialize_field("retroPreShowTime", &self.retroPreShowTime())?;
        s.end()
    }
}

pub struct clz_Torappu_RetroStageTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_RetroStageTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_zoneToRetro(
        &mut self,
        zoneToRetro: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroStageTable::VT_ZONETORETRO,
            zoneToRetro,
        );
    }
    #[inline]
    pub fn add_stageValidInfo(
        &mut self,
        stageValidInfo: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageValidInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroStageTable::VT_STAGEVALIDINFO,
            stageValidInfo,
        );
    }
    #[inline]
    pub fn add_stages(
        &mut self,
        stages: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RetroStageOverrideInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroStageTable::VT_STAGES,
            stages,
        );
    }
    #[inline]
    pub fn add_retroActList(
        &mut self,
        retroActList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RetroActData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroStageTable::VT_RETROACTLIST,
            retroActList,
        );
    }
    #[inline]
    pub fn add_retroTrailList(
        &mut self,
        retroTrailList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_RetroTrailData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroStageTable::VT_RETROTRAILLIST,
            retroTrailList,
        );
    }
    #[inline]
    pub fn add_stageList(
        &mut self,
        stageList: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_StageData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroStageTable::VT_STAGELIST,
            stageList,
        );
    }
    #[inline]
    pub fn add_ruleData(
        &mut self,
        ruleData: flatbuffers::WIPOffset<clz_Torappu_RetroTrailRuleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_RetroTrailRuleData>>(
                clz_Torappu_RetroStageTable::VT_RULEDATA,
                ruleData,
            );
    }
    #[inline]
    pub fn add_customData(
        &mut self,
        customData: flatbuffers::WIPOffset<clz_Torappu_ActivityCustomData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ActivityCustomData>>(
                clz_Torappu_RetroStageTable::VT_CUSTOMDATA,
                customData,
            );
    }
    #[inline]
    pub fn add_initRetroCoin(&mut self, initRetroCoin: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RetroStageTable::VT_INITRETROCOIN,
            initRetroCoin,
            0,
        );
    }
    #[inline]
    pub fn add_retroCoinPerWeek(&mut self, retroCoinPerWeek: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RetroStageTable::VT_RETROCOINPERWEEK,
            retroCoinPerWeek,
            0,
        );
    }
    #[inline]
    pub fn add_retroCoinMaxOfLevels(
        &mut self,
        retroCoinMaxOfLevels: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__int__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroStageTable::VT_RETROCOINMAXOFLEVELS,
            retroCoinMaxOfLevels,
        );
    }
    #[inline]
    pub fn add_retroUnlockCost(&mut self, retroUnlockCost: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_RetroStageTable::VT_RETROUNLOCKCOST,
            retroUnlockCost,
            0,
        );
    }
    #[inline]
    pub fn add_retroDetail(&mut self, retroDetail: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_RetroStageTable::VT_RETRODETAIL,
            retroDetail,
        );
    }
    #[inline]
    pub fn add_retroPreShowTime(&mut self, retroPreShowTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_RetroStageTable::VT_RETROPRESHOWTIME,
            retroPreShowTime,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_RetroStageTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_RetroStageTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_RetroStageTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_RetroStageTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_RetroStageTable");
        ds.field("zoneToRetro", &self.zoneToRetro());
        ds.field("stageValidInfo", &self.stageValidInfo());
        ds.field("stages", &self.stages());
        ds.field("retroActList", &self.retroActList());
        ds.field("retroTrailList", &self.retroTrailList());
        ds.field("stageList", &self.stageList());
        ds.field("ruleData", &self.ruleData());
        ds.field("customData", &self.customData());
        ds.field("initRetroCoin", &self.initRetroCoin());
        ds.field("retroCoinPerWeek", &self.retroCoinPerWeek());
        ds.field("retroCoinMaxOfLevels", &self.retroCoinMaxOfLevels());
        ds.field("retroUnlockCost", &self.retroUnlockCost());
        ds.field("retroDetail", &self.retroDetail());
        ds.field("retroPreShowTime", &self.retroPreShowTime());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_RetroStageTableT {
    pub zoneToRetro: Option<Vec<dict__string__stringT>>,
    pub stageValidInfo: Option<Vec<dict__string__clz_Torappu_StageValidInfoT>>,
    pub stages: Option<Vec<dict__string__clz_Torappu_RetroStageOverrideInfoT>>,
    pub retroActList: Option<Vec<dict__string__clz_Torappu_RetroActDataT>>,
    pub retroTrailList: Option<Vec<dict__string__clz_Torappu_RetroTrailDataT>>,
    pub stageList: Option<Vec<dict__string__clz_Torappu_StageDataT>>,
    pub ruleData: Option<Box<clz_Torappu_RetroTrailRuleDataT>>,
    pub customData: Option<Box<clz_Torappu_ActivityCustomDataT>>,
    pub initRetroCoin: i32,
    pub retroCoinPerWeek: i32,
    pub retroCoinMaxOfLevels: Option<Vec<dict__int__intT>>,
    pub retroUnlockCost: i32,
    pub retroDetail: Option<String>,
    pub retroPreShowTime: i64,
}
impl Default for clz_Torappu_RetroStageTableT {
    fn default() -> Self {
        Self {
            zoneToRetro: None,
            stageValidInfo: None,
            stages: None,
            retroActList: None,
            retroTrailList: None,
            stageList: None,
            ruleData: None,
            customData: None,
            initRetroCoin: 0,
            retroCoinPerWeek: 0,
            retroCoinMaxOfLevels: None,
            retroUnlockCost: 0,
            retroDetail: None,
            retroPreShowTime: 0,
        }
    }
}
impl clz_Torappu_RetroStageTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_RetroStageTable<'b>> {
        let zoneToRetro = self.zoneToRetro.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let stageValidInfo = self.stageValidInfo.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let stages = self.stages.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let retroActList = self.retroActList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let retroTrailList = self.retroTrailList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let stageList = self.stageList.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let ruleData = self.ruleData.as_ref().map(|x| x.pack(_fbb));
        let customData = self.customData.as_ref().map(|x| x.pack(_fbb));
        let initRetroCoin = self.initRetroCoin;
        let retroCoinPerWeek = self.retroCoinPerWeek;
        let retroCoinMaxOfLevels = self.retroCoinMaxOfLevels.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let retroUnlockCost = self.retroUnlockCost;
        let retroDetail = self.retroDetail.as_ref().map(|x| _fbb.create_string(x));
        let retroPreShowTime = self.retroPreShowTime;
        clz_Torappu_RetroStageTable::create(
            _fbb,
            &clz_Torappu_RetroStageTableArgs {
                zoneToRetro,
                stageValidInfo,
                stages,
                retroActList,
                retroTrailList,
                stageList,
                ruleData,
                customData,
                initRetroCoin,
                retroCoinPerWeek,
                retroCoinMaxOfLevels,
                retroUnlockCost,
                retroDetail,
                retroPreShowTime,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_RetroStageTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_retro_stage_table_unchecked`.
pub fn root_as_clz_torappu_retro_stage_table(
    buf: &[u8],
) -> Result<clz_Torappu_RetroStageTable<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_RetroStageTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_RetroStageTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_retro_stage_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_retro_stage_table(
    buf: &[u8],
) -> Result<clz_Torappu_RetroStageTable<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_RetroStageTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_RetroStageTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_retro_stage_table_unchecked`.
pub fn root_as_clz_torappu_retro_stage_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_RetroStageTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_RetroStageTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_RetroStageTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_retro_stage_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_retro_stage_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_RetroStageTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_RetroStageTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_RetroStageTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_RetroStageTable`.
pub unsafe fn root_as_clz_torappu_retro_stage_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_RetroStageTable<'_> {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_RetroStageTable>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_RetroStageTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_RetroStageTable`.
pub unsafe fn size_prefixed_root_as_clz_torappu_retro_stage_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_RetroStageTable<'_> {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_RetroStageTable>(buf) }
}
#[inline]
pub fn finish_clz_torappu_retro_stage_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_RetroStageTable<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_retro_stage_table_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_RetroStageTable<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
