// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate serde;
use self::serde::ser::{Serialize, SerializeStruct, Serializer};

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_TIP_DATA_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_TIP_DATA_CATEGORY: i32 = 31;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_TIP_DATA_CATEGORY: [enum__Torappu_TipData_Category; 7] = [
    enum__Torappu_TipData_Category::NONE,
    enum__Torappu_TipData_Category::BATTLE,
    enum__Torappu_TipData_Category::UI,
    enum__Torappu_TipData_Category::BUILDING,
    enum__Torappu_TipData_Category::GACHA,
    enum__Torappu_TipData_Category::MISC,
    enum__Torappu_TipData_Category::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_TipData_Category(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_TipData_Category {
    pub const NONE: Self = Self(0);
    pub const BATTLE: Self = Self(1);
    pub const UI: Self = Self(2);
    pub const BUILDING: Self = Self(4);
    pub const GACHA: Self = Self(8);
    pub const MISC: Self = Self(16);
    pub const ALL: Self = Self(31);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 31;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::BATTLE,
        Self::UI,
        Self::BUILDING,
        Self::GACHA,
        Self::MISC,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::BATTLE => Some("BATTLE"),
            Self::UI => Some("UI"),
            Self::BUILDING => Some("BUILDING"),
            Self::GACHA => Some("GACHA"),
            Self::MISC => Some("MISC"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_TipData_Category {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl Serialize for enum__Torappu_TipData_Category {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_unit_variant(
            "enum__Torappu_TipData_Category",
            self.0 as u32,
            self.variant_name().unwrap(),
        )
    }
}

impl<'a> flatbuffers::Follow<'a> for enum__Torappu_TipData_Category {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_TipData_Category {
    type Output = enum__Torappu_TipData_Category;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_TipData_Category {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_TipData_Category {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_TipData_Category {}
pub enum clz_Torappu_TipDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TipData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TipData<'a> {
    type Inner = clz_Torappu_TipData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_TipData<'a> {
    pub const VT_TIP: flatbuffers::VOffsetT = 4;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 6;
    pub const VT_CATEGORY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TipData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TipDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'bldr>> {
        let mut builder = clz_Torappu_TipDataBuilder::new(_fbb);
        builder.add_category(args.category);
        builder.add_weight(args.weight);
        if let Some(x) = args.tip {
            builder.add_tip(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_TipDataT {
        let tip = self.tip().map(|x| x.to_string());
        let weight = self.weight();
        let category = self.category();
        clz_Torappu_TipDataT {
            tip,
            weight,
            category,
        }
    }

    #[inline]
    pub fn tip(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_TipData::VT_TIP, None)
        }
    }
    #[inline]
    pub fn weight(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_TipData::VT_WEIGHT, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn category(&self) -> enum__Torappu_TipData_Category {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_TipData_Category>(
                    clz_Torappu_TipData::VT_CATEGORY,
                    Some(enum__Torappu_TipData_Category::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TipData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tip", Self::VT_TIP, false)?
            .visit_field::<f32>("weight", Self::VT_WEIGHT, false)?
            .visit_field::<enum__Torappu_TipData_Category>("category", Self::VT_CATEGORY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TipDataArgs<'a> {
    pub tip: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weight: f32,
    pub category: enum__Torappu_TipData_Category,
}
impl<'a> Default for clz_Torappu_TipDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TipDataArgs {
            tip: None,
            weight: 0.0,
            category: enum__Torappu_TipData_Category::NONE,
        }
    }
}

impl Serialize for clz_Torappu_TipData<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_TipData", 3)?;
        if let Some(f) = self.tip() {
            s.serialize_field("tip", &f)?;
        } else {
            s.skip_field("tip")?;
        }
        s.serialize_field("weight", &self.weight())?;
        s.serialize_field("category", &self.category())?;
        s.end()
    }
}

pub struct clz_Torappu_TipDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TipDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_tip(&mut self, tip: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_TipData::VT_TIP, tip);
    }
    #[inline]
    pub fn add_weight(&mut self, weight: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_TipData::VT_WEIGHT, weight, 0.0);
    }
    #[inline]
    pub fn add_category(&mut self, category: enum__Torappu_TipData_Category) {
        self.fbb_.push_slot::<enum__Torappu_TipData_Category>(
            clz_Torappu_TipData::VT_CATEGORY,
            category,
            enum__Torappu_TipData_Category::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TipDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TipDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TipData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TipData");
        ds.field("tip", &self.tip());
        ds.field("weight", &self.weight());
        ds.field("category", &self.category());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_TipDataT {
    pub tip: Option<String>,
    pub weight: f32,
    pub category: enum__Torappu_TipData_Category,
}
impl Default for clz_Torappu_TipDataT {
    fn default() -> Self {
        Self {
            tip: None,
            weight: 0.0,
            category: enum__Torappu_TipData_Category::NONE,
        }
    }
}
impl clz_Torappu_TipDataT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TipData<'b>> {
        let tip = self.tip.as_ref().map(|x| _fbb.create_string(x));
        let weight = self.weight;
        let category = self.category;
        clz_Torappu_TipData::create(
            _fbb,
            &clz_Torappu_TipDataArgs {
                tip,
                weight,
                category,
            },
        )
    }
}
pub enum clz_Torappu_WorldViewTipOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_WorldViewTip<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_WorldViewTip<'a> {
    type Inner = clz_Torappu_WorldViewTip<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_WorldViewTip<'a> {
    pub const VT_TITLE: flatbuffers::VOffsetT = 4;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
    pub const VT_BACKGROUNDPICID: flatbuffers::VOffsetT = 8;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_WorldViewTip { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_WorldViewTipArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_WorldViewTip<'bldr>> {
        let mut builder = clz_Torappu_WorldViewTipBuilder::new(_fbb);
        builder.add_weight(args.weight);
        if let Some(x) = args.backgroundPicId {
            builder.add_backgroundPicId(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.title {
            builder.add_title(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_WorldViewTipT {
        let title = self.title().map(|x| x.to_string());
        let description = self.description().map(|x| x.to_string());
        let backgroundPicId = self.backgroundPicId().map(|x| x.to_string());
        let weight = self.weight();
        clz_Torappu_WorldViewTipT {
            title,
            description,
            backgroundPicId,
            weight,
        }
    }

    #[inline]
    pub fn title(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_WorldViewTip::VT_TITLE, None)
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_WorldViewTip::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn backgroundPicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_WorldViewTip::VT_BACKGROUNDPICID,
                None,
            )
        }
    }
    #[inline]
    pub fn weight(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_WorldViewTip::VT_WEIGHT, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_WorldViewTip<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "backgroundPicId",
                Self::VT_BACKGROUNDPICID,
                false,
            )?
            .visit_field::<f32>("weight", Self::VT_WEIGHT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_WorldViewTipArgs<'a> {
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub backgroundPicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub weight: f32,
}
impl<'a> Default for clz_Torappu_WorldViewTipArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_WorldViewTipArgs {
            title: None,
            description: None,
            backgroundPicId: None,
            weight: 0.0,
        }
    }
}

impl Serialize for clz_Torappu_WorldViewTip<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_WorldViewTip", 4)?;
        if let Some(f) = self.title() {
            s.serialize_field("title", &f)?;
        } else {
            s.skip_field("title")?;
        }
        if let Some(f) = self.description() {
            s.serialize_field("description", &f)?;
        } else {
            s.skip_field("description")?;
        }
        if let Some(f) = self.backgroundPicId() {
            s.serialize_field("backgroundPicId", &f)?;
        } else {
            s.skip_field("backgroundPicId")?;
        }
        s.serialize_field("weight", &self.weight())?;
        s.end()
    }
}

pub struct clz_Torappu_WorldViewTipBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_WorldViewTipBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_WorldViewTip::VT_TITLE,
            title,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_WorldViewTip::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_backgroundPicId(&mut self, backgroundPicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_WorldViewTip::VT_BACKGROUNDPICID,
            backgroundPicId,
        );
    }
    #[inline]
    pub fn add_weight(&mut self, weight: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_WorldViewTip::VT_WEIGHT, weight, 0.0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_WorldViewTipBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_WorldViewTipBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_WorldViewTip<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_WorldViewTip<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_WorldViewTip");
        ds.field("title", &self.title());
        ds.field("description", &self.description());
        ds.field("backgroundPicId", &self.backgroundPicId());
        ds.field("weight", &self.weight());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_WorldViewTipT {
    pub title: Option<String>,
    pub description: Option<String>,
    pub backgroundPicId: Option<String>,
    pub weight: f32,
}
impl Default for clz_Torappu_WorldViewTipT {
    fn default() -> Self {
        Self {
            title: None,
            description: None,
            backgroundPicId: None,
            weight: 0.0,
        }
    }
}
impl clz_Torappu_WorldViewTipT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_WorldViewTip<'b>> {
        let title = self.title.as_ref().map(|x| _fbb.create_string(x));
        let description = self.description.as_ref().map(|x| _fbb.create_string(x));
        let backgroundPicId = self.backgroundPicId.as_ref().map(|x| _fbb.create_string(x));
        let weight = self.weight;
        clz_Torappu_WorldViewTip::create(
            _fbb,
            &clz_Torappu_WorldViewTipArgs {
                title,
                description,
                backgroundPicId,
                weight,
            },
        )
    }
}
pub enum clz_Torappu_TipTableOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_TipTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_TipTable<'a> {
    type Inner = clz_Torappu_TipTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: unsafe { flatbuffers::Table::new(buf, loc) },
        }
    }
}

impl<'a> clz_Torappu_TipTable<'a> {
    pub const VT_TIPS: flatbuffers::VOffsetT = 4;
    pub const VT_WORLDVIEWTIPS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_TipTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_TipTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TipTable<'bldr>> {
        let mut builder = clz_Torappu_TipTableBuilder::new(_fbb);
        if let Some(x) = args.worldViewTips {
            builder.add_worldViewTips(x);
        }
        if let Some(x) = args.tips {
            builder.add_tips(x);
        }
        builder.finish()
    }

    pub fn unpack(&self) -> clz_Torappu_TipTableT {
        let tips = self.tips().map(|x| x.iter().map(|t| t.unpack()).collect());
        let worldViewTips = self
            .worldViewTips()
            .map(|x| x.iter().map(|t| t.unpack()).collect());
        clz_Torappu_TipTableT {
            tips,
            worldViewTips,
        }
    }

    #[inline]
    pub fn tips(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData>>,
            >>(clz_Torappu_TipTable::VT_TIPS, None)
        }
    }
    #[inline]
    pub fn worldViewTips(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_WorldViewTip<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_WorldViewTip>>,
            >>(clz_Torappu_TipTable::VT_WORLDVIEWTIPS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_TipTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_TipData>>,
            >>("tips", Self::VT_TIPS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_WorldViewTip>>,
            >>("worldViewTips", Self::VT_WORLDVIEWTIPS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_TipTableArgs<'a> {
    pub tips: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'a>>>,
        >,
    >,
    pub worldViewTips: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_WorldViewTip<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_TipTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_TipTableArgs {
            tips: None,
            worldViewTips: None,
        }
    }
}

impl Serialize for clz_Torappu_TipTable<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("clz_Torappu_TipTable", 2)?;
        if let Some(f) = self.tips() {
            s.serialize_field("tips", &f)?;
        } else {
            s.skip_field("tips")?;
        }
        if let Some(f) = self.worldViewTips() {
            s.serialize_field("worldViewTips", &f)?;
        } else {
            s.skip_field("worldViewTips")?;
        }
        s.end()
    }
}

pub struct clz_Torappu_TipTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_TipTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_tips(
        &mut self,
        tips: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_TipData<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_TipTable::VT_TIPS, tips);
    }
    #[inline]
    pub fn add_worldViewTips(
        &mut self,
        worldViewTips: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_WorldViewTip<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_TipTable::VT_WORLDVIEWTIPS,
            worldViewTips,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_TipTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_TipTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_TipTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_TipTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_TipTable");
        ds.field("tips", &self.tips());
        ds.field("worldViewTips", &self.worldViewTips());
        ds.finish()
    }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct clz_Torappu_TipTableT {
    pub tips: Option<Vec<clz_Torappu_TipDataT>>,
    pub worldViewTips: Option<Vec<clz_Torappu_WorldViewTipT>>,
}
impl Default for clz_Torappu_TipTableT {
    fn default() -> Self {
        Self {
            tips: None,
            worldViewTips: None,
        }
    }
}
impl clz_Torappu_TipTableT {
    pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
        &self,
        _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_TipTable<'b>> {
        let tips = self.tips.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        let worldViewTips = self.worldViewTips.as_ref().map(|x| {
            let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
            _fbb.create_vector(&w)
        });
        clz_Torappu_TipTable::create(
            _fbb,
            &clz_Torappu_TipTableArgs {
                tips,
                worldViewTips,
            },
        )
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_TipTable`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_tip_table_unchecked`.
pub fn root_as_clz_torappu_tip_table(
    buf: &[u8],
) -> Result<clz_Torappu_TipTable<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_TipTable>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_TipTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_tip_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_tip_table(
    buf: &[u8],
) -> Result<clz_Torappu_TipTable<'_>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_TipTable>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_TipTable` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_tip_table_unchecked`.
pub fn root_as_clz_torappu_tip_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_TipTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_TipTable<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_TipTable` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_tip_table_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_tip_table_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_TipTable<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_TipTable<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_TipTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_TipTable`.
pub unsafe fn root_as_clz_torappu_tip_table_unchecked(buf: &[u8]) -> clz_Torappu_TipTable<'_> {
    unsafe { flatbuffers::root_unchecked::<clz_Torappu_TipTable>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_TipTable and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_TipTable`.
pub unsafe fn size_prefixed_root_as_clz_torappu_tip_table_unchecked(
    buf: &[u8],
) -> clz_Torappu_TipTable<'_> {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_TipTable>(buf) }
}
#[inline]
pub fn finish_clz_torappu_tip_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_TipTable<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_tip_table_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_TipTable<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
