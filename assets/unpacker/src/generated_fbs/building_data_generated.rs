// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDING_DATA_ROOM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDING_DATA_ROOM_TYPE: i32 = 8191;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDING_DATA_ROOM_TYPE: [enum__Torappu_BuildingData_RoomType;
    16] = [
    enum__Torappu_BuildingData_RoomType::NONE,
    enum__Torappu_BuildingData_RoomType::CONTROL,
    enum__Torappu_BuildingData_RoomType::POWER,
    enum__Torappu_BuildingData_RoomType::MANUFACTURE,
    enum__Torappu_BuildingData_RoomType::SHOP,
    enum__Torappu_BuildingData_RoomType::DORMITORY,
    enum__Torappu_BuildingData_RoomType::MEETING,
    enum__Torappu_BuildingData_RoomType::HIRE,
    enum__Torappu_BuildingData_RoomType::ELEVATOR,
    enum__Torappu_BuildingData_RoomType::CORRIDOR,
    enum__Torappu_BuildingData_RoomType::TRADING,
    enum__Torappu_BuildingData_RoomType::WORKSHOP,
    enum__Torappu_BuildingData_RoomType::TRAINING,
    enum__Torappu_BuildingData_RoomType::FUNCTIONAL,
    enum__Torappu_BuildingData_RoomType::PRIVATE,
    enum__Torappu_BuildingData_RoomType::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildingData_RoomType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildingData_RoomType {
    pub const NONE: Self = Self(0);
    pub const CONTROL: Self = Self(1);
    pub const POWER: Self = Self(2);
    pub const MANUFACTURE: Self = Self(4);
    pub const SHOP: Self = Self(8);
    pub const DORMITORY: Self = Self(16);
    pub const MEETING: Self = Self(32);
    pub const HIRE: Self = Self(64);
    pub const ELEVATOR: Self = Self(128);
    pub const CORRIDOR: Self = Self(256);
    pub const TRADING: Self = Self(512);
    pub const WORKSHOP: Self = Self(1024);
    pub const TRAINING: Self = Self(2048);
    pub const FUNCTIONAL: Self = Self(3710);
    pub const PRIVATE: Self = Self(4096);
    pub const ALL: Self = Self(8191);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 8191;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CONTROL,
        Self::POWER,
        Self::MANUFACTURE,
        Self::SHOP,
        Self::DORMITORY,
        Self::MEETING,
        Self::HIRE,
        Self::ELEVATOR,
        Self::CORRIDOR,
        Self::TRADING,
        Self::WORKSHOP,
        Self::TRAINING,
        Self::FUNCTIONAL,
        Self::PRIVATE,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CONTROL => Some("CONTROL"),
            Self::POWER => Some("POWER"),
            Self::MANUFACTURE => Some("MANUFACTURE"),
            Self::SHOP => Some("SHOP"),
            Self::DORMITORY => Some("DORMITORY"),
            Self::MEETING => Some("MEETING"),
            Self::HIRE => Some("HIRE"),
            Self::ELEVATOR => Some("ELEVATOR"),
            Self::CORRIDOR => Some("CORRIDOR"),
            Self::TRADING => Some("TRADING"),
            Self::WORKSHOP => Some("WORKSHOP"),
            Self::TRAINING => Some("TRAINING"),
            Self::FUNCTIONAL => Some("FUNCTIONAL"),
            Self::PRIVATE => Some("PRIVATE"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildingData_RoomType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildingData_RoomType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildingData_RoomType {
    type Output = enum__Torappu_BuildingData_RoomType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildingData_RoomType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildingData_RoomType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildingData_RoomType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDING_DATA_ROOM_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDING_DATA_ROOM_CATEGORY: i32 = 511;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDING_DATA_ROOM_CATEGORY:
    [enum__Torappu_BuildingData_RoomCategory; 11] = [
    enum__Torappu_BuildingData_RoomCategory::NONE,
    enum__Torappu_BuildingData_RoomCategory::FUNCTION,
    enum__Torappu_BuildingData_RoomCategory::OUTPUT,
    enum__Torappu_BuildingData_RoomCategory::CUSTOM,
    enum__Torappu_BuildingData_RoomCategory::ELEVATOR,
    enum__Torappu_BuildingData_RoomCategory::CORRIDOR,
    enum__Torappu_BuildingData_RoomCategory::SPECIAL,
    enum__Torappu_BuildingData_RoomCategory::CUSTOM_P,
    enum__Torappu_BuildingData_RoomCategory::ELEVATOR_P,
    enum__Torappu_BuildingData_RoomCategory::CORRIDOR_P,
    enum__Torappu_BuildingData_RoomCategory::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildingData_RoomCategory(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildingData_RoomCategory {
    pub const NONE: Self = Self(0);
    pub const FUNCTION: Self = Self(1);
    pub const OUTPUT: Self = Self(2);
    pub const CUSTOM: Self = Self(4);
    pub const ELEVATOR: Self = Self(8);
    pub const CORRIDOR: Self = Self(16);
    pub const SPECIAL: Self = Self(32);
    pub const CUSTOM_P: Self = Self(64);
    pub const ELEVATOR_P: Self = Self(128);
    pub const CORRIDOR_P: Self = Self(256);
    pub const ALL: Self = Self(511);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 511;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::FUNCTION,
        Self::OUTPUT,
        Self::CUSTOM,
        Self::ELEVATOR,
        Self::CORRIDOR,
        Self::SPECIAL,
        Self::CUSTOM_P,
        Self::ELEVATOR_P,
        Self::CORRIDOR_P,
        Self::ALL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::FUNCTION => Some("FUNCTION"),
            Self::OUTPUT => Some("OUTPUT"),
            Self::CUSTOM => Some("CUSTOM"),
            Self::ELEVATOR => Some("ELEVATOR"),
            Self::CORRIDOR => Some("CORRIDOR"),
            Self::SPECIAL => Some("SPECIAL"),
            Self::CUSTOM_P => Some("CUSTOM_P"),
            Self::ELEVATOR_P => Some("ELEVATOR_P"),
            Self::CORRIDOR_P => Some("CORRIDOR_P"),
            Self::ALL => Some("ALL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildingData_RoomCategory {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildingData_RoomCategory {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildingData_RoomCategory {
    type Output = enum__Torappu_BuildingData_RoomCategory;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildingData_RoomCategory {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildingData_RoomCategory {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildingData_RoomCategory {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_TYPE: i32 = 90;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_TYPE: [enum__Torappu_ItemType; 91] = [
    enum__Torappu_ItemType::NONE,
    enum__Torappu_ItemType::CHAR,
    enum__Torappu_ItemType::CARD_EXP,
    enum__Torappu_ItemType::MATERIAL,
    enum__Torappu_ItemType::GOLD,
    enum__Torappu_ItemType::EXP_PLAYER,
    enum__Torappu_ItemType::TKT_TRY,
    enum__Torappu_ItemType::TKT_RECRUIT,
    enum__Torappu_ItemType::TKT_INST_FIN,
    enum__Torappu_ItemType::TKT_GACHA,
    enum__Torappu_ItemType::ACTIVITY_COIN,
    enum__Torappu_ItemType::DIAMOND,
    enum__Torappu_ItemType::DIAMOND_SHD,
    enum__Torappu_ItemType::HGG_SHD,
    enum__Torappu_ItemType::LGG_SHD,
    enum__Torappu_ItemType::FURN,
    enum__Torappu_ItemType::AP_GAMEPLAY,
    enum__Torappu_ItemType::AP_BASE,
    enum__Torappu_ItemType::SOCIAL_PT,
    enum__Torappu_ItemType::CHAR_SKIN,
    enum__Torappu_ItemType::TKT_GACHA_10,
    enum__Torappu_ItemType::TKT_GACHA_PRSV,
    enum__Torappu_ItemType::AP_ITEM,
    enum__Torappu_ItemType::AP_SUPPLY,
    enum__Torappu_ItemType::RENAMING_CARD,
    enum__Torappu_ItemType::RENAMING_CARD_2,
    enum__Torappu_ItemType::ET_STAGE,
    enum__Torappu_ItemType::ACTIVITY_ITEM,
    enum__Torappu_ItemType::VOUCHER_PICK,
    enum__Torappu_ItemType::VOUCHER_CGACHA,
    enum__Torappu_ItemType::VOUCHER_MGACHA,
    enum__Torappu_ItemType::CRS_SHOP_COIN,
    enum__Torappu_ItemType::CRS_RUNE_COIN,
    enum__Torappu_ItemType::LMTGS_COIN,
    enum__Torappu_ItemType::EPGS_COIN,
    enum__Torappu_ItemType::LIMITED_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_FREE_GACHA,
    enum__Torappu_ItemType::REP_COIN,
    enum__Torappu_ItemType::ROGUELIKE,
    enum__Torappu_ItemType::LINKAGE_TKT_GACHA_10,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_4,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_5,
    enum__Torappu_ItemType::VOUCHER_ELITE_II_6,
    enum__Torappu_ItemType::VOUCHER_SKIN,
    enum__Torappu_ItemType::RETRO_COIN,
    enum__Torappu_ItemType::PLAYER_AVATAR,
    enum__Torappu_ItemType::UNI_COLLECTION,
    enum__Torappu_ItemType::VOUCHER_FULL_POTENTIAL,
    enum__Torappu_ItemType::RL_COIN,
    enum__Torappu_ItemType::RETURN_CREDIT,
    enum__Torappu_ItemType::MEDAL,
    enum__Torappu_ItemType::CHARM,
    enum__Torappu_ItemType::HOME_BACKGROUND,
    enum__Torappu_ItemType::EXTERMINATION_AGENT,
    enum__Torappu_ItemType::OPTIONAL_VOUCHER_PICK,
    enum__Torappu_ItemType::ACT_CART_COMPONENT,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_LEVELMAX_4,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_6,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_5,
    enum__Torappu_ItemType::VOUCHER_SKILL_SPECIALLEVELMAX_4,
    enum__Torappu_ItemType::ACTIVITY_POTENTIAL,
    enum__Torappu_ItemType::ITEM_PACK,
    enum__Torappu_ItemType::SANDBOX,
    enum__Torappu_ItemType::FAVOR_ADD_ITEM,
    enum__Torappu_ItemType::CLASSIC_SHD,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA,
    enum__Torappu_ItemType::CLASSIC_TKT_GACHA_10,
    enum__Torappu_ItemType::LIMITED_BUFF,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_5,
    enum__Torappu_ItemType::CLASSIC_FES_PICK_TIER_6,
    enum__Torappu_ItemType::RETURN_PROGRESS,
    enum__Torappu_ItemType::NEW_PROGRESS,
    enum__Torappu_ItemType::MCARD_VOUCHER,
    enum__Torappu_ItemType::MATERIAL_ISSUE_VOUCHER,
    enum__Torappu_ItemType::CRS_SHOP_COIN_V2,
    enum__Torappu_ItemType::HOME_THEME,
    enum__Torappu_ItemType::SANDBOX_PERM,
    enum__Torappu_ItemType::SANDBOX_TOKEN,
    enum__Torappu_ItemType::TEMPLATE_TRAP,
    enum__Torappu_ItemType::NAME_CARD_SKIN,
    enum__Torappu_ItemType::EMOTICON_SET,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA,
    enum__Torappu_ItemType::EXCLUSIVE_TKT_GACHA_10,
    enum__Torappu_ItemType::SO_CHAR_EXP,
    enum__Torappu_ItemType::GIFTPACKAGE_TKT,
    enum__Torappu_ItemType::VOUCHER_SKIN_V2,
    enum__Torappu_ItemType::RANDOM_VOUCHER_SKIN,
    enum__Torappu_ItemType::ACT1VHALFIDLE_ITEM,
    enum__Torappu_ItemType::PLOT_ITEM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemType {
    pub const NONE: Self = Self(0);
    pub const CHAR: Self = Self(1);
    pub const CARD_EXP: Self = Self(2);
    pub const MATERIAL: Self = Self(3);
    pub const GOLD: Self = Self(4);
    pub const EXP_PLAYER: Self = Self(5);
    pub const TKT_TRY: Self = Self(6);
    pub const TKT_RECRUIT: Self = Self(7);
    pub const TKT_INST_FIN: Self = Self(8);
    pub const TKT_GACHA: Self = Self(9);
    pub const ACTIVITY_COIN: Self = Self(10);
    pub const DIAMOND: Self = Self(11);
    pub const DIAMOND_SHD: Self = Self(12);
    pub const HGG_SHD: Self = Self(13);
    pub const LGG_SHD: Self = Self(14);
    pub const FURN: Self = Self(15);
    pub const AP_GAMEPLAY: Self = Self(16);
    pub const AP_BASE: Self = Self(17);
    pub const SOCIAL_PT: Self = Self(18);
    pub const CHAR_SKIN: Self = Self(19);
    pub const TKT_GACHA_10: Self = Self(20);
    pub const TKT_GACHA_PRSV: Self = Self(21);
    pub const AP_ITEM: Self = Self(22);
    pub const AP_SUPPLY: Self = Self(23);
    pub const RENAMING_CARD: Self = Self(24);
    pub const RENAMING_CARD_2: Self = Self(25);
    pub const ET_STAGE: Self = Self(26);
    pub const ACTIVITY_ITEM: Self = Self(27);
    pub const VOUCHER_PICK: Self = Self(28);
    pub const VOUCHER_CGACHA: Self = Self(29);
    pub const VOUCHER_MGACHA: Self = Self(30);
    pub const CRS_SHOP_COIN: Self = Self(31);
    pub const CRS_RUNE_COIN: Self = Self(32);
    pub const LMTGS_COIN: Self = Self(33);
    pub const EPGS_COIN: Self = Self(34);
    pub const LIMITED_TKT_GACHA_10: Self = Self(35);
    pub const LIMITED_FREE_GACHA: Self = Self(36);
    pub const REP_COIN: Self = Self(37);
    pub const ROGUELIKE: Self = Self(38);
    pub const LINKAGE_TKT_GACHA_10: Self = Self(39);
    pub const VOUCHER_ELITE_II_4: Self = Self(40);
    pub const VOUCHER_ELITE_II_5: Self = Self(41);
    pub const VOUCHER_ELITE_II_6: Self = Self(42);
    pub const VOUCHER_SKIN: Self = Self(43);
    pub const RETRO_COIN: Self = Self(44);
    pub const PLAYER_AVATAR: Self = Self(45);
    pub const UNI_COLLECTION: Self = Self(46);
    pub const VOUCHER_FULL_POTENTIAL: Self = Self(47);
    pub const RL_COIN: Self = Self(48);
    pub const RETURN_CREDIT: Self = Self(49);
    pub const MEDAL: Self = Self(50);
    pub const CHARM: Self = Self(51);
    pub const HOME_BACKGROUND: Self = Self(52);
    pub const EXTERMINATION_AGENT: Self = Self(53);
    pub const OPTIONAL_VOUCHER_PICK: Self = Self(54);
    pub const ACT_CART_COMPONENT: Self = Self(55);
    pub const VOUCHER_LEVELMAX_6: Self = Self(56);
    pub const VOUCHER_LEVELMAX_5: Self = Self(57);
    pub const VOUCHER_LEVELMAX_4: Self = Self(58);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_6: Self = Self(59);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_5: Self = Self(60);
    pub const VOUCHER_SKILL_SPECIALLEVELMAX_4: Self = Self(61);
    pub const ACTIVITY_POTENTIAL: Self = Self(62);
    pub const ITEM_PACK: Self = Self(63);
    pub const SANDBOX: Self = Self(64);
    pub const FAVOR_ADD_ITEM: Self = Self(65);
    pub const CLASSIC_SHD: Self = Self(66);
    pub const CLASSIC_TKT_GACHA: Self = Self(67);
    pub const CLASSIC_TKT_GACHA_10: Self = Self(68);
    pub const LIMITED_BUFF: Self = Self(69);
    pub const CLASSIC_FES_PICK_TIER_5: Self = Self(70);
    pub const CLASSIC_FES_PICK_TIER_6: Self = Self(71);
    pub const RETURN_PROGRESS: Self = Self(72);
    pub const NEW_PROGRESS: Self = Self(73);
    pub const MCARD_VOUCHER: Self = Self(74);
    pub const MATERIAL_ISSUE_VOUCHER: Self = Self(75);
    pub const CRS_SHOP_COIN_V2: Self = Self(76);
    pub const HOME_THEME: Self = Self(77);
    pub const SANDBOX_PERM: Self = Self(78);
    pub const SANDBOX_TOKEN: Self = Self(79);
    pub const TEMPLATE_TRAP: Self = Self(80);
    pub const NAME_CARD_SKIN: Self = Self(81);
    pub const EMOTICON_SET: Self = Self(82);
    pub const EXCLUSIVE_TKT_GACHA: Self = Self(83);
    pub const EXCLUSIVE_TKT_GACHA_10: Self = Self(84);
    pub const SO_CHAR_EXP: Self = Self(85);
    pub const GIFTPACKAGE_TKT: Self = Self(86);
    pub const VOUCHER_SKIN_V2: Self = Self(87);
    pub const RANDOM_VOUCHER_SKIN: Self = Self(88);
    pub const ACT1VHALFIDLE_ITEM: Self = Self(89);
    pub const PLOT_ITEM: Self = Self(90);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 90;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CHAR,
        Self::CARD_EXP,
        Self::MATERIAL,
        Self::GOLD,
        Self::EXP_PLAYER,
        Self::TKT_TRY,
        Self::TKT_RECRUIT,
        Self::TKT_INST_FIN,
        Self::TKT_GACHA,
        Self::ACTIVITY_COIN,
        Self::DIAMOND,
        Self::DIAMOND_SHD,
        Self::HGG_SHD,
        Self::LGG_SHD,
        Self::FURN,
        Self::AP_GAMEPLAY,
        Self::AP_BASE,
        Self::SOCIAL_PT,
        Self::CHAR_SKIN,
        Self::TKT_GACHA_10,
        Self::TKT_GACHA_PRSV,
        Self::AP_ITEM,
        Self::AP_SUPPLY,
        Self::RENAMING_CARD,
        Self::RENAMING_CARD_2,
        Self::ET_STAGE,
        Self::ACTIVITY_ITEM,
        Self::VOUCHER_PICK,
        Self::VOUCHER_CGACHA,
        Self::VOUCHER_MGACHA,
        Self::CRS_SHOP_COIN,
        Self::CRS_RUNE_COIN,
        Self::LMTGS_COIN,
        Self::EPGS_COIN,
        Self::LIMITED_TKT_GACHA_10,
        Self::LIMITED_FREE_GACHA,
        Self::REP_COIN,
        Self::ROGUELIKE,
        Self::LINKAGE_TKT_GACHA_10,
        Self::VOUCHER_ELITE_II_4,
        Self::VOUCHER_ELITE_II_5,
        Self::VOUCHER_ELITE_II_6,
        Self::VOUCHER_SKIN,
        Self::RETRO_COIN,
        Self::PLAYER_AVATAR,
        Self::UNI_COLLECTION,
        Self::VOUCHER_FULL_POTENTIAL,
        Self::RL_COIN,
        Self::RETURN_CREDIT,
        Self::MEDAL,
        Self::CHARM,
        Self::HOME_BACKGROUND,
        Self::EXTERMINATION_AGENT,
        Self::OPTIONAL_VOUCHER_PICK,
        Self::ACT_CART_COMPONENT,
        Self::VOUCHER_LEVELMAX_6,
        Self::VOUCHER_LEVELMAX_5,
        Self::VOUCHER_LEVELMAX_4,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_6,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_5,
        Self::VOUCHER_SKILL_SPECIALLEVELMAX_4,
        Self::ACTIVITY_POTENTIAL,
        Self::ITEM_PACK,
        Self::SANDBOX,
        Self::FAVOR_ADD_ITEM,
        Self::CLASSIC_SHD,
        Self::CLASSIC_TKT_GACHA,
        Self::CLASSIC_TKT_GACHA_10,
        Self::LIMITED_BUFF,
        Self::CLASSIC_FES_PICK_TIER_5,
        Self::CLASSIC_FES_PICK_TIER_6,
        Self::RETURN_PROGRESS,
        Self::NEW_PROGRESS,
        Self::MCARD_VOUCHER,
        Self::MATERIAL_ISSUE_VOUCHER,
        Self::CRS_SHOP_COIN_V2,
        Self::HOME_THEME,
        Self::SANDBOX_PERM,
        Self::SANDBOX_TOKEN,
        Self::TEMPLATE_TRAP,
        Self::NAME_CARD_SKIN,
        Self::EMOTICON_SET,
        Self::EXCLUSIVE_TKT_GACHA,
        Self::EXCLUSIVE_TKT_GACHA_10,
        Self::SO_CHAR_EXP,
        Self::GIFTPACKAGE_TKT,
        Self::VOUCHER_SKIN_V2,
        Self::RANDOM_VOUCHER_SKIN,
        Self::ACT1VHALFIDLE_ITEM,
        Self::PLOT_ITEM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CHAR => Some("CHAR"),
            Self::CARD_EXP => Some("CARD_EXP"),
            Self::MATERIAL => Some("MATERIAL"),
            Self::GOLD => Some("GOLD"),
            Self::EXP_PLAYER => Some("EXP_PLAYER"),
            Self::TKT_TRY => Some("TKT_TRY"),
            Self::TKT_RECRUIT => Some("TKT_RECRUIT"),
            Self::TKT_INST_FIN => Some("TKT_INST_FIN"),
            Self::TKT_GACHA => Some("TKT_GACHA"),
            Self::ACTIVITY_COIN => Some("ACTIVITY_COIN"),
            Self::DIAMOND => Some("DIAMOND"),
            Self::DIAMOND_SHD => Some("DIAMOND_SHD"),
            Self::HGG_SHD => Some("HGG_SHD"),
            Self::LGG_SHD => Some("LGG_SHD"),
            Self::FURN => Some("FURN"),
            Self::AP_GAMEPLAY => Some("AP_GAMEPLAY"),
            Self::AP_BASE => Some("AP_BASE"),
            Self::SOCIAL_PT => Some("SOCIAL_PT"),
            Self::CHAR_SKIN => Some("CHAR_SKIN"),
            Self::TKT_GACHA_10 => Some("TKT_GACHA_10"),
            Self::TKT_GACHA_PRSV => Some("TKT_GACHA_PRSV"),
            Self::AP_ITEM => Some("AP_ITEM"),
            Self::AP_SUPPLY => Some("AP_SUPPLY"),
            Self::RENAMING_CARD => Some("RENAMING_CARD"),
            Self::RENAMING_CARD_2 => Some("RENAMING_CARD_2"),
            Self::ET_STAGE => Some("ET_STAGE"),
            Self::ACTIVITY_ITEM => Some("ACTIVITY_ITEM"),
            Self::VOUCHER_PICK => Some("VOUCHER_PICK"),
            Self::VOUCHER_CGACHA => Some("VOUCHER_CGACHA"),
            Self::VOUCHER_MGACHA => Some("VOUCHER_MGACHA"),
            Self::CRS_SHOP_COIN => Some("CRS_SHOP_COIN"),
            Self::CRS_RUNE_COIN => Some("CRS_RUNE_COIN"),
            Self::LMTGS_COIN => Some("LMTGS_COIN"),
            Self::EPGS_COIN => Some("EPGS_COIN"),
            Self::LIMITED_TKT_GACHA_10 => Some("LIMITED_TKT_GACHA_10"),
            Self::LIMITED_FREE_GACHA => Some("LIMITED_FREE_GACHA"),
            Self::REP_COIN => Some("REP_COIN"),
            Self::ROGUELIKE => Some("ROGUELIKE"),
            Self::LINKAGE_TKT_GACHA_10 => Some("LINKAGE_TKT_GACHA_10"),
            Self::VOUCHER_ELITE_II_4 => Some("VOUCHER_ELITE_II_4"),
            Self::VOUCHER_ELITE_II_5 => Some("VOUCHER_ELITE_II_5"),
            Self::VOUCHER_ELITE_II_6 => Some("VOUCHER_ELITE_II_6"),
            Self::VOUCHER_SKIN => Some("VOUCHER_SKIN"),
            Self::RETRO_COIN => Some("RETRO_COIN"),
            Self::PLAYER_AVATAR => Some("PLAYER_AVATAR"),
            Self::UNI_COLLECTION => Some("UNI_COLLECTION"),
            Self::VOUCHER_FULL_POTENTIAL => Some("VOUCHER_FULL_POTENTIAL"),
            Self::RL_COIN => Some("RL_COIN"),
            Self::RETURN_CREDIT => Some("RETURN_CREDIT"),
            Self::MEDAL => Some("MEDAL"),
            Self::CHARM => Some("CHARM"),
            Self::HOME_BACKGROUND => Some("HOME_BACKGROUND"),
            Self::EXTERMINATION_AGENT => Some("EXTERMINATION_AGENT"),
            Self::OPTIONAL_VOUCHER_PICK => Some("OPTIONAL_VOUCHER_PICK"),
            Self::ACT_CART_COMPONENT => Some("ACT_CART_COMPONENT"),
            Self::VOUCHER_LEVELMAX_6 => Some("VOUCHER_LEVELMAX_6"),
            Self::VOUCHER_LEVELMAX_5 => Some("VOUCHER_LEVELMAX_5"),
            Self::VOUCHER_LEVELMAX_4 => Some("VOUCHER_LEVELMAX_4"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_6 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_6"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_5 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_5"),
            Self::VOUCHER_SKILL_SPECIALLEVELMAX_4 => Some("VOUCHER_SKILL_SPECIALLEVELMAX_4"),
            Self::ACTIVITY_POTENTIAL => Some("ACTIVITY_POTENTIAL"),
            Self::ITEM_PACK => Some("ITEM_PACK"),
            Self::SANDBOX => Some("SANDBOX"),
            Self::FAVOR_ADD_ITEM => Some("FAVOR_ADD_ITEM"),
            Self::CLASSIC_SHD => Some("CLASSIC_SHD"),
            Self::CLASSIC_TKT_GACHA => Some("CLASSIC_TKT_GACHA"),
            Self::CLASSIC_TKT_GACHA_10 => Some("CLASSIC_TKT_GACHA_10"),
            Self::LIMITED_BUFF => Some("LIMITED_BUFF"),
            Self::CLASSIC_FES_PICK_TIER_5 => Some("CLASSIC_FES_PICK_TIER_5"),
            Self::CLASSIC_FES_PICK_TIER_6 => Some("CLASSIC_FES_PICK_TIER_6"),
            Self::RETURN_PROGRESS => Some("RETURN_PROGRESS"),
            Self::NEW_PROGRESS => Some("NEW_PROGRESS"),
            Self::MCARD_VOUCHER => Some("MCARD_VOUCHER"),
            Self::MATERIAL_ISSUE_VOUCHER => Some("MATERIAL_ISSUE_VOUCHER"),
            Self::CRS_SHOP_COIN_V2 => Some("CRS_SHOP_COIN_V2"),
            Self::HOME_THEME => Some("HOME_THEME"),
            Self::SANDBOX_PERM => Some("SANDBOX_PERM"),
            Self::SANDBOX_TOKEN => Some("SANDBOX_TOKEN"),
            Self::TEMPLATE_TRAP => Some("TEMPLATE_TRAP"),
            Self::NAME_CARD_SKIN => Some("NAME_CARD_SKIN"),
            Self::EMOTICON_SET => Some("EMOTICON_SET"),
            Self::EXCLUSIVE_TKT_GACHA => Some("EXCLUSIVE_TKT_GACHA"),
            Self::EXCLUSIVE_TKT_GACHA_10 => Some("EXCLUSIVE_TKT_GACHA_10"),
            Self::SO_CHAR_EXP => Some("SO_CHAR_EXP"),
            Self::GIFTPACKAGE_TKT => Some("GIFTPACKAGE_TKT"),
            Self::VOUCHER_SKIN_V2 => Some("VOUCHER_SKIN_V2"),
            Self::RANDOM_VOUCHER_SKIN => Some("RANDOM_VOUCHER_SKIN"),
            Self::ACT1VHALFIDLE_ITEM => Some("ACT1VHALFIDLE_ITEM"),
            Self::PLOT_ITEM => Some("PLOT_ITEM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemType {
    type Output = enum__Torappu_ItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDING_DATA_LAYOUT_DATA_STOREY_DATA_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDING_DATA_LAYOUT_DATA_STOREY_DATA_TYPE: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDING_DATA_LAYOUT_DATA_STOREY_DATA_TYPE:
    [enum__Torappu_BuildingData_LayoutData_StoreyData_Type; 2] = [
    enum__Torappu_BuildingData_LayoutData_StoreyData_Type::UPGROUND,
    enum__Torappu_BuildingData_LayoutData_StoreyData_Type::DOWNGROUND,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildingData_LayoutData_StoreyData_Type(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildingData_LayoutData_StoreyData_Type {
    pub const UPGROUND: Self = Self(0);
    pub const DOWNGROUND: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::UPGROUND, Self::DOWNGROUND];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::UPGROUND => Some("UPGROUND"),
            Self::DOWNGROUND => Some("DOWNGROUND"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildingData_LayoutData_StoreyData_Type {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildingData_LayoutData_StoreyData_Type {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildingData_LayoutData_StoreyData_Type {
    type Output = enum__Torappu_BuildingData_LayoutData_StoreyData_Type;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildingData_LayoutData_StoreyData_Type {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildingData_LayoutData_StoreyData_Type {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildingData_LayoutData_StoreyData_Type {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_EVOLVE_PHASE: i32 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_EVOLVE_PHASE: [enum__Torappu_EvolvePhase; 5] = [
    enum__Torappu_EvolvePhase::PHASE_0,
    enum__Torappu_EvolvePhase::PHASE_1,
    enum__Torappu_EvolvePhase::PHASE_2,
    enum__Torappu_EvolvePhase::PHASE_3,
    enum__Torappu_EvolvePhase::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_EvolvePhase(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_EvolvePhase {
    pub const PHASE_0: Self = Self(0);
    pub const PHASE_1: Self = Self(1);
    pub const PHASE_2: Self = Self(2);
    pub const PHASE_3: Self = Self(3);
    pub const E_NUM: Self = Self(4);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::PHASE_0,
        Self::PHASE_1,
        Self::PHASE_2,
        Self::PHASE_3,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::PHASE_0 => Some("PHASE_0"),
            Self::PHASE_1 => Some("PHASE_1"),
            Self::PHASE_2 => Some("PHASE_2"),
            Self::PHASE_3 => Some("PHASE_3"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_EvolvePhase {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_EvolvePhase {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_EvolvePhase {
    type Output = enum__Torappu_EvolvePhase;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_EvolvePhase {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_EvolvePhase {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_EvolvePhase {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDING_DATA_BUFF_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDING_DATA_BUFF_CATEGORY: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDING_DATA_BUFF_CATEGORY:
    [enum__Torappu_BuildingData_BuffCategory; 4] = [
    enum__Torappu_BuildingData_BuffCategory::NONE,
    enum__Torappu_BuildingData_BuffCategory::FUNCTION,
    enum__Torappu_BuildingData_BuffCategory::OUTPUT,
    enum__Torappu_BuildingData_BuffCategory::RECOVERY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildingData_BuffCategory(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildingData_BuffCategory {
    pub const NONE: Self = Self(0);
    pub const FUNCTION: Self = Self(1);
    pub const OUTPUT: Self = Self(2);
    pub const RECOVERY: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::FUNCTION, Self::OUTPUT, Self::RECOVERY];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::FUNCTION => Some("FUNCTION"),
            Self::OUTPUT => Some("OUTPUT"),
            Self::RECOVERY => Some("RECOVERY"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildingData_BuffCategory {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildingData_BuffCategory {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildingData_BuffCategory {
    type Output = enum__Torappu_BuildingData_BuffCategory;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildingData_BuffCategory {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildingData_BuffCategory {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildingData_BuffCategory {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDING_DATA_FURNITURE_INTERACT: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDING_DATA_FURNITURE_INTERACT: i32 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDING_DATA_FURNITURE_INTERACT:
    [enum__Torappu_BuildingData_FurnitureInteract; 4] = [
    enum__Torappu_BuildingData_FurnitureInteract::NONE,
    enum__Torappu_BuildingData_FurnitureInteract::ANIMATOR,
    enum__Torappu_BuildingData_FurnitureInteract::MUSIC,
    enum__Torappu_BuildingData_FurnitureInteract::FUNCTION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildingData_FurnitureInteract(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildingData_FurnitureInteract {
    pub const NONE: Self = Self(0);
    pub const ANIMATOR: Self = Self(1);
    pub const MUSIC: Self = Self(2);
    pub const FUNCTION: Self = Self(3);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 3;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::ANIMATOR, Self::MUSIC, Self::FUNCTION];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ANIMATOR => Some("ANIMATOR"),
            Self::MUSIC => Some("MUSIC"),
            Self::FUNCTION => Some("FUNCTION"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildingData_FurnitureInteract {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildingData_FurnitureInteract {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildingData_FurnitureInteract {
    type Output = enum__Torappu_BuildingData_FurnitureInteract;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildingData_FurnitureInteract {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildingData_FurnitureInteract {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildingData_FurnitureInteract {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDING_DATA_FURNITURE_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDING_DATA_FURNITURE_TYPE: i32 = 13;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDING_DATA_FURNITURE_TYPE:
    [enum__Torappu_BuildingData_FurnitureType; 14] = [
    enum__Torappu_BuildingData_FurnitureType::FLOOR,
    enum__Torappu_BuildingData_FurnitureType::CARPET,
    enum__Torappu_BuildingData_FurnitureType::SEATING,
    enum__Torappu_BuildingData_FurnitureType::BEDDING,
    enum__Torappu_BuildingData_FurnitureType::TABLE,
    enum__Torappu_BuildingData_FurnitureType::CABINET,
    enum__Torappu_BuildingData_FurnitureType::DECORATION,
    enum__Torappu_BuildingData_FurnitureType::WALLPAPER,
    enum__Torappu_BuildingData_FurnitureType::WALLDECO,
    enum__Torappu_BuildingData_FurnitureType::WALLLAMP,
    enum__Torappu_BuildingData_FurnitureType::CEILING,
    enum__Torappu_BuildingData_FurnitureType::CEILINGLAMP,
    enum__Torappu_BuildingData_FurnitureType::FUNCTION,
    enum__Torappu_BuildingData_FurnitureType::INTERACT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildingData_FurnitureType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildingData_FurnitureType {
    pub const FLOOR: Self = Self(0);
    pub const CARPET: Self = Self(1);
    pub const SEATING: Self = Self(2);
    pub const BEDDING: Self = Self(3);
    pub const TABLE: Self = Self(4);
    pub const CABINET: Self = Self(5);
    pub const DECORATION: Self = Self(6);
    pub const WALLPAPER: Self = Self(7);
    pub const WALLDECO: Self = Self(8);
    pub const WALLLAMP: Self = Self(9);
    pub const CEILING: Self = Self(10);
    pub const CEILINGLAMP: Self = Self(11);
    pub const FUNCTION: Self = Self(12);
    pub const INTERACT: Self = Self(13);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 13;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::FLOOR,
        Self::CARPET,
        Self::SEATING,
        Self::BEDDING,
        Self::TABLE,
        Self::CABINET,
        Self::DECORATION,
        Self::WALLPAPER,
        Self::WALLDECO,
        Self::WALLLAMP,
        Self::CEILING,
        Self::CEILINGLAMP,
        Self::FUNCTION,
        Self::INTERACT,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::FLOOR => Some("FLOOR"),
            Self::CARPET => Some("CARPET"),
            Self::SEATING => Some("SEATING"),
            Self::BEDDING => Some("BEDDING"),
            Self::TABLE => Some("TABLE"),
            Self::CABINET => Some("CABINET"),
            Self::DECORATION => Some("DECORATION"),
            Self::WALLPAPER => Some("WALLPAPER"),
            Self::WALLDECO => Some("WALLDECO"),
            Self::WALLLAMP => Some("WALLLAMP"),
            Self::CEILING => Some("CEILING"),
            Self::CEILINGLAMP => Some("CEILINGLAMP"),
            Self::FUNCTION => Some("FUNCTION"),
            Self::INTERACT => Some("INTERACT"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildingData_FurnitureType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildingData_FurnitureType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildingData_FurnitureType {
    type Output = enum__Torappu_BuildingData_FurnitureType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildingData_FurnitureType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildingData_FurnitureType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildingData_FurnitureType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDING_DATA_FURNITURE_SUB_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDING_DATA_FURNITURE_SUB_TYPE: i32 = 40;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDING_DATA_FURNITURE_SUB_TYPE:
    [enum__Torappu_BuildingData_FurnitureSubType; 41] = [
    enum__Torappu_BuildingData_FurnitureSubType::NONE,
    enum__Torappu_BuildingData_FurnitureSubType::CHAIR,
    enum__Torappu_BuildingData_FurnitureSubType::SOFA,
    enum__Torappu_BuildingData_FurnitureSubType::BARSTOOL,
    enum__Torappu_BuildingData_FurnitureSubType::STOOL,
    enum__Torappu_BuildingData_FurnitureSubType::BENCH,
    enum__Torappu_BuildingData_FurnitureSubType::ORTHER_S,
    enum__Torappu_BuildingData_FurnitureSubType::POSTER,
    enum__Torappu_BuildingData_FurnitureSubType::CURTAIN,
    enum__Torappu_BuildingData_FurnitureSubType::BOARD_WD,
    enum__Torappu_BuildingData_FurnitureSubType::SHELF,
    enum__Torappu_BuildingData_FurnitureSubType::INSTRUMENT_WD,
    enum__Torappu_BuildingData_FurnitureSubType::ART_WD,
    enum__Torappu_BuildingData_FurnitureSubType::PLAQUE,
    enum__Torappu_BuildingData_FurnitureSubType::CONTRACT,
    enum__Torappu_BuildingData_FurnitureSubType::ANNIHILATION,
    enum__Torappu_BuildingData_FurnitureSubType::ORTHER_WD,
    enum__Torappu_BuildingData_FurnitureSubType::FLOORLAMP,
    enum__Torappu_BuildingData_FurnitureSubType::PLANT,
    enum__Torappu_BuildingData_FurnitureSubType::PARTITION,
    enum__Torappu_BuildingData_FurnitureSubType::COOKING,
    enum__Torappu_BuildingData_FurnitureSubType::CATERING,
    enum__Torappu_BuildingData_FurnitureSubType::DEVICE,
    enum__Torappu_BuildingData_FurnitureSubType::INSTRUMENT_D,
    enum__Torappu_BuildingData_FurnitureSubType::ART_D,
    enum__Torappu_BuildingData_FurnitureSubType::BOARD_D,
    enum__Torappu_BuildingData_FurnitureSubType::ENTERTAINMENT,
    enum__Torappu_BuildingData_FurnitureSubType::STORAGE,
    enum__Torappu_BuildingData_FurnitureSubType::DRESSING,
    enum__Torappu_BuildingData_FurnitureSubType::WARM,
    enum__Torappu_BuildingData_FurnitureSubType::WASH,
    enum__Torappu_BuildingData_FurnitureSubType::ORTHER_D,
    enum__Torappu_BuildingData_FurnitureSubType::COLUMN,
    enum__Torappu_BuildingData_FurnitureSubType::DECORATION_C,
    enum__Torappu_BuildingData_FurnitureSubType::CURTAIN_C,
    enum__Torappu_BuildingData_FurnitureSubType::DEVICE_C,
    enum__Torappu_BuildingData_FurnitureSubType::CONTRACT_2,
    enum__Torappu_BuildingData_FurnitureSubType::LIGHT,
    enum__Torappu_BuildingData_FurnitureSubType::ORTHER_C,
    enum__Torappu_BuildingData_FurnitureSubType::VISITOR,
    enum__Torappu_BuildingData_FurnitureSubType::MUSIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildingData_FurnitureSubType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildingData_FurnitureSubType {
    pub const NONE: Self = Self(0);
    pub const CHAIR: Self = Self(1);
    pub const SOFA: Self = Self(2);
    pub const BARSTOOL: Self = Self(3);
    pub const STOOL: Self = Self(4);
    pub const BENCH: Self = Self(5);
    pub const ORTHER_S: Self = Self(6);
    pub const POSTER: Self = Self(7);
    pub const CURTAIN: Self = Self(8);
    pub const BOARD_WD: Self = Self(9);
    pub const SHELF: Self = Self(10);
    pub const INSTRUMENT_WD: Self = Self(11);
    pub const ART_WD: Self = Self(12);
    pub const PLAQUE: Self = Self(13);
    pub const CONTRACT: Self = Self(14);
    pub const ANNIHILATION: Self = Self(15);
    pub const ORTHER_WD: Self = Self(16);
    pub const FLOORLAMP: Self = Self(17);
    pub const PLANT: Self = Self(18);
    pub const PARTITION: Self = Self(19);
    pub const COOKING: Self = Self(20);
    pub const CATERING: Self = Self(21);
    pub const DEVICE: Self = Self(22);
    pub const INSTRUMENT_D: Self = Self(23);
    pub const ART_D: Self = Self(24);
    pub const BOARD_D: Self = Self(25);
    pub const ENTERTAINMENT: Self = Self(26);
    pub const STORAGE: Self = Self(27);
    pub const DRESSING: Self = Self(28);
    pub const WARM: Self = Self(29);
    pub const WASH: Self = Self(30);
    pub const ORTHER_D: Self = Self(31);
    pub const COLUMN: Self = Self(32);
    pub const DECORATION_C: Self = Self(33);
    pub const CURTAIN_C: Self = Self(34);
    pub const DEVICE_C: Self = Self(35);
    pub const CONTRACT_2: Self = Self(36);
    pub const LIGHT: Self = Self(37);
    pub const ORTHER_C: Self = Self(38);
    pub const VISITOR: Self = Self(39);
    pub const MUSIC: Self = Self(40);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 40;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::CHAIR,
        Self::SOFA,
        Self::BARSTOOL,
        Self::STOOL,
        Self::BENCH,
        Self::ORTHER_S,
        Self::POSTER,
        Self::CURTAIN,
        Self::BOARD_WD,
        Self::SHELF,
        Self::INSTRUMENT_WD,
        Self::ART_WD,
        Self::PLAQUE,
        Self::CONTRACT,
        Self::ANNIHILATION,
        Self::ORTHER_WD,
        Self::FLOORLAMP,
        Self::PLANT,
        Self::PARTITION,
        Self::COOKING,
        Self::CATERING,
        Self::DEVICE,
        Self::INSTRUMENT_D,
        Self::ART_D,
        Self::BOARD_D,
        Self::ENTERTAINMENT,
        Self::STORAGE,
        Self::DRESSING,
        Self::WARM,
        Self::WASH,
        Self::ORTHER_D,
        Self::COLUMN,
        Self::DECORATION_C,
        Self::CURTAIN_C,
        Self::DEVICE_C,
        Self::CONTRACT_2,
        Self::LIGHT,
        Self::ORTHER_C,
        Self::VISITOR,
        Self::MUSIC,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::CHAIR => Some("CHAIR"),
            Self::SOFA => Some("SOFA"),
            Self::BARSTOOL => Some("BARSTOOL"),
            Self::STOOL => Some("STOOL"),
            Self::BENCH => Some("BENCH"),
            Self::ORTHER_S => Some("ORTHER_S"),
            Self::POSTER => Some("POSTER"),
            Self::CURTAIN => Some("CURTAIN"),
            Self::BOARD_WD => Some("BOARD_WD"),
            Self::SHELF => Some("SHELF"),
            Self::INSTRUMENT_WD => Some("INSTRUMENT_WD"),
            Self::ART_WD => Some("ART_WD"),
            Self::PLAQUE => Some("PLAQUE"),
            Self::CONTRACT => Some("CONTRACT"),
            Self::ANNIHILATION => Some("ANNIHILATION"),
            Self::ORTHER_WD => Some("ORTHER_WD"),
            Self::FLOORLAMP => Some("FLOORLAMP"),
            Self::PLANT => Some("PLANT"),
            Self::PARTITION => Some("PARTITION"),
            Self::COOKING => Some("COOKING"),
            Self::CATERING => Some("CATERING"),
            Self::DEVICE => Some("DEVICE"),
            Self::INSTRUMENT_D => Some("INSTRUMENT_D"),
            Self::ART_D => Some("ART_D"),
            Self::BOARD_D => Some("BOARD_D"),
            Self::ENTERTAINMENT => Some("ENTERTAINMENT"),
            Self::STORAGE => Some("STORAGE"),
            Self::DRESSING => Some("DRESSING"),
            Self::WARM => Some("WARM"),
            Self::WASH => Some("WASH"),
            Self::ORTHER_D => Some("ORTHER_D"),
            Self::COLUMN => Some("COLUMN"),
            Self::DECORATION_C => Some("DECORATION_C"),
            Self::CURTAIN_C => Some("CURTAIN_C"),
            Self::DEVICE_C => Some("DEVICE_C"),
            Self::CONTRACT_2 => Some("CONTRACT_2"),
            Self::LIGHT => Some("LIGHT"),
            Self::ORTHER_C => Some("ORTHER_C"),
            Self::VISITOR => Some("VISITOR"),
            Self::MUSIC => Some("MUSIC"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildingData_FurnitureSubType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildingData_FurnitureSubType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildingData_FurnitureSubType {
    type Output = enum__Torappu_BuildingData_FurnitureSubType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildingData_FurnitureSubType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildingData_FurnitureSubType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildingData_FurnitureSubType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDING_DATA_FURNITURE_LOCATION: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDING_DATA_FURNITURE_LOCATION: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDING_DATA_FURNITURE_LOCATION:
    [enum__Torappu_BuildingData_FurnitureLocation; 7] = [
    enum__Torappu_BuildingData_FurnitureLocation::NONE,
    enum__Torappu_BuildingData_FurnitureLocation::WALL,
    enum__Torappu_BuildingData_FurnitureLocation::FLOOR,
    enum__Torappu_BuildingData_FurnitureLocation::CARPET,
    enum__Torappu_BuildingData_FurnitureLocation::CEILING,
    enum__Torappu_BuildingData_FurnitureLocation::POSTER,
    enum__Torappu_BuildingData_FurnitureLocation::CEILINGDECAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildingData_FurnitureLocation(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildingData_FurnitureLocation {
    pub const NONE: Self = Self(0);
    pub const WALL: Self = Self(1);
    pub const FLOOR: Self = Self(2);
    pub const CARPET: Self = Self(3);
    pub const CEILING: Self = Self(4);
    pub const POSTER: Self = Self(5);
    pub const CEILINGDECAL: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::WALL,
        Self::FLOOR,
        Self::CARPET,
        Self::CEILING,
        Self::POSTER,
        Self::CEILINGDECAL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::WALL => Some("WALL"),
            Self::FLOOR => Some("FLOOR"),
            Self::CARPET => Some("CARPET"),
            Self::CEILING => Some("CEILING"),
            Self::POSTER => Some("POSTER"),
            Self::CEILINGDECAL => Some("CEILINGDECAL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildingData_FurnitureLocation {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildingData_FurnitureLocation {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildingData_FurnitureLocation {
    type Output = enum__Torappu_BuildingData_FurnitureLocation;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildingData_FurnitureLocation {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildingData_FurnitureLocation {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildingData_FurnitureLocation {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDING_DATA_FURNITURE_CATEGORY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDING_DATA_FURNITURE_CATEGORY: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDING_DATA_FURNITURE_CATEGORY:
    [enum__Torappu_BuildingData_FurnitureCategory; 3] = [
    enum__Torappu_BuildingData_FurnitureCategory::FURNITURE,
    enum__Torappu_BuildingData_FurnitureCategory::WALL,
    enum__Torappu_BuildingData_FurnitureCategory::FLOOR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildingData_FurnitureCategory(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildingData_FurnitureCategory {
    pub const FURNITURE: Self = Self(0);
    pub const WALL: Self = Self(1);
    pub const FLOOR: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::FURNITURE, Self::WALL, Self::FLOOR];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::FURNITURE => Some("FURNITURE"),
            Self::WALL => Some("WALL"),
            Self::FLOOR => Some("FLOOR"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildingData_FurnitureCategory {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildingData_FurnitureCategory {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildingData_FurnitureCategory {
    type Output = enum__Torappu_BuildingData_FurnitureCategory;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildingData_FurnitureCategory {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildingData_FurnitureCategory {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildingData_FurnitureCategory {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDING_DATA_DIY_SORT_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDING_DATA_DIY_SORT_TYPE: i32 = 10;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDING_DATA_DIY_SORT_TYPE:
    [enum__Torappu_BuildingData_DiySortType; 11] = [
    enum__Torappu_BuildingData_DiySortType::NONE,
    enum__Torappu_BuildingData_DiySortType::THEME,
    enum__Torappu_BuildingData_DiySortType::FURNITURE,
    enum__Torappu_BuildingData_DiySortType::FURNITURE_IN_THEME,
    enum__Torappu_BuildingData_DiySortType::RECENT_THEME,
    enum__Torappu_BuildingData_DiySortType::RECENT_FURNITURE,
    enum__Torappu_BuildingData_DiySortType::MEETING_THEME,
    enum__Torappu_BuildingData_DiySortType::MEETING_FURNITURE,
    enum__Torappu_BuildingData_DiySortType::MEETING_FURNITURE_IN_THEME,
    enum__Torappu_BuildingData_DiySortType::MEETING_RECENT_THEME,
    enum__Torappu_BuildingData_DiySortType::MEETING_RECENT_FURNITURE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildingData_DiySortType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildingData_DiySortType {
    pub const NONE: Self = Self(0);
    pub const THEME: Self = Self(1);
    pub const FURNITURE: Self = Self(2);
    pub const FURNITURE_IN_THEME: Self = Self(3);
    pub const RECENT_THEME: Self = Self(4);
    pub const RECENT_FURNITURE: Self = Self(5);
    pub const MEETING_THEME: Self = Self(6);
    pub const MEETING_FURNITURE: Self = Self(7);
    pub const MEETING_FURNITURE_IN_THEME: Self = Self(8);
    pub const MEETING_RECENT_THEME: Self = Self(9);
    pub const MEETING_RECENT_FURNITURE: Self = Self(10);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 10;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::THEME,
        Self::FURNITURE,
        Self::FURNITURE_IN_THEME,
        Self::RECENT_THEME,
        Self::RECENT_FURNITURE,
        Self::MEETING_THEME,
        Self::MEETING_FURNITURE,
        Self::MEETING_FURNITURE_IN_THEME,
        Self::MEETING_RECENT_THEME,
        Self::MEETING_RECENT_FURNITURE,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::THEME => Some("THEME"),
            Self::FURNITURE => Some("FURNITURE"),
            Self::FURNITURE_IN_THEME => Some("FURNITURE_IN_THEME"),
            Self::RECENT_THEME => Some("RECENT_THEME"),
            Self::RECENT_FURNITURE => Some("RECENT_FURNITURE"),
            Self::MEETING_THEME => Some("MEETING_THEME"),
            Self::MEETING_FURNITURE => Some("MEETING_FURNITURE"),
            Self::MEETING_FURNITURE_IN_THEME => Some("MEETING_FURNITURE_IN_THEME"),
            Self::MEETING_RECENT_THEME => Some("MEETING_RECENT_THEME"),
            Self::MEETING_RECENT_FURNITURE => Some("MEETING_RECENT_FURNITURE"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildingData_DiySortType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildingData_DiySortType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildingData_DiySortType {
    type Output = enum__Torappu_BuildingData_DiySortType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildingData_DiySortType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildingData_DiySortType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildingData_DiySortType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDING_DATA_DIY_UISORT_ORDER: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDING_DATA_DIY_UISORT_ORDER: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDING_DATA_DIY_UISORT_ORDER:
    [enum__Torappu_BuildingData_DiyUISortOrder; 2] = [
    enum__Torappu_BuildingData_DiyUISortOrder::DESC,
    enum__Torappu_BuildingData_DiyUISortOrder::ASC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildingData_DiyUISortOrder(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildingData_DiyUISortOrder {
    pub const DESC: Self = Self(0);
    pub const ASC: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::DESC, Self::ASC];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::DESC => Some("DESC"),
            Self::ASC => Some("ASC"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildingData_DiyUISortOrder {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildingData_DiyUISortOrder {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildingData_DiyUISortOrder {
    type Output = enum__Torappu_BuildingData_DiyUISortOrder;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildingData_DiyUISortOrder {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildingData_DiyUISortOrder {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildingData_DiyUISortOrder {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDING_DATA_FORMULA_ITEM_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDING_DATA_FORMULA_ITEM_TYPE: i32 = 8;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDING_DATA_FORMULA_ITEM_TYPE:
    [enum__Torappu_BuildingData_FormulaItemType; 9] = [
    enum__Torappu_BuildingData_FormulaItemType::NONE,
    enum__Torappu_BuildingData_FormulaItemType::F_EVOLVE,
    enum__Torappu_BuildingData_FormulaItemType::F_BUILDING,
    enum__Torappu_BuildingData_FormulaItemType::F_GOLD,
    enum__Torappu_BuildingData_FormulaItemType::F_DIAMOND,
    enum__Torappu_BuildingData_FormulaItemType::F_FURNITURE,
    enum__Torappu_BuildingData_FormulaItemType::F_EXP,
    enum__Torappu_BuildingData_FormulaItemType::F_ASC,
    enum__Torappu_BuildingData_FormulaItemType::F_SKILL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildingData_FormulaItemType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildingData_FormulaItemType {
    pub const NONE: Self = Self(0);
    pub const F_EVOLVE: Self = Self(1);
    pub const F_BUILDING: Self = Self(2);
    pub const F_GOLD: Self = Self(3);
    pub const F_DIAMOND: Self = Self(4);
    pub const F_FURNITURE: Self = Self(5);
    pub const F_EXP: Self = Self(6);
    pub const F_ASC: Self = Self(7);
    pub const F_SKILL: Self = Self(8);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 8;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::F_EVOLVE,
        Self::F_BUILDING,
        Self::F_GOLD,
        Self::F_DIAMOND,
        Self::F_FURNITURE,
        Self::F_EXP,
        Self::F_ASC,
        Self::F_SKILL,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::F_EVOLVE => Some("F_EVOLVE"),
            Self::F_BUILDING => Some("F_BUILDING"),
            Self::F_GOLD => Some("F_GOLD"),
            Self::F_DIAMOND => Some("F_DIAMOND"),
            Self::F_FURNITURE => Some("F_FURNITURE"),
            Self::F_EXP => Some("F_EXP"),
            Self::F_ASC => Some("F_ASC"),
            Self::F_SKILL => Some("F_SKILL"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildingData_FormulaItemType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildingData_FormulaItemType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildingData_FormulaItemType {
    type Output = enum__Torappu_BuildingData_FormulaItemType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildingData_FormulaItemType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildingData_FormulaItemType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildingData_FormulaItemType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_ITEM_RARITY: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_ITEM_RARITY: i32 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_ITEM_RARITY: [enum__Torappu_ItemRarity; 7] = [
    enum__Torappu_ItemRarity::TIER_1,
    enum__Torappu_ItemRarity::TIER_2,
    enum__Torappu_ItemRarity::TIER_3,
    enum__Torappu_ItemRarity::TIER_4,
    enum__Torappu_ItemRarity::TIER_5,
    enum__Torappu_ItemRarity::TIER_6,
    enum__Torappu_ItemRarity::E_NUM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_ItemRarity(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_ItemRarity {
    pub const TIER_1: Self = Self(0);
    pub const TIER_2: Self = Self(1);
    pub const TIER_3: Self = Self(2);
    pub const TIER_4: Self = Self(3);
    pub const TIER_5: Self = Self(4);
    pub const TIER_6: Self = Self(5);
    pub const E_NUM: Self = Self(6);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::TIER_1,
        Self::TIER_2,
        Self::TIER_3,
        Self::TIER_4,
        Self::TIER_5,
        Self::TIER_6,
        Self::E_NUM,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::TIER_1 => Some("TIER_1"),
            Self::TIER_2 => Some("TIER_2"),
            Self::TIER_3 => Some("TIER_3"),
            Self::TIER_4 => Some("TIER_4"),
            Self::TIER_5 => Some("TIER_5"),
            Self::TIER_6 => Some("TIER_6"),
            Self::E_NUM => Some("E_NUM"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_ItemRarity {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_ItemRarity {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_ItemRarity {
    type Output = enum__Torappu_ItemRarity;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_ItemRarity {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_ItemRarity {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_ItemRarity {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ENUM__TORAPPU_BUILDING_DATA_CHAR_STATION_FILTER_TYPE: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ENUM__TORAPPU_BUILDING_DATA_CHAR_STATION_FILTER_TYPE: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENUM__TORAPPU_BUILDING_DATA_CHAR_STATION_FILTER_TYPE:
    [enum__Torappu_BuildingData_CharStationFilterType; 3] = [
    enum__Torappu_BuildingData_CharStationFilterType::All,
    enum__Torappu_BuildingData_CharStationFilterType::DormLock,
    enum__Torappu_BuildingData_CharStationFilterType::NotStationed,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct enum__Torappu_BuildingData_CharStationFilterType(pub i32);
#[allow(non_upper_case_globals)]
impl enum__Torappu_BuildingData_CharStationFilterType {
    pub const All: Self = Self(0);
    pub const DormLock: Self = Self(1);
    pub const NotStationed: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::All, Self::DormLock, Self::NotStationed];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::All => Some("All"),
            Self::DormLock => Some("DormLock"),
            Self::NotStationed => Some("NotStationed"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for enum__Torappu_BuildingData_CharStationFilterType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for enum__Torappu_BuildingData_CharStationFilterType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for enum__Torappu_BuildingData_CharStationFilterType {
    type Output = enum__Torappu_BuildingData_CharStationFilterType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for enum__Torappu_BuildingData_CharStationFilterType {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for enum__Torappu_BuildingData_CharStationFilterType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for enum__Torappu_BuildingData_CharStationFilterType {}
pub enum dict__string__intOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__int<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__int<'a> {
    type Inner = dict__string__int<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__int<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__int { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__intArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__int<'bldr>> {
        let mut builder = dict__string__intBuilder::new(_fbb);
        builder.add_value(args.value);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__int::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__int) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(dict__string__int::VT_VALUE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for dict__string__int<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__intArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: i32,
}
impl<'a> Default for dict__string__intArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__intArgs {
            key: None, // required field
            value: 0,
        }
    }
}

pub struct dict__string__intBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__intBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__int::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_
            .push_slot::<i32>(dict__string__int::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__intBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__intBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__int<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__int::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__int<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__int");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_RoomUnlockCond_CondItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'a> {
    type Inner = clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;
    pub const VT_COUNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_RoomUnlockCond_CondItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_RoomUnlockCond_CondItemArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_RoomUnlockCond_CondItemBuilder::new(_fbb);
        builder.add_count(args.count);
        builder.add_level(args.level);
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_BuildingData_RoomType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_RoomType>(
                    clz_Torappu_BuildingData_RoomUnlockCond_CondItem::VT_TYPE_,
                    Some(enum__Torappu_BuildingData_RoomType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_RoomUnlockCond_CondItem::VT_LEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_RoomUnlockCond_CondItem::VT_COUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_BuildingData_RoomType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_RoomUnlockCond_CondItemArgs {
    pub type_: enum__Torappu_BuildingData_RoomType,
    pub level: i32,
    pub count: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_RoomUnlockCond_CondItemArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_RoomUnlockCond_CondItemArgs {
            type_: enum__Torappu_BuildingData_RoomType::NONE,
            level: 0,
            count: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_RoomUnlockCond_CondItemBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_RoomUnlockCond_CondItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_BuildingData_RoomType) {
        self.fbb_.push_slot::<enum__Torappu_BuildingData_RoomType>(
            clz_Torappu_BuildingData_RoomUnlockCond_CondItem::VT_TYPE_,
            type_,
            enum__Torappu_BuildingData_RoomType::NONE,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_RoomUnlockCond_CondItem::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_RoomUnlockCond_CondItem::VT_COUNT,
            count,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_RoomUnlockCond_CondItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_RoomUnlockCond_CondItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_RoomUnlockCond_CondItem");
        ds.field("type_", &self.type_());
        ds.field("level", &self.level());
        ds.field("count", &self.count());
        ds.finish()
    }
}
pub enum dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'a>
{
    type Inner = dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'bldr>>
    {
        let mut builder =
            dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItemBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomUnlockCond_CondItem>>(dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<i32>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomUnlockCond_CondItem>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItemArgs<'a> {
    pub key: i32,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'a>>>,
}
impl<'a> Default for dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItemArgs {
            key: 0,
            value: None,
        }
    }
}

pub struct dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItemBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomUnlockCond_CondItem>>(dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_RoomUnlockCondOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_RoomUnlockCond<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_RoomUnlockCond<'a> {
    type Inner = clz_Torappu_BuildingData_RoomUnlockCond<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_RoomUnlockCond<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NUMBER: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_RoomUnlockCond { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_RoomUnlockCondArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomUnlockCond<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_RoomUnlockCondBuilder::new(_fbb);
        if let Some(x) = args.number {
            builder.add_number(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_RoomUnlockCond::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn number(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem,
                    >,
                >,
            >>(clz_Torappu_BuildingData_RoomUnlockCond::VT_NUMBER, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_RoomUnlockCond<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem,
                    >,
                >,
            >>("number", Self::VT_NUMBER, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_RoomUnlockCondArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub number: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_RoomUnlockCondArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_RoomUnlockCondArgs {
            id: None,
            number: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_RoomUnlockCondBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_RoomUnlockCondBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_RoomUnlockCond::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_number(
        &mut self,
        number: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_BuildingData_RoomUnlockCond_CondItem<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_RoomUnlockCond::VT_NUMBER,
            number,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_RoomUnlockCondBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_RoomUnlockCondBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomUnlockCond<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_RoomUnlockCond<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_RoomUnlockCond");
        ds.field("id", &self.id());
        ds.field("number", &self.number());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_RoomUnlockCondOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_RoomUnlockCond<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_BuildingData_RoomUnlockCond<'a> {
    type Inner = dict__string__clz_Torappu_BuildingData_RoomUnlockCond<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_RoomUnlockCond<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_RoomUnlockCond { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_RoomUnlockCondArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_RoomUnlockCond<'bldr>> {
        let mut builder = dict__string__clz_Torappu_BuildingData_RoomUnlockCondBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_RoomUnlockCond::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_RoomUnlockCond,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_RoomUnlockCond<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomUnlockCond>>(
                    dict__string__clz_Torappu_BuildingData_RoomUnlockCond::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_RoomUnlockCond<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomUnlockCond>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_RoomUnlockCondArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomUnlockCond<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_RoomUnlockCondArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_RoomUnlockCondArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_RoomUnlockCondBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_RoomUnlockCondBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_RoomUnlockCond::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomUnlockCond<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomUnlockCond>>(
                dict__string__clz_Torappu_BuildingData_RoomUnlockCond::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_RoomUnlockCondBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_RoomUnlockCondBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_RoomUnlockCond<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_RoomUnlockCond::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_RoomUnlockCond<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_RoomUnlockCond");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_GridPositionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_GridPosition<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_GridPosition<'a> {
    type Inner = clz_Torappu_GridPosition<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_GridPosition<'a> {
    pub const VT_ROW: flatbuffers::VOffsetT = 4;
    pub const VT_COL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_GridPosition { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_GridPositionArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_GridPosition<'bldr>> {
        let mut builder = clz_Torappu_GridPositionBuilder::new(_fbb);
        builder.add_col(args.col);
        builder.add_row(args.row);
        builder.finish()
    }

    #[inline]
    pub fn row(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_GridPosition::VT_ROW, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn col(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_GridPosition::VT_COL, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_GridPosition<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("row", Self::VT_ROW, false)?
            .visit_field::<i32>("col", Self::VT_COL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_GridPositionArgs {
    pub row: i32,
    pub col: i32,
}
impl<'a> Default for clz_Torappu_GridPositionArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_GridPositionArgs { row: 0, col: 0 }
    }
}

pub struct clz_Torappu_GridPositionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_GridPositionBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_row(&mut self, row: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_GridPosition::VT_ROW, row, 0);
    }
    #[inline]
    pub fn add_col(&mut self, col: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_GridPosition::VT_COL, col, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_GridPositionBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_GridPositionBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_GridPosition<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_GridPosition<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_GridPosition");
        ds.field("row", &self.row());
        ds.field("col", &self.col());
        ds.finish()
    }
}
pub enum clz_Torappu_ItemBundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_ItemBundle<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_ItemBundle<'a> {
    type Inner = clz_Torappu_ItemBundle<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_ItemBundle<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_COUNT: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_ItemBundle { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_ItemBundleArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'bldr>> {
        let mut builder = clz_Torappu_ItemBundleBuilder::new(_fbb);
        builder.add_type_(args.type_);
        builder.add_count(args.count);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_ItemBundle::VT_ID, None)
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_ItemBundle::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_ItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_ItemType>(
                    clz_Torappu_ItemBundle::VT_TYPE_,
                    Some(enum__Torappu_ItemType::NONE),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_ItemBundle<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<enum__Torappu_ItemType>("type_", Self::VT_TYPE_, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_ItemBundleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub type_: enum__Torappu_ItemType,
}
impl<'a> Default for clz_Torappu_ItemBundleArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_ItemBundleArgs {
            id: None,
            count: 0,
            type_: enum__Torappu_ItemType::NONE,
        }
    }
}

pub struct clz_Torappu_ItemBundleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_ItemBundle::VT_ID, id);
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_ItemBundle::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_ItemType) {
        self.fbb_.push_slot::<enum__Torappu_ItemType>(
            clz_Torappu_ItemBundle::VT_TYPE_,
            type_,
            enum__Torappu_ItemType::NONE,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_ItemBundleBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_ItemBundleBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_ItemBundle<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_ItemBundle");
        ds.field("id", &self.id());
        ds.field("count", &self.count());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_RoomData_BuildCostOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_RoomData_BuildCost<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_RoomData_BuildCost<'a> {
    type Inner = clz_Torappu_BuildingData_RoomData_BuildCost<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_RoomData_BuildCost<'a> {
    pub const VT_ITEMS: flatbuffers::VOffsetT = 4;
    pub const VT_TIME: flatbuffers::VOffsetT = 6;
    pub const VT_LABOR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_RoomData_BuildCost { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_RoomData_BuildCostArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomData_BuildCost<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_RoomData_BuildCostBuilder::new(_fbb);
        builder.add_time(args.time);
        builder.add_labor(args.labor);
        if let Some(x) = args.items {
            builder.add_items(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn items(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_BuildingData_RoomData_BuildCost::VT_ITEMS, None)
        }
    }
    #[inline]
    pub fn time(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_BuildingData_RoomData_BuildCost::VT_TIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn labor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_RoomData_BuildCost::VT_LABOR,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_RoomData_BuildCost<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("items", Self::VT_ITEMS, false)?
            .visit_field::<i64>("time", Self::VT_TIME, false)?
            .visit_field::<i32>("labor", Self::VT_LABOR, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_RoomData_BuildCostArgs<'a> {
    pub items: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
    pub time: i64,
    pub labor: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_RoomData_BuildCostArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_RoomData_BuildCostArgs {
            items: None,
            time: 0,
            labor: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_RoomData_BuildCostBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_RoomData_BuildCostBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_items(
        &mut self,
        items: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_RoomData_BuildCost::VT_ITEMS,
            items,
        );
    }
    #[inline]
    pub fn add_time(&mut self, time: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_BuildingData_RoomData_BuildCost::VT_TIME,
            time,
            0,
        );
    }
    #[inline]
    pub fn add_labor(&mut self, labor: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_RoomData_BuildCost::VT_LABOR,
            labor,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_RoomData_BuildCostBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_RoomData_BuildCostBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomData_BuildCost<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_RoomData_BuildCost<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_RoomData_BuildCost");
        ds.field("items", &self.items());
        ds.field("time", &self.time());
        ds.field("labor", &self.labor());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_RoomData_PhaseDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_RoomData_PhaseData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_RoomData_PhaseData<'a> {
    type Inner = clz_Torappu_BuildingData_RoomData_PhaseData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_RoomData_PhaseData<'a> {
    pub const VT_OVERRIDENAME: flatbuffers::VOffsetT = 4;
    pub const VT_OVERRIDEPREFABID: flatbuffers::VOffsetT = 6;
    pub const VT_UNLOCKCONDID: flatbuffers::VOffsetT = 8;
    pub const VT_BUILDCOST: flatbuffers::VOffsetT = 10;
    pub const VT_ELECTRICITY: flatbuffers::VOffsetT = 12;
    pub const VT_MAXSTATIONEDNUM: flatbuffers::VOffsetT = 14;
    pub const VT_MANPOWERCOST: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_RoomData_PhaseData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_RoomData_PhaseDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomData_PhaseData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_RoomData_PhaseDataBuilder::new(_fbb);
        builder.add_manpowerCost(args.manpowerCost);
        builder.add_maxStationedNum(args.maxStationedNum);
        builder.add_electricity(args.electricity);
        if let Some(x) = args.buildCost {
            builder.add_buildCost(x);
        }
        if let Some(x) = args.unlockCondId {
            builder.add_unlockCondId(x);
        }
        if let Some(x) = args.overridePrefabId {
            builder.add_overridePrefabId(x);
        }
        if let Some(x) = args.overrideName {
            builder.add_overrideName(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn overrideName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_RoomData_PhaseData::VT_OVERRIDENAME,
                None,
            )
        }
    }
    #[inline]
    pub fn overridePrefabId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_RoomData_PhaseData::VT_OVERRIDEPREFABID,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockCondId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_RoomData_PhaseData::VT_UNLOCKCONDID,
                None,
            )
        }
    }
    #[inline]
    pub fn buildCost(&self) -> Option<clz_Torappu_BuildingData_RoomData_BuildCost<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomData_BuildCost>>(
                    clz_Torappu_BuildingData_RoomData_PhaseData::VT_BUILDCOST,
                    None,
                )
        }
    }
    #[inline]
    pub fn electricity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_RoomData_PhaseData::VT_ELECTRICITY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxStationedNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_RoomData_PhaseData::VT_MAXSTATIONEDNUM,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn manpowerCost(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_BuildingData_RoomData_PhaseData::VT_MANPOWERCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_RoomData_PhaseData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("overrideName", Self::VT_OVERRIDENAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("overridePrefabId", Self::VT_OVERRIDEPREFABID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unlockCondId", Self::VT_UNLOCKCONDID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomData_BuildCost>>("buildCost", Self::VT_BUILDCOST, false)?
     .visit_field::<i32>("electricity", Self::VT_ELECTRICITY, false)?
     .visit_field::<i32>("maxStationedNum", Self::VT_MAXSTATIONEDNUM, false)?
     .visit_field::<i64>("manpowerCost", Self::VT_MANPOWERCOST, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_RoomData_PhaseDataArgs<'a> {
    pub overrideName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub overridePrefabId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockCondId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buildCost: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomData_BuildCost<'a>>>,
    pub electricity: i32,
    pub maxStationedNum: i32,
    pub manpowerCost: i64,
}
impl<'a> Default for clz_Torappu_BuildingData_RoomData_PhaseDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_RoomData_PhaseDataArgs {
            overrideName: None,
            overridePrefabId: None,
            unlockCondId: None,
            buildCost: None,
            electricity: 0,
            maxStationedNum: 0,
            manpowerCost: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_RoomData_PhaseDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_RoomData_PhaseDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_overrideName(&mut self, overrideName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_RoomData_PhaseData::VT_OVERRIDENAME,
            overrideName,
        );
    }
    #[inline]
    pub fn add_overridePrefabId(&mut self, overridePrefabId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_RoomData_PhaseData::VT_OVERRIDEPREFABID,
            overridePrefabId,
        );
    }
    #[inline]
    pub fn add_unlockCondId(&mut self, unlockCondId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_RoomData_PhaseData::VT_UNLOCKCONDID,
            unlockCondId,
        );
    }
    #[inline]
    pub fn add_buildCost(
        &mut self,
        buildCost: flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomData_BuildCost<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomData_BuildCost>>(clz_Torappu_BuildingData_RoomData_PhaseData::VT_BUILDCOST, buildCost);
    }
    #[inline]
    pub fn add_electricity(&mut self, electricity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_RoomData_PhaseData::VT_ELECTRICITY,
            electricity,
            0,
        );
    }
    #[inline]
    pub fn add_maxStationedNum(&mut self, maxStationedNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_RoomData_PhaseData::VT_MAXSTATIONEDNUM,
            maxStationedNum,
            0,
        );
    }
    #[inline]
    pub fn add_manpowerCost(&mut self, manpowerCost: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_BuildingData_RoomData_PhaseData::VT_MANPOWERCOST,
            manpowerCost,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_RoomData_PhaseDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_RoomData_PhaseDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomData_PhaseData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_RoomData_PhaseData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_RoomData_PhaseData");
        ds.field("overrideName", &self.overrideName());
        ds.field("overridePrefabId", &self.overridePrefabId());
        ds.field("unlockCondId", &self.unlockCondId());
        ds.field("buildCost", &self.buildCost());
        ds.field("electricity", &self.electricity());
        ds.field("maxStationedNum", &self.maxStationedNum());
        ds.field("manpowerCost", &self.manpowerCost());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_RoomDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_RoomData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_RoomData<'a> {
    type Inner = clz_Torappu_BuildingData_RoomData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_RoomData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
    pub const VT_DEFAULTPREFABID: flatbuffers::VOffsetT = 10;
    pub const VT_CANLEVELDOWN: flatbuffers::VOffsetT = 12;
    pub const VT_MAXCOUNT: flatbuffers::VOffsetT = 14;
    pub const VT_CATEGORY: flatbuffers::VOffsetT = 16;
    pub const VT_SIZE: flatbuffers::VOffsetT = 18;
    pub const VT_PHASES: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_RoomData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_RoomDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_RoomDataBuilder::new(_fbb);
        if let Some(x) = args.phases {
            builder.add_phases(x);
        }
        if let Some(x) = args.size {
            builder.add_size(x);
        }
        builder.add_category(args.category);
        builder.add_maxCount(args.maxCount);
        if let Some(x) = args.defaultPrefabId {
            builder.add_defaultPrefabId(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_id(args.id);
        builder.add_canLevelDown(args.canLevelDown);
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> enum__Torappu_BuildingData_RoomType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_RoomType>(
                    clz_Torappu_BuildingData_RoomData::VT_ID,
                    Some(enum__Torappu_BuildingData_RoomType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_RoomData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_RoomData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn defaultPrefabId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_RoomData::VT_DEFAULTPREFABID,
                None,
            )
        }
    }
    #[inline]
    pub fn canLevelDown(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BuildingData_RoomData::VT_CANLEVELDOWN,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData_RoomData::VT_MAXCOUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn category(&self) -> enum__Torappu_BuildingData_RoomCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_RoomCategory>(
                    clz_Torappu_BuildingData_RoomData::VT_CATEGORY,
                    Some(enum__Torappu_BuildingData_RoomCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn size(&self) -> Option<clz_Torappu_GridPosition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                    clz_Torappu_BuildingData_RoomData::VT_SIZE,
                    None,
                )
        }
    }
    #[inline]
    pub fn phases(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomData_PhaseData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomData_PhaseData>,
                >,
            >>(clz_Torappu_BuildingData_RoomData::VT_PHASES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_RoomData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_BuildingData_RoomType>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "defaultPrefabId",
                Self::VT_DEFAULTPREFABID,
                false,
            )?
            .visit_field::<bool>("canLevelDown", Self::VT_CANLEVELDOWN, false)?
            .visit_field::<i32>("maxCount", Self::VT_MAXCOUNT, false)?
            .visit_field::<enum__Torappu_BuildingData_RoomCategory>(
                "category",
                Self::VT_CATEGORY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                "size",
                Self::VT_SIZE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomData_PhaseData>,
                >,
            >>("phases", Self::VT_PHASES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_RoomDataArgs<'a> {
    pub id: enum__Torappu_BuildingData_RoomType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub defaultPrefabId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub canLevelDown: bool,
    pub maxCount: i32,
    pub category: enum__Torappu_BuildingData_RoomCategory,
    pub size: Option<flatbuffers::WIPOffset<clz_Torappu_GridPosition<'a>>>,
    pub phases: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomData_PhaseData<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_RoomDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_RoomDataArgs {
            id: enum__Torappu_BuildingData_RoomType::NONE,
            name: None,
            description: None,
            defaultPrefabId: None,
            canLevelDown: false,
            maxCount: 0,
            category: enum__Torappu_BuildingData_RoomCategory::NONE,
            size: None,
            phases: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_RoomDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_RoomDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: enum__Torappu_BuildingData_RoomType) {
        self.fbb_.push_slot::<enum__Torappu_BuildingData_RoomType>(
            clz_Torappu_BuildingData_RoomData::VT_ID,
            id,
            enum__Torappu_BuildingData_RoomType::NONE,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_RoomData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_RoomData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_defaultPrefabId(&mut self, defaultPrefabId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_RoomData::VT_DEFAULTPREFABID,
            defaultPrefabId,
        );
    }
    #[inline]
    pub fn add_canLevelDown(&mut self, canLevelDown: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuildingData_RoomData::VT_CANLEVELDOWN,
            canLevelDown,
            false,
        );
    }
    #[inline]
    pub fn add_maxCount(&mut self, maxCount: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_BuildingData_RoomData::VT_MAXCOUNT, maxCount, 0);
    }
    #[inline]
    pub fn add_category(&mut self, category: enum__Torappu_BuildingData_RoomCategory) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_RoomCategory>(
                clz_Torappu_BuildingData_RoomData::VT_CATEGORY,
                category,
                enum__Torappu_BuildingData_RoomCategory::NONE,
            );
    }
    #[inline]
    pub fn add_size(&mut self, size: flatbuffers::WIPOffset<clz_Torappu_GridPosition<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_GridPosition>>(
                clz_Torappu_BuildingData_RoomData::VT_SIZE,
                size,
            );
    }
    #[inline]
    pub fn add_phases(
        &mut self,
        phases: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomData_PhaseData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_RoomData::VT_PHASES,
            phases,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_RoomDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_RoomDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_RoomData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_RoomData");
        ds.field("id", &self.id());
        ds.field("name", &self.name());
        ds.field("description", &self.description());
        ds.field("defaultPrefabId", &self.defaultPrefabId());
        ds.field("canLevelDown", &self.canLevelDown());
        ds.field("maxCount", &self.maxCount());
        ds.field("category", &self.category());
        ds.field("size", &self.size());
        ds.field("phases", &self.phases());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_RoomDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_RoomData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_BuildingData_RoomData<'a> {
    type Inner = dict__string__clz_Torappu_BuildingData_RoomData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_RoomData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_RoomData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_RoomDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_RoomData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_BuildingData_RoomDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_RoomData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_RoomData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_RoomData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomData>>(
                    dict__string__clz_Torappu_BuildingData_RoomData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_RoomData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_RoomDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_RoomDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_RoomDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_RoomDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_RoomDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_RoomData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_RoomData>>(
                dict__string__clz_Torappu_BuildingData_RoomData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_RoomDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_RoomDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_RoomData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_RoomData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_RoomData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_RoomData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_LayoutData_RoomSlotOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_LayoutData_RoomSlot<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_LayoutData_RoomSlot<'a> {
    type Inner = clz_Torappu_BuildingData_LayoutData_RoomSlot<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_LayoutData_RoomSlot<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_CLEANCOSTID: flatbuffers::VOffsetT = 6;
    pub const VT_COSTLABOR: flatbuffers::VOffsetT = 8;
    pub const VT_PROVIDELABOR: flatbuffers::VOffsetT = 10;
    pub const VT_SIZE: flatbuffers::VOffsetT = 12;
    pub const VT_OFFSET: flatbuffers::VOffsetT = 14;
    pub const VT_CATEGORY: flatbuffers::VOffsetT = 16;
    pub const VT_STOREYID: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_LayoutData_RoomSlot { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_LayoutData_RoomSlotArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_RoomSlot<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_LayoutData_RoomSlotBuilder::new(_fbb);
        if let Some(x) = args.storeyId {
            builder.add_storeyId(x);
        }
        builder.add_category(args.category);
        if let Some(x) = args.offset {
            builder.add_offset(x);
        }
        if let Some(x) = args.size {
            builder.add_size(x);
        }
        builder.add_provideLabor(args.provideLabor);
        builder.add_costLabor(args.costLabor);
        if let Some(x) = args.cleanCostId {
            builder.add_cleanCostId(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn cleanCostId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_CLEANCOSTID,
                None,
            )
        }
    }
    #[inline]
    pub fn costLabor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_COSTLABOR,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn provideLabor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_PROVIDELABOR,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn size(&self) -> Option<clz_Torappu_GridPosition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                    clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_SIZE,
                    None,
                )
        }
    }
    #[inline]
    pub fn offset(&self) -> Option<clz_Torappu_GridPosition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                    clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_OFFSET,
                    None,
                )
        }
    }
    #[inline]
    pub fn category(&self) -> enum__Torappu_BuildingData_RoomCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_RoomCategory>(
                    clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_CATEGORY,
                    Some(enum__Torappu_BuildingData_RoomCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn storeyId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_STOREYID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_LayoutData_RoomSlot<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "cleanCostId",
                Self::VT_CLEANCOSTID,
                false,
            )?
            .visit_field::<i32>("costLabor", Self::VT_COSTLABOR, false)?
            .visit_field::<i32>("provideLabor", Self::VT_PROVIDELABOR, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                "size",
                Self::VT_SIZE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                "offset",
                Self::VT_OFFSET,
                false,
            )?
            .visit_field::<enum__Torappu_BuildingData_RoomCategory>(
                "category",
                Self::VT_CATEGORY,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "storeyId",
                Self::VT_STOREYID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_LayoutData_RoomSlotArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cleanCostId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub costLabor: i32,
    pub provideLabor: i32,
    pub size: Option<flatbuffers::WIPOffset<clz_Torappu_GridPosition<'a>>>,
    pub offset: Option<flatbuffers::WIPOffset<clz_Torappu_GridPosition<'a>>>,
    pub category: enum__Torappu_BuildingData_RoomCategory,
    pub storeyId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_BuildingData_LayoutData_RoomSlotArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_LayoutData_RoomSlotArgs {
            id: None,
            cleanCostId: None,
            costLabor: 0,
            provideLabor: 0,
            size: None,
            offset: None,
            category: enum__Torappu_BuildingData_RoomCategory::NONE,
            storeyId: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_LayoutData_RoomSlotBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_LayoutData_RoomSlotBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_cleanCostId(&mut self, cleanCostId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_CLEANCOSTID,
            cleanCostId,
        );
    }
    #[inline]
    pub fn add_costLabor(&mut self, costLabor: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_COSTLABOR,
            costLabor,
            0,
        );
    }
    #[inline]
    pub fn add_provideLabor(&mut self, provideLabor: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_PROVIDELABOR,
            provideLabor,
            0,
        );
    }
    #[inline]
    pub fn add_size(&mut self, size: flatbuffers::WIPOffset<clz_Torappu_GridPosition<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_GridPosition>>(
                clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_SIZE,
                size,
            );
    }
    #[inline]
    pub fn add_offset(&mut self, offset: flatbuffers::WIPOffset<clz_Torappu_GridPosition<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_GridPosition>>(
                clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_OFFSET,
                offset,
            );
    }
    #[inline]
    pub fn add_category(&mut self, category: enum__Torappu_BuildingData_RoomCategory) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_RoomCategory>(
                clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_CATEGORY,
                category,
                enum__Torappu_BuildingData_RoomCategory::NONE,
            );
    }
    #[inline]
    pub fn add_storeyId(&mut self, storeyId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_STOREYID,
            storeyId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_LayoutData_RoomSlotBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_LayoutData_RoomSlotBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_RoomSlot<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_LayoutData_RoomSlot<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_LayoutData_RoomSlot");
        ds.field("id", &self.id());
        ds.field("cleanCostId", &self.cleanCostId());
        ds.field("costLabor", &self.costLabor());
        ds.field("provideLabor", &self.provideLabor());
        ds.field("size", &self.size());
        ds.field("offset", &self.offset());
        ds.field("category", &self.category());
        ds.field("storeyId", &self.storeyId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlotOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot<'a>
{
    type Inner = dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlotArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlotBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_LayoutData_RoomSlot<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_LayoutData_RoomSlot>>(
                    dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_LayoutData_RoomSlot>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlotArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_RoomSlot<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlotArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlotArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlotBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlotBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_RoomSlot<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_RoomSlot>>(dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlotBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlotBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'a>
{
    type Inner = clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'a> {
    pub const VT_ITEMS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'bldr>>
    {
        let mut builder =
            clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostBuilder::new(_fbb);
        if let Some(x) = args.items {
            builder.add_items(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn items(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(
                clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost::VT_ITEMS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("items", Self::VT_ITEMS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostArgs<'a> {
    pub items: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostArgs { items: None }
    }
}

pub struct clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_items(
        &mut self,
        items: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost::VT_ITEMS,
            items,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost");
        ds.field("items", &self.items());
        ds.finish()
    }
}
pub enum dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'a>
{
    type Inner = dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostArgs<
            'args,
        >,
    ) -> flatbuffers::WIPOffset<
        dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'bldr>,
    > {
        let mut builder =
            dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostBuilder::new(
                _fbb,
            );
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost,
            >>(
                dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("key", Self::VT_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostArgs<'a> {
    pub key: i32,
    pub value: Option<
        flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'a>>,
    >,
}
impl<'a> Default
    for dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostArgs {
            key: 0,
            value: None,
        }
    }
}

pub struct dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost,
        >>(
            dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostBuilder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCostBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f
            .debug_struct("dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_LayoutData_SlotCleanCostOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'a> {
    type Inner = clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NUMBER: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_LayoutData_SlotCleanCost { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_LayoutData_SlotCleanCostArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_LayoutData_SlotCleanCostBuilder::new(_fbb);
        if let Some(x) = args.number {
            builder.add_number(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_LayoutData_SlotCleanCost::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn number(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost,
                    >,
                >,
            >>(
                clz_Torappu_BuildingData_LayoutData_SlotCleanCost::VT_NUMBER,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost,
                    >,
                >,
            >>("number", Self::VT_NUMBER, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_LayoutData_SlotCleanCostArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub number: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_LayoutData_SlotCleanCostArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_LayoutData_SlotCleanCostArgs {
            id: None,
            number: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_LayoutData_SlotCleanCostBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_LayoutData_SlotCleanCostBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_LayoutData_SlotCleanCost::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_number(
        &mut self,
        number: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_BuildingData_LayoutData_SlotCleanCost_CountCost<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_LayoutData_SlotCleanCost::VT_NUMBER,
            number,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_LayoutData_SlotCleanCostBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_LayoutData_SlotCleanCostBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_LayoutData_SlotCleanCost");
        ds.field("id", &self.id());
        ds.field("number", &self.number());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCostOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'a>
{
    type Inner = dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCostArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCostBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_LayoutData_SlotCleanCost>>(dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_LayoutData_SlotCleanCost>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCostArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCostArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCostArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCostBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCostBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_SlotCleanCost>>(dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCostBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCostBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_LayoutData_StoreyDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_LayoutData_StoreyData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_LayoutData_StoreyData<'a> {
    type Inner = clz_Torappu_BuildingData_LayoutData_StoreyData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_LayoutData_StoreyData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_YOFFSET: flatbuffers::VOffsetT = 6;
    pub const VT_UNLOCKCONTROLLEVEL: flatbuffers::VOffsetT = 8;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_LayoutData_StoreyData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_LayoutData_StoreyDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_StoreyData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_LayoutData_StoreyDataBuilder::new(_fbb);
        builder.add_type_(args.type_);
        builder.add_unlockControlLevel(args.unlockControlLevel);
        builder.add_yOffset(args.yOffset);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_LayoutData_StoreyData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn yOffset(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_LayoutData_StoreyData::VT_YOFFSET,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn unlockControlLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_LayoutData_StoreyData::VT_UNLOCKCONTROLLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_BuildingData_LayoutData_StoreyData_Type {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_LayoutData_StoreyData_Type>(
                    clz_Torappu_BuildingData_LayoutData_StoreyData::VT_TYPE_,
                    Some(enum__Torappu_BuildingData_LayoutData_StoreyData_Type::UPGROUND),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_LayoutData_StoreyData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("yOffset", Self::VT_YOFFSET, false)?
            .visit_field::<i32>("unlockControlLevel", Self::VT_UNLOCKCONTROLLEVEL, false)?
            .visit_field::<enum__Torappu_BuildingData_LayoutData_StoreyData_Type>(
                "type_",
                Self::VT_TYPE_,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_LayoutData_StoreyDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub yOffset: i32,
    pub unlockControlLevel: i32,
    pub type_: enum__Torappu_BuildingData_LayoutData_StoreyData_Type,
}
impl<'a> Default for clz_Torappu_BuildingData_LayoutData_StoreyDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_LayoutData_StoreyDataArgs {
            id: None,
            yOffset: 0,
            unlockControlLevel: 0,
            type_: enum__Torappu_BuildingData_LayoutData_StoreyData_Type::UPGROUND,
        }
    }
}

pub struct clz_Torappu_BuildingData_LayoutData_StoreyDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_LayoutData_StoreyDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_LayoutData_StoreyData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_yOffset(&mut self, yOffset: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_LayoutData_StoreyData::VT_YOFFSET,
            yOffset,
            0,
        );
    }
    #[inline]
    pub fn add_unlockControlLevel(&mut self, unlockControlLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_LayoutData_StoreyData::VT_UNLOCKCONTROLLEVEL,
            unlockControlLevel,
            0,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_BuildingData_LayoutData_StoreyData_Type) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_LayoutData_StoreyData_Type>(
                clz_Torappu_BuildingData_LayoutData_StoreyData::VT_TYPE_,
                type_,
                enum__Torappu_BuildingData_LayoutData_StoreyData_Type::UPGROUND,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_LayoutData_StoreyDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_LayoutData_StoreyDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_StoreyData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_LayoutData_StoreyData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_LayoutData_StoreyData");
        ds.field("id", &self.id());
        ds.field("yOffset", &self.yOffset());
        ds.field("unlockControlLevel", &self.unlockControlLevel());
        ds.field("type_", &self.type_());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_LayoutData_StoreyDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData<'a>
{
    type Inner = dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_LayoutData_StoreyDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_BuildingData_LayoutData_StoreyDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_LayoutData_StoreyData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_LayoutData_StoreyData>>(dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_LayoutData_StoreyData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_LayoutData_StoreyDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_StoreyData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_LayoutData_StoreyDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_LayoutData_StoreyDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_LayoutData_StoreyDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_LayoutData_StoreyDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_StoreyData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData_StoreyData>>(dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_LayoutData_StoreyDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_LayoutData_StoreyDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_LayoutDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_LayoutData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_LayoutData<'a> {
    type Inner = clz_Torappu_BuildingData_LayoutData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_LayoutData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SLOTS: flatbuffers::VOffsetT = 6;
    pub const VT_CLEANCOSTS: flatbuffers::VOffsetT = 8;
    pub const VT_STOREYS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_LayoutData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_LayoutDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_LayoutDataBuilder::new(_fbb);
        if let Some(x) = args.storeys {
            builder.add_storeys(x);
        }
        if let Some(x) = args.cleanCosts {
            builder.add_cleanCosts(x);
        }
        if let Some(x) = args.slots {
            builder.add_slots(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_LayoutData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn slots(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot,
                    >,
                >,
            >>(clz_Torappu_BuildingData_LayoutData::VT_SLOTS, None)
        }
    }
    #[inline]
    pub fn cleanCosts(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost,
                    >,
                >,
            >>(clz_Torappu_BuildingData_LayoutData::VT_CLEANCOSTS, None)
        }
    }
    #[inline]
    pub fn storeys(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData,
                    >,
                >,
            >>(clz_Torappu_BuildingData_LayoutData::VT_STOREYS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_LayoutData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot,
                    >,
                >,
            >>("slots", Self::VT_SLOTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost,
                    >,
                >,
            >>("cleanCosts", Self::VT_CLEANCOSTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData,
                    >,
                >,
            >>("storeys", Self::VT_STOREYS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_LayoutDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub slots: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot<'a>,
                >,
            >,
        >,
    >,
    pub cleanCosts: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'a>,
                >,
            >,
        >,
    >,
    pub storeys: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_LayoutDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_LayoutDataArgs {
            id: None,
            slots: None,
            cleanCosts: None,
            storeys: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_LayoutDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_LayoutDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_LayoutData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_slots(
        &mut self,
        slots: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_LayoutData_RoomSlot<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_LayoutData::VT_SLOTS,
            slots,
        );
    }
    #[inline]
    pub fn add_cleanCosts(
        &mut self,
        cleanCosts: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_LayoutData_SlotCleanCost<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_LayoutData::VT_CLEANCOSTS,
            cleanCosts,
        );
    }
    #[inline]
    pub fn add_storeys(
        &mut self,
        storeys: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_LayoutData_StoreyData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_LayoutData::VT_STOREYS,
            storeys,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_LayoutDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_LayoutDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_LayoutData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_LayoutData");
        ds.field("id", &self.id());
        ds.field("slots", &self.slots());
        ds.field("cleanCosts", &self.cleanCosts());
        ds.field("storeys", &self.storeys());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_LayoutDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_LayoutData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_BuildingData_LayoutData<'a> {
    type Inner = dict__string__clz_Torappu_BuildingData_LayoutData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_LayoutData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_LayoutData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_LayoutDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_LayoutData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_BuildingData_LayoutDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_LayoutData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_LayoutData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_LayoutData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_LayoutData>>(
                    dict__string__clz_Torappu_BuildingData_LayoutData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_LayoutData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_LayoutData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_LayoutDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_LayoutDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_LayoutDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_LayoutDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_LayoutDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_LayoutData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_LayoutData>>(
                dict__string__clz_Torappu_BuildingData_LayoutData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_LayoutDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_LayoutDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_LayoutData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_LayoutData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_LayoutData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_LayoutData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_PrefabInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_PrefabInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_PrefabInfo<'a> {
    type Inner = clz_Torappu_BuildingData_PrefabInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_PrefabInfo<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_BLUEPRINTROOMOVERRIDEID: flatbuffers::VOffsetT = 6;
    pub const VT_SIZE: flatbuffers::VOffsetT = 8;
    pub const VT_FLOORGRIDSIZE: flatbuffers::VOffsetT = 10;
    pub const VT_BACKWALLGRIDSIZE: flatbuffers::VOffsetT = 12;
    pub const VT_OBSTACLEID: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_PrefabInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_PrefabInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_PrefabInfo<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_PrefabInfoBuilder::new(_fbb);
        if let Some(x) = args.obstacleId {
            builder.add_obstacleId(x);
        }
        if let Some(x) = args.backWallGridSize {
            builder.add_backWallGridSize(x);
        }
        if let Some(x) = args.floorGridSize {
            builder.add_floorGridSize(x);
        }
        if let Some(x) = args.size {
            builder.add_size(x);
        }
        if let Some(x) = args.blueprintRoomOverrideId {
            builder.add_blueprintRoomOverrideId(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_PrefabInfo::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn blueprintRoomOverrideId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_PrefabInfo::VT_BLUEPRINTROOMOVERRIDEID,
                None,
            )
        }
    }
    #[inline]
    pub fn size(&self) -> Option<clz_Torappu_GridPosition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                    clz_Torappu_BuildingData_PrefabInfo::VT_SIZE,
                    None,
                )
        }
    }
    #[inline]
    pub fn floorGridSize(&self) -> Option<clz_Torappu_GridPosition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                    clz_Torappu_BuildingData_PrefabInfo::VT_FLOORGRIDSIZE,
                    None,
                )
        }
    }
    #[inline]
    pub fn backWallGridSize(&self) -> Option<clz_Torappu_GridPosition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                    clz_Torappu_BuildingData_PrefabInfo::VT_BACKWALLGRIDSIZE,
                    None,
                )
        }
    }
    #[inline]
    pub fn obstacleId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_PrefabInfo::VT_OBSTACLEID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_PrefabInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "blueprintRoomOverrideId",
                Self::VT_BLUEPRINTROOMOVERRIDEID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                "size",
                Self::VT_SIZE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                "floorGridSize",
                Self::VT_FLOORGRIDSIZE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_GridPosition>>(
                "backWallGridSize",
                Self::VT_BACKWALLGRIDSIZE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obstacleId",
                Self::VT_OBSTACLEID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_PrefabInfoArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub blueprintRoomOverrideId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub size: Option<flatbuffers::WIPOffset<clz_Torappu_GridPosition<'a>>>,
    pub floorGridSize: Option<flatbuffers::WIPOffset<clz_Torappu_GridPosition<'a>>>,
    pub backWallGridSize: Option<flatbuffers::WIPOffset<clz_Torappu_GridPosition<'a>>>,
    pub obstacleId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_BuildingData_PrefabInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_PrefabInfoArgs {
            id: None,
            blueprintRoomOverrideId: None,
            size: None,
            floorGridSize: None,
            backWallGridSize: None,
            obstacleId: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_PrefabInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_PrefabInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_PrefabInfo::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_blueprintRoomOverrideId(
        &mut self,
        blueprintRoomOverrideId: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_PrefabInfo::VT_BLUEPRINTROOMOVERRIDEID,
            blueprintRoomOverrideId,
        );
    }
    #[inline]
    pub fn add_size(&mut self, size: flatbuffers::WIPOffset<clz_Torappu_GridPosition<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_GridPosition>>(
                clz_Torappu_BuildingData_PrefabInfo::VT_SIZE,
                size,
            );
    }
    #[inline]
    pub fn add_floorGridSize(
        &mut self,
        floorGridSize: flatbuffers::WIPOffset<clz_Torappu_GridPosition<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_GridPosition>>(
                clz_Torappu_BuildingData_PrefabInfo::VT_FLOORGRIDSIZE,
                floorGridSize,
            );
    }
    #[inline]
    pub fn add_backWallGridSize(
        &mut self,
        backWallGridSize: flatbuffers::WIPOffset<clz_Torappu_GridPosition<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_GridPosition>>(
                clz_Torappu_BuildingData_PrefabInfo::VT_BACKWALLGRIDSIZE,
                backWallGridSize,
            );
    }
    #[inline]
    pub fn add_obstacleId(&mut self, obstacleId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_PrefabInfo::VT_OBSTACLEID,
            obstacleId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_PrefabInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_PrefabInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_PrefabInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_PrefabInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_PrefabInfo");
        ds.field("id", &self.id());
        ds.field("blueprintRoomOverrideId", &self.blueprintRoomOverrideId());
        ds.field("size", &self.size());
        ds.field("floorGridSize", &self.floorGridSize());
        ds.field("backWallGridSize", &self.backWallGridSize());
        ds.field("obstacleId", &self.obstacleId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_PrefabInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_PrefabInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_BuildingData_PrefabInfo<'a> {
    type Inner = dict__string__clz_Torappu_BuildingData_PrefabInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_PrefabInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_PrefabInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_PrefabInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_PrefabInfo<'bldr>> {
        let mut builder = dict__string__clz_Torappu_BuildingData_PrefabInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_PrefabInfo::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_PrefabInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_PrefabInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_PrefabInfo>>(
                    dict__string__clz_Torappu_BuildingData_PrefabInfo::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_PrefabInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_PrefabInfo>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_PrefabInfoArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_PrefabInfo<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_PrefabInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_PrefabInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_PrefabInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_PrefabInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_PrefabInfo::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_PrefabInfo<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_PrefabInfo>>(
                dict__string__clz_Torappu_BuildingData_PrefabInfo::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_PrefabInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_PrefabInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_PrefabInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_PrefabInfo::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_PrefabInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_PrefabInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_ControlRoomPhaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_ControlRoomPhase<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_ControlRoomPhase<'a> {
    type Inner = clz_Torappu_BuildingData_ControlRoomPhase<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_ControlRoomPhase<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_ControlRoomPhase { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        _args: &'args clz_Torappu_BuildingData_ControlRoomPhaseArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ControlRoomPhase<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_ControlRoomPhaseBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_ControlRoomPhase<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_ControlRoomPhaseArgs {}
impl<'a> Default for clz_Torappu_BuildingData_ControlRoomPhaseArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_ControlRoomPhaseArgs {}
    }
}

pub struct clz_Torappu_BuildingData_ControlRoomPhaseBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_ControlRoomPhaseBuilder<'a, 'b, A>
{
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_ControlRoomPhaseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_ControlRoomPhaseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ControlRoomPhase<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_ControlRoomPhase<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_ControlRoomPhase");
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_ControlRoomBeanOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_ControlRoomBean<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_ControlRoomBean<'a> {
    type Inner = clz_Torappu_BuildingData_ControlRoomBean<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_ControlRoomBean<'a> {
    pub const VT_BASICCOSTBUFF: flatbuffers::VOffsetT = 4;
    pub const VT_PHASES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_ControlRoomBean { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_ControlRoomBeanArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ControlRoomBean<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_ControlRoomBeanBuilder::new(_fbb);
        if let Some(x) = args.phases {
            builder.add_phases(x);
        }
        builder.add_basicCostBuff(args.basicCostBuff);
        builder.finish()
    }

    #[inline]
    pub fn basicCostBuff(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_ControlRoomBean::VT_BASICCOSTBUFF,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn phases(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ControlRoomPhase<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ControlRoomPhase>,
                >,
            >>(clz_Torappu_BuildingData_ControlRoomBean::VT_PHASES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_ControlRoomBean<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("basicCostBuff", Self::VT_BASICCOSTBUFF, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ControlRoomPhase>,
                >,
            >>("phases", Self::VT_PHASES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_ControlRoomBeanArgs<'a> {
    pub basicCostBuff: i32,
    pub phases: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ControlRoomPhase<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_ControlRoomBeanArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_ControlRoomBeanArgs {
            basicCostBuff: 0,
            phases: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_ControlRoomBeanBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_ControlRoomBeanBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_basicCostBuff(&mut self, basicCostBuff: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_ControlRoomBean::VT_BASICCOSTBUFF,
            basicCostBuff,
            0,
        );
    }
    #[inline]
    pub fn add_phases(
        &mut self,
        phases: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ControlRoomPhase<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_ControlRoomBean::VT_PHASES,
            phases,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_ControlRoomBeanBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_ControlRoomBeanBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ControlRoomBean<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_ControlRoomBean<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_ControlRoomBean");
        ds.field("basicCostBuff", &self.basicCostBuff());
        ds.field("phases", &self.phases());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_ManufactPhaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_ManufactPhase<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_ManufactPhase<'a> {
    type Inner = clz_Torappu_BuildingData_ManufactPhase<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_ManufactPhase<'a> {
    pub const VT_SPEED: flatbuffers::VOffsetT = 4;
    pub const VT_OUTPUTCAPACITY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_ManufactPhase { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_ManufactPhaseArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactPhase<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_ManufactPhaseBuilder::new(_fbb);
        builder.add_outputCapacity(args.outputCapacity);
        builder.add_speed(args.speed);
        builder.finish()
    }

    #[inline]
    pub fn speed(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_BuildingData_ManufactPhase::VT_SPEED, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn outputCapacity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_ManufactPhase::VT_OUTPUTCAPACITY,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_ManufactPhase<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("speed", Self::VT_SPEED, false)?
            .visit_field::<i32>("outputCapacity", Self::VT_OUTPUTCAPACITY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_ManufactPhaseArgs {
    pub speed: f32,
    pub outputCapacity: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_ManufactPhaseArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_ManufactPhaseArgs {
            speed: 0.0,
            outputCapacity: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_ManufactPhaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_ManufactPhaseBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_speed(&mut self, speed: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_BuildingData_ManufactPhase::VT_SPEED, speed, 0.0);
    }
    #[inline]
    pub fn add_outputCapacity(&mut self, outputCapacity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_ManufactPhase::VT_OUTPUTCAPACITY,
            outputCapacity,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_ManufactPhaseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_ManufactPhaseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactPhase<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_ManufactPhase<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_ManufactPhase");
        ds.field("speed", &self.speed());
        ds.field("outputCapacity", &self.outputCapacity());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_ManufactRoomBeanOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_ManufactRoomBean<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_ManufactRoomBean<'a> {
    type Inner = clz_Torappu_BuildingData_ManufactRoomBean<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_ManufactRoomBean<'a> {
    pub const VT_BASICSPEEDBUFF: flatbuffers::VOffsetT = 4;
    pub const VT_PHASES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_ManufactRoomBean { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_ManufactRoomBeanArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactRoomBean<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_ManufactRoomBeanBuilder::new(_fbb);
        if let Some(x) = args.phases {
            builder.add_phases(x);
        }
        builder.add_basicSpeedBuff(args.basicSpeedBuff);
        builder.finish()
    }

    #[inline]
    pub fn basicSpeedBuff(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_BuildingData_ManufactRoomBean::VT_BASICSPEEDBUFF,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn phases(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ManufactPhase<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ManufactPhase>,
                >,
            >>(clz_Torappu_BuildingData_ManufactRoomBean::VT_PHASES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_ManufactRoomBean<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("basicSpeedBuff", Self::VT_BASICSPEEDBUFF, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ManufactPhase>,
                >,
            >>("phases", Self::VT_PHASES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_ManufactRoomBeanArgs<'a> {
    pub basicSpeedBuff: f32,
    pub phases: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ManufactPhase<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_ManufactRoomBeanArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_ManufactRoomBeanArgs {
            basicSpeedBuff: 0.0,
            phases: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_ManufactRoomBeanBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_ManufactRoomBeanBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_basicSpeedBuff(&mut self, basicSpeedBuff: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_BuildingData_ManufactRoomBean::VT_BASICSPEEDBUFF,
            basicSpeedBuff,
            0.0,
        );
    }
    #[inline]
    pub fn add_phases(
        &mut self,
        phases: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ManufactPhase<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_ManufactRoomBean::VT_PHASES,
            phases,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_ManufactRoomBeanBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_ManufactRoomBeanBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactRoomBean<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_ManufactRoomBean<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_ManufactRoomBean");
        ds.field("basicSpeedBuff", &self.basicSpeedBuff());
        ds.field("phases", &self.phases());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_ShopPhaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_ShopPhase<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_ShopPhase<'a> {
    type Inner = clz_Torappu_BuildingData_ShopPhase<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_ShopPhase<'a> {
    pub const VT_COUNTERNUM: flatbuffers::VOffsetT = 4;
    pub const VT_SPEED: flatbuffers::VOffsetT = 6;
    pub const VT_MONEYCAPACITY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_ShopPhase { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_ShopPhaseArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ShopPhase<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_ShopPhaseBuilder::new(_fbb);
        builder.add_moneyCapacity(args.moneyCapacity);
        builder.add_speed(args.speed);
        builder.add_counterNum(args.counterNum);
        builder.finish()
    }

    #[inline]
    pub fn counterNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData_ShopPhase::VT_COUNTERNUM, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn speed(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_BuildingData_ShopPhase::VT_SPEED, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn moneyCapacity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_ShopPhase::VT_MONEYCAPACITY,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_ShopPhase<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("counterNum", Self::VT_COUNTERNUM, false)?
            .visit_field::<f32>("speed", Self::VT_SPEED, false)?
            .visit_field::<i32>("moneyCapacity", Self::VT_MONEYCAPACITY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_ShopPhaseArgs {
    pub counterNum: i32,
    pub speed: f32,
    pub moneyCapacity: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_ShopPhaseArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_ShopPhaseArgs {
            counterNum: 0,
            speed: 0.0,
            moneyCapacity: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_ShopPhaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_ShopPhaseBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_counterNum(&mut self, counterNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_ShopPhase::VT_COUNTERNUM,
            counterNum,
            0,
        );
    }
    #[inline]
    pub fn add_speed(&mut self, speed: f32) {
        self.fbb_
            .push_slot::<f32>(clz_Torappu_BuildingData_ShopPhase::VT_SPEED, speed, 0.0);
    }
    #[inline]
    pub fn add_moneyCapacity(&mut self, moneyCapacity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_ShopPhase::VT_MONEYCAPACITY,
            moneyCapacity,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_ShopPhaseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_ShopPhaseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ShopPhase<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_ShopPhase<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_ShopPhase");
        ds.field("counterNum", &self.counterNum());
        ds.field("speed", &self.speed());
        ds.field("moneyCapacity", &self.moneyCapacity());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_<'a>
{
    type Inner = clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_<'a> {
    pub const VT_PHASES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_Args<'args>,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_<'bldr>,
    > {
        let mut builder =
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_Builder::new(_fbb);
        if let Some(x) = args.phases {
            builder.add_phases(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn phases(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ShopPhase<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ShopPhase>,
                >,
            >>(
                clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_::VT_PHASES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ShopPhase>,
                >,
            >>("phases", Self::VT_PHASES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_Args<'a> {
    pub phases: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ShopPhase<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_Args<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_Args { phases: None }
    }
}

pub struct clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_phases(
        &mut self,
        phases: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ShopPhase<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_::VT_PHASES,
            phases,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_");
        ds.field("phases", &self.phases());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_HirePhaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_HirePhase<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_HirePhase<'a> {
    type Inner = clz_Torappu_BuildingData_HirePhase<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_HirePhase<'a> {
    pub const VT_ECONOMIZERATE: flatbuffers::VOffsetT = 4;
    pub const VT_RESSPEED: flatbuffers::VOffsetT = 6;
    pub const VT_REFRESHTIMES: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_HirePhase { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_HirePhaseArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_HirePhase<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_HirePhaseBuilder::new(_fbb);
        builder.add_refreshTimes(args.refreshTimes);
        builder.add_resSpeed(args.resSpeed);
        builder.add_economizeRate(args.economizeRate);
        builder.finish()
    }

    #[inline]
    pub fn economizeRate(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_BuildingData_HirePhase::VT_ECONOMIZERATE,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn resSpeed(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData_HirePhase::VT_RESSPEED, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn refreshTimes(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData_HirePhase::VT_REFRESHTIMES, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_HirePhase<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("economizeRate", Self::VT_ECONOMIZERATE, false)?
            .visit_field::<i32>("resSpeed", Self::VT_RESSPEED, false)?
            .visit_field::<i32>("refreshTimes", Self::VT_REFRESHTIMES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_HirePhaseArgs {
    pub economizeRate: f32,
    pub resSpeed: i32,
    pub refreshTimes: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_HirePhaseArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_HirePhaseArgs {
            economizeRate: 0.0,
            resSpeed: 0,
            refreshTimes: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_HirePhaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_HirePhaseBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_economizeRate(&mut self, economizeRate: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_BuildingData_HirePhase::VT_ECONOMIZERATE,
            economizeRate,
            0.0,
        );
    }
    #[inline]
    pub fn add_resSpeed(&mut self, resSpeed: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_BuildingData_HirePhase::VT_RESSPEED, resSpeed, 0);
    }
    #[inline]
    pub fn add_refreshTimes(&mut self, refreshTimes: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_HirePhase::VT_REFRESHTIMES,
            refreshTimes,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_HirePhaseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_HirePhaseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_HirePhase<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_HirePhase<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_HirePhase");
        ds.field("economizeRate", &self.economizeRate());
        ds.field("resSpeed", &self.resSpeed());
        ds.field("refreshTimes", &self.refreshTimes());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_HireRoomBeanOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_HireRoomBean<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_HireRoomBean<'a> {
    type Inner = clz_Torappu_BuildingData_HireRoomBean<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_HireRoomBean<'a> {
    pub const VT_BASICSPEEDBUFF: flatbuffers::VOffsetT = 4;
    pub const VT_PHASES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_HireRoomBean { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_HireRoomBeanArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_HireRoomBean<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_HireRoomBeanBuilder::new(_fbb);
        if let Some(x) = args.phases {
            builder.add_phases(x);
        }
        builder.add_basicSpeedBuff(args.basicSpeedBuff);
        builder.finish()
    }

    #[inline]
    pub fn basicSpeedBuff(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_BuildingData_HireRoomBean::VT_BASICSPEEDBUFF,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn phases(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_HirePhase<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_HirePhase>,
                >,
            >>(clz_Torappu_BuildingData_HireRoomBean::VT_PHASES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_HireRoomBean<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("basicSpeedBuff", Self::VT_BASICSPEEDBUFF, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_HirePhase>,
                >,
            >>("phases", Self::VT_PHASES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_HireRoomBeanArgs<'a> {
    pub basicSpeedBuff: f32,
    pub phases: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_HirePhase<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_HireRoomBeanArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_HireRoomBeanArgs {
            basicSpeedBuff: 0.0,
            phases: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_HireRoomBeanBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_HireRoomBeanBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_basicSpeedBuff(&mut self, basicSpeedBuff: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_BuildingData_HireRoomBean::VT_BASICSPEEDBUFF,
            basicSpeedBuff,
            0.0,
        );
    }
    #[inline]
    pub fn add_phases(
        &mut self,
        phases: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_HirePhase<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_HireRoomBean::VT_PHASES,
            phases,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_HireRoomBeanBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_HireRoomBeanBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_HireRoomBean<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_HireRoomBean<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_HireRoomBean");
        ds.field("basicSpeedBuff", &self.basicSpeedBuff());
        ds.field("phases", &self.phases());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_DormPhaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_DormPhase<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_DormPhase<'a> {
    type Inner = clz_Torappu_BuildingData_DormPhase<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_DormPhase<'a> {
    pub const VT_MANPOWERRECOVER: flatbuffers::VOffsetT = 4;
    pub const VT_DECORATIONLIMIT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_DormPhase { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_DormPhaseArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_DormPhase<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_DormPhaseBuilder::new(_fbb);
        builder.add_decorationLimit(args.decorationLimit);
        builder.add_manpowerRecover(args.manpowerRecover);
        builder.finish()
    }

    #[inline]
    pub fn manpowerRecover(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_DormPhase::VT_MANPOWERRECOVER,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn decorationLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_DormPhase::VT_DECORATIONLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_DormPhase<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("manpowerRecover", Self::VT_MANPOWERRECOVER, false)?
            .visit_field::<i32>("decorationLimit", Self::VT_DECORATIONLIMIT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_DormPhaseArgs {
    pub manpowerRecover: i32,
    pub decorationLimit: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_DormPhaseArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_DormPhaseArgs {
            manpowerRecover: 0,
            decorationLimit: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_DormPhaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_DormPhaseBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_manpowerRecover(&mut self, manpowerRecover: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_DormPhase::VT_MANPOWERRECOVER,
            manpowerRecover,
            0,
        );
    }
    #[inline]
    pub fn add_decorationLimit(&mut self, decorationLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_DormPhase::VT_DECORATIONLIMIT,
            decorationLimit,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_DormPhaseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_DormPhaseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_DormPhase<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_DormPhase<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_DormPhase");
        ds.field("manpowerRecover", &self.manpowerRecover());
        ds.field("decorationLimit", &self.decorationLimit());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_<'a>
{
    type Inner = clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_<'a> {
    pub const VT_PHASES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_Args<'args>,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_<'bldr>,
    > {
        let mut builder =
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_Builder::new(_fbb);
        if let Some(x) = args.phases {
            builder.add_phases(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn phases(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_DormPhase<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_DormPhase>,
                >,
            >>(
                clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_::VT_PHASES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_DormPhase>,
                >,
            >>("phases", Self::VT_PHASES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_Args<'a> {
    pub phases: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_DormPhase<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_Args<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_Args { phases: None }
    }
}

pub struct clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_phases(
        &mut self,
        phases: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_DormPhase<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_::VT_PHASES,
            phases,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_");
        ds.field("phases", &self.phases());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_PrivatePhaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_PrivatePhase<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_PrivatePhase<'a> {
    type Inner = clz_Torappu_BuildingData_PrivatePhase<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_PrivatePhase<'a> {
    pub const VT_DECORATIONLIMIT: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_PrivatePhase { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_PrivatePhaseArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_PrivatePhase<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_PrivatePhaseBuilder::new(_fbb);
        builder.add_decorationLimit(args.decorationLimit);
        builder.finish()
    }

    #[inline]
    pub fn decorationLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_PrivatePhase::VT_DECORATIONLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_PrivatePhase<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("decorationLimit", Self::VT_DECORATIONLIMIT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_PrivatePhaseArgs {
    pub decorationLimit: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_PrivatePhaseArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_PrivatePhaseArgs { decorationLimit: 0 }
    }
}

pub struct clz_Torappu_BuildingData_PrivatePhaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_PrivatePhaseBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_decorationLimit(&mut self, decorationLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_PrivatePhase::VT_DECORATIONLIMIT,
            decorationLimit,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_PrivatePhaseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_PrivatePhaseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_PrivatePhase<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_PrivatePhase<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_PrivatePhase");
        ds.field("decorationLimit", &self.decorationLimit());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_<'a>
{
    type Inner = clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_<'a> {
    pub const VT_PHASES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_Args<
            'args,
        >,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_<'bldr>,
    > {
        let mut builder =
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_Builder::new(
                _fbb,
            );
        if let Some(x) = args.phases {
            builder.add_phases(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn phases(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_PrivatePhase<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_PrivatePhase>,
                >,
            >>(
                clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_::VT_PHASES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_PrivatePhase>,
                >,
            >>("phases", Self::VT_PHASES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_Args<'a> {
    pub phases: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_PrivatePhase<'a>>,
            >,
        >,
    >,
}
impl<'a> Default
    for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_Args<'a>
{
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_Args { phases: None }
    }
}

pub struct clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_phases(
        &mut self,
        phases: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_PrivatePhase<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_::VT_PHASES,
            phases,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_Builder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f
            .debug_struct("clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_");
        ds.field("phases", &self.phases());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_MeetingPhaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_MeetingPhase<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_MeetingPhase<'a> {
    type Inner = clz_Torappu_BuildingData_MeetingPhase<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_MeetingPhase<'a> {
    pub const VT_FRIENDSLOTINC: flatbuffers::VOffsetT = 4;
    pub const VT_MAXVISITORNUM: flatbuffers::VOffsetT = 6;
    pub const VT_GATHERINGSPEED: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_MeetingPhase { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_MeetingPhaseArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_MeetingPhase<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_MeetingPhaseBuilder::new(_fbb);
        builder.add_gatheringSpeed(args.gatheringSpeed);
        builder.add_maxVisitorNum(args.maxVisitorNum);
        builder.add_friendSlotInc(args.friendSlotInc);
        builder.finish()
    }

    #[inline]
    pub fn friendSlotInc(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_MeetingPhase::VT_FRIENDSLOTINC,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn maxVisitorNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_MeetingPhase::VT_MAXVISITORNUM,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn gatheringSpeed(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_MeetingPhase::VT_GATHERINGSPEED,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_MeetingPhase<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("friendSlotInc", Self::VT_FRIENDSLOTINC, false)?
            .visit_field::<i32>("maxVisitorNum", Self::VT_MAXVISITORNUM, false)?
            .visit_field::<i32>("gatheringSpeed", Self::VT_GATHERINGSPEED, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_MeetingPhaseArgs {
    pub friendSlotInc: i32,
    pub maxVisitorNum: i32,
    pub gatheringSpeed: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_MeetingPhaseArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_MeetingPhaseArgs {
            friendSlotInc: 0,
            maxVisitorNum: 0,
            gatheringSpeed: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_MeetingPhaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_MeetingPhaseBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_friendSlotInc(&mut self, friendSlotInc: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_MeetingPhase::VT_FRIENDSLOTINC,
            friendSlotInc,
            0,
        );
    }
    #[inline]
    pub fn add_maxVisitorNum(&mut self, maxVisitorNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_MeetingPhase::VT_MAXVISITORNUM,
            maxVisitorNum,
            0,
        );
    }
    #[inline]
    pub fn add_gatheringSpeed(&mut self, gatheringSpeed: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_MeetingPhase::VT_GATHERINGSPEED,
            gatheringSpeed,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_MeetingPhaseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_MeetingPhaseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_MeetingPhase<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_MeetingPhase<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_MeetingPhase");
        ds.field("friendSlotInc", &self.friendSlotInc());
        ds.field("maxVisitorNum", &self.maxVisitorNum());
        ds.field("gatheringSpeed", &self.gatheringSpeed());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_MeetingRoomBeanOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_MeetingRoomBean<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_MeetingRoomBean<'a> {
    type Inner = clz_Torappu_BuildingData_MeetingRoomBean<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_MeetingRoomBean<'a> {
    pub const VT_BASICSPEEDBUFF: flatbuffers::VOffsetT = 4;
    pub const VT_PHASES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_MeetingRoomBean { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_MeetingRoomBeanArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_MeetingRoomBean<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_MeetingRoomBeanBuilder::new(_fbb);
        if let Some(x) = args.phases {
            builder.add_phases(x);
        }
        builder.add_basicSpeedBuff(args.basicSpeedBuff);
        builder.finish()
    }

    #[inline]
    pub fn basicSpeedBuff(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_BuildingData_MeetingRoomBean::VT_BASICSPEEDBUFF,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn phases(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_MeetingPhase<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_MeetingPhase>,
                >,
            >>(clz_Torappu_BuildingData_MeetingRoomBean::VT_PHASES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_MeetingRoomBean<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("basicSpeedBuff", Self::VT_BASICSPEEDBUFF, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_MeetingPhase>,
                >,
            >>("phases", Self::VT_PHASES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_MeetingRoomBeanArgs<'a> {
    pub basicSpeedBuff: f32,
    pub phases: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_MeetingPhase<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_MeetingRoomBeanArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_MeetingRoomBeanArgs {
            basicSpeedBuff: 0.0,
            phases: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_MeetingRoomBeanBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_MeetingRoomBeanBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_basicSpeedBuff(&mut self, basicSpeedBuff: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_BuildingData_MeetingRoomBean::VT_BASICSPEEDBUFF,
            basicSpeedBuff,
            0.0,
        );
    }
    #[inline]
    pub fn add_phases(
        &mut self,
        phases: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_MeetingPhase<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_MeetingRoomBean::VT_PHASES,
            phases,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_MeetingRoomBeanBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_MeetingRoomBeanBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_MeetingRoomBean<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_MeetingRoomBean<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_MeetingRoomBean");
        ds.field("basicSpeedBuff", &self.basicSpeedBuff());
        ds.field("phases", &self.phases());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_TradingPhaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_TradingPhase<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_TradingPhase<'a> {
    type Inner = clz_Torappu_BuildingData_TradingPhase<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_TradingPhase<'a> {
    pub const VT_ORDERSPEED: flatbuffers::VOffsetT = 4;
    pub const VT_ORDERLIMIT: flatbuffers::VOffsetT = 6;
    pub const VT_ORDERRARITY: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_TradingPhase { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_TradingPhaseArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_TradingPhase<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_TradingPhaseBuilder::new(_fbb);
        builder.add_orderRarity(args.orderRarity);
        builder.add_orderLimit(args.orderLimit);
        builder.add_orderSpeed(args.orderSpeed);
        builder.finish()
    }

    #[inline]
    pub fn orderSpeed(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_BuildingData_TradingPhase::VT_ORDERSPEED,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn orderLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_TradingPhase::VT_ORDERLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn orderRarity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_TradingPhase::VT_ORDERRARITY,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_TradingPhase<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("orderSpeed", Self::VT_ORDERSPEED, false)?
            .visit_field::<i32>("orderLimit", Self::VT_ORDERLIMIT, false)?
            .visit_field::<i32>("orderRarity", Self::VT_ORDERRARITY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_TradingPhaseArgs {
    pub orderSpeed: f32,
    pub orderLimit: i32,
    pub orderRarity: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_TradingPhaseArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_TradingPhaseArgs {
            orderSpeed: 0.0,
            orderLimit: 0,
            orderRarity: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_TradingPhaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_TradingPhaseBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_orderSpeed(&mut self, orderSpeed: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_BuildingData_TradingPhase::VT_ORDERSPEED,
            orderSpeed,
            0.0,
        );
    }
    #[inline]
    pub fn add_orderLimit(&mut self, orderLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_TradingPhase::VT_ORDERLIMIT,
            orderLimit,
            0,
        );
    }
    #[inline]
    pub fn add_orderRarity(&mut self, orderRarity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_TradingPhase::VT_ORDERRARITY,
            orderRarity,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_TradingPhaseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_TradingPhaseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_TradingPhase<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_TradingPhase<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_TradingPhase");
        ds.field("orderSpeed", &self.orderSpeed());
        ds.field("orderLimit", &self.orderLimit());
        ds.field("orderRarity", &self.orderRarity());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_TradingRoomBeanOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_TradingRoomBean<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_TradingRoomBean<'a> {
    type Inner = clz_Torappu_BuildingData_TradingRoomBean<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_TradingRoomBean<'a> {
    pub const VT_BASICSPEEDBUFF: flatbuffers::VOffsetT = 4;
    pub const VT_PHASES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_TradingRoomBean { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_TradingRoomBeanArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_TradingRoomBean<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_TradingRoomBeanBuilder::new(_fbb);
        if let Some(x) = args.phases {
            builder.add_phases(x);
        }
        builder.add_basicSpeedBuff(args.basicSpeedBuff);
        builder.finish()
    }

    #[inline]
    pub fn basicSpeedBuff(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_BuildingData_TradingRoomBean::VT_BASICSPEEDBUFF,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn phases(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_TradingPhase<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_TradingPhase>,
                >,
            >>(clz_Torappu_BuildingData_TradingRoomBean::VT_PHASES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_TradingRoomBean<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("basicSpeedBuff", Self::VT_BASICSPEEDBUFF, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_TradingPhase>,
                >,
            >>("phases", Self::VT_PHASES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_TradingRoomBeanArgs<'a> {
    pub basicSpeedBuff: f32,
    pub phases: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_TradingPhase<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_TradingRoomBeanArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_TradingRoomBeanArgs {
            basicSpeedBuff: 0.0,
            phases: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_TradingRoomBeanBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_TradingRoomBeanBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_basicSpeedBuff(&mut self, basicSpeedBuff: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_BuildingData_TradingRoomBean::VT_BASICSPEEDBUFF,
            basicSpeedBuff,
            0.0,
        );
    }
    #[inline]
    pub fn add_phases(
        &mut self,
        phases: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_TradingPhase<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_TradingRoomBean::VT_PHASES,
            phases,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_TradingRoomBeanBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_TradingRoomBeanBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_TradingRoomBean<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_TradingRoomBean<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_TradingRoomBean");
        ds.field("basicSpeedBuff", &self.basicSpeedBuff());
        ds.field("phases", &self.phases());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_WorkshopPhaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_WorkshopPhase<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_WorkshopPhase<'a> {
    type Inner = clz_Torappu_BuildingData_WorkshopPhase<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_WorkshopPhase<'a> {
    pub const VT_MANPOWERFACTOR: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_WorkshopPhase { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_WorkshopPhaseArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_WorkshopPhase<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_WorkshopPhaseBuilder::new(_fbb);
        builder.add_manpowerFactor(args.manpowerFactor);
        builder.finish()
    }

    #[inline]
    pub fn manpowerFactor(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_BuildingData_WorkshopPhase::VT_MANPOWERFACTOR,
                    Some(0.0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_WorkshopPhase<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("manpowerFactor", Self::VT_MANPOWERFACTOR, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_WorkshopPhaseArgs {
    pub manpowerFactor: f32,
}
impl<'a> Default for clz_Torappu_BuildingData_WorkshopPhaseArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_WorkshopPhaseArgs {
            manpowerFactor: 0.0,
        }
    }
}

pub struct clz_Torappu_BuildingData_WorkshopPhaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_WorkshopPhaseBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_manpowerFactor(&mut self, manpowerFactor: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_BuildingData_WorkshopPhase::VT_MANPOWERFACTOR,
            manpowerFactor,
            0.0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_WorkshopPhaseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_WorkshopPhaseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_WorkshopPhase<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_WorkshopPhase<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_WorkshopPhase");
        ds.field("manpowerFactor", &self.manpowerFactor());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_<'a>
{
    type Inner = clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_<'a> {
    pub const VT_PHASES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_ { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_Args<
            'args,
        >,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_<'bldr>,
    > {
        let mut builder =
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_Builder::new(
                _fbb,
            );
        if let Some(x) = args.phases {
            builder.add_phases(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn phases(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopPhase<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopPhase>,
                >,
            >>(
                clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_::VT_PHASES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopPhase>,
                >,
            >>("phases", Self::VT_PHASES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_Args<'a> {
    pub phases: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopPhase<'a>>,
            >,
        >,
    >,
}
impl<'a> Default
    for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_Args<'a>
{
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_Args { phases: None }
    }
}

pub struct clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_Builder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_Builder<'a, 'b, A>
{
    #[inline]
    pub fn add_phases(
        &mut self,
        phases: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopPhase<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_::VT_PHASES,
            phases,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_Builder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_",
        );
        ds.field("phases", &self.phases());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_TrainingPhaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_TrainingPhase<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_TrainingPhase<'a> {
    type Inner = clz_Torappu_BuildingData_TrainingPhase<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_TrainingPhase<'a> {
    pub const VT_SPECSKILLLVLLIMIT: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_TrainingPhase { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_TrainingPhaseArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_TrainingPhase<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_TrainingPhaseBuilder::new(_fbb);
        builder.add_specSkillLvlLimit(args.specSkillLvlLimit);
        builder.finish()
    }

    #[inline]
    pub fn specSkillLvlLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_TrainingPhase::VT_SPECSKILLLVLLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_TrainingPhase<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("specSkillLvlLimit", Self::VT_SPECSKILLLVLLIMIT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_TrainingPhaseArgs {
    pub specSkillLvlLimit: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_TrainingPhaseArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_TrainingPhaseArgs {
            specSkillLvlLimit: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_TrainingPhaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_TrainingPhaseBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_specSkillLvlLimit(&mut self, specSkillLvlLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_TrainingPhase::VT_SPECSKILLLVLLIMIT,
            specSkillLvlLimit,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_TrainingPhaseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_TrainingPhaseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_TrainingPhase<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_TrainingPhase<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_TrainingPhase");
        ds.field("specSkillLvlLimit", &self.specSkillLvlLimit());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_TrainingBeanOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_TrainingBean<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_TrainingBean<'a> {
    type Inner = clz_Torappu_BuildingData_TrainingBean<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_TrainingBean<'a> {
    pub const VT_BASICSPEEDBUFF: flatbuffers::VOffsetT = 4;
    pub const VT_PHASES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_TrainingBean { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_TrainingBeanArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_TrainingBean<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_TrainingBeanBuilder::new(_fbb);
        if let Some(x) = args.phases {
            builder.add_phases(x);
        }
        builder.add_basicSpeedBuff(args.basicSpeedBuff);
        builder.finish()
    }

    #[inline]
    pub fn basicSpeedBuff(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_BuildingData_TrainingBean::VT_BASICSPEEDBUFF,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn phases(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_TrainingPhase<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_TrainingPhase>,
                >,
            >>(clz_Torappu_BuildingData_TrainingBean::VT_PHASES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_TrainingBean<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("basicSpeedBuff", Self::VT_BASICSPEEDBUFF, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_TrainingPhase>,
                >,
            >>("phases", Self::VT_PHASES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_TrainingBeanArgs<'a> {
    pub basicSpeedBuff: f32,
    pub phases: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_TrainingPhase<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_TrainingBeanArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_TrainingBeanArgs {
            basicSpeedBuff: 0.0,
            phases: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_TrainingBeanBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_TrainingBeanBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_basicSpeedBuff(&mut self, basicSpeedBuff: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_BuildingData_TrainingBean::VT_BASICSPEEDBUFF,
            basicSpeedBuff,
            0.0,
        );
    }
    #[inline]
    pub fn add_phases(
        &mut self,
        phases: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_TrainingPhase<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_TrainingBean::VT_PHASES,
            phases,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_TrainingBeanBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_TrainingBeanBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_TrainingBean<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_TrainingBean<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_TrainingBean");
        ds.field("basicSpeedBuff", &self.basicSpeedBuff());
        ds.field("phases", &self.phases());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_PowerPhaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_PowerPhase<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_PowerPhase<'a> {
    type Inner = clz_Torappu_BuildingData_PowerPhase<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_PowerPhase<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_PowerPhase { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        _args: &'args clz_Torappu_BuildingData_PowerPhaseArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_PowerPhase<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_PowerPhaseBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_PowerPhase<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_PowerPhaseArgs {}
impl<'a> Default for clz_Torappu_BuildingData_PowerPhaseArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_PowerPhaseArgs {}
    }
}

pub struct clz_Torappu_BuildingData_PowerPhaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_PowerPhaseBuilder<'a, 'b, A>
{
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_PowerPhaseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_PowerPhaseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_PowerPhase<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_PowerPhase<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_PowerPhase");
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_PowerRoomBeanOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_PowerRoomBean<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_PowerRoomBean<'a> {
    type Inner = clz_Torappu_BuildingData_PowerRoomBean<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_PowerRoomBean<'a> {
    pub const VT_BASICSPEEDBUFF: flatbuffers::VOffsetT = 4;
    pub const VT_PHASES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_PowerRoomBean { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_PowerRoomBeanArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_PowerRoomBean<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_PowerRoomBeanBuilder::new(_fbb);
        if let Some(x) = args.phases {
            builder.add_phases(x);
        }
        builder.add_basicSpeedBuff(args.basicSpeedBuff);
        builder.finish()
    }

    #[inline]
    pub fn basicSpeedBuff(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_BuildingData_PowerRoomBean::VT_BASICSPEEDBUFF,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn phases(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_PowerPhase<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_PowerPhase>,
                >,
            >>(clz_Torappu_BuildingData_PowerRoomBean::VT_PHASES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_PowerRoomBean<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("basicSpeedBuff", Self::VT_BASICSPEEDBUFF, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_PowerPhase>,
                >,
            >>("phases", Self::VT_PHASES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_PowerRoomBeanArgs<'a> {
    pub basicSpeedBuff: f32,
    pub phases: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_PowerPhase<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_PowerRoomBeanArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_PowerRoomBeanArgs {
            basicSpeedBuff: 0.0,
            phases: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_PowerRoomBeanBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_PowerRoomBeanBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_basicSpeedBuff(&mut self, basicSpeedBuff: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_BuildingData_PowerRoomBean::VT_BASICSPEEDBUFF,
            basicSpeedBuff,
            0.0,
        );
    }
    #[inline]
    pub fn add_phases(
        &mut self,
        phases: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_PowerPhase<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_PowerRoomBean::VT_PHASES,
            phases,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_PowerRoomBeanBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_PowerRoomBeanBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_PowerRoomBean<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_PowerRoomBean<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_PowerRoomBean");
        ds.field("basicSpeedBuff", &self.basicSpeedBuff());
        ds.field("phases", &self.phases());
        ds.finish()
    }
}
pub enum clz_Torappu_CharacterData_UnlockConditionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_CharacterData_UnlockCondition<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_CharacterData_UnlockCondition<'a> {
    type Inner = clz_Torappu_CharacterData_UnlockCondition<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_CharacterData_UnlockCondition<'a> {
    pub const VT_PHASE: flatbuffers::VOffsetT = 4;
    pub const VT_LEVEL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_CharacterData_UnlockCondition { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_CharacterData_UnlockConditionArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'bldr>> {
        let mut builder = clz_Torappu_CharacterData_UnlockConditionBuilder::new(_fbb);
        builder.add_level(args.level);
        builder.add_phase(args.phase);
        builder.finish()
    }

    #[inline]
    pub fn phase(&self) -> enum__Torappu_EvolvePhase {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_EvolvePhase>(
                    clz_Torappu_CharacterData_UnlockCondition::VT_PHASE,
                    Some(enum__Torappu_EvolvePhase::PHASE_0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn level(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_CharacterData_UnlockCondition::VT_LEVEL, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_CharacterData_UnlockCondition<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_EvolvePhase>("phase", Self::VT_PHASE, false)?
            .visit_field::<i32>("level", Self::VT_LEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_CharacterData_UnlockConditionArgs {
    pub phase: enum__Torappu_EvolvePhase,
    pub level: i32,
}
impl<'a> Default for clz_Torappu_CharacterData_UnlockConditionArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_CharacterData_UnlockConditionArgs {
            phase: enum__Torappu_EvolvePhase::PHASE_0,
            level: 0,
        }
    }
}

pub struct clz_Torappu_CharacterData_UnlockConditionBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_CharacterData_UnlockConditionBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_phase(&mut self, phase: enum__Torappu_EvolvePhase) {
        self.fbb_.push_slot::<enum__Torappu_EvolvePhase>(
            clz_Torappu_CharacterData_UnlockCondition::VT_PHASE,
            phase,
            enum__Torappu_EvolvePhase::PHASE_0,
        );
    }
    #[inline]
    pub fn add_level(&mut self, level: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_CharacterData_UnlockCondition::VT_LEVEL,
            level,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_CharacterData_UnlockConditionBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_CharacterData_UnlockConditionBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_CharacterData_UnlockCondition<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_CharacterData_UnlockCondition");
        ds.field("phase", &self.phase());
        ds.field("level", &self.level());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem<'a> {
    type Inner = clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem<'a> {
    pub const VT_BUFFID: flatbuffers::VOffsetT = 4;
    pub const VT_COND: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItemBuilder::new(_fbb);
        if let Some(x) = args.cond {
            builder.add_cond(x);
        }
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem::VT_BUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn cond(&self) -> Option<clz_Torappu_CharacterData_UnlockCondition<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                    clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem::VT_COND,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                "cond",
                Self::VT_COND,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItemArgs<'a> {
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cond: Option<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'a>>>,
}
impl<'a> Default for clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItemArgs {
            buffId: None,
            cond: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItemBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn add_cond(
        &mut self,
        cond: flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_CharacterData_UnlockCondition>>(
                clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem::VT_COND,
                cond,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem");
        ds.field("buffId", &self.buffId());
        ds.field("cond", &self.cond());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_BuildingBuffCharSlotOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_BuildingBuffCharSlot<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_BuildingBuffCharSlot<'a> {
    type Inner = clz_Torappu_BuildingData_BuildingBuffCharSlot<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_BuildingBuffCharSlot<'a> {
    pub const VT_BUFFDATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_BuildingBuffCharSlot { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_BuildingBuffCharSlotArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingBuffCharSlot<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_BuildingBuffCharSlotBuilder::new(_fbb);
        if let Some(x) = args.buffData {
            builder.add_buffData(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn buffData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem,
                    >,
                >,
            >>(
                clz_Torappu_BuildingData_BuildingBuffCharSlot::VT_BUFFDATA,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_BuildingBuffCharSlot<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem,
                    >,
                >,
            >>("buffData", Self::VT_BUFFDATA, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_BuildingBuffCharSlotArgs<'a> {
    pub buffData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_BuildingBuffCharSlotArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_BuildingBuffCharSlotArgs { buffData: None }
    }
}

pub struct clz_Torappu_BuildingData_BuildingBuffCharSlotBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_BuildingBuffCharSlotBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_buffData(
        &mut self,
        buffData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_BuildingData_BuildingBuffCharSlot_SlotItem<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingBuffCharSlot::VT_BUFFDATA,
            buffData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_BuildingBuffCharSlotBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_BuildingBuffCharSlotBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingBuffCharSlot<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_BuildingBuffCharSlot<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_BuildingBuffCharSlot");
        ds.field("buffData", &self.buffData());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_BuildingCharacterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_BuildingCharacter<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_BuildingCharacter<'a> {
    type Inner = clz_Torappu_BuildingData_BuildingCharacter<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_BuildingCharacter<'a> {
    pub const VT_CHARID: flatbuffers::VOffsetT = 4;
    pub const VT_MAXMANPOWER: flatbuffers::VOffsetT = 6;
    pub const VT_BUFFCHAR: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_BuildingCharacter { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_BuildingCharacterArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingCharacter<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_BuildingCharacterBuilder::new(_fbb);
        builder.add_maxManpower(args.maxManpower);
        if let Some(x) = args.buffChar {
            builder.add_buffChar(x);
        }
        if let Some(x) = args.charId {
            builder.add_charId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn charId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_BuildingCharacter::VT_CHARID,
                None,
            )
        }
    }
    #[inline]
    pub fn maxManpower(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_BuildingData_BuildingCharacter::VT_MAXMANPOWER,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buffChar(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_BuildingBuffCharSlot<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_BuildingBuffCharSlot>,
                >,
            >>(
                clz_Torappu_BuildingData_BuildingCharacter::VT_BUFFCHAR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_BuildingCharacter<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("charId", Self::VT_CHARID, false)?
            .visit_field::<i64>("maxManpower", Self::VT_MAXMANPOWER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_BuildingBuffCharSlot>,
                >,
            >>("buffChar", Self::VT_BUFFCHAR, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_BuildingCharacterArgs<'a> {
    pub charId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub maxManpower: i64,
    pub buffChar: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_BuildingBuffCharSlot<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_BuildingCharacterArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_BuildingCharacterArgs {
            charId: None,
            maxManpower: 0,
            buffChar: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_BuildingCharacterBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_BuildingCharacterBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_charId(&mut self, charId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingCharacter::VT_CHARID,
            charId,
        );
    }
    #[inline]
    pub fn add_maxManpower(&mut self, maxManpower: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_BuildingData_BuildingCharacter::VT_MAXMANPOWER,
            maxManpower,
            0,
        );
    }
    #[inline]
    pub fn add_buffChar(
        &mut self,
        buffChar: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_BuildingBuffCharSlot<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingCharacter::VT_BUFFCHAR,
            buffChar,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_BuildingCharacterBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_BuildingCharacterBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingCharacter<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_BuildingCharacter<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_BuildingCharacter");
        ds.field("charId", &self.charId());
        ds.field("maxManpower", &self.maxManpower());
        ds.field("buffChar", &self.buffChar());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_BuildingCharacterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_BuildingCharacter<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_BuildingData_BuildingCharacter<'a> {
    type Inner = dict__string__clz_Torappu_BuildingData_BuildingCharacter<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_BuildingCharacter<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_BuildingCharacter { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_BuildingCharacterArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_BuildingCharacter<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_BuildingData_BuildingCharacterBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_BuildingCharacter::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_BuildingCharacter,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_BuildingCharacter<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_BuildingCharacter>>(
                    dict__string__clz_Torappu_BuildingData_BuildingCharacter::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_BuildingCharacter<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_BuildingCharacter>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_BuildingCharacterArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingCharacter<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_BuildingCharacterArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_BuildingCharacterArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_BuildingCharacterBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_BuildingCharacterBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_BuildingCharacter::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingCharacter<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingCharacter>>(
                dict__string__clz_Torappu_BuildingData_BuildingCharacter::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_BuildingCharacterBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_BuildingCharacterBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_BuildingCharacter<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_BuildingCharacter::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_BuildingCharacter<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_BuildingCharacter");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_BuildingBuffOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_BuildingBuff<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_BuildingBuff<'a> {
    type Inner = clz_Torappu_BuildingData_BuildingBuff<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_BuildingBuff<'a> {
    pub const VT_BUFFID: flatbuffers::VOffsetT = 4;
    pub const VT_BUFFNAME: flatbuffers::VOffsetT = 6;
    pub const VT_BUFFICON: flatbuffers::VOffsetT = 8;
    pub const VT_SKILLICON: flatbuffers::VOffsetT = 10;
    pub const VT_SORTID: flatbuffers::VOffsetT = 12;
    pub const VT_BUFFCOLOR: flatbuffers::VOffsetT = 14;
    pub const VT_TEXTCOLOR: flatbuffers::VOffsetT = 16;
    pub const VT_BUFFCATEGORY: flatbuffers::VOffsetT = 18;
    pub const VT_ROOMTYPE: flatbuffers::VOffsetT = 20;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 22;
    pub const VT_EFFICIENCY: flatbuffers::VOffsetT = 24;
    pub const VT_TARGETGROUPSORTID: flatbuffers::VOffsetT = 26;
    pub const VT_TARGETS: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_BuildingBuff { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_BuildingBuffArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingBuff<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_BuildingBuffBuilder::new(_fbb);
        if let Some(x) = args.targets {
            builder.add_targets(x);
        }
        builder.add_targetGroupSortId(args.targetGroupSortId);
        builder.add_efficiency(args.efficiency);
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        builder.add_roomType(args.roomType);
        builder.add_buffCategory(args.buffCategory);
        if let Some(x) = args.textColor {
            builder.add_textColor(x);
        }
        if let Some(x) = args.buffColor {
            builder.add_buffColor(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.skillIcon {
            builder.add_skillIcon(x);
        }
        if let Some(x) = args.buffIcon {
            builder.add_buffIcon(x);
        }
        if let Some(x) = args.buffName {
            builder.add_buffName(x);
        }
        if let Some(x) = args.buffId {
            builder.add_buffId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn buffId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_BuildingBuff::VT_BUFFID,
                None,
            )
        }
    }
    #[inline]
    pub fn buffName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_BuildingBuff::VT_BUFFNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn buffIcon(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_BuildingBuff::VT_BUFFICON,
                None,
            )
        }
    }
    #[inline]
    pub fn skillIcon(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_BuildingBuff::VT_SKILLICON,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData_BuildingBuff::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn buffColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_BuildingBuff::VT_BUFFCOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn textColor(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_BuildingBuff::VT_TEXTCOLOR,
                None,
            )
        }
    }
    #[inline]
    pub fn buffCategory(&self) -> enum__Torappu_BuildingData_BuffCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_BuffCategory>(
                    clz_Torappu_BuildingData_BuildingBuff::VT_BUFFCATEGORY,
                    Some(enum__Torappu_BuildingData_BuffCategory::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn roomType(&self) -> enum__Torappu_BuildingData_RoomType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_RoomType>(
                    clz_Torappu_BuildingData_BuildingBuff::VT_ROOMTYPE,
                    Some(enum__Torappu_BuildingData_RoomType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_BuildingBuff::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn efficiency(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_BuildingBuff::VT_EFFICIENCY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn targetGroupSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_BuildingBuff::VT_TARGETGROUPSORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn targets(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_BuildingData_BuildingBuff::VT_TARGETS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_BuildingBuff<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("buffId", Self::VT_BUFFID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffName",
                Self::VT_BUFFNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffIcon",
                Self::VT_BUFFICON,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "skillIcon",
                Self::VT_SKILLICON,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffColor",
                Self::VT_BUFFCOLOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "textColor",
                Self::VT_TEXTCOLOR,
                false,
            )?
            .visit_field::<enum__Torappu_BuildingData_BuffCategory>(
                "buffCategory",
                Self::VT_BUFFCATEGORY,
                false,
            )?
            .visit_field::<enum__Torappu_BuildingData_RoomType>(
                "roomType",
                Self::VT_ROOMTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<i32>("efficiency", Self::VT_EFFICIENCY, false)?
            .visit_field::<i32>("targetGroupSortId", Self::VT_TARGETGROUPSORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("targets", Self::VT_TARGETS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_BuildingBuffArgs<'a> {
    pub buffId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffIcon: Option<flatbuffers::WIPOffset<&'a str>>,
    pub skillIcon: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub buffColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub textColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffCategory: enum__Torappu_BuildingData_BuffCategory,
    pub roomType: enum__Torappu_BuildingData_RoomType,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub efficiency: i32,
    pub targetGroupSortId: i32,
    pub targets: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_BuildingBuffArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_BuildingBuffArgs {
            buffId: None,
            buffName: None,
            buffIcon: None,
            skillIcon: None,
            sortId: 0,
            buffColor: None,
            textColor: None,
            buffCategory: enum__Torappu_BuildingData_BuffCategory::NONE,
            roomType: enum__Torappu_BuildingData_RoomType::NONE,
            description: None,
            efficiency: 0,
            targetGroupSortId: 0,
            targets: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_BuildingBuffBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_BuildingBuffBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_buffId(&mut self, buffId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingBuff::VT_BUFFID,
            buffId,
        );
    }
    #[inline]
    pub fn add_buffName(&mut self, buffName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingBuff::VT_BUFFNAME,
            buffName,
        );
    }
    #[inline]
    pub fn add_buffIcon(&mut self, buffIcon: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingBuff::VT_BUFFICON,
            buffIcon,
        );
    }
    #[inline]
    pub fn add_skillIcon(&mut self, skillIcon: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingBuff::VT_SKILLICON,
            skillIcon,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_BuildingData_BuildingBuff::VT_SORTID, sortId, 0);
    }
    #[inline]
    pub fn add_buffColor(&mut self, buffColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingBuff::VT_BUFFCOLOR,
            buffColor,
        );
    }
    #[inline]
    pub fn add_textColor(&mut self, textColor: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingBuff::VT_TEXTCOLOR,
            textColor,
        );
    }
    #[inline]
    pub fn add_buffCategory(&mut self, buffCategory: enum__Torappu_BuildingData_BuffCategory) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_BuffCategory>(
                clz_Torappu_BuildingData_BuildingBuff::VT_BUFFCATEGORY,
                buffCategory,
                enum__Torappu_BuildingData_BuffCategory::NONE,
            );
    }
    #[inline]
    pub fn add_roomType(&mut self, roomType: enum__Torappu_BuildingData_RoomType) {
        self.fbb_.push_slot::<enum__Torappu_BuildingData_RoomType>(
            clz_Torappu_BuildingData_BuildingBuff::VT_ROOMTYPE,
            roomType,
            enum__Torappu_BuildingData_RoomType::NONE,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingBuff::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_efficiency(&mut self, efficiency: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_BuildingBuff::VT_EFFICIENCY,
            efficiency,
            0,
        );
    }
    #[inline]
    pub fn add_targetGroupSortId(&mut self, targetGroupSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_BuildingBuff::VT_TARGETGROUPSORTID,
            targetGroupSortId,
            0,
        );
    }
    #[inline]
    pub fn add_targets(
        &mut self,
        targets: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingBuff::VT_TARGETS,
            targets,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_BuildingBuffBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_BuildingBuffBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingBuff<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_BuildingBuff<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_BuildingBuff");
        ds.field("buffId", &self.buffId());
        ds.field("buffName", &self.buffName());
        ds.field("buffIcon", &self.buffIcon());
        ds.field("skillIcon", &self.skillIcon());
        ds.field("sortId", &self.sortId());
        ds.field("buffColor", &self.buffColor());
        ds.field("textColor", &self.textColor());
        ds.field("buffCategory", &self.buffCategory());
        ds.field("roomType", &self.roomType());
        ds.field("description", &self.description());
        ds.field("efficiency", &self.efficiency());
        ds.field("targetGroupSortId", &self.targetGroupSortId());
        ds.field("targets", &self.targets());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_BuildingBuffOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_BuildingBuff<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_BuildingData_BuildingBuff<'a> {
    type Inner = dict__string__clz_Torappu_BuildingData_BuildingBuff<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_BuildingBuff<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_BuildingBuff { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_BuildingBuffArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_BuildingBuff<'bldr>> {
        let mut builder = dict__string__clz_Torappu_BuildingData_BuildingBuffBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_BuildingBuff::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_BuildingBuff,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_BuildingBuff<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_BuildingBuff>>(
                    dict__string__clz_Torappu_BuildingData_BuildingBuff::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_BuildingBuff<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_BuildingBuff>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_BuildingBuffArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingBuff<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_BuildingBuffArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_BuildingBuffArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_BuildingBuffBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_BuildingBuffBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_BuildingBuff::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingBuff<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingBuff>>(
                dict__string__clz_Torappu_BuildingData_BuildingBuff::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_BuildingBuffBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_BuildingBuffBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_BuildingBuff<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_BuildingBuff::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_BuildingBuff<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_BuildingBuff");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum dict__string__list_stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__list_string<'a> {
    type Inner = dict__string__list_string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__list_string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__list_string<'bldr>> {
        let mut builder = dict__string__list_stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__list_string::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__list_string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(dict__string__list_string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__list_string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for dict__string__list_stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__list_stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__list_stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__list_string::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_string::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__list_string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, dict__string__list_string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__list_string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_WorkshopExtraWeightItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_WorkshopExtraWeightItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_WorkshopExtraWeightItem<'a> {
    type Inner = clz_Torappu_BuildingData_WorkshopExtraWeightItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_WorkshopExtraWeightItem<'a> {
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMID: flatbuffers::VOffsetT = 6;
    pub const VT_ITEMCOUNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_WorkshopExtraWeightItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_WorkshopExtraWeightItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_WorkshopExtraWeightItem<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_WorkshopExtraWeightItemBuilder::new(_fbb);
        builder.add_itemCount(args.itemCount);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.add_weight(args.weight);
        builder.finish()
    }

    #[inline]
    pub fn weight(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_WorkshopExtraWeightItem::VT_WEIGHT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_WorkshopExtraWeightItem::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_WorkshopExtraWeightItem::VT_ITEMCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_WorkshopExtraWeightItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("weight", Self::VT_WEIGHT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("itemCount", Self::VT_ITEMCOUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_WorkshopExtraWeightItemArgs<'a> {
    pub weight: i32,
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemCount: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_WorkshopExtraWeightItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_WorkshopExtraWeightItemArgs {
            weight: 0,
            itemId: None,
            itemCount: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_WorkshopExtraWeightItemBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_WorkshopExtraWeightItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_weight(&mut self, weight: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_WorkshopExtraWeightItem::VT_WEIGHT,
            weight,
            0,
        );
    }
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_WorkshopExtraWeightItem::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_itemCount(&mut self, itemCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_WorkshopExtraWeightItem::VT_ITEMCOUNT,
            itemCount,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_WorkshopExtraWeightItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_WorkshopExtraWeightItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_WorkshopExtraWeightItem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_WorkshopExtraWeightItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_WorkshopExtraWeightItem");
        ds.field("weight", &self.weight());
        ds.field("itemId", &self.itemId());
        ds.field("itemCount", &self.itemCount());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_CustomData_FurnitureDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_CustomData_FurnitureData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_CustomData_FurnitureData<'a> {
    type Inner = clz_Torappu_BuildingData_CustomData_FurnitureData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_CustomData_FurnitureData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_ICONID: flatbuffers::VOffsetT = 10;
    pub const VT_INTERACTTYPE: flatbuffers::VOffsetT = 12;
    pub const VT_MUSICID: flatbuffers::VOffsetT = 14;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 16;
    pub const VT_SUBTYPE: flatbuffers::VOffsetT = 18;
    pub const VT_LOCATION: flatbuffers::VOffsetT = 20;
    pub const VT_CATEGORY: flatbuffers::VOffsetT = 22;
    pub const VT_VALIDONROTATE: flatbuffers::VOffsetT = 24;
    pub const VT_ENABLEROTATE: flatbuffers::VOffsetT = 26;
    pub const VT_RARITY: flatbuffers::VOffsetT = 28;
    pub const VT_THEMEID: flatbuffers::VOffsetT = 30;
    pub const VT_GROUPID: flatbuffers::VOffsetT = 32;
    pub const VT_WIDTH: flatbuffers::VOffsetT = 34;
    pub const VT_DEPTH: flatbuffers::VOffsetT = 36;
    pub const VT_HEIGHT: flatbuffers::VOffsetT = 38;
    pub const VT_COMFORT: flatbuffers::VOffsetT = 40;
    pub const VT_USAGE: flatbuffers::VOffsetT = 42;
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 44;
    pub const VT_OBTAINAPPROACH: flatbuffers::VOffsetT = 46;
    pub const VT_PROCESSEDPRODUCTID: flatbuffers::VOffsetT = 48;
    pub const VT_PROCESSEDPRODUCTCOUNT: flatbuffers::VOffsetT = 50;
    pub const VT_PROCESSEDBYPRODUCTPERCENTAGE: flatbuffers::VOffsetT = 52;
    pub const VT_PROCESSEDBYPRODUCTGROUP: flatbuffers::VOffsetT = 54;
    pub const VT_CANBEDESTROY: flatbuffers::VOffsetT = 56;
    pub const VT_ISONLY: flatbuffers::VOffsetT = 58;
    pub const VT_ENABLEROOMTYPE: flatbuffers::VOffsetT = 60;
    pub const VT_QUANTITY: flatbuffers::VOffsetT = 62;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_CustomData_FurnitureData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_CustomData_FurnitureDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_FurnitureData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_CustomData_FurnitureDataBuilder::new(_fbb);
        builder.add_quantity(args.quantity);
        builder.add_enableRoomType(args.enableRoomType);
        builder.add_isOnly(args.isOnly);
        if let Some(x) = args.processedByProductGroup {
            builder.add_processedByProductGroup(x);
        }
        builder.add_processedByProductPercentage(args.processedByProductPercentage);
        builder.add_processedProductCount(args.processedProductCount);
        if let Some(x) = args.processedProductId {
            builder.add_processedProductId(x);
        }
        if let Some(x) = args.obtainApproach {
            builder.add_obtainApproach(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        if let Some(x) = args.usage {
            builder.add_usage(x);
        }
        builder.add_comfort(args.comfort);
        builder.add_height(args.height);
        builder.add_depth(args.depth);
        builder.add_width(args.width);
        if let Some(x) = args.groupId {
            builder.add_groupId(x);
        }
        if let Some(x) = args.themeId {
            builder.add_themeId(x);
        }
        builder.add_rarity(args.rarity);
        builder.add_category(args.category);
        builder.add_location(args.location);
        builder.add_subType(args.subType);
        builder.add_type_(args.type_);
        if let Some(x) = args.musicId {
            builder.add_musicId(x);
        }
        builder.add_interactType(args.interactType);
        if let Some(x) = args.iconId {
            builder.add_iconId(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_canBeDestroy(args.canBeDestroy);
        builder.add_enableRotate(args.enableRotate);
        builder.add_validOnRotate(args.validOnRotate);
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn iconId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_ICONID,
                None,
            )
        }
    }
    #[inline]
    pub fn interactType(&self) -> enum__Torappu_BuildingData_FurnitureInteract {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_FurnitureInteract>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_INTERACTTYPE,
                    Some(enum__Torappu_BuildingData_FurnitureInteract::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn musicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_MUSICID,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_BuildingData_FurnitureType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_FurnitureType>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_TYPE_,
                    Some(enum__Torappu_BuildingData_FurnitureType::FLOOR),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn subType(&self) -> enum__Torappu_BuildingData_FurnitureSubType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_FurnitureSubType>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_SUBTYPE,
                    Some(enum__Torappu_BuildingData_FurnitureSubType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn location(&self) -> enum__Torappu_BuildingData_FurnitureLocation {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_FurnitureLocation>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_LOCATION,
                    Some(enum__Torappu_BuildingData_FurnitureLocation::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn category(&self) -> enum__Torappu_BuildingData_FurnitureCategory {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_FurnitureCategory>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_CATEGORY,
                    Some(enum__Torappu_BuildingData_FurnitureCategory::FURNITURE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn validOnRotate(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_VALIDONROTATE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn enableRotate(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_ENABLEROTATE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rarity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_RARITY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn themeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_THEMEID,
                None,
            )
        }
    }
    #[inline]
    pub fn groupId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_GROUPID,
                None,
            )
        }
    }
    #[inline]
    pub fn width(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_WIDTH,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn depth(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_DEPTH,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn height(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_HEIGHT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn comfort(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_COMFORT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn usage(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_USAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_DESCRIPTION,
                None,
            )
        }
    }
    #[inline]
    pub fn obtainApproach(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_OBTAINAPPROACH,
                None,
            )
        }
    }
    #[inline]
    pub fn processedProductId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_PROCESSEDPRODUCTID,
                None,
            )
        }
    }
    #[inline]
    pub fn processedProductCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_PROCESSEDPRODUCTCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn processedByProductPercentage(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<i32>(clz_Torappu_BuildingData_CustomData_FurnitureData::VT_PROCESSEDBYPRODUCTPERCENTAGE, Some(0)).unwrap()
        }
    }
    #[inline]
    pub fn processedByProductGroup(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopExtraWeightItem<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopExtraWeightItem>,
                >,
            >>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_PROCESSEDBYPRODUCTGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn canBeDestroy(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_CANBEDESTROY,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isOnly(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_ISONLY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn enableRoomType(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_ENABLEROOMTYPE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn quantity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_FurnitureData::VT_QUANTITY,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_CustomData_FurnitureData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("iconId", Self::VT_ICONID, false)?
            .visit_field::<enum__Torappu_BuildingData_FurnitureInteract>(
                "interactType",
                Self::VT_INTERACTTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("musicId", Self::VT_MUSICID, false)?
            .visit_field::<enum__Torappu_BuildingData_FurnitureType>(
                "type_",
                Self::VT_TYPE_,
                false,
            )?
            .visit_field::<enum__Torappu_BuildingData_FurnitureSubType>(
                "subType",
                Self::VT_SUBTYPE,
                false,
            )?
            .visit_field::<enum__Torappu_BuildingData_FurnitureLocation>(
                "location",
                Self::VT_LOCATION,
                false,
            )?
            .visit_field::<enum__Torappu_BuildingData_FurnitureCategory>(
                "category",
                Self::VT_CATEGORY,
                false,
            )?
            .visit_field::<bool>("validOnRotate", Self::VT_VALIDONROTATE, false)?
            .visit_field::<bool>("enableRotate", Self::VT_ENABLEROTATE, false)?
            .visit_field::<i32>("rarity", Self::VT_RARITY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("themeId", Self::VT_THEMEID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupId", Self::VT_GROUPID, false)?
            .visit_field::<i32>("width", Self::VT_WIDTH, false)?
            .visit_field::<i32>("depth", Self::VT_DEPTH, false)?
            .visit_field::<i32>("height", Self::VT_HEIGHT, false)?
            .visit_field::<i32>("comfort", Self::VT_COMFORT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("usage", Self::VT_USAGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obtainApproach",
                Self::VT_OBTAINAPPROACH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "processedProductId",
                Self::VT_PROCESSEDPRODUCTID,
                false,
            )?
            .visit_field::<i32>(
                "processedProductCount",
                Self::VT_PROCESSEDPRODUCTCOUNT,
                false,
            )?
            .visit_field::<i32>(
                "processedByProductPercentage",
                Self::VT_PROCESSEDBYPRODUCTPERCENTAGE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopExtraWeightItem>,
                >,
            >>(
                "processedByProductGroup",
                Self::VT_PROCESSEDBYPRODUCTGROUP,
                false,
            )?
            .visit_field::<bool>("canBeDestroy", Self::VT_CANBEDESTROY, false)?
            .visit_field::<i32>("isOnly", Self::VT_ISONLY, false)?
            .visit_field::<i32>("enableRoomType", Self::VT_ENABLEROOMTYPE, false)?
            .visit_field::<i32>("quantity", Self::VT_QUANTITY, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_CustomData_FurnitureDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iconId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub interactType: enum__Torappu_BuildingData_FurnitureInteract,
    pub musicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_BuildingData_FurnitureType,
    pub subType: enum__Torappu_BuildingData_FurnitureSubType,
    pub location: enum__Torappu_BuildingData_FurnitureLocation,
    pub category: enum__Torappu_BuildingData_FurnitureCategory,
    pub validOnRotate: bool,
    pub enableRotate: bool,
    pub rarity: i32,
    pub themeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub groupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub width: i32,
    pub depth: i32,
    pub height: i32,
    pub comfort: i32,
    pub usage: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obtainApproach: Option<flatbuffers::WIPOffset<&'a str>>,
    pub processedProductId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub processedProductCount: i32,
    pub processedByProductPercentage: i32,
    pub processedByProductGroup: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopExtraWeightItem<'a>>,
            >,
        >,
    >,
    pub canBeDestroy: bool,
    pub isOnly: i32,
    pub enableRoomType: i32,
    pub quantity: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_CustomData_FurnitureDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_CustomData_FurnitureDataArgs {
            id: None,
            sortId: 0,
            name: None,
            iconId: None,
            interactType: enum__Torappu_BuildingData_FurnitureInteract::NONE,
            musicId: None,
            type_: enum__Torappu_BuildingData_FurnitureType::FLOOR,
            subType: enum__Torappu_BuildingData_FurnitureSubType::NONE,
            location: enum__Torappu_BuildingData_FurnitureLocation::NONE,
            category: enum__Torappu_BuildingData_FurnitureCategory::FURNITURE,
            validOnRotate: false,
            enableRotate: false,
            rarity: 0,
            themeId: None,
            groupId: None,
            width: 0,
            depth: 0,
            height: 0,
            comfort: 0,
            usage: None,
            description: None,
            obtainApproach: None,
            processedProductId: None,
            processedProductCount: 0,
            processedByProductPercentage: 0,
            processedByProductGroup: None,
            canBeDestroy: false,
            isOnly: 0,
            enableRoomType: 0,
            quantity: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_CustomData_FurnitureDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_CustomData_FurnitureDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_iconId(&mut self, iconId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_ICONID,
            iconId,
        );
    }
    #[inline]
    pub fn add_interactType(&mut self, interactType: enum__Torappu_BuildingData_FurnitureInteract) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_FurnitureInteract>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_INTERACTTYPE,
                interactType,
                enum__Torappu_BuildingData_FurnitureInteract::NONE,
            );
    }
    #[inline]
    pub fn add_musicId(&mut self, musicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_MUSICID,
            musicId,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_BuildingData_FurnitureType) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_FurnitureType>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_TYPE_,
                type_,
                enum__Torappu_BuildingData_FurnitureType::FLOOR,
            );
    }
    #[inline]
    pub fn add_subType(&mut self, subType: enum__Torappu_BuildingData_FurnitureSubType) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_FurnitureSubType>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_SUBTYPE,
                subType,
                enum__Torappu_BuildingData_FurnitureSubType::NONE,
            );
    }
    #[inline]
    pub fn add_location(&mut self, location: enum__Torappu_BuildingData_FurnitureLocation) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_FurnitureLocation>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_LOCATION,
                location,
                enum__Torappu_BuildingData_FurnitureLocation::NONE,
            );
    }
    #[inline]
    pub fn add_category(&mut self, category: enum__Torappu_BuildingData_FurnitureCategory) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_FurnitureCategory>(
                clz_Torappu_BuildingData_CustomData_FurnitureData::VT_CATEGORY,
                category,
                enum__Torappu_BuildingData_FurnitureCategory::FURNITURE,
            );
    }
    #[inline]
    pub fn add_validOnRotate(&mut self, validOnRotate: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_VALIDONROTATE,
            validOnRotate,
            false,
        );
    }
    #[inline]
    pub fn add_enableRotate(&mut self, enableRotate: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_ENABLEROTATE,
            enableRotate,
            false,
        );
    }
    #[inline]
    pub fn add_rarity(&mut self, rarity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_RARITY,
            rarity,
            0,
        );
    }
    #[inline]
    pub fn add_themeId(&mut self, themeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_THEMEID,
            themeId,
        );
    }
    #[inline]
    pub fn add_groupId(&mut self, groupId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_GROUPID,
            groupId,
        );
    }
    #[inline]
    pub fn add_width(&mut self, width: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_WIDTH,
            width,
            0,
        );
    }
    #[inline]
    pub fn add_depth(&mut self, depth: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_DEPTH,
            depth,
            0,
        );
    }
    #[inline]
    pub fn add_height(&mut self, height: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_HEIGHT,
            height,
            0,
        );
    }
    #[inline]
    pub fn add_comfort(&mut self, comfort: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_COMFORT,
            comfort,
            0,
        );
    }
    #[inline]
    pub fn add_usage(&mut self, usage: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_USAGE,
            usage,
        );
    }
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_DESCRIPTION,
            description,
        );
    }
    #[inline]
    pub fn add_obtainApproach(&mut self, obtainApproach: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_OBTAINAPPROACH,
            obtainApproach,
        );
    }
    #[inline]
    pub fn add_processedProductId(&mut self, processedProductId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_PROCESSEDPRODUCTID,
            processedProductId,
        );
    }
    #[inline]
    pub fn add_processedProductCount(&mut self, processedProductCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_PROCESSEDPRODUCTCOUNT,
            processedProductCount,
            0,
        );
    }
    #[inline]
    pub fn add_processedByProductPercentage(&mut self, processedByProductPercentage: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_PROCESSEDBYPRODUCTPERCENTAGE,
            processedByProductPercentage,
            0,
        );
    }
    #[inline]
    pub fn add_processedByProductGroup(
        &mut self,
        processedByProductGroup: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopExtraWeightItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_PROCESSEDBYPRODUCTGROUP,
            processedByProductGroup,
        );
    }
    #[inline]
    pub fn add_canBeDestroy(&mut self, canBeDestroy: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_CANBEDESTROY,
            canBeDestroy,
            false,
        );
    }
    #[inline]
    pub fn add_isOnly(&mut self, isOnly: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_ISONLY,
            isOnly,
            0,
        );
    }
    #[inline]
    pub fn add_enableRoomType(&mut self, enableRoomType: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_ENABLEROOMTYPE,
            enableRoomType,
            0,
        );
    }
    #[inline]
    pub fn add_quantity(&mut self, quantity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_FurnitureData::VT_QUANTITY,
            quantity,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_CustomData_FurnitureDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_CustomData_FurnitureDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_FurnitureData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_CustomData_FurnitureData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_CustomData_FurnitureData");
        ds.field("id", &self.id());
        ds.field("sortId", &self.sortId());
        ds.field("name", &self.name());
        ds.field("iconId", &self.iconId());
        ds.field("interactType", &self.interactType());
        ds.field("musicId", &self.musicId());
        ds.field("type_", &self.type_());
        ds.field("subType", &self.subType());
        ds.field("location", &self.location());
        ds.field("category", &self.category());
        ds.field("validOnRotate", &self.validOnRotate());
        ds.field("enableRotate", &self.enableRotate());
        ds.field("rarity", &self.rarity());
        ds.field("themeId", &self.themeId());
        ds.field("groupId", &self.groupId());
        ds.field("width", &self.width());
        ds.field("depth", &self.depth());
        ds.field("height", &self.height());
        ds.field("comfort", &self.comfort());
        ds.field("usage", &self.usage());
        ds.field("description", &self.description());
        ds.field("obtainApproach", &self.obtainApproach());
        ds.field("processedProductId", &self.processedProductId());
        ds.field("processedProductCount", &self.processedProductCount());
        ds.field(
            "processedByProductPercentage",
            &self.processedByProductPercentage(),
        );
        ds.field("processedByProductGroup", &self.processedByProductGroup());
        ds.field("canBeDestroy", &self.canBeDestroy());
        ds.field("isOnly", &self.isOnly());
        ds.field("enableRoomType", &self.enableRoomType());
        ds.field("quantity", &self.quantity());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_CustomData_FurnitureDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData<'a>
{
    type Inner = dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_CustomData_FurnitureDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_BuildingData_CustomData_FurnitureDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_CustomData_FurnitureData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_FurnitureData>>(dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_FurnitureData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_CustomData_FurnitureDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_FurnitureData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_CustomData_FurnitureDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_CustomData_FurnitureDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_CustomData_FurnitureDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_CustomData_FurnitureDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_FurnitureData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_FurnitureData>>(dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_CustomData_FurnitureDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_CustomData_FurnitureDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem<'a> {
    type Inner = clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem<'a> {
    pub const VT_FURNITUREID: flatbuffers::VOffsetT = 4;
    pub const VT_POS0: flatbuffers::VOffsetT = 6;
    pub const VT_POS1: flatbuffers::VOffsetT = 8;
    pub const VT_DIR: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem<'bldr>>
    {
        let mut builder = clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItemBuilder::new(_fbb);
        builder.add_dir(args.dir);
        builder.add_pos1(args.pos1);
        builder.add_pos0(args.pos0);
        if let Some(x) = args.furnitureId {
            builder.add_furnitureId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn furnitureId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem::VT_FURNITUREID,
                None,
            )
        }
    }
    #[inline]
    pub fn pos0(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem::VT_POS0,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn pos1(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem::VT_POS1,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn dir(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem::VT_DIR,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "furnitureId",
                Self::VT_FURNITUREID,
                false,
            )?
            .visit_field::<i32>("pos0", Self::VT_POS0, false)?
            .visit_field::<i32>("pos1", Self::VT_POS1, false)?
            .visit_field::<i32>("dir", Self::VT_DIR, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItemArgs<'a> {
    pub furnitureId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pos0: i32,
    pub pos1: i32,
    pub dir: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItemArgs {
            furnitureId: None,
            pos0: 0,
            pos1: 0,
            dir: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItemBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_furnitureId(&mut self, furnitureId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem::VT_FURNITUREID,
            furnitureId,
        );
    }
    #[inline]
    pub fn add_pos0(&mut self, pos0: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem::VT_POS0,
            pos0,
            0,
        );
    }
    #[inline]
    pub fn add_pos1(&mut self, pos1: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem::VT_POS1,
            pos1,
            0,
        );
    }
    #[inline]
    pub fn add_dir(&mut self, dir: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem::VT_DIR,
            dir,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem");
        ds.field("furnitureId", &self.furnitureId());
        ds.field("pos0", &self.pos0());
        ds.field("pos1", &self.pos1());
        ds.field("dir", &self.dir());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_CustomData_ThemeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_CustomData_ThemeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_CustomData_ThemeData<'a> {
    type Inner = clz_Torappu_BuildingData_CustomData_ThemeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_CustomData_ThemeData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_ENABLEROOMTYPE: flatbuffers::VOffsetT = 6;
    pub const VT_SORTID: flatbuffers::VOffsetT = 8;
    pub const VT_NAME: flatbuffers::VOffsetT = 10;
    pub const VT_THEMETYPE: flatbuffers::VOffsetT = 12;
    pub const VT_DESC: flatbuffers::VOffsetT = 14;
    pub const VT_QUICKSETUP: flatbuffers::VOffsetT = 16;
    pub const VT_GROUPS: flatbuffers::VOffsetT = 18;
    pub const VT_FURNITURES: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_CustomData_ThemeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_CustomData_ThemeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_ThemeData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_CustomData_ThemeDataBuilder::new(_fbb);
        if let Some(x) = args.furnitures {
            builder.add_furnitures(x);
        }
        if let Some(x) = args.groups {
            builder.add_groups(x);
        }
        if let Some(x) = args.quickSetup {
            builder.add_quickSetup(x);
        }
        if let Some(x) = args.desc {
            builder.add_desc(x);
        }
        if let Some(x) = args.themeType {
            builder.add_themeType(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_sortId(args.sortId);
        builder.add_enableRoomType(args.enableRoomType);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_ThemeData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn enableRoomType(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_ThemeData::VT_ENABLEROOMTYPE,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_ThemeData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_ThemeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn themeType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_ThemeData::VT_THEMETYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn desc(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_ThemeData::VT_DESC,
                None,
            )
        }
    }
    #[inline]
    pub fn quickSetup(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem,
                    >,
                >,
            >>(
                clz_Torappu_BuildingData_CustomData_ThemeData::VT_QUICKSETUP,
                None,
            )
        }
    }
    #[inline]
    pub fn groups(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_BuildingData_CustomData_ThemeData::VT_GROUPS,
                None,
            )
        }
    }
    #[inline]
    pub fn furnitures(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_BuildingData_CustomData_ThemeData::VT_FURNITURES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_CustomData_ThemeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("enableRoomType", Self::VT_ENABLEROOMTYPE, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "themeType",
                Self::VT_THEMETYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("desc", Self::VT_DESC, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem,
                    >,
                >,
            >>("quickSetup", Self::VT_QUICKSETUP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("groups", Self::VT_GROUPS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("furnitures", Self::VT_FURNITURES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_CustomData_ThemeDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enableRoomType: i32,
    pub sortId: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub themeType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub desc: Option<flatbuffers::WIPOffset<&'a str>>,
    pub quickSetup: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem<'a>,
                >,
            >,
        >,
    >,
    pub groups: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub furnitures: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_CustomData_ThemeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_CustomData_ThemeDataArgs {
            id: None,
            enableRoomType: 0,
            sortId: 0,
            name: None,
            themeType: None,
            desc: None,
            quickSetup: None,
            groups: None,
            furnitures: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_CustomData_ThemeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_CustomData_ThemeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_ThemeData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_enableRoomType(&mut self, enableRoomType: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_ThemeData::VT_ENABLEROOMTYPE,
            enableRoomType,
            0,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_ThemeData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_ThemeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_themeType(&mut self, themeType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_ThemeData::VT_THEMETYPE,
            themeType,
        );
    }
    #[inline]
    pub fn add_desc(&mut self, desc: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_ThemeData::VT_DESC,
            desc,
        );
    }
    #[inline]
    pub fn add_quickSetup(
        &mut self,
        quickSetup: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_BuildingData_CustomData_ThemeQuickSetupItem<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_ThemeData::VT_QUICKSETUP,
            quickSetup,
        );
    }
    #[inline]
    pub fn add_groups(
        &mut self,
        groups: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_ThemeData::VT_GROUPS,
            groups,
        );
    }
    #[inline]
    pub fn add_furnitures(
        &mut self,
        furnitures: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_ThemeData::VT_FURNITURES,
            furnitures,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_CustomData_ThemeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_CustomData_ThemeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_ThemeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_CustomData_ThemeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_CustomData_ThemeData");
        ds.field("id", &self.id());
        ds.field("enableRoomType", &self.enableRoomType());
        ds.field("sortId", &self.sortId());
        ds.field("name", &self.name());
        ds.field("themeType", &self.themeType());
        ds.field("desc", &self.desc());
        ds.field("quickSetup", &self.quickSetup());
        ds.field("groups", &self.groups());
        ds.field("furnitures", &self.furnitures());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_CustomData_ThemeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_CustomData_ThemeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_BuildingData_CustomData_ThemeData<'a>
{
    type Inner = dict__string__clz_Torappu_BuildingData_CustomData_ThemeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_CustomData_ThemeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_CustomData_ThemeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_CustomData_ThemeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_CustomData_ThemeData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_BuildingData_CustomData_ThemeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_CustomData_ThemeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_CustomData_ThemeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_CustomData_ThemeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_ThemeData>>(
                    dict__string__clz_Torappu_BuildingData_CustomData_ThemeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_CustomData_ThemeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_ThemeData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_CustomData_ThemeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_ThemeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_CustomData_ThemeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_CustomData_ThemeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_CustomData_ThemeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_CustomData_ThemeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_CustomData_ThemeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_ThemeData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_ThemeData>>(dict__string__clz_Torappu_BuildingData_CustomData_ThemeData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_CustomData_ThemeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_CustomData_ThemeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_CustomData_ThemeData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_CustomData_ThemeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_CustomData_ThemeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_CustomData_ThemeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_CustomData_GroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_CustomData_GroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_CustomData_GroupData<'a> {
    type Inner = clz_Torappu_BuildingData_CustomData_GroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_CustomData_GroupData<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_THEMEID: flatbuffers::VOffsetT = 10;
    pub const VT_COMFORT: flatbuffers::VOffsetT = 12;
    pub const VT_COUNT: flatbuffers::VOffsetT = 14;
    pub const VT_FURNITURE: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_CustomData_GroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_CustomData_GroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_GroupData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_CustomData_GroupDataBuilder::new(_fbb);
        if let Some(x) = args.furniture {
            builder.add_furniture(x);
        }
        builder.add_count(args.count);
        builder.add_comfort(args.comfort);
        if let Some(x) = args.themeId {
            builder.add_themeId(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_sortId(args.sortId);
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_GroupData::VT_ID,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_GroupData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_GroupData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn themeId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_GroupData::VT_THEMEID,
                None,
            )
        }
    }
    #[inline]
    pub fn comfort(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_GroupData::VT_COMFORT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_GroupData::VT_COUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn furniture(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_BuildingData_CustomData_GroupData::VT_FURNITURE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_CustomData_GroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("themeId", Self::VT_THEMEID, false)?
            .visit_field::<i32>("comfort", Self::VT_COMFORT, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("furniture", Self::VT_FURNITURE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_CustomData_GroupDataArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sortId: i32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub themeId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub comfort: i32,
    pub count: i32,
    pub furniture: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_CustomData_GroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_CustomData_GroupDataArgs {
            id: None,
            sortId: 0,
            name: None,
            themeId: None,
            comfort: 0,
            count: 0,
            furniture: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_CustomData_GroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_CustomData_GroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_GroupData::VT_ID,
            id,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_GroupData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_GroupData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_themeId(&mut self, themeId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_GroupData::VT_THEMEID,
            themeId,
        );
    }
    #[inline]
    pub fn add_comfort(&mut self, comfort: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_GroupData::VT_COMFORT,
            comfort,
            0,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_GroupData::VT_COUNT,
            count,
            0,
        );
    }
    #[inline]
    pub fn add_furniture(
        &mut self,
        furniture: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_GroupData::VT_FURNITURE,
            furniture,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_CustomData_GroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_CustomData_GroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_GroupData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_CustomData_GroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_CustomData_GroupData");
        ds.field("id", &self.id());
        ds.field("sortId", &self.sortId());
        ds.field("name", &self.name());
        ds.field("themeId", &self.themeId());
        ds.field("comfort", &self.comfort());
        ds.field("count", &self.count());
        ds.field("furniture", &self.furniture());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_CustomData_GroupDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_CustomData_GroupData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_BuildingData_CustomData_GroupData<'a>
{
    type Inner = dict__string__clz_Torappu_BuildingData_CustomData_GroupData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_CustomData_GroupData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_CustomData_GroupData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_CustomData_GroupDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_CustomData_GroupData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_BuildingData_CustomData_GroupDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_CustomData_GroupData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_CustomData_GroupData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_CustomData_GroupData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_GroupData>>(
                    dict__string__clz_Torappu_BuildingData_CustomData_GroupData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_CustomData_GroupData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_GroupData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_CustomData_GroupDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_GroupData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_CustomData_GroupDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_CustomData_GroupDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_CustomData_GroupDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_CustomData_GroupDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_CustomData_GroupData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_GroupData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_GroupData>>(dict__string__clz_Torappu_BuildingData_CustomData_GroupData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_CustomData_GroupDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_CustomData_GroupDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_CustomData_GroupData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_CustomData_GroupData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_CustomData_GroupData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_CustomData_GroupData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_CustomData_FurnitureTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'a> {
    type Inner = clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_ENABLEROOMTYPE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_CustomData_FurnitureTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_CustomData_FurnitureTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_CustomData_FurnitureTypeDataBuilder::new(_fbb);
        builder.add_enableRoomType(args.enableRoomType);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> enum__Torappu_BuildingData_FurnitureType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_FurnitureType>(
                    clz_Torappu_BuildingData_CustomData_FurnitureTypeData::VT_TYPE_,
                    Some(enum__Torappu_BuildingData_FurnitureType::FLOOR),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_FurnitureTypeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn enableRoomType(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_FurnitureTypeData::VT_ENABLEROOMTYPE,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_BuildingData_FurnitureType>(
                "type_",
                Self::VT_TYPE_,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<i32>("enableRoomType", Self::VT_ENABLEROOMTYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_CustomData_FurnitureTypeDataArgs<'a> {
    pub type_: enum__Torappu_BuildingData_FurnitureType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub enableRoomType: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_CustomData_FurnitureTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_CustomData_FurnitureTypeDataArgs {
            type_: enum__Torappu_BuildingData_FurnitureType::FLOOR,
            name: None,
            enableRoomType: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_CustomData_FurnitureTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_CustomData_FurnitureTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_BuildingData_FurnitureType) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_FurnitureType>(
                clz_Torappu_BuildingData_CustomData_FurnitureTypeData::VT_TYPE_,
                type_,
                enum__Torappu_BuildingData_FurnitureType::FLOOR,
            );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_FurnitureTypeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_enableRoomType(&mut self, enableRoomType: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_FurnitureTypeData::VT_ENABLEROOMTYPE,
            enableRoomType,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_CustomData_FurnitureTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_CustomData_FurnitureTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_CustomData_FurnitureTypeData");
        ds.field("type_", &self.type_());
        ds.field("name", &self.name());
        ds.field("enableRoomType", &self.enableRoomType());
        ds.finish()
    }
}
pub enum dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeDataOffset
{}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData<
    'a,
> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'a> {
  type Inner = dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeDataArgs<'args>
  ) -> flatbuffers::WIPOffset<dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'bldr>> {
    let mut builder = dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeDataBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.add_key(args.key);
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> enum__Torappu_BuildingData_FurnitureType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<enum__Torappu_BuildingData_FurnitureType>(dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData::VT_KEY, Some(enum__Torappu_BuildingData_FurnitureType::FLOOR)).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: enum__Torappu_BuildingData_FurnitureType) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(&val)
  }
  #[inline]
  pub fn value(&self) -> Option<clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_FurnitureTypeData>>(dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<enum__Torappu_BuildingData_FurnitureType>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_FurnitureTypeData>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeDataArgs<
    'a,
> {
    pub key: enum__Torappu_BuildingData_FurnitureType,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'a>>>,
}
impl<'a> Default for dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeDataArgs {
      key: enum__Torappu_BuildingData_FurnitureType::FLOOR,
      value: None,
    }
  }
}

pub struct dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: enum__Torappu_BuildingData_FurnitureType) {
    self.fbb_.push_slot::<enum__Torappu_BuildingData_FurnitureType>(dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData::VT_KEY, key, enum__Torappu_BuildingData_FurnitureType::FLOOR);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_FurnitureTypeData>>(dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'a> {
    type Inner = clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'a> {
    pub const VT_SUBTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
    pub const VT_SORTID: flatbuffers::VOffsetT = 10;
    pub const VT_COUNTLIMIT: flatbuffers::VOffsetT = 12;
    pub const VT_ENABLEROOMTYPE: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'bldr>>
    {
        let mut builder =
            clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataBuilder::new(_fbb);
        builder.add_enableRoomType(args.enableRoomType);
        builder.add_countLimit(args.countLimit);
        builder.add_sortId(args.sortId);
        builder.add_type_(args.type_);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_subType(args.subType);
        builder.finish()
    }

    #[inline]
    pub fn subType(&self) -> enum__Torappu_BuildingData_FurnitureSubType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_FurnitureSubType>(
                    clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_SUBTYPE,
                    Some(enum__Torappu_BuildingData_FurnitureSubType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> enum__Torappu_BuildingData_FurnitureType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_FurnitureType>(
                    clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_TYPE_,
                    Some(enum__Torappu_BuildingData_FurnitureType::FLOOR),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn countLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_COUNTLIMIT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn enableRoomType(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_ENABLEROOMTYPE,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_BuildingData_FurnitureSubType>(
                "subType",
                Self::VT_SUBTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<enum__Torappu_BuildingData_FurnitureType>(
                "type_",
                Self::VT_TYPE_,
                false,
            )?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<i32>("countLimit", Self::VT_COUNTLIMIT, false)?
            .visit_field::<i32>("enableRoomType", Self::VT_ENABLEROOMTYPE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataArgs<'a> {
    pub subType: enum__Torappu_BuildingData_FurnitureSubType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: enum__Torappu_BuildingData_FurnitureType,
    pub sortId: i32,
    pub countLimit: i32,
    pub enableRoomType: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataArgs {
            subType: enum__Torappu_BuildingData_FurnitureSubType::NONE,
            name: None,
            type_: enum__Torappu_BuildingData_FurnitureType::FLOOR,
            sortId: 0,
            countLimit: 0,
            enableRoomType: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_subType(&mut self, subType: enum__Torappu_BuildingData_FurnitureSubType) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_FurnitureSubType>(
                clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_SUBTYPE,
                subType,
                enum__Torappu_BuildingData_FurnitureSubType::NONE,
            );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_type_(&mut self, type_: enum__Torappu_BuildingData_FurnitureType) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_FurnitureType>(
                clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_TYPE_,
                type_,
                enum__Torappu_BuildingData_FurnitureType::FLOOR,
            );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_countLimit(&mut self, countLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_COUNTLIMIT,
            countLimit,
            0,
        );
    }
    #[inline]
    pub fn add_enableRoomType(&mut self, enableRoomType: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_ENABLEROOMTYPE,
            enableRoomType,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData");
        ds.field("subType", &self.subType());
        ds.field("name", &self.name());
        ds.field("type_", &self.type_());
        ds.field("sortId", &self.sortId());
        ds.field("countLimit", &self.countLimit());
        ds.field("enableRoomType", &self.enableRoomType());
        ds.finish()
    }
}
pub enum dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataOffset
{}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<
    'a,
> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'a> {
  type Inner = dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataArgs<'args>
  ) -> flatbuffers::WIPOffset<dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'bldr>> {
    let mut builder = dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.add_key(args.key);
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> enum__Torappu_BuildingData_FurnitureSubType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<enum__Torappu_BuildingData_FurnitureSubType>(dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_KEY, Some(enum__Torappu_BuildingData_FurnitureSubType::NONE)).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: enum__Torappu_BuildingData_FurnitureSubType) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(&val)
  }
  #[inline]
  pub fn value(&self) -> Option<clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData>>(dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<enum__Torappu_BuildingData_FurnitureSubType>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataArgs<
    'a,
> {
    pub key: enum__Torappu_BuildingData_FurnitureSubType,
    pub value: Option<
        flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'a>>,
    >,
}
impl<'a> Default for dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataArgs {
      key: enum__Torappu_BuildingData_FurnitureSubType::NONE,
      value: None,
    }
  }
}

pub struct dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: enum__Torappu_BuildingData_FurnitureSubType) {
    self.fbb_.push_slot::<enum__Torappu_BuildingData_FurnitureSubType>(dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_KEY, key, enum__Torappu_BuildingData_FurnitureSubType::NONE);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData>>(dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'a>
{
    type Inner = clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'a> {
    pub const VT_FURNITUREID: flatbuffers::VOffsetT = 4;
    pub const VT_XOFFSET: flatbuffers::VOffsetT = 6;
    pub const VT_YOFFSET: flatbuffers::VOffsetT = 8;
    pub const VT_DEFAULTPREFABID: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'bldr>,
    > {
        let mut builder =
            clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemBuilder::new(_fbb);
        if let Some(x) = args.defaultPrefabId {
            builder.add_defaultPrefabId(x);
        }
        builder.add_yOffset(args.yOffset);
        builder.add_xOffset(args.xOffset);
        if let Some(x) = args.furnitureId {
            builder.add_furnitureId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn furnitureId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem::VT_FURNITUREID,
                None,
            )
        }
    }
    #[inline]
    pub fn xOffset(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem::VT_XOFFSET,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn yOffset(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem::VT_YOFFSET,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn defaultPrefabId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem::VT_DEFAULTPREFABID, None)
        }
    }
}

impl flatbuffers::Verifiable
    for clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "furnitureId",
                Self::VT_FURNITUREID,
                false,
            )?
            .visit_field::<i32>("xOffset", Self::VT_XOFFSET, false)?
            .visit_field::<i32>("yOffset", Self::VT_YOFFSET, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "defaultPrefabId",
                Self::VT_DEFAULTPREFABID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemArgs<'a> {
    pub furnitureId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub xOffset: i32,
    pub yOffset: i32,
    pub defaultPrefabId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemArgs {
            furnitureId: None,
            xOffset: 0,
            yOffset: 0,
            defaultPrefabId: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_furnitureId(&mut self, furnitureId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem::VT_FURNITUREID,
            furnitureId,
        );
    }
    #[inline]
    pub fn add_xOffset(&mut self, xOffset: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem::VT_XOFFSET,
            xOffset,
            0,
        );
    }
    #[inline]
    pub fn add_yOffset(&mut self, yOffset: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem::VT_YOFFSET,
            yOffset,
            0,
        );
    }
    #[inline]
    pub fn add_defaultPrefabId(&mut self, defaultPrefabId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem::VT_DEFAULTPREFABID,
            defaultPrefabId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem");
        ds.field("furnitureId", &self.furnitureId());
        ds.field("xOffset", &self.xOffset());
        ds.field("yOffset", &self.yOffset());
        ds.field("defaultPrefabId", &self.defaultPrefabId());
        ds.finish()
    }
}
pub enum dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemOffset
{}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'a>
{
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'a>
{
    type Inner =
        dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'bldr>,
    > {
        let mut builder = dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem::VT_KEY, None).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem>>>>(dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem,
                    >,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemArgs<
    'a,
> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default
    for dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemBuilder<
        'a,
        'b,
        A,
    >
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem::VT_VALUE, value);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemBuilder<'a, 'b, A>{
        let start = _fbb.start_table();
        dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItemBuilder {
      fbb_: _fbb,
      start_: start,
    }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem::VT_KEY,"key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem",
        );
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_CustomData_InteractItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_CustomData_InteractItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_CustomData_InteractItem<'a> {
    type Inner = clz_Torappu_BuildingData_CustomData_InteractItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_CustomData_InteractItem<'a> {
    pub const VT_SKINID: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_CustomData_InteractItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_CustomData_InteractItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_InteractItem<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_CustomData_InteractItemBuilder::new(_fbb);
        if let Some(x) = args.skinId {
            builder.add_skinId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn skinId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_InteractItem::VT_SKINID,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_CustomData_InteractItem<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("skinId", Self::VT_SKINID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_CustomData_InteractItemArgs<'a> {
    pub skinId: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_BuildingData_CustomData_InteractItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_CustomData_InteractItemArgs { skinId: None }
    }
}

pub struct clz_Torappu_BuildingData_CustomData_InteractItemBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_CustomData_InteractItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_skinId(&mut self, skinId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_InteractItem::VT_SKINID,
            skinId,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_CustomData_InteractItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_CustomData_InteractItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_InteractItem<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_CustomData_InteractItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_CustomData_InteractItem");
        ds.field("skinId", &self.skinId());
        ds.finish()
    }
}
pub enum dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem<'a>
{
    type Inner = dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItemArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem<'bldr>,
    > {
        let mut builder =
            dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItemBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_InteractItem<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_InteractItem>,
                >,
            >>(
                dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_InteractItem>,
                >,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItemArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_InteractItem<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItemArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItemBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItemBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_InteractItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItemBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItemBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateDataOffset
{}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData<'a>
{
    type Inner =
        clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_SEQUENCES: flatbuffers::VOffsetT = 6;
    pub const VT_STABLESEQUENCE: flatbuffers::VOffsetT = 8;
    pub const VT_STABLESEQUENCEORDER: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData<'bldr>,
    > {
        let mut builder = clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateDataBuilder::new(_fbb);
        builder.add_stableSequenceOrder(args.stableSequenceOrder);
        if let Some(x) = args.stableSequence {
            builder.add_stableSequence(x);
        }
        if let Some(x) = args.sequences {
            builder.add_sequences(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData::VT_NAME, None)
        }
    }
    #[inline]
    pub fn sequences(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData::VT_SEQUENCES, None)
        }
    }
    #[inline]
    pub fn stableSequence(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData::VT_STABLESEQUENCE, None)
        }
    }
    #[inline]
    pub fn stableSequenceOrder(&self) -> enum__Torappu_BuildingData_DiyUISortOrder {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<enum__Torappu_BuildingData_DiyUISortOrder>(clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData::VT_STABLESEQUENCEORDER, Some(enum__Torappu_BuildingData_DiyUISortOrder::DESC)).unwrap()
        }
    }
}

impl flatbuffers::Verifiable
    for clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("sequences", Self::VT_SEQUENCES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "stableSequence",
                Self::VT_STABLESEQUENCE,
                false,
            )?
            .visit_field::<enum__Torappu_BuildingData_DiyUISortOrder>(
                "stableSequenceOrder",
                Self::VT_STABLESEQUENCEORDER,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateDataArgs<
    'a,
> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sequences: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub stableSequence: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stableSequenceOrder: enum__Torappu_BuildingData_DiyUISortOrder,
}
impl<'a> Default
    for clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateDataArgs<'a>
{
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateDataArgs {
            name: None,
            sequences: None,
            stableSequence: None,
            stableSequenceOrder: enum__Torappu_BuildingData_DiyUISortOrder::DESC,
        }
    }
}

pub struct clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateDataBuilder<
        'a,
        'b,
        A,
    >
{
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData::VT_NAME, name);
    }
    #[inline]
    pub fn add_sequences(
        &mut self,
        sequences: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData::VT_SEQUENCES, sequences);
    }
    #[inline]
    pub fn add_stableSequence(&mut self, stableSequence: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData::VT_STABLESEQUENCE, stableSequence);
    }
    #[inline]
    pub fn add_stableSequenceOrder(
        &mut self,
        stableSequenceOrder: enum__Torappu_BuildingData_DiyUISortOrder,
    ) {
        self.fbb_.push_slot::<enum__Torappu_BuildingData_DiyUISortOrder>(clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData::VT_STABLESEQUENCEORDER, stableSequenceOrder, enum__Torappu_BuildingData_DiyUISortOrder::DESC);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateDataBuilder<'a, 'b, A>{
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData",
        );
        ds.field("name", &self.name());
        ds.field("sequences", &self.sequences());
        ds.field("stableSequence", &self.stableSequence());
        ds.field("stableSequenceOrder", &self.stableSequenceOrder());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a>
{
    type Inner = clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a> {
    pub const VT_DIYSORTTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_EXPANDSTATE: flatbuffers::VOffsetT = 6;
    pub const VT_DEFAULTTEMPLATEINDEX: flatbuffers::VOffsetT = 8;
    pub const VT_DEFAULTTEMPLATEORDER: flatbuffers::VOffsetT = 10;
    pub const VT_TEMPLATES: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'bldr>>
    {
        let mut builder =
            clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataBuilder::new(_fbb);
        if let Some(x) = args.templates {
            builder.add_templates(x);
        }
        builder.add_defaultTemplateOrder(args.defaultTemplateOrder);
        builder.add_defaultTemplateIndex(args.defaultTemplateIndex);
        if let Some(x) = args.expandState {
            builder.add_expandState(x);
        }
        builder.add_diySortType(args.diySortType);
        builder.finish()
    }

    #[inline]
    pub fn diySortType(&self) -> enum__Torappu_BuildingData_DiySortType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_DiySortType>(
                    clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_DIYSORTTYPE,
                    Some(enum__Torappu_BuildingData_DiySortType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn expandState(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_EXPANDSTATE,
                None,
            )
        }
    }
    #[inline]
    pub fn defaultTemplateIndex(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<i32>(clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_DEFAULTTEMPLATEINDEX, Some(0)).unwrap()
        }
    }
    #[inline]
    pub fn defaultTemplateOrder(&self) -> enum__Torappu_BuildingData_DiyUISortOrder {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<enum__Torappu_BuildingData_DiyUISortOrder>(clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_DEFAULTTEMPLATEORDER, Some(enum__Torappu_BuildingData_DiyUISortOrder::DESC)).unwrap()
        }
    }
    #[inline]
    pub fn templates(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData<
                    'a,
                >,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData>>>>(clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_TEMPLATES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<enum__Torappu_BuildingData_DiySortType>("diySortType", Self::VT_DIYSORTTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("expandState", Self::VT_EXPANDSTATE, false)?
     .visit_field::<i32>("defaultTemplateIndex", Self::VT_DEFAULTTEMPLATEINDEX, false)?
     .visit_field::<enum__Torappu_BuildingData_DiyUISortOrder>("defaultTemplateOrder", Self::VT_DEFAULTTEMPLATEORDER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData>>>>("templates", Self::VT_TEMPLATES, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataArgs<'a> {
    pub diySortType: enum__Torappu_BuildingData_DiySortType,
    pub expandState: Option<flatbuffers::WIPOffset<&'a str>>,
    pub defaultTemplateIndex: i32,
    pub defaultTemplateOrder: enum__Torappu_BuildingData_DiyUISortOrder,
    pub templates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData<'a>>>>>,
}
impl<'a> Default for clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataArgs {
            diySortType: enum__Torappu_BuildingData_DiySortType::NONE,
            expandState: None,
            defaultTemplateIndex: 0,
            defaultTemplateOrder: enum__Torappu_BuildingData_DiyUISortOrder::DESC,
            templates: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_diySortType(&mut self, diySortType: enum__Torappu_BuildingData_DiySortType) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_DiySortType>(
                clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_DIYSORTTYPE,
                diySortType,
                enum__Torappu_BuildingData_DiySortType::NONE,
            );
    }
    #[inline]
    pub fn add_expandState(&mut self, expandState: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_EXPANDSTATE,
            expandState,
        );
    }
    #[inline]
    pub fn add_defaultTemplateIndex(&mut self, defaultTemplateIndex: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_DEFAULTTEMPLATEINDEX,
            defaultTemplateIndex,
            0,
        );
    }
    #[inline]
    pub fn add_defaultTemplateOrder(
        &mut self,
        defaultTemplateOrder: enum__Torappu_BuildingData_DiyUISortOrder,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_DiyUISortOrder>(
            clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_DEFAULTTEMPLATEORDER,
            defaultTemplateOrder,
            enum__Torappu_BuildingData_DiyUISortOrder::DESC,
        );
    }
    #[inline]
    pub fn add_templates(
        &mut self,
        templates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData_DiyUISortTemplateData<'b >>>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_TEMPLATES,
            templates,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData");
        ds.field("diySortType", &self.diySortType());
        ds.field("expandState", &self.expandState());
        ds.field("defaultTemplateIndex", &self.defaultTemplateIndex());
        ds.field("defaultTemplateOrder", &self.defaultTemplateOrder());
        ds.field("templates", &self.templates());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a>
{
    type Inner = dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataBuilder::new(
                _fbb,
            );
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_KEY, None).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData>>(dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a>>,
    >,
}
impl<'a> Default
    for dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData,
        >>(
            dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataBuilder<'a, 'b, A>
    {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData",
        );
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataOffset
{}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<
    'a,
> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a> {
  type Inner = dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataArgs<'args>
  ) -> flatbuffers::WIPOffset<dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'bldr>> {
    let mut builder = dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.add_key(args.key);
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> enum__Torappu_BuildingData_DiySortType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<enum__Torappu_BuildingData_DiySortType>(dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_KEY, Some(enum__Torappu_BuildingData_DiySortType::NONE)).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: enum__Torappu_BuildingData_DiySortType) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(&val)
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData>>>>(dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<enum__Torappu_BuildingData_DiySortType>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData>>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataArgs<
    'a,
> {
    pub key: enum__Torappu_BuildingData_DiySortType,
    pub value: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataArgs {
      key: enum__Torappu_BuildingData_DiySortType::NONE,
      value: None,
    }
  }
}

pub struct dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: enum__Torappu_BuildingData_DiySortType) {
    self.fbb_.push_slot::<enum__Torappu_BuildingData_DiySortType>(dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_KEY, key, enum__Torappu_BuildingData_DiySortType::NONE);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum clz_Torappu_BuildingData_CustomDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_CustomData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_CustomData<'a> {
    type Inner = clz_Torappu_BuildingData_CustomData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_CustomData<'a> {
    pub const VT_FURNITURES: flatbuffers::VOffsetT = 4;
    pub const VT_THEMES: flatbuffers::VOffsetT = 6;
    pub const VT_GROUPS: flatbuffers::VOffsetT = 8;
    pub const VT_TYPES: flatbuffers::VOffsetT = 10;
    pub const VT_SUBTYPES: flatbuffers::VOffsetT = 12;
    pub const VT_DEFAULTFURNITURES: flatbuffers::VOffsetT = 14;
    pub const VT_INTERACTGROUPS: flatbuffers::VOffsetT = 16;
    pub const VT_DIYUISORTTEMPLATES: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_CustomData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_CustomDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_CustomDataBuilder::new(_fbb);
        if let Some(x) = args.diyUISortTemplates {
            builder.add_diyUISortTemplates(x);
        }
        if let Some(x) = args.interactGroups {
            builder.add_interactGroups(x);
        }
        if let Some(x) = args.defaultFurnitures {
            builder.add_defaultFurnitures(x);
        }
        if let Some(x) = args.subTypes {
            builder.add_subTypes(x);
        }
        if let Some(x) = args.types {
            builder.add_types(x);
        }
        if let Some(x) = args.groups {
            builder.add_groups(x);
        }
        if let Some(x) = args.themes {
            builder.add_themes(x);
        }
        if let Some(x) = args.furnitures {
            builder.add_furnitures(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn furnitures(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData,
                    >,
                >,
            >>(clz_Torappu_BuildingData_CustomData::VT_FURNITURES, None)
        }
    }
    #[inline]
    pub fn themes(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_BuildingData_CustomData_ThemeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_CustomData_ThemeData,
                    >,
                >,
            >>(clz_Torappu_BuildingData_CustomData::VT_THEMES, None)
        }
    }
    #[inline]
    pub fn groups(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_BuildingData_CustomData_GroupData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_CustomData_GroupData,
                    >,
                >,
            >>(clz_Torappu_BuildingData_CustomData::VT_GROUPS, None)
        }
    }
    #[inline]
    pub fn types(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'a>>>>{
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData>>>>(clz_Torappu_BuildingData_CustomData::VT_TYPES, None)
        }
    }
    #[inline]
    pub fn subTypes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'a>>>>{
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData>>>>(clz_Torappu_BuildingData_CustomData::VT_SUBTYPES, None)
        }
    }
    #[inline]
    pub fn defaultFurnitures(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'a>>>>{
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem>>>>(clz_Torappu_BuildingData_CustomData::VT_DEFAULTFURNITURES, None)
        }
    }
    #[inline]
    pub fn interactGroups(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem,
                    >,
                >,
            >>(clz_Torappu_BuildingData_CustomData::VT_INTERACTGROUPS, None)
        }
    }
    #[inline]
    pub fn diyUISortTemplates(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a>>>>{
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData>>>>(clz_Torappu_BuildingData_CustomData::VT_DIYUISORTTEMPLATES, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_CustomData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData>>>>("furnitures", Self::VT_FURNITURES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_CustomData_ThemeData>>>>("themes", Self::VT_THEMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_CustomData_GroupData>>>>("groups", Self::VT_GROUPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData>>>>("types", Self::VT_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData>>>>("subTypes", Self::VT_SUBTYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem>>>>("defaultFurnitures", Self::VT_DEFAULTFURNITURES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem>>>>("interactGroups", Self::VT_INTERACTGROUPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData>>>>("diyUISortTemplates", Self::VT_DIYUISORTTEMPLATES, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_CustomDataArgs<'a> {
    pub furnitures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData<'a>>>>>,
    pub themes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_CustomData_ThemeData<'a>>>>>,
    pub groups: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_CustomData_GroupData<'a>>>>>,
    pub types: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'a>>>>>,
    pub subTypes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'a>>>>>,
    pub defaultFurnitures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'a>>>>>,
    pub interactGroups: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem<'a>>>>>,
    pub diyUISortTemplates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'a>>>>>,
}
impl<'a> Default for clz_Torappu_BuildingData_CustomDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_CustomDataArgs {
            furnitures: None,
            themes: None,
            groups: None,
            types: None,
            subTypes: None,
            defaultFurnitures: None,
            interactGroups: None,
            diyUISortTemplates: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_CustomDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_CustomDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_furnitures(
        &mut self,
        furnitures: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_CustomData_FurnitureData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData::VT_FURNITURES,
            furnitures,
        );
    }
    #[inline]
    pub fn add_themes(
        &mut self,
        themes: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_CustomData_ThemeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData::VT_THEMES,
            themes,
        );
    }
    #[inline]
    pub fn add_groups(
        &mut self,
        groups: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_CustomData_GroupData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData::VT_GROUPS,
            groups,
        );
    }
    #[inline]
    pub fn add_types(
        &mut self,
        types: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<dict__enum__Torappu_BuildingData_FurnitureType__clz_Torappu_BuildingData_CustomData_FurnitureTypeData<'b >>>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData::VT_TYPES,
            types,
        );
    }
    #[inline]
    pub fn add_subTypes(
        &mut self,
        subTypes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<dict__enum__Torappu_BuildingData_FurnitureSubType__clz_Torappu_BuildingData_CustomData_FurnitureSubTypeData<'b >>>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData::VT_SUBTYPES,
            subTypes,
        );
    }
    #[inline]
    pub fn add_defaultFurnitures(
        &mut self,
        defaultFurnitures: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<dict__string__list_clz_Torappu_BuildingData_CustomData_DormitoryDefaultFurnitureItem<'b >>>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData::VT_DEFAULTFURNITURES,
            defaultFurnitures,
        );
    }
    #[inline]
    pub fn add_interactGroups(
        &mut self,
        interactGroups: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__list_clz_Torappu_BuildingData_CustomData_InteractItem<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData::VT_INTERACTGROUPS,
            interactGroups,
        );
    }
    #[inline]
    pub fn add_diyUISortTemplates(
        &mut self,
        diyUISortTemplates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<dict__enum__Torappu_BuildingData_DiySortType__list_dict__string__clz_Torappu_BuildingData_CustomData_DiyUISortTemplateListData<'b >>>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CustomData::VT_DIYUISORTTEMPLATES,
            diyUISortTemplates,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_CustomDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_CustomDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_CustomData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_CustomData");
        ds.field("furnitures", &self.furnitures());
        ds.field("themes", &self.themes());
        ds.field("groups", &self.groups());
        ds.field("types", &self.types());
        ds.field("subTypes", &self.subTypes());
        ds.field("defaultFurnitures", &self.defaultFurnitures());
        ds.field("interactGroups", &self.interactGroups());
        ds.field("diyUISortTemplates", &self.diyUISortTemplates());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_ManufactFormula_UnlockRoomOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_ManufactFormula_UnlockRoom<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_ManufactFormula_UnlockRoom<'a> {
    type Inner = clz_Torappu_BuildingData_ManufactFormula_UnlockRoom<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_ManufactFormula_UnlockRoom<'a> {
    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_ROOMLEVEL: flatbuffers::VOffsetT = 6;
    pub const VT_ROOMCOUNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_ManufactFormula_UnlockRoom { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_ManufactFormula_UnlockRoomArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactFormula_UnlockRoom<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_ManufactFormula_UnlockRoomBuilder::new(_fbb);
        builder.add_roomCount(args.roomCount);
        builder.add_roomLevel(args.roomLevel);
        builder.add_roomId(args.roomId);
        builder.finish()
    }

    #[inline]
    pub fn roomId(&self) -> enum__Torappu_BuildingData_RoomType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_RoomType>(
                    clz_Torappu_BuildingData_ManufactFormula_UnlockRoom::VT_ROOMID,
                    Some(enum__Torappu_BuildingData_RoomType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn roomLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_ManufactFormula_UnlockRoom::VT_ROOMLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn roomCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_ManufactFormula_UnlockRoom::VT_ROOMCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_ManufactFormula_UnlockRoom<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_BuildingData_RoomType>("roomId", Self::VT_ROOMID, false)?
            .visit_field::<i32>("roomLevel", Self::VT_ROOMLEVEL, false)?
            .visit_field::<i32>("roomCount", Self::VT_ROOMCOUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_ManufactFormula_UnlockRoomArgs {
    pub roomId: enum__Torappu_BuildingData_RoomType,
    pub roomLevel: i32,
    pub roomCount: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_ManufactFormula_UnlockRoomArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_ManufactFormula_UnlockRoomArgs {
            roomId: enum__Torappu_BuildingData_RoomType::NONE,
            roomLevel: 0,
            roomCount: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_ManufactFormula_UnlockRoomBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_ManufactFormula_UnlockRoomBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_roomId(&mut self, roomId: enum__Torappu_BuildingData_RoomType) {
        self.fbb_.push_slot::<enum__Torappu_BuildingData_RoomType>(
            clz_Torappu_BuildingData_ManufactFormula_UnlockRoom::VT_ROOMID,
            roomId,
            enum__Torappu_BuildingData_RoomType::NONE,
        );
    }
    #[inline]
    pub fn add_roomLevel(&mut self, roomLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_ManufactFormula_UnlockRoom::VT_ROOMLEVEL,
            roomLevel,
            0,
        );
    }
    #[inline]
    pub fn add_roomCount(&mut self, roomCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_ManufactFormula_UnlockRoom::VT_ROOMCOUNT,
            roomCount,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_ManufactFormula_UnlockRoomBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_ManufactFormula_UnlockRoomBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactFormula_UnlockRoom<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_ManufactFormula_UnlockRoom<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_ManufactFormula_UnlockRoom");
        ds.field("roomId", &self.roomId());
        ds.field("roomLevel", &self.roomLevel());
        ds.field("roomCount", &self.roomCount());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_ManufactFormula_UnlockStageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_ManufactFormula_UnlockStage<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_ManufactFormula_UnlockStage<'a> {
    type Inner = clz_Torappu_BuildingData_ManufactFormula_UnlockStage<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_ManufactFormula_UnlockStage<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_RANK: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_ManufactFormula_UnlockStage { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_ManufactFormula_UnlockStageArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactFormula_UnlockStage<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_ManufactFormula_UnlockStageBuilder::new(_fbb);
        builder.add_rank(args.rank);
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_ManufactFormula_UnlockStage::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn rank(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_ManufactFormula_UnlockStage::VT_RANK,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_ManufactFormula_UnlockStage<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<i32>("rank", Self::VT_RANK, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_ManufactFormula_UnlockStageArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rank: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_ManufactFormula_UnlockStageArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_ManufactFormula_UnlockStageArgs {
            stageId: None,
            rank: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_ManufactFormula_UnlockStageBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_ManufactFormula_UnlockStageBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_ManufactFormula_UnlockStage::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_rank(&mut self, rank: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_ManufactFormula_UnlockStage::VT_RANK,
            rank,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_ManufactFormula_UnlockStageBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_ManufactFormula_UnlockStageBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactFormula_UnlockStage<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_ManufactFormula_UnlockStage<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_ManufactFormula_UnlockStage");
        ds.field("stageId", &self.stageId());
        ds.field("rank", &self.rank());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_ManufactFormulaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_ManufactFormula<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_ManufactFormula<'a> {
    type Inner = clz_Torappu_BuildingData_ManufactFormula<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_ManufactFormula<'a> {
    pub const VT_FORMULAID: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMID: flatbuffers::VOffsetT = 6;
    pub const VT_COUNT: flatbuffers::VOffsetT = 8;
    pub const VT_WEIGHT: flatbuffers::VOffsetT = 10;
    pub const VT_COSTPOINT: flatbuffers::VOffsetT = 12;
    pub const VT_FORMULATYPE: flatbuffers::VOffsetT = 14;
    pub const VT_BUFFTYPE: flatbuffers::VOffsetT = 16;
    pub const VT_COSTS: flatbuffers::VOffsetT = 18;
    pub const VT_REQUIREROOMS: flatbuffers::VOffsetT = 20;
    pub const VT_REQUIRESTAGES: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_ManufactFormula { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_ManufactFormulaArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactFormula<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_ManufactFormulaBuilder::new(_fbb);
        builder.add_costPoint(args.costPoint);
        if let Some(x) = args.requireStages {
            builder.add_requireStages(x);
        }
        if let Some(x) = args.requireRooms {
            builder.add_requireRooms(x);
        }
        if let Some(x) = args.costs {
            builder.add_costs(x);
        }
        if let Some(x) = args.buffType {
            builder.add_buffType(x);
        }
        builder.add_formulaType(args.formulaType);
        builder.add_weight(args.weight);
        builder.add_count(args.count);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        if let Some(x) = args.formulaId {
            builder.add_formulaId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn formulaId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_ManufactFormula::VT_FORMULAID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_ManufactFormula::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData_ManufactFormula::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn weight(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData_ManufactFormula::VT_WEIGHT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn costPoint(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_BuildingData_ManufactFormula::VT_COSTPOINT,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn formulaType(&self) -> enum__Torappu_BuildingData_FormulaItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_FormulaItemType>(
                    clz_Torappu_BuildingData_ManufactFormula::VT_FORMULATYPE,
                    Some(enum__Torappu_BuildingData_FormulaItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buffType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_ManufactFormula::VT_BUFFTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn costs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_BuildingData_ManufactFormula::VT_COSTS, None)
        }
    }
    #[inline]
    pub fn requireRooms(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ManufactFormula_UnlockRoom<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_BuildingData_ManufactFormula_UnlockRoom,
                    >,
                >,
            >>(
                clz_Torappu_BuildingData_ManufactFormula::VT_REQUIREROOMS,
                None,
            )
        }
    }
    #[inline]
    pub fn requireStages(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ManufactFormula_UnlockStage<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_BuildingData_ManufactFormula_UnlockStage,
                    >,
                >,
            >>(
                clz_Torappu_BuildingData_ManufactFormula::VT_REQUIRESTAGES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_ManufactFormula<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "formulaId",
                Self::VT_FORMULAID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<i32>("weight", Self::VT_WEIGHT, false)?
            .visit_field::<i64>("costPoint", Self::VT_COSTPOINT, false)?
            .visit_field::<enum__Torappu_BuildingData_FormulaItemType>(
                "formulaType",
                Self::VT_FORMULATYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffType",
                Self::VT_BUFFTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("costs", Self::VT_COSTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_BuildingData_ManufactFormula_UnlockRoom,
                    >,
                >,
            >>("requireRooms", Self::VT_REQUIREROOMS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_BuildingData_ManufactFormula_UnlockStage,
                    >,
                >,
            >>("requireStages", Self::VT_REQUIRESTAGES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_ManufactFormulaArgs<'a> {
    pub formulaId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub weight: i32,
    pub costPoint: i64,
    pub formulaType: enum__Torappu_BuildingData_FormulaItemType,
    pub buffType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub costs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
    pub requireRooms: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_BuildingData_ManufactFormula_UnlockRoom<'a>,
                >,
            >,
        >,
    >,
    pub requireStages: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_BuildingData_ManufactFormula_UnlockStage<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_ManufactFormulaArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_ManufactFormulaArgs {
            formulaId: None,
            itemId: None,
            count: 0,
            weight: 0,
            costPoint: 0,
            formulaType: enum__Torappu_BuildingData_FormulaItemType::NONE,
            buffType: None,
            costs: None,
            requireRooms: None,
            requireStages: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_ManufactFormulaBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_ManufactFormulaBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_formulaId(&mut self, formulaId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_ManufactFormula::VT_FORMULAID,
            formulaId,
        );
    }
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_ManufactFormula::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_BuildingData_ManufactFormula::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_weight(&mut self, weight: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_ManufactFormula::VT_WEIGHT,
            weight,
            0,
        );
    }
    #[inline]
    pub fn add_costPoint(&mut self, costPoint: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_BuildingData_ManufactFormula::VT_COSTPOINT,
            costPoint,
            0,
        );
    }
    #[inline]
    pub fn add_formulaType(&mut self, formulaType: enum__Torappu_BuildingData_FormulaItemType) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_FormulaItemType>(
                clz_Torappu_BuildingData_ManufactFormula::VT_FORMULATYPE,
                formulaType,
                enum__Torappu_BuildingData_FormulaItemType::NONE,
            );
    }
    #[inline]
    pub fn add_buffType(&mut self, buffType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_ManufactFormula::VT_BUFFTYPE,
            buffType,
        );
    }
    #[inline]
    pub fn add_costs(
        &mut self,
        costs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_ManufactFormula::VT_COSTS,
            costs,
        );
    }
    #[inline]
    pub fn add_requireRooms(
        &mut self,
        requireRooms: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_BuildingData_ManufactFormula_UnlockRoom<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_ManufactFormula::VT_REQUIREROOMS,
            requireRooms,
        );
    }
    #[inline]
    pub fn add_requireStages(
        &mut self,
        requireStages: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_BuildingData_ManufactFormula_UnlockStage<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_ManufactFormula::VT_REQUIRESTAGES,
            requireStages,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_ManufactFormulaBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_ManufactFormulaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactFormula<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_ManufactFormula<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_ManufactFormula");
        ds.field("formulaId", &self.formulaId());
        ds.field("itemId", &self.itemId());
        ds.field("count", &self.count());
        ds.field("weight", &self.weight());
        ds.field("costPoint", &self.costPoint());
        ds.field("formulaType", &self.formulaType());
        ds.field("buffType", &self.buffType());
        ds.field("costs", &self.costs());
        ds.field("requireRooms", &self.requireRooms());
        ds.field("requireStages", &self.requireStages());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_ManufactFormulaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_ManufactFormula<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_BuildingData_ManufactFormula<'a> {
    type Inner = dict__string__clz_Torappu_BuildingData_ManufactFormula<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_ManufactFormula<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_ManufactFormula { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_ManufactFormulaArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_ManufactFormula<'bldr>> {
        let mut builder = dict__string__clz_Torappu_BuildingData_ManufactFormulaBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_ManufactFormula::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_ManufactFormula,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_ManufactFormula<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ManufactFormula>>(
                    dict__string__clz_Torappu_BuildingData_ManufactFormula::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_ManufactFormula<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ManufactFormula>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_ManufactFormulaArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactFormula<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_ManufactFormulaArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_ManufactFormulaArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_ManufactFormulaBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_ManufactFormulaBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_ManufactFormula::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactFormula<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactFormula>>(
                dict__string__clz_Torappu_BuildingData_ManufactFormula::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_ManufactFormulaBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_ManufactFormulaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_ManufactFormula<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_ManufactFormula::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_ManufactFormula<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_ManufactFormula");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_ShopFormula_UnlockRoomOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_ShopFormula_UnlockRoom<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_ShopFormula_UnlockRoom<'a> {
    type Inner = clz_Torappu_BuildingData_ShopFormula_UnlockRoom<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_ShopFormula_UnlockRoom<'a> {
    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_ROOMLEVEL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_ShopFormula_UnlockRoom { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_ShopFormula_UnlockRoomArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ShopFormula_UnlockRoom<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_ShopFormula_UnlockRoomBuilder::new(_fbb);
        builder.add_roomLevel(args.roomLevel);
        builder.add_roomId(args.roomId);
        builder.finish()
    }

    #[inline]
    pub fn roomId(&self) -> enum__Torappu_BuildingData_RoomType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_RoomType>(
                    clz_Torappu_BuildingData_ShopFormula_UnlockRoom::VT_ROOMID,
                    Some(enum__Torappu_BuildingData_RoomType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn roomLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_ShopFormula_UnlockRoom::VT_ROOMLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_ShopFormula_UnlockRoom<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_BuildingData_RoomType>("roomId", Self::VT_ROOMID, false)?
            .visit_field::<i32>("roomLevel", Self::VT_ROOMLEVEL, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_ShopFormula_UnlockRoomArgs {
    pub roomId: enum__Torappu_BuildingData_RoomType,
    pub roomLevel: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_ShopFormula_UnlockRoomArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_ShopFormula_UnlockRoomArgs {
            roomId: enum__Torappu_BuildingData_RoomType::NONE,
            roomLevel: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_ShopFormula_UnlockRoomBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_ShopFormula_UnlockRoomBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_roomId(&mut self, roomId: enum__Torappu_BuildingData_RoomType) {
        self.fbb_.push_slot::<enum__Torappu_BuildingData_RoomType>(
            clz_Torappu_BuildingData_ShopFormula_UnlockRoom::VT_ROOMID,
            roomId,
            enum__Torappu_BuildingData_RoomType::NONE,
        );
    }
    #[inline]
    pub fn add_roomLevel(&mut self, roomLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_ShopFormula_UnlockRoom::VT_ROOMLEVEL,
            roomLevel,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_ShopFormula_UnlockRoomBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_ShopFormula_UnlockRoomBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ShopFormula_UnlockRoom<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_ShopFormula_UnlockRoom<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_ShopFormula_UnlockRoom");
        ds.field("roomId", &self.roomId());
        ds.field("roomLevel", &self.roomLevel());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_ShopFormulaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_ShopFormula<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_ShopFormula<'a> {
    type Inner = clz_Torappu_BuildingData_ShopFormula<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_ShopFormula<'a> {
    pub const VT_FORMULAID: flatbuffers::VOffsetT = 4;
    pub const VT_ITEMID: flatbuffers::VOffsetT = 6;
    pub const VT_FORMULATYPE: flatbuffers::VOffsetT = 8;
    pub const VT_COSTPOINT: flatbuffers::VOffsetT = 10;
    pub const VT_GAINITEM: flatbuffers::VOffsetT = 12;
    pub const VT_REQUIREROOMS: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_ShopFormula { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_ShopFormulaArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ShopFormula<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_ShopFormulaBuilder::new(_fbb);
        builder.add_costPoint(args.costPoint);
        if let Some(x) = args.requireRooms {
            builder.add_requireRooms(x);
        }
        if let Some(x) = args.gainItem {
            builder.add_gainItem(x);
        }
        builder.add_formulaType(args.formulaType);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        if let Some(x) = args.formulaId {
            builder.add_formulaId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn formulaId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_ShopFormula::VT_FORMULAID,
                None,
            )
        }
    }
    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_ShopFormula::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn formulaType(&self) -> enum__Torappu_BuildingData_FormulaItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_FormulaItemType>(
                    clz_Torappu_BuildingData_ShopFormula::VT_FORMULATYPE,
                    Some(enum__Torappu_BuildingData_FormulaItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn costPoint(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_BuildingData_ShopFormula::VT_COSTPOINT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn gainItem(&self) -> Option<clz_Torappu_ItemBundle<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>(
                    clz_Torappu_BuildingData_ShopFormula::VT_GAINITEM,
                    None,
                )
        }
    }
    #[inline]
    pub fn requireRooms(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ShopFormula_UnlockRoom<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ShopFormula_UnlockRoom>,
                >,
            >>(clz_Torappu_BuildingData_ShopFormula::VT_REQUIREROOMS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_ShopFormula<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "formulaId",
                Self::VT_FORMULAID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<enum__Torappu_BuildingData_FormulaItemType>(
                "formulaType",
                Self::VT_FORMULATYPE,
                false,
            )?
            .visit_field::<i64>("costPoint", Self::VT_COSTPOINT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>(
                "gainItem",
                Self::VT_GAINITEM,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ShopFormula_UnlockRoom>,
                >,
            >>("requireRooms", Self::VT_REQUIREROOMS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_ShopFormulaArgs<'a> {
    pub formulaId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub formulaType: enum__Torappu_BuildingData_FormulaItemType,
    pub costPoint: i64,
    pub gainItem: Option<flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'a>>>,
    pub requireRooms: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ShopFormula_UnlockRoom<'a>>,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_ShopFormulaArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_ShopFormulaArgs {
            formulaId: None,
            itemId: None,
            formulaType: enum__Torappu_BuildingData_FormulaItemType::NONE,
            costPoint: 0,
            gainItem: None,
            requireRooms: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_ShopFormulaBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_ShopFormulaBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_formulaId(&mut self, formulaId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_ShopFormula::VT_FORMULAID,
            formulaId,
        );
    }
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_ShopFormula::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_formulaType(&mut self, formulaType: enum__Torappu_BuildingData_FormulaItemType) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_FormulaItemType>(
                clz_Torappu_BuildingData_ShopFormula::VT_FORMULATYPE,
                formulaType,
                enum__Torappu_BuildingData_FormulaItemType::NONE,
            );
    }
    #[inline]
    pub fn add_costPoint(&mut self, costPoint: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_BuildingData_ShopFormula::VT_COSTPOINT,
            costPoint,
            0,
        );
    }
    #[inline]
    pub fn add_gainItem(&mut self, gainItem: flatbuffers::WIPOffset<clz_Torappu_ItemBundle<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_ItemBundle>>(
                clz_Torappu_BuildingData_ShopFormula::VT_GAINITEM,
                gainItem,
            );
    }
    #[inline]
    pub fn add_requireRooms(
        &mut self,
        requireRooms: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ShopFormula_UnlockRoom<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_ShopFormula::VT_REQUIREROOMS,
            requireRooms,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_ShopFormulaBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_ShopFormulaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_ShopFormula<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_ShopFormula<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_ShopFormula");
        ds.field("formulaId", &self.formulaId());
        ds.field("itemId", &self.itemId());
        ds.field("formulaType", &self.formulaType());
        ds.field("costPoint", &self.costPoint());
        ds.field("gainItem", &self.gainItem());
        ds.field("requireRooms", &self.requireRooms());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_ShopFormulaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_ShopFormula<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_BuildingData_ShopFormula<'a> {
    type Inner = dict__string__clz_Torappu_BuildingData_ShopFormula<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_ShopFormula<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_ShopFormula { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_ShopFormulaArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_ShopFormula<'bldr>> {
        let mut builder = dict__string__clz_Torappu_BuildingData_ShopFormulaBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_ShopFormula::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_ShopFormula,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_ShopFormula<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ShopFormula>>(
                    dict__string__clz_Torappu_BuildingData_ShopFormula::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_ShopFormula<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ShopFormula>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_ShopFormulaArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_ShopFormula<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_ShopFormulaArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_ShopFormulaArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_ShopFormulaBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_ShopFormulaBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_ShopFormula::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_ShopFormula<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_ShopFormula>>(
                dict__string__clz_Torappu_BuildingData_ShopFormula::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_ShopFormulaBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_ShopFormulaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_ShopFormula<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_ShopFormula::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_ShopFormula<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_ShopFormula");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_WorkshopFormula_UnlockRoomOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom<'a> {
    type Inner = clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom<'a> {
    pub const VT_ROOMID: flatbuffers::VOffsetT = 4;
    pub const VT_ROOMLEVEL: flatbuffers::VOffsetT = 6;
    pub const VT_ROOMCOUNT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_WorkshopFormula_UnlockRoomArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_WorkshopFormula_UnlockRoomBuilder::new(_fbb);
        builder.add_roomCount(args.roomCount);
        builder.add_roomLevel(args.roomLevel);
        builder.add_roomId(args.roomId);
        builder.finish()
    }

    #[inline]
    pub fn roomId(&self) -> enum__Torappu_BuildingData_RoomType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_RoomType>(
                    clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom::VT_ROOMID,
                    Some(enum__Torappu_BuildingData_RoomType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn roomLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom::VT_ROOMLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn roomCount(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom::VT_ROOMCOUNT,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_BuildingData_RoomType>("roomId", Self::VT_ROOMID, false)?
            .visit_field::<i32>("roomLevel", Self::VT_ROOMLEVEL, false)?
            .visit_field::<i32>("roomCount", Self::VT_ROOMCOUNT, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_WorkshopFormula_UnlockRoomArgs {
    pub roomId: enum__Torappu_BuildingData_RoomType,
    pub roomLevel: i32,
    pub roomCount: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_WorkshopFormula_UnlockRoomArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_WorkshopFormula_UnlockRoomArgs {
            roomId: enum__Torappu_BuildingData_RoomType::NONE,
            roomLevel: 0,
            roomCount: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_WorkshopFormula_UnlockRoomBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_WorkshopFormula_UnlockRoomBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_roomId(&mut self, roomId: enum__Torappu_BuildingData_RoomType) {
        self.fbb_.push_slot::<enum__Torappu_BuildingData_RoomType>(
            clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom::VT_ROOMID,
            roomId,
            enum__Torappu_BuildingData_RoomType::NONE,
        );
    }
    #[inline]
    pub fn add_roomLevel(&mut self, roomLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom::VT_ROOMLEVEL,
            roomLevel,
            0,
        );
    }
    #[inline]
    pub fn add_roomCount(&mut self, roomCount: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom::VT_ROOMCOUNT,
            roomCount,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_WorkshopFormula_UnlockRoomBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_WorkshopFormula_UnlockRoomBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom");
        ds.field("roomId", &self.roomId());
        ds.field("roomLevel", &self.roomLevel());
        ds.field("roomCount", &self.roomCount());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_WorkshopFormula_UnlockStageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_WorkshopFormula_UnlockStage<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_WorkshopFormula_UnlockStage<'a> {
    type Inner = clz_Torappu_BuildingData_WorkshopFormula_UnlockStage<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_WorkshopFormula_UnlockStage<'a> {
    pub const VT_STAGEID: flatbuffers::VOffsetT = 4;
    pub const VT_RANK: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_WorkshopFormula_UnlockStage { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_WorkshopFormula_UnlockStageArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_WorkshopFormula_UnlockStage<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_WorkshopFormula_UnlockStageBuilder::new(_fbb);
        builder.add_rank(args.rank);
        if let Some(x) = args.stageId {
            builder.add_stageId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn stageId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_WorkshopFormula_UnlockStage::VT_STAGEID,
                None,
            )
        }
    }
    #[inline]
    pub fn rank(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_WorkshopFormula_UnlockStage::VT_RANK,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_WorkshopFormula_UnlockStage<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stageId", Self::VT_STAGEID, false)?
            .visit_field::<i32>("rank", Self::VT_RANK, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_WorkshopFormula_UnlockStageArgs<'a> {
    pub stageId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rank: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_WorkshopFormula_UnlockStageArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_WorkshopFormula_UnlockStageArgs {
            stageId: None,
            rank: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_WorkshopFormula_UnlockStageBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_WorkshopFormula_UnlockStageBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_stageId(&mut self, stageId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_WorkshopFormula_UnlockStage::VT_STAGEID,
            stageId,
        );
    }
    #[inline]
    pub fn add_rank(&mut self, rank: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_WorkshopFormula_UnlockStage::VT_RANK,
            rank,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_WorkshopFormula_UnlockStageBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_WorkshopFormula_UnlockStageBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_WorkshopFormula_UnlockStage<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_WorkshopFormula_UnlockStage<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_WorkshopFormula_UnlockStage");
        ds.field("stageId", &self.stageId());
        ds.field("rank", &self.rank());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_WorkshopFormulaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_WorkshopFormula<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_WorkshopFormula<'a> {
    type Inner = clz_Torappu_BuildingData_WorkshopFormula<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_WorkshopFormula<'a> {
    pub const VT_SORTID: flatbuffers::VOffsetT = 4;
    pub const VT_FORMULAID: flatbuffers::VOffsetT = 6;
    pub const VT_RARITY: flatbuffers::VOffsetT = 8;
    pub const VT_ITEMID: flatbuffers::VOffsetT = 10;
    pub const VT_COUNT: flatbuffers::VOffsetT = 12;
    pub const VT_GOLDCOST: flatbuffers::VOffsetT = 14;
    pub const VT_APCOST: flatbuffers::VOffsetT = 16;
    pub const VT_FORMULATYPE: flatbuffers::VOffsetT = 18;
    pub const VT_BUFFTYPE: flatbuffers::VOffsetT = 20;
    pub const VT_EXTRAOUTCOMERATE: flatbuffers::VOffsetT = 22;
    pub const VT_EXTRAOUTCOMEGROUP: flatbuffers::VOffsetT = 24;
    pub const VT_COSTS: flatbuffers::VOffsetT = 26;
    pub const VT_REQUIREROOMS: flatbuffers::VOffsetT = 28;
    pub const VT_REQUIRESTAGES: flatbuffers::VOffsetT = 30;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_WorkshopFormula { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_WorkshopFormulaArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_WorkshopFormula<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_WorkshopFormulaBuilder::new(_fbb);
        builder.add_apCost(args.apCost);
        builder.add_goldCost(args.goldCost);
        if let Some(x) = args.requireStages {
            builder.add_requireStages(x);
        }
        if let Some(x) = args.requireRooms {
            builder.add_requireRooms(x);
        }
        if let Some(x) = args.costs {
            builder.add_costs(x);
        }
        if let Some(x) = args.extraOutcomeGroup {
            builder.add_extraOutcomeGroup(x);
        }
        builder.add_extraOutcomeRate(args.extraOutcomeRate);
        if let Some(x) = args.buffType {
            builder.add_buffType(x);
        }
        builder.add_formulaType(args.formulaType);
        builder.add_count(args.count);
        if let Some(x) = args.itemId {
            builder.add_itemId(x);
        }
        builder.add_rarity(args.rarity);
        if let Some(x) = args.formulaId {
            builder.add_formulaId(x);
        }
        builder.add_sortId(args.sortId);
        builder.finish()
    }

    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData_WorkshopFormula::VT_SORTID, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn formulaId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_WorkshopFormula::VT_FORMULAID,
                None,
            )
        }
    }
    #[inline]
    pub fn rarity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData_WorkshopFormula::VT_RARITY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn itemId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_WorkshopFormula::VT_ITEMID,
                None,
            )
        }
    }
    #[inline]
    pub fn count(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData_WorkshopFormula::VT_COUNT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn goldCost(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_BuildingData_WorkshopFormula::VT_GOLDCOST,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn apCost(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_BuildingData_WorkshopFormula::VT_APCOST, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn formulaType(&self) -> enum__Torappu_BuildingData_FormulaItemType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_FormulaItemType>(
                    clz_Torappu_BuildingData_WorkshopFormula::VT_FORMULATYPE,
                    Some(enum__Torappu_BuildingData_FormulaItemType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn buffType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_WorkshopFormula::VT_BUFFTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn extraOutcomeRate(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(
                    clz_Torappu_BuildingData_WorkshopFormula::VT_EXTRAOUTCOMERATE,
                    Some(0.0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn extraOutcomeGroup(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopExtraWeightItem<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopExtraWeightItem>,
                >,
            >>(
                clz_Torappu_BuildingData_WorkshopFormula::VT_EXTRAOUTCOMEGROUP,
                None,
            )
        }
    }
    #[inline]
    pub fn costs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>(clz_Torappu_BuildingData_WorkshopFormula::VT_COSTS, None)
        }
    }
    #[inline]
    pub fn requireRooms(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom,
                    >,
                >,
            >>(
                clz_Torappu_BuildingData_WorkshopFormula::VT_REQUIREROOMS,
                None,
            )
        }
    }
    #[inline]
    pub fn requireStages(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopFormula_UnlockStage<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_BuildingData_WorkshopFormula_UnlockStage,
                    >,
                >,
            >>(
                clz_Torappu_BuildingData_WorkshopFormula::VT_REQUIRESTAGES,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_WorkshopFormula<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "formulaId",
                Self::VT_FORMULAID,
                false,
            )?
            .visit_field::<i32>("rarity", Self::VT_RARITY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("itemId", Self::VT_ITEMID, false)?
            .visit_field::<i32>("count", Self::VT_COUNT, false)?
            .visit_field::<i64>("goldCost", Self::VT_GOLDCOST, false)?
            .visit_field::<i64>("apCost", Self::VT_APCOST, false)?
            .visit_field::<enum__Torappu_BuildingData_FormulaItemType>(
                "formulaType",
                Self::VT_FORMULATYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "buffType",
                Self::VT_BUFFTYPE,
                false,
            )?
            .visit_field::<f32>("extraOutcomeRate", Self::VT_EXTRAOUTCOMERATE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopExtraWeightItem>,
                >,
            >>("extraOutcomeGroup", Self::VT_EXTRAOUTCOMEGROUP, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle>>,
            >>("costs", Self::VT_COSTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom,
                    >,
                >,
            >>("requireRooms", Self::VT_REQUIREROOMS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        clz_Torappu_BuildingData_WorkshopFormula_UnlockStage,
                    >,
                >,
            >>("requireStages", Self::VT_REQUIRESTAGES, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_WorkshopFormulaArgs<'a> {
    pub sortId: i32,
    pub formulaId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rarity: i32,
    pub itemId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub count: i32,
    pub goldCost: i64,
    pub apCost: i64,
    pub formulaType: enum__Torappu_BuildingData_FormulaItemType,
    pub buffType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub extraOutcomeRate: f32,
    pub extraOutcomeGroup: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopExtraWeightItem<'a>>,
            >,
        >,
    >,
    pub costs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'a>>>,
        >,
    >,
    pub requireRooms: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom<'a>,
                >,
            >,
        >,
    >,
    pub requireStages: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_BuildingData_WorkshopFormula_UnlockStage<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_WorkshopFormulaArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_WorkshopFormulaArgs {
            sortId: 0,
            formulaId: None,
            rarity: 0,
            itemId: None,
            count: 0,
            goldCost: 0,
            apCost: 0,
            formulaType: enum__Torappu_BuildingData_FormulaItemType::NONE,
            buffType: None,
            extraOutcomeRate: 0.0,
            extraOutcomeGroup: None,
            costs: None,
            requireRooms: None,
            requireStages: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_WorkshopFormulaBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_WorkshopFormulaBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_WorkshopFormula::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn add_formulaId(&mut self, formulaId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_WorkshopFormula::VT_FORMULAID,
            formulaId,
        );
    }
    #[inline]
    pub fn add_rarity(&mut self, rarity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_WorkshopFormula::VT_RARITY,
            rarity,
            0,
        );
    }
    #[inline]
    pub fn add_itemId(&mut self, itemId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_WorkshopFormula::VT_ITEMID,
            itemId,
        );
    }
    #[inline]
    pub fn add_count(&mut self, count: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_BuildingData_WorkshopFormula::VT_COUNT, count, 0);
    }
    #[inline]
    pub fn add_goldCost(&mut self, goldCost: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_BuildingData_WorkshopFormula::VT_GOLDCOST,
            goldCost,
            0,
        );
    }
    #[inline]
    pub fn add_apCost(&mut self, apCost: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_BuildingData_WorkshopFormula::VT_APCOST,
            apCost,
            0,
        );
    }
    #[inline]
    pub fn add_formulaType(&mut self, formulaType: enum__Torappu_BuildingData_FormulaItemType) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_FormulaItemType>(
                clz_Torappu_BuildingData_WorkshopFormula::VT_FORMULATYPE,
                formulaType,
                enum__Torappu_BuildingData_FormulaItemType::NONE,
            );
    }
    #[inline]
    pub fn add_buffType(&mut self, buffType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_WorkshopFormula::VT_BUFFTYPE,
            buffType,
        );
    }
    #[inline]
    pub fn add_extraOutcomeRate(&mut self, extraOutcomeRate: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_BuildingData_WorkshopFormula::VT_EXTRAOUTCOMERATE,
            extraOutcomeRate,
            0.0,
        );
    }
    #[inline]
    pub fn add_extraOutcomeGroup(
        &mut self,
        extraOutcomeGroup: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopExtraWeightItem<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_WorkshopFormula::VT_EXTRAOUTCOMEGROUP,
            extraOutcomeGroup,
        );
    }
    #[inline]
    pub fn add_costs(
        &mut self,
        costs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<clz_Torappu_ItemBundle<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_WorkshopFormula::VT_COSTS,
            costs,
        );
    }
    #[inline]
    pub fn add_requireRooms(
        &mut self,
        requireRooms: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_BuildingData_WorkshopFormula_UnlockRoom<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_WorkshopFormula::VT_REQUIREROOMS,
            requireRooms,
        );
    }
    #[inline]
    pub fn add_requireStages(
        &mut self,
        requireStages: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    clz_Torappu_BuildingData_WorkshopFormula_UnlockStage<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_WorkshopFormula::VT_REQUIRESTAGES,
            requireStages,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_WorkshopFormulaBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_WorkshopFormulaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_WorkshopFormula<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_WorkshopFormula<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_WorkshopFormula");
        ds.field("sortId", &self.sortId());
        ds.field("formulaId", &self.formulaId());
        ds.field("rarity", &self.rarity());
        ds.field("itemId", &self.itemId());
        ds.field("count", &self.count());
        ds.field("goldCost", &self.goldCost());
        ds.field("apCost", &self.apCost());
        ds.field("formulaType", &self.formulaType());
        ds.field("buffType", &self.buffType());
        ds.field("extraOutcomeRate", &self.extraOutcomeRate());
        ds.field("extraOutcomeGroup", &self.extraOutcomeGroup());
        ds.field("costs", &self.costs());
        ds.field("requireRooms", &self.requireRooms());
        ds.field("requireStages", &self.requireStages());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_WorkshopFormulaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_WorkshopFormula<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_BuildingData_WorkshopFormula<'a> {
    type Inner = dict__string__clz_Torappu_BuildingData_WorkshopFormula<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_WorkshopFormula<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_WorkshopFormula { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_WorkshopFormulaArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_WorkshopFormula<'bldr>> {
        let mut builder = dict__string__clz_Torappu_BuildingData_WorkshopFormulaBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_WorkshopFormula::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_WorkshopFormula,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_WorkshopFormula<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopFormula>>(
                    dict__string__clz_Torappu_BuildingData_WorkshopFormula::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_WorkshopFormula<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopFormula>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_WorkshopFormulaArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_WorkshopFormula<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_WorkshopFormulaArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_WorkshopFormulaArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_WorkshopFormulaBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_WorkshopFormulaBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_WorkshopFormula::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_WorkshopFormula<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_WorkshopFormula>>(
                dict__string__clz_Torappu_BuildingData_WorkshopFormula::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_WorkshopFormulaBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_WorkshopFormulaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_WorkshopFormula<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_WorkshopFormula::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_WorkshopFormula<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_WorkshopFormula");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_CreditFormula_ValueModelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_CreditFormula_ValueModel<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_CreditFormula_ValueModel<'a> {
    type Inner = clz_Torappu_BuildingData_CreditFormula_ValueModel<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_CreditFormula_ValueModel<'a> {
    pub const VT_BASIC: flatbuffers::VOffsetT = 4;
    pub const VT_ADDITION: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_CreditFormula_ValueModel { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_CreditFormula_ValueModelArgs,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CreditFormula_ValueModel<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_CreditFormula_ValueModelBuilder::new(_fbb);
        builder.add_addition(args.addition);
        builder.add_basic(args.basic);
        builder.finish()
    }

    #[inline]
    pub fn basic(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CreditFormula_ValueModel::VT_BASIC,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn addition(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_CreditFormula_ValueModel::VT_ADDITION,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_CreditFormula_ValueModel<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("basic", Self::VT_BASIC, false)?
            .visit_field::<i32>("addition", Self::VT_ADDITION, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_CreditFormula_ValueModelArgs {
    pub basic: i32,
    pub addition: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_CreditFormula_ValueModelArgs {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_CreditFormula_ValueModelArgs {
            basic: 0,
            addition: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_CreditFormula_ValueModelBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_CreditFormula_ValueModelBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_basic(&mut self, basic: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CreditFormula_ValueModel::VT_BASIC,
            basic,
            0,
        );
    }
    #[inline]
    pub fn add_addition(&mut self, addition: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_CreditFormula_ValueModel::VT_ADDITION,
            addition,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_CreditFormula_ValueModelBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_CreditFormula_ValueModelBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CreditFormula_ValueModel<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_CreditFormula_ValueModel<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_CreditFormula_ValueModel");
        ds.field("basic", &self.basic());
        ds.field("addition", &self.addition());
        ds.finish()
    }
}
pub enum dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel<'a>
{
    type Inner = dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModelArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel<'bldr>>
    {
        let mut builder =
            dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModelBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_CreditFormula_ValueModel<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CreditFormula_ValueModel>>(dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<i32>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CreditFormula_ValueModel>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModelArgs<'a> {
    pub key: i32,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_CreditFormula_ValueModel<'a>>>,
}
impl<'a> Default for dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModelArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModelArgs {
            key: 0,
            value: None,
        }
    }
}

pub struct dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModelBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModelBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_CreditFormula_ValueModel<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_CreditFormula_ValueModel>>(dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModelBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModelBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_CreditFormulaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_CreditFormula<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_CreditFormula<'a> {
    type Inner = clz_Torappu_BuildingData_CreditFormula<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_CreditFormula<'a> {
    pub const VT_INITIATIVE: flatbuffers::VOffsetT = 4;
    pub const VT_PASSIVE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_CreditFormula { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_CreditFormulaArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CreditFormula<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_CreditFormulaBuilder::new(_fbb);
        if let Some(x) = args.passive {
            builder.add_passive(x);
        }
        if let Some(x) = args.initiative {
            builder.add_initiative(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn initiative(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel,
                    >,
                >,
            >>(clz_Torappu_BuildingData_CreditFormula::VT_INITIATIVE, None)
        }
    }
    #[inline]
    pub fn passive(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel,
                    >,
                >,
            >>(clz_Torappu_BuildingData_CreditFormula::VT_PASSIVE, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_CreditFormula<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel,
                    >,
                >,
            >>("initiative", Self::VT_INITIATIVE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel,
                    >,
                >,
            >>("passive", Self::VT_PASSIVE, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_CreditFormulaArgs<'a> {
    pub initiative: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel<'a>,
                >,
            >,
        >,
    >,
    pub passive: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_CreditFormulaArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_CreditFormulaArgs {
            initiative: None,
            passive: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_CreditFormulaBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
{
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_CreditFormulaBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_initiative(
        &mut self,
        initiative: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CreditFormula::VT_INITIATIVE,
            initiative,
        );
    }
    #[inline]
    pub fn add_passive(
        &mut self,
        passive: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_BuildingData_CreditFormula_ValueModel<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_CreditFormula::VT_PASSIVE,
            passive,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_CreditFormulaBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_CreditFormulaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_CreditFormula<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_CreditFormula<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_CreditFormula");
        ds.field("initiative", &self.initiative());
        ds.field("passive", &self.passive());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_WorkshopRarityInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_WorkshopRarityInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_WorkshopRarityInfo<'a> {
    type Inner = clz_Torappu_BuildingData_WorkshopRarityInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_WorkshopRarityInfo<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_ORDER: flatbuffers::VOffsetT = 6;
    pub const VT_RARITYLIST: flatbuffers::VOffsetT = 8;
    pub const VT_COLOR: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_WorkshopRarityInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_WorkshopRarityInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_WorkshopRarityInfo<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_WorkshopRarityInfoBuilder::new(_fbb);
        if let Some(x) = args.color {
            builder.add_color(x);
        }
        if let Some(x) = args.rarityList {
            builder.add_rarityList(x);
        }
        builder.add_order(args.order);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_WorkshopRarityInfo::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn order(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_WorkshopRarityInfo::VT_ORDER,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn rarityList(&self) -> Option<flatbuffers::Vector<'a, enum__Torappu_ItemRarity>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, enum__Torappu_ItemRarity>>>(clz_Torappu_BuildingData_WorkshopRarityInfo::VT_RARITYLIST, None)
        }
    }
    #[inline]
    pub fn color(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_WorkshopRarityInfo::VT_COLOR,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_WorkshopRarityInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<i32>("order", Self::VT_ORDER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, enum__Torappu_ItemRarity>>>("rarityList", Self::VT_RARITYLIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("color", Self::VT_COLOR, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_WorkshopRarityInfoArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub order: i32,
    pub rarityList:
        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, enum__Torappu_ItemRarity>>>,
    pub color: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_BuildingData_WorkshopRarityInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_WorkshopRarityInfoArgs {
            name: None,
            order: 0,
            rarityList: None,
            color: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_WorkshopRarityInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_WorkshopRarityInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_WorkshopRarityInfo::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_order(&mut self, order: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_WorkshopRarityInfo::VT_ORDER,
            order,
            0,
        );
    }
    #[inline]
    pub fn add_rarityList(
        &mut self,
        rarityList: flatbuffers::WIPOffset<flatbuffers::Vector<'b, enum__Torappu_ItemRarity>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_WorkshopRarityInfo::VT_RARITYLIST,
            rarityList,
        );
    }
    #[inline]
    pub fn add_color(&mut self, color: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_WorkshopRarityInfo::VT_COLOR,
            color,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_WorkshopRarityInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_WorkshopRarityInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_WorkshopRarityInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_WorkshopRarityInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_WorkshopRarityInfo");
        ds.field("name", &self.name());
        ds.field("order", &self.order());
        ds.field("rarityList", &self.rarityList());
        ds.field("color", &self.color());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_SlotPrequeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_SlotPrequeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_SlotPrequeData<'a> {
    type Inner = clz_Torappu_BuildingData_SlotPrequeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_SlotPrequeData<'a> {
    pub const VT_ROOMTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_TYPESORTID: flatbuffers::VOffsetT = 8;
    pub const VT_ISPREQUE: flatbuffers::VOffsetT = 10;
    pub const VT_PREQUENUM: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_SlotPrequeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_SlotPrequeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_SlotPrequeData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_SlotPrequeDataBuilder::new(_fbb);
        builder.add_prequeNum(args.prequeNum);
        builder.add_typeSortId(args.typeSortId);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_roomType(args.roomType);
        builder.add_isPreque(args.isPreque);
        builder.finish()
    }

    #[inline]
    pub fn roomType(&self) -> enum__Torappu_BuildingData_RoomType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_RoomType>(
                    clz_Torappu_BuildingData_SlotPrequeData::VT_ROOMTYPE,
                    Some(enum__Torappu_BuildingData_RoomType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_SlotPrequeData::VT_NAME,
                None,
            )
        }
    }
    #[inline]
    pub fn typeSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_SlotPrequeData::VT_TYPESORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn isPreque(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BuildingData_SlotPrequeData::VT_ISPREQUE,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn prequeNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_SlotPrequeData::VT_PREQUENUM,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_SlotPrequeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_BuildingData_RoomType>(
                "roomType",
                Self::VT_ROOMTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<i32>("typeSortId", Self::VT_TYPESORTID, false)?
            .visit_field::<bool>("isPreque", Self::VT_ISPREQUE, false)?
            .visit_field::<i32>("prequeNum", Self::VT_PREQUENUM, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_SlotPrequeDataArgs<'a> {
    pub roomType: enum__Torappu_BuildingData_RoomType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub typeSortId: i32,
    pub isPreque: bool,
    pub prequeNum: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_SlotPrequeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_SlotPrequeDataArgs {
            roomType: enum__Torappu_BuildingData_RoomType::NONE,
            name: None,
            typeSortId: 0,
            isPreque: false,
            prequeNum: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_SlotPrequeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_SlotPrequeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_roomType(&mut self, roomType: enum__Torappu_BuildingData_RoomType) {
        self.fbb_.push_slot::<enum__Torappu_BuildingData_RoomType>(
            clz_Torappu_BuildingData_SlotPrequeData::VT_ROOMTYPE,
            roomType,
            enum__Torappu_BuildingData_RoomType::NONE,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_SlotPrequeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn add_typeSortId(&mut self, typeSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_SlotPrequeData::VT_TYPESORTID,
            typeSortId,
            0,
        );
    }
    #[inline]
    pub fn add_isPreque(&mut self, isPreque: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuildingData_SlotPrequeData::VT_ISPREQUE,
            isPreque,
            false,
        );
    }
    #[inline]
    pub fn add_prequeNum(&mut self, prequeNum: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_SlotPrequeData::VT_PREQUENUM,
            prequeNum,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_SlotPrequeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_SlotPrequeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_SlotPrequeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_SlotPrequeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_SlotPrequeData");
        ds.field("roomType", &self.roomType());
        ds.field("name", &self.name());
        ds.field("typeSortId", &self.typeSortId());
        ds.field("isPreque", &self.isPreque());
        ds.field("prequeNum", &self.prequeNum());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_SlotPrequeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_SlotPrequeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_BuildingData_SlotPrequeData<'a> {
    type Inner = dict__string__clz_Torappu_BuildingData_SlotPrequeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_SlotPrequeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_SlotPrequeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_SlotPrequeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_SlotPrequeData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_BuildingData_SlotPrequeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_SlotPrequeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_SlotPrequeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_SlotPrequeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_SlotPrequeData>>(
                    dict__string__clz_Torappu_BuildingData_SlotPrequeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_SlotPrequeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_SlotPrequeData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_SlotPrequeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_SlotPrequeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_SlotPrequeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_SlotPrequeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_SlotPrequeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_SlotPrequeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_SlotPrequeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_SlotPrequeData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_SlotPrequeData>>(
                dict__string__clz_Torappu_BuildingData_SlotPrequeData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_SlotPrequeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_SlotPrequeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_SlotPrequeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_SlotPrequeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_SlotPrequeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_SlotPrequeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_DormitoryPrequeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_DormitoryPrequeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_DormitoryPrequeData<'a> {
    type Inner = clz_Torappu_BuildingData_DormitoryPrequeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_DormitoryPrequeData<'a> {
    pub const VT_ROOMTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_DormitoryPrequeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_DormitoryPrequeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_DormitoryPrequeData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_DormitoryPrequeDataBuilder::new(_fbb);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_roomType(args.roomType);
        builder.finish()
    }

    #[inline]
    pub fn roomType(&self) -> enum__Torappu_BuildingData_RoomType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_RoomType>(
                    clz_Torappu_BuildingData_DormitoryPrequeData::VT_ROOMTYPE,
                    Some(enum__Torappu_BuildingData_RoomType::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_DormitoryPrequeData::VT_NAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_DormitoryPrequeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_BuildingData_RoomType>(
                "roomType",
                Self::VT_ROOMTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_DormitoryPrequeDataArgs<'a> {
    pub roomType: enum__Torappu_BuildingData_RoomType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_BuildingData_DormitoryPrequeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_DormitoryPrequeDataArgs {
            roomType: enum__Torappu_BuildingData_RoomType::NONE,
            name: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_DormitoryPrequeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_DormitoryPrequeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_roomType(&mut self, roomType: enum__Torappu_BuildingData_RoomType) {
        self.fbb_.push_slot::<enum__Torappu_BuildingData_RoomType>(
            clz_Torappu_BuildingData_DormitoryPrequeData::VT_ROOMTYPE,
            roomType,
            enum__Torappu_BuildingData_RoomType::NONE,
        );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_DormitoryPrequeData::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_DormitoryPrequeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_DormitoryPrequeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_DormitoryPrequeData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_DormitoryPrequeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_DormitoryPrequeData");
        ds.field("roomType", &self.roomType());
        ds.field("name", &self.name());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_DormitoryPrequeDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_DormitoryPrequeData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_BuildingData_DormitoryPrequeData<'a>
{
    type Inner = dict__string__clz_Torappu_BuildingData_DormitoryPrequeData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_DormitoryPrequeData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_DormitoryPrequeData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_DormitoryPrequeDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_DormitoryPrequeData<'bldr>>
    {
        let mut builder =
            dict__string__clz_Torappu_BuildingData_DormitoryPrequeDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_DormitoryPrequeData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_DormitoryPrequeData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_DormitoryPrequeData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_DormitoryPrequeData>>(
                    dict__string__clz_Torappu_BuildingData_DormitoryPrequeData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_DormitoryPrequeData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_DormitoryPrequeData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_DormitoryPrequeDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_DormitoryPrequeData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_DormitoryPrequeDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_DormitoryPrequeDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_DormitoryPrequeDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_DormitoryPrequeDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_DormitoryPrequeData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_DormitoryPrequeData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_DormitoryPrequeData>>(dict__string__clz_Torappu_BuildingData_DormitoryPrequeData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_DormitoryPrequeDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_DormitoryPrequeDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_DormitoryPrequeData<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_DormitoryPrequeData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_DormitoryPrequeData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_DormitoryPrequeData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum dict__string__stringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__string<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__string<'a> {
    type Inner = dict__string__string<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__string<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__string { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__stringArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__string<'bldr>> {
        let mut builder = dict__string__stringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_KEY, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &dict__string__string) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__string::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__string__string<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__stringArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for dict__string__stringArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__stringArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__stringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> dict__string__stringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__string::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__stringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__stringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<dict__string__string<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__string::VT_KEY, "key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__string<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__string");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_StationManageConstDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_StationManageConstData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_StationManageConstData<'a> {
    type Inner = clz_Torappu_BuildingData_StationManageConstData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_StationManageConstData<'a> {
    pub const VT_CANTWORKTOASTNOTIREDCHAR: flatbuffers::VOffsetT = 4;
    pub const VT_CANTWORKTOASTNOAVAILQUEUE: flatbuffers::VOffsetT = 6;
    pub const VT_CANTWORKTOASTNONEED: flatbuffers::VOffsetT = 8;
    pub const VT_CANTRESTTOASTNOTIREDCHAR: flatbuffers::VOffsetT = 10;
    pub const VT_CANTRESTTOASTNOAVAILDORM: flatbuffers::VOffsetT = 12;
    pub const VT_WORKBATCHTOAST: flatbuffers::VOffsetT = 14;
    pub const VT_RESTBATCHTOAST: flatbuffers::VOffsetT = 16;
    pub const VT_ROOMNOAVAILQUEUETOAST: flatbuffers::VOffsetT = 18;
    pub const VT_CANTUSENOPERSON: flatbuffers::VOffsetT = 20;
    pub const VT_CANTUSEWORKING: flatbuffers::VOffsetT = 22;
    pub const VT_QUEUECLEARED: flatbuffers::VOffsetT = 24;
    pub const VT_UPDATETIME: flatbuffers::VOffsetT = 26;
    pub const VT_DORMLOCKUPDATETIME: flatbuffers::VOffsetT = 28;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_StationManageConstData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_StationManageConstDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_StationManageConstData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_StationManageConstDataBuilder::new(_fbb);
        builder.add_dormLockUpdateTime(args.dormLockUpdateTime);
        builder.add_updateTime(args.updateTime);
        if let Some(x) = args.queueCleared {
            builder.add_queueCleared(x);
        }
        if let Some(x) = args.cantUseWorking {
            builder.add_cantUseWorking(x);
        }
        if let Some(x) = args.cantUseNoPerson {
            builder.add_cantUseNoPerson(x);
        }
        if let Some(x) = args.roomNoAvailQueueToast {
            builder.add_roomNoAvailQueueToast(x);
        }
        if let Some(x) = args.restBatchToast {
            builder.add_restBatchToast(x);
        }
        if let Some(x) = args.workBatchToast {
            builder.add_workBatchToast(x);
        }
        if let Some(x) = args.cantRestToastNoAvailDorm {
            builder.add_cantRestToastNoAvailDorm(x);
        }
        if let Some(x) = args.cantRestToastNoTiredChar {
            builder.add_cantRestToastNoTiredChar(x);
        }
        if let Some(x) = args.cantWorkToastNoNeed {
            builder.add_cantWorkToastNoNeed(x);
        }
        if let Some(x) = args.cantWorkToastNoAvailQueue {
            builder.add_cantWorkToastNoAvailQueue(x);
        }
        if let Some(x) = args.cantWorkToastNoTiredChar {
            builder.add_cantWorkToastNoTiredChar(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn cantWorkToastNoTiredChar(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_StationManageConstData::VT_CANTWORKTOASTNOTIREDCHAR,
                None,
            )
        }
    }
    #[inline]
    pub fn cantWorkToastNoAvailQueue(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_StationManageConstData::VT_CANTWORKTOASTNOAVAILQUEUE,
                None,
            )
        }
    }
    #[inline]
    pub fn cantWorkToastNoNeed(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_StationManageConstData::VT_CANTWORKTOASTNONEED,
                None,
            )
        }
    }
    #[inline]
    pub fn cantRestToastNoTiredChar(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_StationManageConstData::VT_CANTRESTTOASTNOTIREDCHAR,
                None,
            )
        }
    }
    #[inline]
    pub fn cantRestToastNoAvailDorm(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_StationManageConstData::VT_CANTRESTTOASTNOAVAILDORM,
                None,
            )
        }
    }
    #[inline]
    pub fn workBatchToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_StationManageConstData::VT_WORKBATCHTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn restBatchToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_StationManageConstData::VT_RESTBATCHTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn roomNoAvailQueueToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_StationManageConstData::VT_ROOMNOAVAILQUEUETOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn cantUseNoPerson(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_StationManageConstData::VT_CANTUSENOPERSON,
                None,
            )
        }
    }
    #[inline]
    pub fn cantUseWorking(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_StationManageConstData::VT_CANTUSEWORKING,
                None,
            )
        }
    }
    #[inline]
    pub fn queueCleared(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_StationManageConstData::VT_QUEUECLEARED,
                None,
            )
        }
    }
    #[inline]
    pub fn updateTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_BuildingData_StationManageConstData::VT_UPDATETIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn dormLockUpdateTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_BuildingData_StationManageConstData::VT_DORMLOCKUPDATETIME,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_StationManageConstData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "cantWorkToastNoTiredChar",
                Self::VT_CANTWORKTOASTNOTIREDCHAR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "cantWorkToastNoAvailQueue",
                Self::VT_CANTWORKTOASTNOAVAILQUEUE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "cantWorkToastNoNeed",
                Self::VT_CANTWORKTOASTNONEED,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "cantRestToastNoTiredChar",
                Self::VT_CANTRESTTOASTNOTIREDCHAR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "cantRestToastNoAvailDorm",
                Self::VT_CANTRESTTOASTNOAVAILDORM,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "workBatchToast",
                Self::VT_WORKBATCHTOAST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "restBatchToast",
                Self::VT_RESTBATCHTOAST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "roomNoAvailQueueToast",
                Self::VT_ROOMNOAVAILQUEUETOAST,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "cantUseNoPerson",
                Self::VT_CANTUSENOPERSON,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "cantUseWorking",
                Self::VT_CANTUSEWORKING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "queueCleared",
                Self::VT_QUEUECLEARED,
                false,
            )?
            .visit_field::<i64>("updateTime", Self::VT_UPDATETIME, false)?
            .visit_field::<i64>("dormLockUpdateTime", Self::VT_DORMLOCKUPDATETIME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_StationManageConstDataArgs<'a> {
    pub cantWorkToastNoTiredChar: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cantWorkToastNoAvailQueue: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cantWorkToastNoNeed: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cantRestToastNoTiredChar: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cantRestToastNoAvailDorm: Option<flatbuffers::WIPOffset<&'a str>>,
    pub workBatchToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub restBatchToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub roomNoAvailQueueToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cantUseNoPerson: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cantUseWorking: Option<flatbuffers::WIPOffset<&'a str>>,
    pub queueCleared: Option<flatbuffers::WIPOffset<&'a str>>,
    pub updateTime: i64,
    pub dormLockUpdateTime: i64,
}
impl<'a> Default for clz_Torappu_BuildingData_StationManageConstDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_StationManageConstDataArgs {
            cantWorkToastNoTiredChar: None,
            cantWorkToastNoAvailQueue: None,
            cantWorkToastNoNeed: None,
            cantRestToastNoTiredChar: None,
            cantRestToastNoAvailDorm: None,
            workBatchToast: None,
            restBatchToast: None,
            roomNoAvailQueueToast: None,
            cantUseNoPerson: None,
            cantUseWorking: None,
            queueCleared: None,
            updateTime: 0,
            dormLockUpdateTime: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_StationManageConstDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_StationManageConstDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_cantWorkToastNoTiredChar(
        &mut self,
        cantWorkToastNoTiredChar: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_StationManageConstData::VT_CANTWORKTOASTNOTIREDCHAR,
            cantWorkToastNoTiredChar,
        );
    }
    #[inline]
    pub fn add_cantWorkToastNoAvailQueue(
        &mut self,
        cantWorkToastNoAvailQueue: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_StationManageConstData::VT_CANTWORKTOASTNOAVAILQUEUE,
            cantWorkToastNoAvailQueue,
        );
    }
    #[inline]
    pub fn add_cantWorkToastNoNeed(
        &mut self,
        cantWorkToastNoNeed: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_StationManageConstData::VT_CANTWORKTOASTNONEED,
            cantWorkToastNoNeed,
        );
    }
    #[inline]
    pub fn add_cantRestToastNoTiredChar(
        &mut self,
        cantRestToastNoTiredChar: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_StationManageConstData::VT_CANTRESTTOASTNOTIREDCHAR,
            cantRestToastNoTiredChar,
        );
    }
    #[inline]
    pub fn add_cantRestToastNoAvailDorm(
        &mut self,
        cantRestToastNoAvailDorm: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_StationManageConstData::VT_CANTRESTTOASTNOAVAILDORM,
            cantRestToastNoAvailDorm,
        );
    }
    #[inline]
    pub fn add_workBatchToast(&mut self, workBatchToast: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_StationManageConstData::VT_WORKBATCHTOAST,
            workBatchToast,
        );
    }
    #[inline]
    pub fn add_restBatchToast(&mut self, restBatchToast: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_StationManageConstData::VT_RESTBATCHTOAST,
            restBatchToast,
        );
    }
    #[inline]
    pub fn add_roomNoAvailQueueToast(
        &mut self,
        roomNoAvailQueueToast: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_StationManageConstData::VT_ROOMNOAVAILQUEUETOAST,
            roomNoAvailQueueToast,
        );
    }
    #[inline]
    pub fn add_cantUseNoPerson(&mut self, cantUseNoPerson: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_StationManageConstData::VT_CANTUSENOPERSON,
            cantUseNoPerson,
        );
    }
    #[inline]
    pub fn add_cantUseWorking(&mut self, cantUseWorking: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_StationManageConstData::VT_CANTUSEWORKING,
            cantUseWorking,
        );
    }
    #[inline]
    pub fn add_queueCleared(&mut self, queueCleared: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_StationManageConstData::VT_QUEUECLEARED,
            queueCleared,
        );
    }
    #[inline]
    pub fn add_updateTime(&mut self, updateTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_BuildingData_StationManageConstData::VT_UPDATETIME,
            updateTime,
            0,
        );
    }
    #[inline]
    pub fn add_dormLockUpdateTime(&mut self, dormLockUpdateTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_BuildingData_StationManageConstData::VT_DORMLOCKUPDATETIME,
            dormLockUpdateTime,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_StationManageConstDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_StationManageConstDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_StationManageConstData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_StationManageConstData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_StationManageConstData");
        ds.field("cantWorkToastNoTiredChar", &self.cantWorkToastNoTiredChar());
        ds.field(
            "cantWorkToastNoAvailQueue",
            &self.cantWorkToastNoAvailQueue(),
        );
        ds.field("cantWorkToastNoNeed", &self.cantWorkToastNoNeed());
        ds.field("cantRestToastNoTiredChar", &self.cantRestToastNoTiredChar());
        ds.field("cantRestToastNoAvailDorm", &self.cantRestToastNoAvailDorm());
        ds.field("workBatchToast", &self.workBatchToast());
        ds.field("restBatchToast", &self.restBatchToast());
        ds.field("roomNoAvailQueueToast", &self.roomNoAvailQueueToast());
        ds.field("cantUseNoPerson", &self.cantUseNoPerson());
        ds.field("cantUseWorking", &self.cantUseWorking());
        ds.field("queueCleared", &self.queueCleared());
        ds.field("updateTime", &self.updateTime());
        ds.field("dormLockUpdateTime", &self.dormLockUpdateTime());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_StationManageFilterInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_StationManageFilterInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_StationManageFilterInfo<'a> {
    type Inner = clz_Torappu_BuildingData_StationManageFilterInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_StationManageFilterInfo<'a> {
    pub const VT_CHARSTATIONFILTERTYPE: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_StationManageFilterInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_StationManageFilterInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_StationManageFilterInfo<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_StationManageFilterInfoBuilder::new(_fbb);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_charStationFilterType(args.charStationFilterType);
        builder.finish()
    }

    #[inline]
    pub fn charStationFilterType(&self) -> enum__Torappu_BuildingData_CharStationFilterType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<enum__Torappu_BuildingData_CharStationFilterType>(
                    clz_Torappu_BuildingData_StationManageFilterInfo::VT_CHARSTATIONFILTERTYPE,
                    Some(enum__Torappu_BuildingData_CharStationFilterType::All),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_StationManageFilterInfo::VT_NAME,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_StationManageFilterInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<enum__Torappu_BuildingData_CharStationFilterType>(
                "charStationFilterType",
                Self::VT_CHARSTATIONFILTERTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_StationManageFilterInfoArgs<'a> {
    pub charStationFilterType: enum__Torappu_BuildingData_CharStationFilterType,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for clz_Torappu_BuildingData_StationManageFilterInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_StationManageFilterInfoArgs {
            charStationFilterType: enum__Torappu_BuildingData_CharStationFilterType::All,
            name: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_StationManageFilterInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_StationManageFilterInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_charStationFilterType(
        &mut self,
        charStationFilterType: enum__Torappu_BuildingData_CharStationFilterType,
    ) {
        self.fbb_
            .push_slot::<enum__Torappu_BuildingData_CharStationFilterType>(
                clz_Torappu_BuildingData_StationManageFilterInfo::VT_CHARSTATIONFILTERTYPE,
                charStationFilterType,
                enum__Torappu_BuildingData_CharStationFilterType::All,
            );
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_StationManageFilterInfo::VT_NAME,
            name,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_StationManageFilterInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_StationManageFilterInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_StationManageFilterInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_StationManageFilterInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_StationManageFilterInfo");
        ds.field("charStationFilterType", &self.charStationFilterType());
        ds.field("name", &self.name());
        ds.finish()
    }
}
pub enum dict__int__clz_Torappu_BuildingData_StationManageFilterInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__int__clz_Torappu_BuildingData_StationManageFilterInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__int__clz_Torappu_BuildingData_StationManageFilterInfo<'a>
{
    type Inner = dict__int__clz_Torappu_BuildingData_StationManageFilterInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__int__clz_Torappu_BuildingData_StationManageFilterInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__int__clz_Torappu_BuildingData_StationManageFilterInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__int__clz_Torappu_BuildingData_StationManageFilterInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_BuildingData_StationManageFilterInfo<'bldr>>
    {
        let mut builder =
            dict__int__clz_Torappu_BuildingData_StationManageFilterInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_key(args.key);
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    dict__int__clz_Torappu_BuildingData_StationManageFilterInfo::VT_KEY,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__int__clz_Torappu_BuildingData_StationManageFilterInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: i32) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(&val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_StationManageFilterInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_StationManageFilterInfo>>(dict__int__clz_Torappu_BuildingData_StationManageFilterInfo::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for dict__int__clz_Torappu_BuildingData_StationManageFilterInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<i32>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_StationManageFilterInfo>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__int__clz_Torappu_BuildingData_StationManageFilterInfoArgs<'a> {
    pub key: i32,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_StationManageFilterInfo<'a>>>,
}
impl<'a> Default for dict__int__clz_Torappu_BuildingData_StationManageFilterInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__int__clz_Torappu_BuildingData_StationManageFilterInfoArgs {
            key: 0,
            value: None,
        }
    }
}

pub struct dict__int__clz_Torappu_BuildingData_StationManageFilterInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__int__clz_Torappu_BuildingData_StationManageFilterInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: i32) {
        self.fbb_.push_slot::<i32>(
            dict__int__clz_Torappu_BuildingData_StationManageFilterInfo::VT_KEY,
            key,
            0,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_StationManageFilterInfo<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_StationManageFilterInfo>>(dict__int__clz_Torappu_BuildingData_StationManageFilterInfo::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__int__clz_Torappu_BuildingData_StationManageFilterInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__int__clz_Torappu_BuildingData_StationManageFilterInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__int__clz_Torappu_BuildingData_StationManageFilterInfo<'a>>
    {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__int__clz_Torappu_BuildingData_StationManageFilterInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__int__clz_Torappu_BuildingData_StationManageFilterInfo");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_MusicSingleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_MusicSingleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_MusicSingleData<'a> {
    type Inner = clz_Torappu_BuildingData_MusicSingleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_MusicSingleData<'a> {
    pub const VT_BGMID: flatbuffers::VOffsetT = 4;
    pub const VT_BGMSORTID: flatbuffers::VOffsetT = 6;
    pub const VT_BGMSTARTTIME: flatbuffers::VOffsetT = 8;
    pub const VT_BGMNAME: flatbuffers::VOffsetT = 10;
    pub const VT_GAMEMUSICID: flatbuffers::VOffsetT = 12;
    pub const VT_OBTAINAPPROACH: flatbuffers::VOffsetT = 14;
    pub const VT_BGMDESCUNLOCKED: flatbuffers::VOffsetT = 16;
    pub const VT_UNLOCKTYPE: flatbuffers::VOffsetT = 18;
    pub const VT_UNLOCKPARAMS: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_MusicSingleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_MusicSingleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_MusicSingleData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_MusicSingleDataBuilder::new(_fbb);
        builder.add_bgmStartTime(args.bgmStartTime);
        if let Some(x) = args.unlockParams {
            builder.add_unlockParams(x);
        }
        if let Some(x) = args.unlockType {
            builder.add_unlockType(x);
        }
        if let Some(x) = args.bgmDescUnlocked {
            builder.add_bgmDescUnlocked(x);
        }
        if let Some(x) = args.obtainApproach {
            builder.add_obtainApproach(x);
        }
        if let Some(x) = args.gameMusicId {
            builder.add_gameMusicId(x);
        }
        if let Some(x) = args.bgmName {
            builder.add_bgmName(x);
        }
        builder.add_bgmSortId(args.bgmSortId);
        if let Some(x) = args.bgmId {
            builder.add_bgmId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn bgmId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_MusicSingleData::VT_BGMID,
                None,
            )
        }
    }
    #[inline]
    pub fn bgmSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_MusicSingleData::VT_BGMSORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn bgmStartTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(
                    clz_Torappu_BuildingData_MusicSingleData::VT_BGMSTARTTIME,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn bgmName(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_MusicSingleData::VT_BGMNAME,
                None,
            )
        }
    }
    #[inline]
    pub fn gameMusicId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_MusicSingleData::VT_GAMEMUSICID,
                None,
            )
        }
    }
    #[inline]
    pub fn obtainApproach(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_MusicSingleData::VT_OBTAINAPPROACH,
                None,
            )
        }
    }
    #[inline]
    pub fn bgmDescUnlocked(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_MusicSingleData::VT_BGMDESCUNLOCKED,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockType(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_MusicSingleData::VT_UNLOCKTYPE,
                None,
            )
        }
    }
    #[inline]
    pub fn unlockParams(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_BuildingData_MusicSingleData::VT_UNLOCKPARAMS,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_MusicSingleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bgmId", Self::VT_BGMID, false)?
            .visit_field::<i32>("bgmSortId", Self::VT_BGMSORTID, false)?
            .visit_field::<i64>("bgmStartTime", Self::VT_BGMSTARTTIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bgmName", Self::VT_BGMNAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "gameMusicId",
                Self::VT_GAMEMUSICID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obtainApproach",
                Self::VT_OBTAINAPPROACH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "bgmDescUnlocked",
                Self::VT_BGMDESCUNLOCKED,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "unlockType",
                Self::VT_UNLOCKTYPE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("unlockParams", Self::VT_UNLOCKPARAMS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_MusicSingleDataArgs<'a> {
    pub bgmId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bgmSortId: i32,
    pub bgmStartTime: i64,
    pub bgmName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gameMusicId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obtainApproach: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bgmDescUnlocked: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unlockParams: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_MusicSingleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_MusicSingleDataArgs {
            bgmId: None,
            bgmSortId: 0,
            bgmStartTime: 0,
            bgmName: None,
            gameMusicId: None,
            obtainApproach: None,
            bgmDescUnlocked: None,
            unlockType: None,
            unlockParams: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_MusicSingleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_MusicSingleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_bgmId(&mut self, bgmId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_MusicSingleData::VT_BGMID,
            bgmId,
        );
    }
    #[inline]
    pub fn add_bgmSortId(&mut self, bgmSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_MusicSingleData::VT_BGMSORTID,
            bgmSortId,
            0,
        );
    }
    #[inline]
    pub fn add_bgmStartTime(&mut self, bgmStartTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_BuildingData_MusicSingleData::VT_BGMSTARTTIME,
            bgmStartTime,
            0,
        );
    }
    #[inline]
    pub fn add_bgmName(&mut self, bgmName: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_MusicSingleData::VT_BGMNAME,
            bgmName,
        );
    }
    #[inline]
    pub fn add_gameMusicId(&mut self, gameMusicId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_MusicSingleData::VT_GAMEMUSICID,
            gameMusicId,
        );
    }
    #[inline]
    pub fn add_obtainApproach(&mut self, obtainApproach: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_MusicSingleData::VT_OBTAINAPPROACH,
            obtainApproach,
        );
    }
    #[inline]
    pub fn add_bgmDescUnlocked(&mut self, bgmDescUnlocked: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_MusicSingleData::VT_BGMDESCUNLOCKED,
            bgmDescUnlocked,
        );
    }
    #[inline]
    pub fn add_unlockType(&mut self, unlockType: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_MusicSingleData::VT_UNLOCKTYPE,
            unlockType,
        );
    }
    #[inline]
    pub fn add_unlockParams(
        &mut self,
        unlockParams: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_MusicSingleData::VT_UNLOCKPARAMS,
            unlockParams,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_MusicSingleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_MusicSingleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_MusicSingleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_MusicSingleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_MusicSingleData");
        ds.field("bgmId", &self.bgmId());
        ds.field("bgmSortId", &self.bgmSortId());
        ds.field("bgmStartTime", &self.bgmStartTime());
        ds.field("bgmName", &self.bgmName());
        ds.field("gameMusicId", &self.gameMusicId());
        ds.field("obtainApproach", &self.obtainApproach());
        ds.field("bgmDescUnlocked", &self.bgmDescUnlocked());
        ds.field("unlockType", &self.unlockType());
        ds.field("unlockParams", &self.unlockParams());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_MusicSingleDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_MusicSingleData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for dict__string__clz_Torappu_BuildingData_MusicSingleData<'a> {
    type Inner = dict__string__clz_Torappu_BuildingData_MusicSingleData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_MusicSingleData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_MusicSingleData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_MusicSingleDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_MusicSingleData<'bldr>> {
        let mut builder = dict__string__clz_Torappu_BuildingData_MusicSingleDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_MusicSingleData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_MusicSingleData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_MusicSingleData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_MusicSingleData>>(
                    dict__string__clz_Torappu_BuildingData_MusicSingleData::VT_VALUE,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for dict__string__clz_Torappu_BuildingData_MusicSingleData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_MusicSingleData>>(
                "value",
                Self::VT_VALUE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_MusicSingleDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_MusicSingleData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_MusicSingleDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_MusicSingleDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_MusicSingleDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_MusicSingleDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_MusicSingleData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_MusicSingleData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_MusicSingleData>>(
                dict__string__clz_Torappu_BuildingData_MusicSingleData::VT_VALUE,
                value,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_MusicSingleDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_MusicSingleDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<dict__string__clz_Torappu_BuildingData_MusicSingleData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_MusicSingleData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_MusicSingleData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("dict__string__clz_Torappu_BuildingData_MusicSingleData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_MusicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_MusicData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_MusicData<'a> {
    type Inner = clz_Torappu_BuildingData_MusicData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_MusicData<'a> {
    pub const VT_DEFAULTMUSIC: flatbuffers::VOffsetT = 4;
    pub const VT_MUSICDATAS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_MusicData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_MusicDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_MusicData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_MusicDataBuilder::new(_fbb);
        if let Some(x) = args.musicDatas {
            builder.add_musicDatas(x);
        }
        if let Some(x) = args.defaultMusic {
            builder.add_defaultMusic(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn defaultMusic(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData_MusicData::VT_DEFAULTMUSIC,
                None,
            )
        }
    }
    #[inline]
    pub fn musicDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_BuildingData_MusicSingleData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_MusicSingleData,
                    >,
                >,
            >>(clz_Torappu_BuildingData_MusicData::VT_MUSICDATAS, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_MusicData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "defaultMusic",
                Self::VT_DEFAULTMUSIC,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    '_,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_MusicSingleData,
                    >,
                >,
            >>("musicDatas", Self::VT_MUSICDATAS, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_MusicDataArgs<'a> {
    pub defaultMusic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub musicDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_MusicSingleData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingData_MusicDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_MusicDataArgs {
            defaultMusic: None,
            musicDatas: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_MusicDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_MusicDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_defaultMusic(&mut self, defaultMusic: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_MusicData::VT_DEFAULTMUSIC,
            defaultMusic,
        );
    }
    #[inline]
    pub fn add_musicDatas(
        &mut self,
        musicDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_MusicSingleData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_MusicData::VT_MUSICDATAS,
            musicDatas,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_MusicDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_MusicDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_MusicData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_MusicData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_MusicData");
        ds.field("defaultMusic", &self.defaultMusic());
        ds.field("musicDatas", &self.musicDatas());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'a>
{
    type Inner = clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'a> {
    pub const VT_TARGETS: flatbuffers::VOffsetT = 4;
    pub const VT_SORTID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'bldr>,
    > {
        let mut builder =
            clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoBuilder::new(_fbb);
        builder.add_sortId(args.sortId);
        if let Some(x) = args.targets {
            builder.add_targets(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn targets(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(
                clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo::VT_TARGETS,
                None,
            )
        }
    }
    #[inline]
    pub fn sortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo::VT_SORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable
    for clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("targets", Self::VT_TARGETS, false)?
            .visit_field::<i32>("sortId", Self::VT_SORTID, false)?
            .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoArgs<'a> {
    pub targets: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub sortId: i32,
}
impl<'a> Default for clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoArgs {
            targets: None,
            sortId: 0,
        }
    }
}

pub struct clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_targets(
        &mut self,
        targets: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo::VT_TARGETS,
            targets,
        );
    }
    #[inline]
    pub fn add_sortId(&mut self, sortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo::VT_SORTID,
            sortId,
            0,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo");
        ds.field("targets", &self.targets());
        ds.field("sortId", &self.sortId());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'a>
{
    type Inner =
        dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'bldr>,
    > {
        let mut builder = dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo::VT_KEY, None).unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(
        &self,
    ) -> Option<clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo>>(dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo,
            >>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoArgs<'a>
{
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<
        flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'a>,
        >,
    >,
}
impl<'a> Default
    for dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoArgs<'a>
{
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoBuilder<
        'a,
        'b,
        A,
    >
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo::VT_KEY, key);
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo>>(dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo::VT_VALUE, value);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoBuilder<'a, 'b, A>{
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo::VT_KEY,"key");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug
    for dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'_>
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct(
            "dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo",
        );
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'a> {
    type Inner = clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'a> {
    pub const VT_HASEFFICIENCYSORT: flatbuffers::VOffsetT = 4;
    pub const VT_DEFAULTGROUPSORTID: flatbuffers::VOffsetT = 6;
    pub const VT_EFFICIENCYTARGETDICT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'bldr>> {
        let mut builder = clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataBuilder::new(_fbb);
        if let Some(x) = args.efficiencyTargetDict {
            builder.add_efficiencyTargetDict(x);
        }
        builder.add_defaultGroupSortId(args.defaultGroupSortId);
        builder.add_hasEfficiencySort(args.hasEfficiencySort);
        builder.finish()
    }

    #[inline]
    pub fn hasEfficiencySort(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(
                    clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData::VT_HASEFFICIENCYSORT,
                    Some(false),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn defaultGroupSortId(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData::VT_DEFAULTGROUPSORTID,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn efficiencyTargetDict(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<
                    'a,
                >,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo>>>>(clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData::VT_EFFICIENCYTARGETDICT, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<bool>("hasEfficiencySort", Self::VT_HASEFFICIENCYSORT, false)?
     .visit_field::<i32>("defaultGroupSortId", Self::VT_DEFAULTGROUPSORTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo>>>>("efficiencyTargetDict", Self::VT_EFFICIENCYTARGETDICT, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataArgs<'a> {
    pub hasEfficiencySort: bool,
    pub defaultGroupSortId: i32,
    pub efficiencyTargetDict: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'a>>>>>,
}
impl<'a> Default for clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataArgs {
            hasEfficiencySort: false,
            defaultGroupSortId: 0,
            efficiencyTargetDict: None,
        }
    }
}

pub struct clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_hasEfficiencySort(&mut self, hasEfficiencySort: bool) {
        self.fbb_.push_slot::<bool>(
            clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData::VT_HASEFFICIENCYSORT,
            hasEfficiencySort,
            false,
        );
    }
    #[inline]
    pub fn add_defaultGroupSortId(&mut self, defaultGroupSortId: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData::VT_DEFAULTGROUPSORTID,
            defaultGroupSortId,
            0,
        );
    }
    #[inline]
    pub fn add_efficiencyTargetDict(
        &mut self,
        efficiencyTargetDict: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData_buffGroupInfo<'b >>>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData::VT_EFFICIENCYTARGETDICT,
            efficiencyTargetDict,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData");
        ds.field("hasEfficiencySort", &self.hasEfficiencySort());
        ds.field("defaultGroupSortId", &self.defaultGroupSortId());
        ds.field("efficiencyTargetDict", &self.efficiencyTargetDict());
        ds.finish()
    }
}
pub enum dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a>
    for dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'a>
{
    type Inner = dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'a> {
    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'bldr>,
    > {
        let mut builder =
            dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn key(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(
                    dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData::VT_KEY,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(
        &self,
        o: &dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData,
    ) -> bool {
        self.key() < o.key()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.key();
        key.cmp(val)
    }
    #[inline]
    pub fn value(&self) -> Option<clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData,
            >>(
                dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData::VT_VALUE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable
    for dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'_>
{
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData>>("value", Self::VT_VALUE, false)?
     .finish();
        Ok(())
    }
}
pub struct dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value:
        Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'a>>>,
}
impl<'a> Default for dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataArgs {
            key: None, // required field
            value: None,
        }
    }
}

pub struct dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataBuilder<
    'a: 'b,
    'b,
    A: flatbuffers::Allocator + 'a,
> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a>
    dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataBuilder<'a, 'b, A>
{
    #[inline]
    pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData::VT_KEY,
            key,
        );
    }
    #[inline]
    pub fn add_value(
        &mut self,
        value: flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'b>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData>>(dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(
        self,
    ) -> flatbuffers::WIPOffset<
        dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'a>,
    > {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(
            o,
            dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData::VT_KEY,
            "key",
        );
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds =
            f.debug_struct("dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData");
        ds.field("key", &self.key());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum clz_Torappu_BuildingDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct clz_Torappu_BuildingData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for clz_Torappu_BuildingData<'a> {
    type Inner = clz_Torappu_BuildingData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> clz_Torappu_BuildingData<'a> {
    pub const VT_CONTROLSLOTID: flatbuffers::VOffsetT = 4;
    pub const VT_MEETINGSLOTID: flatbuffers::VOffsetT = 6;
    pub const VT_INITMAXLABOR: flatbuffers::VOffsetT = 8;
    pub const VT_LABORRECOVERTIME: flatbuffers::VOffsetT = 10;
    pub const VT_MANUFACTINPUTCAPACITY: flatbuffers::VOffsetT = 12;
    pub const VT_SHOPCOUNTERCAPACITY: flatbuffers::VOffsetT = 14;
    pub const VT_COMFORTLIMIT: flatbuffers::VOffsetT = 16;
    pub const VT_CREDITINITIATIVELIMIT: flatbuffers::VOffsetT = 18;
    pub const VT_CREDITPASSIVELIMIT: flatbuffers::VOffsetT = 20;
    pub const VT_CREDITCOMFORTFACTOR: flatbuffers::VOffsetT = 22;
    pub const VT_CREDITGUARANTEED: flatbuffers::VOffsetT = 24;
    pub const VT_CREDITCEILING: flatbuffers::VOffsetT = 26;
    pub const VT_MANUFACTUNLOCKTIPS: flatbuffers::VOffsetT = 28;
    pub const VT_SHOPUNLOCKTIPS: flatbuffers::VOffsetT = 30;
    pub const VT_MANUFACTSTATIONBUFF: flatbuffers::VOffsetT = 32;
    pub const VT_COMFORTMANPOWERRECOVERFACTOR: flatbuffers::VOffsetT = 34;
    pub const VT_MANPOWERDISPLAYFACTOR: flatbuffers::VOffsetT = 36;
    pub const VT_SHOPOUTPUTRATIO: flatbuffers::VOffsetT = 38;
    pub const VT_SHOPSTACKRATIO: flatbuffers::VOffsetT = 40;
    pub const VT_BASICFAVORPERDAY: flatbuffers::VOffsetT = 42;
    pub const VT_HUMANRESOURCELIMIT: flatbuffers::VOffsetT = 44;
    pub const VT_TIREDAPTHRESHOLD: flatbuffers::VOffsetT = 46;
    pub const VT_PROCESSEDCOUNTRATIO: flatbuffers::VOffsetT = 48;
    pub const VT_TRADINGSTRATEGYUNLOCKLEVEL: flatbuffers::VOffsetT = 50;
    pub const VT_TRADINGREDUCETIMEUNIT: flatbuffers::VOffsetT = 52;
    pub const VT_TRADINGLABORCOSTUNIT: flatbuffers::VOffsetT = 54;
    pub const VT_MANUFACTREDUCETIMEUNIT: flatbuffers::VOffsetT = 56;
    pub const VT_MANUFACTLABORCOSTUNIT: flatbuffers::VOffsetT = 58;
    pub const VT_LABORASSISTUNLOCKLEVEL: flatbuffers::VOffsetT = 60;
    pub const VT_APTOLABORUNLOCKLEVEL: flatbuffers::VOffsetT = 62;
    pub const VT_APTOLABORRATIO: flatbuffers::VOffsetT = 64;
    pub const VT_SOCIALRESOURCELIMIT: flatbuffers::VOffsetT = 66;
    pub const VT_SOCIALSLOTNUM: flatbuffers::VOffsetT = 68;
    pub const VT_FURNIDUPLICATIONLIMIT: flatbuffers::VOffsetT = 70;
    pub const VT_ASSISTFAVORREPORT: flatbuffers::VOffsetT = 72;
    pub const VT_MANUFACTMANPOWERCOSTBYNUM: flatbuffers::VOffsetT = 74;
    pub const VT_TRADINGMANPOWERCOSTBYNUM: flatbuffers::VOffsetT = 76;
    pub const VT_TRAININGBONUSMAX: flatbuffers::VOffsetT = 78;
    pub const VT_BETAREMOVETIME: flatbuffers::VOffsetT = 80;
    pub const VT_FURNIHIGHLIGHTTIME: flatbuffers::VOffsetT = 82;
    pub const VT_CANNOTVISITTOAST: flatbuffers::VOffsetT = 84;
    pub const VT_MUSICPLAYEROPENTIME: flatbuffers::VOffsetT = 86;
    pub const VT_ROOMSWITHOUTREMOVESTAFF: flatbuffers::VOffsetT = 88;
    pub const VT_PRIVATEFAVORLEVELTHRESHOLDS: flatbuffers::VOffsetT = 90;
    pub const VT_ROOMUNLOCKCONDS: flatbuffers::VOffsetT = 92;
    pub const VT_ROOMS: flatbuffers::VOffsetT = 94;
    pub const VT_LAYOUTS: flatbuffers::VOffsetT = 96;
    pub const VT_PREFABS: flatbuffers::VOffsetT = 98;
    pub const VT_CONTROLDATA: flatbuffers::VOffsetT = 100;
    pub const VT_MANUFACTDATA: flatbuffers::VOffsetT = 102;
    pub const VT_SHOPDATA: flatbuffers::VOffsetT = 104;
    pub const VT_HIREDATA: flatbuffers::VOffsetT = 106;
    pub const VT_DORMDATA: flatbuffers::VOffsetT = 108;
    pub const VT_PRIVATEROOMDATA: flatbuffers::VOffsetT = 110;
    pub const VT_MEETINGDATA: flatbuffers::VOffsetT = 112;
    pub const VT_TRADINGDATA: flatbuffers::VOffsetT = 114;
    pub const VT_WORKSHOPDATA: flatbuffers::VOffsetT = 116;
    pub const VT_TRAININGDATA: flatbuffers::VOffsetT = 118;
    pub const VT_POWERDATA: flatbuffers::VOffsetT = 120;
    pub const VT_CHARS: flatbuffers::VOffsetT = 122;
    pub const VT_BUFFS: flatbuffers::VOffsetT = 124;
    pub const VT_WORKSHOPBONUS: flatbuffers::VOffsetT = 126;
    pub const VT_CUSTOMDATA: flatbuffers::VOffsetT = 128;
    pub const VT_MANUFACTFORMULAS: flatbuffers::VOffsetT = 130;
    pub const VT_SHOPFORMULAS: flatbuffers::VOffsetT = 132;
    pub const VT_WORKSHOPFORMULAS: flatbuffers::VOffsetT = 134;
    pub const VT_CREDITFORMULA: flatbuffers::VOffsetT = 136;
    pub const VT_GOLDITEMS: flatbuffers::VOffsetT = 138;
    pub const VT_ASSISTANTUNLOCK: flatbuffers::VOffsetT = 140;
    pub const VT_WORKSHOPRARITIES: flatbuffers::VOffsetT = 142;
    pub const VT_TODOITEMSORTPRIORITYDICT: flatbuffers::VOffsetT = 144;
    pub const VT_SLOTPREQUEDATAS: flatbuffers::VOffsetT = 146;
    pub const VT_DORMITORYPREQUEDATAS: flatbuffers::VOffsetT = 148;
    pub const VT_WORKSHOPTARGETDESDICT: flatbuffers::VOffsetT = 150;
    pub const VT_TRADINGORDERDESDICT: flatbuffers::VOffsetT = 152;
    pub const VT_STATIONMANAGECONSTDATA: flatbuffers::VOffsetT = 154;
    pub const VT_STATIONMANAGEFILTERINFOS: flatbuffers::VOffsetT = 156;
    pub const VT_MUSICDATA: flatbuffers::VOffsetT = 158;
    pub const VT_EMOJIS: flatbuffers::VOffsetT = 160;
    pub const VT_CATEGORYNAMES: flatbuffers::VOffsetT = 162;
    pub const VT_BUFFSORTDATA: flatbuffers::VOffsetT = 164;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        clz_Torappu_BuildingData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args clz_Torappu_BuildingDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData<'bldr>> {
        let mut builder = clz_Torappu_BuildingDataBuilder::new(_fbb);
        builder.add_musicPlayerOpenTime(args.musicPlayerOpenTime);
        builder.add_betaRemoveTime(args.betaRemoveTime);
        builder.add_assistFavorReport(args.assistFavorReport);
        builder.add_tiredApThreshold(args.tiredApThreshold);
        if let Some(x) = args.buffSortData {
            builder.add_buffSortData(x);
        }
        if let Some(x) = args.categoryNames {
            builder.add_categoryNames(x);
        }
        if let Some(x) = args.emojis {
            builder.add_emojis(x);
        }
        if let Some(x) = args.musicData {
            builder.add_musicData(x);
        }
        if let Some(x) = args.stationManageFilterInfos {
            builder.add_stationManageFilterInfos(x);
        }
        if let Some(x) = args.stationManageConstData {
            builder.add_stationManageConstData(x);
        }
        if let Some(x) = args.tradingOrderDesDict {
            builder.add_tradingOrderDesDict(x);
        }
        if let Some(x) = args.workshopTargetDesDict {
            builder.add_workshopTargetDesDict(x);
        }
        if let Some(x) = args.dormitoryPrequeDatas {
            builder.add_dormitoryPrequeDatas(x);
        }
        if let Some(x) = args.slotPrequeDatas {
            builder.add_slotPrequeDatas(x);
        }
        if let Some(x) = args.todoItemSortPriorityDict {
            builder.add_todoItemSortPriorityDict(x);
        }
        if let Some(x) = args.workshopRarities {
            builder.add_workshopRarities(x);
        }
        if let Some(x) = args.assistantUnlock {
            builder.add_assistantUnlock(x);
        }
        if let Some(x) = args.goldItems {
            builder.add_goldItems(x);
        }
        if let Some(x) = args.creditFormula {
            builder.add_creditFormula(x);
        }
        if let Some(x) = args.workshopFormulas {
            builder.add_workshopFormulas(x);
        }
        if let Some(x) = args.shopFormulas {
            builder.add_shopFormulas(x);
        }
        if let Some(x) = args.manufactFormulas {
            builder.add_manufactFormulas(x);
        }
        if let Some(x) = args.customData {
            builder.add_customData(x);
        }
        if let Some(x) = args.workshopBonus {
            builder.add_workshopBonus(x);
        }
        if let Some(x) = args.buffs {
            builder.add_buffs(x);
        }
        if let Some(x) = args.chars {
            builder.add_chars(x);
        }
        if let Some(x) = args.powerData {
            builder.add_powerData(x);
        }
        if let Some(x) = args.trainingData {
            builder.add_trainingData(x);
        }
        if let Some(x) = args.workshopData {
            builder.add_workshopData(x);
        }
        if let Some(x) = args.tradingData {
            builder.add_tradingData(x);
        }
        if let Some(x) = args.meetingData {
            builder.add_meetingData(x);
        }
        if let Some(x) = args.privateRoomData {
            builder.add_privateRoomData(x);
        }
        if let Some(x) = args.dormData {
            builder.add_dormData(x);
        }
        if let Some(x) = args.hireData {
            builder.add_hireData(x);
        }
        if let Some(x) = args.shopData {
            builder.add_shopData(x);
        }
        if let Some(x) = args.manufactData {
            builder.add_manufactData(x);
        }
        if let Some(x) = args.controlData {
            builder.add_controlData(x);
        }
        if let Some(x) = args.prefabs {
            builder.add_prefabs(x);
        }
        if let Some(x) = args.layouts {
            builder.add_layouts(x);
        }
        if let Some(x) = args.rooms {
            builder.add_rooms(x);
        }
        if let Some(x) = args.roomUnlockConds {
            builder.add_roomUnlockConds(x);
        }
        if let Some(x) = args.privateFavorLevelThresholds {
            builder.add_privateFavorLevelThresholds(x);
        }
        if let Some(x) = args.roomsWithoutRemoveStaff {
            builder.add_roomsWithoutRemoveStaff(x);
        }
        if let Some(x) = args.canNotVisitToast {
            builder.add_canNotVisitToast(x);
        }
        builder.add_furniHighlightTime(args.furniHighlightTime);
        builder.add_trainingBonusMax(args.trainingBonusMax);
        if let Some(x) = args.tradingManpowerCostByNum {
            builder.add_tradingManpowerCostByNum(x);
        }
        if let Some(x) = args.manufactManpowerCostByNum {
            builder.add_manufactManpowerCostByNum(x);
        }
        builder.add_furniDuplicationLimit(args.furniDuplicationLimit);
        builder.add_socialSlotNum(args.socialSlotNum);
        builder.add_socialResourceLimit(args.socialResourceLimit);
        builder.add_apToLaborRatio(args.apToLaborRatio);
        builder.add_apToLaborUnlockLevel(args.apToLaborUnlockLevel);
        builder.add_laborAssistUnlockLevel(args.laborAssistUnlockLevel);
        builder.add_manufactLaborCostUnit(args.manufactLaborCostUnit);
        builder.add_manufactReduceTimeUnit(args.manufactReduceTimeUnit);
        builder.add_tradingLaborCostUnit(args.tradingLaborCostUnit);
        builder.add_tradingReduceTimeUnit(args.tradingReduceTimeUnit);
        builder.add_tradingStrategyUnlockLevel(args.tradingStrategyUnlockLevel);
        builder.add_processedCountRatio(args.processedCountRatio);
        builder.add_humanResourceLimit(args.humanResourceLimit);
        builder.add_basicFavorPerDay(args.basicFavorPerDay);
        if let Some(x) = args.shopStackRatio {
            builder.add_shopStackRatio(x);
        }
        if let Some(x) = args.shopOutputRatio {
            builder.add_shopOutputRatio(x);
        }
        builder.add_manpowerDisplayFactor(args.manpowerDisplayFactor);
        builder.add_comfortManpowerRecoverFactor(args.comfortManpowerRecoverFactor);
        builder.add_manufactStationBuff(args.manufactStationBuff);
        if let Some(x) = args.shopUnlockTips {
            builder.add_shopUnlockTips(x);
        }
        if let Some(x) = args.manufactUnlockTips {
            builder.add_manufactUnlockTips(x);
        }
        builder.add_creditCeiling(args.creditCeiling);
        builder.add_creditGuaranteed(args.creditGuaranteed);
        builder.add_creditComfortFactor(args.creditComfortFactor);
        builder.add_creditPassiveLimit(args.creditPassiveLimit);
        builder.add_creditInitiativeLimit(args.creditInitiativeLimit);
        builder.add_comfortLimit(args.comfortLimit);
        builder.add_shopCounterCapacity(args.shopCounterCapacity);
        builder.add_manufactInputCapacity(args.manufactInputCapacity);
        builder.add_laborRecoverTime(args.laborRecoverTime);
        builder.add_initMaxLabor(args.initMaxLabor);
        if let Some(x) = args.meetingSlotId {
            builder.add_meetingSlotId(x);
        }
        if let Some(x) = args.controlSlotId {
            builder.add_controlSlotId(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn controlSlotId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData::VT_CONTROLSLOTID,
                None,
            )
        }
    }
    #[inline]
    pub fn meetingSlotId(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData::VT_MEETINGSLOTID,
                None,
            )
        }
    }
    #[inline]
    pub fn initMaxLabor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_INITMAXLABOR, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn laborRecoverTime(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_LABORRECOVERTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn manufactInputCapacity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_MANUFACTINPUTCAPACITY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn shopCounterCapacity(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_SHOPCOUNTERCAPACITY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn comfortLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_COMFORTLIMIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn creditInitiativeLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_CREDITINITIATIVELIMIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn creditPassiveLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_CREDITPASSIVELIMIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn creditComfortFactor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_CREDITCOMFORTFACTOR, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn creditGuaranteed(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_CREDITGUARANTEED, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn creditCeiling(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_CREDITCEILING, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn manufactUnlockTips(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData::VT_MANUFACTUNLOCKTIPS,
                None,
            )
        }
    }
    #[inline]
    pub fn shopUnlockTips(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData::VT_SHOPUNLOCKTIPS,
                None,
            )
        }
    }
    #[inline]
    pub fn manufactStationBuff(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_BuildingData::VT_MANUFACTSTATIONBUFF, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn comfortManpowerRecoverFactor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData::VT_COMFORTMANPOWERRECOVERFACTOR,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn manpowerDisplayFactor(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_MANPOWERDISPLAYFACTOR, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn shopOutputRatio(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_BuildingData::VT_SHOPOUTPUTRATIO, None)
        }
    }
    #[inline]
    pub fn shopStackRatio(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_BuildingData::VT_SHOPSTACKRATIO, None)
        }
    }
    #[inline]
    pub fn basicFavorPerDay(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_BASICFAVORPERDAY, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn humanResourceLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_HUMANRESOURCELIMIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn tiredApThreshold(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_BuildingData::VT_TIREDAPTHRESHOLD, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn processedCountRatio(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_PROCESSEDCOUNTRATIO, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn tradingStrategyUnlockLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(
                    clz_Torappu_BuildingData::VT_TRADINGSTRATEGYUNLOCKLEVEL,
                    Some(0),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn tradingReduceTimeUnit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_TRADINGREDUCETIMEUNIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn tradingLaborCostUnit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_TRADINGLABORCOSTUNIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn manufactReduceTimeUnit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_MANUFACTREDUCETIMEUNIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn manufactLaborCostUnit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_MANUFACTLABORCOSTUNIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn laborAssistUnlockLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_LABORASSISTUNLOCKLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn apToLaborUnlockLevel(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_APTOLABORUNLOCKLEVEL, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn apToLaborRatio(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_APTOLABORRATIO, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn socialResourceLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_SOCIALRESOURCELIMIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn socialSlotNum(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_SOCIALSLOTNUM, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn furniDuplicationLimit(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_FURNIDUPLICATIONLIMIT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn assistFavorReport(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_BuildingData::VT_ASSISTFAVORREPORT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn manufactManpowerCostByNum(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_BuildingData::VT_MANUFACTMANPOWERCOSTBYNUM,
                    None,
                )
        }
    }
    #[inline]
    pub fn tradingManpowerCostByNum(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_BuildingData::VT_TRADINGMANPOWERCOSTBYNUM,
                    None,
                )
        }
    }
    #[inline]
    pub fn trainingBonusMax(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(clz_Torappu_BuildingData::VT_TRAININGBONUSMAX, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn betaRemoveTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_BuildingData::VT_BETAREMOVETIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn furniHighlightTime(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(clz_Torappu_BuildingData::VT_FURNIHIGHLIGHTTIME, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn canNotVisitToast(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                clz_Torappu_BuildingData::VT_CANNOTVISITTOAST,
                None,
            )
        }
    }
    #[inline]
    pub fn musicPlayerOpenTime(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i64>(clz_Torappu_BuildingData::VT_MUSICPLAYEROPENTIME, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn roomsWithoutRemoveStaff(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_BuildingData::VT_ROOMSWITHOUTREMOVESTAFF, None)
        }
    }
    #[inline]
    pub fn privateFavorLevelThresholds(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_BuildingData::VT_PRIVATEFAVORLEVELTHRESHOLDS,
                    None,
                )
        }
    }
    #[inline]
    pub fn roomUnlockConds(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_RoomUnlockCond<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_RoomUnlockCond,
                    >,
                >,
            >>(clz_Torappu_BuildingData::VT_ROOMUNLOCKCONDS, None)
        }
    }
    #[inline]
    pub fn rooms(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_RoomData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_RoomData>,
                >,
            >>(clz_Torappu_BuildingData::VT_ROOMS, None)
        }
    }
    #[inline]
    pub fn layouts(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_LayoutData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_LayoutData>,
                >,
            >>(clz_Torappu_BuildingData::VT_LAYOUTS, None)
        }
    }
    #[inline]
    pub fn prefabs(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_PrefabInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_PrefabInfo>,
                >,
            >>(clz_Torappu_BuildingData::VT_PREFABS, None)
        }
    }
    #[inline]
    pub fn controlData(&self) -> Option<clz_Torappu_BuildingData_ControlRoomBean<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ControlRoomBean>>(
                    clz_Torappu_BuildingData::VT_CONTROLDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn manufactData(&self) -> Option<clz_Torappu_BuildingData_ManufactRoomBean<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ManufactRoomBean>>(
                    clz_Torappu_BuildingData::VT_MANUFACTDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn shopData(
        &self,
    ) -> Option<clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_,
            >>(clz_Torappu_BuildingData::VT_SHOPDATA, None)
        }
    }
    #[inline]
    pub fn hireData(&self) -> Option<clz_Torappu_BuildingData_HireRoomBean<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_HireRoomBean>>(
                    clz_Torappu_BuildingData::VT_HIREDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn dormData(
        &self,
    ) -> Option<clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_,
            >>(clz_Torappu_BuildingData::VT_DORMDATA, None)
        }
    }
    #[inline]
    pub fn privateRoomData(
        &self,
    ) -> Option<clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_,
            >>(clz_Torappu_BuildingData::VT_PRIVATEROOMDATA, None)
        }
    }
    #[inline]
    pub fn meetingData(&self) -> Option<clz_Torappu_BuildingData_MeetingRoomBean<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_MeetingRoomBean>>(
                    clz_Torappu_BuildingData::VT_MEETINGDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn tradingData(&self) -> Option<clz_Torappu_BuildingData_TradingRoomBean<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_TradingRoomBean>>(
                    clz_Torappu_BuildingData::VT_TRADINGDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn workshopData(
        &self,
    ) -> Option<clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_,
            >>(clz_Torappu_BuildingData::VT_WORKSHOPDATA, None)
        }
    }
    #[inline]
    pub fn trainingData(&self) -> Option<clz_Torappu_BuildingData_TrainingBean<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_TrainingBean>>(
                    clz_Torappu_BuildingData::VT_TRAININGDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn powerData(&self) -> Option<clz_Torappu_BuildingData_PowerRoomBean<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_PowerRoomBean>>(
                    clz_Torappu_BuildingData::VT_POWERDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn chars(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_BuildingData_BuildingCharacter<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_BuildingCharacter,
                    >,
                >,
            >>(clz_Torappu_BuildingData::VT_CHARS, None)
        }
    }
    #[inline]
    pub fn buffs(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_BuildingBuff<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_BuildingBuff,
                    >,
                >,
            >>(clz_Torappu_BuildingData::VT_BUFFS, None)
        }
    }
    #[inline]
    pub fn workshopBonus(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string>>,
            >>(clz_Torappu_BuildingData::VT_WORKSHOPBONUS, None)
        }
    }
    #[inline]
    pub fn customData(&self) -> Option<clz_Torappu_BuildingData_CustomData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData>>(
                    clz_Torappu_BuildingData::VT_CUSTOMDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn manufactFormulas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_BuildingData_ManufactFormula<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_ManufactFormula,
                    >,
                >,
            >>(clz_Torappu_BuildingData::VT_MANUFACTFORMULAS, None)
        }
    }
    #[inline]
    pub fn shopFormulas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_ShopFormula<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_ShopFormula,
                    >,
                >,
            >>(clz_Torappu_BuildingData::VT_SHOPFORMULAS, None)
        }
    }
    #[inline]
    pub fn workshopFormulas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_BuildingData_WorkshopFormula<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_WorkshopFormula,
                    >,
                >,
            >>(clz_Torappu_BuildingData::VT_WORKSHOPFORMULAS, None)
        }
    }
    #[inline]
    pub fn creditFormula(&self) -> Option<clz_Torappu_BuildingData_CreditFormula<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CreditFormula>>(
                    clz_Torappu_BuildingData::VT_CREDITFORMULA,
                    None,
                )
        }
    }
    #[inline]
    pub fn goldItems(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_BuildingData::VT_GOLDITEMS, None)
        }
    }
    #[inline]
    pub fn assistantUnlock(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    clz_Torappu_BuildingData::VT_ASSISTANTUNLOCK,
                    None,
                )
        }
    }
    #[inline]
    pub fn workshopRarities(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopRarityInfo<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopRarityInfo>,
                >,
            >>(clz_Torappu_BuildingData::VT_WORKSHOPRARITIES, None)
        }
    }
    #[inline]
    pub fn todoItemSortPriorityDict(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int>>,
            >>(clz_Torappu_BuildingData::VT_TODOITEMSORTPRIORITYDICT, None)
        }
    }
    #[inline]
    pub fn slotPrequeDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_SlotPrequeData<'a>>,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_SlotPrequeData,
                    >,
                >,
            >>(clz_Torappu_BuildingData::VT_SLOTPREQUEDATAS, None)
        }
    }
    #[inline]
    pub fn dormitoryPrequeDatas(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_BuildingData_DormitoryPrequeData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_DormitoryPrequeData,
                    >,
                >,
            >>(clz_Torappu_BuildingData::VT_DORMITORYPREQUEDATAS, None)
        }
    }
    #[inline]
    pub fn workshopTargetDesDict(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_BuildingData::VT_WORKSHOPTARGETDESDICT, None)
        }
    }
    #[inline]
    pub fn tradingOrderDesDict(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_BuildingData::VT_TRADINGORDERDESDICT, None)
        }
    }
    #[inline]
    pub fn stationManageConstData(
        &self,
    ) -> Option<clz_Torappu_BuildingData_StationManageConstData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_StationManageConstData>>(clz_Torappu_BuildingData::VT_STATIONMANAGECONSTDATA, None)
        }
    }
    #[inline]
    pub fn stationManageFilterInfos(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__int__clz_Torappu_BuildingData_StationManageFilterInfo<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__int__clz_Torappu_BuildingData_StationManageFilterInfo,
                    >,
                >,
            >>(clz_Torappu_BuildingData::VT_STATIONMANAGEFILTERINFOS, None)
        }
    }
    #[inline]
    pub fn musicData(&self) -> Option<clz_Torappu_BuildingData_MusicData<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_MusicData>>(
                    clz_Torappu_BuildingData::VT_MUSICDATA,
                    None,
                )
        }
    }
    #[inline]
    pub fn emojis(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(clz_Torappu_BuildingData::VT_EMOJIS, None)
        }
    }
    #[inline]
    pub fn categoryNames(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string>>,
            >>(clz_Torappu_BuildingData::VT_CATEGORYNAMES, None)
        }
    }
    #[inline]
    pub fn buffSortData(
        &self,
    ) -> Option<
        flatbuffers::Vector<
            'a,
            flatbuffers::ForwardsUOffset<
                dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'a>,
            >,
        >,
    > {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<
                    'a,
                    flatbuffers::ForwardsUOffset<
                        dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData,
                    >,
                >,
            >>(clz_Torappu_BuildingData::VT_BUFFSORTDATA, None)
        }
    }
}

impl flatbuffers::Verifiable for clz_Torappu_BuildingData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("controlSlotId", Self::VT_CONTROLSLOTID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("meetingSlotId", Self::VT_MEETINGSLOTID, false)?
     .visit_field::<i32>("initMaxLabor", Self::VT_INITMAXLABOR, false)?
     .visit_field::<i32>("laborRecoverTime", Self::VT_LABORRECOVERTIME, false)?
     .visit_field::<i32>("manufactInputCapacity", Self::VT_MANUFACTINPUTCAPACITY, false)?
     .visit_field::<i32>("shopCounterCapacity", Self::VT_SHOPCOUNTERCAPACITY, false)?
     .visit_field::<i32>("comfortLimit", Self::VT_COMFORTLIMIT, false)?
     .visit_field::<i32>("creditInitiativeLimit", Self::VT_CREDITINITIATIVELIMIT, false)?
     .visit_field::<i32>("creditPassiveLimit", Self::VT_CREDITPASSIVELIMIT, false)?
     .visit_field::<i32>("creditComfortFactor", Self::VT_CREDITCOMFORTFACTOR, false)?
     .visit_field::<i32>("creditGuaranteed", Self::VT_CREDITGUARANTEED, false)?
     .visit_field::<i32>("creditCeiling", Self::VT_CREDITCEILING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("manufactUnlockTips", Self::VT_MANUFACTUNLOCKTIPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("shopUnlockTips", Self::VT_SHOPUNLOCKTIPS, false)?
     .visit_field::<f32>("manufactStationBuff", Self::VT_MANUFACTSTATIONBUFF, false)?
     .visit_field::<i32>("comfortManpowerRecoverFactor", Self::VT_COMFORTMANPOWERRECOVERFACTOR, false)?
     .visit_field::<i32>("manpowerDisplayFactor", Self::VT_MANPOWERDISPLAYFACTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>>>("shopOutputRatio", Self::VT_SHOPOUTPUTRATIO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>>>("shopStackRatio", Self::VT_SHOPSTACKRATIO, false)?
     .visit_field::<i32>("basicFavorPerDay", Self::VT_BASICFAVORPERDAY, false)?
     .visit_field::<i32>("humanResourceLimit", Self::VT_HUMANRESOURCELIMIT, false)?
     .visit_field::<i64>("tiredApThreshold", Self::VT_TIREDAPTHRESHOLD, false)?
     .visit_field::<i32>("processedCountRatio", Self::VT_PROCESSEDCOUNTRATIO, false)?
     .visit_field::<i32>("tradingStrategyUnlockLevel", Self::VT_TRADINGSTRATEGYUNLOCKLEVEL, false)?
     .visit_field::<i32>("tradingReduceTimeUnit", Self::VT_TRADINGREDUCETIMEUNIT, false)?
     .visit_field::<i32>("tradingLaborCostUnit", Self::VT_TRADINGLABORCOSTUNIT, false)?
     .visit_field::<i32>("manufactReduceTimeUnit", Self::VT_MANUFACTREDUCETIMEUNIT, false)?
     .visit_field::<i32>("manufactLaborCostUnit", Self::VT_MANUFACTLABORCOSTUNIT, false)?
     .visit_field::<i32>("laborAssistUnlockLevel", Self::VT_LABORASSISTUNLOCKLEVEL, false)?
     .visit_field::<i32>("apToLaborUnlockLevel", Self::VT_APTOLABORUNLOCKLEVEL, false)?
     .visit_field::<i32>("apToLaborRatio", Self::VT_APTOLABORRATIO, false)?
     .visit_field::<i32>("socialResourceLimit", Self::VT_SOCIALRESOURCELIMIT, false)?
     .visit_field::<i32>("socialSlotNum", Self::VT_SOCIALSLOTNUM, false)?
     .visit_field::<i32>("furniDuplicationLimit", Self::VT_FURNIDUPLICATIONLIMIT, false)?
     .visit_field::<i64>("assistFavorReport", Self::VT_ASSISTFAVORREPORT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("manufactManpowerCostByNum", Self::VT_MANUFACTMANPOWERCOSTBYNUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("tradingManpowerCostByNum", Self::VT_TRADINGMANPOWERCOSTBYNUM, false)?
     .visit_field::<i32>("trainingBonusMax", Self::VT_TRAININGBONUSMAX, false)?
     .visit_field::<i64>("betaRemoveTime", Self::VT_BETAREMOVETIME, false)?
     .visit_field::<f32>("furniHighlightTime", Self::VT_FURNIHIGHLIGHTTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("canNotVisitToast", Self::VT_CANNOTVISITTOAST, false)?
     .visit_field::<i64>("musicPlayerOpenTime", Self::VT_MUSICPLAYEROPENTIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("roomsWithoutRemoveStaff", Self::VT_ROOMSWITHOUTREMOVESTAFF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("privateFavorLevelThresholds", Self::VT_PRIVATEFAVORLEVELTHRESHOLDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_RoomUnlockCond>>>>("roomUnlockConds", Self::VT_ROOMUNLOCKCONDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_RoomData>>>>("rooms", Self::VT_ROOMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_LayoutData>>>>("layouts", Self::VT_LAYOUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_PrefabInfo>>>>("prefabs", Self::VT_PREFABS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ControlRoomBean>>("controlData", Self::VT_CONTROLDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_ManufactRoomBean>>("manufactData", Self::VT_MANUFACTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_>>("shopData", Self::VT_SHOPDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_HireRoomBean>>("hireData", Self::VT_HIREDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_>>("dormData", Self::VT_DORMDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_>>("privateRoomData", Self::VT_PRIVATEROOMDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_MeetingRoomBean>>("meetingData", Self::VT_MEETINGDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_TradingRoomBean>>("tradingData", Self::VT_TRADINGDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_>>("workshopData", Self::VT_WORKSHOPDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_TrainingBean>>("trainingData", Self::VT_TRAININGDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_PowerRoomBean>>("powerData", Self::VT_POWERDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_BuildingCharacter>>>>("chars", Self::VT_CHARS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_BuildingBuff>>>>("buffs", Self::VT_BUFFS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__list_string>>>>("workshopBonus", Self::VT_WORKSHOPBONUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CustomData>>("customData", Self::VT_CUSTOMDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_ManufactFormula>>>>("manufactFormulas", Self::VT_MANUFACTFORMULAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_ShopFormula>>>>("shopFormulas", Self::VT_SHOPFORMULAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_WorkshopFormula>>>>("workshopFormulas", Self::VT_WORKSHOPFORMULAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_CreditFormula>>("creditFormula", Self::VT_CREDITFORMULA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>>>("goldItems", Self::VT_GOLDITEMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("assistantUnlock", Self::VT_ASSISTANTUNLOCK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopRarityInfo>>>>("workshopRarities", Self::VT_WORKSHOPRARITIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__int>>>>("todoItemSortPriorityDict", Self::VT_TODOITEMSORTPRIORITYDICT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_SlotPrequeData>>>>("slotPrequeDatas", Self::VT_SLOTPREQUEDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_DormitoryPrequeData>>>>("dormitoryPrequeDatas", Self::VT_DORMITORYPREQUEDATAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>>>("workshopTargetDesDict", Self::VT_WORKSHOPTARGETDESDICT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>>>("tradingOrderDesDict", Self::VT_TRADINGORDERDESDICT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_StationManageConstData>>("stationManageConstData", Self::VT_STATIONMANAGECONSTDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__int__clz_Torappu_BuildingData_StationManageFilterInfo>>>>("stationManageFilterInfos", Self::VT_STATIONMANAGEFILTERINFOS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_MusicData>>("musicData", Self::VT_MUSICDATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("emojis", Self::VT_EMOJIS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__string>>>>("categoryNames", Self::VT_CATEGORYNAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData>>>>("buffSortData", Self::VT_BUFFSORTDATA, false)?
     .finish();
        Ok(())
    }
}
pub struct clz_Torappu_BuildingDataArgs<'a> {
    pub controlSlotId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub meetingSlotId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub initMaxLabor: i32,
    pub laborRecoverTime: i32,
    pub manufactInputCapacity: i32,
    pub shopCounterCapacity: i32,
    pub comfortLimit: i32,
    pub creditInitiativeLimit: i32,
    pub creditPassiveLimit: i32,
    pub creditComfortFactor: i32,
    pub creditGuaranteed: i32,
    pub creditCeiling: i32,
    pub manufactUnlockTips: Option<flatbuffers::WIPOffset<&'a str>>,
    pub shopUnlockTips: Option<flatbuffers::WIPOffset<&'a str>>,
    pub manufactStationBuff: f32,
    pub comfortManpowerRecoverFactor: i32,
    pub manpowerDisplayFactor: i32,
    pub shopOutputRatio: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>,
        >,
    >,
    pub shopStackRatio: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>,
        >,
    >,
    pub basicFavorPerDay: i32,
    pub humanResourceLimit: i32,
    pub tiredApThreshold: i64,
    pub processedCountRatio: i32,
    pub tradingStrategyUnlockLevel: i32,
    pub tradingReduceTimeUnit: i32,
    pub tradingLaborCostUnit: i32,
    pub manufactReduceTimeUnit: i32,
    pub manufactLaborCostUnit: i32,
    pub laborAssistUnlockLevel: i32,
    pub apToLaborUnlockLevel: i32,
    pub apToLaborRatio: i32,
    pub socialResourceLimit: i32,
    pub socialSlotNum: i32,
    pub furniDuplicationLimit: i32,
    pub assistFavorReport: i64,
    pub manufactManpowerCostByNum: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub tradingManpowerCostByNum: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub trainingBonusMax: i32,
    pub betaRemoveTime: i64,
    pub furniHighlightTime: f32,
    pub canNotVisitToast: Option<flatbuffers::WIPOffset<&'a str>>,
    pub musicPlayerOpenTime: i64,
    pub roomsWithoutRemoveStaff: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub privateFavorLevelThresholds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub roomUnlockConds: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_RoomUnlockCond<'a>,
                >,
            >,
        >,
    >,
    pub rooms: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_RoomData<'a>>,
            >,
        >,
    >,
    pub layouts: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_LayoutData<'a>>,
            >,
        >,
    >,
    pub prefabs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_PrefabInfo<'a>>,
            >,
        >,
    >,
    pub controlData: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_ControlRoomBean<'a>>>,
    pub manufactData: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactRoomBean<'a>>>,
    pub shopData: Option<
        flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_<'a>,
        >,
    >,
    pub hireData: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_HireRoomBean<'a>>>,
    pub dormData: Option<
        flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_<'a>,
        >,
    >,
    pub privateRoomData: Option<
        flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_<'a>,
        >,
    >,
    pub meetingData: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_MeetingRoomBean<'a>>>,
    pub tradingData: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_TradingRoomBean<'a>>>,
    pub workshopData: Option<
        flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_<'a>,
        >,
    >,
    pub trainingData: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_TrainingBean<'a>>>,
    pub powerData: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_PowerRoomBean<'a>>>,
    pub chars: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_BuildingCharacter<'a>,
                >,
            >,
        >,
    >,
    pub buffs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_BuildingBuff<'a>,
                >,
            >,
        >,
    >,
    pub workshopBonus: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__list_string<'a>>>,
        >,
    >,
    pub customData: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData<'a>>>,
    pub manufactFormulas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_ManufactFormula<'a>,
                >,
            >,
        >,
    >,
    pub shopFormulas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_ShopFormula<'a>,
                >,
            >,
        >,
    >,
    pub workshopFormulas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_WorkshopFormula<'a>,
                >,
            >,
        >,
    >,
    pub creditFormula: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_CreditFormula<'a>>>,
    pub goldItems: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>,
        >,
    >,
    pub assistantUnlock: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub workshopRarities: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopRarityInfo<'a>>,
            >,
        >,
    >,
    pub todoItemSortPriorityDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__int<'a>>>,
        >,
    >,
    pub slotPrequeDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_SlotPrequeData<'a>,
                >,
            >,
        >,
    >,
    pub dormitoryPrequeDatas: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_DormitoryPrequeData<'a>,
                >,
            >,
        >,
    >,
    pub workshopTargetDesDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
    pub tradingOrderDesDict: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
    pub stationManageConstData:
        Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_StationManageConstData<'a>>>,
    pub stationManageFilterInfos: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_BuildingData_StationManageFilterInfo<'a>,
                >,
            >,
        >,
    >,
    pub musicData: Option<flatbuffers::WIPOffset<clz_Torappu_BuildingData_MusicData<'a>>>,
    pub emojis: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub categoryNames: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<dict__string__string<'a>>>,
        >,
    >,
    pub buffSortData: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'a,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'a>,
                >,
            >,
        >,
    >,
}
impl<'a> Default for clz_Torappu_BuildingDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        clz_Torappu_BuildingDataArgs {
            controlSlotId: None,
            meetingSlotId: None,
            initMaxLabor: 0,
            laborRecoverTime: 0,
            manufactInputCapacity: 0,
            shopCounterCapacity: 0,
            comfortLimit: 0,
            creditInitiativeLimit: 0,
            creditPassiveLimit: 0,
            creditComfortFactor: 0,
            creditGuaranteed: 0,
            creditCeiling: 0,
            manufactUnlockTips: None,
            shopUnlockTips: None,
            manufactStationBuff: 0.0,
            comfortManpowerRecoverFactor: 0,
            manpowerDisplayFactor: 0,
            shopOutputRatio: None,
            shopStackRatio: None,
            basicFavorPerDay: 0,
            humanResourceLimit: 0,
            tiredApThreshold: 0,
            processedCountRatio: 0,
            tradingStrategyUnlockLevel: 0,
            tradingReduceTimeUnit: 0,
            tradingLaborCostUnit: 0,
            manufactReduceTimeUnit: 0,
            manufactLaborCostUnit: 0,
            laborAssistUnlockLevel: 0,
            apToLaborUnlockLevel: 0,
            apToLaborRatio: 0,
            socialResourceLimit: 0,
            socialSlotNum: 0,
            furniDuplicationLimit: 0,
            assistFavorReport: 0,
            manufactManpowerCostByNum: None,
            tradingManpowerCostByNum: None,
            trainingBonusMax: 0,
            betaRemoveTime: 0,
            furniHighlightTime: 0.0,
            canNotVisitToast: None,
            musicPlayerOpenTime: 0,
            roomsWithoutRemoveStaff: None,
            privateFavorLevelThresholds: None,
            roomUnlockConds: None,
            rooms: None,
            layouts: None,
            prefabs: None,
            controlData: None,
            manufactData: None,
            shopData: None,
            hireData: None,
            dormData: None,
            privateRoomData: None,
            meetingData: None,
            tradingData: None,
            workshopData: None,
            trainingData: None,
            powerData: None,
            chars: None,
            buffs: None,
            workshopBonus: None,
            customData: None,
            manufactFormulas: None,
            shopFormulas: None,
            workshopFormulas: None,
            creditFormula: None,
            goldItems: None,
            assistantUnlock: None,
            workshopRarities: None,
            todoItemSortPriorityDict: None,
            slotPrequeDatas: None,
            dormitoryPrequeDatas: None,
            workshopTargetDesDict: None,
            tradingOrderDesDict: None,
            stationManageConstData: None,
            stationManageFilterInfos: None,
            musicData: None,
            emojis: None,
            categoryNames: None,
            buffSortData: None,
        }
    }
}

pub struct clz_Torappu_BuildingDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> clz_Torappu_BuildingDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_controlSlotId(&mut self, controlSlotId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_CONTROLSLOTID,
            controlSlotId,
        );
    }
    #[inline]
    pub fn add_meetingSlotId(&mut self, meetingSlotId: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_MEETINGSLOTID,
            meetingSlotId,
        );
    }
    #[inline]
    pub fn add_initMaxLabor(&mut self, initMaxLabor: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_BuildingData::VT_INITMAXLABOR, initMaxLabor, 0);
    }
    #[inline]
    pub fn add_laborRecoverTime(&mut self, laborRecoverTime: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_LABORRECOVERTIME,
            laborRecoverTime,
            0,
        );
    }
    #[inline]
    pub fn add_manufactInputCapacity(&mut self, manufactInputCapacity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_MANUFACTINPUTCAPACITY,
            manufactInputCapacity,
            0,
        );
    }
    #[inline]
    pub fn add_shopCounterCapacity(&mut self, shopCounterCapacity: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_SHOPCOUNTERCAPACITY,
            shopCounterCapacity,
            0,
        );
    }
    #[inline]
    pub fn add_comfortLimit(&mut self, comfortLimit: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_BuildingData::VT_COMFORTLIMIT, comfortLimit, 0);
    }
    #[inline]
    pub fn add_creditInitiativeLimit(&mut self, creditInitiativeLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_CREDITINITIATIVELIMIT,
            creditInitiativeLimit,
            0,
        );
    }
    #[inline]
    pub fn add_creditPassiveLimit(&mut self, creditPassiveLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_CREDITPASSIVELIMIT,
            creditPassiveLimit,
            0,
        );
    }
    #[inline]
    pub fn add_creditComfortFactor(&mut self, creditComfortFactor: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_CREDITCOMFORTFACTOR,
            creditComfortFactor,
            0,
        );
    }
    #[inline]
    pub fn add_creditGuaranteed(&mut self, creditGuaranteed: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_CREDITGUARANTEED,
            creditGuaranteed,
            0,
        );
    }
    #[inline]
    pub fn add_creditCeiling(&mut self, creditCeiling: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_BuildingData::VT_CREDITCEILING, creditCeiling, 0);
    }
    #[inline]
    pub fn add_manufactUnlockTips(&mut self, manufactUnlockTips: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_MANUFACTUNLOCKTIPS,
            manufactUnlockTips,
        );
    }
    #[inline]
    pub fn add_shopUnlockTips(&mut self, shopUnlockTips: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_SHOPUNLOCKTIPS,
            shopUnlockTips,
        );
    }
    #[inline]
    pub fn add_manufactStationBuff(&mut self, manufactStationBuff: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_BuildingData::VT_MANUFACTSTATIONBUFF,
            manufactStationBuff,
            0.0,
        );
    }
    #[inline]
    pub fn add_comfortManpowerRecoverFactor(&mut self, comfortManpowerRecoverFactor: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_COMFORTMANPOWERRECOVERFACTOR,
            comfortManpowerRecoverFactor,
            0,
        );
    }
    #[inline]
    pub fn add_manpowerDisplayFactor(&mut self, manpowerDisplayFactor: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_MANPOWERDISPLAYFACTOR,
            manpowerDisplayFactor,
            0,
        );
    }
    #[inline]
    pub fn add_shopOutputRatio(
        &mut self,
        shopOutputRatio: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_SHOPOUTPUTRATIO,
            shopOutputRatio,
        );
    }
    #[inline]
    pub fn add_shopStackRatio(
        &mut self,
        shopStackRatio: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_SHOPSTACKRATIO,
            shopStackRatio,
        );
    }
    #[inline]
    pub fn add_basicFavorPerDay(&mut self, basicFavorPerDay: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_BASICFAVORPERDAY,
            basicFavorPerDay,
            0,
        );
    }
    #[inline]
    pub fn add_humanResourceLimit(&mut self, humanResourceLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_HUMANRESOURCELIMIT,
            humanResourceLimit,
            0,
        );
    }
    #[inline]
    pub fn add_tiredApThreshold(&mut self, tiredApThreshold: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_BuildingData::VT_TIREDAPTHRESHOLD,
            tiredApThreshold,
            0,
        );
    }
    #[inline]
    pub fn add_processedCountRatio(&mut self, processedCountRatio: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_PROCESSEDCOUNTRATIO,
            processedCountRatio,
            0,
        );
    }
    #[inline]
    pub fn add_tradingStrategyUnlockLevel(&mut self, tradingStrategyUnlockLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_TRADINGSTRATEGYUNLOCKLEVEL,
            tradingStrategyUnlockLevel,
            0,
        );
    }
    #[inline]
    pub fn add_tradingReduceTimeUnit(&mut self, tradingReduceTimeUnit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_TRADINGREDUCETIMEUNIT,
            tradingReduceTimeUnit,
            0,
        );
    }
    #[inline]
    pub fn add_tradingLaborCostUnit(&mut self, tradingLaborCostUnit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_TRADINGLABORCOSTUNIT,
            tradingLaborCostUnit,
            0,
        );
    }
    #[inline]
    pub fn add_manufactReduceTimeUnit(&mut self, manufactReduceTimeUnit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_MANUFACTREDUCETIMEUNIT,
            manufactReduceTimeUnit,
            0,
        );
    }
    #[inline]
    pub fn add_manufactLaborCostUnit(&mut self, manufactLaborCostUnit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_MANUFACTLABORCOSTUNIT,
            manufactLaborCostUnit,
            0,
        );
    }
    #[inline]
    pub fn add_laborAssistUnlockLevel(&mut self, laborAssistUnlockLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_LABORASSISTUNLOCKLEVEL,
            laborAssistUnlockLevel,
            0,
        );
    }
    #[inline]
    pub fn add_apToLaborUnlockLevel(&mut self, apToLaborUnlockLevel: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_APTOLABORUNLOCKLEVEL,
            apToLaborUnlockLevel,
            0,
        );
    }
    #[inline]
    pub fn add_apToLaborRatio(&mut self, apToLaborRatio: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_APTOLABORRATIO,
            apToLaborRatio,
            0,
        );
    }
    #[inline]
    pub fn add_socialResourceLimit(&mut self, socialResourceLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_SOCIALRESOURCELIMIT,
            socialResourceLimit,
            0,
        );
    }
    #[inline]
    pub fn add_socialSlotNum(&mut self, socialSlotNum: i32) {
        self.fbb_
            .push_slot::<i32>(clz_Torappu_BuildingData::VT_SOCIALSLOTNUM, socialSlotNum, 0);
    }
    #[inline]
    pub fn add_furniDuplicationLimit(&mut self, furniDuplicationLimit: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_FURNIDUPLICATIONLIMIT,
            furniDuplicationLimit,
            0,
        );
    }
    #[inline]
    pub fn add_assistFavorReport(&mut self, assistFavorReport: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_BuildingData::VT_ASSISTFAVORREPORT,
            assistFavorReport,
            0,
        );
    }
    #[inline]
    pub fn add_manufactManpowerCostByNum(
        &mut self,
        manufactManpowerCostByNum: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_MANUFACTMANPOWERCOSTBYNUM,
            manufactManpowerCostByNum,
        );
    }
    #[inline]
    pub fn add_tradingManpowerCostByNum(
        &mut self,
        tradingManpowerCostByNum: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_TRADINGMANPOWERCOSTBYNUM,
            tradingManpowerCostByNum,
        );
    }
    #[inline]
    pub fn add_trainingBonusMax(&mut self, trainingBonusMax: i32) {
        self.fbb_.push_slot::<i32>(
            clz_Torappu_BuildingData::VT_TRAININGBONUSMAX,
            trainingBonusMax,
            0,
        );
    }
    #[inline]
    pub fn add_betaRemoveTime(&mut self, betaRemoveTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_BuildingData::VT_BETAREMOVETIME,
            betaRemoveTime,
            0,
        );
    }
    #[inline]
    pub fn add_furniHighlightTime(&mut self, furniHighlightTime: f32) {
        self.fbb_.push_slot::<f32>(
            clz_Torappu_BuildingData::VT_FURNIHIGHLIGHTTIME,
            furniHighlightTime,
            0.0,
        );
    }
    #[inline]
    pub fn add_canNotVisitToast(&mut self, canNotVisitToast: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_CANNOTVISITTOAST,
            canNotVisitToast,
        );
    }
    #[inline]
    pub fn add_musicPlayerOpenTime(&mut self, musicPlayerOpenTime: i64) {
        self.fbb_.push_slot::<i64>(
            clz_Torappu_BuildingData::VT_MUSICPLAYEROPENTIME,
            musicPlayerOpenTime,
            0,
        );
    }
    #[inline]
    pub fn add_roomsWithoutRemoveStaff(
        &mut self,
        roomsWithoutRemoveStaff: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_ROOMSWITHOUTREMOVESTAFF,
            roomsWithoutRemoveStaff,
        );
    }
    #[inline]
    pub fn add_privateFavorLevelThresholds(
        &mut self,
        privateFavorLevelThresholds: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_PRIVATEFAVORLEVELTHRESHOLDS,
            privateFavorLevelThresholds,
        );
    }
    #[inline]
    pub fn add_roomUnlockConds(
        &mut self,
        roomUnlockConds: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_RoomUnlockCond<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_ROOMUNLOCKCONDS,
            roomUnlockConds,
        );
    }
    #[inline]
    pub fn add_rooms(
        &mut self,
        rooms: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_RoomData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_ROOMS,
            rooms,
        );
    }
    #[inline]
    pub fn add_layouts(
        &mut self,
        layouts: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_LayoutData<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_LAYOUTS,
            layouts,
        );
    }
    #[inline]
    pub fn add_prefabs(
        &mut self,
        prefabs: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<dict__string__clz_Torappu_BuildingData_PrefabInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_PREFABS,
            prefabs,
        );
    }
    #[inline]
    pub fn add_controlData(
        &mut self,
        controlData: flatbuffers::WIPOffset<clz_Torappu_BuildingData_ControlRoomBean<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_ControlRoomBean>>(
                clz_Torappu_BuildingData::VT_CONTROLDATA,
                controlData,
            );
    }
    #[inline]
    pub fn add_manufactData(
        &mut self,
        manufactData: flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactRoomBean<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_ManufactRoomBean>>(
                clz_Torappu_BuildingData::VT_MANUFACTDATA,
                manufactData,
            );
    }
    #[inline]
    pub fn add_shopData(
        &mut self,
        shopData: flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_ShopPhase_,
        >>(clz_Torappu_BuildingData::VT_SHOPDATA, shopData);
    }
    #[inline]
    pub fn add_hireData(
        &mut self,
        hireData: flatbuffers::WIPOffset<clz_Torappu_BuildingData_HireRoomBean<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_HireRoomBean>>(
                clz_Torappu_BuildingData::VT_HIREDATA,
                hireData,
            );
    }
    #[inline]
    pub fn add_dormData(
        &mut self,
        dormData: flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_DormPhase_,
        >>(clz_Torappu_BuildingData::VT_DORMDATA, dormData);
    }
    #[inline]
    pub fn add_privateRoomData(
        &mut self,
        privateRoomData: flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_PrivatePhase_,
        >>(
            clz_Torappu_BuildingData::VT_PRIVATEROOMDATA,
            privateRoomData,
        );
    }
    #[inline]
    pub fn add_meetingData(
        &mut self,
        meetingData: flatbuffers::WIPOffset<clz_Torappu_BuildingData_MeetingRoomBean<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_MeetingRoomBean>>(
                clz_Torappu_BuildingData::VT_MEETINGDATA,
                meetingData,
            );
    }
    #[inline]
    pub fn add_tradingData(
        &mut self,
        tradingData: flatbuffers::WIPOffset<clz_Torappu_BuildingData_TradingRoomBean<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_TradingRoomBean>>(
                clz_Torappu_BuildingData::VT_TRADINGDATA,
                tradingData,
            );
    }
    #[inline]
    pub fn add_workshopData(
        &mut self,
        workshopData: flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_RoomBean_1_Torappu_BuildingData_WorkshopPhase_,
        >>(clz_Torappu_BuildingData::VT_WORKSHOPDATA, workshopData);
    }
    #[inline]
    pub fn add_trainingData(
        &mut self,
        trainingData: flatbuffers::WIPOffset<clz_Torappu_BuildingData_TrainingBean<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_TrainingBean>>(
                clz_Torappu_BuildingData::VT_TRAININGDATA,
                trainingData,
            );
    }
    #[inline]
    pub fn add_powerData(
        &mut self,
        powerData: flatbuffers::WIPOffset<clz_Torappu_BuildingData_PowerRoomBean<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_PowerRoomBean>>(
                clz_Torappu_BuildingData::VT_POWERDATA,
                powerData,
            );
    }
    #[inline]
    pub fn add_chars(
        &mut self,
        chars: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_BuildingCharacter<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_CHARS,
            chars,
        );
    }
    #[inline]
    pub fn add_buffs(
        &mut self,
        buffs: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_BuildingBuff<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_BUFFS,
            buffs,
        );
    }
    #[inline]
    pub fn add_workshopBonus(
        &mut self,
        workshopBonus: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__list_string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_WORKSHOPBONUS,
            workshopBonus,
        );
    }
    #[inline]
    pub fn add_customData(
        &mut self,
        customData: flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_CustomData>>(
                clz_Torappu_BuildingData::VT_CUSTOMDATA,
                customData,
            );
    }
    #[inline]
    pub fn add_manufactFormulas(
        &mut self,
        manufactFormulas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_ManufactFormula<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_MANUFACTFORMULAS,
            manufactFormulas,
        );
    }
    #[inline]
    pub fn add_shopFormulas(
        &mut self,
        shopFormulas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_ShopFormula<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_SHOPFORMULAS,
            shopFormulas,
        );
    }
    #[inline]
    pub fn add_workshopFormulas(
        &mut self,
        workshopFormulas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_WorkshopFormula<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_WORKSHOPFORMULAS,
            workshopFormulas,
        );
    }
    #[inline]
    pub fn add_creditFormula(
        &mut self,
        creditFormula: flatbuffers::WIPOffset<clz_Torappu_BuildingData_CreditFormula<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_CreditFormula>>(
                clz_Torappu_BuildingData::VT_CREDITFORMULA,
                creditFormula,
            );
    }
    #[inline]
    pub fn add_goldItems(
        &mut self,
        goldItems: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_GOLDITEMS,
            goldItems,
        );
    }
    #[inline]
    pub fn add_assistantUnlock(
        &mut self,
        assistantUnlock: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_ASSISTANTUNLOCK,
            assistantUnlock,
        );
    }
    #[inline]
    pub fn add_workshopRarities(
        &mut self,
        workshopRarities: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<clz_Torappu_BuildingData_WorkshopRarityInfo<'b>>,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_WORKSHOPRARITIES,
            workshopRarities,
        );
    }
    #[inline]
    pub fn add_todoItemSortPriorityDict(
        &mut self,
        todoItemSortPriorityDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__int<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_TODOITEMSORTPRIORITYDICT,
            todoItemSortPriorityDict,
        );
    }
    #[inline]
    pub fn add_slotPrequeDatas(
        &mut self,
        slotPrequeDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_SlotPrequeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_SLOTPREQUEDATAS,
            slotPrequeDatas,
        );
    }
    #[inline]
    pub fn add_dormitoryPrequeDatas(
        &mut self,
        dormitoryPrequeDatas: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_DormitoryPrequeData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_DORMITORYPREQUEDATAS,
            dormitoryPrequeDatas,
        );
    }
    #[inline]
    pub fn add_workshopTargetDesDict(
        &mut self,
        workshopTargetDesDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_WORKSHOPTARGETDESDICT,
            workshopTargetDesDict,
        );
    }
    #[inline]
    pub fn add_tradingOrderDesDict(
        &mut self,
        tradingOrderDesDict: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_TRADINGORDERDESDICT,
            tradingOrderDesDict,
        );
    }
    #[inline]
    pub fn add_stationManageConstData(
        &mut self,
        stationManageConstData: flatbuffers::WIPOffset<
            clz_Torappu_BuildingData_StationManageConstData<'b>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_StationManageConstData>>(clz_Torappu_BuildingData::VT_STATIONMANAGECONSTDATA, stationManageConstData);
    }
    #[inline]
    pub fn add_stationManageFilterInfos(
        &mut self,
        stationManageFilterInfos: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__int__clz_Torappu_BuildingData_StationManageFilterInfo<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_STATIONMANAGEFILTERINFOS,
            stationManageFilterInfos,
        );
    }
    #[inline]
    pub fn add_musicData(
        &mut self,
        musicData: flatbuffers::WIPOffset<clz_Torappu_BuildingData_MusicData<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<clz_Torappu_BuildingData_MusicData>>(
                clz_Torappu_BuildingData::VT_MUSICDATA,
                musicData,
            );
    }
    #[inline]
    pub fn add_emojis(
        &mut self,
        emojis: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_EMOJIS,
            emojis,
        );
    }
    #[inline]
    pub fn add_categoryNames(
        &mut self,
        categoryNames: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<dict__string__string<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_CATEGORYNAMES,
            categoryNames,
        );
    }
    #[inline]
    pub fn add_buffSortData(
        &mut self,
        buffSortData: flatbuffers::WIPOffset<
            flatbuffers::Vector<
                'b,
                flatbuffers::ForwardsUOffset<
                    dict__string__clz_Torappu_BuildingData_BuildingRoomTypeBuffSortData<'b>,
                >,
            >,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            clz_Torappu_BuildingData::VT_BUFFSORTDATA,
            buffSortData,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> clz_Torappu_BuildingDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        clz_Torappu_BuildingDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<clz_Torappu_BuildingData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for clz_Torappu_BuildingData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("clz_Torappu_BuildingData");
        ds.field("controlSlotId", &self.controlSlotId());
        ds.field("meetingSlotId", &self.meetingSlotId());
        ds.field("initMaxLabor", &self.initMaxLabor());
        ds.field("laborRecoverTime", &self.laborRecoverTime());
        ds.field("manufactInputCapacity", &self.manufactInputCapacity());
        ds.field("shopCounterCapacity", &self.shopCounterCapacity());
        ds.field("comfortLimit", &self.comfortLimit());
        ds.field("creditInitiativeLimit", &self.creditInitiativeLimit());
        ds.field("creditPassiveLimit", &self.creditPassiveLimit());
        ds.field("creditComfortFactor", &self.creditComfortFactor());
        ds.field("creditGuaranteed", &self.creditGuaranteed());
        ds.field("creditCeiling", &self.creditCeiling());
        ds.field("manufactUnlockTips", &self.manufactUnlockTips());
        ds.field("shopUnlockTips", &self.shopUnlockTips());
        ds.field("manufactStationBuff", &self.manufactStationBuff());
        ds.field(
            "comfortManpowerRecoverFactor",
            &self.comfortManpowerRecoverFactor(),
        );
        ds.field("manpowerDisplayFactor", &self.manpowerDisplayFactor());
        ds.field("shopOutputRatio", &self.shopOutputRatio());
        ds.field("shopStackRatio", &self.shopStackRatio());
        ds.field("basicFavorPerDay", &self.basicFavorPerDay());
        ds.field("humanResourceLimit", &self.humanResourceLimit());
        ds.field("tiredApThreshold", &self.tiredApThreshold());
        ds.field("processedCountRatio", &self.processedCountRatio());
        ds.field(
            "tradingStrategyUnlockLevel",
            &self.tradingStrategyUnlockLevel(),
        );
        ds.field("tradingReduceTimeUnit", &self.tradingReduceTimeUnit());
        ds.field("tradingLaborCostUnit", &self.tradingLaborCostUnit());
        ds.field("manufactReduceTimeUnit", &self.manufactReduceTimeUnit());
        ds.field("manufactLaborCostUnit", &self.manufactLaborCostUnit());
        ds.field("laborAssistUnlockLevel", &self.laborAssistUnlockLevel());
        ds.field("apToLaborUnlockLevel", &self.apToLaborUnlockLevel());
        ds.field("apToLaborRatio", &self.apToLaborRatio());
        ds.field("socialResourceLimit", &self.socialResourceLimit());
        ds.field("socialSlotNum", &self.socialSlotNum());
        ds.field("furniDuplicationLimit", &self.furniDuplicationLimit());
        ds.field("assistFavorReport", &self.assistFavorReport());
        ds.field(
            "manufactManpowerCostByNum",
            &self.manufactManpowerCostByNum(),
        );
        ds.field("tradingManpowerCostByNum", &self.tradingManpowerCostByNum());
        ds.field("trainingBonusMax", &self.trainingBonusMax());
        ds.field("betaRemoveTime", &self.betaRemoveTime());
        ds.field("furniHighlightTime", &self.furniHighlightTime());
        ds.field("canNotVisitToast", &self.canNotVisitToast());
        ds.field("musicPlayerOpenTime", &self.musicPlayerOpenTime());
        ds.field("roomsWithoutRemoveStaff", &self.roomsWithoutRemoveStaff());
        ds.field(
            "privateFavorLevelThresholds",
            &self.privateFavorLevelThresholds(),
        );
        ds.field("roomUnlockConds", &self.roomUnlockConds());
        ds.field("rooms", &self.rooms());
        ds.field("layouts", &self.layouts());
        ds.field("prefabs", &self.prefabs());
        ds.field("controlData", &self.controlData());
        ds.field("manufactData", &self.manufactData());
        ds.field("shopData", &self.shopData());
        ds.field("hireData", &self.hireData());
        ds.field("dormData", &self.dormData());
        ds.field("privateRoomData", &self.privateRoomData());
        ds.field("meetingData", &self.meetingData());
        ds.field("tradingData", &self.tradingData());
        ds.field("workshopData", &self.workshopData());
        ds.field("trainingData", &self.trainingData());
        ds.field("powerData", &self.powerData());
        ds.field("chars", &self.chars());
        ds.field("buffs", &self.buffs());
        ds.field("workshopBonus", &self.workshopBonus());
        ds.field("customData", &self.customData());
        ds.field("manufactFormulas", &self.manufactFormulas());
        ds.field("shopFormulas", &self.shopFormulas());
        ds.field("workshopFormulas", &self.workshopFormulas());
        ds.field("creditFormula", &self.creditFormula());
        ds.field("goldItems", &self.goldItems());
        ds.field("assistantUnlock", &self.assistantUnlock());
        ds.field("workshopRarities", &self.workshopRarities());
        ds.field("todoItemSortPriorityDict", &self.todoItemSortPriorityDict());
        ds.field("slotPrequeDatas", &self.slotPrequeDatas());
        ds.field("dormitoryPrequeDatas", &self.dormitoryPrequeDatas());
        ds.field("workshopTargetDesDict", &self.workshopTargetDesDict());
        ds.field("tradingOrderDesDict", &self.tradingOrderDesDict());
        ds.field("stationManageConstData", &self.stationManageConstData());
        ds.field("stationManageFilterInfos", &self.stationManageFilterInfos());
        ds.field("musicData", &self.musicData());
        ds.field("emojis", &self.emojis());
        ds.field("categoryNames", &self.categoryNames());
        ds.field("buffSortData", &self.buffSortData());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `clz_Torappu_BuildingData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_building_data_unchecked`.
pub fn root_as_clz_torappu_building_data(
    buf: &[u8],
) -> Result<clz_Torappu_BuildingData, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<clz_Torappu_BuildingData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `clz_Torappu_BuildingData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_clz_torappu_building_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_building_data(
    buf: &[u8],
) -> Result<clz_Torappu_BuildingData, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<clz_Torappu_BuildingData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `clz_Torappu_BuildingData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_building_data_unchecked`.
pub fn root_as_clz_torappu_building_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_BuildingData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<clz_Torappu_BuildingData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `clz_Torappu_BuildingData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_clz_torappu_building_data_unchecked`.
pub fn size_prefixed_root_as_clz_torappu_building_data_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<clz_Torappu_BuildingData<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<clz_Torappu_BuildingData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a clz_Torappu_BuildingData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `clz_Torappu_BuildingData`.
pub unsafe fn root_as_clz_torappu_building_data_unchecked(buf: &[u8]) -> clz_Torappu_BuildingData {
    flatbuffers::root_unchecked::<clz_Torappu_BuildingData>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed clz_Torappu_BuildingData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `clz_Torappu_BuildingData`.
pub unsafe fn size_prefixed_root_as_clz_torappu_building_data_unchecked(
    buf: &[u8],
) -> clz_Torappu_BuildingData {
    flatbuffers::size_prefixed_root_unchecked::<clz_Torappu_BuildingData>(buf)
}
#[inline]
pub fn finish_clz_torappu_building_data_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_BuildingData<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_clz_torappu_building_data_buffer<
    'a,
    'b,
    A: flatbuffers::Allocator + 'a,
>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<clz_Torappu_BuildingData<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
