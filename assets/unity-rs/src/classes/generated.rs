//! Generated Unity class definitions
//!
//! This file is auto-generated by ClassesGenerator.
//! Do not edit manually - changes will be overwritten.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use crate::classes::object::{ObjectInfo, ObjectReaderTrait};
use crate::classes::pptr::PPtrData;
use crate::math::*;

// Type alias: In Python, Object is used in PPtr[Object]
// In Rust, we alias ObjectInfo as Object for the same usage
pub type Object = ObjectInfo;

/// Macro to implement the Object trait for generated structs
/// This provides the same functionality as Python's Object inheritance
macro_rules! impl_object {
    ($struct_name:ident) => {
        impl crate::classes::object::Object for $struct_name {
            fn object_reader(&self) -> Option<&dyn ObjectReaderTrait> {
                self.object_reader
                    .as_ref()
                    .map(|b| &**b as &dyn ObjectReaderTrait)
            }

            fn set_object_reader(&mut self, reader: Box<dyn ObjectReaderTrait>) {
                self.object_reader = Some(reader);
            }

            fn type_name(&self) -> &str {
                stringify!($struct_name)
            }

            fn as_any(&self) -> &dyn std::any::Any {
                self
            }

            fn to_json_value(&self) -> serde_json::Value {
                serde_json::to_value(self).unwrap_or_else(|_| serde_json::json!({}))
            }
        }
    };
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnnotationManager {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CurrentPreset_m_AnnotationList: Option<Vec<Annotation>>,
    pub m_FadeGizmoSize: Option<f32>,
    pub m_FadeGizmos: Option<bool>,
    pub m_IconSize: Option<f32>,
    pub m_RecentlyChanged: Option<Vec<Annotation>>,
    pub m_ShowGrid: Option<bool>,
    pub m_ShowSelectionOutline: Option<bool>,
    pub m_ShowSelectionWire: Option<bool>,
    pub m_Use3dGizmos: Option<bool>,
    pub m_WorldIconSize: Option<f32>,
}

impl_object!(AnnotationManager);

impl Clone for AnnotationManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CurrentPreset_m_AnnotationList: self.m_CurrentPreset_m_AnnotationList.clone(),
            m_FadeGizmoSize: self.m_FadeGizmoSize.clone(),
            m_FadeGizmos: self.m_FadeGizmos.clone(),
            m_IconSize: self.m_IconSize.clone(),
            m_RecentlyChanged: self.m_RecentlyChanged.clone(),
            m_ShowGrid: self.m_ShowGrid.clone(),
            m_ShowSelectionOutline: self.m_ShowSelectionOutline.clone(),
            m_ShowSelectionWire: self.m_ShowSelectionWire.clone(),
            m_Use3dGizmos: self.m_Use3dGizmos.clone(),
            m_WorldIconSize: self.m_WorldIconSize.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetDatabaseV1 {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleNames: Option<Vec<(i32, AssetBundleFullName)>>,
    pub m_AssetTimeStamps: Option<Vec<(String, AssetTimeStamp)>>,
    pub m_Assets: Option<Vec<(GUID, Asset)>>,
    pub m_Metrics: Option<AssetDatabaseMetrics>,
    pub m_UnityShadersVersion: Option<i32>,
    pub m_lastValidVersionHashes: Option<Vec<(u32, u32)>>,
    pub m_lastValidVersions: Option<Vec<(AssetImporterHashKey, u32)>>,
}

impl_object!(AssetDatabaseV1);

impl Clone for AssetDatabaseV1 {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleNames: self.m_AssetBundleNames.clone(),
            m_AssetTimeStamps: self.m_AssetTimeStamps.clone(),
            m_Assets: self.m_Assets.clone(),
            m_Metrics: self.m_Metrics.clone(),
            m_UnityShadersVersion: self.m_UnityShadersVersion.clone(),
            m_lastValidVersionHashes: self.m_lastValidVersionHashes.clone(),
            m_lastValidVersions: self.m_lastValidVersions.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetMetaData {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub assetStoreRef: Option<u64>,
    pub guid: Option<GUID>,
    pub labels: Option<Vec<String>>,
    pub licenseType: Option<i32>,
    pub originalChangeset: Option<u32>,
    pub originalDigest: Option<Hash128>,
    pub originalName: Option<String>,
    pub originalParent: Option<GUID>,
    pub pathName: Option<String>,
    pub timeCreated: Option<u64>,
}

impl_object!(AssetMetaData);

impl Clone for AssetMetaData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            assetStoreRef: self.assetStoreRef.clone(),
            guid: self.guid.clone(),
            labels: self.labels.clone(),
            licenseType: self.licenseType.clone(),
            originalChangeset: self.originalChangeset.clone(),
            originalDigest: self.originalDigest.clone(),
            originalName: self.originalName.clone(),
            originalParent: self.originalParent.clone(),
            pathName: self.pathName.clone(),
            timeCreated: self.timeCreated.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetServerCache {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CachesInitialized: Option<i32>,
    pub m_CommitItemSelection: Option<Vec<GUID>>,
    pub m_DeletedItems: Option<Vec<(GUID, DeletedItem)>>,
    pub m_Items: Option<Vec<(GUID, Item)>>,
    pub m_LastCommitMessage: Option<String>,
    pub m_LatestServerChangeset: Option<i32>,
    pub m_ModifiedItems: Option<Vec<(GUID, Item)>>,
    pub m_WorkingItemMetaData: Option<Vec<(GUID, CachedAssetMetaData)>>,
}

impl_object!(AssetServerCache);

impl Clone for AssetServerCache {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CachesInitialized: self.m_CachesInitialized.clone(),
            m_CommitItemSelection: self.m_CommitItemSelection.clone(),
            m_DeletedItems: self.m_DeletedItems.clone(),
            m_Items: self.m_Items.clone(),
            m_LastCommitMessage: self.m_LastCommitMessage.clone(),
            m_LatestServerChangeset: self.m_LatestServerChangeset.clone(),
            m_ModifiedItems: self.m_ModifiedItems.clone(),
            m_WorkingItemMetaData: self.m_WorkingItemMetaData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioBuildInfo {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AudioClipCount: Option<i32>,
    pub m_AudioMixerCount: Option<i32>,
    pub m_IsAudioDisabled: Option<bool>,
}

impl_object!(AudioBuildInfo);

impl Clone for AudioBuildInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AudioClipCount: self.m_AudioClipCount.clone(),
            m_AudioMixerCount: self.m_AudioMixerCount.clone(),
            m_IsAudioDisabled: self.m_IsAudioDisabled.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuiltAssetBundleInfoSet {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bundleInfos: Option<Vec<BuiltAssetBundleInfo>>,
}

impl_object!(BuiltAssetBundleInfoSet);

impl Clone for BuiltAssetBundleInfoSet {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bundleInfos: self.bundleInfos.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Derived {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(Derived);

impl Clone for Derived {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SubDerived {
    // extends Derived
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(SubDerived);

impl Clone for SubDerived {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DifferentMarshallingTestObject {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(DifferentMarshallingTestObject);

impl Clone for DifferentMarshallingTestObject {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EditorBuildSettings {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Scenes: Option<Vec<Scene>>,
    pub m_UseUCBPForAssetBundles: Option<bool>,
    pub m_configObjects: Option<Vec<(String, PPtrData<Object>)>>,
}

impl_object!(EditorBuildSettings);

impl Clone for EditorBuildSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Scenes: self.m_Scenes.clone(),
            m_UseUCBPForAssetBundles: self.m_UseUCBPForAssetBundles.clone(),
            m_configObjects: self.m_configObjects.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EditorExtension {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(EditorExtension);

impl Clone for EditorExtension {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Component {
    // extends EditorExtension
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(Component);

impl Clone for Component {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Behaviour {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(Behaviour);

impl Clone for Behaviour {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Animation {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AnimatePhysics: Option<bool>,
    pub m_Animation: Option<PPtrData<AnimationClip>>,
    pub m_Animations: Option<Vec<PPtrData<AnimationClip>>>,
    pub m_CullingType: Option<i32>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_PlayAutomatically: Option<bool>,
    pub m_UpdateMode: Option<i32>,
    pub m_UserAABB: Option<AABB>,
    pub m_WrapMode: Option<i32>,
}

impl_object!(Animation);

impl Clone for Animation {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AnimatePhysics: self.m_AnimatePhysics.clone(),
            m_Animation: self.m_Animation.clone(),
            m_Animations: self.m_Animations.clone(),
            m_CullingType: self.m_CullingType.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_PlayAutomatically: self.m_PlayAutomatically.clone(),
            m_UpdateMode: self.m_UpdateMode.clone(),
            m_UserAABB: self.m_UserAABB.clone(),
            m_WrapMode: self.m_WrapMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Animator {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AllowConstantClipSamplingOptimization: Option<bool>,
    pub m_AnimatePhysics: Option<bool>,
    pub m_ApplyRootMotion: Option<bool>,
    pub m_Avatar: Option<PPtrData<Avatar>>,
    pub m_Controller: Option<PPtrData<AnimatorController>>,
    pub m_CullingMode: Option<i32>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_HasTransformHierarchy: Option<bool>,
    pub m_KeepAnimatorControllerStateOnDisable: Option<bool>,
    pub m_KeepAnimatorStateOnDisable: Option<bool>,
    pub m_LinearVelocityBlending: Option<bool>,
    pub m_StabilizeFeet: Option<bool>,
    pub m_UpdateMode: Option<i32>,
    pub m_WriteDefaultValuesOnDisable: Option<bool>,
}

impl_object!(Animator);

impl Clone for Animator {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AllowConstantClipSamplingOptimization: self
                .m_AllowConstantClipSamplingOptimization
                .clone(),
            m_AnimatePhysics: self.m_AnimatePhysics.clone(),
            m_ApplyRootMotion: self.m_ApplyRootMotion.clone(),
            m_Avatar: self.m_Avatar.clone(),
            m_Controller: self.m_Controller.clone(),
            m_CullingMode: self.m_CullingMode.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_HasTransformHierarchy: self.m_HasTransformHierarchy.clone(),
            m_KeepAnimatorControllerStateOnDisable: self
                .m_KeepAnimatorControllerStateOnDisable
                .clone(),
            m_KeepAnimatorStateOnDisable: self.m_KeepAnimatorStateOnDisable.clone(),
            m_LinearVelocityBlending: self.m_LinearVelocityBlending.clone(),
            m_StabilizeFeet: self.m_StabilizeFeet.clone(),
            m_UpdateMode: self.m_UpdateMode.clone(),
            m_WriteDefaultValuesOnDisable: self.m_WriteDefaultValuesOnDisable.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ArticulationBody {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AnchorPosition: Option<Vector3>,
    pub m_AnchorRotation: Option<Quaternion>,
    pub m_AngularDamping: Option<f32>,
    pub m_ArticulationJointType: Option<i32>,
    pub m_CenterOfMass: Option<Vector3>,
    pub m_CollisionDetectionMode: Option<i32>,
    pub m_ComputeParentAnchor: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Immovable: Option<bool>,
    pub m_ImplicitCom: Option<bool>,
    pub m_ImplicitTensor: Option<bool>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_InertiaRotation: Option<Quaternion>,
    pub m_InertiaTensor: Option<Vector3>,
    pub m_JointFriction: Option<f32>,
    pub m_LinearDamping: Option<f32>,
    pub m_LinearX: Option<i32>,
    pub m_LinearY: Option<i32>,
    pub m_LinearZ: Option<i32>,
    pub m_Mass: Option<f32>,
    pub m_MatchAnchors: Option<bool>,
    pub m_ParentAnchorPosition: Option<Vector3>,
    pub m_ParentAnchorRotation: Option<Quaternion>,
    pub m_SwingY: Option<i32>,
    pub m_SwingZ: Option<i32>,
    pub m_Twist: Option<i32>,
    pub m_UseGravity: Option<bool>,
    pub m_XDrive: Option<ArticulationDrive>,
    pub m_YDrive: Option<ArticulationDrive>,
    pub m_ZDrive: Option<ArticulationDrive>,
}

impl_object!(ArticulationBody);

impl Clone for ArticulationBody {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AnchorPosition: self.m_AnchorPosition.clone(),
            m_AnchorRotation: self.m_AnchorRotation.clone(),
            m_AngularDamping: self.m_AngularDamping.clone(),
            m_ArticulationJointType: self.m_ArticulationJointType.clone(),
            m_CenterOfMass: self.m_CenterOfMass.clone(),
            m_CollisionDetectionMode: self.m_CollisionDetectionMode.clone(),
            m_ComputeParentAnchor: self.m_ComputeParentAnchor.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Immovable: self.m_Immovable.clone(),
            m_ImplicitCom: self.m_ImplicitCom.clone(),
            m_ImplicitTensor: self.m_ImplicitTensor.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_InertiaRotation: self.m_InertiaRotation.clone(),
            m_InertiaTensor: self.m_InertiaTensor.clone(),
            m_JointFriction: self.m_JointFriction.clone(),
            m_LinearDamping: self.m_LinearDamping.clone(),
            m_LinearX: self.m_LinearX.clone(),
            m_LinearY: self.m_LinearY.clone(),
            m_LinearZ: self.m_LinearZ.clone(),
            m_Mass: self.m_Mass.clone(),
            m_MatchAnchors: self.m_MatchAnchors.clone(),
            m_ParentAnchorPosition: self.m_ParentAnchorPosition.clone(),
            m_ParentAnchorRotation: self.m_ParentAnchorRotation.clone(),
            m_SwingY: self.m_SwingY.clone(),
            m_SwingZ: self.m_SwingZ.clone(),
            m_Twist: self.m_Twist.clone(),
            m_UseGravity: self.m_UseGravity.clone(),
            m_XDrive: self.m_XDrive.clone(),
            m_YDrive: self.m_YDrive.clone(),
            m_ZDrive: self.m_ZDrive.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioBehaviour {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(AudioBehaviour);

impl Clone for AudioBehaviour {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioListener {
    // extends AudioBehaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<u8>,
    pub m_ExtensionPropertyValues: Option<Vec<ExtensionPropertyValue>>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(AudioListener);

impl Clone for AudioListener {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_ExtensionPropertyValues: self.m_ExtensionPropertyValues.clone(),
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioSource {
    // extends AudioBehaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub BypassEffects: Option<bool>,
    pub BypassListenerEffects: Option<bool>,
    pub BypassReverbZones: Option<bool>,
    pub DopplerLevel: Option<f32>,
    pub Loop: Option<bool>,
    pub MaxDistance: Option<f32>,
    pub MinDistance: Option<f32>,
    pub Mute: Option<bool>,
    pub OutputAudioMixerGroup: Option<PPtrData<AudioMixerGroup>>,
    pub Pan2D: Option<f32>,
    pub Priority: Option<i32>,
    pub Spatialize: Option<bool>,
    pub SpatializePostEffects: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_ExtensionPropertyValues: Option<Vec<ExtensionPropertyValue>>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Pitch: Option<f32>,
    pub m_PlayOnAwake: Option<bool>,
    pub m_Resource: Option<PPtrData<AudioResource>>,
    pub m_Volume: Option<f32>,
    pub m_audioClip: Option<PPtrData<AudioClip>>,
    pub panLevelCustomCurve: Option<AnimationCurve>,
    pub reverbZoneMixCustomCurve: Option<AnimationCurve>,
    pub rolloffCustomCurve: Option<AnimationCurve>,
    pub rolloffMode: Option<i32>,
    pub spreadCustomCurve: Option<AnimationCurve>,
}

impl_object!(AudioSource);

impl Clone for AudioSource {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            BypassEffects: self.BypassEffects.clone(),
            BypassListenerEffects: self.BypassListenerEffects.clone(),
            BypassReverbZones: self.BypassReverbZones.clone(),
            DopplerLevel: self.DopplerLevel.clone(),
            Loop: self.Loop.clone(),
            MaxDistance: self.MaxDistance.clone(),
            MinDistance: self.MinDistance.clone(),
            Mute: self.Mute.clone(),
            OutputAudioMixerGroup: self.OutputAudioMixerGroup.clone(),
            Pan2D: self.Pan2D.clone(),
            Priority: self.Priority.clone(),
            Spatialize: self.Spatialize.clone(),
            SpatializePostEffects: self.SpatializePostEffects.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExtensionPropertyValues: self.m_ExtensionPropertyValues.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Pitch: self.m_Pitch.clone(),
            m_PlayOnAwake: self.m_PlayOnAwake.clone(),
            m_Resource: self.m_Resource.clone(),
            m_Volume: self.m_Volume.clone(),
            m_audioClip: self.m_audioClip.clone(),
            panLevelCustomCurve: self.panLevelCustomCurve.clone(),
            reverbZoneMixCustomCurve: self.reverbZoneMixCustomCurve.clone(),
            rolloffCustomCurve: self.rolloffCustomCurve.clone(),
            rolloffMode: self.rolloffMode.clone(),
            spreadCustomCurve: self.spreadCustomCurve.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioFilter {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(AudioFilter);

impl Clone for AudioFilter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioChorusFilter {
    // extends AudioFilter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Delay: Option<f32>,
    pub m_Depth: Option<f32>,
    pub m_DryMix: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_FeedBack: Option<f32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Rate: Option<f32>,
    pub m_WetMix1: Option<f32>,
    pub m_WetMix2: Option<f32>,
    pub m_WetMix3: Option<f32>,
}

impl_object!(AudioChorusFilter);

impl Clone for AudioChorusFilter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Delay: self.m_Delay.clone(),
            m_Depth: self.m_Depth.clone(),
            m_DryMix: self.m_DryMix.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_FeedBack: self.m_FeedBack.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Rate: self.m_Rate.clone(),
            m_WetMix1: self.m_WetMix1.clone(),
            m_WetMix2: self.m_WetMix2.clone(),
            m_WetMix3: self.m_WetMix3.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioDistortionFilter {
    // extends AudioFilter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DistortionLevel: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(AudioDistortionFilter);

impl Clone for AudioDistortionFilter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DistortionLevel: self.m_DistortionLevel.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioEchoFilter {
    // extends AudioFilter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DecayRatio: Option<f32>,
    pub m_Delay: Option<f32>,
    pub m_DryMix: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_WetMix: Option<f32>,
}

impl_object!(AudioEchoFilter);

impl Clone for AudioEchoFilter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DecayRatio: self.m_DecayRatio.clone(),
            m_Delay: self.m_Delay.clone(),
            m_DryMix: self.m_DryMix.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_WetMix: self.m_WetMix.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioHighPassFilter {
    // extends AudioFilter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CutoffFrequency: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_HighpassResonanceQ: Option<f32>,
}

impl_object!(AudioHighPassFilter);

impl Clone for AudioHighPassFilter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CutoffFrequency: self.m_CutoffFrequency.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_HighpassResonanceQ: self.m_HighpassResonanceQ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioLowPassFilter {
    // extends AudioFilter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub lowpassLevelCustomCurve: Option<AnimationCurve>,
    pub m_CutoffFrequency: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LowpassResonanceQ: Option<f32>,
}

impl_object!(AudioLowPassFilter);

impl Clone for AudioLowPassFilter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            lowpassLevelCustomCurve: self.lowpassLevelCustomCurve.clone(),
            m_CutoffFrequency: self.m_CutoffFrequency.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LowpassResonanceQ: self.m_LowpassResonanceQ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioReverbFilter {
    // extends AudioFilter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DecayHFRatio: Option<f32>,
    pub m_DecayTime: Option<f32>,
    pub m_Density: Option<f32>,
    pub m_Diffusion: Option<f32>,
    pub m_DryLevel: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_HFReference: Option<f32>,
    pub m_LFReference: Option<f32>,
    pub m_ReflectionsDelay: Option<f32>,
    pub m_ReflectionsLevel: Option<f32>,
    pub m_ReverbDelay: Option<f32>,
    pub m_ReverbLevel: Option<f32>,
    pub m_ReverbPreset: Option<i32>,
    pub m_Room: Option<f32>,
    pub m_RoomHF: Option<f32>,
    pub m_RoomLF: Option<f32>,
    pub m_RoomRolloff: Option<f32>,
}

impl_object!(AudioReverbFilter);

impl Clone for AudioReverbFilter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DecayHFRatio: self.m_DecayHFRatio.clone(),
            m_DecayTime: self.m_DecayTime.clone(),
            m_Density: self.m_Density.clone(),
            m_Diffusion: self.m_Diffusion.clone(),
            m_DryLevel: self.m_DryLevel.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_HFReference: self.m_HFReference.clone(),
            m_LFReference: self.m_LFReference.clone(),
            m_ReflectionsDelay: self.m_ReflectionsDelay.clone(),
            m_ReflectionsLevel: self.m_ReflectionsLevel.clone(),
            m_ReverbDelay: self.m_ReverbDelay.clone(),
            m_ReverbLevel: self.m_ReverbLevel.clone(),
            m_ReverbPreset: self.m_ReverbPreset.clone(),
            m_Room: self.m_Room.clone(),
            m_RoomHF: self.m_RoomHF.clone(),
            m_RoomLF: self.m_RoomLF.clone(),
            m_RoomRolloff: self.m_RoomRolloff.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioReverbZone {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DecayHFRatio: Option<f32>,
    pub m_DecayTime: Option<f32>,
    pub m_Density: Option<f32>,
    pub m_Diffusion: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_HFReference: Option<f32>,
    pub m_LFReference: Option<f32>,
    pub m_MaxDistance: Option<f32>,
    pub m_MinDistance: Option<f32>,
    pub m_Reflections: Option<i32>,
    pub m_ReflectionsDelay: Option<f32>,
    pub m_Reverb: Option<i32>,
    pub m_ReverbDelay: Option<f32>,
    pub m_ReverbPreset: Option<i32>,
    pub m_Room: Option<i32>,
    pub m_RoomHF: Option<i32>,
    pub m_RoomLF: Option<i32>,
    pub m_RoomRolloffFactor: Option<f32>,
}

impl_object!(AudioReverbZone);

impl Clone for AudioReverbZone {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DecayHFRatio: self.m_DecayHFRatio.clone(),
            m_DecayTime: self.m_DecayTime.clone(),
            m_Density: self.m_Density.clone(),
            m_Diffusion: self.m_Diffusion.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_HFReference: self.m_HFReference.clone(),
            m_LFReference: self.m_LFReference.clone(),
            m_MaxDistance: self.m_MaxDistance.clone(),
            m_MinDistance: self.m_MinDistance.clone(),
            m_Reflections: self.m_Reflections.clone(),
            m_ReflectionsDelay: self.m_ReflectionsDelay.clone(),
            m_Reverb: self.m_Reverb.clone(),
            m_ReverbDelay: self.m_ReverbDelay.clone(),
            m_ReverbPreset: self.m_ReverbPreset.clone(),
            m_Room: self.m_Room.clone(),
            m_RoomHF: self.m_RoomHF.clone(),
            m_RoomLF: self.m_RoomLF.clone(),
            m_RoomRolloffFactor: self.m_RoomRolloffFactor.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Camera {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub far_clip_plane: Option<f32>,
    pub field_of_view: Option<f32>,
    pub m_AllowDynamicResolution: Option<bool>,
    pub m_AllowMSAA: Option<bool>,
    pub m_Anamorphism: Option<f32>,
    pub m_Aperture: Option<f32>,
    pub m_BackGroundColor: Option<Color>,
    pub m_BarrelClipping: Option<f32>,
    pub m_BladeCount: Option<i32>,
    pub m_ClearFlags: Option<u32>,
    pub m_CullingMask: Option<BitField>,
    pub m_Curvature: Option<Vector2>,
    pub m_Depth: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_FocalLength: Option<f32>,
    pub m_FocusDistance: Option<f32>,
    pub m_ForceIntoRT: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_GateFitMode: Option<i32>,
    pub m_HDR: Option<bool>,
    pub m_Iso: Option<i32>,
    pub m_LensShift: Option<Vector2>,
    pub m_NormalizedViewPortRect: Option<Rectf>,
    pub m_OcclusionCulling: Option<bool>,
    pub m_RenderingPath: Option<i32>,
    pub m_SensorSize: Option<Vector2>,
    pub m_ShutterSpeed: Option<f32>,
    pub m_StereoConvergence: Option<f32>,
    pub m_StereoMirrorMode: Option<bool>,
    pub m_StereoSeparation: Option<f32>,
    pub m_TargetDisplay: Option<i32>,
    pub m_TargetEye: Option<i32>,
    pub m_TargetTexture: Option<PPtrData<RenderTexture>>,
    pub m_projectionMatrixMode: Option<i32>,
    pub near_clip_plane: Option<f32>,
    pub orthographic: Option<bool>,
    pub orthographic_size: Option<f32>,
}

impl_object!(Camera);

impl Clone for Camera {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            far_clip_plane: self.far_clip_plane.clone(),
            field_of_view: self.field_of_view.clone(),
            m_AllowDynamicResolution: self.m_AllowDynamicResolution.clone(),
            m_AllowMSAA: self.m_AllowMSAA.clone(),
            m_Anamorphism: self.m_Anamorphism.clone(),
            m_Aperture: self.m_Aperture.clone(),
            m_BackGroundColor: self.m_BackGroundColor.clone(),
            m_BarrelClipping: self.m_BarrelClipping.clone(),
            m_BladeCount: self.m_BladeCount.clone(),
            m_ClearFlags: self.m_ClearFlags.clone(),
            m_CullingMask: self.m_CullingMask.clone(),
            m_Curvature: self.m_Curvature.clone(),
            m_Depth: self.m_Depth.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_FocalLength: self.m_FocalLength.clone(),
            m_FocusDistance: self.m_FocusDistance.clone(),
            m_ForceIntoRT: self.m_ForceIntoRT.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_GateFitMode: self.m_GateFitMode.clone(),
            m_HDR: self.m_HDR.clone(),
            m_Iso: self.m_Iso.clone(),
            m_LensShift: self.m_LensShift.clone(),
            m_NormalizedViewPortRect: self.m_NormalizedViewPortRect.clone(),
            m_OcclusionCulling: self.m_OcclusionCulling.clone(),
            m_RenderingPath: self.m_RenderingPath.clone(),
            m_SensorSize: self.m_SensorSize.clone(),
            m_ShutterSpeed: self.m_ShutterSpeed.clone(),
            m_StereoConvergence: self.m_StereoConvergence.clone(),
            m_StereoMirrorMode: self.m_StereoMirrorMode.clone(),
            m_StereoSeparation: self.m_StereoSeparation.clone(),
            m_TargetDisplay: self.m_TargetDisplay.clone(),
            m_TargetEye: self.m_TargetEye.clone(),
            m_TargetTexture: self.m_TargetTexture.clone(),
            m_projectionMatrixMode: self.m_projectionMatrixMode.clone(),
            near_clip_plane: self.near_clip_plane.clone(),
            orthographic: self.orthographic.clone(),
            orthographic_size: self.orthographic_size.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ScriptableCamera {
    // extends Camera
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub far_clip_plane: Option<f32>,
    pub field_of_view: Option<f32>,
    pub m_AllowDynamicResolution: Option<bool>,
    pub m_AllowMSAA: Option<bool>,
    pub m_BackGroundColor: Option<Color>,
    pub m_ClearFlags: Option<u32>,
    pub m_CullingMask: Option<BitField>,
    pub m_Depth: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_FocalLength: Option<f32>,
    pub m_ForceIntoRT: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_GateFitMode: Option<i32>,
    pub m_HDR: Option<bool>,
    pub m_LensShift: Option<Vector2>,
    pub m_NormalizedViewPortRect: Option<Rectf>,
    pub m_OcclusionCulling: Option<bool>,
    pub m_RenderingPath: Option<i32>,
    pub m_Script: Option<PPtrData<MonoScript>>,
    pub m_SensorSize: Option<Vector2>,
    pub m_StereoConvergence: Option<f32>,
    pub m_StereoSeparation: Option<f32>,
    pub m_TargetDisplay: Option<i32>,
    pub m_TargetEye: Option<i32>,
    pub m_TargetTexture: Option<PPtrData<RenderTexture>>,
    pub m_projectionMatrixMode: Option<i32>,
    pub near_clip_plane: Option<f32>,
    pub orthographic: Option<bool>,
    pub orthographic_size: Option<f32>,
}

impl_object!(ScriptableCamera);

impl Clone for ScriptableCamera {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            far_clip_plane: self.far_clip_plane.clone(),
            field_of_view: self.field_of_view.clone(),
            m_AllowDynamicResolution: self.m_AllowDynamicResolution.clone(),
            m_AllowMSAA: self.m_AllowMSAA.clone(),
            m_BackGroundColor: self.m_BackGroundColor.clone(),
            m_ClearFlags: self.m_ClearFlags.clone(),
            m_CullingMask: self.m_CullingMask.clone(),
            m_Depth: self.m_Depth.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_FocalLength: self.m_FocalLength.clone(),
            m_ForceIntoRT: self.m_ForceIntoRT.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_GateFitMode: self.m_GateFitMode.clone(),
            m_HDR: self.m_HDR.clone(),
            m_LensShift: self.m_LensShift.clone(),
            m_NormalizedViewPortRect: self.m_NormalizedViewPortRect.clone(),
            m_OcclusionCulling: self.m_OcclusionCulling.clone(),
            m_RenderingPath: self.m_RenderingPath.clone(),
            m_Script: self.m_Script.clone(),
            m_SensorSize: self.m_SensorSize.clone(),
            m_StereoConvergence: self.m_StereoConvergence.clone(),
            m_StereoSeparation: self.m_StereoSeparation.clone(),
            m_TargetDisplay: self.m_TargetDisplay.clone(),
            m_TargetEye: self.m_TargetEye.clone(),
            m_TargetTexture: self.m_TargetTexture.clone(),
            m_projectionMatrixMode: self.m_projectionMatrixMode.clone(),
            near_clip_plane: self.near_clip_plane.clone(),
            orthographic: self.orthographic.clone(),
            orthographic_size: self.orthographic_size.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Canvas {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AdditionalShaderChannelsFlag: Option<i32>,
    pub m_Alpha: Option<f32>,
    pub m_Camera: Option<PPtrData<Camera>>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Normals: Option<bool>,
    pub m_OverridePixelPerfect: Option<bool>,
    pub m_OverrideSorting: Option<bool>,
    pub m_PixelPerfect: Option<bool>,
    pub m_PlaneDistance: Option<f32>,
    pub m_PositionUVs: Option<bool>,
    pub m_ReceivesEvents: Option<bool>,
    pub m_RenderMode: Option<i32>,
    pub m_SortingBucketNormalizedSize: Option<f32>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
    pub m_TargetDisplay: Option<i8>,
    pub m_UpdateRectTransformForStandalone: Option<i32>,
    pub m_VertexColorAlwaysGammaSpace: Option<bool>,
}

impl_object!(Canvas);

impl Clone for Canvas {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AdditionalShaderChannelsFlag: self.m_AdditionalShaderChannelsFlag.clone(),
            m_Alpha: self.m_Alpha.clone(),
            m_Camera: self.m_Camera.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Normals: self.m_Normals.clone(),
            m_OverridePixelPerfect: self.m_OverridePixelPerfect.clone(),
            m_OverrideSorting: self.m_OverrideSorting.clone(),
            m_PixelPerfect: self.m_PixelPerfect.clone(),
            m_PlaneDistance: self.m_PlaneDistance.clone(),
            m_PositionUVs: self.m_PositionUVs.clone(),
            m_ReceivesEvents: self.m_ReceivesEvents.clone(),
            m_RenderMode: self.m_RenderMode.clone(),
            m_SortingBucketNormalizedSize: self.m_SortingBucketNormalizedSize.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_TargetDisplay: self.m_TargetDisplay.clone(),
            m_UpdateRectTransformForStandalone: self.m_UpdateRectTransformForStandalone.clone(),
            m_VertexColorAlwaysGammaSpace: self.m_VertexColorAlwaysGammaSpace.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CanvasGroup {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Alpha: Option<f32>,
    pub m_BlocksRaycasts: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IgnoreParentGroups: Option<bool>,
    pub m_Interactable: Option<bool>,
}

impl_object!(CanvasGroup);

impl Clone for CanvasGroup {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Alpha: self.m_Alpha.clone(),
            m_BlocksRaycasts: self.m_BlocksRaycasts.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IgnoreParentGroups: self.m_IgnoreParentGroups.clone(),
            m_Interactable: self.m_Interactable.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Cloth {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BendingStiffness: Option<f32>,
    pub m_CapsuleColliders: Option<Vec<PPtrData<CapsuleCollider>>>,
    pub m_Coefficients: Option<Vec<ClothConstrainCoefficients>>,
    pub m_CollisionMassScale: Option<f32>,
    pub m_Damping: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_ExternalAcceleration: Option<Vector3>,
    pub m_Friction: Option<f32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_RandomAcceleration: Option<Vector3>,
    pub m_SelfAndInterCollisionIndices: Option<Vec<u32>>,
    pub m_SelfCollisionDistance: Option<f32>,
    pub m_SelfCollisionStiffness: Option<f32>,
    pub m_SleepThreshold: Option<f32>,
    pub m_SolverFrequency: Option<f32>,
    pub m_SphereColliders: Option<Vec<(PPtrData<SphereCollider>, PPtrData<SphereCollider>)>>,
    pub m_StretchingStiffness: Option<f32>,
    pub m_UseContinuousCollision: Option<bool>,
    pub m_UseGravity: Option<bool>,
    pub m_UseTethers: Option<bool>,
    pub m_UseVirtualParticles: Option<bool>,
    pub m_VirtualParticleIndices: Option<Vec<u32>>,
    pub m_VirtualParticleWeights: Option<Vec<Vector3>>,
    pub m_WorldAccelerationScale: Option<f32>,
    pub m_WorldVelocityScale: Option<f32>,
}

impl_object!(Cloth);

impl Clone for Cloth {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BendingStiffness: self.m_BendingStiffness.clone(),
            m_CapsuleColliders: self.m_CapsuleColliders.clone(),
            m_Coefficients: self.m_Coefficients.clone(),
            m_CollisionMassScale: self.m_CollisionMassScale.clone(),
            m_Damping: self.m_Damping.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExternalAcceleration: self.m_ExternalAcceleration.clone(),
            m_Friction: self.m_Friction.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_RandomAcceleration: self.m_RandomAcceleration.clone(),
            m_SelfAndInterCollisionIndices: self.m_SelfAndInterCollisionIndices.clone(),
            m_SelfCollisionDistance: self.m_SelfCollisionDistance.clone(),
            m_SelfCollisionStiffness: self.m_SelfCollisionStiffness.clone(),
            m_SleepThreshold: self.m_SleepThreshold.clone(),
            m_SolverFrequency: self.m_SolverFrequency.clone(),
            m_SphereColliders: self.m_SphereColliders.clone(),
            m_StretchingStiffness: self.m_StretchingStiffness.clone(),
            m_UseContinuousCollision: self.m_UseContinuousCollision.clone(),
            m_UseGravity: self.m_UseGravity.clone(),
            m_UseTethers: self.m_UseTethers.clone(),
            m_UseVirtualParticles: self.m_UseVirtualParticles.clone(),
            m_VirtualParticleIndices: self.m_VirtualParticleIndices.clone(),
            m_VirtualParticleWeights: self.m_VirtualParticleWeights.clone(),
            m_WorldAccelerationScale: self.m_WorldAccelerationScale.clone(),
            m_WorldVelocityScale: self.m_WorldVelocityScale.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct InteractiveCloth {
    // extends Cloth
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AttachedColliders: Option<Vec<ClothAttachment>>,
    pub m_AttachmentResponse: Option<f32>,
    pub m_AttachmentTearFactor: Option<f32>,
    pub m_BendingStiffness: Option<f32>,
    pub m_CollisionResponse: Option<f32>,
    pub m_Damping: Option<f32>,
    pub m_Density: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_ExternalAcceleration: Option<Vector3>,
    pub m_Friction: Option<f32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Mesh: Option<PPtrData<Mesh>>,
    pub m_Pressure: Option<f32>,
    pub m_RandomAcceleration: Option<Vector3>,
    pub m_SelfCollision: Option<bool>,
    pub m_StretchingStiffness: Option<f32>,
    pub m_TearFactor: Option<f32>,
    pub m_Thickness: Option<f32>,
    pub m_UseGravity: Option<bool>,
}

impl_object!(InteractiveCloth);

impl Clone for InteractiveCloth {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AttachedColliders: self.m_AttachedColliders.clone(),
            m_AttachmentResponse: self.m_AttachmentResponse.clone(),
            m_AttachmentTearFactor: self.m_AttachmentTearFactor.clone(),
            m_BendingStiffness: self.m_BendingStiffness.clone(),
            m_CollisionResponse: self.m_CollisionResponse.clone(),
            m_Damping: self.m_Damping.clone(),
            m_Density: self.m_Density.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExternalAcceleration: self.m_ExternalAcceleration.clone(),
            m_Friction: self.m_Friction.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Mesh: self.m_Mesh.clone(),
            m_Pressure: self.m_Pressure.clone(),
            m_RandomAcceleration: self.m_RandomAcceleration.clone(),
            m_SelfCollision: self.m_SelfCollision.clone(),
            m_StretchingStiffness: self.m_StretchingStiffness.clone(),
            m_TearFactor: self.m_TearFactor.clone(),
            m_Thickness: self.m_Thickness.clone(),
            m_UseGravity: self.m_UseGravity.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SkinnedCloth {
    // extends Cloth
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BendingStiffness: Option<f32>,
    pub m_Coefficients: Option<Vec<ClothConstrainCoefficients>>,
    pub m_Damping: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_ExternalAcceleration: Option<Vector3>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_RandomAcceleration: Option<Vector3>,
    pub m_SelfCollision: Option<bool>,
    pub m_StretchingStiffness: Option<f32>,
    pub m_Thickness: Option<f32>,
    pub m_UseGravity: Option<bool>,
    pub m_WorldAccelerationScale: Option<f32>,
    pub m_WorldVelocityScale: Option<f32>,
}

impl_object!(SkinnedCloth);

impl Clone for SkinnedCloth {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BendingStiffness: self.m_BendingStiffness.clone(),
            m_Coefficients: self.m_Coefficients.clone(),
            m_Damping: self.m_Damping.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExternalAcceleration: self.m_ExternalAcceleration.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_RandomAcceleration: self.m_RandomAcceleration.clone(),
            m_SelfCollision: self.m_SelfCollision.clone(),
            m_StretchingStiffness: self.m_StretchingStiffness.clone(),
            m_Thickness: self.m_Thickness.clone(),
            m_UseGravity: self.m_UseGravity.clone(),
            m_WorldAccelerationScale: self.m_WorldAccelerationScale.clone(),
            m_WorldVelocityScale: self.m_WorldVelocityScale.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CloudServiceHandlerBehaviour {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(CloudServiceHandlerBehaviour);

impl Clone for CloudServiceHandlerBehaviour {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Collider2D {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(Collider2D);

impl Clone for Collider2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BoxCollider2D {
    // extends Collider2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AutoTiling: Option<bool>,
    pub m_CallbackLayers: Option<BitField>,
    pub m_Center: Option<Vector2>,
    pub m_CompositeOperation: Option<i32>,
    pub m_CompositeOrder: Option<i32>,
    pub m_ContactCaptureLayers: Option<BitField>,
    pub m_Density: Option<f32>,
    pub m_EdgeRadius: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_ForceReceiveLayers: Option<BitField>,
    pub m_ForceSendLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_IsTrigger: Option<bool>,
    pub m_LayerOverridePriority: Option<i32>,
    pub m_Material: Option<PPtrData<PhysicsMaterial2D>>,
    pub m_Offset: Option<Vector2>,
    pub m_Size: Option<Vector2>,
    pub m_SpriteTilingProperty: Option<SpriteTilingProperty>,
    pub m_UsedByComposite: Option<bool>,
    pub m_UsedByEffector: Option<bool>,
}

impl_object!(BoxCollider2D);

impl Clone for BoxCollider2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AutoTiling: self.m_AutoTiling.clone(),
            m_CallbackLayers: self.m_CallbackLayers.clone(),
            m_Center: self.m_Center.clone(),
            m_CompositeOperation: self.m_CompositeOperation.clone(),
            m_CompositeOrder: self.m_CompositeOrder.clone(),
            m_ContactCaptureLayers: self.m_ContactCaptureLayers.clone(),
            m_Density: self.m_Density.clone(),
            m_EdgeRadius: self.m_EdgeRadius.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_ForceReceiveLayers: self.m_ForceReceiveLayers.clone(),
            m_ForceSendLayers: self.m_ForceSendLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_IsTrigger: self.m_IsTrigger.clone(),
            m_LayerOverridePriority: self.m_LayerOverridePriority.clone(),
            m_Material: self.m_Material.clone(),
            m_Offset: self.m_Offset.clone(),
            m_Size: self.m_Size.clone(),
            m_SpriteTilingProperty: self.m_SpriteTilingProperty.clone(),
            m_UsedByComposite: self.m_UsedByComposite.clone(),
            m_UsedByEffector: self.m_UsedByEffector.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CapsuleCollider2D {
    // extends Collider2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CallbackLayers: Option<BitField>,
    pub m_CompositeOperation: Option<i32>,
    pub m_CompositeOrder: Option<i32>,
    pub m_ContactCaptureLayers: Option<BitField>,
    pub m_Density: Option<f32>,
    pub m_Direction: Option<i32>,
    pub m_Enabled: Option<u8>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_ForceReceiveLayers: Option<BitField>,
    pub m_ForceSendLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_IsTrigger: Option<bool>,
    pub m_LayerOverridePriority: Option<i32>,
    pub m_Material: Option<PPtrData<PhysicsMaterial2D>>,
    pub m_Offset: Option<Vector2>,
    pub m_Size: Option<Vector2>,
    pub m_UsedByComposite: Option<bool>,
    pub m_UsedByEffector: Option<bool>,
}

impl_object!(CapsuleCollider2D);

impl Clone for CapsuleCollider2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CallbackLayers: self.m_CallbackLayers.clone(),
            m_CompositeOperation: self.m_CompositeOperation.clone(),
            m_CompositeOrder: self.m_CompositeOrder.clone(),
            m_ContactCaptureLayers: self.m_ContactCaptureLayers.clone(),
            m_Density: self.m_Density.clone(),
            m_Direction: self.m_Direction.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_ForceReceiveLayers: self.m_ForceReceiveLayers.clone(),
            m_ForceSendLayers: self.m_ForceSendLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_IsTrigger: self.m_IsTrigger.clone(),
            m_LayerOverridePriority: self.m_LayerOverridePriority.clone(),
            m_Material: self.m_Material.clone(),
            m_Offset: self.m_Offset.clone(),
            m_Size: self.m_Size.clone(),
            m_UsedByComposite: self.m_UsedByComposite.clone(),
            m_UsedByEffector: self.m_UsedByEffector.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CircleCollider2D {
    // extends Collider2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CallbackLayers: Option<BitField>,
    pub m_Center: Option<Vector2>,
    pub m_CompositeOperation: Option<i32>,
    pub m_CompositeOrder: Option<i32>,
    pub m_ContactCaptureLayers: Option<BitField>,
    pub m_Density: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_ForceReceiveLayers: Option<BitField>,
    pub m_ForceSendLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_IsTrigger: Option<bool>,
    pub m_LayerOverridePriority: Option<i32>,
    pub m_Material: Option<PPtrData<PhysicsMaterial2D>>,
    pub m_Offset: Option<Vector2>,
    pub m_Radius: Option<f32>,
    pub m_UsedByComposite: Option<bool>,
    pub m_UsedByEffector: Option<bool>,
}

impl_object!(CircleCollider2D);

impl Clone for CircleCollider2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CallbackLayers: self.m_CallbackLayers.clone(),
            m_Center: self.m_Center.clone(),
            m_CompositeOperation: self.m_CompositeOperation.clone(),
            m_CompositeOrder: self.m_CompositeOrder.clone(),
            m_ContactCaptureLayers: self.m_ContactCaptureLayers.clone(),
            m_Density: self.m_Density.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_ForceReceiveLayers: self.m_ForceReceiveLayers.clone(),
            m_ForceSendLayers: self.m_ForceSendLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_IsTrigger: self.m_IsTrigger.clone(),
            m_LayerOverridePriority: self.m_LayerOverridePriority.clone(),
            m_Material: self.m_Material.clone(),
            m_Offset: self.m_Offset.clone(),
            m_Radius: self.m_Radius.clone(),
            m_UsedByComposite: self.m_UsedByComposite.clone(),
            m_UsedByEffector: self.m_UsedByEffector.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CompositeCollider2D {
    // extends Collider2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CallbackLayers: Option<BitField>,
    pub m_ColliderPaths: Option<Vec<SubCollider>>,
    pub m_CompositeGameObject: Option<PPtrData<GameObject>>,
    pub m_CompositeOperation: Option<i32>,
    pub m_CompositeOrder: Option<i32>,
    pub m_CompositePaths: Option<Polygon2D>,
    pub m_ContactCaptureLayers: Option<BitField>,
    pub m_Density: Option<f32>,
    pub m_EdgeRadius: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_ForceReceiveLayers: Option<BitField>,
    pub m_ForceSendLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_GenerationType: Option<i32>,
    pub m_GeometryType: Option<i32>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_IsTrigger: Option<bool>,
    pub m_LayerOverridePriority: Option<i32>,
    pub m_Material: Option<PPtrData<PhysicsMaterial2D>>,
    pub m_Offset: Option<Vector2>,
    pub m_OffsetDistance: Option<f32>,
    pub m_UseDelaunayMesh: Option<bool>,
    pub m_UsedByComposite: Option<bool>,
    pub m_UsedByEffector: Option<bool>,
    pub m_VertexDistance: Option<f32>,
}

impl_object!(CompositeCollider2D);

impl Clone for CompositeCollider2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CallbackLayers: self.m_CallbackLayers.clone(),
            m_ColliderPaths: self.m_ColliderPaths.clone(),
            m_CompositeGameObject: self.m_CompositeGameObject.clone(),
            m_CompositeOperation: self.m_CompositeOperation.clone(),
            m_CompositeOrder: self.m_CompositeOrder.clone(),
            m_CompositePaths: self.m_CompositePaths.clone(),
            m_ContactCaptureLayers: self.m_ContactCaptureLayers.clone(),
            m_Density: self.m_Density.clone(),
            m_EdgeRadius: self.m_EdgeRadius.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_ForceReceiveLayers: self.m_ForceReceiveLayers.clone(),
            m_ForceSendLayers: self.m_ForceSendLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_GenerationType: self.m_GenerationType.clone(),
            m_GeometryType: self.m_GeometryType.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_IsTrigger: self.m_IsTrigger.clone(),
            m_LayerOverridePriority: self.m_LayerOverridePriority.clone(),
            m_Material: self.m_Material.clone(),
            m_Offset: self.m_Offset.clone(),
            m_OffsetDistance: self.m_OffsetDistance.clone(),
            m_UseDelaunayMesh: self.m_UseDelaunayMesh.clone(),
            m_UsedByComposite: self.m_UsedByComposite.clone(),
            m_UsedByEffector: self.m_UsedByEffector.clone(),
            m_VertexDistance: self.m_VertexDistance.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CustomCollider2D {
    // extends Collider2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CallbackLayers: Option<BitField>,
    pub m_CompositeOperation: Option<i32>,
    pub m_CompositeOrder: Option<i32>,
    pub m_ContactCaptureLayers: Option<BitField>,
    pub m_CustomShapes: Option<PhysicsShapeGroup2D>,
    pub m_Density: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_ForceReceiveLayers: Option<BitField>,
    pub m_ForceSendLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_IsTrigger: Option<bool>,
    pub m_LayerOverridePriority: Option<i32>,
    pub m_Material: Option<PPtrData<PhysicsMaterial2D>>,
    pub m_Offset: Option<Vector2>,
    pub m_UsedByComposite: Option<bool>,
    pub m_UsedByEffector: Option<bool>,
}

impl_object!(CustomCollider2D);

impl Clone for CustomCollider2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CallbackLayers: self.m_CallbackLayers.clone(),
            m_CompositeOperation: self.m_CompositeOperation.clone(),
            m_CompositeOrder: self.m_CompositeOrder.clone(),
            m_ContactCaptureLayers: self.m_ContactCaptureLayers.clone(),
            m_CustomShapes: self.m_CustomShapes.clone(),
            m_Density: self.m_Density.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_ForceReceiveLayers: self.m_ForceReceiveLayers.clone(),
            m_ForceSendLayers: self.m_ForceSendLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_IsTrigger: self.m_IsTrigger.clone(),
            m_LayerOverridePriority: self.m_LayerOverridePriority.clone(),
            m_Material: self.m_Material.clone(),
            m_Offset: self.m_Offset.clone(),
            m_UsedByComposite: self.m_UsedByComposite.clone(),
            m_UsedByEffector: self.m_UsedByEffector.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EdgeCollider2D {
    // extends Collider2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AdjacentEndPoint: Option<Vector2>,
    pub m_AdjacentStartPoint: Option<Vector2>,
    pub m_CallbackLayers: Option<BitField>,
    pub m_CompositeOperation: Option<i32>,
    pub m_CompositeOrder: Option<i32>,
    pub m_ContactCaptureLayers: Option<BitField>,
    pub m_Density: Option<f32>,
    pub m_EdgeRadius: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_ForceReceiveLayers: Option<BitField>,
    pub m_ForceSendLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_IsTrigger: Option<bool>,
    pub m_LayerOverridePriority: Option<i32>,
    pub m_Material: Option<PPtrData<PhysicsMaterial2D>>,
    pub m_Offset: Option<Vector2>,
    pub m_Points: Option<Vec<Vector2>>,
    pub m_UseAdjacentEndPoint: Option<bool>,
    pub m_UseAdjacentStartPoint: Option<bool>,
    pub m_UsedByComposite: Option<bool>,
    pub m_UsedByEffector: Option<bool>,
}

impl_object!(EdgeCollider2D);

impl Clone for EdgeCollider2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AdjacentEndPoint: self.m_AdjacentEndPoint.clone(),
            m_AdjacentStartPoint: self.m_AdjacentStartPoint.clone(),
            m_CallbackLayers: self.m_CallbackLayers.clone(),
            m_CompositeOperation: self.m_CompositeOperation.clone(),
            m_CompositeOrder: self.m_CompositeOrder.clone(),
            m_ContactCaptureLayers: self.m_ContactCaptureLayers.clone(),
            m_Density: self.m_Density.clone(),
            m_EdgeRadius: self.m_EdgeRadius.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_ForceReceiveLayers: self.m_ForceReceiveLayers.clone(),
            m_ForceSendLayers: self.m_ForceSendLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_IsTrigger: self.m_IsTrigger.clone(),
            m_LayerOverridePriority: self.m_LayerOverridePriority.clone(),
            m_Material: self.m_Material.clone(),
            m_Offset: self.m_Offset.clone(),
            m_Points: self.m_Points.clone(),
            m_UseAdjacentEndPoint: self.m_UseAdjacentEndPoint.clone(),
            m_UseAdjacentStartPoint: self.m_UseAdjacentStartPoint.clone(),
            m_UsedByComposite: self.m_UsedByComposite.clone(),
            m_UsedByEffector: self.m_UsedByEffector.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PolygonCollider2D {
    // extends Collider2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AutoTiling: Option<bool>,
    pub m_CallbackLayers: Option<BitField>,
    pub m_CompositeOperation: Option<i32>,
    pub m_CompositeOrder: Option<i32>,
    pub m_ContactCaptureLayers: Option<BitField>,
    pub m_Density: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_ForceReceiveLayers: Option<BitField>,
    pub m_ForceSendLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_IsTrigger: Option<bool>,
    pub m_LayerOverridePriority: Option<i32>,
    pub m_Material: Option<PPtrData<PhysicsMaterial2D>>,
    pub m_Offset: Option<Vector2>,
    pub m_Points: Option<Polygon2D>,
    pub m_Poly: Option<Polygon2D>,
    pub m_SpriteTilingProperty: Option<SpriteTilingProperty>,
    pub m_UseDelaunayMesh: Option<bool>,
    pub m_UsedByComposite: Option<bool>,
    pub m_UsedByEffector: Option<bool>,
}

impl_object!(PolygonCollider2D);

impl Clone for PolygonCollider2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AutoTiling: self.m_AutoTiling.clone(),
            m_CallbackLayers: self.m_CallbackLayers.clone(),
            m_CompositeOperation: self.m_CompositeOperation.clone(),
            m_CompositeOrder: self.m_CompositeOrder.clone(),
            m_ContactCaptureLayers: self.m_ContactCaptureLayers.clone(),
            m_Density: self.m_Density.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_ForceReceiveLayers: self.m_ForceReceiveLayers.clone(),
            m_ForceSendLayers: self.m_ForceSendLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_IsTrigger: self.m_IsTrigger.clone(),
            m_LayerOverridePriority: self.m_LayerOverridePriority.clone(),
            m_Material: self.m_Material.clone(),
            m_Offset: self.m_Offset.clone(),
            m_Points: self.m_Points.clone(),
            m_Poly: self.m_Poly.clone(),
            m_SpriteTilingProperty: self.m_SpriteTilingProperty.clone(),
            m_UseDelaunayMesh: self.m_UseDelaunayMesh.clone(),
            m_UsedByComposite: self.m_UsedByComposite.clone(),
            m_UsedByEffector: self.m_UsedByEffector.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PolygonColliderBase2D {
    // extends Collider2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(PolygonColliderBase2D);

impl Clone for PolygonColliderBase2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TilemapCollider2D {
    // extends Collider2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CallbackLayers: Option<BitField>,
    pub m_CompositeOperation: Option<i32>,
    pub m_CompositeOrder: Option<i32>,
    pub m_ContactCaptureLayers: Option<BitField>,
    pub m_Density: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_ExtrusionFactor: Option<f32>,
    pub m_ForceReceiveLayers: Option<BitField>,
    pub m_ForceSendLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_IsTrigger: Option<bool>,
    pub m_LayerOverridePriority: Option<i32>,
    pub m_Material: Option<PPtrData<PhysicsMaterial2D>>,
    pub m_MaximumTileChangeCount: Option<u32>,
    pub m_Offset: Option<Vector2>,
    pub m_UseDelaunayMesh: Option<bool>,
    pub m_UsedByComposite: Option<bool>,
    pub m_UsedByEffector: Option<bool>,
}

impl_object!(TilemapCollider2D);

impl Clone for TilemapCollider2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CallbackLayers: self.m_CallbackLayers.clone(),
            m_CompositeOperation: self.m_CompositeOperation.clone(),
            m_CompositeOrder: self.m_CompositeOrder.clone(),
            m_ContactCaptureLayers: self.m_ContactCaptureLayers.clone(),
            m_Density: self.m_Density.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_ExtrusionFactor: self.m_ExtrusionFactor.clone(),
            m_ForceReceiveLayers: self.m_ForceReceiveLayers.clone(),
            m_ForceSendLayers: self.m_ForceSendLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_IsTrigger: self.m_IsTrigger.clone(),
            m_LayerOverridePriority: self.m_LayerOverridePriority.clone(),
            m_Material: self.m_Material.clone(),
            m_MaximumTileChangeCount: self.m_MaximumTileChangeCount.clone(),
            m_Offset: self.m_Offset.clone(),
            m_UseDelaunayMesh: self.m_UseDelaunayMesh.clone(),
            m_UsedByComposite: self.m_UsedByComposite.clone(),
            m_UsedByEffector: self.m_UsedByEffector.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ConstantForce {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<u8>,
    pub m_Force: Option<Vector3>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_RelativeForce: Option<Vector3>,
    pub m_RelativeTorque: Option<Vector3>,
    pub m_Torque: Option<Vector3>,
}

impl_object!(ConstantForce);

impl Clone for ConstantForce {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_Force: self.m_Force.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_RelativeForce: self.m_RelativeForce.clone(),
            m_RelativeTorque: self.m_RelativeTorque.clone(),
            m_Torque: self.m_Torque.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Effector2D {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(Effector2D);

impl Clone for Effector2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AreaEffector2D {
    // extends Effector2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AngularDrag: Option<f32>,
    pub m_ColliderMask: Option<BitField>,
    pub m_Drag: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_ForceAngle: Option<f32>,
    pub m_ForceDirection: Option<f32>,
    pub m_ForceMagnitude: Option<f32>,
    pub m_ForceTarget: Option<i32>,
    pub m_ForceVariation: Option<f32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_UseColliderMask: Option<bool>,
    pub m_UseGlobalAngle: Option<bool>,
}

impl_object!(AreaEffector2D);

impl Clone for AreaEffector2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AngularDrag: self.m_AngularDrag.clone(),
            m_ColliderMask: self.m_ColliderMask.clone(),
            m_Drag: self.m_Drag.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ForceAngle: self.m_ForceAngle.clone(),
            m_ForceDirection: self.m_ForceDirection.clone(),
            m_ForceMagnitude: self.m_ForceMagnitude.clone(),
            m_ForceTarget: self.m_ForceTarget.clone(),
            m_ForceVariation: self.m_ForceVariation.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_UseColliderMask: self.m_UseColliderMask.clone(),
            m_UseGlobalAngle: self.m_UseGlobalAngle.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuoyancyEffector2D {
    // extends Effector2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AngularDrag: Option<f32>,
    pub m_ColliderMask: Option<BitField>,
    pub m_Density: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_FlowAngle: Option<f32>,
    pub m_FlowMagnitude: Option<f32>,
    pub m_FlowVariation: Option<f32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LinearDrag: Option<f32>,
    pub m_SurfaceLevel: Option<f32>,
    pub m_UseColliderMask: Option<bool>,
}

impl_object!(BuoyancyEffector2D);

impl Clone for BuoyancyEffector2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AngularDrag: self.m_AngularDrag.clone(),
            m_ColliderMask: self.m_ColliderMask.clone(),
            m_Density: self.m_Density.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_FlowAngle: self.m_FlowAngle.clone(),
            m_FlowMagnitude: self.m_FlowMagnitude.clone(),
            m_FlowVariation: self.m_FlowVariation.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LinearDrag: self.m_LinearDrag.clone(),
            m_SurfaceLevel: self.m_SurfaceLevel.clone(),
            m_UseColliderMask: self.m_UseColliderMask.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PlatformEffector2D {
    // extends Effector2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ColliderMask: Option<BitField>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_OneWay: Option<bool>,
    pub m_RotationalOffset: Option<f32>,
    pub m_SideAngleVariance: Option<f32>,
    pub m_SideArc: Option<f32>,
    pub m_SideBounce: Option<bool>,
    pub m_SideFriction: Option<bool>,
    pub m_SurfaceArc: Option<f32>,
    pub m_UseColliderMask: Option<bool>,
    pub m_UseOneWay: Option<bool>,
    pub m_UseOneWayGrouping: Option<bool>,
    pub m_UseSideBounce: Option<bool>,
    pub m_UseSideFriction: Option<bool>,
}

impl_object!(PlatformEffector2D);

impl Clone for PlatformEffector2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ColliderMask: self.m_ColliderMask.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_OneWay: self.m_OneWay.clone(),
            m_RotationalOffset: self.m_RotationalOffset.clone(),
            m_SideAngleVariance: self.m_SideAngleVariance.clone(),
            m_SideArc: self.m_SideArc.clone(),
            m_SideBounce: self.m_SideBounce.clone(),
            m_SideFriction: self.m_SideFriction.clone(),
            m_SurfaceArc: self.m_SurfaceArc.clone(),
            m_UseColliderMask: self.m_UseColliderMask.clone(),
            m_UseOneWay: self.m_UseOneWay.clone(),
            m_UseOneWayGrouping: self.m_UseOneWayGrouping.clone(),
            m_UseSideBounce: self.m_UseSideBounce.clone(),
            m_UseSideFriction: self.m_UseSideFriction.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PointEffector2D {
    // extends Effector2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AngularDrag: Option<f32>,
    pub m_ColliderMask: Option<BitField>,
    pub m_DistanceScale: Option<f32>,
    pub m_Drag: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_ForceMagnitude: Option<f32>,
    pub m_ForceMode: Option<i32>,
    pub m_ForceSource: Option<i32>,
    pub m_ForceTarget: Option<i32>,
    pub m_ForceVariation: Option<f32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_UseColliderMask: Option<bool>,
}

impl_object!(PointEffector2D);

impl Clone for PointEffector2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AngularDrag: self.m_AngularDrag.clone(),
            m_ColliderMask: self.m_ColliderMask.clone(),
            m_DistanceScale: self.m_DistanceScale.clone(),
            m_Drag: self.m_Drag.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ForceMagnitude: self.m_ForceMagnitude.clone(),
            m_ForceMode: self.m_ForceMode.clone(),
            m_ForceSource: self.m_ForceSource.clone(),
            m_ForceTarget: self.m_ForceTarget.clone(),
            m_ForceVariation: self.m_ForceVariation.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_UseColliderMask: self.m_UseColliderMask.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SurfaceEffector2D {
    // extends Effector2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ColliderMask: Option<BitField>,
    pub m_Enabled: Option<u8>,
    pub m_ForceScale: Option<f32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Speed: Option<f32>,
    pub m_SpeedVariation: Option<f32>,
    pub m_UseBounce: Option<bool>,
    pub m_UseColliderMask: Option<bool>,
    pub m_UseContactForce: Option<bool>,
    pub m_UseFriction: Option<bool>,
}

impl_object!(SurfaceEffector2D);

impl Clone for SurfaceEffector2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ColliderMask: self.m_ColliderMask.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ForceScale: self.m_ForceScale.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Speed: self.m_Speed.clone(),
            m_SpeedVariation: self.m_SpeedVariation.clone(),
            m_UseBounce: self.m_UseBounce.clone(),
            m_UseColliderMask: self.m_UseColliderMask.clone(),
            m_UseContactForce: self.m_UseContactForce.clone(),
            m_UseFriction: self.m_UseFriction.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct FlareLayer {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(FlareLayer);

impl Clone for FlareLayer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GUIElement {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(GUIElement);

impl Clone for GUIElement {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GUIText {
    // extends GUIElement
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Alignment: Option<i16>,
    pub m_Anchor: Option<i16>,
    pub m_Color: Option<Color>,
    pub m_Enabled: Option<u8>,
    pub m_Font: Option<PPtrData<Font>>,
    pub m_FontSize: Option<i32>,
    pub m_FontStyle: Option<i32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LineSpacing: Option<f32>,
    pub m_Material: Option<PPtrData<Material>>,
    pub m_PixelCorrect: Option<bool>,
    pub m_PixelOffset: Option<Vector2>,
    pub m_RichText: Option<bool>,
    pub m_TabSize: Option<f32>,
    pub m_Text: Option<String>,
}

impl_object!(GUIText);

impl Clone for GUIText {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Alignment: self.m_Alignment.clone(),
            m_Anchor: self.m_Anchor.clone(),
            m_Color: self.m_Color.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_Font: self.m_Font.clone(),
            m_FontSize: self.m_FontSize.clone(),
            m_FontStyle: self.m_FontStyle.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LineSpacing: self.m_LineSpacing.clone(),
            m_Material: self.m_Material.clone(),
            m_PixelCorrect: self.m_PixelCorrect.clone(),
            m_PixelOffset: self.m_PixelOffset.clone(),
            m_RichText: self.m_RichText.clone(),
            m_TabSize: self.m_TabSize.clone(),
            m_Text: self.m_Text.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GUITexture {
    // extends GUIElement
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BottomBorder: Option<i32>,
    pub m_Color: Option<Color>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LeftBorder: Option<i32>,
    pub m_PixelInset: Option<Rectf>,
    pub m_RightBorder: Option<i32>,
    pub m_Texture: Option<PPtrData<Texture>>,
    pub m_TopBorder: Option<i32>,
}

impl_object!(GUITexture);

impl Clone for GUITexture {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BottomBorder: self.m_BottomBorder.clone(),
            m_Color: self.m_Color.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LeftBorder: self.m_LeftBorder.clone(),
            m_PixelInset: self.m_PixelInset.clone(),
            m_RightBorder: self.m_RightBorder.clone(),
            m_Texture: self.m_Texture.clone(),
            m_TopBorder: self.m_TopBorder.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GUILayer {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(GUILayer);

impl Clone for GUILayer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GridLayout {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(GridLayout);

impl Clone for GridLayout {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Grid {
    // extends GridLayout
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CellGap: Option<Vector3>,
    pub m_CellLayout: Option<i32>,
    pub m_CellSize: Option<Vector3>,
    pub m_CellSwizzle: Option<i32>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(Grid);

impl Clone for Grid {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CellGap: self.m_CellGap.clone(),
            m_CellLayout: self.m_CellLayout.clone(),
            m_CellSize: self.m_CellSize.clone(),
            m_CellSwizzle: self.m_CellSwizzle.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Tilemap {
    // extends GridLayout
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AnimatedTiles: Option<Vec<(int3_storage, TileAnimationData)>>,
    pub m_AnimationFrameRate: Option<f32>,
    pub m_Color: Option<Color>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Origin: Option<int3_storage>,
    pub m_Size: Option<int3_storage>,
    pub m_TileAnchor: Option<Vector3>,
    pub m_TileAssetArray: Option<Vec<TilemapRefCountedData>>,
    pub m_TileColorArray: Option<Vec<TilemapRefCountedData>>,
    pub m_TileMatrixArray: Option<Vec<TilemapRefCountedData>>,
    pub m_TileObjectToInstantiateArray: Option<Vec<TilemapRefCountedData>>,
    pub m_TileOrientation: Option<i32>,
    pub m_TileOrientationMatrix: Option<Matrix4x4>,
    pub m_TileSpriteArray: Option<Vec<TilemapRefCountedData>>,
    pub m_Tiles: Option<Vec<(int3_storage, Tile)>>,
}

impl_object!(Tilemap);

impl Clone for Tilemap {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AnimatedTiles: self.m_AnimatedTiles.clone(),
            m_AnimationFrameRate: self.m_AnimationFrameRate.clone(),
            m_Color: self.m_Color.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Origin: self.m_Origin.clone(),
            m_Size: self.m_Size.clone(),
            m_TileAnchor: self.m_TileAnchor.clone(),
            m_TileAssetArray: self.m_TileAssetArray.clone(),
            m_TileColorArray: self.m_TileColorArray.clone(),
            m_TileMatrixArray: self.m_TileMatrixArray.clone(),
            m_TileObjectToInstantiateArray: self.m_TileObjectToInstantiateArray.clone(),
            m_TileOrientation: self.m_TileOrientation.clone(),
            m_TileOrientationMatrix: self.m_TileOrientationMatrix.clone(),
            m_TileSpriteArray: self.m_TileSpriteArray.clone(),
            m_Tiles: self.m_Tiles.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Halo {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Color: Option<Color>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Size: Option<f32>,
}

impl_object!(Halo);

impl Clone for Halo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Color: self.m_Color.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Size: self.m_Size.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HaloLayer {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(HaloLayer);

impl Clone for HaloLayer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct IConstraint {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(IConstraint);

impl Clone for IConstraint {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AimConstraint {
    // extends IConstraint
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Active: Option<bool>,
    pub m_AffectRotationX: Option<bool>,
    pub m_AffectRotationY: Option<bool>,
    pub m_AffectRotationZ: Option<bool>,
    pub m_AimVector: Option<Vector3>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IsContraintActive: Option<bool>,
    pub m_RotationAtRest: Option<Vector3>,
    pub m_RotationOffset: Option<Vector3>,
    pub m_Sources: Option<Vec<ConstraintSource>>,
    pub m_UpType: Option<i32>,
    pub m_UpVector: Option<Vector3>,
    pub m_Weight: Option<f32>,
    pub m_WorldUpObject: Option<PPtrData<Transform>>,
    pub m_WorldUpVector: Option<Vector3>,
}

impl_object!(AimConstraint);

impl Clone for AimConstraint {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Active: self.m_Active.clone(),
            m_AffectRotationX: self.m_AffectRotationX.clone(),
            m_AffectRotationY: self.m_AffectRotationY.clone(),
            m_AffectRotationZ: self.m_AffectRotationZ.clone(),
            m_AimVector: self.m_AimVector.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IsContraintActive: self.m_IsContraintActive.clone(),
            m_RotationAtRest: self.m_RotationAtRest.clone(),
            m_RotationOffset: self.m_RotationOffset.clone(),
            m_Sources: self.m_Sources.clone(),
            m_UpType: self.m_UpType.clone(),
            m_UpVector: self.m_UpVector.clone(),
            m_Weight: self.m_Weight.clone(),
            m_WorldUpObject: self.m_WorldUpObject.clone(),
            m_WorldUpVector: self.m_WorldUpVector.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LookAtConstraint {
    // extends IConstraint
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Active: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IsContraintActive: Option<bool>,
    pub m_Roll: Option<f32>,
    pub m_RotationAtRest: Option<Vector3>,
    pub m_RotationOffset: Option<Vector3>,
    pub m_Sources: Option<Vec<ConstraintSource>>,
    pub m_UseUpObject: Option<bool>,
    pub m_Weight: Option<f32>,
    pub m_WorldUpObject: Option<PPtrData<Transform>>,
}

impl_object!(LookAtConstraint);

impl Clone for LookAtConstraint {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Active: self.m_Active.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IsContraintActive: self.m_IsContraintActive.clone(),
            m_Roll: self.m_Roll.clone(),
            m_RotationAtRest: self.m_RotationAtRest.clone(),
            m_RotationOffset: self.m_RotationOffset.clone(),
            m_Sources: self.m_Sources.clone(),
            m_UseUpObject: self.m_UseUpObject.clone(),
            m_Weight: self.m_Weight.clone(),
            m_WorldUpObject: self.m_WorldUpObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ParentConstraint {
    // extends IConstraint
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Active: Option<bool>,
    pub m_AffectRotationX: Option<bool>,
    pub m_AffectRotationY: Option<bool>,
    pub m_AffectRotationZ: Option<bool>,
    pub m_AffectTranslationX: Option<bool>,
    pub m_AffectTranslationY: Option<bool>,
    pub m_AffectTranslationZ: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IsContraintActive: Option<bool>,
    pub m_RotationAtRest: Option<Vector3>,
    pub m_RotationOffsets: Option<Vec<Vector3>>,
    pub m_Sources: Option<Vec<ConstraintSource>>,
    pub m_TranslationAtRest: Option<Vector3>,
    pub m_TranslationOffsets: Option<Vec<Vector3>>,
    pub m_Weight: Option<f32>,
}

impl_object!(ParentConstraint);

impl Clone for ParentConstraint {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Active: self.m_Active.clone(),
            m_AffectRotationX: self.m_AffectRotationX.clone(),
            m_AffectRotationY: self.m_AffectRotationY.clone(),
            m_AffectRotationZ: self.m_AffectRotationZ.clone(),
            m_AffectTranslationX: self.m_AffectTranslationX.clone(),
            m_AffectTranslationY: self.m_AffectTranslationY.clone(),
            m_AffectTranslationZ: self.m_AffectTranslationZ.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IsContraintActive: self.m_IsContraintActive.clone(),
            m_RotationAtRest: self.m_RotationAtRest.clone(),
            m_RotationOffsets: self.m_RotationOffsets.clone(),
            m_Sources: self.m_Sources.clone(),
            m_TranslationAtRest: self.m_TranslationAtRest.clone(),
            m_TranslationOffsets: self.m_TranslationOffsets.clone(),
            m_Weight: self.m_Weight.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PositionConstraint {
    // extends IConstraint
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Active: Option<bool>,
    pub m_AffectTranslationX: Option<bool>,
    pub m_AffectTranslationY: Option<bool>,
    pub m_AffectTranslationZ: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IsContraintActive: Option<bool>,
    pub m_Sources: Option<Vec<ConstraintSource>>,
    pub m_TranslationAtRest: Option<Vector3>,
    pub m_TranslationOffset: Option<Vector3>,
    pub m_Weight: Option<f32>,
}

impl_object!(PositionConstraint);

impl Clone for PositionConstraint {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Active: self.m_Active.clone(),
            m_AffectTranslationX: self.m_AffectTranslationX.clone(),
            m_AffectTranslationY: self.m_AffectTranslationY.clone(),
            m_AffectTranslationZ: self.m_AffectTranslationZ.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IsContraintActive: self.m_IsContraintActive.clone(),
            m_Sources: self.m_Sources.clone(),
            m_TranslationAtRest: self.m_TranslationAtRest.clone(),
            m_TranslationOffset: self.m_TranslationOffset.clone(),
            m_Weight: self.m_Weight.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RotationConstraint {
    // extends IConstraint
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Active: Option<bool>,
    pub m_AffectRotationX: Option<bool>,
    pub m_AffectRotationY: Option<bool>,
    pub m_AffectRotationZ: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IsContraintActive: Option<bool>,
    pub m_RotationAtRest: Option<Vector3>,
    pub m_RotationOffset: Option<Vector3>,
    pub m_Sources: Option<Vec<ConstraintSource>>,
    pub m_Weight: Option<f32>,
}

impl_object!(RotationConstraint);

impl Clone for RotationConstraint {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Active: self.m_Active.clone(),
            m_AffectRotationX: self.m_AffectRotationX.clone(),
            m_AffectRotationY: self.m_AffectRotationY.clone(),
            m_AffectRotationZ: self.m_AffectRotationZ.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IsContraintActive: self.m_IsContraintActive.clone(),
            m_RotationAtRest: self.m_RotationAtRest.clone(),
            m_RotationOffset: self.m_RotationOffset.clone(),
            m_Sources: self.m_Sources.clone(),
            m_Weight: self.m_Weight.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ScaleConstraint {
    // extends IConstraint
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Active: Option<bool>,
    pub m_AffectScalingX: Option<bool>,
    pub m_AffectScalingY: Option<bool>,
    pub m_AffectScalingZ: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IsContraintActive: Option<bool>,
    pub m_ScaleAtRest: Option<Vector3>,
    pub m_ScaleOffset: Option<Vector3>,
    pub m_Sources: Option<Vec<ConstraintSource>>,
    pub m_Weight: Option<f32>,
}

impl_object!(ScaleConstraint);

impl Clone for ScaleConstraint {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Active: self.m_Active.clone(),
            m_AffectScalingX: self.m_AffectScalingX.clone(),
            m_AffectScalingY: self.m_AffectScalingY.clone(),
            m_AffectScalingZ: self.m_AffectScalingZ.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IsContraintActive: self.m_IsContraintActive.clone(),
            m_ScaleAtRest: self.m_ScaleAtRest.clone(),
            m_ScaleOffset: self.m_ScaleOffset.clone(),
            m_Sources: self.m_Sources.clone(),
            m_Weight: self.m_Weight.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Joint2D {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(Joint2D);

impl Clone for Joint2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnchoredJoint2D {
    // extends Joint2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(AnchoredJoint2D);

impl Clone for AnchoredJoint2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DistanceJoint2D {
    // extends AnchoredJoint2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Anchor: Option<Vector2>,
    pub m_AutoConfigureConnectedAnchor: Option<bool>,
    pub m_AutoConfigureDistance: Option<bool>,
    pub m_BreakAction: Option<i32>,
    pub m_BreakForce: Option<f32>,
    pub m_BreakTorque: Option<f32>,
    pub m_CollideConnected: Option<bool>,
    pub m_ConnectedAnchor: Option<Vector2>,
    pub m_ConnectedRigidBody: Option<PPtrData<Rigidbody2D>>,
    pub m_Distance: Option<f32>,
    pub m_EnableCollision: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_MaxDistanceOnly: Option<bool>,
}

impl_object!(DistanceJoint2D);

impl Clone for DistanceJoint2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Anchor: self.m_Anchor.clone(),
            m_AutoConfigureConnectedAnchor: self.m_AutoConfigureConnectedAnchor.clone(),
            m_AutoConfigureDistance: self.m_AutoConfigureDistance.clone(),
            m_BreakAction: self.m_BreakAction.clone(),
            m_BreakForce: self.m_BreakForce.clone(),
            m_BreakTorque: self.m_BreakTorque.clone(),
            m_CollideConnected: self.m_CollideConnected.clone(),
            m_ConnectedAnchor: self.m_ConnectedAnchor.clone(),
            m_ConnectedRigidBody: self.m_ConnectedRigidBody.clone(),
            m_Distance: self.m_Distance.clone(),
            m_EnableCollision: self.m_EnableCollision.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_MaxDistanceOnly: self.m_MaxDistanceOnly.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct FixedJoint2D {
    // extends AnchoredJoint2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Anchor: Option<Vector2>,
    pub m_AutoConfigureConnectedAnchor: Option<bool>,
    pub m_BreakAction: Option<i32>,
    pub m_BreakForce: Option<f32>,
    pub m_BreakTorque: Option<f32>,
    pub m_ConnectedAnchor: Option<Vector2>,
    pub m_ConnectedRigidBody: Option<PPtrData<Rigidbody2D>>,
    pub m_DampingRatio: Option<f32>,
    pub m_EnableCollision: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_Frequency: Option<f32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(FixedJoint2D);

impl Clone for FixedJoint2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Anchor: self.m_Anchor.clone(),
            m_AutoConfigureConnectedAnchor: self.m_AutoConfigureConnectedAnchor.clone(),
            m_BreakAction: self.m_BreakAction.clone(),
            m_BreakForce: self.m_BreakForce.clone(),
            m_BreakTorque: self.m_BreakTorque.clone(),
            m_ConnectedAnchor: self.m_ConnectedAnchor.clone(),
            m_ConnectedRigidBody: self.m_ConnectedRigidBody.clone(),
            m_DampingRatio: self.m_DampingRatio.clone(),
            m_EnableCollision: self.m_EnableCollision.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_Frequency: self.m_Frequency.clone(),
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct FrictionJoint2D {
    // extends AnchoredJoint2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Anchor: Option<Vector2>,
    pub m_AutoConfigureConnectedAnchor: Option<bool>,
    pub m_BreakAction: Option<i32>,
    pub m_BreakForce: Option<f32>,
    pub m_BreakTorque: Option<f32>,
    pub m_ConnectedAnchor: Option<Vector2>,
    pub m_ConnectedRigidBody: Option<PPtrData<Rigidbody2D>>,
    pub m_EnableCollision: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_MaxForce: Option<f32>,
    pub m_MaxTorque: Option<f32>,
}

impl_object!(FrictionJoint2D);

impl Clone for FrictionJoint2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Anchor: self.m_Anchor.clone(),
            m_AutoConfigureConnectedAnchor: self.m_AutoConfigureConnectedAnchor.clone(),
            m_BreakAction: self.m_BreakAction.clone(),
            m_BreakForce: self.m_BreakForce.clone(),
            m_BreakTorque: self.m_BreakTorque.clone(),
            m_ConnectedAnchor: self.m_ConnectedAnchor.clone(),
            m_ConnectedRigidBody: self.m_ConnectedRigidBody.clone(),
            m_EnableCollision: self.m_EnableCollision.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_MaxForce: self.m_MaxForce.clone(),
            m_MaxTorque: self.m_MaxTorque.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HingeJoint2D {
    // extends AnchoredJoint2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Anchor: Option<Vector2>,
    pub m_AngleLimits: Option<JointAngleLimit2D>,
    pub m_AutoConfigureConnectedAnchor: Option<bool>,
    pub m_BreakAction: Option<i32>,
    pub m_BreakForce: Option<f32>,
    pub m_BreakTorque: Option<f32>,
    pub m_CollideConnected: Option<bool>,
    pub m_ConnectedAnchor: Option<Vector2>,
    pub m_ConnectedRigidBody: Option<PPtrData<Rigidbody2D>>,
    pub m_EnableCollision: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Motor: Option<JointMotor2D>,
    pub m_UseConnectedAnchor: Option<bool>,
    pub m_UseLimits: Option<bool>,
    pub m_UseMotor: Option<bool>,
}

impl_object!(HingeJoint2D);

impl Clone for HingeJoint2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Anchor: self.m_Anchor.clone(),
            m_AngleLimits: self.m_AngleLimits.clone(),
            m_AutoConfigureConnectedAnchor: self.m_AutoConfigureConnectedAnchor.clone(),
            m_BreakAction: self.m_BreakAction.clone(),
            m_BreakForce: self.m_BreakForce.clone(),
            m_BreakTorque: self.m_BreakTorque.clone(),
            m_CollideConnected: self.m_CollideConnected.clone(),
            m_ConnectedAnchor: self.m_ConnectedAnchor.clone(),
            m_ConnectedRigidBody: self.m_ConnectedRigidBody.clone(),
            m_EnableCollision: self.m_EnableCollision.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Motor: self.m_Motor.clone(),
            m_UseConnectedAnchor: self.m_UseConnectedAnchor.clone(),
            m_UseLimits: self.m_UseLimits.clone(),
            m_UseMotor: self.m_UseMotor.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SliderJoint2D {
    // extends AnchoredJoint2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Anchor: Option<Vector2>,
    pub m_Angle: Option<f32>,
    pub m_AutoConfigureAngle: Option<bool>,
    pub m_AutoConfigureConnectedAnchor: Option<bool>,
    pub m_BreakAction: Option<i32>,
    pub m_BreakForce: Option<f32>,
    pub m_BreakTorque: Option<f32>,
    pub m_CollideConnected: Option<bool>,
    pub m_ConnectedAnchor: Option<Vector2>,
    pub m_ConnectedRigidBody: Option<PPtrData<Rigidbody2D>>,
    pub m_EnableCollision: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Motor: Option<JointMotor2D>,
    pub m_TranslationLimits: Option<JointTranslationLimits2D>,
    pub m_UseLimits: Option<bool>,
    pub m_UseMotor: Option<bool>,
}

impl_object!(SliderJoint2D);

impl Clone for SliderJoint2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Anchor: self.m_Anchor.clone(),
            m_Angle: self.m_Angle.clone(),
            m_AutoConfigureAngle: self.m_AutoConfigureAngle.clone(),
            m_AutoConfigureConnectedAnchor: self.m_AutoConfigureConnectedAnchor.clone(),
            m_BreakAction: self.m_BreakAction.clone(),
            m_BreakForce: self.m_BreakForce.clone(),
            m_BreakTorque: self.m_BreakTorque.clone(),
            m_CollideConnected: self.m_CollideConnected.clone(),
            m_ConnectedAnchor: self.m_ConnectedAnchor.clone(),
            m_ConnectedRigidBody: self.m_ConnectedRigidBody.clone(),
            m_EnableCollision: self.m_EnableCollision.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Motor: self.m_Motor.clone(),
            m_TranslationLimits: self.m_TranslationLimits.clone(),
            m_UseLimits: self.m_UseLimits.clone(),
            m_UseMotor: self.m_UseMotor.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpringJoint2D {
    // extends AnchoredJoint2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Anchor: Option<Vector2>,
    pub m_AutoConfigureConnectedAnchor: Option<bool>,
    pub m_AutoConfigureDistance: Option<bool>,
    pub m_BreakAction: Option<i32>,
    pub m_BreakForce: Option<f32>,
    pub m_BreakTorque: Option<f32>,
    pub m_CollideConnected: Option<bool>,
    pub m_ConnectedAnchor: Option<Vector2>,
    pub m_ConnectedRigidBody: Option<PPtrData<Rigidbody2D>>,
    pub m_DampingRatio: Option<f32>,
    pub m_Distance: Option<f32>,
    pub m_EnableCollision: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_Frequency: Option<f32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(SpringJoint2D);

impl Clone for SpringJoint2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Anchor: self.m_Anchor.clone(),
            m_AutoConfigureConnectedAnchor: self.m_AutoConfigureConnectedAnchor.clone(),
            m_AutoConfigureDistance: self.m_AutoConfigureDistance.clone(),
            m_BreakAction: self.m_BreakAction.clone(),
            m_BreakForce: self.m_BreakForce.clone(),
            m_BreakTorque: self.m_BreakTorque.clone(),
            m_CollideConnected: self.m_CollideConnected.clone(),
            m_ConnectedAnchor: self.m_ConnectedAnchor.clone(),
            m_ConnectedRigidBody: self.m_ConnectedRigidBody.clone(),
            m_DampingRatio: self.m_DampingRatio.clone(),
            m_Distance: self.m_Distance.clone(),
            m_EnableCollision: self.m_EnableCollision.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_Frequency: self.m_Frequency.clone(),
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct WheelJoint2D {
    // extends AnchoredJoint2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Anchor: Option<Vector2>,
    pub m_AutoConfigureConnectedAnchor: Option<bool>,
    pub m_BreakAction: Option<i32>,
    pub m_BreakForce: Option<f32>,
    pub m_BreakTorque: Option<f32>,
    pub m_CollideConnected: Option<bool>,
    pub m_ConnectedAnchor: Option<Vector2>,
    pub m_ConnectedRigidBody: Option<PPtrData<Rigidbody2D>>,
    pub m_EnableCollision: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Motor: Option<JointMotor2D>,
    pub m_Suspension: Option<JointSuspension2D>,
    pub m_UseMotor: Option<bool>,
}

impl_object!(WheelJoint2D);

impl Clone for WheelJoint2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Anchor: self.m_Anchor.clone(),
            m_AutoConfigureConnectedAnchor: self.m_AutoConfigureConnectedAnchor.clone(),
            m_BreakAction: self.m_BreakAction.clone(),
            m_BreakForce: self.m_BreakForce.clone(),
            m_BreakTorque: self.m_BreakTorque.clone(),
            m_CollideConnected: self.m_CollideConnected.clone(),
            m_ConnectedAnchor: self.m_ConnectedAnchor.clone(),
            m_ConnectedRigidBody: self.m_ConnectedRigidBody.clone(),
            m_EnableCollision: self.m_EnableCollision.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Motor: self.m_Motor.clone(),
            m_Suspension: self.m_Suspension.clone(),
            m_UseMotor: self.m_UseMotor.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RelativeJoint2D {
    // extends Joint2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AngularOffset: Option<f32>,
    pub m_AutoConfigureOffset: Option<bool>,
    pub m_BreakAction: Option<i32>,
    pub m_BreakForce: Option<f32>,
    pub m_BreakTorque: Option<f32>,
    pub m_ConnectedRigidBody: Option<PPtrData<Rigidbody2D>>,
    pub m_CorrectionScale: Option<f32>,
    pub m_EnableCollision: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LinearOffset: Option<Vector2>,
    pub m_MaxForce: Option<f32>,
    pub m_MaxTorque: Option<f32>,
}

impl_object!(RelativeJoint2D);

impl Clone for RelativeJoint2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AngularOffset: self.m_AngularOffset.clone(),
            m_AutoConfigureOffset: self.m_AutoConfigureOffset.clone(),
            m_BreakAction: self.m_BreakAction.clone(),
            m_BreakForce: self.m_BreakForce.clone(),
            m_BreakTorque: self.m_BreakTorque.clone(),
            m_ConnectedRigidBody: self.m_ConnectedRigidBody.clone(),
            m_CorrectionScale: self.m_CorrectionScale.clone(),
            m_EnableCollision: self.m_EnableCollision.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LinearOffset: self.m_LinearOffset.clone(),
            m_MaxForce: self.m_MaxForce.clone(),
            m_MaxTorque: self.m_MaxTorque.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TargetJoint2D {
    // extends Joint2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Anchor: Option<Vector2>,
    pub m_AutoConfigureTarget: Option<bool>,
    pub m_BreakAction: Option<i32>,
    pub m_BreakForce: Option<f32>,
    pub m_BreakTorque: Option<f32>,
    pub m_ConnectedRigidBody: Option<PPtrData<Rigidbody2D>>,
    pub m_DampingRatio: Option<f32>,
    pub m_EnableCollision: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_Frequency: Option<f32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_MaxForce: Option<f32>,
    pub m_Target: Option<Vector2>,
}

impl_object!(TargetJoint2D);

impl Clone for TargetJoint2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Anchor: self.m_Anchor.clone(),
            m_AutoConfigureTarget: self.m_AutoConfigureTarget.clone(),
            m_BreakAction: self.m_BreakAction.clone(),
            m_BreakForce: self.m_BreakForce.clone(),
            m_BreakTorque: self.m_BreakTorque.clone(),
            m_ConnectedRigidBody: self.m_ConnectedRigidBody.clone(),
            m_DampingRatio: self.m_DampingRatio.clone(),
            m_EnableCollision: self.m_EnableCollision.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_Frequency: self.m_Frequency.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_MaxForce: self.m_MaxForce.clone(),
            m_Target: self.m_Target.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LensFlare {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Brightness: Option<f32>,
    pub m_Color: Option<Color>,
    pub m_Directional: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_FadeSpeed: Option<f32>,
    pub m_Flare: Option<PPtrData<Flare>>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IgnoreLayers: Option<BitField>,
}

impl_object!(LensFlare);

impl Clone for LensFlare {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Brightness: self.m_Brightness.clone(),
            m_Color: self.m_Color.clone(),
            m_Directional: self.m_Directional.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_FadeSpeed: self.m_FadeSpeed.clone(),
            m_Flare: self.m_Flare.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IgnoreLayers: self.m_IgnoreLayers.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Light {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ActuallyLightmapped: Option<bool>,
    pub m_AreaSize: Option<Vector2>,
    pub m_BakedIndex: Option<i32>,
    pub m_BakingOutput: Option<LightBakingOutput>,
    pub m_BounceIntensity: Option<f32>,
    pub m_BoundingSphereOverride: Option<Vector4>,
    pub m_CCT: Option<f32>,
    pub m_Color: Option<Color>,
    pub m_ColorTemperature: Option<f32>,
    pub m_Cookie: Option<PPtrData<Texture>>,
    pub m_CookieSize: Option<f32>,
    pub m_CullingMask: Option<BitField>,
    pub m_DrawHalo: Option<bool>,
    pub m_EnableSpotReflector: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_FalloffTable: Option<FalloffTable>,
    pub m_Flare: Option<PPtrData<Flare>>,
    pub m_ForceVisible: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_InnerSpotAngle: Option<f32>,
    pub m_Intensity: Option<f32>,
    pub m_LightShadowCasterMode: Option<i32>,
    pub m_LightUnit: Option<i32>,
    pub m_Lightmapping: Option<i32>,
    pub m_LuxAtDistance: Option<f32>,
    pub m_Range: Option<f32>,
    pub m_RenderMode: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_Shadows: Option<ShadowSettings>,
    pub m_Shape: Option<i32>,
    pub m_SpotAngle: Option<f32>,
    pub m_Type: Option<i32>,
    pub m_UseBoundingSphereOverride: Option<bool>,
    pub m_UseColorTemperature: Option<bool>,
    pub m_UseViewFrustumForShadowCasterCull: Option<bool>,
}

impl_object!(Light);

impl Clone for Light {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ActuallyLightmapped: self.m_ActuallyLightmapped.clone(),
            m_AreaSize: self.m_AreaSize.clone(),
            m_BakedIndex: self.m_BakedIndex.clone(),
            m_BakingOutput: self.m_BakingOutput.clone(),
            m_BounceIntensity: self.m_BounceIntensity.clone(),
            m_BoundingSphereOverride: self.m_BoundingSphereOverride.clone(),
            m_CCT: self.m_CCT.clone(),
            m_Color: self.m_Color.clone(),
            m_ColorTemperature: self.m_ColorTemperature.clone(),
            m_Cookie: self.m_Cookie.clone(),
            m_CookieSize: self.m_CookieSize.clone(),
            m_CullingMask: self.m_CullingMask.clone(),
            m_DrawHalo: self.m_DrawHalo.clone(),
            m_EnableSpotReflector: self.m_EnableSpotReflector.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_FalloffTable: self.m_FalloffTable.clone(),
            m_Flare: self.m_Flare.clone(),
            m_ForceVisible: self.m_ForceVisible.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_InnerSpotAngle: self.m_InnerSpotAngle.clone(),
            m_Intensity: self.m_Intensity.clone(),
            m_LightShadowCasterMode: self.m_LightShadowCasterMode.clone(),
            m_LightUnit: self.m_LightUnit.clone(),
            m_Lightmapping: self.m_Lightmapping.clone(),
            m_LuxAtDistance: self.m_LuxAtDistance.clone(),
            m_Range: self.m_Range.clone(),
            m_RenderMode: self.m_RenderMode.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_Shadows: self.m_Shadows.clone(),
            m_Shape: self.m_Shape.clone(),
            m_SpotAngle: self.m_SpotAngle.clone(),
            m_Type: self.m_Type.clone(),
            m_UseBoundingSphereOverride: self.m_UseBoundingSphereOverride.clone(),
            m_UseColorTemperature: self.m_UseColorTemperature.clone(),
            m_UseViewFrustumForShadowCasterCull: self.m_UseViewFrustumForShadowCasterCull.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LightProbeGroup {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(LightProbeGroup);

impl Clone for LightProbeGroup {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LightProbeProxyVolume {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BoundingBoxMode: Option<i32>,
    pub m_BoundingBoxOrigin: Option<Vector3>,
    pub m_BoundingBoxSize: Option<Vector3>,
    pub m_DataFormat: Option<i32>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_ProbePositionMode: Option<i32>,
    pub m_QualityMode: Option<i32>,
    pub m_RefreshMode: Option<i32>,
    pub m_ResolutionMode: Option<i32>,
    pub m_ResolutionProbesPerUnit: Option<f32>,
    pub m_ResolutionX: Option<u32>,
    pub m_ResolutionY: Option<u32>,
    pub m_ResolutionZ: Option<u32>,
}

impl_object!(LightProbeProxyVolume);

impl Clone for LightProbeProxyVolume {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BoundingBoxMode: self.m_BoundingBoxMode.clone(),
            m_BoundingBoxOrigin: self.m_BoundingBoxOrigin.clone(),
            m_BoundingBoxSize: self.m_BoundingBoxSize.clone(),
            m_DataFormat: self.m_DataFormat.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_ProbePositionMode: self.m_ProbePositionMode.clone(),
            m_QualityMode: self.m_QualityMode.clone(),
            m_RefreshMode: self.m_RefreshMode.clone(),
            m_ResolutionMode: self.m_ResolutionMode.clone(),
            m_ResolutionProbesPerUnit: self.m_ResolutionProbesPerUnit.clone(),
            m_ResolutionX: self.m_ResolutionX.clone(),
            m_ResolutionY: self.m_ResolutionY.clone(),
            m_ResolutionZ: self.m_ResolutionZ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MonoBehaviour {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Name: Option<String>,
    pub m_Script: Option<PPtrData<MonoScript>>,
}

impl_object!(MonoBehaviour);

impl Clone for MonoBehaviour {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Name: self.m_Name.clone(),
            m_Script: self.m_Script.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NavMeshAgent {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub avoidancePriority: Option<i32>,
    pub m_Acceleration: Option<f32>,
    pub m_AgentTypeID: Option<i32>,
    pub m_AngularSpeed: Option<f32>,
    pub m_AutoBraking: Option<bool>,
    pub m_AutoRepath: Option<bool>,
    pub m_AutoTraverseOffMeshLink: Option<bool>,
    pub m_BaseOffset: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Height: Option<f32>,
    pub m_ObstacleAvoidanceType: Option<i32>,
    pub m_Radius: Option<f32>,
    pub m_Speed: Option<f32>,
    pub m_StoppingDistance: Option<f32>,
    pub m_WalkableMask: Option<u32>,
}

impl_object!(NavMeshAgent);

impl Clone for NavMeshAgent {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            avoidancePriority: self.avoidancePriority.clone(),
            m_Acceleration: self.m_Acceleration.clone(),
            m_AgentTypeID: self.m_AgentTypeID.clone(),
            m_AngularSpeed: self.m_AngularSpeed.clone(),
            m_AutoBraking: self.m_AutoBraking.clone(),
            m_AutoRepath: self.m_AutoRepath.clone(),
            m_AutoTraverseOffMeshLink: self.m_AutoTraverseOffMeshLink.clone(),
            m_BaseOffset: self.m_BaseOffset.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Height: self.m_Height.clone(),
            m_ObstacleAvoidanceType: self.m_ObstacleAvoidanceType.clone(),
            m_Radius: self.m_Radius.clone(),
            m_Speed: self.m_Speed.clone(),
            m_StoppingDistance: self.m_StoppingDistance.clone(),
            m_WalkableMask: self.m_WalkableMask.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NavMeshObstacle {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Carve: Option<bool>,
    pub m_CarveOnlyStationary: Option<bool>,
    pub m_Center: Option<Vector3>,
    pub m_Enabled: Option<u8>,
    pub m_Extents: Option<Vector3>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Height: Option<f32>,
    pub m_MoveThreshold: Option<f32>,
    pub m_Radius: Option<f32>,
    pub m_Shape: Option<i32>,
    pub m_TimeToStationary: Option<f32>,
}

impl_object!(NavMeshObstacle);

impl Clone for NavMeshObstacle {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Carve: self.m_Carve.clone(),
            m_CarveOnlyStationary: self.m_CarveOnlyStationary.clone(),
            m_Center: self.m_Center.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_Extents: self.m_Extents.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Height: self.m_Height.clone(),
            m_MoveThreshold: self.m_MoveThreshold.clone(),
            m_Radius: self.m_Radius.clone(),
            m_Shape: self.m_Shape.clone(),
            m_TimeToStationary: self.m_TimeToStationary.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NetworkView {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Observed: Option<PPtrData<Component>>,
    pub m_StateSynchronization: Option<i32>,
    pub m_ViewID: Option<NetworkViewID>,
}

impl_object!(NetworkView);

impl Clone for NetworkView {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Observed: self.m_Observed.clone(),
            m_StateSynchronization: self.m_StateSynchronization.clone(),
            m_ViewID: self.m_ViewID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct OffMeshLink {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Activated: Option<bool>,
    pub m_AgentTypeID: Option<i32>,
    pub m_AreaIndex: Option<u32>,
    pub m_AutoUpdatePositions: Option<bool>,
    pub m_BiDirectional: Option<bool>,
    pub m_CostOverride: Option<f32>,
    pub m_DtPolyRef: Option<u32>,
    pub m_Enabled: Option<u8>,
    pub m_End: Option<PPtrData<Transform>>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_NavMeshLayer: Option<u32>,
    pub m_Start: Option<PPtrData<Transform>>,
}

impl_object!(OffMeshLink);

impl Clone for OffMeshLink {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Activated: self.m_Activated.clone(),
            m_AgentTypeID: self.m_AgentTypeID.clone(),
            m_AreaIndex: self.m_AreaIndex.clone(),
            m_AutoUpdatePositions: self.m_AutoUpdatePositions.clone(),
            m_BiDirectional: self.m_BiDirectional.clone(),
            m_CostOverride: self.m_CostOverride.clone(),
            m_DtPolyRef: self.m_DtPolyRef.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_End: self.m_End.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_NavMeshLayer: self.m_NavMeshLayer.clone(),
            m_Start: self.m_Start.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ParticleSystemForceField {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Parameters: Option<ParticleSystemForceFieldParameters>,
}

impl_object!(ParticleSystemForceField);

impl Clone for ParticleSystemForceField {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Parameters: self.m_Parameters.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PhysicsUpdateBehaviour2D {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(PhysicsUpdateBehaviour2D);

impl Clone for PhysicsUpdateBehaviour2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ConstantForce2D {
    // extends PhysicsUpdateBehaviour2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<u8>,
    pub m_Force: Option<Vector2>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_RelativeForce: Option<Vector2>,
    pub m_Torque: Option<f32>,
}

impl_object!(ConstantForce2D);

impl Clone for ConstantForce2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_Force: self.m_Force.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_RelativeForce: self.m_RelativeForce.clone(),
            m_Torque: self.m_Torque.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PlayableDirector {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DirectorUpdateMode: Option<i32>,
    pub m_Enabled: Option<u8>,
    pub m_ExposedReferences: Option<ExposedReferenceTable>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_InitialState: Option<i32>,
    pub m_InitialTime: Option<f64>,
    pub m_PlayableAsset: Option<PPtrData<Object>>,
    pub m_SceneBindings: Option<Vec<DirectorGenericBinding>>,
    pub m_WrapMode: Option<i32>,
}

impl_object!(PlayableDirector);

impl Clone for PlayableDirector {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DirectorUpdateMode: self.m_DirectorUpdateMode.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExposedReferences: self.m_ExposedReferences.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_InitialState: self.m_InitialState.clone(),
            m_InitialTime: self.m_InitialTime.clone(),
            m_PlayableAsset: self.m_PlayableAsset.clone(),
            m_SceneBindings: self.m_SceneBindings.clone(),
            m_WrapMode: self.m_WrapMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Projector {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AspectRatio: Option<f32>,
    pub m_Enabled: Option<u8>,
    pub m_FarClipPlane: Option<f32>,
    pub m_FieldOfView: Option<f32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IgnoreLayers: Option<BitField>,
    pub m_Material: Option<PPtrData<Material>>,
    pub m_NearClipPlane: Option<f32>,
    pub m_Orthographic: Option<bool>,
    pub m_OrthographicSize: Option<f32>,
}

impl_object!(Projector);

impl Clone for Projector {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AspectRatio: self.m_AspectRatio.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_FarClipPlane: self.m_FarClipPlane.clone(),
            m_FieldOfView: self.m_FieldOfView.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IgnoreLayers: self.m_IgnoreLayers.clone(),
            m_Material: self.m_Material.clone(),
            m_NearClipPlane: self.m_NearClipPlane.clone(),
            m_Orthographic: self.m_Orthographic.clone(),
            m_OrthographicSize: self.m_OrthographicSize.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ReflectionProbe {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BackGroundColor: Option<Color>,
    pub m_BakedTexture: Option<PPtrData<Texture>>,
    pub m_BlendDistance: Option<f32>,
    pub m_BoxOffset: Option<Vector3>,
    pub m_BoxProjection: Option<bool>,
    pub m_BoxSize: Option<Vector3>,
    pub m_ClearFlags: Option<u32>,
    pub m_CullingMask: Option<BitField>,
    pub m_CustomBakedTexture: Option<PPtrData<Texture>>,
    pub m_Enabled: Option<u8>,
    pub m_FarClip: Option<f32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_HDR: Option<bool>,
    pub m_Importance: Option<i16>,
    pub m_IntensityMultiplier: Option<f32>,
    pub m_Mode: Option<i32>,
    pub m_NearClip: Option<f32>,
    pub m_RefreshMode: Option<i32>,
    pub m_RenderDynamicObjects: Option<bool>,
    pub m_Resolution: Option<i32>,
    pub m_ShadowDistance: Option<f32>,
    pub m_TimeSlicingMode: Option<i32>,
    pub m_Type: Option<i32>,
    pub m_UpdateFrequency: Option<i32>,
    pub m_UseOcclusionCulling: Option<bool>,
}

impl_object!(ReflectionProbe);

impl Clone for ReflectionProbe {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BackGroundColor: self.m_BackGroundColor.clone(),
            m_BakedTexture: self.m_BakedTexture.clone(),
            m_BlendDistance: self.m_BlendDistance.clone(),
            m_BoxOffset: self.m_BoxOffset.clone(),
            m_BoxProjection: self.m_BoxProjection.clone(),
            m_BoxSize: self.m_BoxSize.clone(),
            m_ClearFlags: self.m_ClearFlags.clone(),
            m_CullingMask: self.m_CullingMask.clone(),
            m_CustomBakedTexture: self.m_CustomBakedTexture.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_FarClip: self.m_FarClip.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_HDR: self.m_HDR.clone(),
            m_Importance: self.m_Importance.clone(),
            m_IntensityMultiplier: self.m_IntensityMultiplier.clone(),
            m_Mode: self.m_Mode.clone(),
            m_NearClip: self.m_NearClip.clone(),
            m_RefreshMode: self.m_RefreshMode.clone(),
            m_RenderDynamicObjects: self.m_RenderDynamicObjects.clone(),
            m_Resolution: self.m_Resolution.clone(),
            m_ShadowDistance: self.m_ShadowDistance.clone(),
            m_TimeSlicingMode: self.m_TimeSlicingMode.clone(),
            m_Type: self.m_Type.clone(),
            m_UpdateFrequency: self.m_UpdateFrequency.clone(),
            m_UseOcclusionCulling: self.m_UseOcclusionCulling.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Skybox {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CustomSkybox: Option<PPtrData<Material>>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(Skybox);

impl Clone for Skybox {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CustomSkybox: self.m_CustomSkybox.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SortingGroup {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_SortAtRoot: Option<bool>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
}

impl_object!(SortingGroup);

impl Clone for SortingGroup {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_SortAtRoot: self.m_SortAtRoot.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct StreamingController {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_StreamingMipmapBias: Option<f32>,
}

impl_object!(StreamingController);

impl Clone for StreamingController {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_StreamingMipmapBias: self.m_StreamingMipmapBias.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Terrain {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AllowAutoConnect: Option<bool>,
    pub m_BakeLightProbesForTrees: Option<bool>,
    pub m_CastShadows: Option<bool>,
    pub m_ChunkDynamicUVST: Option<Vector4>,
    pub m_DefaultSmoothness: Option<f32>,
    pub m_DetailObjectDensity: Option<f32>,
    pub m_DetailObjectDistance: Option<f32>,
    pub m_DrawHeightmap: Option<bool>,
    pub m_DrawInstanced: Option<bool>,
    pub m_DrawTreesAndFoliage: Option<bool>,
    pub m_DynamicUVST: Option<Vector4>,
    pub m_EnableHeightmapRayTracing: Option<bool>,
    pub m_EnableTreesAndDetailsRayTracing: Option<bool>,
    pub m_Enabled: Option<u8>,
    pub m_ExplicitProbeSetHash: Option<Hash128>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_GroupingID: Option<i32>,
    pub m_HeightmapMaximumLOD: Option<i32>,
    pub m_HeightmapMinimumLODSimplification: Option<i32>,
    pub m_HeightmapPixelError: Option<f32>,
    pub m_IgnoreQualitySettings: Option<bool>,
    pub m_LegacyShininess: Option<f32>,
    pub m_LegacySpecular: Option<Color>,
    pub m_LightmapIndex: Option<u16>,
    pub m_LightmapIndexDynamic: Option<u16>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_LightmapTilingOffsetDynamic: Option<Vector4>,
    pub m_MaterialTemplate: Option<PPtrData<Material>>,
    pub m_MaterialType: Option<i32>,
    pub m_PreserveTreePrototypeLayers: Option<bool>,
    pub m_ReflectionProbeUsage: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_ShadowCastingMode: Option<i32>,
    pub m_SplatMapDistance: Option<f32>,
    pub m_StaticShadowCaster: Option<bool>,
    pub m_TerrainData: Option<PPtrData<TerrainData>>,
    pub m_TreeBillboardDistance: Option<f32>,
    pub m_TreeCrossFadeLength: Option<f32>,
    pub m_TreeDistance: Option<f32>,
    pub m_TreeMaximumFullLODCount: Option<i32>,
    pub m_TreeMotionVectorModeOverride: Option<i32>,
    pub m_UseDefaultSmoothness: Option<bool>,
}

impl_object!(Terrain);

impl Clone for Terrain {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AllowAutoConnect: self.m_AllowAutoConnect.clone(),
            m_BakeLightProbesForTrees: self.m_BakeLightProbesForTrees.clone(),
            m_CastShadows: self.m_CastShadows.clone(),
            m_ChunkDynamicUVST: self.m_ChunkDynamicUVST.clone(),
            m_DefaultSmoothness: self.m_DefaultSmoothness.clone(),
            m_DetailObjectDensity: self.m_DetailObjectDensity.clone(),
            m_DetailObjectDistance: self.m_DetailObjectDistance.clone(),
            m_DrawHeightmap: self.m_DrawHeightmap.clone(),
            m_DrawInstanced: self.m_DrawInstanced.clone(),
            m_DrawTreesAndFoliage: self.m_DrawTreesAndFoliage.clone(),
            m_DynamicUVST: self.m_DynamicUVST.clone(),
            m_EnableHeightmapRayTracing: self.m_EnableHeightmapRayTracing.clone(),
            m_EnableTreesAndDetailsRayTracing: self.m_EnableTreesAndDetailsRayTracing.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExplicitProbeSetHash: self.m_ExplicitProbeSetHash.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_GroupingID: self.m_GroupingID.clone(),
            m_HeightmapMaximumLOD: self.m_HeightmapMaximumLOD.clone(),
            m_HeightmapMinimumLODSimplification: self.m_HeightmapMinimumLODSimplification.clone(),
            m_HeightmapPixelError: self.m_HeightmapPixelError.clone(),
            m_IgnoreQualitySettings: self.m_IgnoreQualitySettings.clone(),
            m_LegacyShininess: self.m_LegacyShininess.clone(),
            m_LegacySpecular: self.m_LegacySpecular.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapIndexDynamic: self.m_LightmapIndexDynamic.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_LightmapTilingOffsetDynamic: self.m_LightmapTilingOffsetDynamic.clone(),
            m_MaterialTemplate: self.m_MaterialTemplate.clone(),
            m_MaterialType: self.m_MaterialType.clone(),
            m_PreserveTreePrototypeLayers: self.m_PreserveTreePrototypeLayers.clone(),
            m_ReflectionProbeUsage: self.m_ReflectionProbeUsage.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_ShadowCastingMode: self.m_ShadowCastingMode.clone(),
            m_SplatMapDistance: self.m_SplatMapDistance.clone(),
            m_StaticShadowCaster: self.m_StaticShadowCaster.clone(),
            m_TerrainData: self.m_TerrainData.clone(),
            m_TreeBillboardDistance: self.m_TreeBillboardDistance.clone(),
            m_TreeCrossFadeLength: self.m_TreeCrossFadeLength.clone(),
            m_TreeDistance: self.m_TreeDistance.clone(),
            m_TreeMaximumFullLODCount: self.m_TreeMaximumFullLODCount.clone(),
            m_TreeMotionVectorModeOverride: self.m_TreeMotionVectorModeOverride.clone(),
            m_UseDefaultSmoothness: self.m_UseDefaultSmoothness.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VideoPlayer {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AspectRatio: Option<i32>,
    pub m_AudioOutputMode: Option<i32>,
    pub m_ControlledAudioTrackCount: Option<u16>,
    pub m_DataSource: Option<i32>,
    pub m_DirectAudioMutes: Option<Vec<bool>>,
    pub m_DirectAudioVolumes: Option<Vec<f32>>,
    pub m_Enabled: Option<u8>,
    pub m_EnabledAudioTracks: Option<Vec<bool>>,
    pub m_FrameReadyEventEnabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Looping: Option<bool>,
    pub m_PlayOnAwake: Option<bool>,
    pub m_PlaybackSpeed: Option<f32>,
    pub m_RenderMode: Option<i32>,
    pub m_SkipOnDrop: Option<bool>,
    pub m_TargetAudioSources: Option<Vec<PPtrData<AudioSource>>>,
    pub m_TargetCamera: Option<PPtrData<Camera>>,
    pub m_TargetCamera3DLayout: Option<i32>,
    pub m_TargetCameraAlpha: Option<f32>,
    pub m_TargetMaterialName: Option<String>,
    pub m_TargetMaterialProperty: Option<String>,
    pub m_TargetMaterialRenderer: Option<PPtrData<Renderer>>,
    pub m_TargetTexture: Option<PPtrData<RenderTexture>>,
    pub m_TimeReference: Option<i32>,
    pub m_TimeUpdateMode: Option<i32>,
    pub m_Url: Option<String>,
    pub m_VideoClip: Option<PPtrData<VideoClip>>,
    pub m_VideoShaders: Option<Vec<PPtrData<Shader>>>,
    pub m_WaitForFirstFrame: Option<bool>,
}

impl_object!(VideoPlayer);

impl Clone for VideoPlayer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AspectRatio: self.m_AspectRatio.clone(),
            m_AudioOutputMode: self.m_AudioOutputMode.clone(),
            m_ControlledAudioTrackCount: self.m_ControlledAudioTrackCount.clone(),
            m_DataSource: self.m_DataSource.clone(),
            m_DirectAudioMutes: self.m_DirectAudioMutes.clone(),
            m_DirectAudioVolumes: self.m_DirectAudioVolumes.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_EnabledAudioTracks: self.m_EnabledAudioTracks.clone(),
            m_FrameReadyEventEnabled: self.m_FrameReadyEventEnabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Looping: self.m_Looping.clone(),
            m_PlayOnAwake: self.m_PlayOnAwake.clone(),
            m_PlaybackSpeed: self.m_PlaybackSpeed.clone(),
            m_RenderMode: self.m_RenderMode.clone(),
            m_SkipOnDrop: self.m_SkipOnDrop.clone(),
            m_TargetAudioSources: self.m_TargetAudioSources.clone(),
            m_TargetCamera: self.m_TargetCamera.clone(),
            m_TargetCamera3DLayout: self.m_TargetCamera3DLayout.clone(),
            m_TargetCameraAlpha: self.m_TargetCameraAlpha.clone(),
            m_TargetMaterialName: self.m_TargetMaterialName.clone(),
            m_TargetMaterialProperty: self.m_TargetMaterialProperty.clone(),
            m_TargetMaterialRenderer: self.m_TargetMaterialRenderer.clone(),
            m_TargetTexture: self.m_TargetTexture.clone(),
            m_TimeReference: self.m_TimeReference.clone(),
            m_TimeUpdateMode: self.m_TimeUpdateMode.clone(),
            m_Url: self.m_Url.clone(),
            m_VideoClip: self.m_VideoClip.clone(),
            m_VideoShaders: self.m_VideoShaders.clone(),
            m_WaitForFirstFrame: self.m_WaitForFirstFrame.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VisualEffect {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AllowInstancing: Option<u8>,
    pub m_Asset: Option<PPtrData<VisualEffectAsset>>,
    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_InitialEventName: Option<String>,
    pub m_InitialEventNameOverriden: Option<u8>,
    pub m_PropertySheet: Option<VFXPropertySheetSerializedBase>,
    pub m_ResetSeedOnPlay: Option<bool>,
    pub m_StartSeed: Option<u32>,
}

impl_object!(VisualEffect);

impl Clone for VisualEffect {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AllowInstancing: self.m_AllowInstancing.clone(),
            m_Asset: self.m_Asset.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_InitialEventName: self.m_InitialEventName.clone(),
            m_InitialEventNameOverriden: self.m_InitialEventNameOverriden.clone(),
            m_PropertySheet: self.m_PropertySheet.clone(),
            m_ResetSeedOnPlay: self.m_ResetSeedOnPlay.clone(),
            m_StartSeed: self.m_StartSeed.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct WindZone {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<u8>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Mode: Option<i32>,
    pub m_Radius: Option<f32>,
    pub m_WindMain: Option<f32>,
    pub m_WindPulseFrequency: Option<f32>,
    pub m_WindPulseMagnitude: Option<f32>,
    pub m_WindTurbulence: Option<f32>,
}

impl_object!(WindZone);

impl Clone for WindZone {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Mode: self.m_Mode.clone(),
            m_Radius: self.m_Radius.clone(),
            m_WindMain: self.m_WindMain.clone(),
            m_WindPulseFrequency: self.m_WindPulseFrequency.clone(),
            m_WindPulseMagnitude: self.m_WindPulseMagnitude.clone(),
            m_WindTurbulence: self.m_WindTurbulence.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CanvasRenderer {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CullTransparentMesh: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(CanvasRenderer);

impl Clone for CanvasRenderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CullTransparentMesh: self.m_CullTransparentMesh.clone(),
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Collider {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_MaxLimitX: Option<f32>,
    pub m_MaxLimitY: Option<f32>,
    pub m_MaxLimitZ: Option<f32>,
    pub m_MinLimitX: Option<f32>,
    pub m_Type: Option<u32>,
    pub m_X: Option<xform>,
    pub m_XMotionType: Option<u32>,
    pub m_YMotionType: Option<u32>,
    pub m_ZMotionType: Option<u32>,
}

impl_object!(Collider);

impl Clone for Collider {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
            m_MaxLimitX: self.m_MaxLimitX.clone(),
            m_MaxLimitY: self.m_MaxLimitY.clone(),
            m_MaxLimitZ: self.m_MaxLimitZ.clone(),
            m_MinLimitX: self.m_MinLimitX.clone(),
            m_Type: self.m_Type.clone(),
            m_X: self.m_X.clone(),
            m_XMotionType: self.m_XMotionType.clone(),
            m_YMotionType: self.m_YMotionType.clone(),
            m_ZMotionType: self.m_ZMotionType.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BoxCollider {
    // extends Collider
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Center: Option<Vector3>,
    pub m_Enabled: Option<bool>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_IsTrigger: Option<bool>,
    pub m_LayerOverridePriority: Option<i32>,
    pub m_Material: Option<PPtrData<PhysicMaterial>>,
    pub m_ProvidesContacts: Option<bool>,
    pub m_Size: Option<Vector3>,
}

impl_object!(BoxCollider);

impl Clone for BoxCollider {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Center: self.m_Center.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_IsTrigger: self.m_IsTrigger.clone(),
            m_LayerOverridePriority: self.m_LayerOverridePriority.clone(),
            m_Material: self.m_Material.clone(),
            m_ProvidesContacts: self.m_ProvidesContacts.clone(),
            m_Size: self.m_Size.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CapsuleCollider {
    // extends Collider
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Center: Option<Vector3>,
    pub m_Direction: Option<i32>,
    pub m_Enabled: Option<bool>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Height: Option<f32>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_IsTrigger: Option<bool>,
    pub m_LayerOverridePriority: Option<i32>,
    pub m_Material: Option<PPtrData<PhysicMaterial>>,
    pub m_ProvidesContacts: Option<bool>,
    pub m_Radius: Option<f32>,
}

impl_object!(CapsuleCollider);

impl Clone for CapsuleCollider {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Center: self.m_Center.clone(),
            m_Direction: self.m_Direction.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Height: self.m_Height.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_IsTrigger: self.m_IsTrigger.clone(),
            m_LayerOverridePriority: self.m_LayerOverridePriority.clone(),
            m_Material: self.m_Material.clone(),
            m_ProvidesContacts: self.m_ProvidesContacts.clone(),
            m_Radius: self.m_Radius.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CharacterController {
    // extends Collider
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Center: Option<Vector3>,
    pub m_Enabled: Option<bool>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Height: Option<f32>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_IsTrigger: Option<bool>,
    pub m_LayerOverridePriority: Option<i32>,
    pub m_Material: Option<PPtrData<PhysicMaterial>>,
    pub m_MinMoveDistance: Option<f32>,
    pub m_ProvidesContacts: Option<bool>,
    pub m_Radius: Option<f32>,
    pub m_SkinWidth: Option<f32>,
    pub m_SlopeLimit: Option<f32>,
    pub m_StepOffset: Option<f32>,
}

impl_object!(CharacterController);

impl Clone for CharacterController {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Center: self.m_Center.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Height: self.m_Height.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_IsTrigger: self.m_IsTrigger.clone(),
            m_LayerOverridePriority: self.m_LayerOverridePriority.clone(),
            m_Material: self.m_Material.clone(),
            m_MinMoveDistance: self.m_MinMoveDistance.clone(),
            m_ProvidesContacts: self.m_ProvidesContacts.clone(),
            m_Radius: self.m_Radius.clone(),
            m_SkinWidth: self.m_SkinWidth.clone(),
            m_SlopeLimit: self.m_SlopeLimit.clone(),
            m_StepOffset: self.m_StepOffset.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MeshCollider {
    // extends Collider
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Convex: Option<bool>,
    pub m_CookingOptions: Option<i32>,
    pub m_Enabled: Option<bool>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_InflateMesh: Option<bool>,
    pub m_IsTrigger: Option<bool>,
    pub m_LayerOverridePriority: Option<i32>,
    pub m_Material: Option<PPtrData<PhysicMaterial>>,
    pub m_Mesh: Option<PPtrData<Mesh>>,
    pub m_ProvidesContacts: Option<bool>,
    pub m_SkinWidth: Option<f32>,
    pub m_SmoothSphereCollisions: Option<bool>,
}

impl_object!(MeshCollider);

impl Clone for MeshCollider {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Convex: self.m_Convex.clone(),
            m_CookingOptions: self.m_CookingOptions.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_InflateMesh: self.m_InflateMesh.clone(),
            m_IsTrigger: self.m_IsTrigger.clone(),
            m_LayerOverridePriority: self.m_LayerOverridePriority.clone(),
            m_Material: self.m_Material.clone(),
            m_Mesh: self.m_Mesh.clone(),
            m_ProvidesContacts: self.m_ProvidesContacts.clone(),
            m_SkinWidth: self.m_SkinWidth.clone(),
            m_SmoothSphereCollisions: self.m_SmoothSphereCollisions.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RaycastCollider {
    // extends Collider
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Center: Option<Vector3>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IsTrigger: Option<bool>,
    pub m_Length: Option<f32>,
    pub m_Material: Option<PPtrData<PhysicMaterial>>,
}

impl_object!(RaycastCollider);

impl Clone for RaycastCollider {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Center: self.m_Center.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IsTrigger: self.m_IsTrigger.clone(),
            m_Length: self.m_Length.clone(),
            m_Material: self.m_Material.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SphereCollider {
    // extends Collider
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Center: Option<Vector3>,
    pub m_Enabled: Option<bool>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_IsTrigger: Option<bool>,
    pub m_LayerOverridePriority: Option<i32>,
    pub m_Material: Option<PPtrData<PhysicMaterial>>,
    pub m_ProvidesContacts: Option<bool>,
    pub m_Radius: Option<f32>,
}

impl_object!(SphereCollider);

impl Clone for SphereCollider {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Center: self.m_Center.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_IsTrigger: self.m_IsTrigger.clone(),
            m_LayerOverridePriority: self.m_LayerOverridePriority.clone(),
            m_Material: self.m_Material.clone(),
            m_ProvidesContacts: self.m_ProvidesContacts.clone(),
            m_Radius: self.m_Radius.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TerrainCollider {
    // extends Collider
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CreateTreeColliders: Option<bool>,
    pub m_EnableTreeColliders: Option<bool>,
    pub m_Enabled: Option<bool>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_IsTrigger: Option<bool>,
    pub m_LayerOverridePriority: Option<i32>,
    pub m_Material: Option<PPtrData<PhysicMaterial>>,
    pub m_ProvidesContacts: Option<bool>,
    pub m_TerrainData: Option<PPtrData<TerrainData>>,
}

impl_object!(TerrainCollider);

impl Clone for TerrainCollider {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CreateTreeColliders: self.m_CreateTreeColliders.clone(),
            m_EnableTreeColliders: self.m_EnableTreeColliders.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_IsTrigger: self.m_IsTrigger.clone(),
            m_LayerOverridePriority: self.m_LayerOverridePriority.clone(),
            m_Material: self.m_Material.clone(),
            m_ProvidesContacts: self.m_ProvidesContacts.clone(),
            m_TerrainData: self.m_TerrainData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct WheelCollider {
    // extends Collider
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Center: Option<Vector3>,
    pub m_Enabled: Option<bool>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_ForceAppPointDistance: Option<f32>,
    pub m_ForwardFriction: Option<WheelFrictionCurve>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_LayerOverridePriority: Option<i32>,
    pub m_Mass: Option<f32>,
    pub m_ProvidesContacts: Option<bool>,
    pub m_Radius: Option<f32>,
    pub m_SidewaysFriction: Option<WheelFrictionCurve>,
    pub m_SuspensionDistance: Option<f32>,
    pub m_SuspensionSpring: Option<JointSpring>,
    pub m_WheelDampingRate: Option<f32>,
}

impl_object!(WheelCollider);

impl Clone for WheelCollider {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Center: self.m_Center.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_ForceAppPointDistance: self.m_ForceAppPointDistance.clone(),
            m_ForwardFriction: self.m_ForwardFriction.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_LayerOverridePriority: self.m_LayerOverridePriority.clone(),
            m_Mass: self.m_Mass.clone(),
            m_ProvidesContacts: self.m_ProvidesContacts.clone(),
            m_Radius: self.m_Radius.clone(),
            m_SidewaysFriction: self.m_SidewaysFriction.clone(),
            m_SuspensionDistance: self.m_SuspensionDistance.clone(),
            m_SuspensionSpring: self.m_SuspensionSpring.clone(),
            m_WheelDampingRate: self.m_WheelDampingRate.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct FakeComponent {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(FakeComponent);

impl Clone for FakeComponent {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Joint {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(Joint);

impl Clone for Joint {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CharacterJoint {
    // extends Joint
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Anchor: Option<Vector3>,
    pub m_AutoConfigureConnectedAnchor: Option<bool>,
    pub m_Axis: Option<Vector3>,
    pub m_BreakForce: Option<f32>,
    pub m_BreakTorque: Option<f32>,
    pub m_ConnectedAnchor: Option<Vector3>,
    pub m_ConnectedArticulationBody: Option<PPtrData<ArticulationBody>>,
    pub m_ConnectedBody: Option<PPtrData<Rigidbody>>,
    pub m_ConnectedMassScale: Option<f32>,
    pub m_EnableCollision: Option<bool>,
    pub m_EnablePreprocessing: Option<bool>,
    pub m_EnableProjection: Option<bool>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_HighTwistLimit: Option<SoftJointLimit>,
    pub m_LowTwistLimit: Option<SoftJointLimit>,
    pub m_MassScale: Option<f32>,
    pub m_ProjectionAngle: Option<f32>,
    pub m_ProjectionDistance: Option<f32>,
    pub m_Swing1Limit: Option<SoftJointLimit>,
    pub m_Swing2Limit: Option<SoftJointLimit>,
    pub m_SwingAxis: Option<Vector3>,
    pub m_SwingLimitSpring: Option<SoftJointLimitSpring>,
    pub m_TwistLimitSpring: Option<SoftJointLimitSpring>,
}

impl_object!(CharacterJoint);

impl Clone for CharacterJoint {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Anchor: self.m_Anchor.clone(),
            m_AutoConfigureConnectedAnchor: self.m_AutoConfigureConnectedAnchor.clone(),
            m_Axis: self.m_Axis.clone(),
            m_BreakForce: self.m_BreakForce.clone(),
            m_BreakTorque: self.m_BreakTorque.clone(),
            m_ConnectedAnchor: self.m_ConnectedAnchor.clone(),
            m_ConnectedArticulationBody: self.m_ConnectedArticulationBody.clone(),
            m_ConnectedBody: self.m_ConnectedBody.clone(),
            m_ConnectedMassScale: self.m_ConnectedMassScale.clone(),
            m_EnableCollision: self.m_EnableCollision.clone(),
            m_EnablePreprocessing: self.m_EnablePreprocessing.clone(),
            m_EnableProjection: self.m_EnableProjection.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_HighTwistLimit: self.m_HighTwistLimit.clone(),
            m_LowTwistLimit: self.m_LowTwistLimit.clone(),
            m_MassScale: self.m_MassScale.clone(),
            m_ProjectionAngle: self.m_ProjectionAngle.clone(),
            m_ProjectionDistance: self.m_ProjectionDistance.clone(),
            m_Swing1Limit: self.m_Swing1Limit.clone(),
            m_Swing2Limit: self.m_Swing2Limit.clone(),
            m_SwingAxis: self.m_SwingAxis.clone(),
            m_SwingLimitSpring: self.m_SwingLimitSpring.clone(),
            m_TwistLimitSpring: self.m_TwistLimitSpring.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ConfigurableJoint {
    // extends Joint
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Anchor: Option<Vector3>,
    pub m_AngularXDrive: Option<JointDrive>,
    pub m_AngularXLimitSpring: Option<SoftJointLimitSpring>,
    pub m_AngularXMotion: Option<i32>,
    pub m_AngularYLimit: Option<SoftJointLimit>,
    pub m_AngularYMotion: Option<i32>,
    pub m_AngularYZDrive: Option<JointDrive>,
    pub m_AngularYZLimitSpring: Option<SoftJointLimitSpring>,
    pub m_AngularZLimit: Option<SoftJointLimit>,
    pub m_AngularZMotion: Option<i32>,
    pub m_AutoConfigureConnectedAnchor: Option<bool>,
    pub m_Axis: Option<Vector3>,
    pub m_BreakForce: Option<f32>,
    pub m_BreakTorque: Option<f32>,
    pub m_ConfiguredInWorldSpace: Option<bool>,
    pub m_ConnectedAnchor: Option<Vector3>,
    pub m_ConnectedArticulationBody: Option<PPtrData<ArticulationBody>>,
    pub m_ConnectedBody: Option<PPtrData<Rigidbody>>,
    pub m_ConnectedMassScale: Option<f32>,
    pub m_EnableCollision: Option<bool>,
    pub m_EnablePreprocessing: Option<bool>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_HighAngularXLimit: Option<SoftJointLimit>,
    pub m_LinearLimit: Option<SoftJointLimit>,
    pub m_LinearLimitSpring: Option<SoftJointLimitSpring>,
    pub m_LowAngularXLimit: Option<SoftJointLimit>,
    pub m_MassScale: Option<f32>,
    pub m_ProjectionAngle: Option<f32>,
    pub m_ProjectionDistance: Option<f32>,
    pub m_ProjectionMode: Option<i32>,
    pub m_RotationDriveMode: Option<i32>,
    pub m_SecondaryAxis: Option<Vector3>,
    pub m_SlerpDrive: Option<JointDrive>,
    pub m_SwapBodies: Option<bool>,
    pub m_TargetAngularVelocity: Option<Vector3>,
    pub m_TargetPosition: Option<Vector3>,
    pub m_TargetRotation: Option<Quaternion>,
    pub m_TargetVelocity: Option<Vector3>,
    pub m_XDrive: Option<JointDrive>,
    pub m_XMotion: Option<i32>,
    pub m_YDrive: Option<JointDrive>,
    pub m_YMotion: Option<i32>,
    pub m_ZDrive: Option<JointDrive>,
    pub m_ZMotion: Option<i32>,
}

impl_object!(ConfigurableJoint);

impl Clone for ConfigurableJoint {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Anchor: self.m_Anchor.clone(),
            m_AngularXDrive: self.m_AngularXDrive.clone(),
            m_AngularXLimitSpring: self.m_AngularXLimitSpring.clone(),
            m_AngularXMotion: self.m_AngularXMotion.clone(),
            m_AngularYLimit: self.m_AngularYLimit.clone(),
            m_AngularYMotion: self.m_AngularYMotion.clone(),
            m_AngularYZDrive: self.m_AngularYZDrive.clone(),
            m_AngularYZLimitSpring: self.m_AngularYZLimitSpring.clone(),
            m_AngularZLimit: self.m_AngularZLimit.clone(),
            m_AngularZMotion: self.m_AngularZMotion.clone(),
            m_AutoConfigureConnectedAnchor: self.m_AutoConfigureConnectedAnchor.clone(),
            m_Axis: self.m_Axis.clone(),
            m_BreakForce: self.m_BreakForce.clone(),
            m_BreakTorque: self.m_BreakTorque.clone(),
            m_ConfiguredInWorldSpace: self.m_ConfiguredInWorldSpace.clone(),
            m_ConnectedAnchor: self.m_ConnectedAnchor.clone(),
            m_ConnectedArticulationBody: self.m_ConnectedArticulationBody.clone(),
            m_ConnectedBody: self.m_ConnectedBody.clone(),
            m_ConnectedMassScale: self.m_ConnectedMassScale.clone(),
            m_EnableCollision: self.m_EnableCollision.clone(),
            m_EnablePreprocessing: self.m_EnablePreprocessing.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_HighAngularXLimit: self.m_HighAngularXLimit.clone(),
            m_LinearLimit: self.m_LinearLimit.clone(),
            m_LinearLimitSpring: self.m_LinearLimitSpring.clone(),
            m_LowAngularXLimit: self.m_LowAngularXLimit.clone(),
            m_MassScale: self.m_MassScale.clone(),
            m_ProjectionAngle: self.m_ProjectionAngle.clone(),
            m_ProjectionDistance: self.m_ProjectionDistance.clone(),
            m_ProjectionMode: self.m_ProjectionMode.clone(),
            m_RotationDriveMode: self.m_RotationDriveMode.clone(),
            m_SecondaryAxis: self.m_SecondaryAxis.clone(),
            m_SlerpDrive: self.m_SlerpDrive.clone(),
            m_SwapBodies: self.m_SwapBodies.clone(),
            m_TargetAngularVelocity: self.m_TargetAngularVelocity.clone(),
            m_TargetPosition: self.m_TargetPosition.clone(),
            m_TargetRotation: self.m_TargetRotation.clone(),
            m_TargetVelocity: self.m_TargetVelocity.clone(),
            m_XDrive: self.m_XDrive.clone(),
            m_XMotion: self.m_XMotion.clone(),
            m_YDrive: self.m_YDrive.clone(),
            m_YMotion: self.m_YMotion.clone(),
            m_ZDrive: self.m_ZDrive.clone(),
            m_ZMotion: self.m_ZMotion.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct FixedJoint {
    // extends Joint
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BreakForce: Option<f32>,
    pub m_BreakTorque: Option<f32>,
    pub m_ConnectedArticulationBody: Option<PPtrData<ArticulationBody>>,
    pub m_ConnectedBody: Option<PPtrData<Rigidbody>>,
    pub m_ConnectedMassScale: Option<f32>,
    pub m_EnableCollision: Option<bool>,
    pub m_EnablePreprocessing: Option<bool>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_MassScale: Option<f32>,
}

impl_object!(FixedJoint);

impl Clone for FixedJoint {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BreakForce: self.m_BreakForce.clone(),
            m_BreakTorque: self.m_BreakTorque.clone(),
            m_ConnectedArticulationBody: self.m_ConnectedArticulationBody.clone(),
            m_ConnectedBody: self.m_ConnectedBody.clone(),
            m_ConnectedMassScale: self.m_ConnectedMassScale.clone(),
            m_EnableCollision: self.m_EnableCollision.clone(),
            m_EnablePreprocessing: self.m_EnablePreprocessing.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_MassScale: self.m_MassScale.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HingeJoint {
    // extends Joint
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Anchor: Option<Vector3>,
    pub m_AutoConfigureConnectedAnchor: Option<bool>,
    pub m_Axis: Option<Vector3>,
    pub m_BreakForce: Option<f32>,
    pub m_BreakTorque: Option<f32>,
    pub m_ConnectedAnchor: Option<Vector3>,
    pub m_ConnectedArticulationBody: Option<PPtrData<ArticulationBody>>,
    pub m_ConnectedBody: Option<PPtrData<Rigidbody>>,
    pub m_ConnectedMassScale: Option<f32>,
    pub m_EnableCollision: Option<bool>,
    pub m_EnablePreprocessing: Option<bool>,
    pub m_Enabled: Option<bool>,
    pub m_ExtendedLimits: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Limits: Option<JointLimits>,
    pub m_MassScale: Option<f32>,
    pub m_Motor: Option<JointMotor>,
    pub m_Spring: Option<JointSpring>,
    pub m_UseAcceleration: Option<bool>,
    pub m_UseLimits: Option<bool>,
    pub m_UseMotor: Option<bool>,
    pub m_UseSpring: Option<bool>,
}

impl_object!(HingeJoint);

impl Clone for HingeJoint {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Anchor: self.m_Anchor.clone(),
            m_AutoConfigureConnectedAnchor: self.m_AutoConfigureConnectedAnchor.clone(),
            m_Axis: self.m_Axis.clone(),
            m_BreakForce: self.m_BreakForce.clone(),
            m_BreakTorque: self.m_BreakTorque.clone(),
            m_ConnectedAnchor: self.m_ConnectedAnchor.clone(),
            m_ConnectedArticulationBody: self.m_ConnectedArticulationBody.clone(),
            m_ConnectedBody: self.m_ConnectedBody.clone(),
            m_ConnectedMassScale: self.m_ConnectedMassScale.clone(),
            m_EnableCollision: self.m_EnableCollision.clone(),
            m_EnablePreprocessing: self.m_EnablePreprocessing.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_ExtendedLimits: self.m_ExtendedLimits.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Limits: self.m_Limits.clone(),
            m_MassScale: self.m_MassScale.clone(),
            m_Motor: self.m_Motor.clone(),
            m_Spring: self.m_Spring.clone(),
            m_UseAcceleration: self.m_UseAcceleration.clone(),
            m_UseLimits: self.m_UseLimits.clone(),
            m_UseMotor: self.m_UseMotor.clone(),
            m_UseSpring: self.m_UseSpring.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpringJoint {
    // extends Joint
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Anchor: Option<Vector3>,
    pub m_AutoConfigureConnectedAnchor: Option<bool>,
    pub m_Axis: Option<Vector3>,
    pub m_BreakForce: Option<f32>,
    pub m_BreakTorque: Option<f32>,
    pub m_ConnectedAnchor: Option<Vector3>,
    pub m_ConnectedArticulationBody: Option<PPtrData<ArticulationBody>>,
    pub m_ConnectedBody: Option<PPtrData<Rigidbody>>,
    pub m_ConnectedMassScale: Option<f32>,
    pub m_Damper: Option<f32>,
    pub m_EnableCollision: Option<bool>,
    pub m_EnablePreprocessing: Option<bool>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_MassScale: Option<f32>,
    pub m_MaxDistance: Option<f32>,
    pub m_MinDistance: Option<f32>,
    pub m_Spring: Option<f32>,
    pub m_Tolerance: Option<f32>,
}

impl_object!(SpringJoint);

impl Clone for SpringJoint {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Anchor: self.m_Anchor.clone(),
            m_AutoConfigureConnectedAnchor: self.m_AutoConfigureConnectedAnchor.clone(),
            m_Axis: self.m_Axis.clone(),
            m_BreakForce: self.m_BreakForce.clone(),
            m_BreakTorque: self.m_BreakTorque.clone(),
            m_ConnectedAnchor: self.m_ConnectedAnchor.clone(),
            m_ConnectedArticulationBody: self.m_ConnectedArticulationBody.clone(),
            m_ConnectedBody: self.m_ConnectedBody.clone(),
            m_ConnectedMassScale: self.m_ConnectedMassScale.clone(),
            m_Damper: self.m_Damper.clone(),
            m_EnableCollision: self.m_EnableCollision.clone(),
            m_EnablePreprocessing: self.m_EnablePreprocessing.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_MassScale: self.m_MassScale.clone(),
            m_MaxDistance: self.m_MaxDistance.clone(),
            m_MinDistance: self.m_MinDistance.clone(),
            m_Spring: self.m_Spring.clone(),
            m_Tolerance: self.m_Tolerance.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LODGroup {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AnimateCrossFading: Option<bool>,
    pub m_Enabled: Option<bool>,
    pub m_FadeMode: Option<i32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LODs: Option<Vec<LOD>>,
    pub m_LastLODIsBillboard: Option<bool>,
    pub m_LocalReferencePoint: Option<Vector3>,
    pub m_ScreenRelativeTransitionHeight: Option<f32>,
    pub m_Size: Option<f32>,
}

impl_object!(LODGroup);

impl Clone for LODGroup {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AnimateCrossFading: self.m_AnimateCrossFading.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_FadeMode: self.m_FadeMode.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LODs: self.m_LODs.clone(),
            m_LastLODIsBillboard: self.m_LastLODIsBillboard.clone(),
            m_LocalReferencePoint: self.m_LocalReferencePoint.clone(),
            m_ScreenRelativeTransitionHeight: self.m_ScreenRelativeTransitionHeight.clone(),
            m_Size: self.m_Size.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MeshFilter {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Mesh: Option<PPtrData<Mesh>>,
}

impl_object!(MeshFilter);

impl Clone for MeshFilter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
            m_Mesh: self.m_Mesh.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MultiplayerRolesData {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ComponentsRolesMasks: Option<Vec<ObjectRolePair>>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_GameObjectRolesMask: Option<i32>,
}

impl_object!(MultiplayerRolesData);

impl Clone for MultiplayerRolesData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ComponentsRolesMasks: self.m_ComponentsRolesMasks.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_GameObjectRolesMask: self.m_GameObjectRolesMask.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct OcclusionArea {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Center: Option<Vector3>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IsTargetVolume: Option<bool>,
    pub m_IsViewVolume: Option<bool>,
    pub m_Size: Option<Vector3>,
    pub m_TargetResolution: Option<i32>,
}

impl_object!(OcclusionArea);

impl Clone for OcclusionArea {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Center: self.m_Center.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IsTargetVolume: self.m_IsTargetVolume.clone(),
            m_IsViewVolume: self.m_IsViewVolume.clone(),
            m_Size: self.m_Size.clone(),
            m_TargetResolution: self.m_TargetResolution.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct OcclusionPortal {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Center: Option<Vector3>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_Open: Option<bool>,
    pub m_Size: Option<Vector3>,
}

impl_object!(OcclusionPortal);

impl Clone for OcclusionPortal {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Center: self.m_Center.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_Open: self.m_Open.clone(),
            m_Size: self.m_Size.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ParticleAnimator {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub Does_Animate_Color: Option<bool>,
    pub autodestruct: Option<bool>,
    pub colorAnimation_0_: Option<Color>,
    pub colorAnimation_1_: Option<Color>,
    pub colorAnimation_2_: Option<Color>,
    pub colorAnimation_3_: Option<Color>,
    pub colorAnimation_4_: Option<Color>,
    pub damping: Option<f32>,
    pub force: Option<Vector3>,
    pub localRotationAxis: Option<Vector3>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub rndForce: Option<Vector3>,
    pub sizeGrow: Option<f32>,
    pub stopSimulation: Option<bool>,
    pub worldRotationAxis: Option<Vector3>,
}

impl_object!(ParticleAnimator);

impl Clone for ParticleAnimator {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            Does_Animate_Color: self.Does_Animate_Color.clone(),
            autodestruct: self.autodestruct.clone(),
            colorAnimation_0_: self.colorAnimation_0_.clone(),
            colorAnimation_1_: self.colorAnimation_1_.clone(),
            colorAnimation_2_: self.colorAnimation_2_.clone(),
            colorAnimation_3_: self.colorAnimation_3_.clone(),
            colorAnimation_4_: self.colorAnimation_4_.clone(),
            damping: self.damping.clone(),
            force: self.force.clone(),
            localRotationAxis: self.localRotationAxis.clone(),
            m_GameObject: self.m_GameObject.clone(),
            rndForce: self.rndForce.clone(),
            sizeGrow: self.sizeGrow.clone(),
            stopSimulation: self.stopSimulation.clone(),
            worldRotationAxis: self.worldRotationAxis.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ParticleEmitter {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(ParticleEmitter);

impl Clone for ParticleEmitter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EllipsoidParticleEmitter {
    // extends ParticleEmitter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub Simulate_in_Worldspace: Option<bool>,
    pub angularVelocity: Option<f32>,
    pub emitterVelocityScale: Option<f32>,
    pub localVelocity: Option<Vector3>,
    pub m_Ellipsoid: Option<Vector3>,
    pub m_Emit: Option<bool>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_MinEmitterRange: Option<f32>,
    pub m_OneShot: Option<bool>,
    pub maxEmission: Option<f32>,
    pub maxEnergy: Option<f32>,
    pub maxSize: Option<f32>,
    pub minEmission: Option<f32>,
    pub minEnergy: Option<f32>,
    pub minSize: Option<f32>,
    pub rndAngularVelocity: Option<f32>,
    pub rndRotation: Option<bool>,
    pub rndVelocity: Option<Vector3>,
    pub tangentVelocity: Option<Vector3>,
    pub worldVelocity: Option<Vector3>,
}

impl_object!(EllipsoidParticleEmitter);

impl Clone for EllipsoidParticleEmitter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            Simulate_in_Worldspace: self.Simulate_in_Worldspace.clone(),
            angularVelocity: self.angularVelocity.clone(),
            emitterVelocityScale: self.emitterVelocityScale.clone(),
            localVelocity: self.localVelocity.clone(),
            m_Ellipsoid: self.m_Ellipsoid.clone(),
            m_Emit: self.m_Emit.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_MinEmitterRange: self.m_MinEmitterRange.clone(),
            m_OneShot: self.m_OneShot.clone(),
            maxEmission: self.maxEmission.clone(),
            maxEnergy: self.maxEnergy.clone(),
            maxSize: self.maxSize.clone(),
            minEmission: self.minEmission.clone(),
            minEnergy: self.minEnergy.clone(),
            minSize: self.minSize.clone(),
            rndAngularVelocity: self.rndAngularVelocity.clone(),
            rndRotation: self.rndRotation.clone(),
            rndVelocity: self.rndVelocity.clone(),
            tangentVelocity: self.tangentVelocity.clone(),
            worldVelocity: self.worldVelocity.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MeshParticleEmitter {
    // extends ParticleEmitter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub Simulate_in_Worldspace: Option<bool>,
    pub angularVelocity: Option<f32>,
    pub emitterVelocityScale: Option<f32>,
    pub localVelocity: Option<Vector3>,
    pub m_Emit: Option<bool>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_InterpolateTriangles: Option<bool>,
    pub m_MaxNormalVelocity: Option<f32>,
    pub m_Mesh: Option<PPtrData<Mesh>>,
    pub m_MinNormalVelocity: Option<f32>,
    pub m_OneShot: Option<bool>,
    pub m_Systematic: Option<bool>,
    pub maxEmission: Option<f32>,
    pub maxEnergy: Option<f32>,
    pub maxSize: Option<f32>,
    pub minEmission: Option<f32>,
    pub minEnergy: Option<f32>,
    pub minSize: Option<f32>,
    pub rndAngularVelocity: Option<f32>,
    pub rndRotation: Option<bool>,
    pub rndVelocity: Option<Vector3>,
    pub tangentVelocity: Option<Vector3>,
    pub worldVelocity: Option<Vector3>,
}

impl_object!(MeshParticleEmitter);

impl Clone for MeshParticleEmitter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            Simulate_in_Worldspace: self.Simulate_in_Worldspace.clone(),
            angularVelocity: self.angularVelocity.clone(),
            emitterVelocityScale: self.emitterVelocityScale.clone(),
            localVelocity: self.localVelocity.clone(),
            m_Emit: self.m_Emit.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_InterpolateTriangles: self.m_InterpolateTriangles.clone(),
            m_MaxNormalVelocity: self.m_MaxNormalVelocity.clone(),
            m_Mesh: self.m_Mesh.clone(),
            m_MinNormalVelocity: self.m_MinNormalVelocity.clone(),
            m_OneShot: self.m_OneShot.clone(),
            m_Systematic: self.m_Systematic.clone(),
            maxEmission: self.maxEmission.clone(),
            maxEnergy: self.maxEnergy.clone(),
            maxSize: self.maxSize.clone(),
            minEmission: self.minEmission.clone(),
            minEnergy: self.minEnergy.clone(),
            minSize: self.minSize.clone(),
            rndAngularVelocity: self.rndAngularVelocity.clone(),
            rndRotation: self.rndRotation.clone(),
            rndVelocity: self.rndVelocity.clone(),
            tangentVelocity: self.tangentVelocity.clone(),
            worldVelocity: self.worldVelocity.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ParticleSystem {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub ClampVelocityModule: Option<ClampVelocityModule>,
    pub CollisionModule: Option<CollisionModule>,
    pub ColorBySpeedModule: Option<ColorBySpeedModule>,
    pub ColorModule: Option<ColorModule>,
    pub CustomDataModule: Option<CustomDataModule>,
    pub EmissionModule: Option<EmissionModule>,
    pub ExternalForcesModule: Option<ExternalForcesModule>,
    pub ForceModule: Option<ForceModule>,
    pub InheritVelocityModule: Option<InheritVelocityModule>,
    pub InitialModule: Option<InitialModule>,
    pub LifetimeByEmitterSpeedModule: Option<LifetimeByEmitterSpeedModule>,
    pub LightsModule: Option<LightsModule>,
    pub NoiseModule: Option<NoiseModule>,
    pub RotationBySpeedModule: Option<RotationBySpeedModule>,
    pub RotationModule: Option<RotationModule>,
    pub ShapeModule: Option<ShapeModule>,
    pub SizeBySpeedModule: Option<SizeBySpeedModule>,
    pub SizeModule: Option<SizeModule>,
    pub SubModule: Option<SubModule>,
    pub TrailModule: Option<TrailModule>,
    pub TriggerModule: Option<TriggerModule>,
    pub UVModule: Option<UVModule>,
    pub VelocityModule: Option<VelocityModule>,
    pub autoRandomSeed: Option<bool>,
    pub cullingMode: Option<i32>,
    pub emitterVelocityMode: Option<i32>,
    pub lengthInSec: Option<f32>,
    pub looping: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub moveWithCustomTransform: Option<PPtrData<Transform>>,
    pub moveWithTransform: Option<bool>,
    pub playOnAwake: Option<bool>,
    pub prewarm: Option<bool>,
    pub randomSeed: Option<i32>,
    pub ringBufferLoopRange: Option<Vector2>,
    pub ringBufferMode: Option<i32>,
    pub scalingMode: Option<i32>,
    pub simulationSpeed: Option<f32>,
    pub speed: Option<f32>,
    pub startDelay: Option<MinMaxCurve>,
    pub stopAction: Option<i32>,
    pub useRigidbodyForVelocity: Option<bool>,
    pub useUnscaledTime: Option<bool>,
}

impl_object!(ParticleSystem);

impl Clone for ParticleSystem {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            ClampVelocityModule: self.ClampVelocityModule.clone(),
            CollisionModule: self.CollisionModule.clone(),
            ColorBySpeedModule: self.ColorBySpeedModule.clone(),
            ColorModule: self.ColorModule.clone(),
            CustomDataModule: self.CustomDataModule.clone(),
            EmissionModule: self.EmissionModule.clone(),
            ExternalForcesModule: self.ExternalForcesModule.clone(),
            ForceModule: self.ForceModule.clone(),
            InheritVelocityModule: self.InheritVelocityModule.clone(),
            InitialModule: self.InitialModule.clone(),
            LifetimeByEmitterSpeedModule: self.LifetimeByEmitterSpeedModule.clone(),
            LightsModule: self.LightsModule.clone(),
            NoiseModule: self.NoiseModule.clone(),
            RotationBySpeedModule: self.RotationBySpeedModule.clone(),
            RotationModule: self.RotationModule.clone(),
            ShapeModule: self.ShapeModule.clone(),
            SizeBySpeedModule: self.SizeBySpeedModule.clone(),
            SizeModule: self.SizeModule.clone(),
            SubModule: self.SubModule.clone(),
            TrailModule: self.TrailModule.clone(),
            TriggerModule: self.TriggerModule.clone(),
            UVModule: self.UVModule.clone(),
            VelocityModule: self.VelocityModule.clone(),
            autoRandomSeed: self.autoRandomSeed.clone(),
            cullingMode: self.cullingMode.clone(),
            emitterVelocityMode: self.emitterVelocityMode.clone(),
            lengthInSec: self.lengthInSec.clone(),
            looping: self.looping.clone(),
            m_GameObject: self.m_GameObject.clone(),
            moveWithCustomTransform: self.moveWithCustomTransform.clone(),
            moveWithTransform: self.moveWithTransform.clone(),
            playOnAwake: self.playOnAwake.clone(),
            prewarm: self.prewarm.clone(),
            randomSeed: self.randomSeed.clone(),
            ringBufferLoopRange: self.ringBufferLoopRange.clone(),
            ringBufferMode: self.ringBufferMode.clone(),
            scalingMode: self.scalingMode.clone(),
            simulationSpeed: self.simulationSpeed.clone(),
            speed: self.speed.clone(),
            startDelay: self.startDelay.clone(),
            stopAction: self.stopAction.clone(),
            useRigidbodyForVelocity: self.useRigidbodyForVelocity.clone(),
            useUnscaledTime: self.useUnscaledTime.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Pipeline {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(Pipeline);

impl Clone for Pipeline {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Renderer {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(Renderer);

impl Clone for Renderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BillboardRenderer {
    // extends Renderer
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Billboard: Option<PPtrData<BillboardAsset>>,
    pub m_CastShadows: Option<u8>,
    pub m_DynamicOccludee: Option<u8>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LightProbeUsage: Option<u8>,
    pub m_LightProbeVolumeOverride: Option<PPtrData<GameObject>>,
    pub m_LightmapIndex: Option<u16>,
    pub m_LightmapIndexDynamic: Option<u16>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_LightmapTilingOffsetDynamic: Option<Vector4>,
    pub m_Materials: Option<Vec<PPtrData<Material>>>,
    pub m_MotionVectors: Option<u8>,
    pub m_ProbeAnchor: Option<PPtrData<Transform>>,
    pub m_RayTraceProcedural: Option<u8>,
    pub m_RayTracingAccelStructBuildFlags: Option<u8>,
    pub m_RayTracingAccelStructBuildFlagsOverride: Option<u8>,
    pub m_RayTracingMode: Option<u8>,
    pub m_ReceiveShadows: Option<bool>,
    pub m_ReflectionProbeUsage: Option<i32>,
    pub m_RendererPriority: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_SmallMeshCulling: Option<u8>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
    pub m_StaticBatchInfo: Option<StaticBatchInfo>,
    pub m_StaticBatchRoot: Option<PPtrData<Transform>>,
    pub m_StaticShadowCaster: Option<u8>,
    pub m_SubsetIndices: Option<Vec<u32>>,
    pub m_UseLightProbes: Option<bool>,
}

impl_object!(BillboardRenderer);

impl Clone for BillboardRenderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Billboard: self.m_Billboard.clone(),
            m_CastShadows: self.m_CastShadows.clone(),
            m_DynamicOccludee: self.m_DynamicOccludee.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LightProbeUsage: self.m_LightProbeUsage.clone(),
            m_LightProbeVolumeOverride: self.m_LightProbeVolumeOverride.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapIndexDynamic: self.m_LightmapIndexDynamic.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_LightmapTilingOffsetDynamic: self.m_LightmapTilingOffsetDynamic.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MotionVectors: self.m_MotionVectors.clone(),
            m_ProbeAnchor: self.m_ProbeAnchor.clone(),
            m_RayTraceProcedural: self.m_RayTraceProcedural.clone(),
            m_RayTracingAccelStructBuildFlags: self.m_RayTracingAccelStructBuildFlags.clone(),
            m_RayTracingAccelStructBuildFlagsOverride: self
                .m_RayTracingAccelStructBuildFlagsOverride
                .clone(),
            m_RayTracingMode: self.m_RayTracingMode.clone(),
            m_ReceiveShadows: self.m_ReceiveShadows.clone(),
            m_ReflectionProbeUsage: self.m_ReflectionProbeUsage.clone(),
            m_RendererPriority: self.m_RendererPriority.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_SmallMeshCulling: self.m_SmallMeshCulling.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_StaticBatchInfo: self.m_StaticBatchInfo.clone(),
            m_StaticBatchRoot: self.m_StaticBatchRoot.clone(),
            m_StaticShadowCaster: self.m_StaticShadowCaster.clone(),
            m_SubsetIndices: self.m_SubsetIndices.clone(),
            m_UseLightProbes: self.m_UseLightProbes.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ClothRenderer {
    // extends Renderer
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CastShadows: Option<bool>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LightProbeAnchor: Option<PPtrData<Transform>>,
    pub m_LightmapIndex: Option<u8>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_Materials: Option<Vec<PPtrData<Material>>>,
    pub m_PauseWhenNotVisible: Option<bool>,
    pub m_ReceiveShadows: Option<bool>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<u32>,
    pub m_SortingOrder: Option<i16>,
    pub m_StaticBatchRoot: Option<PPtrData<Transform>>,
    pub m_SubsetIndices: Option<Vec<u32>>,
    pub m_UseLightProbes: Option<bool>,
}

impl_object!(ClothRenderer);

impl Clone for ClothRenderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CastShadows: self.m_CastShadows.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LightProbeAnchor: self.m_LightProbeAnchor.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_Materials: self.m_Materials.clone(),
            m_PauseWhenNotVisible: self.m_PauseWhenNotVisible.clone(),
            m_ReceiveShadows: self.m_ReceiveShadows.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_StaticBatchRoot: self.m_StaticBatchRoot.clone(),
            m_SubsetIndices: self.m_SubsetIndices.clone(),
            m_UseLightProbes: self.m_UseLightProbes.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LineRenderer {
    // extends Renderer
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ApplyActiveColorSpace: Option<bool>,
    pub m_CastShadows: Option<bool>,
    pub m_DynamicOccludee: Option<u8>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LightProbeAnchor: Option<PPtrData<Transform>>,
    pub m_LightProbeUsage: Option<u8>,
    pub m_LightProbeVolumeOverride: Option<PPtrData<GameObject>>,
    pub m_LightmapIndex: Option<u16>,
    pub m_LightmapIndexDynamic: Option<u16>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_LightmapTilingOffsetDynamic: Option<Vector4>,
    pub m_Loop: Option<bool>,
    pub m_MaskInteraction: Option<i32>,
    pub m_Materials: Option<Vec<PPtrData<Material>>>,
    pub m_MotionVectors: Option<u8>,
    pub m_Parameters: Option<LineParameters>,
    pub m_Positions: Option<Vec<Vector3>>,
    pub m_ProbeAnchor: Option<PPtrData<Transform>>,
    pub m_RayTraceProcedural: Option<u8>,
    pub m_RayTracingAccelStructBuildFlags: Option<u8>,
    pub m_RayTracingAccelStructBuildFlagsOverride: Option<u8>,
    pub m_RayTracingMode: Option<u8>,
    pub m_ReceiveShadows: Option<bool>,
    pub m_ReflectionProbeUsage: Option<i32>,
    pub m_RendererPriority: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_SmallMeshCulling: Option<u8>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
    pub m_StaticBatchInfo: Option<StaticBatchInfo>,
    pub m_StaticBatchRoot: Option<PPtrData<Transform>>,
    pub m_StaticShadowCaster: Option<u8>,
    pub m_SubsetIndices: Option<Vec<u32>>,
    pub m_UseLightProbes: Option<bool>,
    pub m_UseWorldSpace: Option<bool>,
}

impl_object!(LineRenderer);

impl Clone for LineRenderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ApplyActiveColorSpace: self.m_ApplyActiveColorSpace.clone(),
            m_CastShadows: self.m_CastShadows.clone(),
            m_DynamicOccludee: self.m_DynamicOccludee.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LightProbeAnchor: self.m_LightProbeAnchor.clone(),
            m_LightProbeUsage: self.m_LightProbeUsage.clone(),
            m_LightProbeVolumeOverride: self.m_LightProbeVolumeOverride.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapIndexDynamic: self.m_LightmapIndexDynamic.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_LightmapTilingOffsetDynamic: self.m_LightmapTilingOffsetDynamic.clone(),
            m_Loop: self.m_Loop.clone(),
            m_MaskInteraction: self.m_MaskInteraction.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MotionVectors: self.m_MotionVectors.clone(),
            m_Parameters: self.m_Parameters.clone(),
            m_Positions: self.m_Positions.clone(),
            m_ProbeAnchor: self.m_ProbeAnchor.clone(),
            m_RayTraceProcedural: self.m_RayTraceProcedural.clone(),
            m_RayTracingAccelStructBuildFlags: self.m_RayTracingAccelStructBuildFlags.clone(),
            m_RayTracingAccelStructBuildFlagsOverride: self
                .m_RayTracingAccelStructBuildFlagsOverride
                .clone(),
            m_RayTracingMode: self.m_RayTracingMode.clone(),
            m_ReceiveShadows: self.m_ReceiveShadows.clone(),
            m_ReflectionProbeUsage: self.m_ReflectionProbeUsage.clone(),
            m_RendererPriority: self.m_RendererPriority.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_SmallMeshCulling: self.m_SmallMeshCulling.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_StaticBatchInfo: self.m_StaticBatchInfo.clone(),
            m_StaticBatchRoot: self.m_StaticBatchRoot.clone(),
            m_StaticShadowCaster: self.m_StaticShadowCaster.clone(),
            m_SubsetIndices: self.m_SubsetIndices.clone(),
            m_UseLightProbes: self.m_UseLightProbes.clone(),
            m_UseWorldSpace: self.m_UseWorldSpace.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RendererFake {
    // extends LineRenderer
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CastShadows: Option<u8>,
    pub m_DynamicOccludee: Option<u8>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LightProbeUsage: Option<u8>,
    pub m_LightProbeVolumeOverride: Option<PPtrData<GameObject>>,
    pub m_LightmapIndex: Option<u16>,
    pub m_LightmapIndexDynamic: Option<u16>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_LightmapTilingOffsetDynamic: Option<Vector4>,
    pub m_Loop: Option<bool>,
    pub m_Materials: Option<Vec<PPtrData<Material>>>,
    pub m_MotionVectors: Option<u8>,
    pub m_Parameters: Option<LineParameters>,
    pub m_Positions: Option<Vec<Vector3>>,
    pub m_ProbeAnchor: Option<PPtrData<Transform>>,
    pub m_RayTraceProcedural: Option<u8>,
    pub m_RayTracingMode: Option<u8>,
    pub m_ReceiveShadows: Option<u8>,
    pub m_ReflectionProbeUsage: Option<u8>,
    pub m_RendererPriority: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
    pub m_StaticBatchInfo: Option<StaticBatchInfo>,
    pub m_StaticBatchRoot: Option<PPtrData<Transform>>,
    pub m_UseWorldSpace: Option<bool>,
}

impl_object!(RendererFake);

impl Clone for RendererFake {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CastShadows: self.m_CastShadows.clone(),
            m_DynamicOccludee: self.m_DynamicOccludee.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LightProbeUsage: self.m_LightProbeUsage.clone(),
            m_LightProbeVolumeOverride: self.m_LightProbeVolumeOverride.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapIndexDynamic: self.m_LightmapIndexDynamic.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_LightmapTilingOffsetDynamic: self.m_LightmapTilingOffsetDynamic.clone(),
            m_Loop: self.m_Loop.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MotionVectors: self.m_MotionVectors.clone(),
            m_Parameters: self.m_Parameters.clone(),
            m_Positions: self.m_Positions.clone(),
            m_ProbeAnchor: self.m_ProbeAnchor.clone(),
            m_RayTraceProcedural: self.m_RayTraceProcedural.clone(),
            m_RayTracingMode: self.m_RayTracingMode.clone(),
            m_ReceiveShadows: self.m_ReceiveShadows.clone(),
            m_ReflectionProbeUsage: self.m_ReflectionProbeUsage.clone(),
            m_RendererPriority: self.m_RendererPriority.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_StaticBatchInfo: self.m_StaticBatchInfo.clone(),
            m_StaticBatchRoot: self.m_StaticBatchRoot.clone(),
            m_UseWorldSpace: self.m_UseWorldSpace.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MeshRenderer {
    // extends Renderer
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AdditionalVertexStreams: Option<PPtrData<Mesh>>,
    pub m_CastShadows: Option<bool>,
    pub m_DynamicOccludee: Option<u8>,
    pub m_Enabled: Option<bool>,
    pub m_EnlightenVertexStream: Option<PPtrData<Mesh>>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LightProbeAnchor: Option<PPtrData<Transform>>,
    pub m_LightProbeUsage: Option<u8>,
    pub m_LightProbeVolumeOverride: Option<PPtrData<GameObject>>,
    pub m_LightmapIndex: Option<u16>,
    pub m_LightmapIndexDynamic: Option<u16>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_LightmapTilingOffsetDynamic: Option<Vector4>,
    pub m_Materials: Option<Vec<PPtrData<Material>>>,
    pub m_MotionVectors: Option<u8>,
    pub m_ProbeAnchor: Option<PPtrData<Transform>>,
    pub m_RayTraceProcedural: Option<u8>,
    pub m_RayTracingAccelStructBuildFlags: Option<u8>,
    pub m_RayTracingAccelStructBuildFlagsOverride: Option<u8>,
    pub m_RayTracingMode: Option<u8>,
    pub m_ReceiveShadows: Option<bool>,
    pub m_ReflectionProbeUsage: Option<i32>,
    pub m_RendererPriority: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_SmallMeshCulling: Option<u8>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
    pub m_StaticBatchInfo: Option<StaticBatchInfo>,
    pub m_StaticBatchRoot: Option<PPtrData<Transform>>,
    pub m_StaticShadowCaster: Option<u8>,
    pub m_SubsetIndices: Option<Vec<u32>>,
    pub m_UseLightProbes: Option<bool>,
}

impl_object!(MeshRenderer);

impl Clone for MeshRenderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AdditionalVertexStreams: self.m_AdditionalVertexStreams.clone(),
            m_CastShadows: self.m_CastShadows.clone(),
            m_DynamicOccludee: self.m_DynamicOccludee.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_EnlightenVertexStream: self.m_EnlightenVertexStream.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LightProbeAnchor: self.m_LightProbeAnchor.clone(),
            m_LightProbeUsage: self.m_LightProbeUsage.clone(),
            m_LightProbeVolumeOverride: self.m_LightProbeVolumeOverride.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapIndexDynamic: self.m_LightmapIndexDynamic.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_LightmapTilingOffsetDynamic: self.m_LightmapTilingOffsetDynamic.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MotionVectors: self.m_MotionVectors.clone(),
            m_ProbeAnchor: self.m_ProbeAnchor.clone(),
            m_RayTraceProcedural: self.m_RayTraceProcedural.clone(),
            m_RayTracingAccelStructBuildFlags: self.m_RayTracingAccelStructBuildFlags.clone(),
            m_RayTracingAccelStructBuildFlagsOverride: self
                .m_RayTracingAccelStructBuildFlagsOverride
                .clone(),
            m_RayTracingMode: self.m_RayTracingMode.clone(),
            m_ReceiveShadows: self.m_ReceiveShadows.clone(),
            m_ReflectionProbeUsage: self.m_ReflectionProbeUsage.clone(),
            m_RendererPriority: self.m_RendererPriority.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_SmallMeshCulling: self.m_SmallMeshCulling.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_StaticBatchInfo: self.m_StaticBatchInfo.clone(),
            m_StaticBatchRoot: self.m_StaticBatchRoot.clone(),
            m_StaticShadowCaster: self.m_StaticShadowCaster.clone(),
            m_SubsetIndices: self.m_SubsetIndices.clone(),
            m_UseLightProbes: self.m_UseLightProbes.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ParticleRenderer {
    // extends Renderer
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub UV_Animation: Option<UVAnimation>,
    pub m_CameraVelocityScale: Option<f32>,
    pub m_CastShadows: Option<bool>,
    pub m_DynamicOccludee: Option<u8>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LengthScale: Option<f32>,
    pub m_LightProbeAnchor: Option<PPtrData<Transform>>,
    pub m_LightProbeUsage: Option<u8>,
    pub m_LightProbeVolumeOverride: Option<PPtrData<GameObject>>,
    pub m_LightmapIndex: Option<u16>,
    pub m_LightmapIndexDynamic: Option<u16>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_LightmapTilingOffsetDynamic: Option<Vector4>,
    pub m_Materials: Option<Vec<PPtrData<Material>>>,
    pub m_MaxParticleSize: Option<f32>,
    pub m_MotionVectors: Option<u8>,
    pub m_ProbeAnchor: Option<PPtrData<Transform>>,
    pub m_ReceiveShadows: Option<bool>,
    pub m_ReflectionProbeUsage: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
    pub m_StaticBatchInfo: Option<StaticBatchInfo>,
    pub m_StaticBatchRoot: Option<PPtrData<Transform>>,
    pub m_StretchParticles: Option<i32>,
    pub m_SubsetIndices: Option<Vec<u32>>,
    pub m_UseLightProbes: Option<bool>,
    pub m_VelocityScale: Option<f32>,
}

impl_object!(ParticleRenderer);

impl Clone for ParticleRenderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            UV_Animation: self.UV_Animation.clone(),
            m_CameraVelocityScale: self.m_CameraVelocityScale.clone(),
            m_CastShadows: self.m_CastShadows.clone(),
            m_DynamicOccludee: self.m_DynamicOccludee.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LengthScale: self.m_LengthScale.clone(),
            m_LightProbeAnchor: self.m_LightProbeAnchor.clone(),
            m_LightProbeUsage: self.m_LightProbeUsage.clone(),
            m_LightProbeVolumeOverride: self.m_LightProbeVolumeOverride.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapIndexDynamic: self.m_LightmapIndexDynamic.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_LightmapTilingOffsetDynamic: self.m_LightmapTilingOffsetDynamic.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MaxParticleSize: self.m_MaxParticleSize.clone(),
            m_MotionVectors: self.m_MotionVectors.clone(),
            m_ProbeAnchor: self.m_ProbeAnchor.clone(),
            m_ReceiveShadows: self.m_ReceiveShadows.clone(),
            m_ReflectionProbeUsage: self.m_ReflectionProbeUsage.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_StaticBatchInfo: self.m_StaticBatchInfo.clone(),
            m_StaticBatchRoot: self.m_StaticBatchRoot.clone(),
            m_StretchParticles: self.m_StretchParticles.clone(),
            m_SubsetIndices: self.m_SubsetIndices.clone(),
            m_UseLightProbes: self.m_UseLightProbes.clone(),
            m_VelocityScale: self.m_VelocityScale.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ParticleSystemRenderer {
    // extends Renderer
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AllowRoll: Option<bool>,
    pub m_ApplyActiveColorSpace: Option<bool>,
    pub m_CameraVelocityScale: Option<f32>,
    pub m_CastShadows: Option<bool>,
    pub m_DynamicOccludee: Option<u8>,
    pub m_EnableGPUInstancing: Option<bool>,
    pub m_Enabled: Option<bool>,
    pub m_Flip: Option<Vector3>,
    pub m_FreeformStretching: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LengthScale: Option<f32>,
    pub m_LightProbeAnchor: Option<PPtrData<Transform>>,
    pub m_LightProbeUsage: Option<u8>,
    pub m_LightProbeVolumeOverride: Option<PPtrData<GameObject>>,
    pub m_LightmapIndex: Option<u16>,
    pub m_LightmapIndexDynamic: Option<u16>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_LightmapTilingOffsetDynamic: Option<Vector4>,
    pub m_MaskInteraction: Option<i32>,
    pub m_Materials: Option<Vec<PPtrData<Material>>>,
    pub m_MaxParticleSize: Option<f32>,
    pub m_Mesh: Option<PPtrData<Mesh>>,
    pub m_Mesh1: Option<PPtrData<Mesh>>,
    pub m_Mesh2: Option<PPtrData<Mesh>>,
    pub m_Mesh3: Option<PPtrData<Mesh>>,
    pub m_MeshDistribution: Option<u8>,
    pub m_MeshWeighting: Option<f32>,
    pub m_MeshWeighting1: Option<f32>,
    pub m_MeshWeighting2: Option<f32>,
    pub m_MeshWeighting3: Option<f32>,
    pub m_MinParticleSize: Option<f32>,
    pub m_MotionVectors: Option<u8>,
    pub m_NormalDirection: Option<f32>,
    pub m_Pivot: Option<Vector3>,
    pub m_ProbeAnchor: Option<PPtrData<Transform>>,
    pub m_RayTraceProcedural: Option<u8>,
    pub m_RayTracingAccelStructBuildFlags: Option<u8>,
    pub m_RayTracingAccelStructBuildFlagsOverride: Option<u8>,
    pub m_RayTracingMode: Option<u8>,
    pub m_ReceiveShadows: Option<bool>,
    pub m_ReflectionProbeUsage: Option<i32>,
    pub m_RenderAlignment: Option<i32>,
    pub m_RenderMode: Option<i32>,
    pub m_RendererPriority: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_RotateWithStretchDirection: Option<bool>,
    pub m_ShadowBias: Option<f32>,
    pub m_SmallMeshCulling: Option<u8>,
    pub m_SortMode: Option<i32>,
    pub m_SortingFudge: Option<f32>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
    pub m_StaticBatchInfo: Option<StaticBatchInfo>,
    pub m_StaticBatchRoot: Option<PPtrData<Transform>>,
    pub m_StaticShadowCaster: Option<u8>,
    pub m_SubsetIndices: Option<Vec<u32>>,
    pub m_TrailVertexStreams: Option<Vec<u8>>,
    pub m_UseCustomTrailVertexStreams: Option<bool>,
    pub m_UseCustomVertexStreams: Option<bool>,
    pub m_UseLightProbes: Option<bool>,
    pub m_VelocityScale: Option<f32>,
    pub m_VertexStreamMask: Option<i32>,
    pub m_VertexStreams: Option<Vec<u8>>,
}

impl_object!(ParticleSystemRenderer);

impl Clone for ParticleSystemRenderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AllowRoll: self.m_AllowRoll.clone(),
            m_ApplyActiveColorSpace: self.m_ApplyActiveColorSpace.clone(),
            m_CameraVelocityScale: self.m_CameraVelocityScale.clone(),
            m_CastShadows: self.m_CastShadows.clone(),
            m_DynamicOccludee: self.m_DynamicOccludee.clone(),
            m_EnableGPUInstancing: self.m_EnableGPUInstancing.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_Flip: self.m_Flip.clone(),
            m_FreeformStretching: self.m_FreeformStretching.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LengthScale: self.m_LengthScale.clone(),
            m_LightProbeAnchor: self.m_LightProbeAnchor.clone(),
            m_LightProbeUsage: self.m_LightProbeUsage.clone(),
            m_LightProbeVolumeOverride: self.m_LightProbeVolumeOverride.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapIndexDynamic: self.m_LightmapIndexDynamic.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_LightmapTilingOffsetDynamic: self.m_LightmapTilingOffsetDynamic.clone(),
            m_MaskInteraction: self.m_MaskInteraction.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MaxParticleSize: self.m_MaxParticleSize.clone(),
            m_Mesh: self.m_Mesh.clone(),
            m_Mesh1: self.m_Mesh1.clone(),
            m_Mesh2: self.m_Mesh2.clone(),
            m_Mesh3: self.m_Mesh3.clone(),
            m_MeshDistribution: self.m_MeshDistribution.clone(),
            m_MeshWeighting: self.m_MeshWeighting.clone(),
            m_MeshWeighting1: self.m_MeshWeighting1.clone(),
            m_MeshWeighting2: self.m_MeshWeighting2.clone(),
            m_MeshWeighting3: self.m_MeshWeighting3.clone(),
            m_MinParticleSize: self.m_MinParticleSize.clone(),
            m_MotionVectors: self.m_MotionVectors.clone(),
            m_NormalDirection: self.m_NormalDirection.clone(),
            m_Pivot: self.m_Pivot.clone(),
            m_ProbeAnchor: self.m_ProbeAnchor.clone(),
            m_RayTraceProcedural: self.m_RayTraceProcedural.clone(),
            m_RayTracingAccelStructBuildFlags: self.m_RayTracingAccelStructBuildFlags.clone(),
            m_RayTracingAccelStructBuildFlagsOverride: self
                .m_RayTracingAccelStructBuildFlagsOverride
                .clone(),
            m_RayTracingMode: self.m_RayTracingMode.clone(),
            m_ReceiveShadows: self.m_ReceiveShadows.clone(),
            m_ReflectionProbeUsage: self.m_ReflectionProbeUsage.clone(),
            m_RenderAlignment: self.m_RenderAlignment.clone(),
            m_RenderMode: self.m_RenderMode.clone(),
            m_RendererPriority: self.m_RendererPriority.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_RotateWithStretchDirection: self.m_RotateWithStretchDirection.clone(),
            m_ShadowBias: self.m_ShadowBias.clone(),
            m_SmallMeshCulling: self.m_SmallMeshCulling.clone(),
            m_SortMode: self.m_SortMode.clone(),
            m_SortingFudge: self.m_SortingFudge.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_StaticBatchInfo: self.m_StaticBatchInfo.clone(),
            m_StaticBatchRoot: self.m_StaticBatchRoot.clone(),
            m_StaticShadowCaster: self.m_StaticShadowCaster.clone(),
            m_SubsetIndices: self.m_SubsetIndices.clone(),
            m_TrailVertexStreams: self.m_TrailVertexStreams.clone(),
            m_UseCustomTrailVertexStreams: self.m_UseCustomTrailVertexStreams.clone(),
            m_UseCustomVertexStreams: self.m_UseCustomVertexStreams.clone(),
            m_UseLightProbes: self.m_UseLightProbes.clone(),
            m_VelocityScale: self.m_VelocityScale.clone(),
            m_VertexStreamMask: self.m_VertexStreamMask.clone(),
            m_VertexStreams: self.m_VertexStreams.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SkinnedMeshRenderer {
    // extends Renderer
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AABB: Option<AABB>,
    pub m_BlendShapeWeights: Option<Vec<f32>>,
    pub m_Bones: Option<Vec<PPtrData<Transform>>>,
    pub m_CastShadows: Option<bool>,
    pub m_DirtyAABB: Option<bool>,
    pub m_DynamicOccludee: Option<u8>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LightProbeAnchor: Option<PPtrData<Transform>>,
    pub m_LightProbeUsage: Option<u8>,
    pub m_LightProbeVolumeOverride: Option<PPtrData<GameObject>>,
    pub m_LightmapIndex: Option<u16>,
    pub m_LightmapIndexDynamic: Option<u16>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_LightmapTilingOffsetDynamic: Option<Vector4>,
    pub m_Materials: Option<Vec<PPtrData<Material>>>,
    pub m_Mesh: Option<PPtrData<Mesh>>,
    pub m_MotionVectors: Option<u8>,
    pub m_ProbeAnchor: Option<PPtrData<Transform>>,
    pub m_Quality: Option<i32>,
    pub m_RayTraceProcedural: Option<u8>,
    pub m_RayTracingAccelStructBuildFlags: Option<u8>,
    pub m_RayTracingAccelStructBuildFlagsOverride: Option<u8>,
    pub m_RayTracingMode: Option<u8>,
    pub m_ReceiveShadows: Option<bool>,
    pub m_ReflectionProbeUsage: Option<i32>,
    pub m_RendererPriority: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_RootBone: Option<PPtrData<Transform>>,
    pub m_SkinnedMotionVectors: Option<bool>,
    pub m_SmallMeshCulling: Option<u8>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
    pub m_StaticBatchInfo: Option<StaticBatchInfo>,
    pub m_StaticBatchRoot: Option<PPtrData<Transform>>,
    pub m_StaticShadowCaster: Option<u8>,
    pub m_SubsetIndices: Option<Vec<u32>>,
    pub m_UpdateWhenOffscreen: Option<bool>,
    pub m_UseLightProbes: Option<bool>,
}

impl_object!(SkinnedMeshRenderer);

impl Clone for SkinnedMeshRenderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AABB: self.m_AABB.clone(),
            m_BlendShapeWeights: self.m_BlendShapeWeights.clone(),
            m_Bones: self.m_Bones.clone(),
            m_CastShadows: self.m_CastShadows.clone(),
            m_DirtyAABB: self.m_DirtyAABB.clone(),
            m_DynamicOccludee: self.m_DynamicOccludee.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LightProbeAnchor: self.m_LightProbeAnchor.clone(),
            m_LightProbeUsage: self.m_LightProbeUsage.clone(),
            m_LightProbeVolumeOverride: self.m_LightProbeVolumeOverride.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapIndexDynamic: self.m_LightmapIndexDynamic.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_LightmapTilingOffsetDynamic: self.m_LightmapTilingOffsetDynamic.clone(),
            m_Materials: self.m_Materials.clone(),
            m_Mesh: self.m_Mesh.clone(),
            m_MotionVectors: self.m_MotionVectors.clone(),
            m_ProbeAnchor: self.m_ProbeAnchor.clone(),
            m_Quality: self.m_Quality.clone(),
            m_RayTraceProcedural: self.m_RayTraceProcedural.clone(),
            m_RayTracingAccelStructBuildFlags: self.m_RayTracingAccelStructBuildFlags.clone(),
            m_RayTracingAccelStructBuildFlagsOverride: self
                .m_RayTracingAccelStructBuildFlagsOverride
                .clone(),
            m_RayTracingMode: self.m_RayTracingMode.clone(),
            m_ReceiveShadows: self.m_ReceiveShadows.clone(),
            m_ReflectionProbeUsage: self.m_ReflectionProbeUsage.clone(),
            m_RendererPriority: self.m_RendererPriority.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_RootBone: self.m_RootBone.clone(),
            m_SkinnedMotionVectors: self.m_SkinnedMotionVectors.clone(),
            m_SmallMeshCulling: self.m_SmallMeshCulling.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_StaticBatchInfo: self.m_StaticBatchInfo.clone(),
            m_StaticBatchRoot: self.m_StaticBatchRoot.clone(),
            m_StaticShadowCaster: self.m_StaticShadowCaster.clone(),
            m_SubsetIndices: self.m_SubsetIndices.clone(),
            m_UpdateWhenOffscreen: self.m_UpdateWhenOffscreen.clone(),
            m_UseLightProbes: self.m_UseLightProbes.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteMask {
    // extends Renderer
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BackSortingLayer: Option<i16>,
    pub m_BackSortingLayerID: Option<i32>,
    pub m_BackSortingOrder: Option<i16>,
    pub m_CastShadows: Option<u8>,
    pub m_DynamicOccludee: Option<u8>,
    pub m_Enabled: Option<bool>,
    pub m_FrontSortingLayer: Option<i16>,
    pub m_FrontSortingLayerID: Option<i32>,
    pub m_FrontSortingOrder: Option<i16>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_IsCustomRangeActive: Option<bool>,
    pub m_LightProbeUsage: Option<u8>,
    pub m_LightProbeVolumeOverride: Option<PPtrData<GameObject>>,
    pub m_LightmapIndex: Option<u16>,
    pub m_LightmapIndexDynamic: Option<u16>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_LightmapTilingOffsetDynamic: Option<Vector4>,
    pub m_MaskAlphaCutoff: Option<f32>,
    pub m_MaskSource: Option<i32>,
    pub m_Materials: Option<Vec<PPtrData<Material>>>,
    pub m_MotionVectors: Option<u8>,
    pub m_ProbeAnchor: Option<PPtrData<Transform>>,
    pub m_RayTraceProcedural: Option<u8>,
    pub m_RayTracingAccelStructBuildFlags: Option<u8>,
    pub m_RayTracingAccelStructBuildFlagsOverride: Option<u8>,
    pub m_RayTracingMode: Option<u8>,
    pub m_ReceiveShadows: Option<u8>,
    pub m_ReflectionProbeUsage: Option<u8>,
    pub m_RendererPriority: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_SmallMeshCulling: Option<u8>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
    pub m_Sprite: Option<PPtrData<Sprite>>,
    pub m_SpriteSortPoint: Option<i32>,
    pub m_StaticBatchInfo: Option<StaticBatchInfo>,
    pub m_StaticBatchRoot: Option<PPtrData<Transform>>,
    pub m_StaticShadowCaster: Option<u8>,
}

impl_object!(SpriteMask);

impl Clone for SpriteMask {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BackSortingLayer: self.m_BackSortingLayer.clone(),
            m_BackSortingLayerID: self.m_BackSortingLayerID.clone(),
            m_BackSortingOrder: self.m_BackSortingOrder.clone(),
            m_CastShadows: self.m_CastShadows.clone(),
            m_DynamicOccludee: self.m_DynamicOccludee.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_FrontSortingLayer: self.m_FrontSortingLayer.clone(),
            m_FrontSortingLayerID: self.m_FrontSortingLayerID.clone(),
            m_FrontSortingOrder: self.m_FrontSortingOrder.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_IsCustomRangeActive: self.m_IsCustomRangeActive.clone(),
            m_LightProbeUsage: self.m_LightProbeUsage.clone(),
            m_LightProbeVolumeOverride: self.m_LightProbeVolumeOverride.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapIndexDynamic: self.m_LightmapIndexDynamic.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_LightmapTilingOffsetDynamic: self.m_LightmapTilingOffsetDynamic.clone(),
            m_MaskAlphaCutoff: self.m_MaskAlphaCutoff.clone(),
            m_MaskSource: self.m_MaskSource.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MotionVectors: self.m_MotionVectors.clone(),
            m_ProbeAnchor: self.m_ProbeAnchor.clone(),
            m_RayTraceProcedural: self.m_RayTraceProcedural.clone(),
            m_RayTracingAccelStructBuildFlags: self.m_RayTracingAccelStructBuildFlags.clone(),
            m_RayTracingAccelStructBuildFlagsOverride: self
                .m_RayTracingAccelStructBuildFlagsOverride
                .clone(),
            m_RayTracingMode: self.m_RayTracingMode.clone(),
            m_ReceiveShadows: self.m_ReceiveShadows.clone(),
            m_ReflectionProbeUsage: self.m_ReflectionProbeUsage.clone(),
            m_RendererPriority: self.m_RendererPriority.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_SmallMeshCulling: self.m_SmallMeshCulling.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_Sprite: self.m_Sprite.clone(),
            m_SpriteSortPoint: self.m_SpriteSortPoint.clone(),
            m_StaticBatchInfo: self.m_StaticBatchInfo.clone(),
            m_StaticBatchRoot: self.m_StaticBatchRoot.clone(),
            m_StaticShadowCaster: self.m_StaticShadowCaster.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteRenderer {
    // extends Renderer
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AdaptiveModeThreshold: Option<f32>,
    pub m_CastShadows: Option<bool>,
    pub m_Color: Option<Color>,
    pub m_DrawMode: Option<i32>,
    pub m_DynamicOccludee: Option<u8>,
    pub m_Enabled: Option<bool>,
    pub m_FlipX: Option<bool>,
    pub m_FlipY: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LightProbeAnchor: Option<PPtrData<Transform>>,
    pub m_LightProbeUsage: Option<u8>,
    pub m_LightProbeVolumeOverride: Option<PPtrData<GameObject>>,
    pub m_LightmapIndex: Option<u16>,
    pub m_LightmapIndexDynamic: Option<u16>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_LightmapTilingOffsetDynamic: Option<Vector4>,
    pub m_MaskInteraction: Option<i32>,
    pub m_Materials: Option<Vec<PPtrData<Material>>>,
    pub m_MotionVectors: Option<u8>,
    pub m_ProbeAnchor: Option<PPtrData<Transform>>,
    pub m_RayTraceProcedural: Option<u8>,
    pub m_RayTracingAccelStructBuildFlags: Option<u8>,
    pub m_RayTracingAccelStructBuildFlagsOverride: Option<u8>,
    pub m_RayTracingMode: Option<u8>,
    pub m_ReceiveShadows: Option<bool>,
    pub m_ReflectionProbeUsage: Option<i32>,
    pub m_RendererPriority: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_Size: Option<Vector2>,
    pub m_SmallMeshCulling: Option<u8>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
    pub m_Sprite: Option<PPtrData<Sprite>>,
    pub m_SpriteSortPoint: Option<i32>,
    pub m_SpriteTileMode: Option<i32>,
    pub m_StaticBatchInfo: Option<StaticBatchInfo>,
    pub m_StaticBatchRoot: Option<PPtrData<Transform>>,
    pub m_StaticShadowCaster: Option<u8>,
    pub m_SubsetIndices: Option<Vec<u32>>,
    pub m_UseLightProbes: Option<bool>,
    pub m_WasSpriteAssigned: Option<bool>,
}

impl_object!(SpriteRenderer);

impl Clone for SpriteRenderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AdaptiveModeThreshold: self.m_AdaptiveModeThreshold.clone(),
            m_CastShadows: self.m_CastShadows.clone(),
            m_Color: self.m_Color.clone(),
            m_DrawMode: self.m_DrawMode.clone(),
            m_DynamicOccludee: self.m_DynamicOccludee.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_FlipX: self.m_FlipX.clone(),
            m_FlipY: self.m_FlipY.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LightProbeAnchor: self.m_LightProbeAnchor.clone(),
            m_LightProbeUsage: self.m_LightProbeUsage.clone(),
            m_LightProbeVolumeOverride: self.m_LightProbeVolumeOverride.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapIndexDynamic: self.m_LightmapIndexDynamic.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_LightmapTilingOffsetDynamic: self.m_LightmapTilingOffsetDynamic.clone(),
            m_MaskInteraction: self.m_MaskInteraction.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MotionVectors: self.m_MotionVectors.clone(),
            m_ProbeAnchor: self.m_ProbeAnchor.clone(),
            m_RayTraceProcedural: self.m_RayTraceProcedural.clone(),
            m_RayTracingAccelStructBuildFlags: self.m_RayTracingAccelStructBuildFlags.clone(),
            m_RayTracingAccelStructBuildFlagsOverride: self
                .m_RayTracingAccelStructBuildFlagsOverride
                .clone(),
            m_RayTracingMode: self.m_RayTracingMode.clone(),
            m_ReceiveShadows: self.m_ReceiveShadows.clone(),
            m_ReflectionProbeUsage: self.m_ReflectionProbeUsage.clone(),
            m_RendererPriority: self.m_RendererPriority.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_Size: self.m_Size.clone(),
            m_SmallMeshCulling: self.m_SmallMeshCulling.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_Sprite: self.m_Sprite.clone(),
            m_SpriteSortPoint: self.m_SpriteSortPoint.clone(),
            m_SpriteTileMode: self.m_SpriteTileMode.clone(),
            m_StaticBatchInfo: self.m_StaticBatchInfo.clone(),
            m_StaticBatchRoot: self.m_StaticBatchRoot.clone(),
            m_StaticShadowCaster: self.m_StaticShadowCaster.clone(),
            m_SubsetIndices: self.m_SubsetIndices.clone(),
            m_UseLightProbes: self.m_UseLightProbes.clone(),
            m_WasSpriteAssigned: self.m_WasSpriteAssigned.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteShapeRenderer {
    // extends Renderer
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CastShadows: Option<u8>,
    pub m_Color: Option<Color>,
    pub m_DynamicOccludee: Option<u8>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LightProbeUsage: Option<u8>,
    pub m_LightProbeVolumeOverride: Option<PPtrData<GameObject>>,
    pub m_LightmapIndex: Option<u16>,
    pub m_LightmapIndexDynamic: Option<u16>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_LightmapTilingOffsetDynamic: Option<Vector4>,
    pub m_LocalAABB: Option<AABB>,
    pub m_MaskInteraction: Option<i32>,
    pub m_Materials: Option<Vec<PPtrData<Material>>>,
    pub m_MotionVectors: Option<u8>,
    pub m_ProbeAnchor: Option<PPtrData<Transform>>,
    pub m_RayTraceProcedural: Option<u8>,
    pub m_RayTracingAccelStructBuildFlags: Option<u8>,
    pub m_RayTracingAccelStructBuildFlagsOverride: Option<u8>,
    pub m_RayTracingMode: Option<u8>,
    pub m_ReceiveShadows: Option<u8>,
    pub m_ReflectionProbeUsage: Option<u8>,
    pub m_RendererPriority: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_ShapeTexture: Option<PPtrData<Texture2D>>,
    pub m_SmallMeshCulling: Option<u8>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
    pub m_SpriteSortPoint: Option<i32>,
    pub m_Sprites: Option<Vec<PPtrData<Sprite>>>,
    pub m_StaticBatchInfo: Option<StaticBatchInfo>,
    pub m_StaticBatchRoot: Option<PPtrData<Transform>>,
    pub m_StaticShadowCaster: Option<u8>,
}

impl_object!(SpriteShapeRenderer);

impl Clone for SpriteShapeRenderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CastShadows: self.m_CastShadows.clone(),
            m_Color: self.m_Color.clone(),
            m_DynamicOccludee: self.m_DynamicOccludee.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LightProbeUsage: self.m_LightProbeUsage.clone(),
            m_LightProbeVolumeOverride: self.m_LightProbeVolumeOverride.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapIndexDynamic: self.m_LightmapIndexDynamic.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_LightmapTilingOffsetDynamic: self.m_LightmapTilingOffsetDynamic.clone(),
            m_LocalAABB: self.m_LocalAABB.clone(),
            m_MaskInteraction: self.m_MaskInteraction.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MotionVectors: self.m_MotionVectors.clone(),
            m_ProbeAnchor: self.m_ProbeAnchor.clone(),
            m_RayTraceProcedural: self.m_RayTraceProcedural.clone(),
            m_RayTracingAccelStructBuildFlags: self.m_RayTracingAccelStructBuildFlags.clone(),
            m_RayTracingAccelStructBuildFlagsOverride: self
                .m_RayTracingAccelStructBuildFlagsOverride
                .clone(),
            m_RayTracingMode: self.m_RayTracingMode.clone(),
            m_ReceiveShadows: self.m_ReceiveShadows.clone(),
            m_ReflectionProbeUsage: self.m_ReflectionProbeUsage.clone(),
            m_RendererPriority: self.m_RendererPriority.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_ShapeTexture: self.m_ShapeTexture.clone(),
            m_SmallMeshCulling: self.m_SmallMeshCulling.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_SpriteSortPoint: self.m_SpriteSortPoint.clone(),
            m_Sprites: self.m_Sprites.clone(),
            m_StaticBatchInfo: self.m_StaticBatchInfo.clone(),
            m_StaticBatchRoot: self.m_StaticBatchRoot.clone(),
            m_StaticShadowCaster: self.m_StaticShadowCaster.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TilemapRenderer {
    // extends Renderer
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CastShadows: Option<u8>,
    pub m_ChunkCullingBounds: Option<Vector3>,
    pub m_ChunkSize: Option<int3_storage>,
    pub m_DetectChunkCullingBounds: Option<i32>,
    pub m_DynamicOccludee: Option<u8>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LightProbeUsage: Option<u8>,
    pub m_LightProbeVolumeOverride: Option<PPtrData<GameObject>>,
    pub m_LightmapIndex: Option<u16>,
    pub m_LightmapIndexDynamic: Option<u16>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_LightmapTilingOffsetDynamic: Option<Vector4>,
    pub m_MaskInteraction: Option<i32>,
    pub m_Materials: Option<Vec<PPtrData<Material>>>,
    pub m_MaxChunkCount: Option<u32>,
    pub m_MaxFrameAge: Option<u32>,
    pub m_Mode: Option<i32>,
    pub m_MotionVectors: Option<u8>,
    pub m_ProbeAnchor: Option<PPtrData<Transform>>,
    pub m_RayTraceProcedural: Option<u8>,
    pub m_RayTracingAccelStructBuildFlags: Option<u8>,
    pub m_RayTracingAccelStructBuildFlagsOverride: Option<u8>,
    pub m_RayTracingMode: Option<u8>,
    pub m_ReceiveShadows: Option<u8>,
    pub m_ReflectionProbeUsage: Option<u8>,
    pub m_RendererPriority: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_SmallMeshCulling: Option<u8>,
    pub m_SortOrder: Option<i32>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
    pub m_StaticBatchInfo: Option<StaticBatchInfo>,
    pub m_StaticBatchRoot: Option<PPtrData<Transform>>,
    pub m_StaticShadowCaster: Option<u8>,
}

impl_object!(TilemapRenderer);

impl Clone for TilemapRenderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CastShadows: self.m_CastShadows.clone(),
            m_ChunkCullingBounds: self.m_ChunkCullingBounds.clone(),
            m_ChunkSize: self.m_ChunkSize.clone(),
            m_DetectChunkCullingBounds: self.m_DetectChunkCullingBounds.clone(),
            m_DynamicOccludee: self.m_DynamicOccludee.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LightProbeUsage: self.m_LightProbeUsage.clone(),
            m_LightProbeVolumeOverride: self.m_LightProbeVolumeOverride.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapIndexDynamic: self.m_LightmapIndexDynamic.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_LightmapTilingOffsetDynamic: self.m_LightmapTilingOffsetDynamic.clone(),
            m_MaskInteraction: self.m_MaskInteraction.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MaxChunkCount: self.m_MaxChunkCount.clone(),
            m_MaxFrameAge: self.m_MaxFrameAge.clone(),
            m_Mode: self.m_Mode.clone(),
            m_MotionVectors: self.m_MotionVectors.clone(),
            m_ProbeAnchor: self.m_ProbeAnchor.clone(),
            m_RayTraceProcedural: self.m_RayTraceProcedural.clone(),
            m_RayTracingAccelStructBuildFlags: self.m_RayTracingAccelStructBuildFlags.clone(),
            m_RayTracingAccelStructBuildFlagsOverride: self
                .m_RayTracingAccelStructBuildFlagsOverride
                .clone(),
            m_RayTracingMode: self.m_RayTracingMode.clone(),
            m_ReceiveShadows: self.m_ReceiveShadows.clone(),
            m_ReflectionProbeUsage: self.m_ReflectionProbeUsage.clone(),
            m_RendererPriority: self.m_RendererPriority.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_SmallMeshCulling: self.m_SmallMeshCulling.clone(),
            m_SortOrder: self.m_SortOrder.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_StaticBatchInfo: self.m_StaticBatchInfo.clone(),
            m_StaticBatchRoot: self.m_StaticBatchRoot.clone(),
            m_StaticShadowCaster: self.m_StaticShadowCaster.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TrailRenderer {
    // extends Renderer
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ApplyActiveColorSpace: Option<bool>,
    pub m_Autodestruct: Option<bool>,
    pub m_CastShadows: Option<bool>,
    pub m_Colors: Option<Gradient>,
    pub m_DynamicOccludee: Option<u8>,
    pub m_Emitting: Option<bool>,
    pub m_Enabled: Option<bool>,
    pub m_EndWidth: Option<f32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LightProbeAnchor: Option<PPtrData<Transform>>,
    pub m_LightProbeUsage: Option<u8>,
    pub m_LightProbeVolumeOverride: Option<PPtrData<GameObject>>,
    pub m_LightmapIndex: Option<u16>,
    pub m_LightmapIndexDynamic: Option<u16>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_LightmapTilingOffsetDynamic: Option<Vector4>,
    pub m_MaskInteraction: Option<i32>,
    pub m_Materials: Option<Vec<PPtrData<Material>>>,
    pub m_MinVertexDistance: Option<f32>,
    pub m_MotionVectors: Option<u8>,
    pub m_Parameters: Option<LineParameters>,
    pub m_ProbeAnchor: Option<PPtrData<Transform>>,
    pub m_RayTraceProcedural: Option<u8>,
    pub m_RayTracingAccelStructBuildFlags: Option<u8>,
    pub m_RayTracingAccelStructBuildFlagsOverride: Option<u8>,
    pub m_RayTracingMode: Option<u8>,
    pub m_ReceiveShadows: Option<bool>,
    pub m_ReflectionProbeUsage: Option<i32>,
    pub m_RendererPriority: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_SmallMeshCulling: Option<u8>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
    pub m_StartWidth: Option<f32>,
    pub m_StaticBatchInfo: Option<StaticBatchInfo>,
    pub m_StaticBatchRoot: Option<PPtrData<Transform>>,
    pub m_StaticShadowCaster: Option<u8>,
    pub m_SubsetIndices: Option<Vec<u32>>,
    pub m_Time: Option<f32>,
    pub m_UseLightProbes: Option<bool>,
}

impl_object!(TrailRenderer);

impl Clone for TrailRenderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ApplyActiveColorSpace: self.m_ApplyActiveColorSpace.clone(),
            m_Autodestruct: self.m_Autodestruct.clone(),
            m_CastShadows: self.m_CastShadows.clone(),
            m_Colors: self.m_Colors.clone(),
            m_DynamicOccludee: self.m_DynamicOccludee.clone(),
            m_Emitting: self.m_Emitting.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_EndWidth: self.m_EndWidth.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LightProbeAnchor: self.m_LightProbeAnchor.clone(),
            m_LightProbeUsage: self.m_LightProbeUsage.clone(),
            m_LightProbeVolumeOverride: self.m_LightProbeVolumeOverride.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapIndexDynamic: self.m_LightmapIndexDynamic.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_LightmapTilingOffsetDynamic: self.m_LightmapTilingOffsetDynamic.clone(),
            m_MaskInteraction: self.m_MaskInteraction.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MinVertexDistance: self.m_MinVertexDistance.clone(),
            m_MotionVectors: self.m_MotionVectors.clone(),
            m_Parameters: self.m_Parameters.clone(),
            m_ProbeAnchor: self.m_ProbeAnchor.clone(),
            m_RayTraceProcedural: self.m_RayTraceProcedural.clone(),
            m_RayTracingAccelStructBuildFlags: self.m_RayTracingAccelStructBuildFlags.clone(),
            m_RayTracingAccelStructBuildFlagsOverride: self
                .m_RayTracingAccelStructBuildFlagsOverride
                .clone(),
            m_RayTracingMode: self.m_RayTracingMode.clone(),
            m_ReceiveShadows: self.m_ReceiveShadows.clone(),
            m_ReflectionProbeUsage: self.m_ReflectionProbeUsage.clone(),
            m_RendererPriority: self.m_RendererPriority.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_SmallMeshCulling: self.m_SmallMeshCulling.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_StartWidth: self.m_StartWidth.clone(),
            m_StaticBatchInfo: self.m_StaticBatchInfo.clone(),
            m_StaticBatchRoot: self.m_StaticBatchRoot.clone(),
            m_StaticShadowCaster: self.m_StaticShadowCaster.clone(),
            m_SubsetIndices: self.m_SubsetIndices.clone(),
            m_Time: self.m_Time.clone(),
            m_UseLightProbes: self.m_UseLightProbes.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct UIRenderer {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CastShadows: Option<u8>,
    pub m_DynamicOccludee: Option<u8>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LightProbeUsage: Option<u8>,
    pub m_LightProbeVolumeOverride: Option<PPtrData<GameObject>>,
    pub m_LightmapIndex: Option<u16>,
    pub m_LightmapIndexDynamic: Option<u16>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_LightmapTilingOffsetDynamic: Option<Vector4>,
    pub m_Materials: Option<Vec<PPtrData<Material>>>,
    pub m_MotionVectors: Option<u8>,
    pub m_ProbeAnchor: Option<PPtrData<Transform>>,
    pub m_RayTraceProcedural: Option<u8>,
    pub m_RayTracingAccelStructBuildFlags: Option<u8>,
    pub m_RayTracingAccelStructBuildFlagsOverride: Option<u8>,
    pub m_RayTracingMode: Option<u8>,
    pub m_ReceiveShadows: Option<u8>,
    pub m_ReflectionProbeUsage: Option<u8>,
    pub m_RendererPriority: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_SmallMeshCulling: Option<u8>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
    pub m_StaticBatchInfo: Option<StaticBatchInfo>,
    pub m_StaticBatchRoot: Option<PPtrData<Transform>>,
    pub m_StaticShadowCaster: Option<u8>,
}

impl_object!(UIRenderer);

impl Clone for UIRenderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CastShadows: self.m_CastShadows.clone(),
            m_DynamicOccludee: self.m_DynamicOccludee.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LightProbeUsage: self.m_LightProbeUsage.clone(),
            m_LightProbeVolumeOverride: self.m_LightProbeVolumeOverride.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapIndexDynamic: self.m_LightmapIndexDynamic.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_LightmapTilingOffsetDynamic: self.m_LightmapTilingOffsetDynamic.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MotionVectors: self.m_MotionVectors.clone(),
            m_ProbeAnchor: self.m_ProbeAnchor.clone(),
            m_RayTraceProcedural: self.m_RayTraceProcedural.clone(),
            m_RayTracingAccelStructBuildFlags: self.m_RayTracingAccelStructBuildFlags.clone(),
            m_RayTracingAccelStructBuildFlagsOverride: self
                .m_RayTracingAccelStructBuildFlagsOverride
                .clone(),
            m_RayTracingMode: self.m_RayTracingMode.clone(),
            m_ReceiveShadows: self.m_ReceiveShadows.clone(),
            m_ReflectionProbeUsage: self.m_ReflectionProbeUsage.clone(),
            m_RendererPriority: self.m_RendererPriority.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_SmallMeshCulling: self.m_SmallMeshCulling.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_StaticBatchInfo: self.m_StaticBatchInfo.clone(),
            m_StaticBatchRoot: self.m_StaticBatchRoot.clone(),
            m_StaticShadowCaster: self.m_StaticShadowCaster.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXRenderer {
    // extends Renderer
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CastShadows: Option<u8>,
    pub m_DynamicOccludee: Option<u8>,
    pub m_Enabled: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LightProbeUsage: Option<u8>,
    pub m_LightProbeVolumeOverride: Option<PPtrData<GameObject>>,
    pub m_LightmapIndex: Option<u16>,
    pub m_LightmapIndexDynamic: Option<u16>,
    pub m_LightmapTilingOffset: Option<Vector4>,
    pub m_LightmapTilingOffsetDynamic: Option<Vector4>,
    pub m_Materials: Option<Vec<PPtrData<Material>>>,
    pub m_MotionVectors: Option<u8>,
    pub m_ProbeAnchor: Option<PPtrData<Transform>>,
    pub m_RayTraceProcedural: Option<u8>,
    pub m_RayTracingAccelStructBuildFlags: Option<u8>,
    pub m_RayTracingAccelStructBuildFlagsOverride: Option<u8>,
    pub m_RayTracingMode: Option<u8>,
    pub m_ReceiveShadows: Option<u8>,
    pub m_ReflectionProbeUsage: Option<u8>,
    pub m_RendererPriority: Option<i32>,
    pub m_RenderingLayerMask: Option<u32>,
    pub m_SmallMeshCulling: Option<u8>,
    pub m_SortingLayer: Option<i16>,
    pub m_SortingLayerID: Option<i32>,
    pub m_SortingOrder: Option<i16>,
    pub m_StaticBatchInfo: Option<StaticBatchInfo>,
    pub m_StaticBatchRoot: Option<PPtrData<Transform>>,
    pub m_StaticShadowCaster: Option<u8>,
}

impl_object!(VFXRenderer);

impl Clone for VFXRenderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CastShadows: self.m_CastShadows.clone(),
            m_DynamicOccludee: self.m_DynamicOccludee.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LightProbeUsage: self.m_LightProbeUsage.clone(),
            m_LightProbeVolumeOverride: self.m_LightProbeVolumeOverride.clone(),
            m_LightmapIndex: self.m_LightmapIndex.clone(),
            m_LightmapIndexDynamic: self.m_LightmapIndexDynamic.clone(),
            m_LightmapTilingOffset: self.m_LightmapTilingOffset.clone(),
            m_LightmapTilingOffsetDynamic: self.m_LightmapTilingOffsetDynamic.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MotionVectors: self.m_MotionVectors.clone(),
            m_ProbeAnchor: self.m_ProbeAnchor.clone(),
            m_RayTraceProcedural: self.m_RayTraceProcedural.clone(),
            m_RayTracingAccelStructBuildFlags: self.m_RayTracingAccelStructBuildFlags.clone(),
            m_RayTracingAccelStructBuildFlagsOverride: self
                .m_RayTracingAccelStructBuildFlagsOverride
                .clone(),
            m_RayTracingMode: self.m_RayTracingMode.clone(),
            m_ReceiveShadows: self.m_ReceiveShadows.clone(),
            m_ReflectionProbeUsage: self.m_ReflectionProbeUsage.clone(),
            m_RendererPriority: self.m_RendererPriority.clone(),
            m_RenderingLayerMask: self.m_RenderingLayerMask.clone(),
            m_SmallMeshCulling: self.m_SmallMeshCulling.clone(),
            m_SortingLayer: self.m_SortingLayer.clone(),
            m_SortingLayerID: self.m_SortingLayerID.clone(),
            m_SortingOrder: self.m_SortingOrder.clone(),
            m_StaticBatchInfo: self.m_StaticBatchInfo.clone(),
            m_StaticBatchRoot: self.m_StaticBatchRoot.clone(),
            m_StaticShadowCaster: self.m_StaticShadowCaster.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Rigidbody {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AngularDrag: Option<f32>,
    pub m_CenterOfMass: Option<Vector3>,
    pub m_CollisionDetection: Option<i32>,
    pub m_Constraints: Option<i32>,
    pub m_Drag: Option<f32>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_ImplicitCom: Option<bool>,
    pub m_ImplicitTensor: Option<bool>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_InertiaRotation: Option<Quaternion>,
    pub m_InertiaTensor: Option<Vector3>,
    pub m_Interpolate: Option<u8>,
    pub m_IsKinematic: Option<bool>,
    pub m_Mass: Option<f32>,
    pub m_UseGravity: Option<bool>,
}

impl_object!(Rigidbody);

impl Clone for Rigidbody {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AngularDrag: self.m_AngularDrag.clone(),
            m_CenterOfMass: self.m_CenterOfMass.clone(),
            m_CollisionDetection: self.m_CollisionDetection.clone(),
            m_Constraints: self.m_Constraints.clone(),
            m_Drag: self.m_Drag.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_ImplicitCom: self.m_ImplicitCom.clone(),
            m_ImplicitTensor: self.m_ImplicitTensor.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_InertiaRotation: self.m_InertiaRotation.clone(),
            m_InertiaTensor: self.m_InertiaTensor.clone(),
            m_Interpolate: self.m_Interpolate.clone(),
            m_IsKinematic: self.m_IsKinematic.clone(),
            m_Mass: self.m_Mass.clone(),
            m_UseGravity: self.m_UseGravity.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Rigidbody2D {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AngularDamping: Option<f32>,
    pub m_AngularDrag: Option<f32>,
    pub m_BodyType: Option<i32>,
    pub m_CollisionDetection: Option<i32>,
    pub m_Constraints: Option<i32>,
    pub m_ExcludeLayers: Option<BitField>,
    pub m_FixedAngle: Option<bool>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_GravityScale: Option<f32>,
    pub m_IncludeLayers: Option<BitField>,
    pub m_Interpolate: Option<i32>,
    pub m_IsKinematic: Option<bool>,
    pub m_LinearDamping: Option<f32>,
    pub m_LinearDrag: Option<f32>,
    pub m_Mass: Option<f32>,
    pub m_Material: Option<PPtrData<PhysicsMaterial2D>>,
    pub m_Simulated: Option<bool>,
    pub m_SleepingMode: Option<i32>,
    pub m_UseAutoMass: Option<bool>,
    pub m_UseFullKinematicContacts: Option<bool>,
}

impl_object!(Rigidbody2D);

impl Clone for Rigidbody2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AngularDamping: self.m_AngularDamping.clone(),
            m_AngularDrag: self.m_AngularDrag.clone(),
            m_BodyType: self.m_BodyType.clone(),
            m_CollisionDetection: self.m_CollisionDetection.clone(),
            m_Constraints: self.m_Constraints.clone(),
            m_ExcludeLayers: self.m_ExcludeLayers.clone(),
            m_FixedAngle: self.m_FixedAngle.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_GravityScale: self.m_GravityScale.clone(),
            m_IncludeLayers: self.m_IncludeLayers.clone(),
            m_Interpolate: self.m_Interpolate.clone(),
            m_IsKinematic: self.m_IsKinematic.clone(),
            m_LinearDamping: self.m_LinearDamping.clone(),
            m_LinearDrag: self.m_LinearDrag.clone(),
            m_Mass: self.m_Mass.clone(),
            m_Material: self.m_Material.clone(),
            m_Simulated: self.m_Simulated.clone(),
            m_SleepingMode: self.m_SleepingMode.clone(),
            m_UseAutoMass: self.m_UseAutoMass.clone(),
            m_UseFullKinematicContacts: self.m_UseFullKinematicContacts.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TextMesh {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Alignment: Option<i16>,
    pub m_Anchor: Option<i16>,
    pub m_CharacterSize: Option<f32>,
    pub m_Color: Option<Color>,
    pub m_Font: Option<PPtrData<Font>>,
    pub m_FontSize: Option<i32>,
    pub m_FontStyle: Option<i32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LineSpacing: Option<f32>,
    pub m_OffsetZ: Option<f32>,
    pub m_RichText: Option<bool>,
    pub m_TabSize: Option<f32>,
    pub m_Text: Option<String>,
}

impl_object!(TextMesh);

impl Clone for TextMesh {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Alignment: self.m_Alignment.clone(),
            m_Anchor: self.m_Anchor.clone(),
            m_CharacterSize: self.m_CharacterSize.clone(),
            m_Color: self.m_Color.clone(),
            m_Font: self.m_Font.clone(),
            m_FontSize: self.m_FontSize.clone(),
            m_FontStyle: self.m_FontStyle.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LineSpacing: self.m_LineSpacing.clone(),
            m_OffsetZ: self.m_OffsetZ.clone(),
            m_RichText: self.m_RichText.clone(),
            m_TabSize: self.m_TabSize.clone(),
            m_Text: self.m_Text.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Transform {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Children: Option<Vec<PPtrData<Transform>>>,
    pub m_Father: Option<PPtrData<Transform>>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LocalPosition: Option<Vector3>,
    pub m_LocalRotation: Option<Quaternion>,
    pub m_LocalScale: Option<Vector3>,
}

impl_object!(Transform);

impl Clone for Transform {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Children: self.m_Children.clone(),
            m_Father: self.m_Father.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LocalPosition: self.m_LocalPosition.clone(),
            m_LocalRotation: self.m_LocalRotation.clone(),
            m_LocalScale: self.m_LocalScale.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RectTransform {
    // extends Transform
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AnchorMax: Option<Vector2>,
    pub m_AnchorMin: Option<Vector2>,
    pub m_AnchoredPosition: Option<Vector2>,
    pub m_Children: Option<Vec<PPtrData<Transform>>>,
    pub m_Father: Option<PPtrData<Transform>>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_LocalPosition: Option<Vector3>,
    pub m_LocalRotation: Option<Quaternion>,
    pub m_LocalScale: Option<Vector3>,
    pub m_Pivot: Option<Vector2>,
    pub m_Position: Option<Vector2>,
    pub m_SizeDelta: Option<Vector2>,
}

impl_object!(RectTransform);

impl Clone for RectTransform {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AnchorMax: self.m_AnchorMax.clone(),
            m_AnchorMin: self.m_AnchorMin.clone(),
            m_AnchoredPosition: self.m_AnchoredPosition.clone(),
            m_Children: self.m_Children.clone(),
            m_Father: self.m_Father.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_LocalPosition: self.m_LocalPosition.clone(),
            m_LocalRotation: self.m_LocalRotation.clone(),
            m_LocalScale: self.m_LocalScale.clone(),
            m_Pivot: self.m_Pivot.clone(),
            m_Position: self.m_Position.clone(),
            m_SizeDelta: self.m_SizeDelta.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Tree {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_SpeedTreeWindAsset: Option<PPtrData<SpeedTreeWindAsset>>,
}

impl_object!(Tree);

impl Clone for Tree {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
            m_SpeedTreeWindAsset: self.m_SpeedTreeWindAsset.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct WorldAnchor {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(WorldAnchor);

impl Clone for WorldAnchor {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct WorldParticleCollider {
    // extends Component
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BounceFactor: Option<f32>,
    pub m_CollidesWith: Option<BitField>,
    pub m_CollisionEnergyLoss: Option<f32>,
    pub m_GameObject: Option<PPtrData<GameObject>>,
    pub m_MinKillVelocity: Option<f32>,
    pub m_SendCollisionMessage: Option<bool>,
}

impl_object!(WorldParticleCollider);

impl Clone for WorldParticleCollider {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BounceFactor: self.m_BounceFactor.clone(),
            m_CollidesWith: self.m_CollidesWith.clone(),
            m_CollisionEnergyLoss: self.m_CollisionEnergyLoss.clone(),
            m_GameObject: self.m_GameObject.clone(),
            m_MinKillVelocity: self.m_MinKillVelocity.clone(),
            m_SendCollisionMessage: self.m_SendCollisionMessage.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GameObject {
    // extends EditorExtension
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Component: Option<Vec<(i32, PPtrData<Component>)>>,
    pub m_IsActive: Option<bool>,
    pub m_Layer: Option<u32>,
    pub m_Name: Option<String>,
    pub m_Tag: Option<u16>,
}

impl_object!(GameObject);

impl Clone for GameObject {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Component: self.m_Component.clone(),
            m_IsActive: self.m_IsActive.clone(),
            m_Layer: self.m_Layer.clone(),
            m_Name: self.m_Name.clone(),
            m_Tag: self.m_Tag.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NamedObject {
    // extends EditorExtension
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(NamedObject);

impl Clone for NamedObject {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnimatorState {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CycleOffset: Option<f32>,
    pub m_CycleOffsetParameter: Option<String>,
    pub m_CycleOffsetParameterActive: Option<bool>,
    pub m_IKOnFeet: Option<bool>,
    pub m_Mirror: Option<bool>,
    pub m_MirrorParameter: Option<String>,
    pub m_MirrorParameterActive: Option<bool>,
    pub m_Motion: Option<PPtrData<Motion>>,
    pub m_Name: Option<String>,
    pub m_Position: Option<Vector3>,
    pub m_Speed: Option<f32>,
    pub m_SpeedParameter: Option<String>,
    pub m_SpeedParameterActive: Option<bool>,
    pub m_StateMachineBehaviours: Option<Vec<PPtrData<MonoBehaviour>>>,
    pub m_Tag: Option<String>,
    pub m_TimeParameter: Option<String>,
    pub m_TimeParameterActive: Option<bool>,
    pub m_Transitions: Option<Vec<PPtrData<AnimatorStateTransition>>>,
    pub m_WriteDefaultValues: Option<bool>,
}

impl_object!(AnimatorState);

impl Clone for AnimatorState {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CycleOffset: self.m_CycleOffset.clone(),
            m_CycleOffsetParameter: self.m_CycleOffsetParameter.clone(),
            m_CycleOffsetParameterActive: self.m_CycleOffsetParameterActive.clone(),
            m_IKOnFeet: self.m_IKOnFeet.clone(),
            m_Mirror: self.m_Mirror.clone(),
            m_MirrorParameter: self.m_MirrorParameter.clone(),
            m_MirrorParameterActive: self.m_MirrorParameterActive.clone(),
            m_Motion: self.m_Motion.clone(),
            m_Name: self.m_Name.clone(),
            m_Position: self.m_Position.clone(),
            m_Speed: self.m_Speed.clone(),
            m_SpeedParameter: self.m_SpeedParameter.clone(),
            m_SpeedParameterActive: self.m_SpeedParameterActive.clone(),
            m_StateMachineBehaviours: self.m_StateMachineBehaviours.clone(),
            m_Tag: self.m_Tag.clone(),
            m_TimeParameter: self.m_TimeParameter.clone(),
            m_TimeParameterActive: self.m_TimeParameterActive.clone(),
            m_Transitions: self.m_Transitions.clone(),
            m_WriteDefaultValues: self.m_WriteDefaultValues.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnimatorStateMachine {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AnyStatePosition: Option<Vector3>,
    pub m_AnyStateTransitions: Option<Vec<PPtrData<AnimatorStateTransition>>>,
    pub m_ChildStateMachines: Option<Vec<ChildAnimatorStateMachine>>,
    pub m_ChildStates: Option<Vec<ChildAnimatorState>>,
    pub m_DefaultState: Option<PPtrData<AnimatorState>>,
    pub m_EntryPosition: Option<Vector3>,
    pub m_EntryTransitions: Option<Vec<PPtrData<AnimatorTransition>>>,
    pub m_ExitPosition: Option<Vector3>,
    pub m_Name: Option<String>,
    pub m_ParentStateMachinePosition: Option<Vector3>,
    pub m_StateMachineBehaviours: Option<Vec<PPtrData<MonoBehaviour>>>,
    pub m_StateMachineTransitions: Option<
        Vec<(
            PPtrData<AnimatorStateMachine>,
            Vec<PPtrData<AnimatorTransition>>,
        )>,
    >,
}

impl_object!(AnimatorStateMachine);

impl Clone for AnimatorStateMachine {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AnyStatePosition: self.m_AnyStatePosition.clone(),
            m_AnyStateTransitions: self.m_AnyStateTransitions.clone(),
            m_ChildStateMachines: self.m_ChildStateMachines.clone(),
            m_ChildStates: self.m_ChildStates.clone(),
            m_DefaultState: self.m_DefaultState.clone(),
            m_EntryPosition: self.m_EntryPosition.clone(),
            m_EntryTransitions: self.m_EntryTransitions.clone(),
            m_ExitPosition: self.m_ExitPosition.clone(),
            m_Name: self.m_Name.clone(),
            m_ParentStateMachinePosition: self.m_ParentStateMachinePosition.clone(),
            m_StateMachineBehaviours: self.m_StateMachineBehaviours.clone(),
            m_StateMachineTransitions: self.m_StateMachineTransitions.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnimatorTransitionBase {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Conditions: Option<Vec<AnimatorCondition>>,
    pub m_DstState: Option<PPtrData<AnimatorState>>,
    pub m_DstStateMachine: Option<PPtrData<AnimatorStateMachine>>,
    pub m_IsExit: Option<bool>,
    pub m_Mute: Option<bool>,
    pub m_Name: Option<String>,
    pub m_Solo: Option<bool>,
}

impl_object!(AnimatorTransitionBase);

impl Clone for AnimatorTransitionBase {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Conditions: self.m_Conditions.clone(),
            m_DstState: self.m_DstState.clone(),
            m_DstStateMachine: self.m_DstStateMachine.clone(),
            m_IsExit: self.m_IsExit.clone(),
            m_Mute: self.m_Mute.clone(),
            m_Name: self.m_Name.clone(),
            m_Solo: self.m_Solo.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnimatorStateTransition {
    // extends AnimatorTransitionBase
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CanTransitionToSelf: Option<bool>,
    pub m_Conditions: Option<Vec<AnimatorCondition>>,
    pub m_DstState: Option<PPtrData<AnimatorState>>,
    pub m_DstStateMachine: Option<PPtrData<AnimatorStateMachine>>,
    pub m_ExitTime: Option<f32>,
    pub m_HasExitTime: Option<bool>,
    pub m_HasFixedDuration: Option<bool>,
    pub m_InterruptionSource: Option<i32>,
    pub m_IsExit: Option<bool>,
    pub m_Mute: Option<bool>,
    pub m_Name: Option<String>,
    pub m_OrderedInterruption: Option<bool>,
    pub m_Solo: Option<bool>,
    pub m_TransitionDuration: Option<f32>,
    pub m_TransitionOffset: Option<f32>,
}

impl_object!(AnimatorStateTransition);

impl Clone for AnimatorStateTransition {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CanTransitionToSelf: self.m_CanTransitionToSelf.clone(),
            m_Conditions: self.m_Conditions.clone(),
            m_DstState: self.m_DstState.clone(),
            m_DstStateMachine: self.m_DstStateMachine.clone(),
            m_ExitTime: self.m_ExitTime.clone(),
            m_HasExitTime: self.m_HasExitTime.clone(),
            m_HasFixedDuration: self.m_HasFixedDuration.clone(),
            m_InterruptionSource: self.m_InterruptionSource.clone(),
            m_IsExit: self.m_IsExit.clone(),
            m_Mute: self.m_Mute.clone(),
            m_Name: self.m_Name.clone(),
            m_OrderedInterruption: self.m_OrderedInterruption.clone(),
            m_Solo: self.m_Solo.clone(),
            m_TransitionDuration: self.m_TransitionDuration.clone(),
            m_TransitionOffset: self.m_TransitionOffset.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnimatorTransition {
    // extends AnimatorTransitionBase
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Conditions: Option<Vec<AnimatorCondition>>,
    pub m_DstState: Option<PPtrData<AnimatorState>>,
    pub m_DstStateMachine: Option<PPtrData<AnimatorStateMachine>>,
    pub m_IsExit: Option<bool>,
    pub m_Mute: Option<bool>,
    pub m_Name: Option<String>,
    pub m_Solo: Option<bool>,
}

impl_object!(AnimatorTransition);

impl Clone for AnimatorTransition {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Conditions: self.m_Conditions.clone(),
            m_DstState: self.m_DstState.clone(),
            m_DstStateMachine: self.m_DstStateMachine.clone(),
            m_IsExit: self.m_IsExit.clone(),
            m_Mute: self.m_Mute.clone(),
            m_Name: self.m_Name.clone(),
            m_Solo: self.m_Solo.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetBundle {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_ClassCompatibility: Option<Vec<(i32, u32)>>,
    pub m_ClassVersionMap: Option<Vec<(i32, i32)>>,
    pub m_Container: Option<Vec<(String, AssetInfo)>>,
    pub m_Dependencies: Option<Vec<String>>,
    pub m_ExplicitDataLayout: Option<i32>,
    pub m_IsStreamedSceneAssetBundle: Option<bool>,
    pub m_MainAsset: Option<AssetInfo>,
    pub m_Name: Option<String>,
    pub m_PathFlags: Option<i32>,
    pub m_PreloadTable: Option<Vec<PPtrData<Object>>>,
    pub m_RuntimeCompatibility: Option<u32>,
    pub m_SceneHashes: Option<Vec<(String, String)>>,
    pub m_ScriptCompatibility: Option<Vec<AssetBundleScriptInfo>>,
}

impl_object!(AssetBundle);

impl Clone for AssetBundle {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_ClassCompatibility: self.m_ClassCompatibility.clone(),
            m_ClassVersionMap: self.m_ClassVersionMap.clone(),
            m_Container: self.m_Container.clone(),
            m_Dependencies: self.m_Dependencies.clone(),
            m_ExplicitDataLayout: self.m_ExplicitDataLayout.clone(),
            m_IsStreamedSceneAssetBundle: self.m_IsStreamedSceneAssetBundle.clone(),
            m_MainAsset: self.m_MainAsset.clone(),
            m_Name: self.m_Name.clone(),
            m_PathFlags: self.m_PathFlags.clone(),
            m_PreloadTable: self.m_PreloadTable.clone(),
            m_RuntimeCompatibility: self.m_RuntimeCompatibility.clone(),
            m_SceneHashes: self.m_SceneHashes.clone(),
            m_ScriptCompatibility: self.m_ScriptCompatibility.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetBundleManifest {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub AssetBundleInfos: Option<Vec<(i32, AssetBundleInfo)>>,
    pub AssetBundleNames: Option<Vec<(i32, String)>>,
    pub AssetBundlesWithVariant: Option<Vec<i32>>,
    pub m_Name: Option<String>,
}

impl_object!(AssetBundleManifest);

impl Clone for AssetBundleManifest {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            AssetBundleInfos: self.AssetBundleInfos.clone(),
            AssetBundleNames: self.AssetBundleNames.clone(),
            AssetBundlesWithVariant: self.AssetBundlesWithVariant.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetImportInProgressProxy {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
}

impl_object!(AssetImportInProgressProxy);

impl Clone for AssetImportInProgressProxy {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetImporter {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(AssetImporter);

impl Clone for AssetImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ASTCImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_Name: Option<String>,
    pub m_UserData: Option<String>,
}

impl_object!(ASTCImporter);

impl Clone for ASTCImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_Name: self.m_Name.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AndroidAssetPackImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(AndroidAssetPackImporter);

impl Clone for AndroidAssetPackImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssemblyDefinitionImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(AssemblyDefinitionImporter);

impl Clone for AssemblyDefinitionImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssemblyDefinitionReferenceImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(AssemblyDefinitionReferenceImporter);

impl Clone for AssemblyDefinitionReferenceImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub audio_preview_data: Option<Vec<u8>>,
    pub m_3D: Option<bool>,
    pub m_Ambisonic: Option<bool>,
    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_DefaultSettings: Option<SampleSettings>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_ForceToMono: Option<bool>,
    pub m_Format: Option<i32>,
    pub m_LoadInBackground: Option<bool>,
    pub m_Loopable: Option<bool>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_Normalize: Option<bool>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_Output: Option<AudioImporterOutput>,
    pub m_PlatformSettingOverrides: Option<Vec<(String, SampleSettings)>>,
    pub m_PreloadAudioData: Option<bool>,
    pub m_PreviewData: Option<PreviewData>,
    pub m_PreviewDataLength: Option<u32>,
    pub m_Quality: Option<f32>,
    pub m_Stream: Option<i32>,
    pub m_UseHardware: Option<bool>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(AudioImporter);

impl Clone for AudioImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            audio_preview_data: self.audio_preview_data.clone(),
            m_3D: self.m_3D.clone(),
            m_Ambisonic: self.m_Ambisonic.clone(),
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_DefaultSettings: self.m_DefaultSettings.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_ForceToMono: self.m_ForceToMono.clone(),
            m_Format: self.m_Format.clone(),
            m_LoadInBackground: self.m_LoadInBackground.clone(),
            m_Loopable: self.m_Loopable.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_Normalize: self.m_Normalize.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_Output: self.m_Output.clone(),
            m_PlatformSettingOverrides: self.m_PlatformSettingOverrides.clone(),
            m_PreloadAudioData: self.m_PreloadAudioData.clone(),
            m_PreviewData: self.m_PreviewData.clone(),
            m_PreviewDataLength: self.m_PreviewDataLength.clone(),
            m_Quality: self.m_Quality.clone(),
            m_Stream: self.m_Stream.clone(),
            m_UseHardware: self.m_UseHardware.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuildArchiveImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(BuildArchiveImporter);

impl Clone for BuildArchiveImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuildInstructionImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(BuildInstructionImporter);

impl Clone for BuildInstructionImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuildMetaDataImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(BuildMetaDataImporter);

impl Clone for BuildMetaDataImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct C4DImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(C4DImporter);

impl Clone for C4DImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ComputeShaderImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_CurrentAPIMask: Option<u32>,
    pub m_CurrentBuildTarget: Option<i32>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_PreprocessorOverride: Option<i32>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(ComputeShaderImporter);

impl Clone for ComputeShaderImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_CurrentAPIMask: self.m_CurrentAPIMask.clone(),
            m_CurrentBuildTarget: self.m_CurrentBuildTarget.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_PreprocessorOverride: self.m_PreprocessorOverride.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DDSImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_IsReadable: Option<bool>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_UserData: Option<String>,
}

impl_object!(DDSImporter);

impl Clone for DDSImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_IsReadable: self.m_IsReadable.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DefaultImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(DefaultImporter);

impl Clone for DefaultImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct IHVImageFormatImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_IgnoreMipmapLimit: Option<bool>,
    pub m_IsReadable: Option<bool>,
    pub m_MipmapLimitGroupName: Option<String>,
    pub m_Name: Option<String>,
    pub m_StreamingMipmaps: Option<bool>,
    pub m_StreamingMipmapsPriority: Option<i32>,
    pub m_TextureSettings: Option<GLTextureSettings>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
    pub m_sRGBTexture: Option<bool>,
}

impl_object!(IHVImageFormatImporter);

impl Clone for IHVImageFormatImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_IgnoreMipmapLimit: self.m_IgnoreMipmapLimit.clone(),
            m_IsReadable: self.m_IsReadable.clone(),
            m_MipmapLimitGroupName: self.m_MipmapLimitGroupName.clone(),
            m_Name: self.m_Name.clone(),
            m_StreamingMipmaps: self.m_StreamingMipmaps.clone(),
            m_StreamingMipmapsPriority: self.m_StreamingMipmapsPriority.clone(),
            m_TextureSettings: self.m_TextureSettings.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
            m_sRGBTexture: self.m_sRGBTexture.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct KTXImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_Name: Option<String>,
    pub m_UserData: Option<String>,
}

impl_object!(KTXImporter);

impl Clone for KTXImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_Name: self.m_Name.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LibraryAssetImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(LibraryAssetImporter);

impl Clone for LibraryAssetImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LocalizationImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(LocalizationImporter);

impl Clone for LocalizationImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ModelImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(ModelImporter);

impl Clone for ModelImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct FBXImporter {
    // extends ModelImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bakeAxisConversion: Option<bool>,
    pub blendShapeNormalImportMode: Option<i32>,
    pub generateSecondaryUV: Option<bool>,
    pub indexFormat: Option<i32>,
    pub keepQuads: Option<bool>,
    pub legacyComputeAllNormalsFromSmoothingGroupsWhenMeshHasBlendShapes: Option<bool>,
    pub m_AddColliders: Option<bool>,
    pub m_AddHumanoidExtraRootOnlyWhenUsingAvatar: Option<bool>,
    pub m_AdditionalBone: Option<bool>,
    pub m_AnimationCompression: Option<i32>,
    pub m_AnimationDoRetargetingWarnings: Option<bool>,
    pub m_AnimationImportErrors: Option<String>,
    pub m_AnimationImportWarnings: Option<String>,
    pub m_AnimationPositionError: Option<f32>,
    pub m_AnimationRetargetingWarnings: Option<String>,
    pub m_AnimationRotationError: Option<f32>,
    pub m_AnimationScaleError: Option<f32>,
    pub m_AnimationType: Option<i32>,
    pub m_AnimationWrapMode: Option<i32>,
    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_AutoGenerateAvatarMappingIfUnspecified: Option<bool>,
    pub m_AutoMapExternalMaterials: Option<bool>,
    pub m_AvatarSetup: Option<i32>,
    pub m_BakeSimulation: Option<bool>,
    pub m_ClipAnimations: Option<Vec<ClipAnimationInfo>>,
    pub m_ContainsAnimation: Option<bool>,
    pub m_CopyAvatar: Option<bool>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_ExtraExposedTransformPaths: Option<Vec<String>>,
    pub m_ExtraUserProperties: Option<Vec<String>>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_FileIdsGeneration: Option<i32>,
    pub m_FileScale: Option<f32>,
    pub m_FileScaleFactor: Option<f32>,
    pub m_FileScaleUnit: Option<String>,
    pub m_FirstImportVersion: Option<i32>,
    pub m_GenerateAnimations: Option<i32>,
    pub m_GenerateMaterials: Option<i32>,
    pub m_GlobalScale: Option<f32>,
    pub m_HasEmbeddedTextures: Option<bool>,
    pub m_HasExtraRoot: Option<bool>,
    pub m_HasPreviousCalculatedGlobalScale: Option<bool>,
    pub m_HumanDescription: Option<HumanDescription>,
    pub m_HumanoidOversampling: Option<i32>,
    pub m_ImportAnimatedCustomProperties: Option<bool>,
    pub m_ImportAnimation: Option<bool>,
    pub m_ImportBlendShapeDeformPercent: Option<bool>,
    pub m_ImportBlendShapes: Option<bool>,
    pub m_ImportCameras: Option<bool>,
    pub m_ImportConstraints: Option<bool>,
    pub m_ImportLights: Option<bool>,
    pub m_ImportMaterials: Option<bool>,
    pub m_ImportPhysicalCameras: Option<bool>,
    pub m_ImportVisibility: Option<bool>,
    pub m_ImportedRoots: Option<Vec<PPtrData<GameObject>>>,
    pub m_ImportedTakeInfos: Option<Vec<TakeInfo>>,
    pub m_InternalIDToNameTable: Option<Vec<((i32, i64), String)>>,
    pub m_IsReadable: Option<bool>,
    pub m_LODScreenPercentages: Option<Vec<f32>>,
    pub m_LastHumanDescriptionAvatarSource: Option<PPtrData<Avatar>>,
    pub m_LegacyGenerateAnimations: Option<i32>,
    pub m_MaterialImportMode: Option<i32>,
    pub m_MaterialLocation: Option<i32>,
    pub m_MaterialName: Option<i32>,
    pub m_MaterialSearch: Option<i32>,
    pub m_Materials: Option<Vec<SourceAssetIdentifier>>,
    pub m_MeshCompression: Option<i32>,
    pub m_MeshSettings_generateSecondaryUV: Option<bool>,
    pub m_MeshSettings_normalImportMode: Option<i32>,
    pub m_MeshSettings_secondaryUVAngleDistortion: Option<f32>,
    pub m_MeshSettings_secondaryUVAreaDistortion: Option<f32>,
    pub m_MeshSettings_secondaryUVHardAngle: Option<f32>,
    pub m_MeshSettings_secondaryUVPackMargin: Option<f32>,
    pub m_MeshSettings_swapUVChannels: Option<bool>,
    pub m_MeshSettings_tangentImportMode: Option<i32>,
    pub m_MotionNodeName: Option<String>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_NodeNameCollisionStrategy: Option<i32>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_OptimizeGameObjects: Option<bool>,
    pub m_PreserveHierarchy: Option<bool>,
    pub m_PreviousCalculatedGlobalScale: Option<f32>,
    pub m_ReferencedClips: Option<Vec<GUID>>,
    pub m_RemapMaterialsIfMaterialImportModeIsNone: Option<bool>,
    pub m_RemoveConstantScaleCurves: Option<bool>,
    pub m_ResampleCurves: Option<bool>,
    pub m_ResampleRotations: Option<bool>,
    pub m_RigImportErrors: Option<String>,
    pub m_RigImportWarnings: Option<String>,
    pub m_SortHierarchyByName: Option<bool>,
    pub m_SplitAnimations: Option<bool>,
    pub m_StrictVertexDataChecks: Option<bool>,
    pub m_SupportsEmbeddedMaterials: Option<bool>,
    pub m_UseFileScale: Option<bool>,
    pub m_UseFileUnits: Option<bool>,
    pub m_UseSRGBMaterialColor: Option<bool>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
    pub maxBonesPerVertex: Option<i32>,
    pub meshOptimizationFlags: Option<i32>,
    pub minBoneWeight: Option<f32>,
    pub normalCalculationMode: Option<i32>,
    pub normalImportMode: Option<i32>,
    pub normalSmoothAngle: Option<f32>,
    pub normalSmoothingSource: Option<i32>,
    pub optimizeBones: Option<bool>,
    pub optimizeMesh: Option<bool>,
    pub optimizeMeshForGPU: Option<bool>,
    pub secondaryUVAngleDistortion: Option<f32>,
    pub secondaryUVAreaDistortion: Option<f32>,
    pub secondaryUVHardAngle: Option<f32>,
    pub secondaryUVMarginMethod: Option<i32>,
    pub secondaryUVMinLightmapResolution: Option<f32>,
    pub secondaryUVMinObjectScale: Option<f32>,
    pub secondaryUVPackMargin: Option<f32>,
    pub skinWeightsMode: Option<i32>,
    pub splitTangentsAcrossUV: Option<bool>,
    pub swapUVChannels: Option<bool>,
    pub tangentImportMode: Option<i32>,
    pub weldVertices: Option<bool>,
}

impl_object!(FBXImporter);

impl Clone for FBXImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bakeAxisConversion: self.bakeAxisConversion.clone(),
            blendShapeNormalImportMode: self.blendShapeNormalImportMode.clone(),
            generateSecondaryUV: self.generateSecondaryUV.clone(),
            indexFormat: self.indexFormat.clone(),
            keepQuads: self.keepQuads.clone(),
            legacyComputeAllNormalsFromSmoothingGroupsWhenMeshHasBlendShapes: self
                .legacyComputeAllNormalsFromSmoothingGroupsWhenMeshHasBlendShapes
                .clone(),
            m_AddColliders: self.m_AddColliders.clone(),
            m_AddHumanoidExtraRootOnlyWhenUsingAvatar: self
                .m_AddHumanoidExtraRootOnlyWhenUsingAvatar
                .clone(),
            m_AdditionalBone: self.m_AdditionalBone.clone(),
            m_AnimationCompression: self.m_AnimationCompression.clone(),
            m_AnimationDoRetargetingWarnings: self.m_AnimationDoRetargetingWarnings.clone(),
            m_AnimationImportErrors: self.m_AnimationImportErrors.clone(),
            m_AnimationImportWarnings: self.m_AnimationImportWarnings.clone(),
            m_AnimationPositionError: self.m_AnimationPositionError.clone(),
            m_AnimationRetargetingWarnings: self.m_AnimationRetargetingWarnings.clone(),
            m_AnimationRotationError: self.m_AnimationRotationError.clone(),
            m_AnimationScaleError: self.m_AnimationScaleError.clone(),
            m_AnimationType: self.m_AnimationType.clone(),
            m_AnimationWrapMode: self.m_AnimationWrapMode.clone(),
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_AutoGenerateAvatarMappingIfUnspecified: self
                .m_AutoGenerateAvatarMappingIfUnspecified
                .clone(),
            m_AutoMapExternalMaterials: self.m_AutoMapExternalMaterials.clone(),
            m_AvatarSetup: self.m_AvatarSetup.clone(),
            m_BakeSimulation: self.m_BakeSimulation.clone(),
            m_ClipAnimations: self.m_ClipAnimations.clone(),
            m_ContainsAnimation: self.m_ContainsAnimation.clone(),
            m_CopyAvatar: self.m_CopyAvatar.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_ExtraExposedTransformPaths: self.m_ExtraExposedTransformPaths.clone(),
            m_ExtraUserProperties: self.m_ExtraUserProperties.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_FileIdsGeneration: self.m_FileIdsGeneration.clone(),
            m_FileScale: self.m_FileScale.clone(),
            m_FileScaleFactor: self.m_FileScaleFactor.clone(),
            m_FileScaleUnit: self.m_FileScaleUnit.clone(),
            m_FirstImportVersion: self.m_FirstImportVersion.clone(),
            m_GenerateAnimations: self.m_GenerateAnimations.clone(),
            m_GenerateMaterials: self.m_GenerateMaterials.clone(),
            m_GlobalScale: self.m_GlobalScale.clone(),
            m_HasEmbeddedTextures: self.m_HasEmbeddedTextures.clone(),
            m_HasExtraRoot: self.m_HasExtraRoot.clone(),
            m_HasPreviousCalculatedGlobalScale: self.m_HasPreviousCalculatedGlobalScale.clone(),
            m_HumanDescription: self.m_HumanDescription.clone(),
            m_HumanoidOversampling: self.m_HumanoidOversampling.clone(),
            m_ImportAnimatedCustomProperties: self.m_ImportAnimatedCustomProperties.clone(),
            m_ImportAnimation: self.m_ImportAnimation.clone(),
            m_ImportBlendShapeDeformPercent: self.m_ImportBlendShapeDeformPercent.clone(),
            m_ImportBlendShapes: self.m_ImportBlendShapes.clone(),
            m_ImportCameras: self.m_ImportCameras.clone(),
            m_ImportConstraints: self.m_ImportConstraints.clone(),
            m_ImportLights: self.m_ImportLights.clone(),
            m_ImportMaterials: self.m_ImportMaterials.clone(),
            m_ImportPhysicalCameras: self.m_ImportPhysicalCameras.clone(),
            m_ImportVisibility: self.m_ImportVisibility.clone(),
            m_ImportedRoots: self.m_ImportedRoots.clone(),
            m_ImportedTakeInfos: self.m_ImportedTakeInfos.clone(),
            m_InternalIDToNameTable: self.m_InternalIDToNameTable.clone(),
            m_IsReadable: self.m_IsReadable.clone(),
            m_LODScreenPercentages: self.m_LODScreenPercentages.clone(),
            m_LastHumanDescriptionAvatarSource: self.m_LastHumanDescriptionAvatarSource.clone(),
            m_LegacyGenerateAnimations: self.m_LegacyGenerateAnimations.clone(),
            m_MaterialImportMode: self.m_MaterialImportMode.clone(),
            m_MaterialLocation: self.m_MaterialLocation.clone(),
            m_MaterialName: self.m_MaterialName.clone(),
            m_MaterialSearch: self.m_MaterialSearch.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MeshCompression: self.m_MeshCompression.clone(),
            m_MeshSettings_generateSecondaryUV: self.m_MeshSettings_generateSecondaryUV.clone(),
            m_MeshSettings_normalImportMode: self.m_MeshSettings_normalImportMode.clone(),
            m_MeshSettings_secondaryUVAngleDistortion: self
                .m_MeshSettings_secondaryUVAngleDistortion
                .clone(),
            m_MeshSettings_secondaryUVAreaDistortion: self
                .m_MeshSettings_secondaryUVAreaDistortion
                .clone(),
            m_MeshSettings_secondaryUVHardAngle: self.m_MeshSettings_secondaryUVHardAngle.clone(),
            m_MeshSettings_secondaryUVPackMargin: self.m_MeshSettings_secondaryUVPackMargin.clone(),
            m_MeshSettings_swapUVChannels: self.m_MeshSettings_swapUVChannels.clone(),
            m_MeshSettings_tangentImportMode: self.m_MeshSettings_tangentImportMode.clone(),
            m_MotionNodeName: self.m_MotionNodeName.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_NodeNameCollisionStrategy: self.m_NodeNameCollisionStrategy.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_OptimizeGameObjects: self.m_OptimizeGameObjects.clone(),
            m_PreserveHierarchy: self.m_PreserveHierarchy.clone(),
            m_PreviousCalculatedGlobalScale: self.m_PreviousCalculatedGlobalScale.clone(),
            m_ReferencedClips: self.m_ReferencedClips.clone(),
            m_RemapMaterialsIfMaterialImportModeIsNone: self
                .m_RemapMaterialsIfMaterialImportModeIsNone
                .clone(),
            m_RemoveConstantScaleCurves: self.m_RemoveConstantScaleCurves.clone(),
            m_ResampleCurves: self.m_ResampleCurves.clone(),
            m_ResampleRotations: self.m_ResampleRotations.clone(),
            m_RigImportErrors: self.m_RigImportErrors.clone(),
            m_RigImportWarnings: self.m_RigImportWarnings.clone(),
            m_SortHierarchyByName: self.m_SortHierarchyByName.clone(),
            m_SplitAnimations: self.m_SplitAnimations.clone(),
            m_StrictVertexDataChecks: self.m_StrictVertexDataChecks.clone(),
            m_SupportsEmbeddedMaterials: self.m_SupportsEmbeddedMaterials.clone(),
            m_UseFileScale: self.m_UseFileScale.clone(),
            m_UseFileUnits: self.m_UseFileUnits.clone(),
            m_UseSRGBMaterialColor: self.m_UseSRGBMaterialColor.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
            maxBonesPerVertex: self.maxBonesPerVertex.clone(),
            meshOptimizationFlags: self.meshOptimizationFlags.clone(),
            minBoneWeight: self.minBoneWeight.clone(),
            normalCalculationMode: self.normalCalculationMode.clone(),
            normalImportMode: self.normalImportMode.clone(),
            normalSmoothAngle: self.normalSmoothAngle.clone(),
            normalSmoothingSource: self.normalSmoothingSource.clone(),
            optimizeBones: self.optimizeBones.clone(),
            optimizeMesh: self.optimizeMesh.clone(),
            optimizeMeshForGPU: self.optimizeMeshForGPU.clone(),
            secondaryUVAngleDistortion: self.secondaryUVAngleDistortion.clone(),
            secondaryUVAreaDistortion: self.secondaryUVAreaDistortion.clone(),
            secondaryUVHardAngle: self.secondaryUVHardAngle.clone(),
            secondaryUVMarginMethod: self.secondaryUVMarginMethod.clone(),
            secondaryUVMinLightmapResolution: self.secondaryUVMinLightmapResolution.clone(),
            secondaryUVMinObjectScale: self.secondaryUVMinObjectScale.clone(),
            secondaryUVPackMargin: self.secondaryUVPackMargin.clone(),
            skinWeightsMode: self.skinWeightsMode.clone(),
            splitTangentsAcrossUV: self.splitTangentsAcrossUV.clone(),
            swapUVChannels: self.swapUVChannels.clone(),
            tangentImportMode: self.tangentImportMode.clone(),
            weldVertices: self.weldVertices.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Mesh3DSImporter {
    // extends ModelImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bakeAxisConversion: Option<bool>,
    pub blendShapeNormalImportMode: Option<i32>,
    pub generateSecondaryUV: Option<bool>,
    pub indexFormat: Option<i32>,
    pub keepQuads: Option<bool>,
    pub legacyComputeAllNormalsFromSmoothingGroupsWhenMeshHasBlendShapes: Option<bool>,
    pub m_AddColliders: Option<bool>,
    pub m_AddHumanoidExtraRootOnlyWhenUsingAvatar: Option<bool>,
    pub m_AdditionalBone: Option<bool>,
    pub m_AnimationCompression: Option<i32>,
    pub m_AnimationDoRetargetingWarnings: Option<bool>,
    pub m_AnimationImportErrors: Option<String>,
    pub m_AnimationImportWarnings: Option<String>,
    pub m_AnimationPositionError: Option<f32>,
    pub m_AnimationRetargetingWarnings: Option<String>,
    pub m_AnimationRotationError: Option<f32>,
    pub m_AnimationScaleError: Option<f32>,
    pub m_AnimationType: Option<i32>,
    pub m_AnimationWrapMode: Option<i32>,
    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_AutoGenerateAvatarMappingIfUnspecified: Option<bool>,
    pub m_AutoMapExternalMaterials: Option<bool>,
    pub m_AvatarSetup: Option<i32>,
    pub m_BakeSimulation: Option<bool>,
    pub m_ClipAnimations: Option<Vec<ClipAnimationInfo>>,
    pub m_ContainsAnimation: Option<bool>,
    pub m_CopyAvatar: Option<bool>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_ExtraExposedTransformPaths: Option<Vec<String>>,
    pub m_ExtraUserProperties: Option<Vec<String>>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_FileIdsGeneration: Option<i32>,
    pub m_FileScale: Option<f32>,
    pub m_FileScaleFactor: Option<f32>,
    pub m_FileScaleUnit: Option<String>,
    pub m_FirstImportVersion: Option<i32>,
    pub m_GenerateAnimations: Option<i32>,
    pub m_GenerateMaterials: Option<i32>,
    pub m_GlobalScale: Option<f32>,
    pub m_HasEmbeddedTextures: Option<bool>,
    pub m_HasExtraRoot: Option<bool>,
    pub m_HasPreviousCalculatedGlobalScale: Option<bool>,
    pub m_HumanDescription: Option<HumanDescription>,
    pub m_HumanoidOversampling: Option<i32>,
    pub m_ImportAnimatedCustomProperties: Option<bool>,
    pub m_ImportAnimation: Option<bool>,
    pub m_ImportBlendShapeDeformPercent: Option<bool>,
    pub m_ImportBlendShapes: Option<bool>,
    pub m_ImportCameras: Option<bool>,
    pub m_ImportConstraints: Option<bool>,
    pub m_ImportLights: Option<bool>,
    pub m_ImportMaterials: Option<bool>,
    pub m_ImportPhysicalCameras: Option<bool>,
    pub m_ImportVisibility: Option<bool>,
    pub m_ImportedRoots: Option<Vec<PPtrData<GameObject>>>,
    pub m_ImportedTakeInfos: Option<Vec<TakeInfo>>,
    pub m_InternalIDToNameTable: Option<Vec<((i32, i64), String)>>,
    pub m_IsReadable: Option<bool>,
    pub m_LODScreenPercentages: Option<Vec<f32>>,
    pub m_LastHumanDescriptionAvatarSource: Option<PPtrData<Avatar>>,
    pub m_LegacyGenerateAnimations: Option<i32>,
    pub m_MaterialImportMode: Option<i32>,
    pub m_MaterialLocation: Option<i32>,
    pub m_MaterialName: Option<i32>,
    pub m_MaterialSearch: Option<i32>,
    pub m_Materials: Option<Vec<SourceAssetIdentifier>>,
    pub m_MeshCompression: Option<i32>,
    pub m_MeshSettings_generateSecondaryUV: Option<bool>,
    pub m_MeshSettings_normalImportMode: Option<i32>,
    pub m_MeshSettings_secondaryUVAngleDistortion: Option<f32>,
    pub m_MeshSettings_secondaryUVAreaDistortion: Option<f32>,
    pub m_MeshSettings_secondaryUVHardAngle: Option<f32>,
    pub m_MeshSettings_secondaryUVPackMargin: Option<f32>,
    pub m_MeshSettings_swapUVChannels: Option<bool>,
    pub m_MeshSettings_tangentImportMode: Option<i32>,
    pub m_MotionNodeName: Option<String>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_NodeNameCollisionStrategy: Option<i32>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_OptimizeGameObjects: Option<bool>,
    pub m_PreserveHierarchy: Option<bool>,
    pub m_PreviousCalculatedGlobalScale: Option<f32>,
    pub m_ReferencedClips: Option<Vec<GUID>>,
    pub m_RemapMaterialsIfMaterialImportModeIsNone: Option<bool>,
    pub m_RemoveConstantScaleCurves: Option<bool>,
    pub m_ResampleCurves: Option<bool>,
    pub m_ResampleRotations: Option<bool>,
    pub m_RigImportErrors: Option<String>,
    pub m_RigImportWarnings: Option<String>,
    pub m_SortHierarchyByName: Option<bool>,
    pub m_SplitAnimations: Option<bool>,
    pub m_StrictVertexDataChecks: Option<bool>,
    pub m_SupportsEmbeddedMaterials: Option<bool>,
    pub m_UseFileScale: Option<bool>,
    pub m_UseFileUnits: Option<bool>,
    pub m_UseSRGBMaterialColor: Option<bool>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
    pub maxBonesPerVertex: Option<i32>,
    pub meshOptimizationFlags: Option<i32>,
    pub minBoneWeight: Option<f32>,
    pub normalCalculationMode: Option<i32>,
    pub normalImportMode: Option<i32>,
    pub normalSmoothAngle: Option<f32>,
    pub normalSmoothingSource: Option<i32>,
    pub optimizeBones: Option<bool>,
    pub optimizeMesh: Option<bool>,
    pub optimizeMeshForGPU: Option<bool>,
    pub secondaryUVAngleDistortion: Option<f32>,
    pub secondaryUVAreaDistortion: Option<f32>,
    pub secondaryUVHardAngle: Option<f32>,
    pub secondaryUVMarginMethod: Option<i32>,
    pub secondaryUVMinLightmapResolution: Option<f32>,
    pub secondaryUVMinObjectScale: Option<f32>,
    pub secondaryUVPackMargin: Option<f32>,
    pub skinWeightsMode: Option<i32>,
    pub splitTangentsAcrossUV: Option<bool>,
    pub swapUVChannels: Option<bool>,
    pub tangentImportMode: Option<i32>,
    pub weldVertices: Option<bool>,
}

impl_object!(Mesh3DSImporter);

impl Clone for Mesh3DSImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bakeAxisConversion: self.bakeAxisConversion.clone(),
            blendShapeNormalImportMode: self.blendShapeNormalImportMode.clone(),
            generateSecondaryUV: self.generateSecondaryUV.clone(),
            indexFormat: self.indexFormat.clone(),
            keepQuads: self.keepQuads.clone(),
            legacyComputeAllNormalsFromSmoothingGroupsWhenMeshHasBlendShapes: self
                .legacyComputeAllNormalsFromSmoothingGroupsWhenMeshHasBlendShapes
                .clone(),
            m_AddColliders: self.m_AddColliders.clone(),
            m_AddHumanoidExtraRootOnlyWhenUsingAvatar: self
                .m_AddHumanoidExtraRootOnlyWhenUsingAvatar
                .clone(),
            m_AdditionalBone: self.m_AdditionalBone.clone(),
            m_AnimationCompression: self.m_AnimationCompression.clone(),
            m_AnimationDoRetargetingWarnings: self.m_AnimationDoRetargetingWarnings.clone(),
            m_AnimationImportErrors: self.m_AnimationImportErrors.clone(),
            m_AnimationImportWarnings: self.m_AnimationImportWarnings.clone(),
            m_AnimationPositionError: self.m_AnimationPositionError.clone(),
            m_AnimationRetargetingWarnings: self.m_AnimationRetargetingWarnings.clone(),
            m_AnimationRotationError: self.m_AnimationRotationError.clone(),
            m_AnimationScaleError: self.m_AnimationScaleError.clone(),
            m_AnimationType: self.m_AnimationType.clone(),
            m_AnimationWrapMode: self.m_AnimationWrapMode.clone(),
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_AutoGenerateAvatarMappingIfUnspecified: self
                .m_AutoGenerateAvatarMappingIfUnspecified
                .clone(),
            m_AutoMapExternalMaterials: self.m_AutoMapExternalMaterials.clone(),
            m_AvatarSetup: self.m_AvatarSetup.clone(),
            m_BakeSimulation: self.m_BakeSimulation.clone(),
            m_ClipAnimations: self.m_ClipAnimations.clone(),
            m_ContainsAnimation: self.m_ContainsAnimation.clone(),
            m_CopyAvatar: self.m_CopyAvatar.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_ExtraExposedTransformPaths: self.m_ExtraExposedTransformPaths.clone(),
            m_ExtraUserProperties: self.m_ExtraUserProperties.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_FileIdsGeneration: self.m_FileIdsGeneration.clone(),
            m_FileScale: self.m_FileScale.clone(),
            m_FileScaleFactor: self.m_FileScaleFactor.clone(),
            m_FileScaleUnit: self.m_FileScaleUnit.clone(),
            m_FirstImportVersion: self.m_FirstImportVersion.clone(),
            m_GenerateAnimations: self.m_GenerateAnimations.clone(),
            m_GenerateMaterials: self.m_GenerateMaterials.clone(),
            m_GlobalScale: self.m_GlobalScale.clone(),
            m_HasEmbeddedTextures: self.m_HasEmbeddedTextures.clone(),
            m_HasExtraRoot: self.m_HasExtraRoot.clone(),
            m_HasPreviousCalculatedGlobalScale: self.m_HasPreviousCalculatedGlobalScale.clone(),
            m_HumanDescription: self.m_HumanDescription.clone(),
            m_HumanoidOversampling: self.m_HumanoidOversampling.clone(),
            m_ImportAnimatedCustomProperties: self.m_ImportAnimatedCustomProperties.clone(),
            m_ImportAnimation: self.m_ImportAnimation.clone(),
            m_ImportBlendShapeDeformPercent: self.m_ImportBlendShapeDeformPercent.clone(),
            m_ImportBlendShapes: self.m_ImportBlendShapes.clone(),
            m_ImportCameras: self.m_ImportCameras.clone(),
            m_ImportConstraints: self.m_ImportConstraints.clone(),
            m_ImportLights: self.m_ImportLights.clone(),
            m_ImportMaterials: self.m_ImportMaterials.clone(),
            m_ImportPhysicalCameras: self.m_ImportPhysicalCameras.clone(),
            m_ImportVisibility: self.m_ImportVisibility.clone(),
            m_ImportedRoots: self.m_ImportedRoots.clone(),
            m_ImportedTakeInfos: self.m_ImportedTakeInfos.clone(),
            m_InternalIDToNameTable: self.m_InternalIDToNameTable.clone(),
            m_IsReadable: self.m_IsReadable.clone(),
            m_LODScreenPercentages: self.m_LODScreenPercentages.clone(),
            m_LastHumanDescriptionAvatarSource: self.m_LastHumanDescriptionAvatarSource.clone(),
            m_LegacyGenerateAnimations: self.m_LegacyGenerateAnimations.clone(),
            m_MaterialImportMode: self.m_MaterialImportMode.clone(),
            m_MaterialLocation: self.m_MaterialLocation.clone(),
            m_MaterialName: self.m_MaterialName.clone(),
            m_MaterialSearch: self.m_MaterialSearch.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MeshCompression: self.m_MeshCompression.clone(),
            m_MeshSettings_generateSecondaryUV: self.m_MeshSettings_generateSecondaryUV.clone(),
            m_MeshSettings_normalImportMode: self.m_MeshSettings_normalImportMode.clone(),
            m_MeshSettings_secondaryUVAngleDistortion: self
                .m_MeshSettings_secondaryUVAngleDistortion
                .clone(),
            m_MeshSettings_secondaryUVAreaDistortion: self
                .m_MeshSettings_secondaryUVAreaDistortion
                .clone(),
            m_MeshSettings_secondaryUVHardAngle: self.m_MeshSettings_secondaryUVHardAngle.clone(),
            m_MeshSettings_secondaryUVPackMargin: self.m_MeshSettings_secondaryUVPackMargin.clone(),
            m_MeshSettings_swapUVChannels: self.m_MeshSettings_swapUVChannels.clone(),
            m_MeshSettings_tangentImportMode: self.m_MeshSettings_tangentImportMode.clone(),
            m_MotionNodeName: self.m_MotionNodeName.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_NodeNameCollisionStrategy: self.m_NodeNameCollisionStrategy.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_OptimizeGameObjects: self.m_OptimizeGameObjects.clone(),
            m_PreserveHierarchy: self.m_PreserveHierarchy.clone(),
            m_PreviousCalculatedGlobalScale: self.m_PreviousCalculatedGlobalScale.clone(),
            m_ReferencedClips: self.m_ReferencedClips.clone(),
            m_RemapMaterialsIfMaterialImportModeIsNone: self
                .m_RemapMaterialsIfMaterialImportModeIsNone
                .clone(),
            m_RemoveConstantScaleCurves: self.m_RemoveConstantScaleCurves.clone(),
            m_ResampleCurves: self.m_ResampleCurves.clone(),
            m_ResampleRotations: self.m_ResampleRotations.clone(),
            m_RigImportErrors: self.m_RigImportErrors.clone(),
            m_RigImportWarnings: self.m_RigImportWarnings.clone(),
            m_SortHierarchyByName: self.m_SortHierarchyByName.clone(),
            m_SplitAnimations: self.m_SplitAnimations.clone(),
            m_StrictVertexDataChecks: self.m_StrictVertexDataChecks.clone(),
            m_SupportsEmbeddedMaterials: self.m_SupportsEmbeddedMaterials.clone(),
            m_UseFileScale: self.m_UseFileScale.clone(),
            m_UseFileUnits: self.m_UseFileUnits.clone(),
            m_UseSRGBMaterialColor: self.m_UseSRGBMaterialColor.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
            maxBonesPerVertex: self.maxBonesPerVertex.clone(),
            meshOptimizationFlags: self.meshOptimizationFlags.clone(),
            minBoneWeight: self.minBoneWeight.clone(),
            normalCalculationMode: self.normalCalculationMode.clone(),
            normalImportMode: self.normalImportMode.clone(),
            normalSmoothAngle: self.normalSmoothAngle.clone(),
            normalSmoothingSource: self.normalSmoothingSource.clone(),
            optimizeBones: self.optimizeBones.clone(),
            optimizeMesh: self.optimizeMesh.clone(),
            optimizeMeshForGPU: self.optimizeMeshForGPU.clone(),
            secondaryUVAngleDistortion: self.secondaryUVAngleDistortion.clone(),
            secondaryUVAreaDistortion: self.secondaryUVAreaDistortion.clone(),
            secondaryUVHardAngle: self.secondaryUVHardAngle.clone(),
            secondaryUVMarginMethod: self.secondaryUVMarginMethod.clone(),
            secondaryUVMinLightmapResolution: self.secondaryUVMinLightmapResolution.clone(),
            secondaryUVMinObjectScale: self.secondaryUVMinObjectScale.clone(),
            secondaryUVPackMargin: self.secondaryUVPackMargin.clone(),
            skinWeightsMode: self.skinWeightsMode.clone(),
            splitTangentsAcrossUV: self.splitTangentsAcrossUV.clone(),
            swapUVChannels: self.swapUVChannels.clone(),
            tangentImportMode: self.tangentImportMode.clone(),
            weldVertices: self.weldVertices.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SketchUpImporter {
    // extends ModelImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bakeAxisConversion: Option<bool>,
    pub blendShapeNormalImportMode: Option<i32>,
    pub generateSecondaryUV: Option<bool>,
    pub indexFormat: Option<i32>,
    pub keepQuads: Option<bool>,
    pub legacyComputeAllNormalsFromSmoothingGroupsWhenMeshHasBlendShapes: Option<bool>,
    pub m_AddColliders: Option<bool>,
    pub m_AddHumanoidExtraRootOnlyWhenUsingAvatar: Option<bool>,
    pub m_AdditionalBone: Option<bool>,
    pub m_AnimationCompression: Option<i32>,
    pub m_AnimationDoRetargetingWarnings: Option<bool>,
    pub m_AnimationImportErrors: Option<String>,
    pub m_AnimationImportWarnings: Option<String>,
    pub m_AnimationPositionError: Option<f32>,
    pub m_AnimationRetargetingWarnings: Option<String>,
    pub m_AnimationRotationError: Option<f32>,
    pub m_AnimationScaleError: Option<f32>,
    pub m_AnimationType: Option<i32>,
    pub m_AnimationWrapMode: Option<i32>,
    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_AssetHash: Option<Hash128>,
    pub m_AutoGenerateAvatarMappingIfUnspecified: Option<bool>,
    pub m_AutoMapExternalMaterials: Option<bool>,
    pub m_AvatarSetup: Option<i32>,
    pub m_BakeSimulation: Option<bool>,
    pub m_ClipAnimations: Option<Vec<ClipAnimationInfo>>,
    pub m_ContainsAnimation: Option<bool>,
    pub m_CopyAvatar: Option<bool>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_ExtraExposedTransformPaths: Option<Vec<String>>,
    pub m_ExtraUserProperties: Option<Vec<String>>,
    pub m_FileIDToRecycleName: Option<Vec<(i64, String)>>,
    pub m_FileIdsGeneration: Option<i32>,
    pub m_FileScale: Option<f32>,
    pub m_FileScaleFactor: Option<f32>,
    pub m_FileScaleUnit: Option<String>,
    pub m_FileUnit: Option<i32>,
    pub m_GenerateBackFace: Option<bool>,
    pub m_GlobalScale: Option<f32>,
    pub m_HasEmbeddedTextures: Option<bool>,
    pub m_HasExtraRoot: Option<bool>,
    pub m_HasPreviousCalculatedGlobalScale: Option<bool>,
    pub m_HumanDescription: Option<HumanDescription>,
    pub m_HumanoidOversampling: Option<i32>,
    pub m_ImportAnimatedCustomProperties: Option<bool>,
    pub m_ImportAnimation: Option<bool>,
    pub m_ImportBlendShapeDeformPercent: Option<bool>,
    pub m_ImportBlendShapes: Option<bool>,
    pub m_ImportCameras: Option<bool>,
    pub m_ImportConstraints: Option<bool>,
    pub m_ImportLights: Option<bool>,
    pub m_ImportMaterials: Option<bool>,
    pub m_ImportPhysicalCameras: Option<bool>,
    pub m_ImportVisibility: Option<bool>,
    pub m_ImportedRoots: Option<Vec<PPtrData<GameObject>>>,
    pub m_ImportedTakeInfos: Option<Vec<TakeInfo>>,
    pub m_InternalIDToNameTable: Option<Vec<((i32, i64), String)>>,
    pub m_IsReadable: Option<bool>,
    pub m_LODScreenPercentages: Option<Vec<f32>>,
    pub m_LastHumanDescriptionAvatarSource: Option<PPtrData<Avatar>>,
    pub m_Latitude: Option<f64>,
    pub m_LegacyGenerateAnimations: Option<i32>,
    pub m_Longitude: Option<f64>,
    pub m_MaterialImportMode: Option<i32>,
    pub m_MaterialLocation: Option<i32>,
    pub m_MaterialName: Option<i32>,
    pub m_MaterialSearch: Option<i32>,
    pub m_Materials: Option<Vec<SourceAssetIdentifier>>,
    pub m_MergeCoplanarFaces: Option<bool>,
    pub m_MeshCompression: Option<i32>,
    pub m_MotionNodeName: Option<String>,
    pub m_Name: Option<String>,
    pub m_NodeNameCollisionStrategy: Option<i32>,
    pub m_NorthCorrection: Option<f64>,
    pub m_OptimizeGameObjects: Option<bool>,
    pub m_PreserveHierarchy: Option<bool>,
    pub m_PreviousCalculatedGlobalScale: Option<f32>,
    pub m_ReferencedClips: Option<Vec<GUID>>,
    pub m_RemapMaterialsIfMaterialImportModeIsNone: Option<bool>,
    pub m_RemoveConstantScaleCurves: Option<bool>,
    pub m_ResampleCurves: Option<bool>,
    pub m_ResampleRotations: Option<bool>,
    pub m_RigImportErrors: Option<String>,
    pub m_RigImportWarnings: Option<String>,
    pub m_SelectedNodes: Option<Vec<i32>>,
    pub m_SketchUpImportData: Option<SketchUpImportData>,
    pub m_SortHierarchyByName: Option<bool>,
    pub m_StrictVertexDataChecks: Option<bool>,
    pub m_SupportsEmbeddedMaterials: Option<bool>,
    pub m_UseFileScale: Option<bool>,
    pub m_UseFileUnits: Option<bool>,
    pub m_UseSRGBMaterialColor: Option<bool>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
    pub maxBonesPerVertex: Option<i32>,
    pub meshOptimizationFlags: Option<i32>,
    pub minBoneWeight: Option<f32>,
    pub normalCalculationMode: Option<i32>,
    pub normalImportMode: Option<i32>,
    pub normalSmoothAngle: Option<f32>,
    pub normalSmoothingSource: Option<i32>,
    pub optimizeBones: Option<bool>,
    pub optimizeMeshForGPU: Option<bool>,
    pub secondaryUVAngleDistortion: Option<f32>,
    pub secondaryUVAreaDistortion: Option<f32>,
    pub secondaryUVHardAngle: Option<f32>,
    pub secondaryUVMarginMethod: Option<i32>,
    pub secondaryUVMinLightmapResolution: Option<f32>,
    pub secondaryUVMinObjectScale: Option<f32>,
    pub secondaryUVPackMargin: Option<f32>,
    pub skinWeightsMode: Option<i32>,
    pub splitTangentsAcrossUV: Option<bool>,
    pub swapUVChannels: Option<bool>,
    pub tangentImportMode: Option<i32>,
    pub weldVertices: Option<bool>,
}

impl_object!(SketchUpImporter);

impl Clone for SketchUpImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bakeAxisConversion: self.bakeAxisConversion.clone(),
            blendShapeNormalImportMode: self.blendShapeNormalImportMode.clone(),
            generateSecondaryUV: self.generateSecondaryUV.clone(),
            indexFormat: self.indexFormat.clone(),
            keepQuads: self.keepQuads.clone(),
            legacyComputeAllNormalsFromSmoothingGroupsWhenMeshHasBlendShapes: self
                .legacyComputeAllNormalsFromSmoothingGroupsWhenMeshHasBlendShapes
                .clone(),
            m_AddColliders: self.m_AddColliders.clone(),
            m_AddHumanoidExtraRootOnlyWhenUsingAvatar: self
                .m_AddHumanoidExtraRootOnlyWhenUsingAvatar
                .clone(),
            m_AdditionalBone: self.m_AdditionalBone.clone(),
            m_AnimationCompression: self.m_AnimationCompression.clone(),
            m_AnimationDoRetargetingWarnings: self.m_AnimationDoRetargetingWarnings.clone(),
            m_AnimationImportErrors: self.m_AnimationImportErrors.clone(),
            m_AnimationImportWarnings: self.m_AnimationImportWarnings.clone(),
            m_AnimationPositionError: self.m_AnimationPositionError.clone(),
            m_AnimationRetargetingWarnings: self.m_AnimationRetargetingWarnings.clone(),
            m_AnimationRotationError: self.m_AnimationRotationError.clone(),
            m_AnimationScaleError: self.m_AnimationScaleError.clone(),
            m_AnimationType: self.m_AnimationType.clone(),
            m_AnimationWrapMode: self.m_AnimationWrapMode.clone(),
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_AssetHash: self.m_AssetHash.clone(),
            m_AutoGenerateAvatarMappingIfUnspecified: self
                .m_AutoGenerateAvatarMappingIfUnspecified
                .clone(),
            m_AutoMapExternalMaterials: self.m_AutoMapExternalMaterials.clone(),
            m_AvatarSetup: self.m_AvatarSetup.clone(),
            m_BakeSimulation: self.m_BakeSimulation.clone(),
            m_ClipAnimations: self.m_ClipAnimations.clone(),
            m_ContainsAnimation: self.m_ContainsAnimation.clone(),
            m_CopyAvatar: self.m_CopyAvatar.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_ExtraExposedTransformPaths: self.m_ExtraExposedTransformPaths.clone(),
            m_ExtraUserProperties: self.m_ExtraUserProperties.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_FileIdsGeneration: self.m_FileIdsGeneration.clone(),
            m_FileScale: self.m_FileScale.clone(),
            m_FileScaleFactor: self.m_FileScaleFactor.clone(),
            m_FileScaleUnit: self.m_FileScaleUnit.clone(),
            m_FileUnit: self.m_FileUnit.clone(),
            m_GenerateBackFace: self.m_GenerateBackFace.clone(),
            m_GlobalScale: self.m_GlobalScale.clone(),
            m_HasEmbeddedTextures: self.m_HasEmbeddedTextures.clone(),
            m_HasExtraRoot: self.m_HasExtraRoot.clone(),
            m_HasPreviousCalculatedGlobalScale: self.m_HasPreviousCalculatedGlobalScale.clone(),
            m_HumanDescription: self.m_HumanDescription.clone(),
            m_HumanoidOversampling: self.m_HumanoidOversampling.clone(),
            m_ImportAnimatedCustomProperties: self.m_ImportAnimatedCustomProperties.clone(),
            m_ImportAnimation: self.m_ImportAnimation.clone(),
            m_ImportBlendShapeDeformPercent: self.m_ImportBlendShapeDeformPercent.clone(),
            m_ImportBlendShapes: self.m_ImportBlendShapes.clone(),
            m_ImportCameras: self.m_ImportCameras.clone(),
            m_ImportConstraints: self.m_ImportConstraints.clone(),
            m_ImportLights: self.m_ImportLights.clone(),
            m_ImportMaterials: self.m_ImportMaterials.clone(),
            m_ImportPhysicalCameras: self.m_ImportPhysicalCameras.clone(),
            m_ImportVisibility: self.m_ImportVisibility.clone(),
            m_ImportedRoots: self.m_ImportedRoots.clone(),
            m_ImportedTakeInfos: self.m_ImportedTakeInfos.clone(),
            m_InternalIDToNameTable: self.m_InternalIDToNameTable.clone(),
            m_IsReadable: self.m_IsReadable.clone(),
            m_LODScreenPercentages: self.m_LODScreenPercentages.clone(),
            m_LastHumanDescriptionAvatarSource: self.m_LastHumanDescriptionAvatarSource.clone(),
            m_Latitude: self.m_Latitude.clone(),
            m_LegacyGenerateAnimations: self.m_LegacyGenerateAnimations.clone(),
            m_Longitude: self.m_Longitude.clone(),
            m_MaterialImportMode: self.m_MaterialImportMode.clone(),
            m_MaterialLocation: self.m_MaterialLocation.clone(),
            m_MaterialName: self.m_MaterialName.clone(),
            m_MaterialSearch: self.m_MaterialSearch.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MergeCoplanarFaces: self.m_MergeCoplanarFaces.clone(),
            m_MeshCompression: self.m_MeshCompression.clone(),
            m_MotionNodeName: self.m_MotionNodeName.clone(),
            m_Name: self.m_Name.clone(),
            m_NodeNameCollisionStrategy: self.m_NodeNameCollisionStrategy.clone(),
            m_NorthCorrection: self.m_NorthCorrection.clone(),
            m_OptimizeGameObjects: self.m_OptimizeGameObjects.clone(),
            m_PreserveHierarchy: self.m_PreserveHierarchy.clone(),
            m_PreviousCalculatedGlobalScale: self.m_PreviousCalculatedGlobalScale.clone(),
            m_ReferencedClips: self.m_ReferencedClips.clone(),
            m_RemapMaterialsIfMaterialImportModeIsNone: self
                .m_RemapMaterialsIfMaterialImportModeIsNone
                .clone(),
            m_RemoveConstantScaleCurves: self.m_RemoveConstantScaleCurves.clone(),
            m_ResampleCurves: self.m_ResampleCurves.clone(),
            m_ResampleRotations: self.m_ResampleRotations.clone(),
            m_RigImportErrors: self.m_RigImportErrors.clone(),
            m_RigImportWarnings: self.m_RigImportWarnings.clone(),
            m_SelectedNodes: self.m_SelectedNodes.clone(),
            m_SketchUpImportData: self.m_SketchUpImportData.clone(),
            m_SortHierarchyByName: self.m_SortHierarchyByName.clone(),
            m_StrictVertexDataChecks: self.m_StrictVertexDataChecks.clone(),
            m_SupportsEmbeddedMaterials: self.m_SupportsEmbeddedMaterials.clone(),
            m_UseFileScale: self.m_UseFileScale.clone(),
            m_UseFileUnits: self.m_UseFileUnits.clone(),
            m_UseSRGBMaterialColor: self.m_UseSRGBMaterialColor.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
            maxBonesPerVertex: self.maxBonesPerVertex.clone(),
            meshOptimizationFlags: self.meshOptimizationFlags.clone(),
            minBoneWeight: self.minBoneWeight.clone(),
            normalCalculationMode: self.normalCalculationMode.clone(),
            normalImportMode: self.normalImportMode.clone(),
            normalSmoothAngle: self.normalSmoothAngle.clone(),
            normalSmoothingSource: self.normalSmoothingSource.clone(),
            optimizeBones: self.optimizeBones.clone(),
            optimizeMeshForGPU: self.optimizeMeshForGPU.clone(),
            secondaryUVAngleDistortion: self.secondaryUVAngleDistortion.clone(),
            secondaryUVAreaDistortion: self.secondaryUVAreaDistortion.clone(),
            secondaryUVHardAngle: self.secondaryUVHardAngle.clone(),
            secondaryUVMarginMethod: self.secondaryUVMarginMethod.clone(),
            secondaryUVMinLightmapResolution: self.secondaryUVMinLightmapResolution.clone(),
            secondaryUVMinObjectScale: self.secondaryUVMinObjectScale.clone(),
            secondaryUVPackMargin: self.secondaryUVPackMargin.clone(),
            skinWeightsMode: self.skinWeightsMode.clone(),
            splitTangentsAcrossUV: self.splitTangentsAcrossUV.clone(),
            swapUVChannels: self.swapUVChannels.clone(),
            tangentImportMode: self.tangentImportMode.clone(),
            weldVertices: self.weldVertices.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MonoImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub executionOrder: Option<i16>,
    pub icon: Option<PPtrData<Texture2D>>,
    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_DefaultReferences: Option<Vec<(String, PPtrData<Object>)>>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(MonoImporter);

impl Clone for MonoImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            executionOrder: self.executionOrder.clone(),
            icon: self.icon.clone(),
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_DefaultReferences: self.m_DefaultReferences.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MovieImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_LinearTexture: Option<bool>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_Quality: Option<f32>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(MovieImporter);

impl Clone for MovieImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_LinearTexture: self.m_LinearTexture.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_Quality: self.m_Quality.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MultiArtifactTestImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(MultiArtifactTestImporter);

impl Clone for MultiArtifactTestImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NativeFormatImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_MainObjectFileID: Option<i64>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(NativeFormatImporter);

impl Clone for NativeFormatImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_MainObjectFileID: self.m_MainObjectFileID.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PVRImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_UserData: Option<String>,
}

impl_object!(PVRImporter);

impl Clone for PVRImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PackageManifestImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(PackageManifestImporter);

impl Clone for PackageManifestImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PluginImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_DefineConstraints: Option<Vec<String>>,
    pub m_ExecutionOrder: Option<Vec<(String, i32)>>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_IconMap: Option<Vec<(String, PPtrData<Texture2D>)>>,
    pub m_IsExplicitlyReferenced: Option<bool>,
    pub m_IsOverridable: Option<bool>,
    pub m_IsPreloaded: Option<bool>,
    pub m_Name: Option<String>,
    pub m_Output: Option<PluginImportOutput>,
    pub m_PlatformData: Option<Vec<((String, String), PlatformSettingsData)>>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
    pub m_ValidateReferences: Option<bool>,
}

impl_object!(PluginImporter);

impl Clone for PluginImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_DefineConstraints: self.m_DefineConstraints.clone(),
            m_ExecutionOrder: self.m_ExecutionOrder.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_IconMap: self.m_IconMap.clone(),
            m_IsExplicitlyReferenced: self.m_IsExplicitlyReferenced.clone(),
            m_IsOverridable: self.m_IsOverridable.clone(),
            m_IsPreloaded: self.m_IsPreloaded.clone(),
            m_Name: self.m_Name.clone(),
            m_Output: self.m_Output.clone(),
            m_PlatformData: self.m_PlatformData.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
            m_ValidateReferences: self.m_ValidateReferences.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PrefabImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AddedObjectFileIDs: Option<Vec<i64>>,
    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_IsPrefabVariant: Option<bool>,
    pub m_Name: Option<String>,
    pub m_UnableToImportOnPreviousDomainReload: Option<bool>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
    pub m_VariantParentGUID: Option<GUID>,
}

impl_object!(PrefabImporter);

impl Clone for PrefabImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AddedObjectFileIDs: self.m_AddedObjectFileIDs.clone(),
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_IsPrefabVariant: self.m_IsPrefabVariant.clone(),
            m_Name: self.m_Name.clone(),
            m_UnableToImportOnPreviousDomainReload: self
                .m_UnableToImportOnPreviousDomainReload
                .clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
            m_VariantParentGUID: self.m_VariantParentGUID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PreviewImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(PreviewImporter);

impl Clone for PreviewImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RayTracingShaderImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_CurrentAPIMask: Option<u32>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(RayTracingShaderImporter);

impl Clone for RayTracingShaderImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_CurrentAPIMask: self.m_CurrentAPIMask.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ReferencesArtifactGenerator {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(ReferencesArtifactGenerator);

impl Clone for ReferencesArtifactGenerator {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RoslynAdditionalFileImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(RoslynAdditionalFileImporter);

impl Clone for RoslynAdditionalFileImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RoslynAnalyzerConfigImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(RoslynAnalyzerConfigImporter);

impl Clone for RoslynAnalyzerConfigImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RuleSetFileImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(RuleSetFileImporter);

impl Clone for RuleSetFileImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ScriptedImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_FileIDToRecycleName: Option<Vec<(i64, String)>>,
    pub m_InternalIDToNameTable: Option<Vec<((i32, i64), String)>>,
    pub m_Name: Option<String>,
    pub m_Script: Option<PPtrData<MonoScript>>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(ScriptedImporter);

impl Clone for ScriptedImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_InternalIDToNameTable: self.m_InternalIDToNameTable.clone(),
            m_Name: self.m_Name.clone(),
            m_Script: self.m_Script.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ShaderImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_DefaultTextures: Option<Vec<(String, PPtrData<Texture>)>>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_NonModifiableTextures: Option<Vec<(String, PPtrData<Texture>)>>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_PreprocessorOverride: Option<i32>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(ShaderImporter);

impl Clone for ShaderImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_DefaultTextures: self.m_DefaultTextures.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_NonModifiableTextures: self.m_NonModifiableTextures.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_PreprocessorOverride: self.m_PreprocessorOverride.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ShaderIncludeImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(ShaderIncludeImporter);

impl Clone for ShaderIncludeImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpeedTreeImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AlphaTestRef: Option<f32>,
    pub m_AnimateCrossFading: Option<bool>,
    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_BestWindQuality: Option<i32>,
    pub m_BillboardTransitionCrossFadeWidth: Option<f32>,
    pub m_EnableBumpMapping: Option<bool>,
    pub m_EnableHueVariation: Option<bool>,
    pub m_EnableLightProbes: Option<bool>,
    pub m_EnableShadowCasting: Option<bool>,
    pub m_EnableShadowReceiving: Option<bool>,
    pub m_EnableSmoothLODTransition: Option<bool>,
    pub m_EnableSubsurfaceScattering: Option<bool>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_FadeOutWidth: Option<f32>,
    pub m_FileIDType: Option<i32>,
    pub m_GenerateColliders: Option<bool>,
    pub m_GenerateRigidbody: Option<bool>,
    pub m_HasBillboard: Option<bool>,
    pub m_HueVariation: Option<Color>,
    pub m_LODSettings: Option<Vec<PerLODSettings>>,
    pub m_MainColor: Option<Color>,
    pub m_MaterialLocation: Option<i32>,
    pub m_MaterialVersion: Option<i32>,
    pub m_Materials: Option<Vec<SourceAssetIdentifier>>,
    pub m_MotionVectorModeEnumValue: Option<i32>,
    pub m_Name: Option<String>,
    pub m_ReflectionProbeEnumValue: Option<i32>,
    pub m_ScaleFactor: Option<f32>,
    pub m_SelectedWindQuality: Option<i32>,
    pub m_Shininess: Option<f32>,
    pub m_SpecColor: Option<Color>,
    pub m_SupportsEmbeddedMaterials: Option<bool>,
    pub m_UnitConversionEnumValue: Option<i32>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(SpeedTreeImporter);

impl Clone for SpeedTreeImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AlphaTestRef: self.m_AlphaTestRef.clone(),
            m_AnimateCrossFading: self.m_AnimateCrossFading.clone(),
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_BestWindQuality: self.m_BestWindQuality.clone(),
            m_BillboardTransitionCrossFadeWidth: self.m_BillboardTransitionCrossFadeWidth.clone(),
            m_EnableBumpMapping: self.m_EnableBumpMapping.clone(),
            m_EnableHueVariation: self.m_EnableHueVariation.clone(),
            m_EnableLightProbes: self.m_EnableLightProbes.clone(),
            m_EnableShadowCasting: self.m_EnableShadowCasting.clone(),
            m_EnableShadowReceiving: self.m_EnableShadowReceiving.clone(),
            m_EnableSmoothLODTransition: self.m_EnableSmoothLODTransition.clone(),
            m_EnableSubsurfaceScattering: self.m_EnableSubsurfaceScattering.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_FadeOutWidth: self.m_FadeOutWidth.clone(),
            m_FileIDType: self.m_FileIDType.clone(),
            m_GenerateColliders: self.m_GenerateColliders.clone(),
            m_GenerateRigidbody: self.m_GenerateRigidbody.clone(),
            m_HasBillboard: self.m_HasBillboard.clone(),
            m_HueVariation: self.m_HueVariation.clone(),
            m_LODSettings: self.m_LODSettings.clone(),
            m_MainColor: self.m_MainColor.clone(),
            m_MaterialLocation: self.m_MaterialLocation.clone(),
            m_MaterialVersion: self.m_MaterialVersion.clone(),
            m_Materials: self.m_Materials.clone(),
            m_MotionVectorModeEnumValue: self.m_MotionVectorModeEnumValue.clone(),
            m_Name: self.m_Name.clone(),
            m_ReflectionProbeEnumValue: self.m_ReflectionProbeEnumValue.clone(),
            m_ScaleFactor: self.m_ScaleFactor.clone(),
            m_SelectedWindQuality: self.m_SelectedWindQuality.clone(),
            m_Shininess: self.m_Shininess.clone(),
            m_SpecColor: self.m_SpecColor.clone(),
            m_SupportsEmbeddedMaterials: self.m_SupportsEmbeddedMaterials.clone(),
            m_UnitConversionEnumValue: self.m_UnitConversionEnumValue.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteAtlasImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_BindAsDefault: Option<bool>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_PackingSettings: Option<PackingSettings>,
    pub m_PlatformSettings: Option<Vec<TextureImporterPlatformSettings>>,
    pub m_SecondaryTextureSettings: Option<Vec<(String, SecondaryTextureSettings)>>,
    pub m_TextureSettings: Option<TextureSettings>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
    pub m_VariantMultiplier: Option<f32>,
}

impl_object!(SpriteAtlasImporter);

impl Clone for SpriteAtlasImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_BindAsDefault: self.m_BindAsDefault.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_PackingSettings: self.m_PackingSettings.clone(),
            m_PlatformSettings: self.m_PlatformSettings.clone(),
            m_SecondaryTextureSettings: self.m_SecondaryTextureSettings.clone(),
            m_TextureSettings: self.m_TextureSettings.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
            m_VariantMultiplier: self.m_VariantMultiplier.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct StyleSheetImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_Name: Option<String>,
    pub m_UserData: Option<String>,
}

impl_object!(StyleSheetImporter);

impl Clone for StyleSheetImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_Name: self.m_Name.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SubstanceImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_DeletedPrototypes: Option<Vec<String>>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_IsFirstImport: Option<i32>,
    pub m_MaterialImportOutputs: Option<Vec<MaterialImportOutput>>,
    pub m_MaterialInstances: Option<Vec<MaterialInstanceSettings>>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(SubstanceImporter);

impl Clone for SubstanceImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_DeletedPrototypes: self.m_DeletedPrototypes.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_IsFirstImport: self.m_IsFirstImport.clone(),
            m_MaterialImportOutputs: self.m_MaterialImportOutputs.clone(),
            m_MaterialInstances: self.m_MaterialInstances.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TextScriptImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(TextScriptImporter);

impl Clone for TextScriptImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TextureImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub correctGamma: Option<i32>,
    pub m_Alignment: Option<i32>,
    pub m_AllowsAlphaSplitting: Option<i32>,
    pub m_AlphaIsTransparency: Option<i32>,
    pub m_AlphaTestReferenceValue: Option<f32>,
    pub m_AlphaUsage: Option<i32>,
    pub m_ApplyGammaDecoding: Option<i32>,
    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_BorderMipMap: Option<i32>,
    pub m_BuildTargetSettings: Option<Vec<BuildTargetSettings>>,
    pub m_CompressionQuality: Option<i32>,
    pub m_CompressionQualitySet: Option<i32>,
    pub m_ConvertToNormalMap: Option<i32>,
    pub m_CookieLightType: Option<i32>,
    pub m_CorrectGamma: Option<i32>,
    pub m_CubemapConvolution: Option<i32>,
    pub m_CubemapConvolutionExponent: Option<f32>,
    pub m_CubemapConvolutionSteps: Option<i32>,
    pub m_EnableMipMap: Option<i32>,
    pub m_ExternalNormalMap: Option<i32>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_FadeOut: Option<i32>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_FlipGreenChannel: Option<i32>,
    pub m_FlipbookColumns: Option<i32>,
    pub m_FlipbookRows: Option<i32>,
    pub m_GenerateCubemap: Option<i32>,
    pub m_GrayScaleToAlpha: Option<i32>,
    pub m_HeightScale: Option<f32>,
    pub m_IgnoreMasterTextureLimit: Option<i32>,
    pub m_IgnoreMipmapLimit: Option<i32>,
    pub m_IgnorePngGamma: Option<bool>,
    pub m_InternalIDToNameTable: Option<Vec<((i32, i64), String)>>,
    pub m_IsReadable: Option<i32>,
    pub m_Lightmap: Option<i32>,
    pub m_LinearTexture: Option<i32>,
    pub m_MaxTextureSize: Option<i32>,
    pub m_MaxTextureSizeSet: Option<i32>,
    pub m_MipMapFadeDistanceEnd: Option<i32>,
    pub m_MipMapFadeDistanceStart: Option<i32>,
    pub m_MipMapMode: Option<i32>,
    pub m_MipMapsPreserveCoverage: Option<i32>,
    pub m_MipmapLimitGroupName: Option<String>,
    pub m_NPOTScale: Option<i32>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_NormalMapFilter: Option<i32>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_Output: Option<TextureImportOutput>,
    pub m_PSDRemoveMatte: Option<bool>,
    pub m_PSDShowRemoveMatteOption: Option<bool>,
    pub m_PlatformSettings: Option<Vec<PlatformSettings>>,
    pub m_PushPullDilation: Option<i32>,
    pub m_RGBM: Option<i32>,
    pub m_RecommendedTextureFormat: Option<i32>,
    pub m_SeamlessCubemap: Option<i32>,
    pub m_SingleChannelComponent: Option<i32>,
    pub m_SourceTextureInformation: Option<SourceTextureInformation>,
    pub m_SpriteBorder: Option<Vector4>,
    pub m_SpriteExtrude: Option<u32>,
    pub m_SpriteGenerateFallbackPhysicsShape: Option<i32>,
    pub m_SpriteMeshType: Option<i32>,
    pub m_SpriteMode: Option<i32>,
    pub m_SpritePackingTag: Option<String>,
    pub m_SpritePivot: Option<Vector2>,
    pub m_SpritePixelsToUnits: Option<f32>,
    pub m_SpriteSheet: Option<SpriteSheetMetaData>,
    pub m_SpriteTessellationDetail: Option<f32>,
    pub m_StreamingMipmaps: Option<i32>,
    pub m_StreamingMipmapsPriority: Option<i32>,
    pub m_Swizzle: Option<u32>,
    pub m_TextureFormat: Option<i32>,
    pub m_TextureFormatSet: Option<i32>,
    pub m_TextureSettings: Option<GLTextureSettings>,
    pub m_TextureShape: Option<i32>,
    pub m_TextureType: Option<i32>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
    pub m_VTOnly: Option<i32>,
    pub m_sRGBTexture: Option<i32>,
}

impl_object!(TextureImporter);

impl Clone for TextureImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            correctGamma: self.correctGamma.clone(),
            m_Alignment: self.m_Alignment.clone(),
            m_AllowsAlphaSplitting: self.m_AllowsAlphaSplitting.clone(),
            m_AlphaIsTransparency: self.m_AlphaIsTransparency.clone(),
            m_AlphaTestReferenceValue: self.m_AlphaTestReferenceValue.clone(),
            m_AlphaUsage: self.m_AlphaUsage.clone(),
            m_ApplyGammaDecoding: self.m_ApplyGammaDecoding.clone(),
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_BorderMipMap: self.m_BorderMipMap.clone(),
            m_BuildTargetSettings: self.m_BuildTargetSettings.clone(),
            m_CompressionQuality: self.m_CompressionQuality.clone(),
            m_CompressionQualitySet: self.m_CompressionQualitySet.clone(),
            m_ConvertToNormalMap: self.m_ConvertToNormalMap.clone(),
            m_CookieLightType: self.m_CookieLightType.clone(),
            m_CorrectGamma: self.m_CorrectGamma.clone(),
            m_CubemapConvolution: self.m_CubemapConvolution.clone(),
            m_CubemapConvolutionExponent: self.m_CubemapConvolutionExponent.clone(),
            m_CubemapConvolutionSteps: self.m_CubemapConvolutionSteps.clone(),
            m_EnableMipMap: self.m_EnableMipMap.clone(),
            m_ExternalNormalMap: self.m_ExternalNormalMap.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_FadeOut: self.m_FadeOut.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_FlipGreenChannel: self.m_FlipGreenChannel.clone(),
            m_FlipbookColumns: self.m_FlipbookColumns.clone(),
            m_FlipbookRows: self.m_FlipbookRows.clone(),
            m_GenerateCubemap: self.m_GenerateCubemap.clone(),
            m_GrayScaleToAlpha: self.m_GrayScaleToAlpha.clone(),
            m_HeightScale: self.m_HeightScale.clone(),
            m_IgnoreMasterTextureLimit: self.m_IgnoreMasterTextureLimit.clone(),
            m_IgnoreMipmapLimit: self.m_IgnoreMipmapLimit.clone(),
            m_IgnorePngGamma: self.m_IgnorePngGamma.clone(),
            m_InternalIDToNameTable: self.m_InternalIDToNameTable.clone(),
            m_IsReadable: self.m_IsReadable.clone(),
            m_Lightmap: self.m_Lightmap.clone(),
            m_LinearTexture: self.m_LinearTexture.clone(),
            m_MaxTextureSize: self.m_MaxTextureSize.clone(),
            m_MaxTextureSizeSet: self.m_MaxTextureSizeSet.clone(),
            m_MipMapFadeDistanceEnd: self.m_MipMapFadeDistanceEnd.clone(),
            m_MipMapFadeDistanceStart: self.m_MipMapFadeDistanceStart.clone(),
            m_MipMapMode: self.m_MipMapMode.clone(),
            m_MipMapsPreserveCoverage: self.m_MipMapsPreserveCoverage.clone(),
            m_MipmapLimitGroupName: self.m_MipmapLimitGroupName.clone(),
            m_NPOTScale: self.m_NPOTScale.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_NormalMapFilter: self.m_NormalMapFilter.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_Output: self.m_Output.clone(),
            m_PSDRemoveMatte: self.m_PSDRemoveMatte.clone(),
            m_PSDShowRemoveMatteOption: self.m_PSDShowRemoveMatteOption.clone(),
            m_PlatformSettings: self.m_PlatformSettings.clone(),
            m_PushPullDilation: self.m_PushPullDilation.clone(),
            m_RGBM: self.m_RGBM.clone(),
            m_RecommendedTextureFormat: self.m_RecommendedTextureFormat.clone(),
            m_SeamlessCubemap: self.m_SeamlessCubemap.clone(),
            m_SingleChannelComponent: self.m_SingleChannelComponent.clone(),
            m_SourceTextureInformation: self.m_SourceTextureInformation.clone(),
            m_SpriteBorder: self.m_SpriteBorder.clone(),
            m_SpriteExtrude: self.m_SpriteExtrude.clone(),
            m_SpriteGenerateFallbackPhysicsShape: self.m_SpriteGenerateFallbackPhysicsShape.clone(),
            m_SpriteMeshType: self.m_SpriteMeshType.clone(),
            m_SpriteMode: self.m_SpriteMode.clone(),
            m_SpritePackingTag: self.m_SpritePackingTag.clone(),
            m_SpritePivot: self.m_SpritePivot.clone(),
            m_SpritePixelsToUnits: self.m_SpritePixelsToUnits.clone(),
            m_SpriteSheet: self.m_SpriteSheet.clone(),
            m_SpriteTessellationDetail: self.m_SpriteTessellationDetail.clone(),
            m_StreamingMipmaps: self.m_StreamingMipmaps.clone(),
            m_StreamingMipmapsPriority: self.m_StreamingMipmapsPriority.clone(),
            m_Swizzle: self.m_Swizzle.clone(),
            m_TextureFormat: self.m_TextureFormat.clone(),
            m_TextureFormatSet: self.m_TextureFormatSet.clone(),
            m_TextureSettings: self.m_TextureSettings.clone(),
            m_TextureShape: self.m_TextureShape.clone(),
            m_TextureType: self.m_TextureType.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
            m_VTOnly: self.m_VTOnly.clone(),
            m_sRGBTexture: self.m_sRGBTexture.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TrueTypeFontImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AscentCalculationMode: Option<i32>,
    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_CharacterPadding: Option<i32>,
    pub m_CharacterSpacing: Option<i32>,
    pub m_CustomCharacters: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_FallbackFontReferences: Option<Vec<PPtrData<Font>>>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_FontColor: Option<Color>,
    pub m_FontName: Option<String>,
    pub m_FontNames: Option<Vec<String>>,
    pub m_FontRenderingMode: Option<i32>,
    pub m_FontSize: Option<i32>,
    pub m_ForceTextureCase: Option<i32>,
    pub m_IncludeFontData: Option<bool>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_Output: Option<Output>,
    pub m_RenderMode: Option<i32>,
    pub m_ShouldRoundAdvanceValue: Option<bool>,
    pub m_Style: Option<i32>,
    pub m_Use2xBehaviour: Option<bool>,
    pub m_UseLegacyBoundsCalculation: Option<bool>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(TrueTypeFontImporter);

impl Clone for TrueTypeFontImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AscentCalculationMode: self.m_AscentCalculationMode.clone(),
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_CharacterPadding: self.m_CharacterPadding.clone(),
            m_CharacterSpacing: self.m_CharacterSpacing.clone(),
            m_CustomCharacters: self.m_CustomCharacters.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_FallbackFontReferences: self.m_FallbackFontReferences.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_FontColor: self.m_FontColor.clone(),
            m_FontName: self.m_FontName.clone(),
            m_FontNames: self.m_FontNames.clone(),
            m_FontRenderingMode: self.m_FontRenderingMode.clone(),
            m_FontSize: self.m_FontSize.clone(),
            m_ForceTextureCase: self.m_ForceTextureCase.clone(),
            m_IncludeFontData: self.m_IncludeFontData.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_Output: self.m_Output.clone(),
            m_RenderMode: self.m_RenderMode.clone(),
            m_ShouldRoundAdvanceValue: self.m_ShouldRoundAdvanceValue.clone(),
            m_Style: self.m_Style.clone(),
            m_Use2xBehaviour: self.m_Use2xBehaviour.clone(),
            m_UseLegacyBoundsCalculation: self.m_UseLegacyBoundsCalculation.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VideoClipImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_AudioImportMode: Option<i32>,
    pub m_ColorSpace: Option<i32>,
    pub m_Deinterlace: Option<i32>,
    pub m_EncodeAlpha: Option<bool>,
    pub m_EndFrame: Option<i32>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_FlipHorizontal: Option<bool>,
    pub m_FlipVertical: Option<bool>,
    pub m_FrameCount: Option<i32>,
    pub m_FrameRange: Option<i32>,
    pub m_FrameRate: Option<f64>,
    pub m_ImportAudio: Option<bool>,
    pub m_IsColorLinear: Option<bool>,
    pub m_Name: Option<String>,
    pub m_OriginalHeight: Option<i32>,
    pub m_OriginalWidth: Option<i32>,
    pub m_Output: Option<VideoClipImporterOutput>,
    pub m_PixelAspectRatioDenominator: Option<u32>,
    pub m_PixelAspectRatioNumerator: Option<u32>,
    pub m_Quality: Option<f32>,
    pub m_SourceAudioChannelCount: Option<Vec<u16>>,
    pub m_SourceAudioSampleRate: Option<Vec<u32>>,
    pub m_SourceFileSize: Option<u64>,
    pub m_SourceHasAlpha: Option<bool>,
    pub m_StartFrame: Option<i32>,
    pub m_TargetSettings: Option<Vec<(String, VideoClipImporterTargetSettings)>>,
    pub m_UseLegacyImporter: Option<bool>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(VideoClipImporter);

impl Clone for VideoClipImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_AudioImportMode: self.m_AudioImportMode.clone(),
            m_ColorSpace: self.m_ColorSpace.clone(),
            m_Deinterlace: self.m_Deinterlace.clone(),
            m_EncodeAlpha: self.m_EncodeAlpha.clone(),
            m_EndFrame: self.m_EndFrame.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_FlipHorizontal: self.m_FlipHorizontal.clone(),
            m_FlipVertical: self.m_FlipVertical.clone(),
            m_FrameCount: self.m_FrameCount.clone(),
            m_FrameRange: self.m_FrameRange.clone(),
            m_FrameRate: self.m_FrameRate.clone(),
            m_ImportAudio: self.m_ImportAudio.clone(),
            m_IsColorLinear: self.m_IsColorLinear.clone(),
            m_Name: self.m_Name.clone(),
            m_OriginalHeight: self.m_OriginalHeight.clone(),
            m_OriginalWidth: self.m_OriginalWidth.clone(),
            m_Output: self.m_Output.clone(),
            m_PixelAspectRatioDenominator: self.m_PixelAspectRatioDenominator.clone(),
            m_PixelAspectRatioNumerator: self.m_PixelAspectRatioNumerator.clone(),
            m_Quality: self.m_Quality.clone(),
            m_SourceAudioChannelCount: self.m_SourceAudioChannelCount.clone(),
            m_SourceAudioSampleRate: self.m_SourceAudioSampleRate.clone(),
            m_SourceFileSize: self.m_SourceFileSize.clone(),
            m_SourceHasAlpha: self.m_SourceHasAlpha.clone(),
            m_StartFrame: self.m_StartFrame.clone(),
            m_TargetSettings: self.m_TargetSettings.clone(),
            m_UseLegacyImporter: self.m_UseLegacyImporter.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VisualEffectImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_Template: Option<VFXTemplate>,
    pub m_UsedFileIDs: Option<Vec<i64>>,
    pub m_UserData: Option<String>,
}

impl_object!(VisualEffectImporter);

impl Clone for VisualEffectImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_Template: self.m_Template.clone(),
            m_UsedFileIDs: self.m_UsedFileIDs.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioContainerElement {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AudioClip: Option<PPtrData<AudioClip>>,
    pub m_Enabled: Option<bool>,
    pub m_Name: Option<String>,
    pub m_Volume: Option<f32>,
}

impl_object!(AudioContainerElement);

impl Clone for AudioContainerElement {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AudioClip: self.m_AudioClip.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_Name: self.m_Name.clone(),
            m_Volume: self.m_Volume.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioMixer {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_EnableSuspend: Option<bool>,
    pub m_MasterGroup: Option<PPtrData<AudioMixerGroup>>,
    pub m_MixerConstant: Option<AudioMixerConstant>,
    pub m_Name: Option<String>,
    pub m_OutputGroup: Option<PPtrData<AudioMixerGroup>>,
    pub m_Snapshots: Option<Vec<PPtrData<AudioMixerSnapshot>>>,
    pub m_StartSnapshot: Option<PPtrData<AudioMixerSnapshot>>,
    pub m_SuspendThreshold: Option<f32>,
    pub m_UpdateMode: Option<i32>,
}

impl_object!(AudioMixer);

impl Clone for AudioMixer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_EnableSuspend: self.m_EnableSuspend.clone(),
            m_MasterGroup: self.m_MasterGroup.clone(),
            m_MixerConstant: self.m_MixerConstant.clone(),
            m_Name: self.m_Name.clone(),
            m_OutputGroup: self.m_OutputGroup.clone(),
            m_Snapshots: self.m_Snapshots.clone(),
            m_StartSnapshot: self.m_StartSnapshot.clone(),
            m_SuspendThreshold: self.m_SuspendThreshold.clone(),
            m_UpdateMode: self.m_UpdateMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioMixerController {
    // extends AudioMixer
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_EnableSuspend: Option<bool>,
    pub m_MasterGroup: Option<PPtrData<AudioMixerGroup>>,
    pub m_MixerConstant: Option<AudioMixerConstant>,
    pub m_Name: Option<String>,
    pub m_OutputGroup: Option<PPtrData<AudioMixerGroup>>,
    pub m_Snapshots: Option<Vec<PPtrData<AudioMixerSnapshot>>>,
    pub m_StartSnapshot: Option<PPtrData<AudioMixerSnapshot>>,
    pub m_SuspendThreshold: Option<f32>,
    pub m_UpdateMode: Option<i32>,
}

impl_object!(AudioMixerController);

impl Clone for AudioMixerController {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_EnableSuspend: self.m_EnableSuspend.clone(),
            m_MasterGroup: self.m_MasterGroup.clone(),
            m_MixerConstant: self.m_MixerConstant.clone(),
            m_Name: self.m_Name.clone(),
            m_OutputGroup: self.m_OutputGroup.clone(),
            m_Snapshots: self.m_Snapshots.clone(),
            m_StartSnapshot: self.m_StartSnapshot.clone(),
            m_SuspendThreshold: self.m_SuspendThreshold.clone(),
            m_UpdateMode: self.m_UpdateMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioMixerEffectController {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Bypass: Option<bool>,
    pub m_EffectID: Option<GUID>,
    pub m_EffectName: Option<String>,
    pub m_EnableWetMix: Option<bool>,
    pub m_MixLevel: Option<GUID>,
    pub m_Name: Option<String>,
    pub m_Parameters: Option<Vec<Parameter>>,
    pub m_SendTarget: Option<PPtrData<AudioMixerEffectController>>,
}

impl_object!(AudioMixerEffectController);

impl Clone for AudioMixerEffectController {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Bypass: self.m_Bypass.clone(),
            m_EffectID: self.m_EffectID.clone(),
            m_EffectName: self.m_EffectName.clone(),
            m_EnableWetMix: self.m_EnableWetMix.clone(),
            m_MixLevel: self.m_MixLevel.clone(),
            m_Name: self.m_Name.clone(),
            m_Parameters: self.m_Parameters.clone(),
            m_SendTarget: self.m_SendTarget.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioMixerGroup {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AudioMixer: Option<PPtrData<AudioMixer>>,
    pub m_Children: Option<Vec<PPtrData<AudioMixerGroup>>>,
    pub m_GroupID: Option<GUID>,
    pub m_Name: Option<String>,
}

impl_object!(AudioMixerGroup);

impl Clone for AudioMixerGroup {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AudioMixer: self.m_AudioMixer.clone(),
            m_Children: self.m_Children.clone(),
            m_GroupID: self.m_GroupID.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioMixerGroupController {
    // extends AudioMixerGroup
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AudioMixer: Option<PPtrData<AudioMixer>>,
    pub m_Children: Option<Vec<PPtrData<AudioMixerGroup>>>,
    pub m_GroupID: Option<GUID>,
    pub m_Name: Option<String>,
}

impl_object!(AudioMixerGroupController);

impl Clone for AudioMixerGroupController {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AudioMixer: self.m_AudioMixer.clone(),
            m_Children: self.m_Children.clone(),
            m_GroupID: self.m_GroupID.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioMixerSnapshot {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AudioMixer: Option<PPtrData<AudioMixer>>,
    pub m_Name: Option<String>,
    pub m_SnapshotID: Option<GUID>,
}

impl_object!(AudioMixerSnapshot);

impl Clone for AudioMixerSnapshot {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AudioMixer: self.m_AudioMixer.clone(),
            m_Name: self.m_Name.clone(),
            m_SnapshotID: self.m_SnapshotID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioMixerSnapshotController {
    // extends AudioMixerSnapshot
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AudioMixer: Option<PPtrData<AudioMixer>>,
    pub m_Name: Option<String>,
    pub m_SnapshotID: Option<GUID>,
}

impl_object!(AudioMixerSnapshotController);

impl Clone for AudioMixerSnapshotController {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AudioMixer: self.m_AudioMixer.clone(),
            m_Name: self.m_Name.clone(),
            m_SnapshotID: self.m_SnapshotID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioResource {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
}

impl_object!(AudioResource);

impl Clone for AudioResource {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioRandomContainer {
    // extends AudioResource
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AutomaticTriggerMode: Option<i32>,
    pub m_AutomaticTriggerTime: Option<f32>,
    pub m_AutomaticTriggerTimeRandomizationEnabled: Option<bool>,
    pub m_AutomaticTriggerTimeRandomizationRange: Option<Vector2>,
    pub m_AvoidRepeatingLast: Option<i32>,
    pub m_Elements: Option<Vec<PPtrData<AudioContainerElement>>>,
    pub m_LoopCount: Option<i32>,
    pub m_LoopCountRandomizationEnabled: Option<bool>,
    pub m_LoopCountRandomizationRange: Option<Vector2>,
    pub m_LoopMode: Option<i32>,
    pub m_Name: Option<String>,
    pub m_Pitch: Option<f32>,
    pub m_PitchRandomizationEnabled: Option<bool>,
    pub m_PitchRandomizationRange: Option<Vector2>,
    pub m_PlaybackMode: Option<i32>,
    pub m_TriggerMode: Option<i32>,
    pub m_Volume: Option<f32>,
    pub m_VolumeRandomizationEnabled: Option<bool>,
    pub m_VolumeRandomizationRange: Option<Vector2>,
}

impl_object!(AudioRandomContainer);

impl Clone for AudioRandomContainer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AutomaticTriggerMode: self.m_AutomaticTriggerMode.clone(),
            m_AutomaticTriggerTime: self.m_AutomaticTriggerTime.clone(),
            m_AutomaticTriggerTimeRandomizationEnabled: self
                .m_AutomaticTriggerTimeRandomizationEnabled
                .clone(),
            m_AutomaticTriggerTimeRandomizationRange: self
                .m_AutomaticTriggerTimeRandomizationRange
                .clone(),
            m_AvoidRepeatingLast: self.m_AvoidRepeatingLast.clone(),
            m_Elements: self.m_Elements.clone(),
            m_LoopCount: self.m_LoopCount.clone(),
            m_LoopCountRandomizationEnabled: self.m_LoopCountRandomizationEnabled.clone(),
            m_LoopCountRandomizationRange: self.m_LoopCountRandomizationRange.clone(),
            m_LoopMode: self.m_LoopMode.clone(),
            m_Name: self.m_Name.clone(),
            m_Pitch: self.m_Pitch.clone(),
            m_PitchRandomizationEnabled: self.m_PitchRandomizationEnabled.clone(),
            m_PitchRandomizationRange: self.m_PitchRandomizationRange.clone(),
            m_PlaybackMode: self.m_PlaybackMode.clone(),
            m_TriggerMode: self.m_TriggerMode.clone(),
            m_Volume: self.m_Volume.clone(),
            m_VolumeRandomizationEnabled: self.m_VolumeRandomizationEnabled.clone(),
            m_VolumeRandomizationRange: self.m_VolumeRandomizationRange.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SampleClip {
    // extends AudioResource
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
}

impl_object!(SampleClip);

impl Clone for SampleClip {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioClip {
    // extends SampleClip
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_3D: Option<bool>,
    pub m_Ambisonic: Option<bool>,
    pub m_AudioData: Option<Vec<u8>>,
    pub m_BitsPerSample: Option<i32>,
    pub m_Channels: Option<i32>,
    pub m_CompressionFormat: Option<i32>,
    pub m_Format: Option<i32>,
    pub m_Frequency: Option<i32>,
    pub m_IsTrackerFormat: Option<bool>,
    pub m_Legacy3D: Option<bool>,
    pub m_Length: Option<f32>,
    pub m_LoadInBackground: Option<bool>,
    pub m_LoadType: Option<i32>,
    pub m_Name: Option<String>,
    pub m_PreloadAudioData: Option<bool>,
    pub m_Resource: Option<StreamedResource>,
    pub m_Stream: Option<i32>,
    pub m_SubsoundIndex: Option<i32>,
    pub m_Type: Option<i32>,
    pub m_UseHardware: Option<bool>,
}

impl_object!(AudioClip);

impl Clone for AudioClip {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_3D: self.m_3D.clone(),
            m_Ambisonic: self.m_Ambisonic.clone(),
            m_AudioData: self.m_AudioData.clone(),
            m_BitsPerSample: self.m_BitsPerSample.clone(),
            m_Channels: self.m_Channels.clone(),
            m_CompressionFormat: self.m_CompressionFormat.clone(),
            m_Format: self.m_Format.clone(),
            m_Frequency: self.m_Frequency.clone(),
            m_IsTrackerFormat: self.m_IsTrackerFormat.clone(),
            m_Legacy3D: self.m_Legacy3D.clone(),
            m_Length: self.m_Length.clone(),
            m_LoadInBackground: self.m_LoadInBackground.clone(),
            m_LoadType: self.m_LoadType.clone(),
            m_Name: self.m_Name.clone(),
            m_PreloadAudioData: self.m_PreloadAudioData.clone(),
            m_Resource: self.m_Resource.clone(),
            m_Stream: self.m_Stream.clone(),
            m_SubsoundIndex: self.m_SubsoundIndex.clone(),
            m_Type: self.m_Type.clone(),
            m_UseHardware: self.m_UseHardware.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Avatar {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Avatar: Option<AvatarConstant>,
    pub m_AvatarSize: Option<u32>,
    pub m_HumanDescription: Option<HumanDescription>,
    pub m_Name: Option<String>,
    pub m_TOS: Option<Vec<(u32, String)>>,
}

impl_object!(Avatar);

impl Clone for Avatar {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Avatar: self.m_Avatar.clone(),
            m_AvatarSize: self.m_AvatarSize.clone(),
            m_HumanDescription: self.m_HumanDescription.clone(),
            m_Name: self.m_Name.clone(),
            m_TOS: self.m_TOS.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AvatarMask {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Elements: Option<Vec<TransformMaskElement>>,
    pub m_Mask: Option<Vec<u32>>,
    pub m_Name: Option<String>,
}

impl_object!(AvatarMask);

impl Clone for AvatarMask {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Elements: self.m_Elements.clone(),
            m_Mask: self.m_Mask.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AvatarSkeletonMask {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub elements: Option<Vec<AvatarSkeletonMaskElement>>,
    pub m_Name: Option<String>,
}

impl_object!(AvatarSkeletonMask);

impl Clone for AvatarSkeletonMask {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            elements: self.elements.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BaseAnimationTrack {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(BaseAnimationTrack);

impl Clone for BaseAnimationTrack {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NewAnimationTrack {
    // extends BaseAnimationTrack
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ClassID: Option<i32>,
    pub m_Curves: Option<Vec<Channel>>,
    pub m_Name: Option<String>,
}

impl_object!(NewAnimationTrack);

impl Clone for NewAnimationTrack {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ClassID: self.m_ClassID.clone(),
            m_Curves: self.m_Curves.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BillboardAsset {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bottom: Option<f32>,
    pub height: Option<f32>,
    pub imageTexCoords: Option<Vec<Vector4>>,
    pub indices: Option<Vec<u16>>,
    pub m_Name: Option<String>,
    pub material: Option<PPtrData<Material>>,
    pub rotated: Option<Vec<u8>>,
    pub vertices: Option<Vec<Vector2>>,
    pub width: Option<f32>,
}

impl_object!(BillboardAsset);

impl Clone for BillboardAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bottom: self.bottom.clone(),
            height: self.height.clone(),
            imageTexCoords: self.imageTexCoords.clone(),
            indices: self.indices.clone(),
            m_Name: self.m_Name.clone(),
            material: self.material.clone(),
            rotated: self.rotated.clone(),
            vertices: self.vertices.clone(),
            width: self.width.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuildReport {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Appendices: Option<Vec<PPtrData<Object>>>,
    pub m_BuildSteps: Option<Vec<BuildStepInfo>>,
    pub m_Files: Option<Vec<BuildReportFile>>,
    pub m_Name: Option<String>,
    pub m_Summary: Option<BuildSummary>,
}

impl_object!(BuildReport);

impl Clone for BuildReport {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Appendices: self.m_Appendices.clone(),
            m_BuildSteps: self.m_BuildSteps.clone(),
            m_Files: self.m_Files.clone(),
            m_Name: self.m_Name.clone(),
            m_Summary: self.m_Summary.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CachedSpriteAtlas {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub alphaTextures: Option<Vec<PPtrData<Texture2D>>>,
    pub frames: Option<Vec<((GUID, i32), SpriteRenderData)>>,
    pub textures: Option<Vec<PPtrData<Texture2D>>>,
}

impl_object!(CachedSpriteAtlas);

impl Clone for CachedSpriteAtlas {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            alphaTextures: self.alphaTextures.clone(),
            frames: self.frames.clone(),
            textures: self.textures.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CachedSpriteAtlasRuntimeData {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub alphaTextures: Option<Vec<PPtrData<Texture2D>>>,
    pub currentPackingHash: Option<Hash128>,
    pub frames: Option<Vec<((GUID, i64), SpriteAtlasData)>>,
    pub textures: Option<Vec<PPtrData<Texture2D>>>,
}

impl_object!(CachedSpriteAtlasRuntimeData);

impl Clone for CachedSpriteAtlasRuntimeData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            alphaTextures: self.alphaTextures.clone(),
            currentPackingHash: self.currentPackingHash.clone(),
            frames: self.frames.clone(),
            textures: self.textures.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ComputeShader {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub constantBuffers: Option<Vec<ComputeShaderCB>>,
    pub kernels: Option<Vec<ComputeShaderKernel>>,
    pub m_Name: Option<String>,
    pub variants: Option<Vec<ComputeShaderPlatformVariant>>,
}

impl_object!(ComputeShader);

impl Clone for ComputeShader {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            constantBuffers: self.constantBuffers.clone(),
            kernels: self.kernels.clone(),
            m_Name: self.m_Name.clone(),
            variants: self.variants.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DefaultAsset {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_IsWarning: Option<bool>,
    pub m_Message: Option<String>,
    pub m_Name: Option<String>,
}

impl_object!(DefaultAsset);

impl Clone for DefaultAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_IsWarning: self.m_IsWarning.clone(),
            m_Message: self.m_Message.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BrokenPrefabAsset {
    // extends DefaultAsset
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BrokenParentPrefab: Option<PPtrData<BrokenPrefabAsset>>,
    pub m_IsPrefabFileValid: Option<bool>,
    pub m_IsVariant: Option<bool>,
    pub m_IsWarning: Option<bool>,
    pub m_Message: Option<String>,
    pub m_Name: Option<String>,
}

impl_object!(BrokenPrefabAsset);

impl Clone for BrokenPrefabAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BrokenParentPrefab: self.m_BrokenParentPrefab.clone(),
            m_IsPrefabFileValid: self.m_IsPrefabFileValid.clone(),
            m_IsVariant: self.m_IsVariant.clone(),
            m_IsWarning: self.m_IsWarning.clone(),
            m_Message: self.m_Message.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SceneAsset {
    // extends DefaultAsset
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_IsWarning: Option<bool>,
    pub m_Message: Option<String>,
    pub m_Name: Option<String>,
}

impl_object!(SceneAsset);

impl Clone for SceneAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_IsWarning: self.m_IsWarning.clone(),
            m_Message: self.m_Message.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EditorProjectAccess {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
}

impl_object!(EditorProjectAccess);

impl Clone for EditorProjectAccess {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Flare {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Elements: Option<Vec<FlareElement>>,
    pub m_FlareTexture: Option<PPtrData<Texture>>,
    pub m_Name: Option<String>,
    pub m_TextureLayout: Option<i32>,
    pub m_UseFog: Option<bool>,
}

impl_object!(Flare);

impl Clone for Flare {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Elements: self.m_Elements.clone(),
            m_FlareTexture: self.m_FlareTexture.clone(),
            m_Name: self.m_Name.clone(),
            m_TextureLayout: self.m_TextureLayout.clone(),
            m_UseFog: self.m_UseFog.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Font {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Ascent: Option<f32>,
    pub m_AsciiStartOffset: Option<i32>,
    pub m_CharacterPadding: Option<i32>,
    pub m_CharacterRects: Option<Vec<CharacterInfo>>,
    pub m_CharacterSpacing: Option<i32>,
    pub m_ConvertCase: Option<i32>,
    pub m_DefaultMaterial: Option<PPtrData<Material>>,
    pub m_DefaultStyle: Option<u32>,
    pub m_Descent: Option<f32>,
    pub m_FallbackFonts: Option<Vec<PPtrData<Font>>>,
    pub m_FontCountX: Option<i32>,
    pub m_FontCountY: Option<i32>,
    pub m_FontData: Option<Vec<i8>>,
    pub m_FontNames: Option<Vec<String>>,
    pub m_FontRenderingMode: Option<i32>,
    pub m_FontSize: Option<f32>,
    pub m_GridFont: Option<bool>,
    pub m_Kerning: Option<f32>,
    pub m_KerningValues: Option<Vec<((u16, u16), f32)>>,
    pub m_LineSpacing: Option<f32>,
    pub m_Name: Option<String>,
    pub m_PerCharacterKerning: Option<Vec<(i32, f32)>>,
    pub m_PixelScale: Option<f32>,
    pub m_ShouldRoundAdvanceValue: Option<bool>,
    pub m_Texture: Option<PPtrData<Texture>>,
    pub m_Tracking: Option<f32>,
    pub m_UseLegacyBoundsCalculation: Option<bool>,
}

impl_object!(Font);

impl Clone for Font {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Ascent: self.m_Ascent.clone(),
            m_AsciiStartOffset: self.m_AsciiStartOffset.clone(),
            m_CharacterPadding: self.m_CharacterPadding.clone(),
            m_CharacterRects: self.m_CharacterRects.clone(),
            m_CharacterSpacing: self.m_CharacterSpacing.clone(),
            m_ConvertCase: self.m_ConvertCase.clone(),
            m_DefaultMaterial: self.m_DefaultMaterial.clone(),
            m_DefaultStyle: self.m_DefaultStyle.clone(),
            m_Descent: self.m_Descent.clone(),
            m_FallbackFonts: self.m_FallbackFonts.clone(),
            m_FontCountX: self.m_FontCountX.clone(),
            m_FontCountY: self.m_FontCountY.clone(),
            m_FontData: self.m_FontData.clone(),
            m_FontNames: self.m_FontNames.clone(),
            m_FontRenderingMode: self.m_FontRenderingMode.clone(),
            m_FontSize: self.m_FontSize.clone(),
            m_GridFont: self.m_GridFont.clone(),
            m_Kerning: self.m_Kerning.clone(),
            m_KerningValues: self.m_KerningValues.clone(),
            m_LineSpacing: self.m_LineSpacing.clone(),
            m_Name: self.m_Name.clone(),
            m_PerCharacterKerning: self.m_PerCharacterKerning.clone(),
            m_PixelScale: self.m_PixelScale.clone(),
            m_ShouldRoundAdvanceValue: self.m_ShouldRoundAdvanceValue.clone(),
            m_Texture: self.m_Texture.clone(),
            m_Tracking: self.m_Tracking.clone(),
            m_UseLegacyBoundsCalculation: self.m_UseLegacyBoundsCalculation.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GameObjectRecorder {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
}

impl_object!(GameObjectRecorder);

impl Clone for GameObjectRecorder {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GraphicsStateCollection {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DeviceRenderer: Option<i32>,
    pub m_Name: Option<String>,
    pub m_QualityLevelName: Option<String>,
    pub m_RenderPassInfoMap: Option<Vec<(u64, RenderPassInfo)>>,
    pub m_RenderStateMap: Option<Vec<(u64, RenderStateInfo)>>,
    pub m_RuntimePlatform: Option<i32>,
    pub m_VariantInfoMap: Option<Vec<(Hash128, VariantInfo)>>,
    pub m_Version: Option<i32>,
    pub m_VertexLayoutInfoMap: Option<Vec<(u64, VertexLayoutInfo)>>,
}

impl_object!(GraphicsStateCollection);

impl Clone for GraphicsStateCollection {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DeviceRenderer: self.m_DeviceRenderer.clone(),
            m_Name: self.m_Name.clone(),
            m_QualityLevelName: self.m_QualityLevelName.clone(),
            m_RenderPassInfoMap: self.m_RenderPassInfoMap.clone(),
            m_RenderStateMap: self.m_RenderStateMap.clone(),
            m_RuntimePlatform: self.m_RuntimePlatform.clone(),
            m_VariantInfoMap: self.m_VariantInfoMap.clone(),
            m_Version: self.m_Version.clone(),
            m_VertexLayoutInfoMap: self.m_VertexLayoutInfoMap.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HumanTemplate {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BoneTemplate: Option<Vec<(String, String)>>,
    pub m_Name: Option<String>,
}

impl_object!(HumanTemplate);

impl Clone for HumanTemplate {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BoneTemplate: self.m_BoneTemplate.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ImportLog {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Logs: Option<Vec<ImportLog_ImportLogEntry>>,
    pub m_Name: Option<String>,
}

impl_object!(ImportLog);

impl Clone for ImportLog {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Logs: self.m_Logs.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LightProbes {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bakedCoefficients: Option<Vec<LightmapData>>,
    pub bakedPositions: Option<Vec<Vector3>>,
    pub hullRays: Option<Vec<Vector3>>,
    pub m_BakedCoefficients: Option<Vec<SphericalHarmonicsL2>>,
    pub m_BakedLightOcclusion: Option<Vec<LightProbeOcclusion>>,
    pub m_Data: Option<LightProbeData>,
    pub m_HasBeenEdited: Option<bool>,
    pub m_Name: Option<String>,
    pub tetrahedra: Option<Vec<Tetrahedron>>,
}

impl_object!(LightProbes);

impl Clone for LightProbes {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bakedCoefficients: self.bakedCoefficients.clone(),
            bakedPositions: self.bakedPositions.clone(),
            hullRays: self.hullRays.clone(),
            m_BakedCoefficients: self.m_BakedCoefficients.clone(),
            m_BakedLightOcclusion: self.m_BakedLightOcclusion.clone(),
            m_Data: self.m_Data.clone(),
            m_HasBeenEdited: self.m_HasBeenEdited.clone(),
            m_Name: self.m_Name.clone(),
            tetrahedra: self.tetrahedra.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LightingDataAsset {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AOTextures: Option<Vec<PPtrData<Texture2D>>>,
    pub m_BakedAmbientProbeInLinear: Option<SphericalHarmonicsL2>,
    pub m_BakedLightIndices: Option<Vec<i32>>,
    pub m_BakedReflectionProbeCubemapCacheFiles: Option<Vec<String>>,
    pub m_BakedReflectionProbeCubemaps: Option<Vec<PPtrData<Texture>>>,
    pub m_BakedReflectionProbes: Option<Vec<SceneObjectIdentifier>>,
    pub m_EnlightenData: Option<Vec<u8>>,
    pub m_EnlightenDataVersion: Option<i32>,
    pub m_EnlightenSceneMapping: Option<EnlightenSceneMapping>,
    pub m_EnlightenSceneMappingRendererIDs: Option<Vec<SceneObjectIdentifier>>,
    pub m_LightBakingOutputs: Option<Vec<LightBakingOutput>>,
    pub m_LightProbes: Option<PPtrData<LightProbes>>,
    pub m_LightmappedRendererData: Option<Vec<RendererData>>,
    pub m_LightmappedRendererDataIDs: Option<Vec<SceneObjectIdentifier>>,
    pub m_Lightmaps: Option<Vec<LightmapData>>,
    pub m_LightmapsCacheFiles: Option<Vec<String>>,
    pub m_LightmapsMode: Option<i32>,
    pub m_Lights: Option<Vec<SceneObjectIdentifier>>,
    pub m_Name: Option<String>,
    pub m_Scene: Option<PPtrData<SceneAsset>>,
    pub m_SceneGUID: Option<GUID>,
}

impl_object!(LightingDataAsset);

impl Clone for LightingDataAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AOTextures: self.m_AOTextures.clone(),
            m_BakedAmbientProbeInLinear: self.m_BakedAmbientProbeInLinear.clone(),
            m_BakedLightIndices: self.m_BakedLightIndices.clone(),
            m_BakedReflectionProbeCubemapCacheFiles: self
                .m_BakedReflectionProbeCubemapCacheFiles
                .clone(),
            m_BakedReflectionProbeCubemaps: self.m_BakedReflectionProbeCubemaps.clone(),
            m_BakedReflectionProbes: self.m_BakedReflectionProbes.clone(),
            m_EnlightenData: self.m_EnlightenData.clone(),
            m_EnlightenDataVersion: self.m_EnlightenDataVersion.clone(),
            m_EnlightenSceneMapping: self.m_EnlightenSceneMapping.clone(),
            m_EnlightenSceneMappingRendererIDs: self.m_EnlightenSceneMappingRendererIDs.clone(),
            m_LightBakingOutputs: self.m_LightBakingOutputs.clone(),
            m_LightProbes: self.m_LightProbes.clone(),
            m_LightmappedRendererData: self.m_LightmappedRendererData.clone(),
            m_LightmappedRendererDataIDs: self.m_LightmappedRendererDataIDs.clone(),
            m_Lightmaps: self.m_Lightmaps.clone(),
            m_LightmapsCacheFiles: self.m_LightmapsCacheFiles.clone(),
            m_LightmapsMode: self.m_LightmapsMode.clone(),
            m_Lights: self.m_Lights.clone(),
            m_Name: self.m_Name.clone(),
            m_Scene: self.m_Scene.clone(),
            m_SceneGUID: self.m_SceneGUID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LightingDataAssetParent {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
}

impl_object!(LightingDataAssetParent);

impl Clone for LightingDataAssetParent {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LightingSettings {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AO: Option<bool>,
    pub m_AOMaxDistance: Option<f32>,
    pub m_AlbedoBoost: Option<f32>,
    pub m_BakeBackend: Option<i32>,
    pub m_BakeResolution: Option<f32>,
    pub m_BounceScale: Option<f32>,
    pub m_CompAOExponent: Option<f32>,
    pub m_CompAOExponentDirect: Option<f32>,
    pub m_EnableBakedLightmaps: Option<bool>,
    pub m_EnableRealtimeLightmaps: Option<bool>,
    pub m_ExportTrainingData: Option<bool>,
    pub m_ExtractAO: Option<bool>,
    pub m_FilterMode: Option<i32>,
    pub m_FinalGather: Option<bool>,
    pub m_FinalGatherFiltering: Option<bool>,
    pub m_FinalGatherRayCount: Option<i32>,
    pub m_ForceUpdates: Option<bool>,
    pub m_ForceWhiteAlbedo: Option<bool>,
    pub m_GIWorkflowMode: Option<i32>,
    pub m_IndirectOutputScale: Option<f32>,
    pub m_LightmapMaxSize: Option<i32>,
    pub m_LightmapParameters: Option<PPtrData<LightmapParameters>>,
    pub m_LightmapsBakeMode: Option<i32>,
    pub m_MixedBakeMode: Option<i32>,
    pub m_Name: Option<String>,
    pub m_PVRBounces: Option<i32>,
    pub m_PVRCulling: Option<bool>,
    pub m_PVRDenoiserTypeAO: Option<i32>,
    pub m_PVRDenoiserTypeDirect: Option<i32>,
    pub m_PVRDenoiserTypeIndirect: Option<i32>,
    pub m_PVRDirectSampleCount: Option<i32>,
    pub m_PVREnvironmentMIS: Option<i32>,
    pub m_PVREnvironmentReferencePointCount: Option<i32>,
    pub m_PVREnvironmentSampleCount: Option<i32>,
    pub m_PVRFilterTypeAO: Option<i32>,
    pub m_PVRFilterTypeDirect: Option<i32>,
    pub m_PVRFilterTypeIndirect: Option<i32>,
    pub m_PVRFilteringAtrousPositionSigmaAO: Option<f32>,
    pub m_PVRFilteringAtrousPositionSigmaDirect: Option<f32>,
    pub m_PVRFilteringAtrousPositionSigmaIndirect: Option<f32>,
    pub m_PVRFilteringGaussRadiusAO: Option<i32>,
    pub m_PVRFilteringGaussRadiusDirect: Option<i32>,
    pub m_PVRFilteringGaussRadiusIndirect: Option<i32>,
    pub m_PVRFilteringMode: Option<i32>,
    pub m_PVRSampleCount: Option<i32>,
    pub m_PVRSampling: Option<i32>,
    pub m_Padding: Option<i32>,
    pub m_RealtimeEnvironmentLighting: Option<bool>,
    pub m_RealtimeResolution: Option<f32>,
    pub m_TextureCompression: Option<bool>,
    pub m_TrainingDataDestination: Option<String>,
    pub m_UsingShadowmask: Option<bool>,
}

impl_object!(LightingSettings);

impl Clone for LightingSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AO: self.m_AO.clone(),
            m_AOMaxDistance: self.m_AOMaxDistance.clone(),
            m_AlbedoBoost: self.m_AlbedoBoost.clone(),
            m_BakeBackend: self.m_BakeBackend.clone(),
            m_BakeResolution: self.m_BakeResolution.clone(),
            m_BounceScale: self.m_BounceScale.clone(),
            m_CompAOExponent: self.m_CompAOExponent.clone(),
            m_CompAOExponentDirect: self.m_CompAOExponentDirect.clone(),
            m_EnableBakedLightmaps: self.m_EnableBakedLightmaps.clone(),
            m_EnableRealtimeLightmaps: self.m_EnableRealtimeLightmaps.clone(),
            m_ExportTrainingData: self.m_ExportTrainingData.clone(),
            m_ExtractAO: self.m_ExtractAO.clone(),
            m_FilterMode: self.m_FilterMode.clone(),
            m_FinalGather: self.m_FinalGather.clone(),
            m_FinalGatherFiltering: self.m_FinalGatherFiltering.clone(),
            m_FinalGatherRayCount: self.m_FinalGatherRayCount.clone(),
            m_ForceUpdates: self.m_ForceUpdates.clone(),
            m_ForceWhiteAlbedo: self.m_ForceWhiteAlbedo.clone(),
            m_GIWorkflowMode: self.m_GIWorkflowMode.clone(),
            m_IndirectOutputScale: self.m_IndirectOutputScale.clone(),
            m_LightmapMaxSize: self.m_LightmapMaxSize.clone(),
            m_LightmapParameters: self.m_LightmapParameters.clone(),
            m_LightmapsBakeMode: self.m_LightmapsBakeMode.clone(),
            m_MixedBakeMode: self.m_MixedBakeMode.clone(),
            m_Name: self.m_Name.clone(),
            m_PVRBounces: self.m_PVRBounces.clone(),
            m_PVRCulling: self.m_PVRCulling.clone(),
            m_PVRDenoiserTypeAO: self.m_PVRDenoiserTypeAO.clone(),
            m_PVRDenoiserTypeDirect: self.m_PVRDenoiserTypeDirect.clone(),
            m_PVRDenoiserTypeIndirect: self.m_PVRDenoiserTypeIndirect.clone(),
            m_PVRDirectSampleCount: self.m_PVRDirectSampleCount.clone(),
            m_PVREnvironmentMIS: self.m_PVREnvironmentMIS.clone(),
            m_PVREnvironmentReferencePointCount: self.m_PVREnvironmentReferencePointCount.clone(),
            m_PVREnvironmentSampleCount: self.m_PVREnvironmentSampleCount.clone(),
            m_PVRFilterTypeAO: self.m_PVRFilterTypeAO.clone(),
            m_PVRFilterTypeDirect: self.m_PVRFilterTypeDirect.clone(),
            m_PVRFilterTypeIndirect: self.m_PVRFilterTypeIndirect.clone(),
            m_PVRFilteringAtrousPositionSigmaAO: self.m_PVRFilteringAtrousPositionSigmaAO.clone(),
            m_PVRFilteringAtrousPositionSigmaDirect: self
                .m_PVRFilteringAtrousPositionSigmaDirect
                .clone(),
            m_PVRFilteringAtrousPositionSigmaIndirect: self
                .m_PVRFilteringAtrousPositionSigmaIndirect
                .clone(),
            m_PVRFilteringGaussRadiusAO: self.m_PVRFilteringGaussRadiusAO.clone(),
            m_PVRFilteringGaussRadiusDirect: self.m_PVRFilteringGaussRadiusDirect.clone(),
            m_PVRFilteringGaussRadiusIndirect: self.m_PVRFilteringGaussRadiusIndirect.clone(),
            m_PVRFilteringMode: self.m_PVRFilteringMode.clone(),
            m_PVRSampleCount: self.m_PVRSampleCount.clone(),
            m_PVRSampling: self.m_PVRSampling.clone(),
            m_Padding: self.m_Padding.clone(),
            m_RealtimeEnvironmentLighting: self.m_RealtimeEnvironmentLighting.clone(),
            m_RealtimeResolution: self.m_RealtimeResolution.clone(),
            m_TextureCompression: self.m_TextureCompression.clone(),
            m_TrainingDataDestination: self.m_TrainingDataDestination.clone(),
            m_UsingShadowmask: self.m_UsingShadowmask.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LightmapParameters {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub AOAntiAliasingSamples: Option<i32>,
    pub AOQuality: Option<i32>,
    pub antiAliasingSamples: Option<i32>,
    pub backFaceTolerance: Option<f32>,
    pub bakedLightmapTag: Option<i32>,
    pub blurRadius: Option<i32>,
    pub clusterResolution: Option<f32>,
    pub directLightQuality: Option<i32>,
    pub edgeStitching: Option<i32>,
    pub irradianceBudget: Option<i32>,
    pub irradianceQuality: Option<i32>,
    pub isTransparent: Option<i32>,
    pub limitLightmapCount: Option<bool>,
    pub m_Name: Option<String>,
    pub maxLightmapCount: Option<i32>,
    pub modellingTolerance: Option<f32>,
    pub pushoff: Option<f32>,
    pub resolution: Option<f32>,
    pub systemTag: Option<i32>,
}

impl_object!(LightmapParameters);

impl Clone for LightmapParameters {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            AOAntiAliasingSamples: self.AOAntiAliasingSamples.clone(),
            AOQuality: self.AOQuality.clone(),
            antiAliasingSamples: self.antiAliasingSamples.clone(),
            backFaceTolerance: self.backFaceTolerance.clone(),
            bakedLightmapTag: self.bakedLightmapTag.clone(),
            blurRadius: self.blurRadius.clone(),
            clusterResolution: self.clusterResolution.clone(),
            directLightQuality: self.directLightQuality.clone(),
            edgeStitching: self.edgeStitching.clone(),
            irradianceBudget: self.irradianceBudget.clone(),
            irradianceQuality: self.irradianceQuality.clone(),
            isTransparent: self.isTransparent.clone(),
            limitLightmapCount: self.limitLightmapCount.clone(),
            m_Name: self.m_Name.clone(),
            maxLightmapCount: self.maxLightmapCount.clone(),
            modellingTolerance: self.modellingTolerance.clone(),
            pushoff: self.pushoff.clone(),
            resolution: self.resolution.clone(),
            systemTag: self.systemTag.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LocalizationAsset {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub Editor_Asset: Option<bool>,
    pub Locale_ISO_Code: Option<String>,
    pub String_Table: Option<Vec<(String, String)>>,
    pub m_Name: Option<String>,
}

impl_object!(LocalizationAsset);

impl Clone for LocalizationAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            Editor_Asset: self.Editor_Asset.clone(),
            Locale_ISO_Code: self.Locale_ISO_Code.clone(),
            String_Table: self.String_Table.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Material {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub disabledShaderPasses: Option<Vec<String>>,
    pub m_BuildTextureStacks: Option<Vec<BuildTextureStackReference>>,
    pub m_CustomRenderQueue: Option<i32>,
    pub m_DoubleSidedGI: Option<bool>,
    pub m_EnableInstancingVariants: Option<bool>,
    pub m_InvalidKeywords: Option<Vec<String>>,
    pub m_LightmapFlags: Option<u32>,
    pub m_Name: Option<String>,
    pub m_SavedProperties: Option<UnityPropertySheet>,
    pub m_Shader: Option<PPtrData<Shader>>,
    pub m_ShaderKeywords: Option<String>,
    pub m_ValidKeywords: Option<Vec<String>>,
    pub stringTagMap: Option<Vec<(String, String)>>,
}

impl_object!(Material);

impl Clone for Material {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            disabledShaderPasses: self.disabledShaderPasses.clone(),
            m_BuildTextureStacks: self.m_BuildTextureStacks.clone(),
            m_CustomRenderQueue: self.m_CustomRenderQueue.clone(),
            m_DoubleSidedGI: self.m_DoubleSidedGI.clone(),
            m_EnableInstancingVariants: self.m_EnableInstancingVariants.clone(),
            m_InvalidKeywords: self.m_InvalidKeywords.clone(),
            m_LightmapFlags: self.m_LightmapFlags.clone(),
            m_Name: self.m_Name.clone(),
            m_SavedProperties: self.m_SavedProperties.clone(),
            m_Shader: self.m_Shader.clone(),
            m_ShaderKeywords: self.m_ShaderKeywords.clone(),
            m_ValidKeywords: self.m_ValidKeywords.clone(),
            stringTagMap: self.stringTagMap.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ProceduralMaterial {
    // extends Material
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub disabledShaderPasses: Option<Vec<String>>,
    pub m_AnimationUpdateRate: Option<i32>,
    pub m_BuildTextureStacks: Option<Vec<BuildTextureStackReference>>,
    pub m_CacheSize: Option<i32>,
    pub m_CustomRenderQueue: Option<i32>,
    pub m_DoubleSidedGI: Option<bool>,
    pub m_EnableInstancingVariants: Option<bool>,
    pub m_Flags: Option<u32>,
    pub m_GenerateMipmaps: Option<bool>,
    pub m_Hash: Option<Hash128>,
    pub m_Height: Option<i32>,
    pub m_Inputs: Option<Vec<SubstanceInput>>,
    pub m_InvalidKeywords: Option<Vec<String>>,
    pub m_LightmapFlags: Option<u32>,
    pub m_LoadingBehavior: Option<i32>,
    pub m_MaximumSize: Option<i32>,
    pub m_Name: Option<String>,
    pub m_PrototypeName: Option<String>,
    pub m_SavedProperties: Option<UnityPropertySheet>,
    pub m_Shader: Option<PPtrData<Shader>>,
    pub m_ShaderKeywords: Option<String>,
    pub m_SubstancePackage: Option<PPtrData<SubstanceArchive>>,
    pub m_Textures: Option<Vec<PPtrData<ProceduralTexture>>>,
    pub m_ValidKeywords: Option<Vec<String>>,
    pub m_Width: Option<i32>,
    pub stringTagMap: Option<Vec<(String, String)>>,
}

impl_object!(ProceduralMaterial);

impl Clone for ProceduralMaterial {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            disabledShaderPasses: self.disabledShaderPasses.clone(),
            m_AnimationUpdateRate: self.m_AnimationUpdateRate.clone(),
            m_BuildTextureStacks: self.m_BuildTextureStacks.clone(),
            m_CacheSize: self.m_CacheSize.clone(),
            m_CustomRenderQueue: self.m_CustomRenderQueue.clone(),
            m_DoubleSidedGI: self.m_DoubleSidedGI.clone(),
            m_EnableInstancingVariants: self.m_EnableInstancingVariants.clone(),
            m_Flags: self.m_Flags.clone(),
            m_GenerateMipmaps: self.m_GenerateMipmaps.clone(),
            m_Hash: self.m_Hash.clone(),
            m_Height: self.m_Height.clone(),
            m_Inputs: self.m_Inputs.clone(),
            m_InvalidKeywords: self.m_InvalidKeywords.clone(),
            m_LightmapFlags: self.m_LightmapFlags.clone(),
            m_LoadingBehavior: self.m_LoadingBehavior.clone(),
            m_MaximumSize: self.m_MaximumSize.clone(),
            m_Name: self.m_Name.clone(),
            m_PrototypeName: self.m_PrototypeName.clone(),
            m_SavedProperties: self.m_SavedProperties.clone(),
            m_Shader: self.m_Shader.clone(),
            m_ShaderKeywords: self.m_ShaderKeywords.clone(),
            m_SubstancePackage: self.m_SubstancePackage.clone(),
            m_Textures: self.m_Textures.clone(),
            m_ValidKeywords: self.m_ValidKeywords.clone(),
            m_Width: self.m_Width.clone(),
            stringTagMap: self.stringTagMap.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Mesh {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BakedConvexCollisionMesh: Option<Vec<u8>>,
    pub m_BakedTriangleCollisionMesh: Option<Vec<u8>>,
    pub m_BindPose: Option<Vec<Matrix4x4>>,
    pub m_BoneNameHashes: Option<Vec<u32>>,
    pub m_BonesAABB: Option<Vec<MinMaxAABB>>,
    pub m_CollisionTriangles: Option<Vec<u32>>,
    pub m_CollisionVertexCount: Option<i32>,
    pub m_Colors: Option<Vec<Color>>,
    pub m_CompressedMesh: Option<CompressedMesh>,
    pub m_CookingOptions: Option<i32>,
    pub m_IndexBuffer: Option<Vec<u8>>,
    pub m_IndexFormat: Option<i32>,
    pub m_IsReadable: Option<bool>,
    pub m_KeepIndices: Option<bool>,
    pub m_KeepVertices: Option<bool>,
    pub m_LocalAABB: Option<AABB>,
    pub m_MeshCompression: Option<u8>,
    pub m_MeshMetrics_0_: Option<f32>,
    pub m_MeshMetrics_1_: Option<f32>,
    pub m_MeshUsageFlags: Option<i32>,
    pub m_Name: Option<String>,
    pub m_Normals: Option<Vec<Vector3>>,
    pub m_RootBoneNameHash: Option<u32>,
    pub m_ShapeVertices: Option<Vec<MeshBlendShapeVertex>>,
    pub m_Shapes: Option<BlendShapeData>,
    pub m_Skin: Option<Vec<BoneInfluence>>,
    pub m_StreamCompression: Option<u8>,
    pub m_StreamData: Option<StreamingInfo>,
    pub m_SubMeshes: Option<Vec<SubMesh>>,
    pub m_Tangents: Option<Vec<Vector4>>,
    pub m_UV: Option<Vec<Vector2>>,
    pub m_UV1: Option<Vec<Vector2>>,
    pub m_Use16BitIndices: Option<i32>,
    pub m_VariableBoneCountWeights: Option<VariableBoneCountWeights>,
    pub m_VertexData: Option<VertexData>,
    pub m_Vertices: Option<Vec<Vector3>>,
}

impl_object!(Mesh);

impl Clone for Mesh {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BakedConvexCollisionMesh: self.m_BakedConvexCollisionMesh.clone(),
            m_BakedTriangleCollisionMesh: self.m_BakedTriangleCollisionMesh.clone(),
            m_BindPose: self.m_BindPose.clone(),
            m_BoneNameHashes: self.m_BoneNameHashes.clone(),
            m_BonesAABB: self.m_BonesAABB.clone(),
            m_CollisionTriangles: self.m_CollisionTriangles.clone(),
            m_CollisionVertexCount: self.m_CollisionVertexCount.clone(),
            m_Colors: self.m_Colors.clone(),
            m_CompressedMesh: self.m_CompressedMesh.clone(),
            m_CookingOptions: self.m_CookingOptions.clone(),
            m_IndexBuffer: self.m_IndexBuffer.clone(),
            m_IndexFormat: self.m_IndexFormat.clone(),
            m_IsReadable: self.m_IsReadable.clone(),
            m_KeepIndices: self.m_KeepIndices.clone(),
            m_KeepVertices: self.m_KeepVertices.clone(),
            m_LocalAABB: self.m_LocalAABB.clone(),
            m_MeshCompression: self.m_MeshCompression.clone(),
            m_MeshMetrics_0_: self.m_MeshMetrics_0_.clone(),
            m_MeshMetrics_1_: self.m_MeshMetrics_1_.clone(),
            m_MeshUsageFlags: self.m_MeshUsageFlags.clone(),
            m_Name: self.m_Name.clone(),
            m_Normals: self.m_Normals.clone(),
            m_RootBoneNameHash: self.m_RootBoneNameHash.clone(),
            m_ShapeVertices: self.m_ShapeVertices.clone(),
            m_Shapes: self.m_Shapes.clone(),
            m_Skin: self.m_Skin.clone(),
            m_StreamCompression: self.m_StreamCompression.clone(),
            m_StreamData: self.m_StreamData.clone(),
            m_SubMeshes: self.m_SubMeshes.clone(),
            m_Tangents: self.m_Tangents.clone(),
            m_UV: self.m_UV.clone(),
            m_UV1: self.m_UV1.clone(),
            m_Use16BitIndices: self.m_Use16BitIndices.clone(),
            m_VariableBoneCountWeights: self.m_VariableBoneCountWeights.clone(),
            m_VertexData: self.m_VertexData.clone(),
            m_Vertices: self.m_Vertices.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Motion {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(Motion);

impl Clone for Motion {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnimationClip {
    // extends Motion
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AnimationType: Option<i32>,
    pub m_Bounds: Option<AABB>,
    pub m_ClipBindingConstant: Option<AnimationClipBindingConstant>,
    pub m_Compressed: Option<bool>,
    pub m_CompressedRotationCurves: Option<Vec<CompressedAnimationCurve>>,
    pub m_EulerCurves: Option<Vec<Vector3Curve>>,
    pub m_Events: Option<Vec<AnimationEvent>>,
    pub m_FloatCurves: Option<Vec<FloatCurve>>,
    pub m_HasGenericRootTransform: Option<bool>,
    pub m_HasMotionFloatCurves: Option<bool>,
    pub m_Legacy: Option<bool>,
    pub m_MuscleClip: Option<ClipMuscleConstant>,
    pub m_MuscleClipSize: Option<u32>,
    pub m_Name: Option<String>,
    pub m_PPtrCurves: Option<Vec<PPtrCurve>>,
    pub m_PositionCurves: Option<Vec<Vector3Curve>>,
    pub m_RotationCurves: Option<Vec<QuaternionCurve>>,
    pub m_SampleRate: Option<f32>,
    pub m_ScaleCurves: Option<Vec<Vector3Curve>>,
    pub m_UseHighQualityCurve: Option<bool>,
    pub m_WrapMode: Option<i32>,
}

impl_object!(AnimationClip);

impl Clone for AnimationClip {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AnimationType: self.m_AnimationType.clone(),
            m_Bounds: self.m_Bounds.clone(),
            m_ClipBindingConstant: self.m_ClipBindingConstant.clone(),
            m_Compressed: self.m_Compressed.clone(),
            m_CompressedRotationCurves: self.m_CompressedRotationCurves.clone(),
            m_EulerCurves: self.m_EulerCurves.clone(),
            m_Events: self.m_Events.clone(),
            m_FloatCurves: self.m_FloatCurves.clone(),
            m_HasGenericRootTransform: self.m_HasGenericRootTransform.clone(),
            m_HasMotionFloatCurves: self.m_HasMotionFloatCurves.clone(),
            m_Legacy: self.m_Legacy.clone(),
            m_MuscleClip: self.m_MuscleClip.clone(),
            m_MuscleClipSize: self.m_MuscleClipSize.clone(),
            m_Name: self.m_Name.clone(),
            m_PPtrCurves: self.m_PPtrCurves.clone(),
            m_PositionCurves: self.m_PositionCurves.clone(),
            m_RotationCurves: self.m_RotationCurves.clone(),
            m_SampleRate: self.m_SampleRate.clone(),
            m_ScaleCurves: self.m_ScaleCurves.clone(),
            m_UseHighQualityCurve: self.m_UseHighQualityCurve.clone(),
            m_WrapMode: self.m_WrapMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PreviewAnimationClip {
    // extends AnimationClip
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Bounds: Option<AABB>,
    pub m_ClipBindingConstant: Option<AnimationClipBindingConstant>,
    pub m_Compressed: Option<bool>,
    pub m_CompressedRotationCurves: Option<Vec<CompressedAnimationCurve>>,
    pub m_EulerCurves: Option<Vec<Vector3Curve>>,
    pub m_Events: Option<Vec<AnimationEvent>>,
    pub m_FloatCurves: Option<Vec<FloatCurve>>,
    pub m_HasGenericRootTransform: Option<bool>,
    pub m_HasMotionFloatCurves: Option<bool>,
    pub m_Legacy: Option<bool>,
    pub m_MuscleClip: Option<ClipMuscleConstant>,
    pub m_MuscleClipSize: Option<u32>,
    pub m_Name: Option<String>,
    pub m_PPtrCurves: Option<Vec<PPtrCurve>>,
    pub m_PositionCurves: Option<Vec<Vector3Curve>>,
    pub m_RotationCurves: Option<Vec<QuaternionCurve>>,
    pub m_SampleRate: Option<f32>,
    pub m_ScaleCurves: Option<Vec<Vector3Curve>>,
    pub m_UseHighQualityCurve: Option<bool>,
    pub m_WrapMode: Option<i32>,
}

impl_object!(PreviewAnimationClip);

impl Clone for PreviewAnimationClip {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Bounds: self.m_Bounds.clone(),
            m_ClipBindingConstant: self.m_ClipBindingConstant.clone(),
            m_Compressed: self.m_Compressed.clone(),
            m_CompressedRotationCurves: self.m_CompressedRotationCurves.clone(),
            m_EulerCurves: self.m_EulerCurves.clone(),
            m_Events: self.m_Events.clone(),
            m_FloatCurves: self.m_FloatCurves.clone(),
            m_HasGenericRootTransform: self.m_HasGenericRootTransform.clone(),
            m_HasMotionFloatCurves: self.m_HasMotionFloatCurves.clone(),
            m_Legacy: self.m_Legacy.clone(),
            m_MuscleClip: self.m_MuscleClip.clone(),
            m_MuscleClipSize: self.m_MuscleClipSize.clone(),
            m_Name: self.m_Name.clone(),
            m_PPtrCurves: self.m_PPtrCurves.clone(),
            m_PositionCurves: self.m_PositionCurves.clone(),
            m_RotationCurves: self.m_RotationCurves.clone(),
            m_SampleRate: self.m_SampleRate.clone(),
            m_ScaleCurves: self.m_ScaleCurves.clone(),
            m_UseHighQualityCurve: self.m_UseHighQualityCurve.clone(),
            m_WrapMode: self.m_WrapMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BlendTree {
    // extends Motion
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BlendEvent: Option<String>,
    pub m_BlendEventY: Option<String>,
    pub m_BlendParameter: Option<String>,
    pub m_BlendParameterY: Option<String>,
    pub m_BlendType: Option<i32>,
    pub m_Childs: Option<Vec<Child>>,
    pub m_MaxThreshold: Option<f32>,
    pub m_MinThreshold: Option<f32>,
    pub m_Name: Option<String>,
    pub m_NormalizedBlendValues: Option<bool>,
    pub m_UseAutomaticThresholds: Option<bool>,
}

impl_object!(BlendTree);

impl Clone for BlendTree {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BlendEvent: self.m_BlendEvent.clone(),
            m_BlendEventY: self.m_BlendEventY.clone(),
            m_BlendParameter: self.m_BlendParameter.clone(),
            m_BlendParameterY: self.m_BlendParameterY.clone(),
            m_BlendType: self.m_BlendType.clone(),
            m_Childs: self.m_Childs.clone(),
            m_MaxThreshold: self.m_MaxThreshold.clone(),
            m_MinThreshold: self.m_MinThreshold.clone(),
            m_Name: self.m_Name.clone(),
            m_NormalizedBlendValues: self.m_NormalizedBlendValues.clone(),
            m_UseAutomaticThresholds: self.m_UseAutomaticThresholds.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NavMeshData {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AgentTypeID: Option<i32>,
    pub m_HeightMeshes: Option<Vec<HeightMeshData>>,
    pub m_Heightmaps: Option<Vec<HeightmapData>>,
    pub m_Name: Option<String>,
    pub m_NavMeshBuildSettings: Option<NavMeshBuildSettings>,
    pub m_NavMeshParams: Option<NavMeshParams>,
    pub m_NavMeshTiles: Option<Vec<NavMeshTileData>>,
    pub m_OffMeshLinks: Option<Vec<AutoOffMeshLinkData>>,
    pub m_Position: Option<Vector3>,
    pub m_Rotation: Option<Quaternion>,
    pub m_SourceBounds: Option<AABB>,
}

impl_object!(NavMeshData);

impl Clone for NavMeshData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AgentTypeID: self.m_AgentTypeID.clone(),
            m_HeightMeshes: self.m_HeightMeshes.clone(),
            m_Heightmaps: self.m_Heightmaps.clone(),
            m_Name: self.m_Name.clone(),
            m_NavMeshBuildSettings: self.m_NavMeshBuildSettings.clone(),
            m_NavMeshParams: self.m_NavMeshParams.clone(),
            m_NavMeshTiles: self.m_NavMeshTiles.clone(),
            m_OffMeshLinks: self.m_OffMeshLinks.clone(),
            m_Position: self.m_Position.clone(),
            m_Rotation: self.m_Rotation.clone(),
            m_SourceBounds: self.m_SourceBounds.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NavMeshObsolete {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
}

impl_object!(NavMeshObsolete);

impl Clone for NavMeshObsolete {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct OcclusionCullingData {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
    pub m_PVSData: Option<Vec<u8>>,
    pub m_Scenes: Option<Vec<OcclusionScene>>,
}

impl_object!(OcclusionCullingData);

impl Clone for OcclusionCullingData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
            m_PVSData: self.m_PVSData.clone(),
            m_Scenes: self.m_Scenes.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PhysicsMaterial {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bounceCombine: Option<i32>,
    pub bounciness: Option<f32>,
    pub dynamicFriction: Option<f32>,
    pub frictionCombine: Option<i32>,
    pub m_BounceCombine: Option<i32>,
    pub m_Bounciness: Option<f32>,
    pub m_DynamicFriction: Option<f32>,
    pub m_FrictionCombine: Option<i32>,
    pub m_Name: Option<String>,
    pub m_StaticFriction: Option<f32>,
    pub staticFriction: Option<f32>,
}

impl_object!(PhysicsMaterial);

impl Clone for PhysicsMaterial {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bounceCombine: self.bounceCombine.clone(),
            bounciness: self.bounciness.clone(),
            dynamicFriction: self.dynamicFriction.clone(),
            frictionCombine: self.frictionCombine.clone(),
            m_BounceCombine: self.m_BounceCombine.clone(),
            m_Bounciness: self.m_Bounciness.clone(),
            m_DynamicFriction: self.m_DynamicFriction.clone(),
            m_FrictionCombine: self.m_FrictionCombine.clone(),
            m_Name: self.m_Name.clone(),
            m_StaticFriction: self.m_StaticFriction.clone(),
            staticFriction: self.staticFriction.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PhysicsMaterial2D {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bounciness: Option<f32>,
    pub friction: Option<f32>,
    pub m_BounceCombine: Option<i32>,
    pub m_FrictionCombine: Option<i32>,
    pub m_Name: Option<String>,
}

impl_object!(PhysicsMaterial2D);

impl Clone for PhysicsMaterial2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bounciness: self.bounciness.clone(),
            friction: self.friction.clone(),
            m_BounceCombine: self.m_BounceCombine.clone(),
            m_FrictionCombine: self.m_FrictionCombine.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PreloadData {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Assets: Option<Vec<PPtrData<Object>>>,
    pub m_Dependencies: Option<Vec<String>>,
    pub m_ExplicitDataLayout: Option<bool>,
    pub m_Name: Option<String>,
}

impl_object!(PreloadData);

impl Clone for PreloadData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Assets: self.m_Assets.clone(),
            m_Dependencies: self.m_Dependencies.clone(),
            m_ExplicitDataLayout: self.m_ExplicitDataLayout.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Preset {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CoupledProperties: Option<Vec<PropertyModification>>,
    pub m_CoupledType: Option<PresetType>,
    pub m_ExcludedProperties: Option<Vec<String>>,
    pub m_Name: Option<String>,
    pub m_Properties: Option<Vec<PropertyModification>>,
    pub m_TargetType: Option<PresetType>,
}

impl_object!(Preset);

impl Clone for Preset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CoupledProperties: self.m_CoupledProperties.clone(),
            m_CoupledType: self.m_CoupledType.clone(),
            m_ExcludedProperties: self.m_ExcludedProperties.clone(),
            m_Name: self.m_Name.clone(),
            m_Properties: self.m_Properties.clone(),
            m_TargetType: self.m_TargetType.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RayTracingShader {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_EnableRayPayloadSizeChecks: Option<bool>,
    pub m_MaxRecursionDepth: Option<u32>,
    pub m_Name: Option<String>,
    pub variants: Option<Vec<RayTracingShaderVariant>>,
}

impl_object!(RayTracingShader);

impl Clone for RayTracingShader {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_EnableRayPayloadSizeChecks: self.m_EnableRayPayloadSizeChecks.clone(),
            m_MaxRecursionDepth: self.m_MaxRecursionDepth.clone(),
            m_Name: self.m_Name.clone(),
            variants: self.variants.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RoslynAdditionalFileAsset {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
}

impl_object!(RoslynAdditionalFileAsset);

impl Clone for RoslynAdditionalFileAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RoslynAnalyzerConfigAsset {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
}

impl_object!(RoslynAnalyzerConfigAsset);

impl Clone for RoslynAnalyzerConfigAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RuntimeAnimatorController {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AnimationClips: Option<Vec<PPtrData<AnimationClip>>>,
    pub m_Controller: Option<ControllerConstant>,
    pub m_ControllerSize: Option<u32>,
    pub m_Name: Option<String>,
    pub m_TOS: Option<Vec<(u32, String)>>,
}

impl_object!(RuntimeAnimatorController);

impl Clone for RuntimeAnimatorController {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AnimationClips: self.m_AnimationClips.clone(),
            m_Controller: self.m_Controller.clone(),
            m_ControllerSize: self.m_ControllerSize.clone(),
            m_Name: self.m_Name.clone(),
            m_TOS: self.m_TOS.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnimatorController {
    // extends RuntimeAnimatorController
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AnimationClips: Option<Vec<PPtrData<AnimationClip>>>,
    pub m_Controller: Option<ControllerConstant>,
    pub m_ControllerSize: Option<u32>,
    pub m_MultiThreadedStateMachine: Option<bool>,
    pub m_Name: Option<String>,
    pub m_StateMachineBehaviourVectorDescription: Option<StateMachineBehaviourVectorDescription>,
    pub m_StateMachineBehaviours: Option<Vec<PPtrData<MonoBehaviour>>>,
    pub m_TOS: Option<Vec<(u32, String)>>,
}

impl_object!(AnimatorController);

impl Clone for AnimatorController {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AnimationClips: self.m_AnimationClips.clone(),
            m_Controller: self.m_Controller.clone(),
            m_ControllerSize: self.m_ControllerSize.clone(),
            m_MultiThreadedStateMachine: self.m_MultiThreadedStateMachine.clone(),
            m_Name: self.m_Name.clone(),
            m_StateMachineBehaviourVectorDescription: self
                .m_StateMachineBehaviourVectorDescription
                .clone(),
            m_StateMachineBehaviours: self.m_StateMachineBehaviours.clone(),
            m_TOS: self.m_TOS.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnimatorOverrideController {
    // extends RuntimeAnimatorController
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Clips: Option<Vec<AnimationClipOverride>>,
    pub m_Controller: Option<PPtrData<RuntimeAnimatorController>>,
    pub m_Name: Option<String>,
}

impl_object!(AnimatorOverrideController);

impl Clone for AnimatorOverrideController {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Clips: self.m_Clips.clone(),
            m_Controller: self.m_Controller.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Shader {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub compressedBlob: Option<Vec<u8>>,
    pub compressedLengths: Option<Vec<Vec<u32>>>,
    pub decompressedLengths: Option<Vec<Vec<u32>>>,
    pub decompressedSize: Option<u32>,
    pub m_AssetGUID: Option<GUID>,
    pub m_Dependencies: Option<Vec<PPtrData<Shader>>>,
    pub m_Name: Option<String>,
    pub m_NonModifiableTextures: Option<Vec<(String, PPtrData<Texture>)>>,
    pub m_ParsedForm: Option<SerializedShader>,
    pub m_PathName: Option<String>,
    pub m_Script: Option<String>,
    pub m_ShaderIsBaked: Option<bool>,
    pub m_SubProgramBlob: Option<Vec<u8>>,
    pub offsets: Option<Vec<Vec<u32>>>,
    pub platforms: Option<Vec<u32>>,
    pub stageCounts: Option<Vec<u32>>,
}

impl_object!(Shader);

impl Clone for Shader {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            compressedBlob: self.compressedBlob.clone(),
            compressedLengths: self.compressedLengths.clone(),
            decompressedLengths: self.decompressedLengths.clone(),
            decompressedSize: self.decompressedSize.clone(),
            m_AssetGUID: self.m_AssetGUID.clone(),
            m_Dependencies: self.m_Dependencies.clone(),
            m_Name: self.m_Name.clone(),
            m_NonModifiableTextures: self.m_NonModifiableTextures.clone(),
            m_ParsedForm: self.m_ParsedForm.clone(),
            m_PathName: self.m_PathName.clone(),
            m_Script: self.m_Script.clone(),
            m_ShaderIsBaked: self.m_ShaderIsBaked.clone(),
            m_SubProgramBlob: self.m_SubProgramBlob.clone(),
            offsets: self.offsets.clone(),
            platforms: self.platforms.clone(),
            stageCounts: self.stageCounts.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ShaderVariantCollection {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
    pub m_Shaders: Option<Vec<(PPtrData<Shader>, ShaderInfo)>>,
}

impl_object!(ShaderVariantCollection);

impl Clone for ShaderVariantCollection {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
            m_Shaders: self.m_Shaders.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpeedTreeWindAsset {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Config8: Option<SpeedTreeWindConfig8>,
    pub m_Config9: Option<SpeedTreeWindConfig9>,
    pub m_Name: Option<String>,
    pub m_Wind: Option<SpeedTreeWind>,
    pub m_eVersion: Option<i32>,
}

impl_object!(SpeedTreeWindAsset);

impl Clone for SpeedTreeWindAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Config8: self.m_Config8.clone(),
            m_Config9: self.m_Config9.clone(),
            m_Name: self.m_Name.clone(),
            m_Wind: self.m_Wind.clone(),
            m_eVersion: self.m_eVersion.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Sprite {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AtlasTags: Option<Vec<String>>,
    pub m_Bones: Option<Vec<SpriteBone>>,
    pub m_Border: Option<Vector4>,
    pub m_Extrude: Option<u32>,
    pub m_IsPolygon: Option<bool>,
    pub m_Name: Option<String>,
    pub m_Offset: Option<Vector2>,
    pub m_PhysicsShape: Option<Vec<Vec<Vector2>>>,
    pub m_Pivot: Option<Vector2>,
    pub m_PixelsToUnits: Option<f32>,
    pub m_RD: Option<SpriteRenderData>,
    pub m_Rect: Option<Rectf>,
    pub m_RenderDataKey: Option<(GUID, i64)>,
    pub m_ScriptableObjects: Option<Vec<PPtrData<MonoBehaviour>>>,
    pub m_SpriteAtlas: Option<PPtrData<SpriteAtlas>>,
}

impl_object!(Sprite);

impl Clone for Sprite {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AtlasTags: self.m_AtlasTags.clone(),
            m_Bones: self.m_Bones.clone(),
            m_Border: self.m_Border.clone(),
            m_Extrude: self.m_Extrude.clone(),
            m_IsPolygon: self.m_IsPolygon.clone(),
            m_Name: self.m_Name.clone(),
            m_Offset: self.m_Offset.clone(),
            m_PhysicsShape: self.m_PhysicsShape.clone(),
            m_Pivot: self.m_Pivot.clone(),
            m_PixelsToUnits: self.m_PixelsToUnits.clone(),
            m_RD: self.m_RD.clone(),
            m_Rect: self.m_Rect.clone(),
            m_RenderDataKey: self.m_RenderDataKey.clone(),
            m_ScriptableObjects: self.m_ScriptableObjects.clone(),
            m_SpriteAtlas: self.m_SpriteAtlas.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteAtlas {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_IsVariant: Option<bool>,
    pub m_Name: Option<String>,
    pub m_PackedSpriteNamesToIndex: Option<Vec<String>>,
    pub m_PackedSprites: Option<Vec<PPtrData<Sprite>>>,
    pub m_RenderDataMap: Option<Vec<((GUID, i64), SpriteAtlasData)>>,
    pub m_Tag: Option<String>,
}

impl_object!(SpriteAtlas);

impl Clone for SpriteAtlas {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_IsVariant: self.m_IsVariant.clone(),
            m_Name: self.m_Name.clone(),
            m_PackedSpriteNamesToIndex: self.m_PackedSpriteNamesToIndex.clone(),
            m_PackedSprites: self.m_PackedSprites.clone(),
            m_RenderDataMap: self.m_RenderDataMap.clone(),
            m_Tag: self.m_Tag.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteAtlasAsset {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ImporterData: Option<SpriteAtlasAssetData>,
    pub m_IsVariant: Option<bool>,
    pub m_MasterAtlas: Option<PPtrData<SpriteAtlas>>,
    pub m_Name: Option<String>,
    pub m_ScriptablePacker: Option<PPtrData<Object>>,
}

impl_object!(SpriteAtlasAsset);

impl Clone for SpriteAtlasAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ImporterData: self.m_ImporterData.clone(),
            m_IsVariant: self.m_IsVariant.clone(),
            m_MasterAtlas: self.m_MasterAtlas.clone(),
            m_Name: self.m_Name.clone(),
            m_ScriptablePacker: self.m_ScriptablePacker.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SubstanceArchive {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
    pub m_PackageData: Option<Vec<u8>>,
}

impl_object!(SubstanceArchive);

impl Clone for SubstanceArchive {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
            m_PackageData: self.m_PackageData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TerrainData {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DetailDatabase: Option<DetailDatabase>,
    pub m_Heightmap: Option<Heightmap>,
    pub m_Name: Option<String>,
    pub m_PreloadShaders: Option<Vec<PPtrData<Shader>>>,
    pub m_SplatDatabase: Option<SplatDatabase>,
}

impl_object!(TerrainData);

impl Clone for TerrainData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DetailDatabase: self.m_DetailDatabase.clone(),
            m_Heightmap: self.m_Heightmap.clone(),
            m_Name: self.m_Name.clone(),
            m_PreloadShaders: self.m_PreloadShaders.clone(),
            m_SplatDatabase: self.m_SplatDatabase.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TerrainLayer {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DiffuseRemapMax: Option<Vector4>,
    pub m_DiffuseRemapMin: Option<Vector4>,
    pub m_DiffuseTexture: Option<PPtrData<Texture2D>>,
    pub m_MaskMapRemapMax: Option<Vector4>,
    pub m_MaskMapRemapMin: Option<Vector4>,
    pub m_MaskMapTexture: Option<PPtrData<Texture2D>>,
    pub m_Metallic: Option<f32>,
    pub m_Name: Option<String>,
    pub m_NormalMapTexture: Option<PPtrData<Texture2D>>,
    pub m_NormalScale: Option<f32>,
    pub m_Smoothness: Option<f32>,
    pub m_SmoothnessSource: Option<i32>,
    pub m_Specular: Option<Color>,
    pub m_TileOffset: Option<Vector2>,
    pub m_TileSize: Option<Vector2>,
}

impl_object!(TerrainLayer);

impl Clone for TerrainLayer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DiffuseRemapMax: self.m_DiffuseRemapMax.clone(),
            m_DiffuseRemapMin: self.m_DiffuseRemapMin.clone(),
            m_DiffuseTexture: self.m_DiffuseTexture.clone(),
            m_MaskMapRemapMax: self.m_MaskMapRemapMax.clone(),
            m_MaskMapRemapMin: self.m_MaskMapRemapMin.clone(),
            m_MaskMapTexture: self.m_MaskMapTexture.clone(),
            m_Metallic: self.m_Metallic.clone(),
            m_Name: self.m_Name.clone(),
            m_NormalMapTexture: self.m_NormalMapTexture.clone(),
            m_NormalScale: self.m_NormalScale.clone(),
            m_Smoothness: self.m_Smoothness.clone(),
            m_SmoothnessSource: self.m_SmoothnessSource.clone(),
            m_Specular: self.m_Specular.clone(),
            m_TileOffset: self.m_TileOffset.clone(),
            m_TileSize: self.m_TileSize.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TextAsset {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
    pub m_PathName: Option<String>,
    pub m_Script: Option<String>,
}

impl_object!(TextAsset);

impl Clone for TextAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
            m_PathName: self.m_PathName.clone(),
            m_Script: self.m_Script.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssemblyDefinitionAsset {
    // extends TextAsset
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
    pub m_Script: Option<String>,
}

impl_object!(AssemblyDefinitionAsset);

impl Clone for AssemblyDefinitionAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
            m_Script: self.m_Script.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssemblyDefinitionReferenceAsset {
    // extends TextAsset
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
    pub m_Script: Option<String>,
}

impl_object!(AssemblyDefinitionReferenceAsset);

impl Clone for AssemblyDefinitionReferenceAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
            m_Script: self.m_Script.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MonoScript {
    // extends TextAsset
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssemblyName: Option<String>,
    pub m_ClassName: Option<String>,
    pub m_ExecutionOrder: Option<i32>,
    pub m_IsEditorScript: Option<bool>,
    pub m_Name: Option<String>,
    pub m_Namespace: Option<String>,
    pub m_PropertiesHash: Option<Hash128>,
}

impl_object!(MonoScript);

impl Clone for MonoScript {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssemblyName: self.m_AssemblyName.clone(),
            m_ClassName: self.m_ClassName.clone(),
            m_ExecutionOrder: self.m_ExecutionOrder.clone(),
            m_IsEditorScript: self.m_IsEditorScript.clone(),
            m_Name: self.m_Name.clone(),
            m_Namespace: self.m_Namespace.clone(),
            m_PropertiesHash: self.m_PropertiesHash.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PackageManifest {
    // extends TextAsset
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
    pub m_Script: Option<String>,
}

impl_object!(PackageManifest);

impl Clone for PackageManifest {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
            m_Script: self.m_Script.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RuleSetFileAsset {
    // extends TextAsset
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
    pub m_Script: Option<String>,
}

impl_object!(RuleSetFileAsset);

impl Clone for RuleSetFileAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
            m_Script: self.m_Script.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ShaderInclude {
    // extends TextAsset
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
    pub m_Script: Option<String>,
}

impl_object!(ShaderInclude);

impl Clone for ShaderInclude {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
            m_Script: self.m_Script.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Texture {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(Texture);

impl Clone for Texture {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BaseVideoTexture {
    // extends Texture
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(BaseVideoTexture);

impl Clone for BaseVideoTexture {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct WebCamTexture {
    // extends BaseVideoTexture
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DownscaleFallback: Option<bool>,
    pub m_ForcedFallbackFormat: Option<i32>,
    pub m_IsAlphaChannelOptional: Option<bool>,
    pub m_Name: Option<String>,
}

impl_object!(WebCamTexture);

impl Clone for WebCamTexture {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DownscaleFallback: self.m_DownscaleFallback.clone(),
            m_ForcedFallbackFormat: self.m_ForcedFallbackFormat.clone(),
            m_IsAlphaChannelOptional: self.m_IsAlphaChannelOptional.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CubemapArray {
    // extends Texture
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub image_data: Option<Vec<u8>>,
    pub m_ColorSpace: Option<i32>,
    pub m_CubemapCount: Option<i32>,
    pub m_DataSize: Option<u32>,
    pub m_DownscaleFallback: Option<bool>,
    pub m_ForcedFallbackFormat: Option<i32>,
    pub m_Format: Option<i32>,
    pub m_IsAlphaChannelOptional: Option<bool>,
    pub m_IsReadable: Option<bool>,
    pub m_MipCount: Option<i32>,
    pub m_Name: Option<String>,
    pub m_StreamData: Option<StreamingInfo>,
    pub m_TextureSettings: Option<GLTextureSettings>,
    pub m_UsageMode: Option<i32>,
    pub m_Width: Option<i32>,
}

impl_object!(CubemapArray);

impl Clone for CubemapArray {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            image_data: self.image_data.clone(),
            m_ColorSpace: self.m_ColorSpace.clone(),
            m_CubemapCount: self.m_CubemapCount.clone(),
            m_DataSize: self.m_DataSize.clone(),
            m_DownscaleFallback: self.m_DownscaleFallback.clone(),
            m_ForcedFallbackFormat: self.m_ForcedFallbackFormat.clone(),
            m_Format: self.m_Format.clone(),
            m_IsAlphaChannelOptional: self.m_IsAlphaChannelOptional.clone(),
            m_IsReadable: self.m_IsReadable.clone(),
            m_MipCount: self.m_MipCount.clone(),
            m_Name: self.m_Name.clone(),
            m_StreamData: self.m_StreamData.clone(),
            m_TextureSettings: self.m_TextureSettings.clone(),
            m_UsageMode: self.m_UsageMode.clone(),
            m_Width: self.m_Width.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LowerResBlitTexture {
    // extends Texture
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DownscaleFallback: Option<bool>,
    pub m_ForcedFallbackFormat: Option<i32>,
    pub m_IsAlphaChannelOptional: Option<bool>,
    pub m_Name: Option<String>,
}

impl_object!(LowerResBlitTexture);

impl Clone for LowerResBlitTexture {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DownscaleFallback: self.m_DownscaleFallback.clone(),
            m_ForcedFallbackFormat: self.m_ForcedFallbackFormat.clone(),
            m_IsAlphaChannelOptional: self.m_IsAlphaChannelOptional.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MovieTexture {
    // extends Texture
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AudioClip: Option<PPtrData<AudioClip>>,
    pub m_ColorSpace: Option<i32>,
    pub m_DownscaleFallback: Option<bool>,
    pub m_ForcedFallbackFormat: Option<i32>,
    pub m_IsAlphaChannelOptional: Option<bool>,
    pub m_Loop: Option<bool>,
    pub m_MovieData: Option<Vec<u8>>,
    pub m_Name: Option<String>,
}

impl_object!(MovieTexture);

impl Clone for MovieTexture {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AudioClip: self.m_AudioClip.clone(),
            m_ColorSpace: self.m_ColorSpace.clone(),
            m_DownscaleFallback: self.m_DownscaleFallback.clone(),
            m_ForcedFallbackFormat: self.m_ForcedFallbackFormat.clone(),
            m_IsAlphaChannelOptional: self.m_IsAlphaChannelOptional.clone(),
            m_Loop: self.m_Loop.clone(),
            m_MovieData: self.m_MovieData.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ProceduralTexture {
    // extends Texture
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub AlphaSource: Option<i32>,
    pub AlphaSourceIsGrayscale: Option<bool>,
    pub Format: Option<i32>,
    pub Type: Option<i32>,
    pub m_AlphaSourceIsInverted: Option<bool>,
    pub m_AlphaSourceUID: Option<u64>,
    pub m_BakedData: Option<Vec<u8>>,
    pub m_BakedParameters: Option<TextureParameters>,
    pub m_ColorSpace: Option<i32>,
    pub m_DownscaleFallback: Option<bool>,
    pub m_ForcedFallbackFormat: Option<i32>,
    pub m_IsAlphaChannelOptional: Option<bool>,
    pub m_LightmapFormat: Option<i32>,
    pub m_Mipmaps: Option<i32>,
    pub m_Name: Option<String>,
    pub m_SubstanceMaterial: Option<PPtrData<ProceduralMaterial>>,
    pub m_SubstanceTextureUID: Option<u64>,
    pub m_TextureParameters: Option<TextureParameters>,
    pub m_TextureSettings: Option<GLTextureSettings>,
}

impl_object!(ProceduralTexture);

impl Clone for ProceduralTexture {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            AlphaSource: self.AlphaSource.clone(),
            AlphaSourceIsGrayscale: self.AlphaSourceIsGrayscale.clone(),
            Format: self.Format.clone(),
            Type: self.Type.clone(),
            m_AlphaSourceIsInverted: self.m_AlphaSourceIsInverted.clone(),
            m_AlphaSourceUID: self.m_AlphaSourceUID.clone(),
            m_BakedData: self.m_BakedData.clone(),
            m_BakedParameters: self.m_BakedParameters.clone(),
            m_ColorSpace: self.m_ColorSpace.clone(),
            m_DownscaleFallback: self.m_DownscaleFallback.clone(),
            m_ForcedFallbackFormat: self.m_ForcedFallbackFormat.clone(),
            m_IsAlphaChannelOptional: self.m_IsAlphaChannelOptional.clone(),
            m_LightmapFormat: self.m_LightmapFormat.clone(),
            m_Mipmaps: self.m_Mipmaps.clone(),
            m_Name: self.m_Name.clone(),
            m_SubstanceMaterial: self.m_SubstanceMaterial.clone(),
            m_SubstanceTextureUID: self.m_SubstanceTextureUID.clone(),
            m_TextureParameters: self.m_TextureParameters.clone(),
            m_TextureSettings: self.m_TextureSettings.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RenderTexture {
    // extends Texture
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AntiAliasing: Option<i32>,
    pub m_BindMS: Option<bool>,
    pub m_ColorFormat: Option<i32>,
    pub m_DepthFormat: Option<i32>,
    pub m_DepthStencilFormat: Option<i32>,
    pub m_Dimension: Option<i32>,
    pub m_DownscaleFallback: Option<bool>,
    pub m_EnableCompatibleFormat: Option<bool>,
    pub m_EnableRandomWrite: Option<bool>,
    pub m_ForcedFallbackFormat: Option<i32>,
    pub m_GenerateMips: Option<bool>,
    pub m_Height: Option<i32>,
    pub m_IsAlphaChannelOptional: Option<bool>,
    pub m_IsCubemap: Option<bool>,
    pub m_IsPowerOfTwo: Option<bool>,
    pub m_MipCount: Option<i32>,
    pub m_MipMap: Option<bool>,
    pub m_Name: Option<String>,
    pub m_SRGB: Option<bool>,
    pub m_ShadowSamplingMode: Option<i32>,
    pub m_TextureSettings: Option<GLTextureSettings>,
    pub m_UseDynamicScale: Option<bool>,
    pub m_UseDynamicScaleExplicit: Option<bool>,
    pub m_VolumeDepth: Option<i32>,
    pub m_Width: Option<i32>,
}

impl_object!(RenderTexture);

impl Clone for RenderTexture {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AntiAliasing: self.m_AntiAliasing.clone(),
            m_BindMS: self.m_BindMS.clone(),
            m_ColorFormat: self.m_ColorFormat.clone(),
            m_DepthFormat: self.m_DepthFormat.clone(),
            m_DepthStencilFormat: self.m_DepthStencilFormat.clone(),
            m_Dimension: self.m_Dimension.clone(),
            m_DownscaleFallback: self.m_DownscaleFallback.clone(),
            m_EnableCompatibleFormat: self.m_EnableCompatibleFormat.clone(),
            m_EnableRandomWrite: self.m_EnableRandomWrite.clone(),
            m_ForcedFallbackFormat: self.m_ForcedFallbackFormat.clone(),
            m_GenerateMips: self.m_GenerateMips.clone(),
            m_Height: self.m_Height.clone(),
            m_IsAlphaChannelOptional: self.m_IsAlphaChannelOptional.clone(),
            m_IsCubemap: self.m_IsCubemap.clone(),
            m_IsPowerOfTwo: self.m_IsPowerOfTwo.clone(),
            m_MipCount: self.m_MipCount.clone(),
            m_MipMap: self.m_MipMap.clone(),
            m_Name: self.m_Name.clone(),
            m_SRGB: self.m_SRGB.clone(),
            m_ShadowSamplingMode: self.m_ShadowSamplingMode.clone(),
            m_TextureSettings: self.m_TextureSettings.clone(),
            m_UseDynamicScale: self.m_UseDynamicScale.clone(),
            m_UseDynamicScaleExplicit: self.m_UseDynamicScaleExplicit.clone(),
            m_VolumeDepth: self.m_VolumeDepth.clone(),
            m_Width: self.m_Width.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CustomRenderTexture {
    // extends RenderTexture
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AntiAliasing: Option<i32>,
    pub m_BindMS: Option<bool>,
    pub m_ColorFormat: Option<i32>,
    pub m_CubemapFaceMask: Option<u32>,
    pub m_CurrentUpdateZoneSpace: Option<i32>,
    pub m_DepthFormat: Option<i32>,
    pub m_DepthStencilFormat: Option<i32>,
    pub m_Dimension: Option<i32>,
    pub m_DoubleBuffered: Option<bool>,
    pub m_DownscaleFallback: Option<bool>,
    pub m_EnableCompatibleFormat: Option<bool>,
    pub m_EnableRandomWrite: Option<bool>,
    pub m_ForcedFallbackFormat: Option<i32>,
    pub m_GenerateMips: Option<bool>,
    pub m_Height: Option<i32>,
    pub m_InitColor: Option<Color>,
    pub m_InitMaterial: Option<PPtrData<Material>>,
    pub m_InitSource: Option<i32>,
    pub m_InitTexture: Option<PPtrData<Texture>>,
    pub m_InitializationMode: Option<i32>,
    pub m_IsAlphaChannelOptional: Option<bool>,
    pub m_Material: Option<PPtrData<Material>>,
    pub m_MipCount: Option<i32>,
    pub m_MipMap: Option<bool>,
    pub m_Name: Option<String>,
    pub m_SRGB: Option<bool>,
    pub m_ShaderPass: Option<u32>,
    pub m_ShadowSamplingMode: Option<i32>,
    pub m_TextureSettings: Option<GLTextureSettings>,
    pub m_UpdateMode: Option<i32>,
    pub m_UpdatePeriod: Option<f32>,
    pub m_UpdateZoneSpace: Option<i32>,
    pub m_UpdateZones: Option<Vec<UpdateZoneInfo>>,
    pub m_UseDynamicScale: Option<bool>,
    pub m_UseDynamicScaleExplicit: Option<bool>,
    pub m_VolumeDepth: Option<i32>,
    pub m_Width: Option<i32>,
    pub m_WrapUpdateZones: Option<bool>,
}

impl_object!(CustomRenderTexture);

impl Clone for CustomRenderTexture {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AntiAliasing: self.m_AntiAliasing.clone(),
            m_BindMS: self.m_BindMS.clone(),
            m_ColorFormat: self.m_ColorFormat.clone(),
            m_CubemapFaceMask: self.m_CubemapFaceMask.clone(),
            m_CurrentUpdateZoneSpace: self.m_CurrentUpdateZoneSpace.clone(),
            m_DepthFormat: self.m_DepthFormat.clone(),
            m_DepthStencilFormat: self.m_DepthStencilFormat.clone(),
            m_Dimension: self.m_Dimension.clone(),
            m_DoubleBuffered: self.m_DoubleBuffered.clone(),
            m_DownscaleFallback: self.m_DownscaleFallback.clone(),
            m_EnableCompatibleFormat: self.m_EnableCompatibleFormat.clone(),
            m_EnableRandomWrite: self.m_EnableRandomWrite.clone(),
            m_ForcedFallbackFormat: self.m_ForcedFallbackFormat.clone(),
            m_GenerateMips: self.m_GenerateMips.clone(),
            m_Height: self.m_Height.clone(),
            m_InitColor: self.m_InitColor.clone(),
            m_InitMaterial: self.m_InitMaterial.clone(),
            m_InitSource: self.m_InitSource.clone(),
            m_InitTexture: self.m_InitTexture.clone(),
            m_InitializationMode: self.m_InitializationMode.clone(),
            m_IsAlphaChannelOptional: self.m_IsAlphaChannelOptional.clone(),
            m_Material: self.m_Material.clone(),
            m_MipCount: self.m_MipCount.clone(),
            m_MipMap: self.m_MipMap.clone(),
            m_Name: self.m_Name.clone(),
            m_SRGB: self.m_SRGB.clone(),
            m_ShaderPass: self.m_ShaderPass.clone(),
            m_ShadowSamplingMode: self.m_ShadowSamplingMode.clone(),
            m_TextureSettings: self.m_TextureSettings.clone(),
            m_UpdateMode: self.m_UpdateMode.clone(),
            m_UpdatePeriod: self.m_UpdatePeriod.clone(),
            m_UpdateZoneSpace: self.m_UpdateZoneSpace.clone(),
            m_UpdateZones: self.m_UpdateZones.clone(),
            m_UseDynamicScale: self.m_UseDynamicScale.clone(),
            m_UseDynamicScaleExplicit: self.m_UseDynamicScaleExplicit.clone(),
            m_VolumeDepth: self.m_VolumeDepth.clone(),
            m_Width: self.m_Width.clone(),
            m_WrapUpdateZones: self.m_WrapUpdateZones.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SparseTexture {
    // extends Texture
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ColorSpace: Option<i32>,
    pub m_DownscaleFallback: Option<bool>,
    pub m_ForcedFallbackFormat: Option<i32>,
    pub m_Format: Option<i32>,
    pub m_Height: Option<i32>,
    pub m_IsAlphaChannelOptional: Option<bool>,
    pub m_MipCount: Option<i32>,
    pub m_Name: Option<String>,
    pub m_TextureSettings: Option<GLTextureSettings>,
    pub m_Width: Option<i32>,
}

impl_object!(SparseTexture);

impl Clone for SparseTexture {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ColorSpace: self.m_ColorSpace.clone(),
            m_DownscaleFallback: self.m_DownscaleFallback.clone(),
            m_ForcedFallbackFormat: self.m_ForcedFallbackFormat.clone(),
            m_Format: self.m_Format.clone(),
            m_Height: self.m_Height.clone(),
            m_IsAlphaChannelOptional: self.m_IsAlphaChannelOptional.clone(),
            m_MipCount: self.m_MipCount.clone(),
            m_Name: self.m_Name.clone(),
            m_TextureSettings: self.m_TextureSettings.clone(),
            m_Width: self.m_Width.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Texture2D {
    // extends Texture
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub image_data: Option<Vec<u8>>,
    pub m_ColorSpace: Option<i32>,
    pub m_CompleteImageSize: Option<i32>,
    pub m_DownscaleFallback: Option<bool>,
    pub m_ForcedFallbackFormat: Option<i32>,
    pub m_Height: Option<i32>,
    pub m_IgnoreMasterTextureLimit: Option<bool>,
    pub m_IgnoreMipmapLimit: Option<bool>,
    pub m_ImageCount: Option<i32>,
    pub m_IsAlphaChannelOptional: Option<bool>,
    pub m_IsPreProcessed: Option<bool>,
    pub m_IsReadable: Option<bool>,
    pub m_LightmapFormat: Option<i32>,
    pub m_MipCount: Option<i32>,
    pub m_MipMap: Option<bool>,
    pub m_MipmapLimitGroupName: Option<String>,
    pub m_MipsStripped: Option<i32>,
    pub m_Name: Option<String>,
    pub m_PlatformBlob: Option<Vec<u8>>,
    pub m_ReadAllowed: Option<bool>,
    pub m_StreamData: Option<StreamingInfo>,
    pub m_StreamingMipmaps: Option<bool>,
    pub m_StreamingMipmapsPriority: Option<i32>,
    pub m_TextureDimension: Option<i32>,
    pub m_TextureFormat: Option<i32>,
    pub m_TextureSettings: Option<GLTextureSettings>,
    pub m_Width: Option<i32>,
}

impl_object!(Texture2D);

impl Clone for Texture2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            image_data: self.image_data.clone(),
            m_ColorSpace: self.m_ColorSpace.clone(),
            m_CompleteImageSize: self.m_CompleteImageSize.clone(),
            m_DownscaleFallback: self.m_DownscaleFallback.clone(),
            m_ForcedFallbackFormat: self.m_ForcedFallbackFormat.clone(),
            m_Height: self.m_Height.clone(),
            m_IgnoreMasterTextureLimit: self.m_IgnoreMasterTextureLimit.clone(),
            m_IgnoreMipmapLimit: self.m_IgnoreMipmapLimit.clone(),
            m_ImageCount: self.m_ImageCount.clone(),
            m_IsAlphaChannelOptional: self.m_IsAlphaChannelOptional.clone(),
            m_IsPreProcessed: self.m_IsPreProcessed.clone(),
            m_IsReadable: self.m_IsReadable.clone(),
            m_LightmapFormat: self.m_LightmapFormat.clone(),
            m_MipCount: self.m_MipCount.clone(),
            m_MipMap: self.m_MipMap.clone(),
            m_MipmapLimitGroupName: self.m_MipmapLimitGroupName.clone(),
            m_MipsStripped: self.m_MipsStripped.clone(),
            m_Name: self.m_Name.clone(),
            m_PlatformBlob: self.m_PlatformBlob.clone(),
            m_ReadAllowed: self.m_ReadAllowed.clone(),
            m_StreamData: self.m_StreamData.clone(),
            m_StreamingMipmaps: self.m_StreamingMipmaps.clone(),
            m_StreamingMipmapsPriority: self.m_StreamingMipmapsPriority.clone(),
            m_TextureDimension: self.m_TextureDimension.clone(),
            m_TextureFormat: self.m_TextureFormat.clone(),
            m_TextureSettings: self.m_TextureSettings.clone(),
            m_Width: self.m_Width.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Cubemap {
    // extends Texture2D
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub image_data: Option<Vec<u8>>,
    pub m_ColorSpace: Option<i32>,
    pub m_CompleteImageSize: Option<i32>,
    pub m_DownscaleFallback: Option<bool>,
    pub m_ForcedFallbackFormat: Option<i32>,
    pub m_Height: Option<i32>,
    pub m_IgnoreMasterTextureLimit: Option<bool>,
    pub m_IgnoreMipmapLimit: Option<bool>,
    pub m_ImageCount: Option<i32>,
    pub m_IsAlphaChannelOptional: Option<bool>,
    pub m_IsPreProcessed: Option<bool>,
    pub m_IsReadable: Option<bool>,
    pub m_LightmapFormat: Option<i32>,
    pub m_MipCount: Option<i32>,
    pub m_MipMap: Option<bool>,
    pub m_MipmapLimitGroupName: Option<String>,
    pub m_MipsStripped: Option<i32>,
    pub m_Name: Option<String>,
    pub m_PlatformBlob: Option<Vec<u8>>,
    pub m_ReadAllowed: Option<bool>,
    pub m_SourceTextures: Option<Vec<PPtrData<Texture2D>>>,
    pub m_StreamData: Option<StreamingInfo>,
    pub m_StreamingMipmaps: Option<bool>,
    pub m_StreamingMipmapsPriority: Option<i32>,
    pub m_TextureDimension: Option<i32>,
    pub m_TextureFormat: Option<i32>,
    pub m_TextureSettings: Option<GLTextureSettings>,
    pub m_Width: Option<i32>,
}

impl_object!(Cubemap);

impl Clone for Cubemap {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            image_data: self.image_data.clone(),
            m_ColorSpace: self.m_ColorSpace.clone(),
            m_CompleteImageSize: self.m_CompleteImageSize.clone(),
            m_DownscaleFallback: self.m_DownscaleFallback.clone(),
            m_ForcedFallbackFormat: self.m_ForcedFallbackFormat.clone(),
            m_Height: self.m_Height.clone(),
            m_IgnoreMasterTextureLimit: self.m_IgnoreMasterTextureLimit.clone(),
            m_IgnoreMipmapLimit: self.m_IgnoreMipmapLimit.clone(),
            m_ImageCount: self.m_ImageCount.clone(),
            m_IsAlphaChannelOptional: self.m_IsAlphaChannelOptional.clone(),
            m_IsPreProcessed: self.m_IsPreProcessed.clone(),
            m_IsReadable: self.m_IsReadable.clone(),
            m_LightmapFormat: self.m_LightmapFormat.clone(),
            m_MipCount: self.m_MipCount.clone(),
            m_MipMap: self.m_MipMap.clone(),
            m_MipmapLimitGroupName: self.m_MipmapLimitGroupName.clone(),
            m_MipsStripped: self.m_MipsStripped.clone(),
            m_Name: self.m_Name.clone(),
            m_PlatformBlob: self.m_PlatformBlob.clone(),
            m_ReadAllowed: self.m_ReadAllowed.clone(),
            m_SourceTextures: self.m_SourceTextures.clone(),
            m_StreamData: self.m_StreamData.clone(),
            m_StreamingMipmaps: self.m_StreamingMipmaps.clone(),
            m_StreamingMipmapsPriority: self.m_StreamingMipmapsPriority.clone(),
            m_TextureDimension: self.m_TextureDimension.clone(),
            m_TextureFormat: self.m_TextureFormat.clone(),
            m_TextureSettings: self.m_TextureSettings.clone(),
            m_Width: self.m_Width.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Texture2DArray {
    // extends Texture
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub image_data: Option<Vec<u8>>,
    pub m_ColorSpace: Option<i32>,
    pub m_DataSize: Option<u32>,
    pub m_Depth: Option<i32>,
    pub m_DownscaleFallback: Option<bool>,
    pub m_ForcedFallbackFormat: Option<i32>,
    pub m_Format: Option<i32>,
    pub m_Height: Option<i32>,
    pub m_IgnoreMipmapLimit: Option<bool>,
    pub m_IsAlphaChannelOptional: Option<bool>,
    pub m_IsReadable: Option<bool>,
    pub m_MipCount: Option<i32>,
    pub m_MipmapLimitGroupName: Option<String>,
    pub m_MipsStripped: Option<i32>,
    pub m_Name: Option<String>,
    pub m_StreamData: Option<StreamingInfo>,
    pub m_TextureSettings: Option<GLTextureSettings>,
    pub m_UsageMode: Option<i32>,
    pub m_Width: Option<i32>,
}

impl_object!(Texture2DArray);

impl Clone for Texture2DArray {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            image_data: self.image_data.clone(),
            m_ColorSpace: self.m_ColorSpace.clone(),
            m_DataSize: self.m_DataSize.clone(),
            m_Depth: self.m_Depth.clone(),
            m_DownscaleFallback: self.m_DownscaleFallback.clone(),
            m_ForcedFallbackFormat: self.m_ForcedFallbackFormat.clone(),
            m_Format: self.m_Format.clone(),
            m_Height: self.m_Height.clone(),
            m_IgnoreMipmapLimit: self.m_IgnoreMipmapLimit.clone(),
            m_IsAlphaChannelOptional: self.m_IsAlphaChannelOptional.clone(),
            m_IsReadable: self.m_IsReadable.clone(),
            m_MipCount: self.m_MipCount.clone(),
            m_MipmapLimitGroupName: self.m_MipmapLimitGroupName.clone(),
            m_MipsStripped: self.m_MipsStripped.clone(),
            m_Name: self.m_Name.clone(),
            m_StreamData: self.m_StreamData.clone(),
            m_TextureSettings: self.m_TextureSettings.clone(),
            m_UsageMode: self.m_UsageMode.clone(),
            m_Width: self.m_Width.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Texture3D {
    // extends Texture
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub image_data: Option<Vec<u8>>,
    pub m_ColorSpace: Option<i32>,
    pub m_CompleteImageSize: Option<i32>,
    pub m_DataSize: Option<u32>,
    pub m_Depth: Option<i32>,
    pub m_DownscaleFallback: Option<bool>,
    pub m_ForcedFallbackFormat: Option<i32>,
    pub m_Format: Option<i32>,
    pub m_Height: Option<i32>,
    pub m_ImageCount: Option<i32>,
    pub m_IsAlphaChannelOptional: Option<bool>,
    pub m_IsReadable: Option<bool>,
    pub m_LightmapFormat: Option<i32>,
    pub m_MipCount: Option<i32>,
    pub m_MipMap: Option<bool>,
    pub m_Name: Option<String>,
    pub m_ReadAllowed: Option<bool>,
    pub m_StreamData: Option<StreamingInfo>,
    pub m_TextureDimension: Option<i32>,
    pub m_TextureFormat: Option<i32>,
    pub m_TextureSettings: Option<GLTextureSettings>,
    pub m_UsageMode: Option<i32>,
    pub m_Width: Option<i32>,
}

impl_object!(Texture3D);

impl Clone for Texture3D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            image_data: self.image_data.clone(),
            m_ColorSpace: self.m_ColorSpace.clone(),
            m_CompleteImageSize: self.m_CompleteImageSize.clone(),
            m_DataSize: self.m_DataSize.clone(),
            m_Depth: self.m_Depth.clone(),
            m_DownscaleFallback: self.m_DownscaleFallback.clone(),
            m_ForcedFallbackFormat: self.m_ForcedFallbackFormat.clone(),
            m_Format: self.m_Format.clone(),
            m_Height: self.m_Height.clone(),
            m_ImageCount: self.m_ImageCount.clone(),
            m_IsAlphaChannelOptional: self.m_IsAlphaChannelOptional.clone(),
            m_IsReadable: self.m_IsReadable.clone(),
            m_LightmapFormat: self.m_LightmapFormat.clone(),
            m_MipCount: self.m_MipCount.clone(),
            m_MipMap: self.m_MipMap.clone(),
            m_Name: self.m_Name.clone(),
            m_ReadAllowed: self.m_ReadAllowed.clone(),
            m_StreamData: self.m_StreamData.clone(),
            m_TextureDimension: self.m_TextureDimension.clone(),
            m_TextureFormat: self.m_TextureFormat.clone(),
            m_TextureSettings: self.m_TextureSettings.clone(),
            m_UsageMode: self.m_UsageMode.clone(),
            m_Width: self.m_Width.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VideoClip {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub Height: Option<u32>,
    pub Width: Option<u32>,
    pub m_AudioChannelCount: Option<Vec<u16>>,
    pub m_AudioLanguage: Option<Vec<String>>,
    pub m_AudioSampleRate: Option<Vec<u32>>,
    pub m_ExternalResources: Option<StreamedResource>,
    pub m_Format: Option<i32>,
    pub m_FrameCount: Option<u64>,
    pub m_FrameRate: Option<f64>,
    pub m_HasSplitAlpha: Option<bool>,
    pub m_Name: Option<String>,
    pub m_OriginalPath: Option<String>,
    pub m_PixelAspecRatioDen: Option<u32>,
    pub m_PixelAspecRatioNum: Option<u32>,
    pub m_ProxyHeight: Option<u32>,
    pub m_ProxyWidth: Option<u32>,
    pub m_VideoShaders: Option<Vec<PPtrData<Shader>>>,
    pub m_sRGB: Option<bool>,
}

impl_object!(VideoClip);

impl Clone for VideoClip {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            Height: self.Height.clone(),
            Width: self.Width.clone(),
            m_AudioChannelCount: self.m_AudioChannelCount.clone(),
            m_AudioLanguage: self.m_AudioLanguage.clone(),
            m_AudioSampleRate: self.m_AudioSampleRate.clone(),
            m_ExternalResources: self.m_ExternalResources.clone(),
            m_Format: self.m_Format.clone(),
            m_FrameCount: self.m_FrameCount.clone(),
            m_FrameRate: self.m_FrameRate.clone(),
            m_HasSplitAlpha: self.m_HasSplitAlpha.clone(),
            m_Name: self.m_Name.clone(),
            m_OriginalPath: self.m_OriginalPath.clone(),
            m_PixelAspecRatioDen: self.m_PixelAspecRatioDen.clone(),
            m_PixelAspecRatioNum: self.m_PixelAspecRatioNum.clone(),
            m_ProxyHeight: self.m_ProxyHeight.clone(),
            m_ProxyWidth: self.m_ProxyWidth.clone(),
            m_VideoShaders: self.m_VideoShaders.clone(),
            m_sRGB: self.m_sRGB.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VisualEffectObject {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(VisualEffectObject);

impl Clone for VisualEffectObject {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VisualEffectAsset {
    // extends VisualEffectObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Infos: Option<VisualEffectInfo>,
    pub m_Name: Option<String>,
    pub m_Systems: Option<Vec<VFXSystemDesc>>,
}

impl_object!(VisualEffectAsset);

impl Clone for VisualEffectAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Infos: self.m_Infos.clone(),
            m_Name: self.m_Name.clone(),
            m_Systems: self.m_Systems.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VisualEffectSubgraph {
    // extends VisualEffectObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(VisualEffectSubgraph);

impl Clone for VisualEffectSubgraph {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VisualEffectSubgraphBlock {
    // extends VisualEffectSubgraph
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
}

impl_object!(VisualEffectSubgraphBlock);

impl Clone for VisualEffectSubgraphBlock {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VisualEffectSubgraphOperator {
    // extends VisualEffectSubgraph
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
}

impl_object!(VisualEffectSubgraphOperator);

impl Clone for VisualEffectSubgraphOperator {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VisualEffectResource {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Graph: Option<PPtrData<MonoBehaviour>>,
    pub m_Infos: Option<VisualEffectInfo>,
    pub m_Name: Option<String>,
    pub m_ShaderSources: Option<Vec<VFXShaderSourceDesc>>,
    pub m_Systems: Option<Vec<VFXEditorSystemDesc>>,
}

impl_object!(VisualEffectResource);

impl Clone for VisualEffectResource {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Graph: self.m_Graph.clone(),
            m_Infos: self.m_Infos.clone(),
            m_Name: self.m_Name.clone(),
            m_ShaderSources: self.m_ShaderSources.clone(),
            m_Systems: self.m_Systems.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EditorExtensionImpl {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub gFlattenedTypeTree: Option<Vec<u8>>,
    pub m_DataTemplate: Option<PPtrData<DataTemplate>>,
    pub m_Object: Option<PPtrData<EditorExtension>>,
    pub m_OverrideVariable: Option<bitset>,
    pub m_TemplateFather: Option<PPtrData<EditorExtensionImpl>>,
}

impl_object!(EditorExtensionImpl);

impl Clone for EditorExtensionImpl {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            gFlattenedTypeTree: self.gFlattenedTypeTree.clone(),
            m_DataTemplate: self.m_DataTemplate.clone(),
            m_Object: self.m_Object.clone(),
            m_OverrideVariable: self.m_OverrideVariable.clone(),
            m_TemplateFather: self.m_TemplateFather.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EditorSettings {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetNamingUsesSpace: Option<bool>,
    pub m_AssetPipelineMode: Option<i32>,
    pub m_AsyncShaderCompilation: Option<bool>,
    pub m_Bc7TextureCompressor: Option<i32>,
    pub m_CacheServerDownloadBatchSize: Option<i32>,
    pub m_CacheServerEnableAuth: Option<bool>,
    pub m_CacheServerEnableDownload: Option<bool>,
    pub m_CacheServerEnableTls: Option<bool>,
    pub m_CacheServerEnableUpload: Option<bool>,
    pub m_CacheServerEndpoint: Option<String>,
    pub m_CacheServerMode: Option<i32>,
    pub m_CacheServerNamespacePrefix: Option<String>,
    pub m_CacheServerValidationMode: Option<i32>,
    pub m_CachingShaderPreprocessor: Option<bool>,
    pub m_CollabEditorSettings: Option<CollabEditorSettings>,
    pub m_DefaultBehaviorMode: Option<i32>,
    pub m_DisableCookiesInLightmapper: Option<bool>,
    pub m_EnableEditorAsyncCPUTextureLoading: Option<bool>,
    pub m_EnableEnlightenBakedGI: Option<bool>,
    pub m_EnableRoslynAnalyzers: Option<bool>,
    pub m_EnableTextureStreamingInEditMode: Option<bool>,
    pub m_EnableTextureStreamingInPlayMode: Option<bool>,
    pub m_EnterPlayModeOptions: Option<i32>,
    pub m_EnterPlayModeOptionsEnabled: Option<bool>,
    pub m_EtcTextureBestCompressor: Option<i32>,
    pub m_EtcTextureCompressorBehavior: Option<i32>,
    pub m_EtcTextureFastCompressor: Option<i32>,
    pub m_EtcTextureNormalCompressor: Option<i32>,
    pub m_ExternalVersionControlSupport: Option<String>,
    pub m_GameObjectNamingDigits: Option<i32>,
    pub m_GameObjectNamingScheme: Option<i32>,
    pub m_InspectorUseIMGUIDefaultInspector: Option<bool>,
    pub m_LineEndingsForNewScripts: Option<i32>,
    pub m_PrefabModeAllowAutoSave: Option<bool>,
    pub m_PrefabRegularEnvironment: Option<PPtrData<SceneAsset>>,
    pub m_PrefabUIEnvironment: Option<PPtrData<SceneAsset>>,
    pub m_ProjectGenerationIncludedExtensions: Option<String>,
    pub m_ProjectGenerationRootNamespace: Option<String>,
    pub m_RecalculateEnvironmentLighting: Option<bool>,
    pub m_ReferencedClipsExactNaming: Option<bool>,
    pub m_RefreshImportMode: Option<i32>,
    pub m_SerializationMode: Option<i32>,
    pub m_SerializeInlineMappingsOnOneLine: Option<bool>,
    pub m_ShowLightmapResolutionOverlay: Option<bool>,
    pub m_SpritePackerCacheSize: Option<i32>,
    pub m_SpritePackerMode: Option<i32>,
    pub m_SpritePackerPaddingPower: Option<i32>,
    pub m_UseLegacyProbeSampleCount: Option<bool>,
    pub m_UserGeneratedProjectSuffix: Option<String>,
    pub m_WebSecurityEmulationEnabled: Option<i32>,
    pub m_WebSecurityEmulationHostUrl: Option<String>,
}

impl_object!(EditorSettings);

impl Clone for EditorSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetNamingUsesSpace: self.m_AssetNamingUsesSpace.clone(),
            m_AssetPipelineMode: self.m_AssetPipelineMode.clone(),
            m_AsyncShaderCompilation: self.m_AsyncShaderCompilation.clone(),
            m_Bc7TextureCompressor: self.m_Bc7TextureCompressor.clone(),
            m_CacheServerDownloadBatchSize: self.m_CacheServerDownloadBatchSize.clone(),
            m_CacheServerEnableAuth: self.m_CacheServerEnableAuth.clone(),
            m_CacheServerEnableDownload: self.m_CacheServerEnableDownload.clone(),
            m_CacheServerEnableTls: self.m_CacheServerEnableTls.clone(),
            m_CacheServerEnableUpload: self.m_CacheServerEnableUpload.clone(),
            m_CacheServerEndpoint: self.m_CacheServerEndpoint.clone(),
            m_CacheServerMode: self.m_CacheServerMode.clone(),
            m_CacheServerNamespacePrefix: self.m_CacheServerNamespacePrefix.clone(),
            m_CacheServerValidationMode: self.m_CacheServerValidationMode.clone(),
            m_CachingShaderPreprocessor: self.m_CachingShaderPreprocessor.clone(),
            m_CollabEditorSettings: self.m_CollabEditorSettings.clone(),
            m_DefaultBehaviorMode: self.m_DefaultBehaviorMode.clone(),
            m_DisableCookiesInLightmapper: self.m_DisableCookiesInLightmapper.clone(),
            m_EnableEditorAsyncCPUTextureLoading: self.m_EnableEditorAsyncCPUTextureLoading.clone(),
            m_EnableEnlightenBakedGI: self.m_EnableEnlightenBakedGI.clone(),
            m_EnableRoslynAnalyzers: self.m_EnableRoslynAnalyzers.clone(),
            m_EnableTextureStreamingInEditMode: self.m_EnableTextureStreamingInEditMode.clone(),
            m_EnableTextureStreamingInPlayMode: self.m_EnableTextureStreamingInPlayMode.clone(),
            m_EnterPlayModeOptions: self.m_EnterPlayModeOptions.clone(),
            m_EnterPlayModeOptionsEnabled: self.m_EnterPlayModeOptionsEnabled.clone(),
            m_EtcTextureBestCompressor: self.m_EtcTextureBestCompressor.clone(),
            m_EtcTextureCompressorBehavior: self.m_EtcTextureCompressorBehavior.clone(),
            m_EtcTextureFastCompressor: self.m_EtcTextureFastCompressor.clone(),
            m_EtcTextureNormalCompressor: self.m_EtcTextureNormalCompressor.clone(),
            m_ExternalVersionControlSupport: self.m_ExternalVersionControlSupport.clone(),
            m_GameObjectNamingDigits: self.m_GameObjectNamingDigits.clone(),
            m_GameObjectNamingScheme: self.m_GameObjectNamingScheme.clone(),
            m_InspectorUseIMGUIDefaultInspector: self.m_InspectorUseIMGUIDefaultInspector.clone(),
            m_LineEndingsForNewScripts: self.m_LineEndingsForNewScripts.clone(),
            m_PrefabModeAllowAutoSave: self.m_PrefabModeAllowAutoSave.clone(),
            m_PrefabRegularEnvironment: self.m_PrefabRegularEnvironment.clone(),
            m_PrefabUIEnvironment: self.m_PrefabUIEnvironment.clone(),
            m_ProjectGenerationIncludedExtensions: self
                .m_ProjectGenerationIncludedExtensions
                .clone(),
            m_ProjectGenerationRootNamespace: self.m_ProjectGenerationRootNamespace.clone(),
            m_RecalculateEnvironmentLighting: self.m_RecalculateEnvironmentLighting.clone(),
            m_ReferencedClipsExactNaming: self.m_ReferencedClipsExactNaming.clone(),
            m_RefreshImportMode: self.m_RefreshImportMode.clone(),
            m_SerializationMode: self.m_SerializationMode.clone(),
            m_SerializeInlineMappingsOnOneLine: self.m_SerializeInlineMappingsOnOneLine.clone(),
            m_ShowLightmapResolutionOverlay: self.m_ShowLightmapResolutionOverlay.clone(),
            m_SpritePackerCacheSize: self.m_SpritePackerCacheSize.clone(),
            m_SpritePackerMode: self.m_SpritePackerMode.clone(),
            m_SpritePackerPaddingPower: self.m_SpritePackerPaddingPower.clone(),
            m_UseLegacyProbeSampleCount: self.m_UseLegacyProbeSampleCount.clone(),
            m_UserGeneratedProjectSuffix: self.m_UserGeneratedProjectSuffix.clone(),
            m_WebSecurityEmulationEnabled: self.m_WebSecurityEmulationEnabled.clone(),
            m_WebSecurityEmulationHostUrl: self.m_WebSecurityEmulationHostUrl.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EditorUserBuildSettings {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ActiveBuildPlatformGroupName: Option<String>,
    pub m_ActiveBuildTarget: Option<i32>,
    pub m_ActiveBuildTargetGroup: Option<i32>,
    pub m_ActivePlatformGuid: Option<GUID>,
    pub m_ActiveProfilePath: Option<String>,
    pub m_ActiveStandaloneBuildSubtarget: Option<i32>,
    pub m_AllowDebugging: Option<bool>,
    pub m_AndroidBuildSystem: Option<i32>,
    pub m_AndroidBuildType: Option<i32>,
    pub m_AndroidCreateSymbols: Option<i32>,
    pub m_AndroidCreateSymbolsZip: Option<bool>,
    pub m_AndroidCurrentDeploymentTargetId: Option<String>,
    pub m_AndroidDebugMinification: Option<i32>,
    pub m_AndroidDeviceSocketAddress: Option<String>,
    pub m_AndroidReleaseMinification: Option<i32>,
    pub m_AndroidUseLegacySdkTools: Option<bool>,
    pub m_ArchitectureFlags: Option<i32>,
    pub m_BuildAppBundle: Option<bool>,
    pub m_BuildLocation: Option<Vec<String>>,
    pub m_BuildScriptsOnly: Option<bool>,
    pub m_BuildWithDeepProfilingSupport: Option<bool>,
    pub m_CompressFilesInPackage: Option<bool>,
    pub m_CompressWithPsArc: Option<bool>,
    pub m_ConnectProfiler: Option<bool>,
    pub m_CreateRomFileForSwitch: Option<bool>,
    pub m_CreateSolutionFileForSwitch: Option<bool>,
    pub m_DatalessPlayer: Option<bool>,
    pub m_Development: Option<bool>,
    pub m_EnableDebugPadForSwitch: Option<bool>,
    pub m_EnableHeadlessMode: Option<bool>,
    pub m_EnableHeapInspectorForSwitch: Option<bool>,
    pub m_EnableHostIOForSwitch: Option<bool>,
    pub m_EnableMemoryTrackerForSwitch: Option<bool>,
    pub m_EnableRomCompressionForSwitch: Option<bool>,
    pub m_ExplicitArrayBoundsChecks: Option<bool>,
    pub m_ExplicitDivideByZeroChecks: Option<bool>,
    pub m_ExplicitNullChecks: Option<bool>,
    pub m_ExportAsGoogleAndroidProject: Option<bool>,
    pub m_FacebookAccessToken: Option<String>,
    pub m_FacebookCreatePackageForSubmission: Option<bool>,
    pub m_ForceInstallation: Option<bool>,
    pub m_ForceOptimizeScriptCompilation: Option<bool>,
    pub m_GenerateMetroReferenceProjects: Option<bool>,
    pub m_GenerateNintendoSwitchShaderInfo: Option<bool>,
    pub m_GenerateWSAReferenceProjects: Option<bool>,
    pub m_HTCSScriptDebuggingForSwitch: Option<bool>,
    pub m_Il2CppCodeGeneration: Option<i32>,
    pub m_InstallInBuildFolder: Option<bool>,
    pub m_MovePackageToDiscOuterEdge: Option<bool>,
    pub m_NVNAftermath: Option<bool>,
    pub m_NVNDrawValidation: Option<bool>,
    pub m_NVNDrawValidationHeavy: Option<bool>,
    pub m_NVNDrawValidationLight: Option<bool>,
    pub m_NVNGraphicsDebuggerForSwitch: Option<bool>,
    pub m_NVNShaderDebugging: Option<bool>,
    pub m_NeedSubmissionMaterials: Option<bool>,
    pub m_OverrideMaxTextureSize: Option<i32>,
    pub m_OverrideTextureCompression: Option<i32>,
    pub m_PS4HardwareTarget: Option<i32>,
    pub m_PS5KeepPackageFiles: Option<bool>,
    pub m_PS5WorkspaceName: Option<String>,
    pub m_PathOnRemoteDevice: Option<String>,
    pub m_PlatformSettings: Option<Vec<(String, PlatformSettingsData)>>,
    pub m_RedirectWritesToHostMountForSwitch: Option<bool>,
    pub m_RemoteDeviceAddress: Option<String>,
    pub m_RemoteDeviceExports: Option<String>,
    pub m_RemoteDeviceInfo: Option<bool>,
    pub m_RemoteDeviceUsername: Option<String>,
    pub m_RomCompressionConfigForSwitch: Option<String>,
    pub m_RomCompressionLevelForSwitch: Option<i32>,
    pub m_RomCompressionTypeForSwitch: Option<i32>,
    pub m_SaveADFForSwitch: Option<bool>,
    pub m_SelectedAndroidETC2Fallback: Option<i32>,
    pub m_SelectedAndroidSubtarget: Option<i32>,
    pub m_SelectedBlackBerryBuildType: Option<i32>,
    pub m_SelectedBlackBerrySubtarget: Option<i32>,
    pub m_SelectedBuildPlatformGroupName: Option<String>,
    pub m_SelectedBuildTarget: Option<i32>,
    pub m_SelectedBuildTargetGroup: Option<i32>,
    pub m_SelectedCompressionType: Option<Vec<(String, i32)>>,
    pub m_SelectedEmbeddedLinuxArchitecture: Option<i32>,
    pub m_SelectedFacebookTarget: Option<i32>,
    pub m_SelectedIOSBuildType: Option<i32>,
    pub m_SelectedMetroBuildAndRunDeployTarget: Option<i32>,
    pub m_SelectedMetroBuildType: Option<i32>,
    pub m_SelectedMetroSDK: Option<i32>,
    pub m_SelectedMetroTarget: Option<i32>,
    pub m_SelectedPS3Subtarget: Option<i32>,
    pub m_SelectedPS4Subtarget: Option<i32>,
    pub m_SelectedPS5CompressionLevel: Option<i32>,
    pub m_SelectedPS5CompressionType: Option<i32>,
    pub m_SelectedPS5Subtarget: Option<i32>,
    pub m_SelectedPSMSubtarget: Option<i32>,
    pub m_SelectedPSP2Subtarget: Option<i32>,
    pub m_SelectedQNXArchitecture: Option<i32>,
    pub m_SelectedQNXOsVersion: Option<i32>,
    pub m_SelectedStandaloneBuildSubtarget: Option<i32>,
    pub m_SelectedStandaloneTarget: Option<i32>,
    pub m_SelectedTizenSubtarget: Option<i32>,
    pub m_SelectedWSAArchitecture: Option<String>,
    pub m_SelectedWSABuildAndRunDeployTarget: Option<i32>,
    pub m_SelectedWSAMinUWPSDK: Option<String>,
    pub m_SelectedWSASDK: Option<i32>,
    pub m_SelectedWSASubtarget: Option<i32>,
    pub m_SelectedWSAUWPBuildType: Option<i32>,
    pub m_SelectedWSAUWPSDK: Option<String>,
    pub m_SelectedWSAUWPVSVersion: Option<String>,
    pub m_SelectedWebGLSubtarget: Option<i32>,
    pub m_SelectedWiiDebugLevel: Option<i32>,
    pub m_SelectedWiiSubtarget: Option<i32>,
    pub m_SelectedWiiUBootMode: Option<i32>,
    pub m_SelectedWiiUBuildOutput: Option<i32>,
    pub m_SelectedWiiUDebugLevel: Option<i32>,
    pub m_SelectedWindowsBuildAndRunDeployTarget: Option<i32>,
    pub m_SelectedXboxOneDeployDrive: Option<i32>,
    pub m_SelectedXboxOneDeployMethod: Option<i32>,
    pub m_SelectedXboxRunMethod: Option<i32>,
    pub m_SelectedXboxSubtarget: Option<i32>,
    pub m_SymlinkLibraries: Option<bool>,
    pub m_SymlinkSources: Option<bool>,
    pub m_SymlinkTrampoline: Option<bool>,
    pub m_UseLegacyNvnPoolAllocatorForSwitch: Option<bool>,
    pub m_WSADotNetNativeEnabled: Option<Vec<bool>>,
    pub m_WaitForPlayerConnection: Option<bool>,
    pub m_WaitForSwitchMemoryTrackerOnStartup: Option<bool>,
    pub m_WebGLClientBrowserPath: Option<String>,
    pub m_WebGLClientBrowserType: Option<i32>,
    pub m_WebGLClientPlatform: Option<i32>,
    pub m_WebGLOptimizationLevel: Option<i32>,
    pub m_WebGLUsePreBuiltUnityEngine: Option<bool>,
    pub m_WebPlayerDeployOnline: Option<bool>,
    pub m_WebPlayerNaClSupport: Option<bool>,
    pub m_WebPlayerOfflineDeployment: Option<bool>,
    pub m_WebPlayerStreamed: Option<bool>,
    pub m_WiiUEnableNetAPI: Option<bool>,
    pub m_WindowsDevicePortalAddress: Option<String>,
    pub m_WindowsDevicePortalUsername: Option<String>,
    pub m_WsaHolographicRemoting: Option<bool>,
    pub m_XboxCompressedXex: Option<bool>,
    pub m_XboxOneNetworkSharePath: Option<String>,
    pub m_XboxOneStreamingInstallLaunchChunkRange: Option<i32>,
    pub m_XboxOneUsername: Option<String>,
    pub m_macosXcodeBuildConfig: Option<i32>,
}

impl_object!(EditorUserBuildSettings);

impl Clone for EditorUserBuildSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ActiveBuildPlatformGroupName: self.m_ActiveBuildPlatformGroupName.clone(),
            m_ActiveBuildTarget: self.m_ActiveBuildTarget.clone(),
            m_ActiveBuildTargetGroup: self.m_ActiveBuildTargetGroup.clone(),
            m_ActivePlatformGuid: self.m_ActivePlatformGuid.clone(),
            m_ActiveProfilePath: self.m_ActiveProfilePath.clone(),
            m_ActiveStandaloneBuildSubtarget: self.m_ActiveStandaloneBuildSubtarget.clone(),
            m_AllowDebugging: self.m_AllowDebugging.clone(),
            m_AndroidBuildSystem: self.m_AndroidBuildSystem.clone(),
            m_AndroidBuildType: self.m_AndroidBuildType.clone(),
            m_AndroidCreateSymbols: self.m_AndroidCreateSymbols.clone(),
            m_AndroidCreateSymbolsZip: self.m_AndroidCreateSymbolsZip.clone(),
            m_AndroidCurrentDeploymentTargetId: self.m_AndroidCurrentDeploymentTargetId.clone(),
            m_AndroidDebugMinification: self.m_AndroidDebugMinification.clone(),
            m_AndroidDeviceSocketAddress: self.m_AndroidDeviceSocketAddress.clone(),
            m_AndroidReleaseMinification: self.m_AndroidReleaseMinification.clone(),
            m_AndroidUseLegacySdkTools: self.m_AndroidUseLegacySdkTools.clone(),
            m_ArchitectureFlags: self.m_ArchitectureFlags.clone(),
            m_BuildAppBundle: self.m_BuildAppBundle.clone(),
            m_BuildLocation: self.m_BuildLocation.clone(),
            m_BuildScriptsOnly: self.m_BuildScriptsOnly.clone(),
            m_BuildWithDeepProfilingSupport: self.m_BuildWithDeepProfilingSupport.clone(),
            m_CompressFilesInPackage: self.m_CompressFilesInPackage.clone(),
            m_CompressWithPsArc: self.m_CompressWithPsArc.clone(),
            m_ConnectProfiler: self.m_ConnectProfiler.clone(),
            m_CreateRomFileForSwitch: self.m_CreateRomFileForSwitch.clone(),
            m_CreateSolutionFileForSwitch: self.m_CreateSolutionFileForSwitch.clone(),
            m_DatalessPlayer: self.m_DatalessPlayer.clone(),
            m_Development: self.m_Development.clone(),
            m_EnableDebugPadForSwitch: self.m_EnableDebugPadForSwitch.clone(),
            m_EnableHeadlessMode: self.m_EnableHeadlessMode.clone(),
            m_EnableHeapInspectorForSwitch: self.m_EnableHeapInspectorForSwitch.clone(),
            m_EnableHostIOForSwitch: self.m_EnableHostIOForSwitch.clone(),
            m_EnableMemoryTrackerForSwitch: self.m_EnableMemoryTrackerForSwitch.clone(),
            m_EnableRomCompressionForSwitch: self.m_EnableRomCompressionForSwitch.clone(),
            m_ExplicitArrayBoundsChecks: self.m_ExplicitArrayBoundsChecks.clone(),
            m_ExplicitDivideByZeroChecks: self.m_ExplicitDivideByZeroChecks.clone(),
            m_ExplicitNullChecks: self.m_ExplicitNullChecks.clone(),
            m_ExportAsGoogleAndroidProject: self.m_ExportAsGoogleAndroidProject.clone(),
            m_FacebookAccessToken: self.m_FacebookAccessToken.clone(),
            m_FacebookCreatePackageForSubmission: self.m_FacebookCreatePackageForSubmission.clone(),
            m_ForceInstallation: self.m_ForceInstallation.clone(),
            m_ForceOptimizeScriptCompilation: self.m_ForceOptimizeScriptCompilation.clone(),
            m_GenerateMetroReferenceProjects: self.m_GenerateMetroReferenceProjects.clone(),
            m_GenerateNintendoSwitchShaderInfo: self.m_GenerateNintendoSwitchShaderInfo.clone(),
            m_GenerateWSAReferenceProjects: self.m_GenerateWSAReferenceProjects.clone(),
            m_HTCSScriptDebuggingForSwitch: self.m_HTCSScriptDebuggingForSwitch.clone(),
            m_Il2CppCodeGeneration: self.m_Il2CppCodeGeneration.clone(),
            m_InstallInBuildFolder: self.m_InstallInBuildFolder.clone(),
            m_MovePackageToDiscOuterEdge: self.m_MovePackageToDiscOuterEdge.clone(),
            m_NVNAftermath: self.m_NVNAftermath.clone(),
            m_NVNDrawValidation: self.m_NVNDrawValidation.clone(),
            m_NVNDrawValidationHeavy: self.m_NVNDrawValidationHeavy.clone(),
            m_NVNDrawValidationLight: self.m_NVNDrawValidationLight.clone(),
            m_NVNGraphicsDebuggerForSwitch: self.m_NVNGraphicsDebuggerForSwitch.clone(),
            m_NVNShaderDebugging: self.m_NVNShaderDebugging.clone(),
            m_NeedSubmissionMaterials: self.m_NeedSubmissionMaterials.clone(),
            m_OverrideMaxTextureSize: self.m_OverrideMaxTextureSize.clone(),
            m_OverrideTextureCompression: self.m_OverrideTextureCompression.clone(),
            m_PS4HardwareTarget: self.m_PS4HardwareTarget.clone(),
            m_PS5KeepPackageFiles: self.m_PS5KeepPackageFiles.clone(),
            m_PS5WorkspaceName: self.m_PS5WorkspaceName.clone(),
            m_PathOnRemoteDevice: self.m_PathOnRemoteDevice.clone(),
            m_PlatformSettings: self.m_PlatformSettings.clone(),
            m_RedirectWritesToHostMountForSwitch: self.m_RedirectWritesToHostMountForSwitch.clone(),
            m_RemoteDeviceAddress: self.m_RemoteDeviceAddress.clone(),
            m_RemoteDeviceExports: self.m_RemoteDeviceExports.clone(),
            m_RemoteDeviceInfo: self.m_RemoteDeviceInfo.clone(),
            m_RemoteDeviceUsername: self.m_RemoteDeviceUsername.clone(),
            m_RomCompressionConfigForSwitch: self.m_RomCompressionConfigForSwitch.clone(),
            m_RomCompressionLevelForSwitch: self.m_RomCompressionLevelForSwitch.clone(),
            m_RomCompressionTypeForSwitch: self.m_RomCompressionTypeForSwitch.clone(),
            m_SaveADFForSwitch: self.m_SaveADFForSwitch.clone(),
            m_SelectedAndroidETC2Fallback: self.m_SelectedAndroidETC2Fallback.clone(),
            m_SelectedAndroidSubtarget: self.m_SelectedAndroidSubtarget.clone(),
            m_SelectedBlackBerryBuildType: self.m_SelectedBlackBerryBuildType.clone(),
            m_SelectedBlackBerrySubtarget: self.m_SelectedBlackBerrySubtarget.clone(),
            m_SelectedBuildPlatformGroupName: self.m_SelectedBuildPlatformGroupName.clone(),
            m_SelectedBuildTarget: self.m_SelectedBuildTarget.clone(),
            m_SelectedBuildTargetGroup: self.m_SelectedBuildTargetGroup.clone(),
            m_SelectedCompressionType: self.m_SelectedCompressionType.clone(),
            m_SelectedEmbeddedLinuxArchitecture: self.m_SelectedEmbeddedLinuxArchitecture.clone(),
            m_SelectedFacebookTarget: self.m_SelectedFacebookTarget.clone(),
            m_SelectedIOSBuildType: self.m_SelectedIOSBuildType.clone(),
            m_SelectedMetroBuildAndRunDeployTarget: self
                .m_SelectedMetroBuildAndRunDeployTarget
                .clone(),
            m_SelectedMetroBuildType: self.m_SelectedMetroBuildType.clone(),
            m_SelectedMetroSDK: self.m_SelectedMetroSDK.clone(),
            m_SelectedMetroTarget: self.m_SelectedMetroTarget.clone(),
            m_SelectedPS3Subtarget: self.m_SelectedPS3Subtarget.clone(),
            m_SelectedPS4Subtarget: self.m_SelectedPS4Subtarget.clone(),
            m_SelectedPS5CompressionLevel: self.m_SelectedPS5CompressionLevel.clone(),
            m_SelectedPS5CompressionType: self.m_SelectedPS5CompressionType.clone(),
            m_SelectedPS5Subtarget: self.m_SelectedPS5Subtarget.clone(),
            m_SelectedPSMSubtarget: self.m_SelectedPSMSubtarget.clone(),
            m_SelectedPSP2Subtarget: self.m_SelectedPSP2Subtarget.clone(),
            m_SelectedQNXArchitecture: self.m_SelectedQNXArchitecture.clone(),
            m_SelectedQNXOsVersion: self.m_SelectedQNXOsVersion.clone(),
            m_SelectedStandaloneBuildSubtarget: self.m_SelectedStandaloneBuildSubtarget.clone(),
            m_SelectedStandaloneTarget: self.m_SelectedStandaloneTarget.clone(),
            m_SelectedTizenSubtarget: self.m_SelectedTizenSubtarget.clone(),
            m_SelectedWSAArchitecture: self.m_SelectedWSAArchitecture.clone(),
            m_SelectedWSABuildAndRunDeployTarget: self.m_SelectedWSABuildAndRunDeployTarget.clone(),
            m_SelectedWSAMinUWPSDK: self.m_SelectedWSAMinUWPSDK.clone(),
            m_SelectedWSASDK: self.m_SelectedWSASDK.clone(),
            m_SelectedWSASubtarget: self.m_SelectedWSASubtarget.clone(),
            m_SelectedWSAUWPBuildType: self.m_SelectedWSAUWPBuildType.clone(),
            m_SelectedWSAUWPSDK: self.m_SelectedWSAUWPSDK.clone(),
            m_SelectedWSAUWPVSVersion: self.m_SelectedWSAUWPVSVersion.clone(),
            m_SelectedWebGLSubtarget: self.m_SelectedWebGLSubtarget.clone(),
            m_SelectedWiiDebugLevel: self.m_SelectedWiiDebugLevel.clone(),
            m_SelectedWiiSubtarget: self.m_SelectedWiiSubtarget.clone(),
            m_SelectedWiiUBootMode: self.m_SelectedWiiUBootMode.clone(),
            m_SelectedWiiUBuildOutput: self.m_SelectedWiiUBuildOutput.clone(),
            m_SelectedWiiUDebugLevel: self.m_SelectedWiiUDebugLevel.clone(),
            m_SelectedWindowsBuildAndRunDeployTarget: self
                .m_SelectedWindowsBuildAndRunDeployTarget
                .clone(),
            m_SelectedXboxOneDeployDrive: self.m_SelectedXboxOneDeployDrive.clone(),
            m_SelectedXboxOneDeployMethod: self.m_SelectedXboxOneDeployMethod.clone(),
            m_SelectedXboxRunMethod: self.m_SelectedXboxRunMethod.clone(),
            m_SelectedXboxSubtarget: self.m_SelectedXboxSubtarget.clone(),
            m_SymlinkLibraries: self.m_SymlinkLibraries.clone(),
            m_SymlinkSources: self.m_SymlinkSources.clone(),
            m_SymlinkTrampoline: self.m_SymlinkTrampoline.clone(),
            m_UseLegacyNvnPoolAllocatorForSwitch: self.m_UseLegacyNvnPoolAllocatorForSwitch.clone(),
            m_WSADotNetNativeEnabled: self.m_WSADotNetNativeEnabled.clone(),
            m_WaitForPlayerConnection: self.m_WaitForPlayerConnection.clone(),
            m_WaitForSwitchMemoryTrackerOnStartup: self
                .m_WaitForSwitchMemoryTrackerOnStartup
                .clone(),
            m_WebGLClientBrowserPath: self.m_WebGLClientBrowserPath.clone(),
            m_WebGLClientBrowserType: self.m_WebGLClientBrowserType.clone(),
            m_WebGLClientPlatform: self.m_WebGLClientPlatform.clone(),
            m_WebGLOptimizationLevel: self.m_WebGLOptimizationLevel.clone(),
            m_WebGLUsePreBuiltUnityEngine: self.m_WebGLUsePreBuiltUnityEngine.clone(),
            m_WebPlayerDeployOnline: self.m_WebPlayerDeployOnline.clone(),
            m_WebPlayerNaClSupport: self.m_WebPlayerNaClSupport.clone(),
            m_WebPlayerOfflineDeployment: self.m_WebPlayerOfflineDeployment.clone(),
            m_WebPlayerStreamed: self.m_WebPlayerStreamed.clone(),
            m_WiiUEnableNetAPI: self.m_WiiUEnableNetAPI.clone(),
            m_WindowsDevicePortalAddress: self.m_WindowsDevicePortalAddress.clone(),
            m_WindowsDevicePortalUsername: self.m_WindowsDevicePortalUsername.clone(),
            m_WsaHolographicRemoting: self.m_WsaHolographicRemoting.clone(),
            m_XboxCompressedXex: self.m_XboxCompressedXex.clone(),
            m_XboxOneNetworkSharePath: self.m_XboxOneNetworkSharePath.clone(),
            m_XboxOneStreamingInstallLaunchChunkRange: self
                .m_XboxOneStreamingInstallLaunchChunkRange
                .clone(),
            m_XboxOneUsername: self.m_XboxOneUsername.clone(),
            m_macosXcodeBuildConfig: self.m_macosXcodeBuildConfig.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EditorUserSettings {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ArtifactGarbageCollection: Option<bool>,
    pub m_AssetPipelineMode: Option<i32>,
    pub m_AssetPipelineMode2: Option<i32>,
    pub m_CacheServerMode: Option<i32>,
    pub m_CacheServers: Option<Vec<String>>,
    pub m_CompressAssetsOnImport: Option<bool>,
    pub m_ConfigSettings: Option<Vec<(String, ConfigSetting)>>,
    pub m_ConfigValues: Option<Vec<(String, String)>>,
    pub m_DesiredImportWorkerCount: Option<i32>,
    pub m_IdleImportWorkerShutdownDelay: Option<i32>,
    pub m_SemanticMergeMode: Option<i32>,
    pub m_StandbyImportWorkerCount: Option<i32>,
    pub m_VCAllowAsyncUpdate: Option<bool>,
    pub m_VCAutomaticAdd: Option<bool>,
    pub m_VCDebugCmd: Option<bool>,
    pub m_VCDebugCom: Option<bool>,
    pub m_VCDebugOut: Option<bool>,
    pub m_VCHierarchyOverlayIcons: Option<bool>,
    pub m_VCOtherOverlayIcons: Option<bool>,
    pub m_VCOverlayIcons: Option<bool>,
    pub m_VCOverwriteFailedCheckoutAssets: Option<bool>,
    pub m_VCPassword: Option<String>,
    pub m_VCProjectOverlayIcons: Option<bool>,
    pub m_VCScanLocalPackagesOnConnect: Option<bool>,
    pub m_VCServer: Option<String>,
    pub m_VCShowFailedCheckout: Option<bool>,
    pub m_VCUserName: Option<String>,
    pub m_VCWorkspace: Option<String>,
}

impl_object!(EditorUserSettings);

impl Clone for EditorUserSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ArtifactGarbageCollection: self.m_ArtifactGarbageCollection.clone(),
            m_AssetPipelineMode: self.m_AssetPipelineMode.clone(),
            m_AssetPipelineMode2: self.m_AssetPipelineMode2.clone(),
            m_CacheServerMode: self.m_CacheServerMode.clone(),
            m_CacheServers: self.m_CacheServers.clone(),
            m_CompressAssetsOnImport: self.m_CompressAssetsOnImport.clone(),
            m_ConfigSettings: self.m_ConfigSettings.clone(),
            m_ConfigValues: self.m_ConfigValues.clone(),
            m_DesiredImportWorkerCount: self.m_DesiredImportWorkerCount.clone(),
            m_IdleImportWorkerShutdownDelay: self.m_IdleImportWorkerShutdownDelay.clone(),
            m_SemanticMergeMode: self.m_SemanticMergeMode.clone(),
            m_StandbyImportWorkerCount: self.m_StandbyImportWorkerCount.clone(),
            m_VCAllowAsyncUpdate: self.m_VCAllowAsyncUpdate.clone(),
            m_VCAutomaticAdd: self.m_VCAutomaticAdd.clone(),
            m_VCDebugCmd: self.m_VCDebugCmd.clone(),
            m_VCDebugCom: self.m_VCDebugCom.clone(),
            m_VCDebugOut: self.m_VCDebugOut.clone(),
            m_VCHierarchyOverlayIcons: self.m_VCHierarchyOverlayIcons.clone(),
            m_VCOtherOverlayIcons: self.m_VCOtherOverlayIcons.clone(),
            m_VCOverlayIcons: self.m_VCOverlayIcons.clone(),
            m_VCOverwriteFailedCheckoutAssets: self.m_VCOverwriteFailedCheckoutAssets.clone(),
            m_VCPassword: self.m_VCPassword.clone(),
            m_VCProjectOverlayIcons: self.m_VCProjectOverlayIcons.clone(),
            m_VCScanLocalPackagesOnConnect: self.m_VCScanLocalPackagesOnConnect.clone(),
            m_VCServer: self.m_VCServer.clone(),
            m_VCShowFailedCheckout: self.m_VCShowFailedCheckout.clone(),
            m_VCUserName: self.m_VCUserName.clone(),
            m_VCWorkspace: self.m_VCWorkspace.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EmptyObject {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(EmptyObject);

impl Clone for EmptyObject {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GUIDSerializer {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub guidToPath: Option<Vec<(GUID, String)>>,
}

impl_object!(GUIDSerializer);

impl Clone for GUIDSerializer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            guidToPath: self.guidToPath.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GameManager {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(GameManager);

impl Clone for GameManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GlobalGameManager {
    // extends GameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(GlobalGameManager);

impl Clone for GlobalGameManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnimationManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(AnimationManager);

impl Clone for AnimationManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub Default_Speaker_Mode: Option<i32>,
    pub Doppler_Factor: Option<f32>,
    pub Rolloff_Scale: Option<f32>,
    pub m_AmbisonicDecoderPlugin: Option<String>,
    pub m_DSPBufferSize: Option<i32>,
    pub m_DisableAudio: Option<bool>,
    pub m_RealVoiceCount: Option<i32>,
    pub m_RequestedDSPBufferSize: Option<i32>,
    pub m_SampleRate: Option<i32>,
    pub m_SpatializerPlugin: Option<String>,
    pub m_SpeedOfSound: Option<f32>,
    pub m_VirtualVoiceCount: Option<i32>,
    pub m_VirtualizeEffects: Option<bool>,
    pub m_Volume: Option<f32>,
}

impl_object!(AudioManager);

impl Clone for AudioManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            Default_Speaker_Mode: self.Default_Speaker_Mode.clone(),
            Doppler_Factor: self.Doppler_Factor.clone(),
            Rolloff_Scale: self.Rolloff_Scale.clone(),
            m_AmbisonicDecoderPlugin: self.m_AmbisonicDecoderPlugin.clone(),
            m_DSPBufferSize: self.m_DSPBufferSize.clone(),
            m_DisableAudio: self.m_DisableAudio.clone(),
            m_RealVoiceCount: self.m_RealVoiceCount.clone(),
            m_RequestedDSPBufferSize: self.m_RequestedDSPBufferSize.clone(),
            m_SampleRate: self.m_SampleRate.clone(),
            m_SpatializerPlugin: self.m_SpatializerPlugin.clone(),
            m_SpeedOfSound: self.m_SpeedOfSound.clone(),
            m_VirtualVoiceCount: self.m_VirtualVoiceCount.clone(),
            m_VirtualizeEffects: self.m_VirtualizeEffects.clone(),
            m_Volume: self.m_Volume.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuildSettings {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub buildGUID: Option<GUID>,
    pub buildTags: Option<Vec<String>>,
    pub enableDynamicBatching: Option<bool>,
    pub enableMultipleDisplays: Option<bool>,
    pub enabledVRDevices: Option<Vec<String>>,
    pub hasAdvancedVersion: Option<bool>,
    pub hasClusterRendering: Option<bool>,
    pub hasLocalLightShadows: Option<bool>,
    pub hasOculusPlugin: Option<bool>,
    pub hasPROVersion: Option<bool>,
    pub hasPublishingRights: Option<bool>,
    pub hasRenderTexture: Option<bool>,
    pub hasShadows: Option<bool>,
    pub hasSoftShadows: Option<bool>,
    pub isDebugBuild: Option<bool>,
    pub isEducationalBuild: Option<bool>,
    pub isEmbedded: Option<bool>,
    pub isNoWatermarkBuild: Option<bool>,
    pub isPrototypingBuild: Option<bool>,
    pub isTrial: Option<bool>,
    pub isWsaHolographicRemotingEnabled: Option<bool>,
    pub levels: Option<Vec<String>>,
    pub m_AuthToken: Option<String>,
    pub m_GraphicsAPIs: Option<Vec<i32>>,
    pub m_Version: Option<String>,
    pub preloadedPlugins: Option<Vec<String>>,
    pub runtimeClassHashes: Option<Vec<(i32, Hash128)>>,
    pub scenes: Option<Vec<String>>,
    pub scriptHashes: Option<Vec<(Hash128, Hash128)>>,
    pub usesOnMouseEvents: Option<bool>,
}

impl_object!(BuildSettings);

impl Clone for BuildSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            buildGUID: self.buildGUID.clone(),
            buildTags: self.buildTags.clone(),
            enableDynamicBatching: self.enableDynamicBatching.clone(),
            enableMultipleDisplays: self.enableMultipleDisplays.clone(),
            enabledVRDevices: self.enabledVRDevices.clone(),
            hasAdvancedVersion: self.hasAdvancedVersion.clone(),
            hasClusterRendering: self.hasClusterRendering.clone(),
            hasLocalLightShadows: self.hasLocalLightShadows.clone(),
            hasOculusPlugin: self.hasOculusPlugin.clone(),
            hasPROVersion: self.hasPROVersion.clone(),
            hasPublishingRights: self.hasPublishingRights.clone(),
            hasRenderTexture: self.hasRenderTexture.clone(),
            hasShadows: self.hasShadows.clone(),
            hasSoftShadows: self.hasSoftShadows.clone(),
            isDebugBuild: self.isDebugBuild.clone(),
            isEducationalBuild: self.isEducationalBuild.clone(),
            isEmbedded: self.isEmbedded.clone(),
            isNoWatermarkBuild: self.isNoWatermarkBuild.clone(),
            isPrototypingBuild: self.isPrototypingBuild.clone(),
            isTrial: self.isTrial.clone(),
            isWsaHolographicRemotingEnabled: self.isWsaHolographicRemotingEnabled.clone(),
            levels: self.levels.clone(),
            m_AuthToken: self.m_AuthToken.clone(),
            m_GraphicsAPIs: self.m_GraphicsAPIs.clone(),
            m_Version: self.m_Version.clone(),
            preloadedPlugins: self.preloadedPlugins.clone(),
            runtimeClassHashes: self.runtimeClassHashes.clone(),
            scenes: self.scenes.clone(),
            scriptHashes: self.scriptHashes.clone(),
            usesOnMouseEvents: self.usesOnMouseEvents.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CloudWebServicesManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(CloudWebServicesManager);

impl Clone for CloudWebServicesManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ClusterInputManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Inputs: Option<Vec<ClusterInput>>,
}

impl_object!(ClusterInputManager);

impl Clone for ClusterInputManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Inputs: self.m_Inputs.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CrashReportManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(CrashReportManager);

impl Clone for CrashReportManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DelayedCallManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(DelayedCallManager);

impl Clone for DelayedCallManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GraphicsSettings {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AllowEnlightenSupportForUpgradedProject: Option<bool>,
    pub m_AlwaysIncludedShaders: Option<Vec<PPtrData<Shader>>>,
    pub m_CameraRelativeLightCulling: Option<bool>,
    pub m_CameraRelativeShadowCulling: Option<bool>,
    pub m_CurrentRenderPipelineGlobalSettings: Option<PPtrData<Object>>,
    pub m_CustomRenderPipeline: Option<PPtrData<MonoBehaviour>>,
    pub m_DefaultRenderingLayerMask: Option<u32>,
    pub m_Deferred: Option<BuiltinShaderSettings>,
    pub m_DeferredReflections: Option<BuiltinShaderSettings>,
    pub m_DepthNormals: Option<BuiltinShaderSettings>,
    pub m_LegacyDeferred: Option<BuiltinShaderSettings>,
    pub m_LensFlare: Option<BuiltinShaderSettings>,
    pub m_LightHalo: Option<BuiltinShaderSettings>,
    pub m_LightProbeOutsideHullStrategy: Option<i32>,
    pub m_LightsUseCCT: Option<bool>,
    pub m_LightsUseColorTemperature: Option<bool>,
    pub m_LightsUseLinearIntensity: Option<bool>,
    pub m_LogWhenShaderIsCompiled: Option<bool>,
    pub m_MotionVectors: Option<BuiltinShaderSettings>,
    pub m_PreloadShadersBatchTimeLimit: Option<i32>,
    pub m_PreloadedShaders: Option<Vec<PPtrData<ShaderVariantCollection>>>,
    pub m_SRPDefaultSettings: Option<Vec<(String, PPtrData<Object>)>>,
    pub m_ScreenSpaceShadows: Option<BuiltinShaderSettings>,
    pub m_ShaderDefinesPerShaderCompiler: Option<Vec<PlatformShaderDefines>>,
    pub m_ShaderSettings: Option<PlatformShaderSettings>,
    pub m_ShaderSettings_Tier1: Option<PlatformShaderSettings>,
    pub m_ShaderSettings_Tier2: Option<PlatformShaderSettings>,
    pub m_ShaderSettings_Tier3: Option<PlatformShaderSettings>,
    pub m_SpritesDefaultMaterial: Option<PPtrData<Material>>,
    pub m_TierSettings_Tier1: Option<TierGraphicsSettings>,
    pub m_TierSettings_Tier2: Option<TierGraphicsSettings>,
    pub m_TierSettings_Tier3: Option<TierGraphicsSettings>,
    pub m_TransparencySortAxis: Option<Vector3>,
    pub m_TransparencySortMode: Option<i32>,
    pub m_VideoShadersIncludeMode: Option<i32>,
}

impl_object!(GraphicsSettings);

impl Clone for GraphicsSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AllowEnlightenSupportForUpgradedProject: self
                .m_AllowEnlightenSupportForUpgradedProject
                .clone(),
            m_AlwaysIncludedShaders: self.m_AlwaysIncludedShaders.clone(),
            m_CameraRelativeLightCulling: self.m_CameraRelativeLightCulling.clone(),
            m_CameraRelativeShadowCulling: self.m_CameraRelativeShadowCulling.clone(),
            m_CurrentRenderPipelineGlobalSettings: self
                .m_CurrentRenderPipelineGlobalSettings
                .clone(),
            m_CustomRenderPipeline: self.m_CustomRenderPipeline.clone(),
            m_DefaultRenderingLayerMask: self.m_DefaultRenderingLayerMask.clone(),
            m_Deferred: self.m_Deferred.clone(),
            m_DeferredReflections: self.m_DeferredReflections.clone(),
            m_DepthNormals: self.m_DepthNormals.clone(),
            m_LegacyDeferred: self.m_LegacyDeferred.clone(),
            m_LensFlare: self.m_LensFlare.clone(),
            m_LightHalo: self.m_LightHalo.clone(),
            m_LightProbeOutsideHullStrategy: self.m_LightProbeOutsideHullStrategy.clone(),
            m_LightsUseCCT: self.m_LightsUseCCT.clone(),
            m_LightsUseColorTemperature: self.m_LightsUseColorTemperature.clone(),
            m_LightsUseLinearIntensity: self.m_LightsUseLinearIntensity.clone(),
            m_LogWhenShaderIsCompiled: self.m_LogWhenShaderIsCompiled.clone(),
            m_MotionVectors: self.m_MotionVectors.clone(),
            m_PreloadShadersBatchTimeLimit: self.m_PreloadShadersBatchTimeLimit.clone(),
            m_PreloadedShaders: self.m_PreloadedShaders.clone(),
            m_SRPDefaultSettings: self.m_SRPDefaultSettings.clone(),
            m_ScreenSpaceShadows: self.m_ScreenSpaceShadows.clone(),
            m_ShaderDefinesPerShaderCompiler: self.m_ShaderDefinesPerShaderCompiler.clone(),
            m_ShaderSettings: self.m_ShaderSettings.clone(),
            m_ShaderSettings_Tier1: self.m_ShaderSettings_Tier1.clone(),
            m_ShaderSettings_Tier2: self.m_ShaderSettings_Tier2.clone(),
            m_ShaderSettings_Tier3: self.m_ShaderSettings_Tier3.clone(),
            m_SpritesDefaultMaterial: self.m_SpritesDefaultMaterial.clone(),
            m_TierSettings_Tier1: self.m_TierSettings_Tier1.clone(),
            m_TierSettings_Tier2: self.m_TierSettings_Tier2.clone(),
            m_TierSettings_Tier3: self.m_TierSettings_Tier3.clone(),
            m_TransparencySortAxis: self.m_TransparencySortAxis.clone(),
            m_TransparencySortMode: self.m_TransparencySortMode.clone(),
            m_VideoShadersIncludeMode: self.m_VideoShadersIncludeMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct InputManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Axes: Option<Vec<InputAxis>>,
    pub m_UsePhysicalKeys: Option<bool>,
}

impl_object!(InputManager);

impl Clone for InputManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Axes: self.m_Axes.clone(),
            m_UsePhysicalKeys: self.m_UsePhysicalKeys.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MasterServerInterface {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(MasterServerInterface);

impl Clone for MasterServerInterface {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MonoManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssemblyNames: Option<Vec<String>>,
    pub m_AssemblyTypes: Option<Vec<i32>>,
    pub m_RuntimeClassHashes: Option<Vec<(u32, Hash128)>>,
    pub m_ScriptHashes: Option<Vec<(Hash128, Hash128)>>,
    pub m_Scripts: Option<Vec<PPtrData<MonoScript>>>,
}

impl_object!(MonoManager);

impl Clone for MonoManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssemblyNames: self.m_AssemblyNames.clone(),
            m_AssemblyTypes: self.m_AssemblyTypes.clone(),
            m_RuntimeClassHashes: self.m_RuntimeClassHashes.clone(),
            m_ScriptHashes: self.m_ScriptHashes.clone(),
            m_Scripts: self.m_Scripts.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MultiplayerManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ActiveMultiplayerRole: Option<i32>,
    pub m_ActiveMultiplayerRoles: Option<i32>,
}

impl_object!(MultiplayerManager);

impl Clone for MultiplayerManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ActiveMultiplayerRole: self.m_ActiveMultiplayerRole.clone(),
            m_ActiveMultiplayerRoles: self.m_ActiveMultiplayerRoles.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NavMeshProjectSettings {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub areas: Option<Vec<NavMeshAreaData>>,
    pub m_LastAgentTypeID: Option<i32>,
    pub m_SettingNames: Option<Vec<String>>,
    pub m_Settings: Option<Vec<NavMeshBuildSettings>>,
}

impl_object!(NavMeshProjectSettings);

impl Clone for NavMeshProjectSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            areas: self.areas.clone(),
            m_LastAgentTypeID: self.m_LastAgentTypeID.clone(),
            m_SettingNames: self.m_SettingNames.clone(),
            m_Settings: self.m_Settings.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NetworkManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetToPrefab: Option<Vec<(GUID, PPtrData<GameObject>)>>,
    pub m_DebugLevel: Option<i32>,
    pub m_Sendrate: Option<f32>,
}

impl_object!(NetworkManager);

impl Clone for NetworkManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetToPrefab: self.m_AssetToPrefab.clone(),
            m_DebugLevel: self.m_DebugLevel.clone(),
            m_Sendrate: self.m_Sendrate.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NotificationManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(NotificationManager);

impl Clone for NotificationManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PerformanceReportingManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(PerformanceReportingManager);

impl Clone for PerformanceReportingManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Physics2DSettings {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AngularSleepTolerance: Option<f32>,
    pub m_AutoSimulation: Option<bool>,
    pub m_AutoSyncTransforms: Option<bool>,
    pub m_BaumgarteScale: Option<f32>,
    pub m_BaumgarteTimeOfImpactScale: Option<f32>,
    pub m_BounceThreshold: Option<f32>,
    pub m_CallbacksOnDisable: Option<bool>,
    pub m_ChangeStopsCallbacks: Option<bool>,
    pub m_ContactThreshold: Option<f32>,
    pub m_DefaultContactOffset: Option<f32>,
    pub m_DefaultMaterial: Option<PPtrData<PhysicsMaterial2D>>,
    pub m_DeleteStopsCallbacks: Option<bool>,
    pub m_Gravity: Option<Vector2>,
    pub m_JobOptions: Option<PhysicsJobOptions2D>,
    pub m_LayerCollisionMatrix: Option<Vec<u32>>,
    pub m_LinearSleepTolerance: Option<f32>,
    pub m_MaxAngularCorrection: Option<f32>,
    pub m_MaxLinearCorrection: Option<f32>,
    pub m_MaxRotationSpeed: Option<f32>,
    pub m_MaxSubStepCount: Option<i32>,
    pub m_MaxTranslationSpeed: Option<f32>,
    pub m_MinPenetrationForPenalty: Option<f32>,
    pub m_MinSubStepFPS: Option<f32>,
    pub m_PositionIterations: Option<i32>,
    pub m_QueriesHitTriggers: Option<bool>,
    pub m_QueriesStartInColliders: Option<bool>,
    pub m_RaycastsHitTriggers: Option<bool>,
    pub m_RaycastsStartInColliders: Option<bool>,
    pub m_ReuseCollisionCallbacks: Option<bool>,
    pub m_SimulationLayers: Option<BitField>,
    pub m_SimulationMode: Option<i32>,
    pub m_TimeToSleep: Option<f32>,
    pub m_UseSubStepContacts: Option<bool>,
    pub m_UseSubStepping: Option<bool>,
    pub m_VelocityIterations: Option<i32>,
    pub m_VelocityThreshold: Option<f32>,
}

impl_object!(Physics2DSettings);

impl Clone for Physics2DSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AngularSleepTolerance: self.m_AngularSleepTolerance.clone(),
            m_AutoSimulation: self.m_AutoSimulation.clone(),
            m_AutoSyncTransforms: self.m_AutoSyncTransforms.clone(),
            m_BaumgarteScale: self.m_BaumgarteScale.clone(),
            m_BaumgarteTimeOfImpactScale: self.m_BaumgarteTimeOfImpactScale.clone(),
            m_BounceThreshold: self.m_BounceThreshold.clone(),
            m_CallbacksOnDisable: self.m_CallbacksOnDisable.clone(),
            m_ChangeStopsCallbacks: self.m_ChangeStopsCallbacks.clone(),
            m_ContactThreshold: self.m_ContactThreshold.clone(),
            m_DefaultContactOffset: self.m_DefaultContactOffset.clone(),
            m_DefaultMaterial: self.m_DefaultMaterial.clone(),
            m_DeleteStopsCallbacks: self.m_DeleteStopsCallbacks.clone(),
            m_Gravity: self.m_Gravity.clone(),
            m_JobOptions: self.m_JobOptions.clone(),
            m_LayerCollisionMatrix: self.m_LayerCollisionMatrix.clone(),
            m_LinearSleepTolerance: self.m_LinearSleepTolerance.clone(),
            m_MaxAngularCorrection: self.m_MaxAngularCorrection.clone(),
            m_MaxLinearCorrection: self.m_MaxLinearCorrection.clone(),
            m_MaxRotationSpeed: self.m_MaxRotationSpeed.clone(),
            m_MaxSubStepCount: self.m_MaxSubStepCount.clone(),
            m_MaxTranslationSpeed: self.m_MaxTranslationSpeed.clone(),
            m_MinPenetrationForPenalty: self.m_MinPenetrationForPenalty.clone(),
            m_MinSubStepFPS: self.m_MinSubStepFPS.clone(),
            m_PositionIterations: self.m_PositionIterations.clone(),
            m_QueriesHitTriggers: self.m_QueriesHitTriggers.clone(),
            m_QueriesStartInColliders: self.m_QueriesStartInColliders.clone(),
            m_RaycastsHitTriggers: self.m_RaycastsHitTriggers.clone(),
            m_RaycastsStartInColliders: self.m_RaycastsStartInColliders.clone(),
            m_ReuseCollisionCallbacks: self.m_ReuseCollisionCallbacks.clone(),
            m_SimulationLayers: self.m_SimulationLayers.clone(),
            m_SimulationMode: self.m_SimulationMode.clone(),
            m_TimeToSleep: self.m_TimeToSleep.clone(),
            m_UseSubStepContacts: self.m_UseSubStepContacts.clone(),
            m_UseSubStepping: self.m_UseSubStepping.clone(),
            m_VelocityIterations: self.m_VelocityIterations.clone(),
            m_VelocityThreshold: self.m_VelocityThreshold.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PhysicsManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AutoSimulation: Option<bool>,
    pub m_AutoSyncTransforms: Option<bool>,
    pub m_BounceThreshold: Option<f32>,
    pub m_BroadphaseType: Option<i32>,
    pub m_ClothGravity: Option<Vector3>,
    pub m_ClothInterCollisionDistance: Option<f32>,
    pub m_ClothInterCollisionSettingsToggle: Option<bool>,
    pub m_ClothInterCollisionStiffness: Option<f32>,
    pub m_ContactPairsMode: Option<i32>,
    pub m_ContactsGeneration: Option<i32>,
    pub m_CurrentBackendId: Option<u32>,
    pub m_DefaultContactOffset: Option<f32>,
    pub m_DefaultMaterial: Option<PPtrData<PhysicMaterial>>,
    pub m_DefaultMaxAngluarSpeed: Option<f32>,
    pub m_DefaultMaxAngularSpeed: Option<f32>,
    pub m_DefaultMaxDepenetrationVelocity: Option<f32>,
    pub m_DefaultSolverIterations: Option<i32>,
    pub m_DefaultSolverVelocityIterations: Option<i32>,
    pub m_EnableAdaptiveForce: Option<bool>,
    pub m_EnableEnhancedDeterminism: Option<bool>,
    pub m_EnablePCM: Option<bool>,
    pub m_EnableUnifiedHeightmaps: Option<bool>,
    pub m_FastMotionThreshold: Option<f32>,
    pub m_FrictionType: Option<i32>,
    pub m_Gravity: Option<Vector3>,
    pub m_ImprovedPatchFriction: Option<bool>,
    pub m_InvokeCollisionCallbacks: Option<bool>,
    pub m_LayerCollisionMatrix: Option<Vec<u32>>,
    pub m_MaxAngularVelocity: Option<f32>,
    pub m_MinPenetrationForPenalty: Option<f32>,
    pub m_QueriesHitBackfaces: Option<bool>,
    pub m_QueriesHitTriggers: Option<bool>,
    pub m_RaycastsHitTriggers: Option<bool>,
    pub m_ReuseCollisionCallbacks: Option<bool>,
    pub m_ScratchBufferChunkCount: Option<u32>,
    pub m_SimulationMode: Option<i32>,
    pub m_SleepAngularVelocity: Option<f32>,
    pub m_SleepThreshold: Option<f32>,
    pub m_SleepVelocity: Option<f32>,
    pub m_SolverIterationCount: Option<i32>,
    pub m_SolverType: Option<i32>,
    pub m_SolverVelocityIterations: Option<i32>,
    pub m_WorldBounds: Option<AABB>,
    pub m_WorldSubdivisions: Option<i32>,
}

impl_object!(PhysicsManager);

impl Clone for PhysicsManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AutoSimulation: self.m_AutoSimulation.clone(),
            m_AutoSyncTransforms: self.m_AutoSyncTransforms.clone(),
            m_BounceThreshold: self.m_BounceThreshold.clone(),
            m_BroadphaseType: self.m_BroadphaseType.clone(),
            m_ClothGravity: self.m_ClothGravity.clone(),
            m_ClothInterCollisionDistance: self.m_ClothInterCollisionDistance.clone(),
            m_ClothInterCollisionSettingsToggle: self.m_ClothInterCollisionSettingsToggle.clone(),
            m_ClothInterCollisionStiffness: self.m_ClothInterCollisionStiffness.clone(),
            m_ContactPairsMode: self.m_ContactPairsMode.clone(),
            m_ContactsGeneration: self.m_ContactsGeneration.clone(),
            m_CurrentBackendId: self.m_CurrentBackendId.clone(),
            m_DefaultContactOffset: self.m_DefaultContactOffset.clone(),
            m_DefaultMaterial: self.m_DefaultMaterial.clone(),
            m_DefaultMaxAngluarSpeed: self.m_DefaultMaxAngluarSpeed.clone(),
            m_DefaultMaxAngularSpeed: self.m_DefaultMaxAngularSpeed.clone(),
            m_DefaultMaxDepenetrationVelocity: self.m_DefaultMaxDepenetrationVelocity.clone(),
            m_DefaultSolverIterations: self.m_DefaultSolverIterations.clone(),
            m_DefaultSolverVelocityIterations: self.m_DefaultSolverVelocityIterations.clone(),
            m_EnableAdaptiveForce: self.m_EnableAdaptiveForce.clone(),
            m_EnableEnhancedDeterminism: self.m_EnableEnhancedDeterminism.clone(),
            m_EnablePCM: self.m_EnablePCM.clone(),
            m_EnableUnifiedHeightmaps: self.m_EnableUnifiedHeightmaps.clone(),
            m_FastMotionThreshold: self.m_FastMotionThreshold.clone(),
            m_FrictionType: self.m_FrictionType.clone(),
            m_Gravity: self.m_Gravity.clone(),
            m_ImprovedPatchFriction: self.m_ImprovedPatchFriction.clone(),
            m_InvokeCollisionCallbacks: self.m_InvokeCollisionCallbacks.clone(),
            m_LayerCollisionMatrix: self.m_LayerCollisionMatrix.clone(),
            m_MaxAngularVelocity: self.m_MaxAngularVelocity.clone(),
            m_MinPenetrationForPenalty: self.m_MinPenetrationForPenalty.clone(),
            m_QueriesHitBackfaces: self.m_QueriesHitBackfaces.clone(),
            m_QueriesHitTriggers: self.m_QueriesHitTriggers.clone(),
            m_RaycastsHitTriggers: self.m_RaycastsHitTriggers.clone(),
            m_ReuseCollisionCallbacks: self.m_ReuseCollisionCallbacks.clone(),
            m_ScratchBufferChunkCount: self.m_ScratchBufferChunkCount.clone(),
            m_SimulationMode: self.m_SimulationMode.clone(),
            m_SleepAngularVelocity: self.m_SleepAngularVelocity.clone(),
            m_SleepThreshold: self.m_SleepThreshold.clone(),
            m_SleepVelocity: self.m_SleepVelocity.clone(),
            m_SolverIterationCount: self.m_SolverIterationCount.clone(),
            m_SolverType: self.m_SolverType.clone(),
            m_SolverVelocityIterations: self.m_SolverVelocityIterations.clone(),
            m_WorldBounds: self.m_WorldBounds.clone(),
            m_WorldSubdivisions: self.m_WorldSubdivisions.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PlayerSettings {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub AID: Option<Hash128>,
    pub AndroidEnableSustainedPerformanceMode: Option<bool>,
    pub AndroidFilterTouchesWhenObscured: Option<bool>,
    pub AndroidLicensePublicKey: Option<String>,
    pub AndroidProfiler: Option<bool>,
    pub D3DHDRBitDepth: Option<i32>,
    pub Force_IOS_Speakers_When_Recording: Option<bool>,
    pub Override_IPod_Music: Option<bool>,
    pub Prepare_IOS_For_Recording: Option<bool>,
    pub accelerometerFrequency: Option<i32>,
    pub activeInputHandler: Option<i32>,
    pub allowFullscreenSwitch: Option<bool>,
    pub allowHDRDisplaySupport: Option<bool>,
    pub allowedAutorotateToLandscapeLeft: Option<bool>,
    pub allowedAutorotateToLandscapeRight: Option<bool>,
    pub allowedAutorotateToPortrait: Option<bool>,
    pub allowedAutorotateToPortraitUpsideDown: Option<bool>,
    pub androidApplicationEntry: Option<i32>,
    pub androidAutoRotationBehavior: Option<i32>,
    pub androidBlitType: Option<i32>,
    pub androidDefaultWindowHeight: Option<i32>,
    pub androidDefaultWindowWidth: Option<i32>,
    pub androidFullscreenMode: Option<i32>,
    pub androidMaxAspectRatio: Option<f32>,
    pub androidMinAspectRatio: Option<f32>,
    pub androidMinimumWindowHeight: Option<i32>,
    pub androidMinimumWindowWidth: Option<i32>,
    pub androidPredictiveBackSupport: Option<bool>,
    pub androidRenderOutsideSafeArea: Option<bool>,
    pub androidResizableWindow: Option<bool>,
    pub androidResizeableActivity: Option<bool>,
    pub androidShowActivityIndicatorOnLoading: Option<i32>,
    pub androidStartInFullscreen: Option<bool>,
    pub androidSupportedAspectRatio: Option<i32>,
    pub androidUseSwappy: Option<bool>,
    pub androidVulkanAllowFilterList: Option<Vec<AndroidDeviceFilterData>>,
    pub androidVulkanDenyFilterList: Option<Vec<AndroidDeviceFilterData>>,
    pub bakeCollisionMeshes: Option<bool>,
    pub bundleIdentifier: Option<String>,
    pub bundleVersion: Option<String>,
    pub captureSingleScreen: Option<bool>,
    pub cloudEnabled: Option<bool>,
    pub cloudProjectId: Option<String>,
    pub companyName: Option<String>,
    pub cpuConfiguration: Option<Vec<i32>>,
    pub cursorHotspot: Option<Vector2>,
    pub d3d11ForceExclusiveMode: Option<bool>,
    pub d3d11FullscreenMode: Option<i32>,
    pub d3d9FullscreenMode: Option<i32>,
    pub debugUnloadMode: Option<i32>,
    pub dedicatedServerOptimizations: Option<bool>,
    pub defaultCursor: Option<PPtrData<Texture2D>>,
    pub defaultIsFullScreen: Option<bool>,
    pub defaultIsNativeResolution: Option<bool>,
    pub defaultScreenHeight: Option<i32>,
    pub defaultScreenHeightWeb: Option<i32>,
    pub defaultScreenOrientation: Option<i32>,
    pub defaultScreenWidth: Option<i32>,
    pub defaultScreenWidthWeb: Option<i32>,
    pub deferSystemGesturesMode: Option<i32>,
    pub disableDepthAndStencilBuffers: Option<bool>,
    pub disableOldInputManagerSupport: Option<bool>,
    pub displayResolutionDialog: Option<i32>,
    pub enableFrameTimingStats: Option<bool>,
    pub enableGamepadInput: Option<bool>,
    pub enableHWStatistics: Option<bool>,
    pub enableNativePlatformBackendsForNewInputSystem: Option<bool>,
    pub enableNewInputSystem: Option<bool>,
    pub enableOpenGLProfilerGPURecorders: Option<bool>,
    pub forceSRGBBlit: Option<bool>,
    pub forceSingleInstance: Option<bool>,
    pub framebufferDepthMemorylessMode: Option<i32>,
    pub fullscreenMode: Option<i32>,
    pub gpuSkinning: Option<bool>,
    pub graphicsJobMode: Option<i32>,
    pub graphicsJobs: Option<bool>,
    pub hdrBitDepth: Option<i32>,
    pub hideHomeButton: Option<bool>,
    pub hmiLoadingImage: Option<PPtrData<Texture2D>>,
    pub iPhoneBundleIdentifier: Option<String>,
    pub ignoreAlphaClear: Option<bool>,
    pub insecureHttpOption: Option<i32>,
    pub invalidatedPatternTexture: Option<PPtrData<Texture2D>>,
    pub iosAllowHTTPDownload: Option<bool>,
    pub iosAppInBackgroundBehavior: Option<i32>,
    pub iosShowActivityIndicatorOnLoading: Option<i32>,
    pub iosUseCustomAppBackgroundBehavior: Option<bool>,
    pub isWsaHolographicRemotingEnabled: Option<bool>,
    pub legacyClampBlendShapeWeights: Option<bool>,
    pub loadStoreDebugModeEnabled: Option<bool>,
    pub m_ActiveColorSpace: Option<i32>,
    pub m_ColorGamuts: Option<Vec<i32>>,
    pub m_HolographicPauseOnTrackingLoss: Option<bool>,
    pub m_HolographicTrackingLossScreen: Option<PPtrData<Texture2D>>,
    pub m_MTRendering: Option<bool>,
    pub m_MobileMTRendering: Option<bool>,
    pub m_MobileRenderingPath: Option<i32>,
    pub m_RenderingPath: Option<i32>,
    pub m_ShowUnitySplashLogo: Option<bool>,
    pub m_ShowUnitySplashScreen: Option<bool>,
    pub m_SplashScreenAnimation: Option<i32>,
    pub m_SplashScreenBackgroundAnimationZoom: Option<f32>,
    pub m_SplashScreenBackgroundColor: Option<Color>,
    pub m_SplashScreenBackgroundLandscape: Option<PPtrData<Texture2D>>,
    pub m_SplashScreenBackgroundLandscapeAspect: Option<f32>,
    pub m_SplashScreenBackgroundLandscapeUvs: Option<Rectf>,
    pub m_SplashScreenBackgroundPortrait: Option<PPtrData<Texture2D>>,
    pub m_SplashScreenBackgroundPortraitAspect: Option<f32>,
    pub m_SplashScreenBackgroundPortraitUvs: Option<Rectf>,
    pub m_SplashScreenDrawMode: Option<i32>,
    pub m_SplashScreenLogoAnimationZoom: Option<f32>,
    pub m_SplashScreenLogoStyle: Option<i32>,
    pub m_SplashScreenLogos: Option<Vec<SplashScreenLogo>>,
    pub m_SplashScreenOverlayOpacity: Option<f32>,
    pub m_SplashScreenStyle: Option<i32>,
    pub m_SpriteBatchVertexThreshold: Option<i32>,
    pub m_StackTraceTypes: Option<Vec<i32>>,
    pub m_StereoRenderingPath: Option<i32>,
    pub m_Stereoscopic3D: Option<bool>,
    pub m_SupportedAspectRatios: Option<AspectRatios>,
    pub m_UnitySplashLogo: Option<PPtrData<Sprite>>,
    pub m_UseDX11: Option<bool>,
    pub m_VirtualRealitySplashScreen: Option<PPtrData<Texture2D>>,
    pub macAppStoreCategory: Option<String>,
    pub macFullscreenMode: Option<i32>,
    pub macRetinaSupport: Option<bool>,
    pub meshDeformation: Option<i32>,
    pub metalFramebufferOnly: Option<bool>,
    pub metroEnableIndependentInputSource: Option<bool>,
    pub metroEnableLowLatencyPresentationAPI: Option<bool>,
    pub metroInputSource: Option<i32>,
    pub mipStripping: Option<bool>,
    pub mobileMTRenderingBaked: Option<bool>,
    pub muteOtherAudioSources: Option<bool>,
    pub n3dsDisableStereoscopicView: Option<bool>,
    pub n3dsEnableSharedListOpt: Option<bool>,
    pub n3dsEnableVSync: Option<bool>,
    pub numberOfMipsStripped: Option<i32>,
    pub numberOfMipsStrippedPerMipmapLimitGroup: Option<Vec<(String, i32)>>,
    pub organizationId: Option<String>,
    pub platformRequiresReadableAssets: Option<bool>,
    pub playerDataPath: Option<String>,
    pub playerMinOpenGLESVersion: Option<i32>,
    pub preloadedAssets: Option<Vec<PPtrData<Object>>>,
    pub preserveFramebufferAlpha: Option<bool>,
    pub productGUID: Option<GUID>,
    pub productName: Option<String>,
    pub projectId: Option<String>,
    pub projectName: Option<String>,
    pub protectGraphicsMemory: Option<bool>,
    pub ps3SplashScreen: Option<PPtrData<Texture2D>>,
    pub psp2AcquireBGM: Option<bool>,
    pub psp2PowerMode: Option<i32>,
    pub qualitySettingsNames: Option<Vec<String>>,
    pub resetResolutionOnWindowResize: Option<bool>,
    pub resizableWindow: Option<bool>,
    pub resolutionScalingMode: Option<i32>,
    pub runInBackground: Option<bool>,
    pub singlePassStereoRendering: Option<bool>,
    pub stadiaPresentMode: Option<i32>,
    pub stadiaTargetFramerate: Option<i32>,
    pub stripPhysics: Option<bool>,
    pub submitAnalytics: Option<bool>,
    pub switchAllowGpuScratchShrinking: Option<bool>,
    pub switchGpuScratchPoolGranularity: Option<i32>,
    pub switchMaxWorkerMultiple: Option<i32>,
    pub switchNVNDefaultPoolsGranularity: Option<i32>,
    pub switchNVNGraphicsFirmwareMemory: Option<i32>,
    pub switchNVNMaxPublicSamplerIDCount: Option<i32>,
    pub switchNVNMaxPublicTextureIDCount: Option<i32>,
    pub switchNVNOtherPoolsGranularity: Option<i32>,
    pub switchNVNShaderPoolsGranularity: Option<i32>,
    pub switchQueueCommandMemory: Option<i32>,
    pub switchQueueComputeMemory: Option<i32>,
    pub switchQueueControlMemory: Option<i32>,
    pub targetDevice: Option<i32>,
    pub targetGlesGraphics: Option<i32>,
    pub targetIOSGraphics: Option<i32>,
    pub targetPixelDensity: Option<i32>,
    pub targetPlatform: Option<i32>,
    pub targetResolution: Option<i32>,
    pub tizenShowActivityIndicatorOnLoading: Option<i32>,
    pub tvOSBundleVersion: Option<String>,
    pub uiUse16BitDepthBuffer: Option<bool>,
    pub unsupportedMSAAFallback: Option<i32>,
    pub uploadClearedTextureDataAfterCreationFromScript: Option<bool>,
    pub use24BitDepthBuffer: Option<bool>,
    pub use32BitDisplayBuffer: Option<bool>,
    pub useAlphaInDashboard: Option<bool>,
    pub useFlipModelSwapchain: Option<bool>,
    pub useHDRDisplay: Option<bool>,
    pub useMacAppStoreValidation: Option<bool>,
    pub useOSAutorotation: Option<bool>,
    pub useOnDemandResources: Option<bool>,
    pub usePlayerLog: Option<bool>,
    pub videoMemoryForVertexBuffers: Option<i32>,
    pub virtualRealitySupported: Option<bool>,
    pub virtualTexturingSupportEnabled: Option<bool>,
    pub visibleInBackground: Option<bool>,
    pub visionOSBundleVersion: Option<String>,
    pub vrSettings: Option<VRSettings>,
    pub vulkanEnableCommandBufferRecycling: Option<bool>,
    pub vulkanEnableLateAcquireNextImage: Option<bool>,
    pub vulkanEnablePreTransform: Option<bool>,
    pub vulkanEnableSetSRGBWrite: Option<bool>,
    pub vulkanNumSwapchainBuffers: Option<u32>,
    pub vulkanUseSWCommandBuffers: Option<bool>,
    pub wiiHio2Usage: Option<i32>,
    pub wiiLoadingScreenBackground: Option<Color>,
    pub wiiLoadingScreenFileName: Option<String>,
    pub wiiLoadingScreenPeriod: Option<i32>,
    pub wiiLoadingScreenRect: Option<Rectf>,
    pub wiiLoadingScreenRectPlacement: Option<i32>,
    pub wiiUAllowScreenCapture: Option<bool>,
    pub wiiUControllerCount: Option<i32>,
    pub wiiUGamePadMSAA: Option<i32>,
    pub wiiUSupportsBalanceBoard: Option<bool>,
    pub wiiUSupportsClassicController: Option<bool>,
    pub wiiUSupportsMotionPlus: Option<bool>,
    pub wiiUSupportsNunchuk: Option<bool>,
    pub wiiUSupportsProController: Option<bool>,
    pub wiiUTVResolution: Option<i32>,
    pub windowsGamepadBackendHint: Option<i32>,
    pub wsaTransparentSwapchain: Option<bool>,
    pub xboxEnableAvatar: Option<bool>,
    pub xboxEnableEnableRenderThreadRunsJobs: Option<bool>,
    pub xboxEnableFitness: Option<bool>,
    pub xboxEnableGuest: Option<bool>,
    pub xboxEnableHeadOrientation: Option<bool>,
    pub xboxEnableKinect: Option<bool>,
    pub xboxEnableKinectAutoTracking: Option<bool>,
    pub xboxEnablePIXSampling: Option<bool>,
    pub xboxEnableSpeech: Option<bool>,
    pub xboxOneDisableEsram: Option<bool>,
    pub xboxOneDisableKinectGpuReservation: Option<bool>,
    pub xboxOneEnable7thCore: Option<bool>,
    pub xboxOneEnableTypeOptimization: Option<bool>,
    pub xboxOneLoggingLevel: Option<i32>,
    pub xboxOneMonoLoggingLevel: Option<i32>,
    pub xboxOnePresentImmediateThreshold: Option<u32>,
    pub xboxOneResolution: Option<i32>,
    pub xboxOneSResolution: Option<i32>,
    pub xboxOneXResolution: Option<i32>,
    pub xboxPIXTextureCapture: Option<bool>,
    pub xboxSkinOnGPU: Option<bool>,
    pub xboxSpeechDB: Option<u32>,
}

impl_object!(PlayerSettings);

impl Clone for PlayerSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            AID: self.AID.clone(),
            AndroidEnableSustainedPerformanceMode: self
                .AndroidEnableSustainedPerformanceMode
                .clone(),
            AndroidFilterTouchesWhenObscured: self.AndroidFilterTouchesWhenObscured.clone(),
            AndroidLicensePublicKey: self.AndroidLicensePublicKey.clone(),
            AndroidProfiler: self.AndroidProfiler.clone(),
            D3DHDRBitDepth: self.D3DHDRBitDepth.clone(),
            Force_IOS_Speakers_When_Recording: self.Force_IOS_Speakers_When_Recording.clone(),
            Override_IPod_Music: self.Override_IPod_Music.clone(),
            Prepare_IOS_For_Recording: self.Prepare_IOS_For_Recording.clone(),
            accelerometerFrequency: self.accelerometerFrequency.clone(),
            activeInputHandler: self.activeInputHandler.clone(),
            allowFullscreenSwitch: self.allowFullscreenSwitch.clone(),
            allowHDRDisplaySupport: self.allowHDRDisplaySupport.clone(),
            allowedAutorotateToLandscapeLeft: self.allowedAutorotateToLandscapeLeft.clone(),
            allowedAutorotateToLandscapeRight: self.allowedAutorotateToLandscapeRight.clone(),
            allowedAutorotateToPortrait: self.allowedAutorotateToPortrait.clone(),
            allowedAutorotateToPortraitUpsideDown: self
                .allowedAutorotateToPortraitUpsideDown
                .clone(),
            androidApplicationEntry: self.androidApplicationEntry.clone(),
            androidAutoRotationBehavior: self.androidAutoRotationBehavior.clone(),
            androidBlitType: self.androidBlitType.clone(),
            androidDefaultWindowHeight: self.androidDefaultWindowHeight.clone(),
            androidDefaultWindowWidth: self.androidDefaultWindowWidth.clone(),
            androidFullscreenMode: self.androidFullscreenMode.clone(),
            androidMaxAspectRatio: self.androidMaxAspectRatio.clone(),
            androidMinAspectRatio: self.androidMinAspectRatio.clone(),
            androidMinimumWindowHeight: self.androidMinimumWindowHeight.clone(),
            androidMinimumWindowWidth: self.androidMinimumWindowWidth.clone(),
            androidPredictiveBackSupport: self.androidPredictiveBackSupport.clone(),
            androidRenderOutsideSafeArea: self.androidRenderOutsideSafeArea.clone(),
            androidResizableWindow: self.androidResizableWindow.clone(),
            androidResizeableActivity: self.androidResizeableActivity.clone(),
            androidShowActivityIndicatorOnLoading: self
                .androidShowActivityIndicatorOnLoading
                .clone(),
            androidStartInFullscreen: self.androidStartInFullscreen.clone(),
            androidSupportedAspectRatio: self.androidSupportedAspectRatio.clone(),
            androidUseSwappy: self.androidUseSwappy.clone(),
            androidVulkanAllowFilterList: self.androidVulkanAllowFilterList.clone(),
            androidVulkanDenyFilterList: self.androidVulkanDenyFilterList.clone(),
            bakeCollisionMeshes: self.bakeCollisionMeshes.clone(),
            bundleIdentifier: self.bundleIdentifier.clone(),
            bundleVersion: self.bundleVersion.clone(),
            captureSingleScreen: self.captureSingleScreen.clone(),
            cloudEnabled: self.cloudEnabled.clone(),
            cloudProjectId: self.cloudProjectId.clone(),
            companyName: self.companyName.clone(),
            cpuConfiguration: self.cpuConfiguration.clone(),
            cursorHotspot: self.cursorHotspot.clone(),
            d3d11ForceExclusiveMode: self.d3d11ForceExclusiveMode.clone(),
            d3d11FullscreenMode: self.d3d11FullscreenMode.clone(),
            d3d9FullscreenMode: self.d3d9FullscreenMode.clone(),
            debugUnloadMode: self.debugUnloadMode.clone(),
            dedicatedServerOptimizations: self.dedicatedServerOptimizations.clone(),
            defaultCursor: self.defaultCursor.clone(),
            defaultIsFullScreen: self.defaultIsFullScreen.clone(),
            defaultIsNativeResolution: self.defaultIsNativeResolution.clone(),
            defaultScreenHeight: self.defaultScreenHeight.clone(),
            defaultScreenHeightWeb: self.defaultScreenHeightWeb.clone(),
            defaultScreenOrientation: self.defaultScreenOrientation.clone(),
            defaultScreenWidth: self.defaultScreenWidth.clone(),
            defaultScreenWidthWeb: self.defaultScreenWidthWeb.clone(),
            deferSystemGesturesMode: self.deferSystemGesturesMode.clone(),
            disableDepthAndStencilBuffers: self.disableDepthAndStencilBuffers.clone(),
            disableOldInputManagerSupport: self.disableOldInputManagerSupport.clone(),
            displayResolutionDialog: self.displayResolutionDialog.clone(),
            enableFrameTimingStats: self.enableFrameTimingStats.clone(),
            enableGamepadInput: self.enableGamepadInput.clone(),
            enableHWStatistics: self.enableHWStatistics.clone(),
            enableNativePlatformBackendsForNewInputSystem: self
                .enableNativePlatformBackendsForNewInputSystem
                .clone(),
            enableNewInputSystem: self.enableNewInputSystem.clone(),
            enableOpenGLProfilerGPURecorders: self.enableOpenGLProfilerGPURecorders.clone(),
            forceSRGBBlit: self.forceSRGBBlit.clone(),
            forceSingleInstance: self.forceSingleInstance.clone(),
            framebufferDepthMemorylessMode: self.framebufferDepthMemorylessMode.clone(),
            fullscreenMode: self.fullscreenMode.clone(),
            gpuSkinning: self.gpuSkinning.clone(),
            graphicsJobMode: self.graphicsJobMode.clone(),
            graphicsJobs: self.graphicsJobs.clone(),
            hdrBitDepth: self.hdrBitDepth.clone(),
            hideHomeButton: self.hideHomeButton.clone(),
            hmiLoadingImage: self.hmiLoadingImage.clone(),
            iPhoneBundleIdentifier: self.iPhoneBundleIdentifier.clone(),
            ignoreAlphaClear: self.ignoreAlphaClear.clone(),
            insecureHttpOption: self.insecureHttpOption.clone(),
            invalidatedPatternTexture: self.invalidatedPatternTexture.clone(),
            iosAllowHTTPDownload: self.iosAllowHTTPDownload.clone(),
            iosAppInBackgroundBehavior: self.iosAppInBackgroundBehavior.clone(),
            iosShowActivityIndicatorOnLoading: self.iosShowActivityIndicatorOnLoading.clone(),
            iosUseCustomAppBackgroundBehavior: self.iosUseCustomAppBackgroundBehavior.clone(),
            isWsaHolographicRemotingEnabled: self.isWsaHolographicRemotingEnabled.clone(),
            legacyClampBlendShapeWeights: self.legacyClampBlendShapeWeights.clone(),
            loadStoreDebugModeEnabled: self.loadStoreDebugModeEnabled.clone(),
            m_ActiveColorSpace: self.m_ActiveColorSpace.clone(),
            m_ColorGamuts: self.m_ColorGamuts.clone(),
            m_HolographicPauseOnTrackingLoss: self.m_HolographicPauseOnTrackingLoss.clone(),
            m_HolographicTrackingLossScreen: self.m_HolographicTrackingLossScreen.clone(),
            m_MTRendering: self.m_MTRendering.clone(),
            m_MobileMTRendering: self.m_MobileMTRendering.clone(),
            m_MobileRenderingPath: self.m_MobileRenderingPath.clone(),
            m_RenderingPath: self.m_RenderingPath.clone(),
            m_ShowUnitySplashLogo: self.m_ShowUnitySplashLogo.clone(),
            m_ShowUnitySplashScreen: self.m_ShowUnitySplashScreen.clone(),
            m_SplashScreenAnimation: self.m_SplashScreenAnimation.clone(),
            m_SplashScreenBackgroundAnimationZoom: self
                .m_SplashScreenBackgroundAnimationZoom
                .clone(),
            m_SplashScreenBackgroundColor: self.m_SplashScreenBackgroundColor.clone(),
            m_SplashScreenBackgroundLandscape: self.m_SplashScreenBackgroundLandscape.clone(),
            m_SplashScreenBackgroundLandscapeAspect: self
                .m_SplashScreenBackgroundLandscapeAspect
                .clone(),
            m_SplashScreenBackgroundLandscapeUvs: self.m_SplashScreenBackgroundLandscapeUvs.clone(),
            m_SplashScreenBackgroundPortrait: self.m_SplashScreenBackgroundPortrait.clone(),
            m_SplashScreenBackgroundPortraitAspect: self
                .m_SplashScreenBackgroundPortraitAspect
                .clone(),
            m_SplashScreenBackgroundPortraitUvs: self.m_SplashScreenBackgroundPortraitUvs.clone(),
            m_SplashScreenDrawMode: self.m_SplashScreenDrawMode.clone(),
            m_SplashScreenLogoAnimationZoom: self.m_SplashScreenLogoAnimationZoom.clone(),
            m_SplashScreenLogoStyle: self.m_SplashScreenLogoStyle.clone(),
            m_SplashScreenLogos: self.m_SplashScreenLogos.clone(),
            m_SplashScreenOverlayOpacity: self.m_SplashScreenOverlayOpacity.clone(),
            m_SplashScreenStyle: self.m_SplashScreenStyle.clone(),
            m_SpriteBatchVertexThreshold: self.m_SpriteBatchVertexThreshold.clone(),
            m_StackTraceTypes: self.m_StackTraceTypes.clone(),
            m_StereoRenderingPath: self.m_StereoRenderingPath.clone(),
            m_Stereoscopic3D: self.m_Stereoscopic3D.clone(),
            m_SupportedAspectRatios: self.m_SupportedAspectRatios.clone(),
            m_UnitySplashLogo: self.m_UnitySplashLogo.clone(),
            m_UseDX11: self.m_UseDX11.clone(),
            m_VirtualRealitySplashScreen: self.m_VirtualRealitySplashScreen.clone(),
            macAppStoreCategory: self.macAppStoreCategory.clone(),
            macFullscreenMode: self.macFullscreenMode.clone(),
            macRetinaSupport: self.macRetinaSupport.clone(),
            meshDeformation: self.meshDeformation.clone(),
            metalFramebufferOnly: self.metalFramebufferOnly.clone(),
            metroEnableIndependentInputSource: self.metroEnableIndependentInputSource.clone(),
            metroEnableLowLatencyPresentationAPI: self.metroEnableLowLatencyPresentationAPI.clone(),
            metroInputSource: self.metroInputSource.clone(),
            mipStripping: self.mipStripping.clone(),
            mobileMTRenderingBaked: self.mobileMTRenderingBaked.clone(),
            muteOtherAudioSources: self.muteOtherAudioSources.clone(),
            n3dsDisableStereoscopicView: self.n3dsDisableStereoscopicView.clone(),
            n3dsEnableSharedListOpt: self.n3dsEnableSharedListOpt.clone(),
            n3dsEnableVSync: self.n3dsEnableVSync.clone(),
            numberOfMipsStripped: self.numberOfMipsStripped.clone(),
            numberOfMipsStrippedPerMipmapLimitGroup: self
                .numberOfMipsStrippedPerMipmapLimitGroup
                .clone(),
            organizationId: self.organizationId.clone(),
            platformRequiresReadableAssets: self.platformRequiresReadableAssets.clone(),
            playerDataPath: self.playerDataPath.clone(),
            playerMinOpenGLESVersion: self.playerMinOpenGLESVersion.clone(),
            preloadedAssets: self.preloadedAssets.clone(),
            preserveFramebufferAlpha: self.preserveFramebufferAlpha.clone(),
            productGUID: self.productGUID.clone(),
            productName: self.productName.clone(),
            projectId: self.projectId.clone(),
            projectName: self.projectName.clone(),
            protectGraphicsMemory: self.protectGraphicsMemory.clone(),
            ps3SplashScreen: self.ps3SplashScreen.clone(),
            psp2AcquireBGM: self.psp2AcquireBGM.clone(),
            psp2PowerMode: self.psp2PowerMode.clone(),
            qualitySettingsNames: self.qualitySettingsNames.clone(),
            resetResolutionOnWindowResize: self.resetResolutionOnWindowResize.clone(),
            resizableWindow: self.resizableWindow.clone(),
            resolutionScalingMode: self.resolutionScalingMode.clone(),
            runInBackground: self.runInBackground.clone(),
            singlePassStereoRendering: self.singlePassStereoRendering.clone(),
            stadiaPresentMode: self.stadiaPresentMode.clone(),
            stadiaTargetFramerate: self.stadiaTargetFramerate.clone(),
            stripPhysics: self.stripPhysics.clone(),
            submitAnalytics: self.submitAnalytics.clone(),
            switchAllowGpuScratchShrinking: self.switchAllowGpuScratchShrinking.clone(),
            switchGpuScratchPoolGranularity: self.switchGpuScratchPoolGranularity.clone(),
            switchMaxWorkerMultiple: self.switchMaxWorkerMultiple.clone(),
            switchNVNDefaultPoolsGranularity: self.switchNVNDefaultPoolsGranularity.clone(),
            switchNVNGraphicsFirmwareMemory: self.switchNVNGraphicsFirmwareMemory.clone(),
            switchNVNMaxPublicSamplerIDCount: self.switchNVNMaxPublicSamplerIDCount.clone(),
            switchNVNMaxPublicTextureIDCount: self.switchNVNMaxPublicTextureIDCount.clone(),
            switchNVNOtherPoolsGranularity: self.switchNVNOtherPoolsGranularity.clone(),
            switchNVNShaderPoolsGranularity: self.switchNVNShaderPoolsGranularity.clone(),
            switchQueueCommandMemory: self.switchQueueCommandMemory.clone(),
            switchQueueComputeMemory: self.switchQueueComputeMemory.clone(),
            switchQueueControlMemory: self.switchQueueControlMemory.clone(),
            targetDevice: self.targetDevice.clone(),
            targetGlesGraphics: self.targetGlesGraphics.clone(),
            targetIOSGraphics: self.targetIOSGraphics.clone(),
            targetPixelDensity: self.targetPixelDensity.clone(),
            targetPlatform: self.targetPlatform.clone(),
            targetResolution: self.targetResolution.clone(),
            tizenShowActivityIndicatorOnLoading: self.tizenShowActivityIndicatorOnLoading.clone(),
            tvOSBundleVersion: self.tvOSBundleVersion.clone(),
            uiUse16BitDepthBuffer: self.uiUse16BitDepthBuffer.clone(),
            unsupportedMSAAFallback: self.unsupportedMSAAFallback.clone(),
            uploadClearedTextureDataAfterCreationFromScript: self
                .uploadClearedTextureDataAfterCreationFromScript
                .clone(),
            use24BitDepthBuffer: self.use24BitDepthBuffer.clone(),
            use32BitDisplayBuffer: self.use32BitDisplayBuffer.clone(),
            useAlphaInDashboard: self.useAlphaInDashboard.clone(),
            useFlipModelSwapchain: self.useFlipModelSwapchain.clone(),
            useHDRDisplay: self.useHDRDisplay.clone(),
            useMacAppStoreValidation: self.useMacAppStoreValidation.clone(),
            useOSAutorotation: self.useOSAutorotation.clone(),
            useOnDemandResources: self.useOnDemandResources.clone(),
            usePlayerLog: self.usePlayerLog.clone(),
            videoMemoryForVertexBuffers: self.videoMemoryForVertexBuffers.clone(),
            virtualRealitySupported: self.virtualRealitySupported.clone(),
            virtualTexturingSupportEnabled: self.virtualTexturingSupportEnabled.clone(),
            visibleInBackground: self.visibleInBackground.clone(),
            visionOSBundleVersion: self.visionOSBundleVersion.clone(),
            vrSettings: self.vrSettings.clone(),
            vulkanEnableCommandBufferRecycling: self.vulkanEnableCommandBufferRecycling.clone(),
            vulkanEnableLateAcquireNextImage: self.vulkanEnableLateAcquireNextImage.clone(),
            vulkanEnablePreTransform: self.vulkanEnablePreTransform.clone(),
            vulkanEnableSetSRGBWrite: self.vulkanEnableSetSRGBWrite.clone(),
            vulkanNumSwapchainBuffers: self.vulkanNumSwapchainBuffers.clone(),
            vulkanUseSWCommandBuffers: self.vulkanUseSWCommandBuffers.clone(),
            wiiHio2Usage: self.wiiHio2Usage.clone(),
            wiiLoadingScreenBackground: self.wiiLoadingScreenBackground.clone(),
            wiiLoadingScreenFileName: self.wiiLoadingScreenFileName.clone(),
            wiiLoadingScreenPeriod: self.wiiLoadingScreenPeriod.clone(),
            wiiLoadingScreenRect: self.wiiLoadingScreenRect.clone(),
            wiiLoadingScreenRectPlacement: self.wiiLoadingScreenRectPlacement.clone(),
            wiiUAllowScreenCapture: self.wiiUAllowScreenCapture.clone(),
            wiiUControllerCount: self.wiiUControllerCount.clone(),
            wiiUGamePadMSAA: self.wiiUGamePadMSAA.clone(),
            wiiUSupportsBalanceBoard: self.wiiUSupportsBalanceBoard.clone(),
            wiiUSupportsClassicController: self.wiiUSupportsClassicController.clone(),
            wiiUSupportsMotionPlus: self.wiiUSupportsMotionPlus.clone(),
            wiiUSupportsNunchuk: self.wiiUSupportsNunchuk.clone(),
            wiiUSupportsProController: self.wiiUSupportsProController.clone(),
            wiiUTVResolution: self.wiiUTVResolution.clone(),
            windowsGamepadBackendHint: self.windowsGamepadBackendHint.clone(),
            wsaTransparentSwapchain: self.wsaTransparentSwapchain.clone(),
            xboxEnableAvatar: self.xboxEnableAvatar.clone(),
            xboxEnableEnableRenderThreadRunsJobs: self.xboxEnableEnableRenderThreadRunsJobs.clone(),
            xboxEnableFitness: self.xboxEnableFitness.clone(),
            xboxEnableGuest: self.xboxEnableGuest.clone(),
            xboxEnableHeadOrientation: self.xboxEnableHeadOrientation.clone(),
            xboxEnableKinect: self.xboxEnableKinect.clone(),
            xboxEnableKinectAutoTracking: self.xboxEnableKinectAutoTracking.clone(),
            xboxEnablePIXSampling: self.xboxEnablePIXSampling.clone(),
            xboxEnableSpeech: self.xboxEnableSpeech.clone(),
            xboxOneDisableEsram: self.xboxOneDisableEsram.clone(),
            xboxOneDisableKinectGpuReservation: self.xboxOneDisableKinectGpuReservation.clone(),
            xboxOneEnable7thCore: self.xboxOneEnable7thCore.clone(),
            xboxOneEnableTypeOptimization: self.xboxOneEnableTypeOptimization.clone(),
            xboxOneLoggingLevel: self.xboxOneLoggingLevel.clone(),
            xboxOneMonoLoggingLevel: self.xboxOneMonoLoggingLevel.clone(),
            xboxOnePresentImmediateThreshold: self.xboxOnePresentImmediateThreshold.clone(),
            xboxOneResolution: self.xboxOneResolution.clone(),
            xboxOneSResolution: self.xboxOneSResolution.clone(),
            xboxOneXResolution: self.xboxOneXResolution.clone(),
            xboxPIXTextureCapture: self.xboxPIXTextureCapture.clone(),
            xboxSkinOnGPU: self.xboxSkinOnGPU.clone(),
            xboxSpeechDB: self.xboxSpeechDB.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct QualitySettings {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub Beautiful: Option<QualitySetting>,
    pub Fantastic: Option<QualitySetting>,
    pub Fast: Option<QualitySetting>,
    pub Fastest: Option<QualitySetting>,
    pub Good: Option<QualitySetting>,
    pub Simple: Option<QualitySetting>,
    pub m_CurrentQuality: Option<i32>,
    pub m_DefaultMobileQuality: Option<i32>,
    pub m_DefaultStandaloneQuality: Option<i32>,
    pub m_DefaultWebPlayerQuality: Option<i32>,
    pub m_EditorQuality: Option<i32>,
    pub m_QualitySettings: Option<Vec<QualitySetting>>,
    pub m_StrippedMaximumLODLevel: Option<i32>,
    pub m_TextureMipmapLimitGroupNames: Option<Vec<String>>,
}

impl_object!(QualitySettings);

impl Clone for QualitySettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            Beautiful: self.Beautiful.clone(),
            Fantastic: self.Fantastic.clone(),
            Fast: self.Fast.clone(),
            Fastest: self.Fastest.clone(),
            Good: self.Good.clone(),
            Simple: self.Simple.clone(),
            m_CurrentQuality: self.m_CurrentQuality.clone(),
            m_DefaultMobileQuality: self.m_DefaultMobileQuality.clone(),
            m_DefaultStandaloneQuality: self.m_DefaultStandaloneQuality.clone(),
            m_DefaultWebPlayerQuality: self.m_DefaultWebPlayerQuality.clone(),
            m_EditorQuality: self.m_EditorQuality.clone(),
            m_QualitySettings: self.m_QualitySettings.clone(),
            m_StrippedMaximumLODLevel: self.m_StrippedMaximumLODLevel.clone(),
            m_TextureMipmapLimitGroupNames: self.m_TextureMipmapLimitGroupNames.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ResourceManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Container: Option<Vec<(String, PPtrData<Object>)>>,
    pub m_DependentAssets: Option<Vec<ResourceManager_Dependency>>,
}

impl_object!(ResourceManager);

impl Clone for ResourceManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Container: self.m_Container.clone(),
            m_DependentAssets: self.m_DependentAssets.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RuntimeInitializeOnLoadManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AfterAssembliesLoadedMethodExecutionOrders: Option<Vec<i32>>,
    pub m_AfterAssembliesLoadedUnityMethodExecutionOrders: Option<Vec<i32>>,
    pub m_AfterMethodExecutionOrders: Option<Vec<i32>>,
    pub m_AfterUnityMethodExecutionOrders: Option<Vec<i32>>,
    pub m_AssemblyNames: Option<Vec<String>>,
    pub m_BeforeMethodExecutionOrders: Option<Vec<i32>>,
    pub m_BeforeSplashScreenMethodExecutionOrders: Option<Vec<i32>>,
    pub m_BeforeSplashScreenUnityMethodExecutionOrders: Option<Vec<i32>>,
    pub m_BeforeUnityMethodExecutionOrders: Option<Vec<i32>>,
    pub m_ClassInfos: Option<Vec<ClassInfo>>,
    pub m_ClassMethodInfos: Option<Vec<ClassMethodInfo>>,
    pub m_MethodExecutionOrders: Option<Vec<i32>>,
    pub m_NamespaceNames: Option<Vec<String>>,
    pub m_SubsystemRegistrationMethodExecutionOrders: Option<Vec<i32>>,
    pub m_SubsystemRegistrationUnityMethodExecutionOrders: Option<Vec<i32>>,
    pub m_UnityMethodExecutionOrders: Option<Vec<i32>>,
}

impl_object!(RuntimeInitializeOnLoadManager);

impl Clone for RuntimeInitializeOnLoadManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AfterAssembliesLoadedMethodExecutionOrders: self
                .m_AfterAssembliesLoadedMethodExecutionOrders
                .clone(),
            m_AfterAssembliesLoadedUnityMethodExecutionOrders: self
                .m_AfterAssembliesLoadedUnityMethodExecutionOrders
                .clone(),
            m_AfterMethodExecutionOrders: self.m_AfterMethodExecutionOrders.clone(),
            m_AfterUnityMethodExecutionOrders: self.m_AfterUnityMethodExecutionOrders.clone(),
            m_AssemblyNames: self.m_AssemblyNames.clone(),
            m_BeforeMethodExecutionOrders: self.m_BeforeMethodExecutionOrders.clone(),
            m_BeforeSplashScreenMethodExecutionOrders: self
                .m_BeforeSplashScreenMethodExecutionOrders
                .clone(),
            m_BeforeSplashScreenUnityMethodExecutionOrders: self
                .m_BeforeSplashScreenUnityMethodExecutionOrders
                .clone(),
            m_BeforeUnityMethodExecutionOrders: self.m_BeforeUnityMethodExecutionOrders.clone(),
            m_ClassInfos: self.m_ClassInfos.clone(),
            m_ClassMethodInfos: self.m_ClassMethodInfos.clone(),
            m_MethodExecutionOrders: self.m_MethodExecutionOrders.clone(),
            m_NamespaceNames: self.m_NamespaceNames.clone(),
            m_SubsystemRegistrationMethodExecutionOrders: self
                .m_SubsystemRegistrationMethodExecutionOrders
                .clone(),
            m_SubsystemRegistrationUnityMethodExecutionOrders: self
                .m_SubsystemRegistrationUnityMethodExecutionOrders
                .clone(),
            m_UnityMethodExecutionOrders: self.m_UnityMethodExecutionOrders.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ShaderNameRegistry {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_PreloadShaders: Option<bool>,
    pub m_Shaders: Option<NameToObjectMap>,
}

impl_object!(ShaderNameRegistry);

impl Clone for ShaderNameRegistry {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_PreloadShaders: self.m_PreloadShaders.clone(),
            m_Shaders: self.m_Shaders.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct StreamingManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(StreamingManager);

impl Clone for StreamingManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TagManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub Builtin_Layer_0: Option<String>,
    pub Builtin_Layer_1: Option<String>,
    pub Builtin_Layer_2: Option<String>,
    pub Builtin_Layer_3: Option<String>,
    pub Builtin_Layer_4: Option<String>,
    pub Builtin_Layer_5: Option<String>,
    pub Builtin_Layer_6: Option<String>,
    pub Builtin_Layer_7: Option<String>,
    pub User_Layer_10: Option<String>,
    pub User_Layer_11: Option<String>,
    pub User_Layer_12: Option<String>,
    pub User_Layer_13: Option<String>,
    pub User_Layer_14: Option<String>,
    pub User_Layer_15: Option<String>,
    pub User_Layer_16: Option<String>,
    pub User_Layer_17: Option<String>,
    pub User_Layer_18: Option<String>,
    pub User_Layer_19: Option<String>,
    pub User_Layer_20: Option<String>,
    pub User_Layer_21: Option<String>,
    pub User_Layer_22: Option<String>,
    pub User_Layer_23: Option<String>,
    pub User_Layer_24: Option<String>,
    pub User_Layer_25: Option<String>,
    pub User_Layer_26: Option<String>,
    pub User_Layer_27: Option<String>,
    pub User_Layer_28: Option<String>,
    pub User_Layer_29: Option<String>,
    pub User_Layer_30: Option<String>,
    pub User_Layer_31: Option<String>,
    pub User_Layer_8: Option<String>,
    pub User_Layer_9: Option<String>,
    pub layers: Option<Vec<String>>,
    pub m_RenderingLayers: Option<Vec<String>>,
    pub m_SortingLayers: Option<Vec<SortingLayerEntry>>,
    pub tags: Option<Vec<String>>,
}

impl_object!(TagManager);

impl Clone for TagManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            Builtin_Layer_0: self.Builtin_Layer_0.clone(),
            Builtin_Layer_1: self.Builtin_Layer_1.clone(),
            Builtin_Layer_2: self.Builtin_Layer_2.clone(),
            Builtin_Layer_3: self.Builtin_Layer_3.clone(),
            Builtin_Layer_4: self.Builtin_Layer_4.clone(),
            Builtin_Layer_5: self.Builtin_Layer_5.clone(),
            Builtin_Layer_6: self.Builtin_Layer_6.clone(),
            Builtin_Layer_7: self.Builtin_Layer_7.clone(),
            User_Layer_10: self.User_Layer_10.clone(),
            User_Layer_11: self.User_Layer_11.clone(),
            User_Layer_12: self.User_Layer_12.clone(),
            User_Layer_13: self.User_Layer_13.clone(),
            User_Layer_14: self.User_Layer_14.clone(),
            User_Layer_15: self.User_Layer_15.clone(),
            User_Layer_16: self.User_Layer_16.clone(),
            User_Layer_17: self.User_Layer_17.clone(),
            User_Layer_18: self.User_Layer_18.clone(),
            User_Layer_19: self.User_Layer_19.clone(),
            User_Layer_20: self.User_Layer_20.clone(),
            User_Layer_21: self.User_Layer_21.clone(),
            User_Layer_22: self.User_Layer_22.clone(),
            User_Layer_23: self.User_Layer_23.clone(),
            User_Layer_24: self.User_Layer_24.clone(),
            User_Layer_25: self.User_Layer_25.clone(),
            User_Layer_26: self.User_Layer_26.clone(),
            User_Layer_27: self.User_Layer_27.clone(),
            User_Layer_28: self.User_Layer_28.clone(),
            User_Layer_29: self.User_Layer_29.clone(),
            User_Layer_30: self.User_Layer_30.clone(),
            User_Layer_31: self.User_Layer_31.clone(),
            User_Layer_8: self.User_Layer_8.clone(),
            User_Layer_9: self.User_Layer_9.clone(),
            layers: self.layers.clone(),
            m_RenderingLayers: self.m_RenderingLayers.clone(),
            m_SortingLayers: self.m_SortingLayers.clone(),
            tags: self.tags.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TimeManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub Fixed_Timestep: Option<RationalTime>,
    pub Maximum_Allowed_Timestep: Option<f32>,
    pub Maximum_Particle_Timestep: Option<f32>,
    pub m_TimeScale: Option<f32>,
}

impl_object!(TimeManager);

impl Clone for TimeManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            Fixed_Timestep: self.Fixed_Timestep.clone(),
            Maximum_Allowed_Timestep: self.Maximum_Allowed_Timestep.clone(),
            Maximum_Particle_Timestep: self.Maximum_Particle_Timestep.clone(),
            m_TimeScale: self.m_TimeScale.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct UnityAdsManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(UnityAdsManager);

impl Clone for UnityAdsManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct UnityAnalyticsManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<bool>,
    pub m_InitializeOnStartup: Option<bool>,
    pub m_TestConfigUrl: Option<String>,
    pub m_TestEventUrl: Option<String>,
    pub m_TestMode: Option<bool>,
}

impl_object!(UnityAnalyticsManager);

impl Clone for UnityAnalyticsManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_InitializeOnStartup: self.m_InitializeOnStartup.clone(),
            m_TestConfigUrl: self.m_TestConfigUrl.clone(),
            m_TestEventUrl: self.m_TestEventUrl.clone(),
            m_TestMode: self.m_TestMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct UnityConnectSettings {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub CrashReportingSettings: Option<CrashReportingSettings>,
    pub PerformanceReportingSettings: Option<PerformanceReportingSettings>,
    pub UnityAdsSettings: Option<UnityAdsSettings>,
    pub UnityAnalyticsSettings: Option<UnityAnalyticsSettings>,
    pub UnityPurchasingSettings: Option<UnityPurchasingSettings>,
    pub m_ConfigUrl: Option<String>,
    pub m_DashboardUrl: Option<String>,
    pub m_Enabled: Option<bool>,
    pub m_EventOldUrl: Option<String>,
    pub m_EventUrl: Option<String>,
    pub m_TestConfigUrl: Option<String>,
    pub m_TestEventUrl: Option<String>,
    pub m_TestInitMode: Option<i32>,
    pub m_TestMode: Option<bool>,
}

impl_object!(UnityConnectSettings);

impl Clone for UnityConnectSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            CrashReportingSettings: self.CrashReportingSettings.clone(),
            PerformanceReportingSettings: self.PerformanceReportingSettings.clone(),
            UnityAdsSettings: self.UnityAdsSettings.clone(),
            UnityAnalyticsSettings: self.UnityAnalyticsSettings.clone(),
            UnityPurchasingSettings: self.UnityPurchasingSettings.clone(),
            m_ConfigUrl: self.m_ConfigUrl.clone(),
            m_DashboardUrl: self.m_DashboardUrl.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_EventOldUrl: self.m_EventOldUrl.clone(),
            m_EventUrl: self.m_EventUrl.clone(),
            m_TestConfigUrl: self.m_TestConfigUrl.clone(),
            m_TestEventUrl: self.m_TestEventUrl.clone(),
            m_TestInitMode: self.m_TestInitMode.clone(),
            m_TestMode: self.m_TestMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BatchEmptyLifetime: Option<u32>,
    pub m_CompiledVersion: Option<u32>,
    pub m_CopyBufferShader: Option<PPtrData<ComputeShader>>,
    pub m_EmptyShader: Option<PPtrData<Shader>>,
    pub m_FixedTimeStep: Option<f32>,
    pub m_IndirectShader: Option<PPtrData<ComputeShader>>,
    pub m_MaxCapacity: Option<u32>,
    pub m_MaxDeltaTime: Option<f32>,
    pub m_MaxScrubTime: Option<f32>,
    pub m_RenderPipeSettingsPath: Option<String>,
    pub m_RuntimeResources: Option<PPtrData<MonoBehaviour>>,
    pub m_RuntimeVersion: Option<u32>,
    pub m_SortShader: Option<PPtrData<ComputeShader>>,
    pub m_StripUpdateShader: Option<PPtrData<ComputeShader>>,
}

impl_object!(VFXManager);

impl Clone for VFXManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BatchEmptyLifetime: self.m_BatchEmptyLifetime.clone(),
            m_CompiledVersion: self.m_CompiledVersion.clone(),
            m_CopyBufferShader: self.m_CopyBufferShader.clone(),
            m_EmptyShader: self.m_EmptyShader.clone(),
            m_FixedTimeStep: self.m_FixedTimeStep.clone(),
            m_IndirectShader: self.m_IndirectShader.clone(),
            m_MaxCapacity: self.m_MaxCapacity.clone(),
            m_MaxDeltaTime: self.m_MaxDeltaTime.clone(),
            m_MaxScrubTime: self.m_MaxScrubTime.clone(),
            m_RenderPipeSettingsPath: self.m_RenderPipeSettingsPath.clone(),
            m_RuntimeResources: self.m_RuntimeResources.clone(),
            m_RuntimeVersion: self.m_RuntimeVersion.clone(),
            m_SortShader: self.m_SortShader.clone(),
            m_StripUpdateShader: self.m_StripUpdateShader.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LevelGameManager {
    // extends GameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(LevelGameManager);

impl Clone for LevelGameManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HaloManager {
    // extends LevelGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(HaloManager);

impl Clone for HaloManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LightmapSettings {
    // extends LevelGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BakedColorSpace: Option<i32>,
    pub m_EnlightenSceneMapping: Option<EnlightenSceneMapping>,
    pub m_GISettings: Option<GISettings>,
    pub m_LightProbes: Option<PPtrData<LightProbes>>,
    pub m_LightingSettings: Option<PPtrData<LightingSettings>>,
    pub m_Lightmaps: Option<Vec<LightmapData>>,
    pub m_LightmapsMode: Option<i32>,
    pub m_RuntimeCPUUsage: Option<i32>,
    pub m_ShadowMaskMode: Option<i32>,
    pub m_UseDualLightmapsInForward: Option<bool>,
    pub m_UseShadowmask: Option<bool>,
}

impl_object!(LightmapSettings);

impl Clone for LightmapSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BakedColorSpace: self.m_BakedColorSpace.clone(),
            m_EnlightenSceneMapping: self.m_EnlightenSceneMapping.clone(),
            m_GISettings: self.m_GISettings.clone(),
            m_LightProbes: self.m_LightProbes.clone(),
            m_LightingSettings: self.m_LightingSettings.clone(),
            m_Lightmaps: self.m_Lightmaps.clone(),
            m_LightmapsMode: self.m_LightmapsMode.clone(),
            m_RuntimeCPUUsage: self.m_RuntimeCPUUsage.clone(),
            m_ShadowMaskMode: self.m_ShadowMaskMode.clone(),
            m_UseDualLightmapsInForward: self.m_UseDualLightmapsInForward.clone(),
            m_UseShadowmask: self.m_UseShadowmask.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NavMeshSettings {
    // extends LevelGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_NavMesh: Option<PPtrData<NavMesh>>,
    pub m_NavMeshData: Option<PPtrData<NavMeshData>>,
}

impl_object!(NavMeshSettings);

impl Clone for NavMeshSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_NavMesh: self.m_NavMesh.clone(),
            m_NavMeshData: self.m_NavMeshData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct OcclusionCullingSettings {
    // extends LevelGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_OcclusionCullingData: Option<PPtrData<OcclusionCullingData>>,
    pub m_Portals: Option<Vec<PPtrData<OcclusionPortal>>>,
    pub m_SceneGUID: Option<GUID>,
    pub m_StaticRenderers: Option<Vec<PPtrData<Renderer>>>,
}

impl_object!(OcclusionCullingSettings);

impl Clone for OcclusionCullingSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_OcclusionCullingData: self.m_OcclusionCullingData.clone(),
            m_Portals: self.m_Portals.clone(),
            m_SceneGUID: self.m_SceneGUID.clone(),
            m_StaticRenderers: self.m_StaticRenderers.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RenderSettings {
    // extends LevelGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AmbientEquatorColor: Option<Color>,
    pub m_AmbientGroundColor: Option<Color>,
    pub m_AmbientIntensity: Option<f32>,
    pub m_AmbientLight: Option<Color>,
    pub m_AmbientMode: Option<i32>,
    pub m_AmbientProbe: Option<SphericalHarmonicsL2>,
    pub m_AmbientProbeInGamma: Option<SphericalHarmonicsL2>,
    pub m_AmbientSkyColor: Option<Color>,
    pub m_CustomReflection: Option<PPtrData<Cubemap>>,
    pub m_DefaultReflectionMode: Option<i32>,
    pub m_DefaultReflectionResolution: Option<i32>,
    pub m_FlareFadeSpeed: Option<f32>,
    pub m_FlareStrength: Option<f32>,
    pub m_Fog: Option<bool>,
    pub m_FogColor: Option<Color>,
    pub m_FogDensity: Option<f32>,
    pub m_FogMode: Option<i32>,
    pub m_GeneratedSkyboxReflection: Option<PPtrData<Cubemap>>,
    pub m_HaloStrength: Option<f32>,
    pub m_HaloTexture: Option<PPtrData<Texture2D>>,
    pub m_IndirectSpecularColor: Option<Color>,
    pub m_LinearFogEnd: Option<f32>,
    pub m_LinearFogStart: Option<f32>,
    pub m_ReflectionBounces: Option<i32>,
    pub m_ReflectionIntensity: Option<f32>,
    pub m_SkyboxMaterial: Option<PPtrData<Material>>,
    pub m_SpotCookie: Option<PPtrData<Texture2D>>,
    pub m_SubtractiveShadowColor: Option<Color>,
    pub m_Sun: Option<PPtrData<Light>>,
    pub m_UseRadianceAmbientProbe: Option<bool>,
}

impl_object!(RenderSettings);

impl Clone for RenderSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AmbientEquatorColor: self.m_AmbientEquatorColor.clone(),
            m_AmbientGroundColor: self.m_AmbientGroundColor.clone(),
            m_AmbientIntensity: self.m_AmbientIntensity.clone(),
            m_AmbientLight: self.m_AmbientLight.clone(),
            m_AmbientMode: self.m_AmbientMode.clone(),
            m_AmbientProbe: self.m_AmbientProbe.clone(),
            m_AmbientProbeInGamma: self.m_AmbientProbeInGamma.clone(),
            m_AmbientSkyColor: self.m_AmbientSkyColor.clone(),
            m_CustomReflection: self.m_CustomReflection.clone(),
            m_DefaultReflectionMode: self.m_DefaultReflectionMode.clone(),
            m_DefaultReflectionResolution: self.m_DefaultReflectionResolution.clone(),
            m_FlareFadeSpeed: self.m_FlareFadeSpeed.clone(),
            m_FlareStrength: self.m_FlareStrength.clone(),
            m_Fog: self.m_Fog.clone(),
            m_FogColor: self.m_FogColor.clone(),
            m_FogDensity: self.m_FogDensity.clone(),
            m_FogMode: self.m_FogMode.clone(),
            m_GeneratedSkyboxReflection: self.m_GeneratedSkyboxReflection.clone(),
            m_HaloStrength: self.m_HaloStrength.clone(),
            m_HaloTexture: self.m_HaloTexture.clone(),
            m_IndirectSpecularColor: self.m_IndirectSpecularColor.clone(),
            m_LinearFogEnd: self.m_LinearFogEnd.clone(),
            m_LinearFogStart: self.m_LinearFogStart.clone(),
            m_ReflectionBounces: self.m_ReflectionBounces.clone(),
            m_ReflectionIntensity: self.m_ReflectionIntensity.clone(),
            m_SkyboxMaterial: self.m_SkyboxMaterial.clone(),
            m_SpotCookie: self.m_SpotCookie.clone(),
            m_SubtractiveShadowColor: self.m_SubtractiveShadowColor.clone(),
            m_Sun: self.m_Sun.clone(),
            m_UseRadianceAmbientProbe: self.m_UseRadianceAmbientProbe.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HierarchyState {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub expanded: Option<Vec<PPtrData<Object>>>,
    pub scrollposition_x: Option<f32>,
    pub scrollposition_y: Option<f32>,
    pub selection: Option<Vec<PPtrData<Object>>>,
}

impl_object!(HierarchyState);

impl Clone for HierarchyState {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            expanded: self.expanded.clone(),
            scrollposition_x: self.scrollposition_x.clone(),
            scrollposition_y: self.scrollposition_y.clone(),
            selection: self.selection.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct InspectorExpandedState {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ExpandedData: Option<Vec<ExpandedData>>,
}

impl_object!(InspectorExpandedState);

impl Clone for InspectorExpandedState {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ExpandedData: self.m_ExpandedData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MarshallingTestObject {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Prop: Option<i32>,
}

impl_object!(MarshallingTestObject);

impl Clone for MarshallingTestObject {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Prop: self.m_Prop.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MemorySettings {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(MemorySettings);

impl Clone for MemorySettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NScreenBridge {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(NScreenBridge);

impl Clone for NScreenBridge {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NativeObjectType {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Inner: Option<NativeType>,
}

impl_object!(NativeObjectType);

impl Clone for NativeObjectType {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Inner: self.m_Inner.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PackedAssets {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Contents: Option<Vec<BuildReportPackedAssetInfo>>,
    pub m_File: Option<u32>,
    pub m_Overhead: Option<u64>,
    pub m_ShortPath: Option<String>,
}

impl_object!(PackedAssets);

impl Clone for PackedAssets {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Contents: self.m_Contents.clone(),
            m_File: self.m_File.clone(),
            m_Overhead: self.m_Overhead.clone(),
            m_ShortPath: self.m_ShortPath.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PlatformModuleSetup {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub modules: Option<Vec<Module>>,
}

impl_object!(PlatformModuleSetup);

impl Clone for PlatformModuleSetup {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            modules: self.modules.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PluginBuildInfo {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_EditorPlugins: Option<Vec<String>>,
    pub m_RuntimePlugins: Option<Vec<String>>,
}

impl_object!(PluginBuildInfo);

impl Clone for PluginBuildInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_EditorPlugins: self.m_EditorPlugins.clone(),
            m_RuntimePlugins: self.m_RuntimePlugins.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Prefab {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ContainsMissingSerializeReferenceTypes: Option<bool>,
    pub m_HideFlagsBehaviour: Option<i32>,
    pub m_IsExploded: Option<bool>,
    pub m_IsPrefabAsset: Option<bool>,
    pub m_IsPrefabParent: Option<bool>,
    pub m_Modification: Option<PrefabModification>,
    pub m_ParentPrefab: Option<PPtrData<Prefab>>,
    pub m_RootGameObject: Option<PPtrData<GameObject>>,
    pub m_SourcePrefab: Option<PPtrData<Prefab>>,
}

impl_object!(Prefab);

impl Clone for Prefab {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ContainsMissingSerializeReferenceTypes: self
                .m_ContainsMissingSerializeReferenceTypes
                .clone(),
            m_HideFlagsBehaviour: self.m_HideFlagsBehaviour.clone(),
            m_IsExploded: self.m_IsExploded.clone(),
            m_IsPrefabAsset: self.m_IsPrefabAsset.clone(),
            m_IsPrefabParent: self.m_IsPrefabParent.clone(),
            m_Modification: self.m_Modification.clone(),
            m_ParentPrefab: self.m_ParentPrefab.clone(),
            m_RootGameObject: self.m_RootGameObject.clone(),
            m_SourcePrefab: self.m_SourcePrefab.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PrefabInstance {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Modification: Option<PrefabModification>,
    pub m_RootGameObject: Option<PPtrData<GameObject>>,
    pub m_SourcePrefab: Option<PPtrData<Prefab>>,
}

impl_object!(PrefabInstance);

impl Clone for PrefabInstance {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Modification: self.m_Modification.clone(),
            m_RootGameObject: self.m_RootGameObject.clone(),
            m_SourcePrefab: self.m_SourcePrefab.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PresetManager {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DefaultList: Option<Vec<DefaultPresetList>>,
    pub m_DefaultPresets: Option<Vec<(PresetType, Vec<DefaultPreset>)>>,
}

impl_object!(PresetManager);

impl Clone for PresetManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DefaultList: self.m_DefaultList.clone(),
            m_DefaultPresets: self.m_DefaultPresets.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PropertyModificationsTargetTestObject {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub byte_data: Option<Vec<u8>>,
    pub m_Array: Option<Vec<PropertyModificationsTargetTestNativeObject>>,
    pub m_Bytes: Option<Vec<u8>>,
    pub m_BytesSize: Option<u32>,
    pub m_Data: Option<PropertyModificationsTargetTestNativeObject>,
    pub m_FloatTestValue: Option<f32>,
    pub m_Floats: Option<Vec<f32>>,
}

impl_object!(PropertyModificationsTargetTestObject);

impl Clone for PropertyModificationsTargetTestObject {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            byte_data: self.byte_data.clone(),
            m_Array: self.m_Array.clone(),
            m_Bytes: self.m_Bytes.clone(),
            m_BytesSize: self.m_BytesSize.clone(),
            m_Data: self.m_Data.clone(),
            m_FloatTestValue: self.m_FloatTestValue.clone(),
            m_Floats: self.m_Floats.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RenderPassAttachment {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(RenderPassAttachment);

impl Clone for RenderPassAttachment {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SceneRoots {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Roots: Option<Vec<PPtrData<Object>>>,
}

impl_object!(SceneRoots);

impl Clone for SceneRoots {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Roots: self.m_Roots.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SceneVisibilityState {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_IsolationMode: Option<bool>,
    pub m_MainStageIsolated: Option<bool>,
    pub m_PrefabStageIsolated: Option<bool>,
    pub m_SceneData: Option<Vec<(SceneIdentifier, SceneVisibilityData)>>,
    pub m_ScenePickingData: Option<SceneDataContainer>,
    pub m_SceneVisibilityData: Option<SceneDataContainer>,
    pub m_SceneVisibilityDataIsolated: Option<SceneDataContainer>,
}

impl_object!(SceneVisibilityState);

impl Clone for SceneVisibilityState {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_IsolationMode: self.m_IsolationMode.clone(),
            m_MainStageIsolated: self.m_MainStageIsolated.clone(),
            m_PrefabStageIsolated: self.m_PrefabStageIsolated.clone(),
            m_SceneData: self.m_SceneData.clone(),
            m_ScenePickingData: self.m_ScenePickingData.clone(),
            m_SceneVisibilityData: self.m_SceneVisibilityData.clone(),
            m_SceneVisibilityDataIsolated: self.m_SceneVisibilityDataIsolated.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ScenesUsingAssets {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ListOfScenesUsingEachAsset: Option<Vec<(String, Vec<String>)>>,
    pub m_ScenesUsingAssets: Option<Vec<BuildReportScenesUsingAsset>>,
}

impl_object!(ScenesUsingAssets);

impl Clone for ScenesUsingAssets {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ListOfScenesUsingEachAsset: self.m_ListOfScenesUsingEachAsset.clone(),
            m_ScenesUsingAssets: self.m_ScenesUsingAssets.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializableManagedHost {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Script: Option<PPtrData<MonoScript>>,
}

impl_object!(SerializableManagedHost);

impl Clone for SerializableManagedHost {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Script: self.m_Script.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializableManagedRefTestClass {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Script: Option<PPtrData<MonoScript>>,
}

impl_object!(SerializableManagedRefTestClass);

impl Clone for SerializableManagedRefTestClass {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Script: self.m_Script.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ShaderContainer {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(ShaderContainer);

impl Clone for ShaderContainer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SiblingDerived {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(SiblingDerived);

impl Clone for SiblingDerived {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteAtlasDatabase {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(SpriteAtlasDatabase);

impl Clone for SpriteAtlasDatabase {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TestObjectVectorPairStringBool {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Map: Option<Vec<(String, bool)>>,
    pub m_String: Option<String>,
}

impl_object!(TestObjectVectorPairStringBool);

impl Clone for TestObjectVectorPairStringBool {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Map: self.m_Map.clone(),
            m_String: self.m_String.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TestObjectWithSerializedAnimationCurve {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Curve: Option<AnimationCurve>,
}

impl_object!(TestObjectWithSerializedAnimationCurve);

impl Clone for TestObjectWithSerializedAnimationCurve {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Curve: self.m_Curve.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TestObjectWithSerializedArray {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ClampTestValue: Option<f32>,
    pub m_IntegerArray: Option<Vec<i32>>,
}

impl_object!(TestObjectWithSerializedArray);

impl Clone for TestObjectWithSerializedArray {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ClampTestValue: self.m_ClampTestValue.clone(),
            m_IntegerArray: self.m_IntegerArray.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TestObjectWithSerializedMapStringBool {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Map: Option<Vec<(String, bool)>>,
    pub m_String: Option<String>,
}

impl_object!(TestObjectWithSerializedMapStringBool);

impl Clone for TestObjectWithSerializedMapStringBool {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Map: self.m_Map.clone(),
            m_String: self.m_String.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TestObjectWithSerializedMapStringNonAlignedStruct {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Map: Option<Vec<(String, NonAlignedStruct)>>,
    pub m_String: Option<String>,
}

impl_object!(TestObjectWithSerializedMapStringNonAlignedStruct);

impl Clone for TestObjectWithSerializedMapStringNonAlignedStruct {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Map: self.m_Map.clone(),
            m_String: self.m_String.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TestObjectWithSpecialLayoutOne {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub differentLayout: Option<LayoutDataOne>,
    pub sameLayout: Option<LayoutDataOne>,
}

impl_object!(TestObjectWithSpecialLayoutOne);

impl Clone for TestObjectWithSpecialLayoutOne {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            differentLayout: self.differentLayout.clone(),
            sameLayout: self.sameLayout.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TestObjectWithSpecialLayoutTwo {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub differentLayout: Option<LayoutDataTwo>,
    pub sameLayout: Option<LayoutDataThree>,
}

impl_object!(TestObjectWithSpecialLayoutTwo);

impl Clone for TestObjectWithSpecialLayoutTwo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            differentLayout: self.differentLayout.clone(),
            sameLayout: self.sameLayout.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TilemapEditorUserSettings {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_FocusMode: Option<i32>,
    pub m_LastUsedPalette: Option<PPtrData<GameObject>>,
}

impl_object!(TilemapEditorUserSettings);

impl Clone for TilemapEditorUserSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_FocusMode: self.m_FocusMode.clone(),
            m_LastUsedPalette: self.m_LastUsedPalette.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VersionControlSettings {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CollabEditorSettings: Option<CollabEditorSettings>,
    pub m_Mode: Option<String>,
    pub m_TrackPackagesOutsideProject: Option<bool>,
}

impl_object!(VersionControlSettings);

impl Clone for VersionControlSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CollabEditorSettings: self.m_CollabEditorSettings.clone(),
            m_Mode: self.m_Mode.clone(),
            m_TrackPackagesOutsideProject: self.m_TrackPackagesOutsideProject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VideoBuildInfo {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_IsVideoModuleDisabled: Option<bool>,
    pub m_VideoClipCount: Option<i32>,
}

impl_object!(VideoBuildInfo);

impl Clone for VideoBuildInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_IsVideoModuleDisabled: self.m_IsVideoModuleDisabled.clone(),
            m_VideoClipCount: self.m_VideoClipCount.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AABB {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Center: Option<Vector3>,
    pub m_Extent: Option<Vector3>,
}

impl_object!(AABB);

impl Clone for AABB {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Center: self.m_Center.clone(),
            m_Extent: self.m_Extent.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AddedComponent {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub addedObject: Option<PPtrData<Component>>,
    pub insertIndex: Option<i32>,
    pub targetCorrespondingSourceObject: Option<PPtrData<GameObject>>,
}

impl_object!(AddedComponent);

impl Clone for AddedComponent {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            addedObject: self.addedObject.clone(),
            insertIndex: self.insertIndex.clone(),
            targetCorrespondingSourceObject: self.targetCorrespondingSourceObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AddedGameObject {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub addedObject: Option<PPtrData<Transform>>,
    pub insertIndex: Option<i32>,
    pub targetCorrespondingSourceObject: Option<PPtrData<Transform>>,
}

impl_object!(AddedGameObject);

impl Clone for AddedGameObject {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            addedObject: self.addedObject.clone(),
            insertIndex: self.insertIndex.clone(),
            targetCorrespondingSourceObject: self.targetCorrespondingSourceObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AndroidDeviceFilterData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub androidOsVersionString: Option<String>,
    pub brandName: Option<String>,
    pub deviceName: Option<String>,
    pub driverVersionString: Option<String>,
    pub productName: Option<String>,
    pub vendorName: Option<String>,
    pub vulkanApiVersionString: Option<String>,
}

impl_object!(AndroidDeviceFilterData);

impl Clone for AndroidDeviceFilterData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            androidOsVersionString: self.androidOsVersionString.clone(),
            brandName: self.brandName.clone(),
            deviceName: self.deviceName.clone(),
            driverVersionString: self.driverVersionString.clone(),
            productName: self.productName.clone(),
            vendorName: self.vendorName.clone(),
            vulkanApiVersionString: self.vulkanApiVersionString.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnimationClipBindingConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub genericBindings: Option<Vec<GenericBinding>>,
    pub pptrCurveMapping: Option<Vec<PPtrData<Object>>>,
}

impl_object!(AnimationClipBindingConstant);

impl Clone for AnimationClipBindingConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            genericBindings: self.genericBindings.clone(),
            pptrCurveMapping: self.pptrCurveMapping.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnimationClipOverride {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_OriginalClip: Option<PPtrData<AnimationClip>>,
    pub m_OverrideClip: Option<PPtrData<AnimationClip>>,
}

impl_object!(AnimationClipOverride);

impl Clone for AnimationClipOverride {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_OriginalClip: self.m_OriginalClip.clone(),
            m_OverrideClip: self.m_OverrideClip.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnimationCurve {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Curve: Option<Vec<Keyframe>>,
    pub m_PostInfinity: Option<i32>,
    pub m_PreInfinity: Option<i32>,
    pub m_RotationOrder: Option<i32>,
}

impl_object!(AnimationCurve);

impl Clone for AnimationCurve {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Curve: self.m_Curve.clone(),
            m_PostInfinity: self.m_PostInfinity.clone(),
            m_PreInfinity: self.m_PreInfinity.clone(),
            m_RotationOrder: self.m_RotationOrder.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnimationEvent {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub data: Option<String>,
    pub floatParameter: Option<f32>,
    pub functionName: Option<String>,
    pub intParameter: Option<i32>,
    pub messageOptions: Option<i32>,
    pub objectReferenceParameter: Option<PPtrData<Object>>,
    pub time: Option<f32>,
}

impl_object!(AnimationEvent);

impl Clone for AnimationEvent {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            data: self.data.clone(),
            floatParameter: self.floatParameter.clone(),
            functionName: self.functionName.clone(),
            intParameter: self.intParameter.clone(),
            messageOptions: self.messageOptions.clone(),
            objectReferenceParameter: self.objectReferenceParameter.clone(),
            time: self.time.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AnimatorCondition {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ConditionEvent: Option<String>,
    pub m_ConditionMode: Option<i32>,
    pub m_EventTreshold: Option<f32>,
}

impl_object!(AnimatorCondition);

impl Clone for AnimatorCondition {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ConditionEvent: self.m_ConditionEvent.clone(),
            m_ConditionMode: self.m_ConditionMode.clone(),
            m_EventTreshold: self.m_EventTreshold.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Annotation {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ClassID: Option<i32>,
    pub m_Flags: Option<i32>,
    pub m_GizmoEnabled: Option<bool>,
    pub m_IconEnabled: Option<bool>,
    pub m_ScriptClass: Option<String>,
}

impl_object!(Annotation);

impl Clone for Annotation {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ClassID: self.m_ClassID.clone(),
            m_Flags: self.m_Flags.clone(),
            m_GizmoEnabled: self.m_GizmoEnabled.clone(),
            m_IconEnabled: self.m_IconEnabled.clone(),
            m_ScriptClass: self.m_ScriptClass.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ArticulationDrive {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub damping: Option<f32>,
    pub driveType: Option<i32>,
    pub forceLimit: Option<f32>,
    pub lowerLimit: Option<f32>,
    pub stiffness: Option<f32>,
    pub target: Option<f32>,
    pub targetVelocity: Option<f32>,
    pub upperLimit: Option<f32>,
}

impl_object!(ArticulationDrive);

impl Clone for ArticulationDrive {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            damping: self.damping.clone(),
            driveType: self.driveType.clone(),
            forceLimit: self.forceLimit.clone(),
            lowerLimit: self.lowerLimit.clone(),
            stiffness: self.stiffness.clone(),
            target: self.target.clone(),
            targetVelocity: self.targetVelocity.clone(),
            upperLimit: self.upperLimit.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AspectRatios {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub Others: Option<bool>,
    pub x16_10: Option<bool>,
    pub x16_9: Option<bool>,
    pub x4_3: Option<bool>,
    pub x5_4: Option<bool>,
}

impl_object!(AspectRatios);

impl Clone for AspectRatios {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            Others: self.Others.clone(),
            x16_10: self.x16_10.clone(),
            x16_9: self.x16_9.clone(),
            x4_3: self.x4_3.clone(),
            x5_4: self.x5_4.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssemblyJsonAsset {
    // extends TextAsset
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
    pub m_PathName: Option<String>,
    pub m_Script: Option<String>,
}

impl_object!(AssemblyJsonAsset);

impl Clone for AssemblyJsonAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
            m_PathName: self.m_PathName.clone(),
            m_Script: self.m_Script.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssemblyJsonImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
    pub m_ExternalObjects: Option<Vec<(SourceAssetIdentifier, PPtrData<Object>)>>,
    pub m_Name: Option<String>,
    pub m_UserData: Option<String>,
}

impl_object!(AssemblyJsonImporter);

impl Clone for AssemblyJsonImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
            m_ExternalObjects: self.m_ExternalObjects.clone(),
            m_Name: self.m_Name.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Asset {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub assetBundleIndex: Option<i32>,
    pub children: Option<Vec<GUID>>,
    pub digest: Option<MdFour>,
    pub guidOfPathLocationDependencies: Option<Vec<(GUID, String)>>,
    pub hash: Option<Hash128>,
    pub hashOfImportedAssetDependencies: Option<Vec<GUID>>,
    pub hashOfSourceAssetDependencies: Option<Vec<GUID>>,
    pub importerClassId: Option<i32>,
    pub importerVersionHash: Option<u32>,
    pub labels: Option<AssetLabels>,
    pub mainRepresentation: Option<LibraryRepresentation>,
    pub metaModificationDate_0_: Option<u32>,
    pub metaModificationDate_1_: Option<u32>,
    pub modificationDate_0_: Option<u32>,
    pub modificationDate_1_: Option<u32>,
    pub parent: Option<GUID>,
    pub representations: Option<Vec<LibraryRepresentation>>,
    pub scriptedImporterClassID: Option<String>,
    pub typ: Option<i32>,
}

impl_object!(Asset);

impl Clone for Asset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            assetBundleIndex: self.assetBundleIndex.clone(),
            children: self.children.clone(),
            digest: self.digest.clone(),
            guidOfPathLocationDependencies: self.guidOfPathLocationDependencies.clone(),
            hash: self.hash.clone(),
            hashOfImportedAssetDependencies: self.hashOfImportedAssetDependencies.clone(),
            hashOfSourceAssetDependencies: self.hashOfSourceAssetDependencies.clone(),
            importerClassId: self.importerClassId.clone(),
            importerVersionHash: self.importerVersionHash.clone(),
            labels: self.labels.clone(),
            mainRepresentation: self.mainRepresentation.clone(),
            metaModificationDate_0_: self.metaModificationDate_0_.clone(),
            metaModificationDate_1_: self.metaModificationDate_1_.clone(),
            modificationDate_0_: self.modificationDate_0_.clone(),
            modificationDate_1_: self.modificationDate_1_.clone(),
            parent: self.parent.clone(),
            representations: self.representations.clone(),
            scriptedImporterClassID: self.scriptedImporterClassID.clone(),
            typ: self.typ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetBundleFullName {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleName: Option<String>,
    pub m_AssetBundleVariant: Option<String>,
}

impl_object!(AssetBundleFullName);

impl Clone for AssetBundleFullName {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleName: self.m_AssetBundleName.clone(),
            m_AssetBundleVariant: self.m_AssetBundleVariant.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetBundleInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub AssetBundleDependencies: Option<Vec<i32>>,
    pub AssetBundleHash: Option<Hash128>,
}

impl_object!(AssetBundleInfo);

impl Clone for AssetBundleInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            AssetBundleDependencies: self.AssetBundleDependencies.clone(),
            AssetBundleHash: self.AssetBundleHash.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetBundleScriptInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub assemblyName: Option<String>,
    pub className: Option<String>,
    pub hash: Option<u32>,
    pub nameSpace: Option<String>,
}

impl_object!(AssetBundleScriptInfo);

impl Clone for AssetBundleScriptInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            assemblyName: self.assemblyName.clone(),
            className: self.className.clone(),
            hash: self.hash.clone(),
            nameSpace: self.nameSpace.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetDatabase {
    // extends Object
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssetBundleNames: Option<Vec<(i32, AssetBundleFullName)>>,
    pub m_AssetTimeStamps: Option<Vec<(String, AssetTimeStamp)>>,
    pub m_Assets: Option<Vec<(GUID, Asset)>>,
    pub m_Metrics: Option<AssetDatabaseMetrics>,
    pub m_UnityShadersVersion: Option<i32>,
    pub m_lastValidVersionHashes: Option<Vec<(i32, u32)>>,
}

impl_object!(AssetDatabase);

impl Clone for AssetDatabase {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssetBundleNames: self.m_AssetBundleNames.clone(),
            m_AssetTimeStamps: self.m_AssetTimeStamps.clone(),
            m_Assets: self.m_Assets.clone(),
            m_Metrics: self.m_Metrics.clone(),
            m_UnityShadersVersion: self.m_UnityShadersVersion.clone(),
            m_lastValidVersionHashes: self.m_lastValidVersionHashes.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetDatabaseMetrics {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub nonProAssetCount: Option<i32>,
    pub nonProAssetsCreatedAfterProLicense: Option<i32>,
    pub totalAssetCount: Option<i32>,
}

impl_object!(AssetDatabaseMetrics);

impl Clone for AssetDatabaseMetrics {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            nonProAssetCount: self.nonProAssetCount.clone(),
            nonProAssetsCreatedAfterProLicense: self.nonProAssetsCreatedAfterProLicense.clone(),
            totalAssetCount: self.totalAssetCount.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetImporterHashKey {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub ScriptClass: Option<String>,
    pub typ: Option<u32>,
}

impl_object!(AssetImporterHashKey);

impl Clone for AssetImporterHashKey {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            ScriptClass: self.ScriptClass.clone(),
            typ: self.typ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetImporterLog {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Logs: Option<Vec<AssetImporter_ImportError>>,
    pub m_Name: Option<String>,
}

impl_object!(AssetImporterLog);

impl Clone for AssetImporterLog {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Logs: self.m_Logs.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetImporter_ImportError {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub error: Option<String>,
    pub file: Option<String>,
    pub line: Option<i32>,
    pub mode: Option<i32>,
    pub object: Option<PPtrData<Object>>,
}

impl_object!(AssetImporter_ImportError);

impl Clone for AssetImporter_ImportError {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            error: self.error.clone(),
            file: self.file.clone(),
            line: self.line.clone(),
            mode: self.mode.clone(),
            object: self.object.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub asset: Option<PPtrData<Object>>,
    pub preloadIndex: Option<i32>,
    pub preloadSize: Option<i32>,
}

impl_object!(AssetInfo);

impl Clone for AssetInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            asset: self.asset.clone(),
            preloadIndex: self.preloadIndex.clone(),
            preloadSize: self.preloadSize.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetLabels {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Labels: Option<Vec<String>>,
}

impl_object!(AssetLabels);

impl Clone for AssetLabels {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Labels: self.m_Labels.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AssetTimeStamp {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub metaModificationDate_0_: Option<u32>,
    pub metaModificationDate_1_: Option<u32>,
    pub modificationDate_0_: Option<u32>,
    pub modificationDate_1_: Option<u32>,
}

impl_object!(AssetTimeStamp);

impl Clone for AssetTimeStamp {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            metaModificationDate_0_: self.metaModificationDate_0_.clone(),
            metaModificationDate_1_: self.metaModificationDate_1_.clone(),
            modificationDate_0_: self.modificationDate_0_.clone(),
            modificationDate_1_: self.modificationDate_1_.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AttachmentIndexArray {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub activeAttachments: Option<i32>,
    pub attachments: Option<Vec<i32>>,
}

impl_object!(AttachmentIndexArray);

impl Clone for AttachmentIndexArray {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            activeAttachments: self.activeAttachments.clone(),
            attachments: self.attachments.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AttachmentInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub format: Option<i32>,
    pub needsResolve: Option<bool>,
}

impl_object!(AttachmentInfo);

impl Clone for AttachmentInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            format: self.format.clone(),
            needsResolve: self.needsResolve.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioImporterOutput {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub editorOutputContainerFormat: Option<i32>,
    pub editorOutputSettings: Option<SampleSettings>,
    pub outputContainerFormat: Option<i32>,
    pub outputSettings: Option<SampleSettings>,
    pub playerResource: Option<StreamedResource>,
}

impl_object!(AudioImporterOutput);

impl Clone for AudioImporterOutput {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            editorOutputContainerFormat: self.editorOutputContainerFormat.clone(),
            editorOutputSettings: self.editorOutputSettings.clone(),
            outputContainerFormat: self.outputContainerFormat.clone(),
            outputSettings: self.outputSettings.clone(),
            playerResource: self.playerResource.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioMixerConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub effectGUIDs: Option<Vec<GUID>>,
    pub effects: Option<Vec<EffectConstant>>,
    pub exposedParameterIndices: Option<Vec<u32>>,
    pub exposedParameterNames: Option<Vec<u32>>,
    pub groupConnections: Option<Vec<GroupConnection>>,
    pub groupGUIDs: Option<Vec<GUID>>,
    pub groupNameBuffer: Option<Vec<i8>>,
    pub groups: Option<Vec<GroupConstant>>,
    pub numSideChainBuffers: Option<u32>,
    pub pluginEffectNameBuffer: Option<Vec<i8>>,
    pub snapshotGUIDs: Option<Vec<GUID>>,
    pub snapshotNameBuffer: Option<Vec<i8>>,
    pub snapshots: Option<Vec<SnapshotConstant>>,
}

impl_object!(AudioMixerConstant);

impl Clone for AudioMixerConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            effectGUIDs: self.effectGUIDs.clone(),
            effects: self.effects.clone(),
            exposedParameterIndices: self.exposedParameterIndices.clone(),
            exposedParameterNames: self.exposedParameterNames.clone(),
            groupConnections: self.groupConnections.clone(),
            groupGUIDs: self.groupGUIDs.clone(),
            groupNameBuffer: self.groupNameBuffer.clone(),
            groups: self.groups.clone(),
            numSideChainBuffers: self.numSideChainBuffers.clone(),
            pluginEffectNameBuffer: self.pluginEffectNameBuffer.clone(),
            snapshotGUIDs: self.snapshotGUIDs.clone(),
            snapshotNameBuffer: self.snapshotNameBuffer.clone(),
            snapshots: self.snapshots.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioMixerLiveUpdateBool {
    // extends
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(AudioMixerLiveUpdateBool);

impl Clone for AudioMixerLiveUpdateBool {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AudioMixerLiveUpdateFloat {
    // extends
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(AudioMixerLiveUpdateFloat);

impl Clone for AudioMixerLiveUpdateFloat {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AutoOffMeshLinkData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Area: Option<u8>,
    pub m_End: Option<Vector3>,
    pub m_LinkDirection: Option<u8>,
    pub m_LinkType: Option<u16>,
    pub m_Radius: Option<f32>,
    pub m_Start: Option<Vector3>,
}

impl_object!(AutoOffMeshLinkData);

impl Clone for AutoOffMeshLinkData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Area: self.m_Area.clone(),
            m_End: self.m_End.clone(),
            m_LinkDirection: self.m_LinkDirection.clone(),
            m_LinkType: self.m_LinkType.clone(),
            m_Radius: self.m_Radius.clone(),
            m_Start: self.m_Start.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AvatarBodyMask {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Mask: Option<Vec<u32>>,
    pub m_Name: Option<String>,
}

impl_object!(AvatarBodyMask);

impl Clone for AvatarBodyMask {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Mask: self.m_Mask.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AvatarConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AvatarSkeleton: Option<OffsetPtr>,
    pub m_AvatarSkeletonPose: Option<OffsetPtr>,
    pub m_DefaultPose: Option<OffsetPtr>,
    pub m_Human: Option<OffsetPtr>,
    pub m_HumanSkeletonIndexArray: Option<Vec<i32>>,
    pub m_HumanSkeletonReverseIndexArray: Option<Vec<i32>>,
    pub m_RootMotionBoneIndex: Option<i32>,
    pub m_RootMotionBoneX: Option<xform>,
    pub m_RootMotionSkeleton: Option<OffsetPtr>,
    pub m_RootMotionSkeletonIndexArray: Option<Vec<i32>>,
    pub m_RootMotionSkeletonPose: Option<OffsetPtr>,
    pub m_Skeleton: Option<OffsetPtr>,
    pub m_SkeletonNameIDArray: Option<Vec<u32>>,
    pub m_SkeletonPose: Option<OffsetPtr>,
}

impl_object!(AvatarConstant);

impl Clone for AvatarConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AvatarSkeleton: self.m_AvatarSkeleton.clone(),
            m_AvatarSkeletonPose: self.m_AvatarSkeletonPose.clone(),
            m_DefaultPose: self.m_DefaultPose.clone(),
            m_Human: self.m_Human.clone(),
            m_HumanSkeletonIndexArray: self.m_HumanSkeletonIndexArray.clone(),
            m_HumanSkeletonReverseIndexArray: self.m_HumanSkeletonReverseIndexArray.clone(),
            m_RootMotionBoneIndex: self.m_RootMotionBoneIndex.clone(),
            m_RootMotionBoneX: self.m_RootMotionBoneX.clone(),
            m_RootMotionSkeleton: self.m_RootMotionSkeleton.clone(),
            m_RootMotionSkeletonIndexArray: self.m_RootMotionSkeletonIndexArray.clone(),
            m_RootMotionSkeletonPose: self.m_RootMotionSkeletonPose.clone(),
            m_Skeleton: self.m_Skeleton.clone(),
            m_SkeletonNameIDArray: self.m_SkeletonNameIDArray.clone(),
            m_SkeletonPose: self.m_SkeletonPose.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct AvatarSkeletonMaskElement {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub path: Option<String>,
    pub weight: Option<f32>,
}

impl_object!(AvatarSkeletonMaskElement);

impl Clone for AvatarSkeletonMaskElement {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            path: self.path.clone(),
            weight: self.weight.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Axes {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Length: Option<f32>,
    pub m_Limit: Option<Limit>,
    pub m_PostQ: Option<Vector4>,
    pub m_PreQ: Option<Vector4>,
    pub m_Sgn: Option<Vector3>,
    pub m_Type: Option<u32>,
}

impl_object!(Axes);

impl Clone for Axes {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Length: self.m_Length.clone(),
            m_Limit: self.m_Limit.clone(),
            m_PostQ: self.m_PostQ.clone(),
            m_PreQ: self.m_PreQ.clone(),
            m_Sgn: self.m_Sgn.clone(),
            m_Type: self.m_Type.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BitField {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Bits: Option<u32>,
}

impl_object!(BitField);

impl Clone for BitField {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Bits: self.m_Bits.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Blend1dDataConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ChildThresholdArray: Option<Vec<f32>>,
}

impl_object!(Blend1dDataConstant);

impl Clone for Blend1dDataConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ChildThresholdArray: self.m_ChildThresholdArray.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Blend2dDataConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ChildMagnitudeArray: Option<Vec<f32>>,
    pub m_ChildNeighborListArray: Option<Vec<MotionNeighborList>>,
    pub m_ChildPairAvgMagInvArray: Option<Vec<f32>>,
    pub m_ChildPairVectorArray: Option<Vec<Vector2>>,
    pub m_ChildPositionArray: Option<Vec<Vector2>>,
    pub m_ChildThresholdArray: Option<Vec<f32>>,
}

impl_object!(Blend2dDataConstant);

impl Clone for Blend2dDataConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ChildMagnitudeArray: self.m_ChildMagnitudeArray.clone(),
            m_ChildNeighborListArray: self.m_ChildNeighborListArray.clone(),
            m_ChildPairAvgMagInvArray: self.m_ChildPairAvgMagInvArray.clone(),
            m_ChildPairVectorArray: self.m_ChildPairVectorArray.clone(),
            m_ChildPositionArray: self.m_ChildPositionArray.clone(),
            m_ChildThresholdArray: self.m_ChildThresholdArray.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BlendDirectDataConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ChildBlendEventIDArray: Option<Vec<u32>>,
    pub m_NormalizedBlendValues: Option<bool>,
}

impl_object!(BlendDirectDataConstant);

impl Clone for BlendDirectDataConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ChildBlendEventIDArray: self.m_ChildBlendEventIDArray.clone(),
            m_NormalizedBlendValues: self.m_NormalizedBlendValues.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BlendShapeData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub channels: Option<Vec<MeshBlendShapeChannel>>,
    pub fullWeights: Option<Vec<f32>>,
    pub shapes: Option<Vec<MeshBlendShape>>,
    pub vertices: Option<Vec<BlendShapeVertex>>,
}

impl_object!(BlendShapeData);

impl Clone for BlendShapeData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            channels: self.channels.clone(),
            fullWeights: self.fullWeights.clone(),
            shapes: self.shapes.clone(),
            vertices: self.vertices.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BlendShapeVertex {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub index: Option<u32>,
    pub normal: Option<Vector3>,
    pub tangent: Option<Vector3>,
    pub vertex: Option<Vector3>,
}

impl_object!(BlendShapeVertex);

impl Clone for BlendShapeVertex {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            index: self.index.clone(),
            normal: self.normal.clone(),
            tangent: self.tangent.clone(),
            vertex: self.vertex.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BlendTreeConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BlendEventArrayConstant: Option<Box<Box<OffsetPtr>>>,
    pub m_NodeArray: Option<Vec<Box<Box<OffsetPtr>>>>,
}

impl_object!(BlendTreeConstant);

impl Clone for BlendTreeConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BlendEventArrayConstant: self.m_BlendEventArrayConstant.clone(),
            m_NodeArray: self.m_NodeArray.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BlendTreeNodeConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Blend1dData: Option<Box<Box<OffsetPtr>>>,
    pub m_Blend2dData: Option<Box<Box<OffsetPtr>>>,
    pub m_BlendDirectData: Option<Box<Box<OffsetPtr>>>,
    pub m_BlendEventID: Option<u32>,
    pub m_BlendEventYID: Option<u32>,
    pub m_BlendType: Option<u32>,
    pub m_ChildIndices: Option<Vec<u32>>,
    pub m_ChildThresholdArray: Option<Vec<f32>>,
    pub m_ClipID: Option<u32>,
    pub m_ClipIndex: Option<u32>,
    pub m_CycleOffset: Option<f32>,
    pub m_Duration: Option<f32>,
    pub m_Mirror: Option<bool>,
}

impl_object!(BlendTreeNodeConstant);

impl Clone for BlendTreeNodeConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Blend1dData: self.m_Blend1dData.clone(),
            m_Blend2dData: self.m_Blend2dData.clone(),
            m_BlendDirectData: self.m_BlendDirectData.clone(),
            m_BlendEventID: self.m_BlendEventID.clone(),
            m_BlendEventYID: self.m_BlendEventYID.clone(),
            m_BlendType: self.m_BlendType.clone(),
            m_ChildIndices: self.m_ChildIndices.clone(),
            m_ChildThresholdArray: self.m_ChildThresholdArray.clone(),
            m_ClipID: self.m_ClipID.clone(),
            m_ClipIndex: self.m_ClipIndex.clone(),
            m_CycleOffset: self.m_CycleOffset.clone(),
            m_Duration: self.m_Duration.clone(),
            m_Mirror: self.m_Mirror.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BoneInfluence {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub boneIndex_0_: Option<i32>,
    pub boneIndex_1_: Option<i32>,
    pub boneIndex_2_: Option<i32>,
    pub boneIndex_3_: Option<i32>,
    pub weight_0_: Option<f32>,
    pub weight_1_: Option<f32>,
    pub weight_2_: Option<f32>,
    pub weight_3_: Option<f32>,
}

impl_object!(BoneInfluence);

impl Clone for BoneInfluence {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            boneIndex_0_: self.boneIndex_0_.clone(),
            boneIndex_1_: self.boneIndex_1_.clone(),
            boneIndex_2_: self.boneIndex_2_.clone(),
            boneIndex_3_: self.boneIndex_3_.clone(),
            weight_0_: self.weight_0_.clone(),
            weight_1_: self.weight_1_.clone(),
            weight_2_: self.weight_2_.clone(),
            weight_3_: self.weight_3_.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BoneWeights4 {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub boneIndex_0_: Option<i32>,
    pub boneIndex_1_: Option<i32>,
    pub boneIndex_2_: Option<i32>,
    pub boneIndex_3_: Option<i32>,
    pub weight_0_: Option<f32>,
    pub weight_1_: Option<f32>,
    pub weight_2_: Option<f32>,
    pub weight_3_: Option<f32>,
}

impl_object!(BoneWeights4);

impl Clone for BoneWeights4 {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            boneIndex_0_: self.boneIndex_0_.clone(),
            boneIndex_1_: self.boneIndex_1_.clone(),
            boneIndex_2_: self.boneIndex_2_.clone(),
            boneIndex_3_: self.boneIndex_3_.clone(),
            weight_0_: self.weight_0_.clone(),
            weight_1_: self.weight_1_.clone(),
            weight_2_: self.weight_2_.clone(),
            weight_3_: self.weight_3_.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BranchWindLevel {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_afBend_0: Option<f32>,
    pub m_afBend_1: Option<f32>,
    pub m_afBend_10: Option<f32>,
    pub m_afBend_11: Option<f32>,
    pub m_afBend_12: Option<f32>,
    pub m_afBend_13: Option<f32>,
    pub m_afBend_14: Option<f32>,
    pub m_afBend_15: Option<f32>,
    pub m_afBend_16: Option<f32>,
    pub m_afBend_17: Option<f32>,
    pub m_afBend_18: Option<f32>,
    pub m_afBend_19: Option<f32>,
    pub m_afBend_2: Option<f32>,
    pub m_afBend_3: Option<f32>,
    pub m_afBend_4: Option<f32>,
    pub m_afBend_5: Option<f32>,
    pub m_afBend_6: Option<f32>,
    pub m_afBend_7: Option<f32>,
    pub m_afBend_8: Option<f32>,
    pub m_afBend_9: Option<f32>,
    pub m_afFlexibility_0: Option<f32>,
    pub m_afFlexibility_1: Option<f32>,
    pub m_afFlexibility_10: Option<f32>,
    pub m_afFlexibility_11: Option<f32>,
    pub m_afFlexibility_12: Option<f32>,
    pub m_afFlexibility_13: Option<f32>,
    pub m_afFlexibility_14: Option<f32>,
    pub m_afFlexibility_15: Option<f32>,
    pub m_afFlexibility_16: Option<f32>,
    pub m_afFlexibility_17: Option<f32>,
    pub m_afFlexibility_18: Option<f32>,
    pub m_afFlexibility_19: Option<f32>,
    pub m_afFlexibility_2: Option<f32>,
    pub m_afFlexibility_3: Option<f32>,
    pub m_afFlexibility_4: Option<f32>,
    pub m_afFlexibility_5: Option<f32>,
    pub m_afFlexibility_6: Option<f32>,
    pub m_afFlexibility_7: Option<f32>,
    pub m_afFlexibility_8: Option<f32>,
    pub m_afFlexibility_9: Option<f32>,
    pub m_afOscillation_0: Option<f32>,
    pub m_afOscillation_1: Option<f32>,
    pub m_afOscillation_10: Option<f32>,
    pub m_afOscillation_11: Option<f32>,
    pub m_afOscillation_12: Option<f32>,
    pub m_afOscillation_13: Option<f32>,
    pub m_afOscillation_14: Option<f32>,
    pub m_afOscillation_15: Option<f32>,
    pub m_afOscillation_16: Option<f32>,
    pub m_afOscillation_17: Option<f32>,
    pub m_afOscillation_18: Option<f32>,
    pub m_afOscillation_19: Option<f32>,
    pub m_afOscillation_2: Option<f32>,
    pub m_afOscillation_3: Option<f32>,
    pub m_afOscillation_4: Option<f32>,
    pub m_afOscillation_5: Option<f32>,
    pub m_afOscillation_6: Option<f32>,
    pub m_afOscillation_7: Option<f32>,
    pub m_afOscillation_8: Option<f32>,
    pub m_afOscillation_9: Option<f32>,
    pub m_afSpeed_0: Option<f32>,
    pub m_afSpeed_1: Option<f32>,
    pub m_afSpeed_10: Option<f32>,
    pub m_afSpeed_11: Option<f32>,
    pub m_afSpeed_12: Option<f32>,
    pub m_afSpeed_13: Option<f32>,
    pub m_afSpeed_14: Option<f32>,
    pub m_afSpeed_15: Option<f32>,
    pub m_afSpeed_16: Option<f32>,
    pub m_afSpeed_17: Option<f32>,
    pub m_afSpeed_18: Option<f32>,
    pub m_afSpeed_19: Option<f32>,
    pub m_afSpeed_2: Option<f32>,
    pub m_afSpeed_3: Option<f32>,
    pub m_afSpeed_4: Option<f32>,
    pub m_afSpeed_5: Option<f32>,
    pub m_afSpeed_6: Option<f32>,
    pub m_afSpeed_7: Option<f32>,
    pub m_afSpeed_8: Option<f32>,
    pub m_afSpeed_9: Option<f32>,
    pub m_afTurbulence_0: Option<f32>,
    pub m_afTurbulence_1: Option<f32>,
    pub m_afTurbulence_10: Option<f32>,
    pub m_afTurbulence_11: Option<f32>,
    pub m_afTurbulence_12: Option<f32>,
    pub m_afTurbulence_13: Option<f32>,
    pub m_afTurbulence_14: Option<f32>,
    pub m_afTurbulence_15: Option<f32>,
    pub m_afTurbulence_16: Option<f32>,
    pub m_afTurbulence_17: Option<f32>,
    pub m_afTurbulence_18: Option<f32>,
    pub m_afTurbulence_19: Option<f32>,
    pub m_afTurbulence_2: Option<f32>,
    pub m_afTurbulence_3: Option<f32>,
    pub m_afTurbulence_4: Option<f32>,
    pub m_afTurbulence_5: Option<f32>,
    pub m_afTurbulence_6: Option<f32>,
    pub m_afTurbulence_7: Option<f32>,
    pub m_afTurbulence_8: Option<f32>,
    pub m_afTurbulence_9: Option<f32>,
    pub m_fIndependence: Option<f32>,
}

impl_object!(BranchWindLevel);

impl Clone for BranchWindLevel {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_afBend_0: self.m_afBend_0.clone(),
            m_afBend_1: self.m_afBend_1.clone(),
            m_afBend_10: self.m_afBend_10.clone(),
            m_afBend_11: self.m_afBend_11.clone(),
            m_afBend_12: self.m_afBend_12.clone(),
            m_afBend_13: self.m_afBend_13.clone(),
            m_afBend_14: self.m_afBend_14.clone(),
            m_afBend_15: self.m_afBend_15.clone(),
            m_afBend_16: self.m_afBend_16.clone(),
            m_afBend_17: self.m_afBend_17.clone(),
            m_afBend_18: self.m_afBend_18.clone(),
            m_afBend_19: self.m_afBend_19.clone(),
            m_afBend_2: self.m_afBend_2.clone(),
            m_afBend_3: self.m_afBend_3.clone(),
            m_afBend_4: self.m_afBend_4.clone(),
            m_afBend_5: self.m_afBend_5.clone(),
            m_afBend_6: self.m_afBend_6.clone(),
            m_afBend_7: self.m_afBend_7.clone(),
            m_afBend_8: self.m_afBend_8.clone(),
            m_afBend_9: self.m_afBend_9.clone(),
            m_afFlexibility_0: self.m_afFlexibility_0.clone(),
            m_afFlexibility_1: self.m_afFlexibility_1.clone(),
            m_afFlexibility_10: self.m_afFlexibility_10.clone(),
            m_afFlexibility_11: self.m_afFlexibility_11.clone(),
            m_afFlexibility_12: self.m_afFlexibility_12.clone(),
            m_afFlexibility_13: self.m_afFlexibility_13.clone(),
            m_afFlexibility_14: self.m_afFlexibility_14.clone(),
            m_afFlexibility_15: self.m_afFlexibility_15.clone(),
            m_afFlexibility_16: self.m_afFlexibility_16.clone(),
            m_afFlexibility_17: self.m_afFlexibility_17.clone(),
            m_afFlexibility_18: self.m_afFlexibility_18.clone(),
            m_afFlexibility_19: self.m_afFlexibility_19.clone(),
            m_afFlexibility_2: self.m_afFlexibility_2.clone(),
            m_afFlexibility_3: self.m_afFlexibility_3.clone(),
            m_afFlexibility_4: self.m_afFlexibility_4.clone(),
            m_afFlexibility_5: self.m_afFlexibility_5.clone(),
            m_afFlexibility_6: self.m_afFlexibility_6.clone(),
            m_afFlexibility_7: self.m_afFlexibility_7.clone(),
            m_afFlexibility_8: self.m_afFlexibility_8.clone(),
            m_afFlexibility_9: self.m_afFlexibility_9.clone(),
            m_afOscillation_0: self.m_afOscillation_0.clone(),
            m_afOscillation_1: self.m_afOscillation_1.clone(),
            m_afOscillation_10: self.m_afOscillation_10.clone(),
            m_afOscillation_11: self.m_afOscillation_11.clone(),
            m_afOscillation_12: self.m_afOscillation_12.clone(),
            m_afOscillation_13: self.m_afOscillation_13.clone(),
            m_afOscillation_14: self.m_afOscillation_14.clone(),
            m_afOscillation_15: self.m_afOscillation_15.clone(),
            m_afOscillation_16: self.m_afOscillation_16.clone(),
            m_afOscillation_17: self.m_afOscillation_17.clone(),
            m_afOscillation_18: self.m_afOscillation_18.clone(),
            m_afOscillation_19: self.m_afOscillation_19.clone(),
            m_afOscillation_2: self.m_afOscillation_2.clone(),
            m_afOscillation_3: self.m_afOscillation_3.clone(),
            m_afOscillation_4: self.m_afOscillation_4.clone(),
            m_afOscillation_5: self.m_afOscillation_5.clone(),
            m_afOscillation_6: self.m_afOscillation_6.clone(),
            m_afOscillation_7: self.m_afOscillation_7.clone(),
            m_afOscillation_8: self.m_afOscillation_8.clone(),
            m_afOscillation_9: self.m_afOscillation_9.clone(),
            m_afSpeed_0: self.m_afSpeed_0.clone(),
            m_afSpeed_1: self.m_afSpeed_1.clone(),
            m_afSpeed_10: self.m_afSpeed_10.clone(),
            m_afSpeed_11: self.m_afSpeed_11.clone(),
            m_afSpeed_12: self.m_afSpeed_12.clone(),
            m_afSpeed_13: self.m_afSpeed_13.clone(),
            m_afSpeed_14: self.m_afSpeed_14.clone(),
            m_afSpeed_15: self.m_afSpeed_15.clone(),
            m_afSpeed_16: self.m_afSpeed_16.clone(),
            m_afSpeed_17: self.m_afSpeed_17.clone(),
            m_afSpeed_18: self.m_afSpeed_18.clone(),
            m_afSpeed_19: self.m_afSpeed_19.clone(),
            m_afSpeed_2: self.m_afSpeed_2.clone(),
            m_afSpeed_3: self.m_afSpeed_3.clone(),
            m_afSpeed_4: self.m_afSpeed_4.clone(),
            m_afSpeed_5: self.m_afSpeed_5.clone(),
            m_afSpeed_6: self.m_afSpeed_6.clone(),
            m_afSpeed_7: self.m_afSpeed_7.clone(),
            m_afSpeed_8: self.m_afSpeed_8.clone(),
            m_afSpeed_9: self.m_afSpeed_9.clone(),
            m_afTurbulence_0: self.m_afTurbulence_0.clone(),
            m_afTurbulence_1: self.m_afTurbulence_1.clone(),
            m_afTurbulence_10: self.m_afTurbulence_10.clone(),
            m_afTurbulence_11: self.m_afTurbulence_11.clone(),
            m_afTurbulence_12: self.m_afTurbulence_12.clone(),
            m_afTurbulence_13: self.m_afTurbulence_13.clone(),
            m_afTurbulence_14: self.m_afTurbulence_14.clone(),
            m_afTurbulence_15: self.m_afTurbulence_15.clone(),
            m_afTurbulence_16: self.m_afTurbulence_16.clone(),
            m_afTurbulence_17: self.m_afTurbulence_17.clone(),
            m_afTurbulence_18: self.m_afTurbulence_18.clone(),
            m_afTurbulence_19: self.m_afTurbulence_19.clone(),
            m_afTurbulence_2: self.m_afTurbulence_2.clone(),
            m_afTurbulence_3: self.m_afTurbulence_3.clone(),
            m_afTurbulence_4: self.m_afTurbulence_4.clone(),
            m_afTurbulence_5: self.m_afTurbulence_5.clone(),
            m_afTurbulence_6: self.m_afTurbulence_6.clone(),
            m_afTurbulence_7: self.m_afTurbulence_7.clone(),
            m_afTurbulence_8: self.m_afTurbulence_8.clone(),
            m_afTurbulence_9: self.m_afTurbulence_9.clone(),
            m_fIndependence: self.m_fIndependence.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BufferBinding {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ArraySize: Option<i32>,
    pub m_Index: Option<i32>,
    pub m_NameIndex: Option<i32>,
}

impl_object!(BufferBinding);

impl Clone for BufferBinding {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ArraySize: self.m_ArraySize.clone(),
            m_Index: self.m_Index.clone(),
            m_NameIndex: self.m_NameIndex.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuildReportFile {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub id: Option<u32>,
    pub path: Option<String>,
    pub role: Option<String>,
    pub totalSize: Option<u64>,
}

impl_object!(BuildReportFile);

impl Clone for BuildReportFile {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            id: self.id.clone(),
            path: self.path.clone(),
            role: self.role.clone(),
            totalSize: self.totalSize.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuildReportPackedAssetInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub buildTimeAssetPath: Option<String>,
    pub classID: Option<i32>,
    pub fileID: Option<i64>,
    pub offset: Option<u64>,
    pub packedSize: Option<i32>,
    pub sourceAssetGUID: Option<GUID>,
}

impl_object!(BuildReportPackedAssetInfo);

impl Clone for BuildReportPackedAssetInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            buildTimeAssetPath: self.buildTimeAssetPath.clone(),
            classID: self.classID.clone(),
            fileID: self.fileID.clone(),
            offset: self.offset.clone(),
            packedSize: self.packedSize.clone(),
            sourceAssetGUID: self.sourceAssetGUID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuildReportScenesUsingAsset {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub assetPath: Option<String>,
    pub scenePaths: Option<Vec<String>>,
}

impl_object!(BuildReportScenesUsingAsset);

impl Clone for BuildReportScenesUsingAsset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            assetPath: self.assetPath.clone(),
            scenePaths: self.scenePaths.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuildStepInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub depth: Option<i32>,
    pub duration: Option<u64>,
    pub durationTicks: Option<u64>,
    pub messages: Option<Vec<BuildStepMessage>>,
    pub stepName: Option<String>,
}

impl_object!(BuildStepInfo);

impl Clone for BuildStepInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            depth: self.depth.clone(),
            duration: self.duration.clone(),
            durationTicks: self.durationTicks.clone(),
            messages: self.messages.clone(),
            stepName: self.stepName.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuildStepMessage {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub content: Option<String>,
    pub typ: Option<i32>,
}

impl_object!(BuildStepMessage);

impl Clone for BuildStepMessage {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            content: self.content.clone(),
            typ: self.typ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuildSummary {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub assetBundleOptions: Option<i32>,
    pub buildGUID: Option<GUID>,
    pub buildResult: Option<i32>,
    pub buildStartTime: Option<DateTime>,
    pub buildType: Option<i32>,
    pub crc: Option<u32>,
    pub multiProcessEnabled: Option<bool>,
    pub name: Option<String>,
    pub options: Option<i32>,
    pub outputPath: Option<String>,
    pub platformGroupName: Option<String>,
    pub platformName: Option<String>,
    pub subtarget: Option<i32>,
    pub success: Option<bool>,
    pub totalErrors: Option<i32>,
    pub totalSize: Option<u64>,
    pub totalTimeMS: Option<u64>,
    pub totalTimeTicks: Option<u64>,
    pub totalWarnings: Option<i32>,
}

impl_object!(BuildSummary);

impl Clone for BuildSummary {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            assetBundleOptions: self.assetBundleOptions.clone(),
            buildGUID: self.buildGUID.clone(),
            buildResult: self.buildResult.clone(),
            buildStartTime: self.buildStartTime.clone(),
            buildType: self.buildType.clone(),
            crc: self.crc.clone(),
            multiProcessEnabled: self.multiProcessEnabled.clone(),
            name: self.name.clone(),
            options: self.options.clone(),
            outputPath: self.outputPath.clone(),
            platformGroupName: self.platformGroupName.clone(),
            platformName: self.platformName.clone(),
            subtarget: self.subtarget.clone(),
            success: self.success.clone(),
            totalErrors: self.totalErrors.clone(),
            totalSize: self.totalSize.clone(),
            totalTimeMS: self.totalTimeMS.clone(),
            totalTimeTicks: self.totalTimeTicks.clone(),
            totalWarnings: self.totalWarnings.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuildTargetSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AllowsAlphaSplitting: Option<bool>,
    pub m_BuildTarget: Option<String>,
    pub m_CompressionQuality: Option<i32>,
    pub m_LoadingBehavior: Option<i32>,
    pub m_MaxTextureSize: Option<i32>,
    pub m_TextureFormat: Option<i32>,
    pub m_TextureHeight: Option<i32>,
    pub m_TextureWidth: Option<i32>,
}

impl_object!(BuildTargetSettings);

impl Clone for BuildTargetSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AllowsAlphaSplitting: self.m_AllowsAlphaSplitting.clone(),
            m_BuildTarget: self.m_BuildTarget.clone(),
            m_CompressionQuality: self.m_CompressionQuality.clone(),
            m_LoadingBehavior: self.m_LoadingBehavior.clone(),
            m_MaxTextureSize: self.m_MaxTextureSize.clone(),
            m_TextureFormat: self.m_TextureFormat.clone(),
            m_TextureHeight: self.m_TextureHeight.clone(),
            m_TextureWidth: self.m_TextureWidth.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuildTextureStackReference {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub groupName: Option<String>,
    pub itemName: Option<String>,
}

impl_object!(BuildTextureStackReference);

impl Clone for BuildTextureStackReference {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            groupName: self.groupName.clone(),
            itemName: self.itemName.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuiltAssetBundleInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bundleArchiveFile: Option<u32>,
    pub bundleName: Option<String>,
    pub packagedFileIndices: Option<Vec<u32>>,
}

impl_object!(BuiltAssetBundleInfo);

impl Clone for BuiltAssetBundleInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bundleArchiveFile: self.bundleArchiveFile.clone(),
            bundleName: self.bundleName.clone(),
            packagedFileIndices: self.packagedFileIndices.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct BuiltinShaderSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Mode: Option<i32>,
    pub m_Shader: Option<PPtrData<Shader>>,
}

impl_object!(BuiltinShaderSettings);

impl Clone for BuiltinShaderSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Mode: self.m_Mode.clone(),
            m_Shader: self.m_Shader.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CGProgram {
    // extends TextAsset
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
    pub m_PathName: Option<String>,
    pub m_Script: Option<String>,
}

impl_object!(CGProgram);

impl Clone for CGProgram {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
            m_PathName: self.m_PathName.clone(),
            m_Script: self.m_Script.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CachedAssetMetaData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub guid: Option<GUID>,
    pub originalChangeset: Option<u32>,
    pub originalDigest: Option<Hash128>,
    pub originalName: Option<String>,
    pub originalParent: Option<GUID>,
    pub pathName: Option<String>,
}

impl_object!(CachedAssetMetaData);

impl Clone for CachedAssetMetaData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            guid: self.guid.clone(),
            originalChangeset: self.originalChangeset.clone(),
            originalDigest: self.originalDigest.clone(),
            originalName: self.originalName.clone(),
            originalParent: self.originalParent.clone(),
            pathName: self.pathName.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Channel {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub attributeName: Option<String>,
    pub byteOffset: Option<i32>,
    pub curve: Option<AnimationCurve>,
}

impl_object!(Channel);

impl Clone for Channel {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            attributeName: self.attributeName.clone(),
            byteOffset: self.byteOffset.clone(),
            curve: self.curve.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ChannelInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub dimension: Option<u8>,
    pub format: Option<u8>,
    pub offset: Option<u8>,
    pub stream: Option<u8>,
}

impl_object!(ChannelInfo);

impl Clone for ChannelInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            dimension: self.dimension.clone(),
            format: self.format.clone(),
            offset: self.offset.clone(),
            stream: self.stream.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CharacterInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub advance: Option<f32>,
    pub flipped: Option<bool>,
    pub index: Option<u32>,
    pub uv: Option<Rectf>,
    pub vert: Option<Rectf>,
    pub width: Option<f32>,
}

impl_object!(CharacterInfo);

impl Clone for CharacterInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            advance: self.advance.clone(),
            flipped: self.flipped.clone(),
            index: self.index.clone(),
            uv: self.uv.clone(),
            vert: self.vert.clone(),
            width: self.width.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Child {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CycleOffset: Option<f32>,
    pub m_IsAnim: Option<bool>,
    pub m_Mirror: Option<bool>,
    pub m_Motion: Option<PPtrData<Motion>>,
    pub m_Position: Option<Vector2>,
    pub m_Threshold: Option<f32>,
    pub m_TimeScale: Option<f32>,
}

impl_object!(Child);

impl Clone for Child {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CycleOffset: self.m_CycleOffset.clone(),
            m_IsAnim: self.m_IsAnim.clone(),
            m_Mirror: self.m_Mirror.clone(),
            m_Motion: self.m_Motion.clone(),
            m_Position: self.m_Position.clone(),
            m_Threshold: self.m_Threshold.clone(),
            m_TimeScale: self.m_TimeScale.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ChildAnimatorState {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Position: Option<Vector3>,
    pub m_State: Option<PPtrData<AnimatorState>>,
}

impl_object!(ChildAnimatorState);

impl Clone for ChildAnimatorState {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Position: self.m_Position.clone(),
            m_State: self.m_State.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ChildAnimatorStateMachine {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Position: Option<Vector3>,
    pub m_StateMachine: Option<PPtrData<AnimatorStateMachine>>,
}

impl_object!(ChildAnimatorStateMachine);

impl Clone for ChildAnimatorStateMachine {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Position: self.m_Position.clone(),
            m_StateMachine: self.m_StateMachine.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ChildMotion {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CycleOffset: Option<f32>,
    pub m_DirectBlendParameter: Option<String>,
    pub m_Mirror: Option<bool>,
    pub m_Motion: Option<PPtrData<Motion>>,
    pub m_Position: Option<Vector2>,
    pub m_Threshold: Option<f32>,
    pub m_TimeScale: Option<f32>,
}

impl_object!(ChildMotion);

impl Clone for ChildMotion {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CycleOffset: self.m_CycleOffset.clone(),
            m_DirectBlendParameter: self.m_DirectBlendParameter.clone(),
            m_Mirror: self.m_Mirror.clone(),
            m_Motion: self.m_Motion.clone(),
            m_Position: self.m_Position.clone(),
            m_Threshold: self.m_Threshold.clone(),
            m_TimeScale: self.m_TimeScale.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ClampVelocityModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub dampen: Option<f32>,
    pub drag: Option<MinMaxCurve>,
    pub enabled: Option<bool>,
    pub inWorldSpace: Option<bool>,
    pub magnitude: Option<MinMaxCurve>,
    pub multiplyDragByParticleSize: Option<bool>,
    pub multiplyDragByParticleVelocity: Option<bool>,
    pub separateAxis: Option<bool>,
    pub x: Option<MinMaxCurve>,
    pub y: Option<MinMaxCurve>,
    pub z: Option<MinMaxCurve>,
}

impl_object!(ClampVelocityModule);

impl Clone for ClampVelocityModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            dampen: self.dampen.clone(),
            drag: self.drag.clone(),
            enabled: self.enabled.clone(),
            inWorldSpace: self.inWorldSpace.clone(),
            magnitude: self.magnitude.clone(),
            multiplyDragByParticleSize: self.multiplyDragByParticleSize.clone(),
            multiplyDragByParticleVelocity: self.multiplyDragByParticleVelocity.clone(),
            separateAxis: self.separateAxis.clone(),
            x: self.x.clone(),
            y: self.y.clone(),
            z: self.z.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ClassInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AssemblyNameIndex: Option<i32>,
    pub m_ClassName: Option<String>,
    pub m_IsUnityClass: Option<bool>,
    pub m_MethodIndex: Option<i32>,
    pub m_NamespaceIndex: Option<i32>,
    pub m_NamespaceName: Option<String>,
    pub m_NumOfMethods: Option<i32>,
}

impl_object!(ClassInfo);

impl Clone for ClassInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AssemblyNameIndex: self.m_AssemblyNameIndex.clone(),
            m_ClassName: self.m_ClassName.clone(),
            m_IsUnityClass: self.m_IsUnityClass.clone(),
            m_MethodIndex: self.m_MethodIndex.clone(),
            m_NamespaceIndex: self.m_NamespaceIndex.clone(),
            m_NamespaceName: self.m_NamespaceName.clone(),
            m_NumOfMethods: self.m_NumOfMethods.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ClassMethodInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ClassIndex: Option<i32>,
    pub m_MethodName: Option<String>,
    pub m_OrderNumber: Option<i32>,
}

impl_object!(ClassMethodInfo);

impl Clone for ClassMethodInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ClassIndex: self.m_ClassIndex.clone(),
            m_MethodName: self.m_MethodName.clone(),
            m_OrderNumber: self.m_OrderNumber.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Clip {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Binding: Option<Box<Box<OffsetPtr>>>,
    pub m_ConstantClip: Option<ConstantClip>,
    pub m_DenseClip: Option<DenseClip>,
    pub m_StreamedClip: Option<StreamedClip>,
}

impl_object!(Clip);

impl Clone for Clip {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Binding: self.m_Binding.clone(),
            m_ConstantClip: self.m_ConstantClip.clone(),
            m_DenseClip: self.m_DenseClip.clone(),
            m_StreamedClip: self.m_StreamedClip.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ClipAnimationInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub additiveReferencePoseFrame: Option<f32>,
    pub bodyMask: Option<Vec<u32>>,
    pub curves: Option<Vec<ClipAnimationInfoCurve>>,
    pub cycleOffset: Option<f32>,
    pub events: Option<Vec<AnimationEvent>>,
    pub firstFrame: Option<f32>,
    pub hasAdditiveReferencePose: Option<bool>,
    pub heightFromFeet: Option<bool>,
    pub internalID: Option<i64>,
    pub keepAdditionalBonesAnimation: Option<bool>,
    pub keepOriginalOrientation: Option<bool>,
    pub keepOriginalPositionXZ: Option<bool>,
    pub keepOriginalPositionY: Option<bool>,
    pub lastFrame: Option<f32>,
    pub level: Option<f32>,
    pub loopBlend: Option<bool>,
    pub loopBlendOrientation: Option<bool>,
    pub loopBlendPositionXZ: Option<bool>,
    pub loopBlendPositionY: Option<bool>,
    pub loopTime: Option<bool>,
    pub loop_value: Option<bool>,
    pub maskSource: Option<PPtrData<AvatarMask>>,
    pub maskType: Option<i32>,
    pub mirror: Option<bool>,
    pub name: Option<String>,
    pub orientationOffsetY: Option<f32>,
    pub skeletonMaskElements: Option<Vec<AvatarSkeletonMaskElement>>,
    pub takeName: Option<String>,
    pub transformMask: Option<Vec<TransformMaskElement>>,
    pub wrapMode: Option<i32>,
}

impl_object!(ClipAnimationInfo);

impl Clone for ClipAnimationInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            additiveReferencePoseFrame: self.additiveReferencePoseFrame.clone(),
            bodyMask: self.bodyMask.clone(),
            curves: self.curves.clone(),
            cycleOffset: self.cycleOffset.clone(),
            events: self.events.clone(),
            firstFrame: self.firstFrame.clone(),
            hasAdditiveReferencePose: self.hasAdditiveReferencePose.clone(),
            heightFromFeet: self.heightFromFeet.clone(),
            internalID: self.internalID.clone(),
            keepAdditionalBonesAnimation: self.keepAdditionalBonesAnimation.clone(),
            keepOriginalOrientation: self.keepOriginalOrientation.clone(),
            keepOriginalPositionXZ: self.keepOriginalPositionXZ.clone(),
            keepOriginalPositionY: self.keepOriginalPositionY.clone(),
            lastFrame: self.lastFrame.clone(),
            level: self.level.clone(),
            loopBlend: self.loopBlend.clone(),
            loopBlendOrientation: self.loopBlendOrientation.clone(),
            loopBlendPositionXZ: self.loopBlendPositionXZ.clone(),
            loopBlendPositionY: self.loopBlendPositionY.clone(),
            loopTime: self.loopTime.clone(),
            loop_value: self.loop_value.clone(),
            maskSource: self.maskSource.clone(),
            maskType: self.maskType.clone(),
            mirror: self.mirror.clone(),
            name: self.name.clone(),
            orientationOffsetY: self.orientationOffsetY.clone(),
            skeletonMaskElements: self.skeletonMaskElements.clone(),
            takeName: self.takeName.clone(),
            transformMask: self.transformMask.clone(),
            wrapMode: self.wrapMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ClipAnimationInfoCurve {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub curve: Option<AnimationCurve>,
    pub name: Option<String>,
}

impl_object!(ClipAnimationInfoCurve);

impl Clone for ClipAnimationInfoCurve {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            curve: self.curve.clone(),
            name: self.name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ClipMuscleConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AdditionalCurveIndexArray: Option<Vec<i32>>,
    pub m_AverageAngularSpeed: Option<f32>,
    pub m_AverageSpeed: Option<Vector3>,
    pub m_Clip: Option<OffsetPtr>,
    pub m_CycleOffset: Option<f32>,
    pub m_DeltaPose: Option<HumanPose>,
    pub m_HeightFromFeet: Option<bool>,
    pub m_IndexArray: Option<Vec<i32>>,
    pub m_KeepOriginalOrientation: Option<bool>,
    pub m_KeepOriginalPositionXZ: Option<bool>,
    pub m_KeepOriginalPositionY: Option<bool>,
    pub m_LeftFootStartX: Option<xform>,
    pub m_Level: Option<f32>,
    pub m_LoopBlend: Option<bool>,
    pub m_LoopBlendOrientation: Option<bool>,
    pub m_LoopBlendPositionXZ: Option<bool>,
    pub m_LoopBlendPositionY: Option<bool>,
    pub m_LoopTime: Option<bool>,
    pub m_Mirror: Option<bool>,
    pub m_MotionStartX: Option<xform>,
    pub m_MotionStopX: Option<xform>,
    pub m_OrientationOffsetY: Option<f32>,
    pub m_RightFootStartX: Option<xform>,
    pub m_StartAtOrigin: Option<bool>,
    pub m_StartTime: Option<f32>,
    pub m_StartX: Option<xform>,
    pub m_StopTime: Option<f32>,
    pub m_StopX: Option<xform>,
    pub m_ValueArrayDelta: Option<Vec<ValueDelta>>,
    pub m_ValueArrayReferencePose: Option<Vec<f32>>,
}

impl_object!(ClipMuscleConstant);

impl Clone for ClipMuscleConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AdditionalCurveIndexArray: self.m_AdditionalCurveIndexArray.clone(),
            m_AverageAngularSpeed: self.m_AverageAngularSpeed.clone(),
            m_AverageSpeed: self.m_AverageSpeed.clone(),
            m_Clip: self.m_Clip.clone(),
            m_CycleOffset: self.m_CycleOffset.clone(),
            m_DeltaPose: self.m_DeltaPose.clone(),
            m_HeightFromFeet: self.m_HeightFromFeet.clone(),
            m_IndexArray: self.m_IndexArray.clone(),
            m_KeepOriginalOrientation: self.m_KeepOriginalOrientation.clone(),
            m_KeepOriginalPositionXZ: self.m_KeepOriginalPositionXZ.clone(),
            m_KeepOriginalPositionY: self.m_KeepOriginalPositionY.clone(),
            m_LeftFootStartX: self.m_LeftFootStartX.clone(),
            m_Level: self.m_Level.clone(),
            m_LoopBlend: self.m_LoopBlend.clone(),
            m_LoopBlendOrientation: self.m_LoopBlendOrientation.clone(),
            m_LoopBlendPositionXZ: self.m_LoopBlendPositionXZ.clone(),
            m_LoopBlendPositionY: self.m_LoopBlendPositionY.clone(),
            m_LoopTime: self.m_LoopTime.clone(),
            m_Mirror: self.m_Mirror.clone(),
            m_MotionStartX: self.m_MotionStartX.clone(),
            m_MotionStopX: self.m_MotionStopX.clone(),
            m_OrientationOffsetY: self.m_OrientationOffsetY.clone(),
            m_RightFootStartX: self.m_RightFootStartX.clone(),
            m_StartAtOrigin: self.m_StartAtOrigin.clone(),
            m_StartTime: self.m_StartTime.clone(),
            m_StartX: self.m_StartX.clone(),
            m_StopTime: self.m_StopTime.clone(),
            m_StopX: self.m_StopX.clone(),
            m_ValueArrayDelta: self.m_ValueArrayDelta.clone(),
            m_ValueArrayReferencePose: self.m_ValueArrayReferencePose.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ClothAttachment {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Collider: Option<PPtrData<Collider>>,
    pub m_Tearable: Option<bool>,
    pub m_TwoWayInteraction: Option<bool>,
}

impl_object!(ClothAttachment);

impl Clone for ClothAttachment {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Collider: self.m_Collider.clone(),
            m_Tearable: self.m_Tearable.clone(),
            m_TwoWayInteraction: self.m_TwoWayInteraction.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ClothConstrainCoefficients {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub collisionSphereDistance: Option<f32>,
    pub collisionSphereRadius: Option<f32>,
    pub maxDistance: Option<f32>,
    pub maxDistanceBias: Option<f32>,
}

impl_object!(ClothConstrainCoefficients);

impl Clone for ClothConstrainCoefficients {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            collisionSphereDistance: self.collisionSphereDistance.clone(),
            collisionSphereRadius: self.collisionSphereRadius.clone(),
            maxDistance: self.maxDistance.clone(),
            maxDistanceBias: self.maxDistanceBias.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ClothSphereColliderPair {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub first: Option<PPtrData<SphereCollider>>,
    pub second: Option<PPtrData<SphereCollider>>,
}

impl_object!(ClothSphereColliderPair);

impl Clone for ClothSphereColliderPair {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            first: self.first.clone(),
            second: self.second.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ClusterInput {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DeviceName: Option<String>,
    pub m_Index: Option<i32>,
    pub m_Name: Option<String>,
    pub m_ServerUrl: Option<String>,
    pub m_Type: Option<i32>,
}

impl_object!(ClusterInput);

impl Clone for ClusterInput {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DeviceName: self.m_DeviceName.clone(),
            m_Index: self.m_Index.clone(),
            m_Name: self.m_Name.clone(),
            m_ServerUrl: self.m_ServerUrl.clone(),
            m_Type: self.m_Type.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CollabEditorSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub inProgressEnabled: Option<bool>,
}

impl_object!(CollabEditorSettings);

impl Clone for CollabEditorSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            inProgressEnabled: self.inProgressEnabled.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Collision {
    // extends
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(Collision);

impl Clone for Collision {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Collision2D {
    // extends
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(Collision2D);

impl Clone for Collision2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CollisionModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bounce: Option<f32>,
    pub colliderForce: Option<f32>,
    pub collidesWith: Option<BitField>,
    pub collidesWithDynamic: Option<bool>,
    pub collisionMessages: Option<bool>,
    pub collisionMode: Option<i32>,
    pub dampen: Option<f32>,
    pub enabled: Option<bool>,
    pub energyLossOnCollision: Option<f32>,
    pub interiorCollisions: Option<bool>,
    pub m_Bounce: Option<MinMaxCurve>,
    pub m_Dampen: Option<MinMaxCurve>,
    pub m_EnergyLossOnCollision: Option<MinMaxCurve>,
    pub m_Planes: Option<Vec<PPtrData<Transform>>>,
    pub maxCollisionShapes: Option<i32>,
    pub maxKillSpeed: Option<f32>,
    pub minKillSpeed: Option<f32>,
    pub multiplyColliderForceByCollisionAngle: Option<bool>,
    pub multiplyColliderForceByParticleSize: Option<bool>,
    pub multiplyColliderForceByParticleSpeed: Option<bool>,
    pub particleRadius: Option<f32>,
    pub plane0: Option<PPtrData<Transform>>,
    pub plane1: Option<PPtrData<Transform>>,
    pub plane2: Option<PPtrData<Transform>>,
    pub plane3: Option<PPtrData<Transform>>,
    pub plane4: Option<PPtrData<Transform>>,
    pub plane5: Option<PPtrData<Transform>>,
    pub quality: Option<i32>,
    pub radiusScale: Option<f32>,
    pub typ: Option<i32>,
    pub voxelSize: Option<f32>,
}

impl_object!(CollisionModule);

impl Clone for CollisionModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bounce: self.bounce.clone(),
            colliderForce: self.colliderForce.clone(),
            collidesWith: self.collidesWith.clone(),
            collidesWithDynamic: self.collidesWithDynamic.clone(),
            collisionMessages: self.collisionMessages.clone(),
            collisionMode: self.collisionMode.clone(),
            dampen: self.dampen.clone(),
            enabled: self.enabled.clone(),
            energyLossOnCollision: self.energyLossOnCollision.clone(),
            interiorCollisions: self.interiorCollisions.clone(),
            m_Bounce: self.m_Bounce.clone(),
            m_Dampen: self.m_Dampen.clone(),
            m_EnergyLossOnCollision: self.m_EnergyLossOnCollision.clone(),
            m_Planes: self.m_Planes.clone(),
            maxCollisionShapes: self.maxCollisionShapes.clone(),
            maxKillSpeed: self.maxKillSpeed.clone(),
            minKillSpeed: self.minKillSpeed.clone(),
            multiplyColliderForceByCollisionAngle: self
                .multiplyColliderForceByCollisionAngle
                .clone(),
            multiplyColliderForceByParticleSize: self.multiplyColliderForceByParticleSize.clone(),
            multiplyColliderForceByParticleSpeed: self.multiplyColliderForceByParticleSpeed.clone(),
            particleRadius: self.particleRadius.clone(),
            plane0: self.plane0.clone(),
            plane1: self.plane1.clone(),
            plane2: self.plane2.clone(),
            plane3: self.plane3.clone(),
            plane4: self.plane4.clone(),
            plane5: self.plane5.clone(),
            quality: self.quality.clone(),
            radiusScale: self.radiusScale.clone(),
            typ: self.typ.clone(),
            voxelSize: self.voxelSize.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ColorBySpeedModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub enabled: Option<bool>,
    pub gradient: Option<MinMaxGradient>,
    pub range: Option<Vector2>,
}

impl_object!(ColorBySpeedModule);

impl Clone for ColorBySpeedModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            enabled: self.enabled.clone(),
            gradient: self.gradient.clone(),
            range: self.range.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ColorModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub enabled: Option<bool>,
    pub gradient: Option<MinMaxGradient>,
}

impl_object!(ColorModule);

impl Clone for ColorModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            enabled: self.enabled.clone(),
            gradient: self.gradient.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ComponentPair {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub component: Option<PPtrData<Component>>,
}

impl_object!(ComponentPair);

impl Clone for ComponentPair {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            component: self.component.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CompressedAnimationCurve {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Path: Option<String>,
    pub m_PostInfinity: Option<i32>,
    pub m_PreInfinity: Option<i32>,
    pub m_Slopes: Option<PackedBitVector>,
    pub m_Times: Option<PackedBitVector>,
    pub m_Values: Option<PackedBitVector>,
}

impl_object!(CompressedAnimationCurve);

impl Clone for CompressedAnimationCurve {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Path: self.m_Path.clone(),
            m_PostInfinity: self.m_PostInfinity.clone(),
            m_PreInfinity: self.m_PreInfinity.clone(),
            m_Slopes: self.m_Slopes.clone(),
            m_Times: self.m_Times.clone(),
            m_Values: self.m_Values.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CompressedMesh {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BindPoses: Option<PackedBitVector>,
    pub m_BoneIndices: Option<PackedBitVector>,
    pub m_Colors: Option<PackedBitVector>,
    pub m_FloatColors: Option<PackedBitVector>,
    pub m_NormalSigns: Option<PackedBitVector>,
    pub m_Normals: Option<PackedBitVector>,
    pub m_TangentSigns: Option<PackedBitVector>,
    pub m_Tangents: Option<PackedBitVector>,
    pub m_Triangles: Option<PackedBitVector>,
    pub m_UV: Option<PackedBitVector>,
    pub m_UVInfo: Option<u32>,
    pub m_Vertices: Option<PackedBitVector>,
    pub m_Weights: Option<PackedBitVector>,
}

impl_object!(CompressedMesh);

impl Clone for CompressedMesh {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BindPoses: self.m_BindPoses.clone(),
            m_BoneIndices: self.m_BoneIndices.clone(),
            m_Colors: self.m_Colors.clone(),
            m_FloatColors: self.m_FloatColors.clone(),
            m_NormalSigns: self.m_NormalSigns.clone(),
            m_Normals: self.m_Normals.clone(),
            m_TangentSigns: self.m_TangentSigns.clone(),
            m_Tangents: self.m_Tangents.clone(),
            m_Triangles: self.m_Triangles.clone(),
            m_UV: self.m_UV.clone(),
            m_UVInfo: self.m_UVInfo.clone(),
            m_Vertices: self.m_Vertices.clone(),
            m_Weights: self.m_Weights.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ComputeBufferCounter {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bindpoint: Option<i32>,
    pub offset: Option<i32>,
}

impl_object!(ComputeBufferCounter);

impl Clone for ComputeBufferCounter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bindpoint: self.bindpoint.clone(),
            offset: self.offset.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ComputeShaderBuiltinSampler {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bindPoint: Option<i32>,
    pub sampler: Option<i32>,
}

impl_object!(ComputeShaderBuiltinSampler);

impl Clone for ComputeShaderBuiltinSampler {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bindPoint: self.bindPoint.clone(),
            sampler: self.sampler.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ComputeShaderCB {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub byteSize: Option<i32>,
    pub name: Option<FastPropertyName>,
    pub params: Option<Vec<ComputeShaderParam>>,
}

impl_object!(ComputeShaderCB);

impl Clone for ComputeShaderCB {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            byteSize: self.byteSize.clone(),
            name: self.name.clone(),
            params: self.params.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ComputeShaderKernel {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub builtinSamplers: Option<Vec<ComputeShaderBuiltinSampler>>,
    pub cbVariantIndices: Option<Vec<u32>>,
    pub cbs: Option<Vec<ComputeShaderResource>>,
    pub code: Option<Vec<u8>>,
    pub inBuffers: Option<Vec<ComputeShaderResource>>,
    pub name: Option<FastPropertyName>,
    pub outBuffers: Option<Vec<ComputeShaderResource>>,
    pub requirements: Option<i64>,
    pub textures: Option<Vec<ComputeShaderResource>>,
    pub threadGroupSize: Option<Vec<u32>>,
}

impl_object!(ComputeShaderKernel);

impl Clone for ComputeShaderKernel {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            builtinSamplers: self.builtinSamplers.clone(),
            cbVariantIndices: self.cbVariantIndices.clone(),
            cbs: self.cbs.clone(),
            code: self.code.clone(),
            inBuffers: self.inBuffers.clone(),
            name: self.name.clone(),
            outBuffers: self.outBuffers.clone(),
            requirements: self.requirements.clone(),
            textures: self.textures.clone(),
            threadGroupSize: self.threadGroupSize.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ComputeShaderKernelParent {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub dynamicKeywords: Option<Vec<String>>,
    pub globalKeywords: Option<Vec<String>>,
    pub localKeywords: Option<Vec<String>>,
    pub name: Option<String>,
    pub uniqueVariants: Option<Vec<ComputeShaderKernel>>,
    pub validKeywords: Option<Vec<String>>,
    pub variantIndices: Option<Vec<(String, u32)>>,
    pub variantMap: Option<Vec<(String, ComputeShaderKernel)>>,
}

impl_object!(ComputeShaderKernelParent);

impl Clone for ComputeShaderKernelParent {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            dynamicKeywords: self.dynamicKeywords.clone(),
            globalKeywords: self.globalKeywords.clone(),
            localKeywords: self.localKeywords.clone(),
            name: self.name.clone(),
            uniqueVariants: self.uniqueVariants.clone(),
            validKeywords: self.validKeywords.clone(),
            variantIndices: self.variantIndices.clone(),
            variantMap: self.variantMap.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ComputeShaderParam {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub arraySize: Option<i32>,
    pub colCount: Option<i32>,
    pub name: Option<FastPropertyName>,
    pub offset: Option<i32>,
    pub rowCount: Option<i32>,
    pub typ: Option<i32>,
}

impl_object!(ComputeShaderParam);

impl Clone for ComputeShaderParam {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            arraySize: self.arraySize.clone(),
            colCount: self.colCount.clone(),
            name: self.name.clone(),
            offset: self.offset.clone(),
            rowCount: self.rowCount.clone(),
            typ: self.typ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ComputeShaderPlatformVariant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub constantBuffers: Option<Vec<ComputeShaderCB>>,
    pub kernels: Option<Vec<ComputeShaderKernelParent>>,
    pub resourcesResolved: Option<bool>,
    pub targetLevel: Option<i32>,
    pub targetRenderer: Option<i32>,
}

impl_object!(ComputeShaderPlatformVariant);

impl Clone for ComputeShaderPlatformVariant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            constantBuffers: self.constantBuffers.clone(),
            kernels: self.kernels.clone(),
            resourcesResolved: self.resourcesResolved.clone(),
            targetLevel: self.targetLevel.clone(),
            targetRenderer: self.targetRenderer.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ComputeShaderResource {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bindPoint: Option<i32>,
    pub counter: Option<ComputeBufferCounter>,
    pub generatedName: Option<FastPropertyName>,
    pub name: Option<FastPropertyName>,
    pub samplerBindPoint: Option<i32>,
    pub secondaryBindPoint: Option<i32>,
    pub texDimension: Option<i32>,
}

impl_object!(ComputeShaderResource);

impl Clone for ComputeShaderResource {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bindPoint: self.bindPoint.clone(),
            counter: self.counter.clone(),
            generatedName: self.generatedName.clone(),
            name: self.name.clone(),
            samplerBindPoint: self.samplerBindPoint.clone(),
            secondaryBindPoint: self.secondaryBindPoint.clone(),
            texDimension: self.texDimension.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ComputeShaderVariant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub constantBuffers: Option<Vec<ComputeShaderCB>>,
    pub kernels: Option<Vec<ComputeShaderKernel>>,
    pub resourcesResolved: Option<bool>,
    pub targetLevel: Option<i32>,
    pub targetRenderer: Option<i32>,
}

impl_object!(ComputeShaderVariant);

impl Clone for ComputeShaderVariant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            constantBuffers: self.constantBuffers.clone(),
            kernels: self.kernels.clone(),
            resourcesResolved: self.resourcesResolved.clone(),
            targetLevel: self.targetLevel.clone(),
            targetRenderer: self.targetRenderer.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Condition {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ConditionEvent: Option<String>,
    pub m_ConditionMode: Option<i32>,
    pub m_EventTreshold: Option<f32>,
    pub m_ExitTime: Option<f32>,
}

impl_object!(Condition);

impl Clone for Condition {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ConditionEvent: self.m_ConditionEvent.clone(),
            m_ConditionMode: self.m_ConditionMode.clone(),
            m_EventTreshold: self.m_EventTreshold.clone(),
            m_ExitTime: self.m_ExitTime.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ConditionConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ConditionMode: Option<u32>,
    pub m_EventID: Option<u32>,
    pub m_EventThreshold: Option<f32>,
    pub m_ExitTime: Option<f32>,
}

impl_object!(ConditionConstant);

impl Clone for ConditionConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ConditionMode: self.m_ConditionMode.clone(),
            m_EventID: self.m_EventID.clone(),
            m_EventThreshold: self.m_EventThreshold.clone(),
            m_ExitTime: self.m_ExitTime.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ConfigSetting {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub flags: Option<u32>,
    pub value: Option<String>,
}

impl_object!(ConfigSetting);

impl Clone for ConfigSetting {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            flags: self.flags.clone(),
            value: self.value.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ConstantBuffer {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_IsPartialCB: Option<bool>,
    pub m_MatrixParams: Option<Vec<MatrixParameter>>,
    pub m_NameIndex: Option<i32>,
    pub m_Size: Option<i32>,
    pub m_StructParams: Option<Vec<StructParameter>>,
    pub m_VectorParams: Option<Vec<VectorParameter>>,
}

impl_object!(ConstantBuffer);

impl Clone for ConstantBuffer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_IsPartialCB: self.m_IsPartialCB.clone(),
            m_MatrixParams: self.m_MatrixParams.clone(),
            m_NameIndex: self.m_NameIndex.clone(),
            m_Size: self.m_Size.clone(),
            m_StructParams: self.m_StructParams.clone(),
            m_VectorParams: self.m_VectorParams.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ConstantClip {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub data: Option<Vec<f32>>,
}

impl_object!(ConstantClip);

impl Clone for ConstantClip {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            data: self.data.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ConstraintSource {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub sourceTransform: Option<PPtrData<Transform>>,
    pub weight: Option<f32>,
}

impl_object!(ConstraintSource);

impl Clone for ConstraintSource {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            sourceTransform: self.sourceTransform.clone(),
            weight: self.weight.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ControllerConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DefaultValues: Option<OffsetPtr>,
    pub m_HumanLayerArray: Option<Vec<OffsetPtr>>,
    pub m_LayerArray: Option<Vec<OffsetPtr>>,
    pub m_StateMachineArray: Option<Vec<OffsetPtr>>,
    pub m_Values: Option<OffsetPtr>,
}

impl_object!(ControllerConstant);

impl Clone for ControllerConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DefaultValues: self.m_DefaultValues.clone(),
            m_HumanLayerArray: self.m_HumanLayerArray.clone(),
            m_LayerArray: self.m_LayerArray.clone(),
            m_StateMachineArray: self.m_StateMachineArray.clone(),
            m_Values: self.m_Values.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CrashReportingSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<bool>,
    pub m_EventUrl: Option<String>,
    pub m_LogBufferSize: Option<u32>,
    pub m_NativeEventUrl: Option<String>,
}

impl_object!(CrashReportingSettings);

impl Clone for CrashReportingSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_EventUrl: self.m_EventUrl.clone(),
            m_LogBufferSize: self.m_LogBufferSize.clone(),
            m_NativeEventUrl: self.m_NativeEventUrl.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct CustomDataModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub color0: Option<MinMaxGradient>,
    pub color1: Option<MinMaxGradient>,
    pub enabled: Option<bool>,
    pub mode0: Option<i32>,
    pub mode1: Option<i32>,
    pub vector0_0: Option<MinMaxCurve>,
    pub vector0_1: Option<MinMaxCurve>,
    pub vector0_2: Option<MinMaxCurve>,
    pub vector0_3: Option<MinMaxCurve>,
    pub vector1_0: Option<MinMaxCurve>,
    pub vector1_1: Option<MinMaxCurve>,
    pub vector1_2: Option<MinMaxCurve>,
    pub vector1_3: Option<MinMaxCurve>,
    pub vectorComponentCount0: Option<i32>,
    pub vectorComponentCount1: Option<i32>,
}

impl_object!(CustomDataModule);

impl Clone for CustomDataModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            color0: self.color0.clone(),
            color1: self.color1.clone(),
            enabled: self.enabled.clone(),
            mode0: self.mode0.clone(),
            mode1: self.mode1.clone(),
            vector0_0: self.vector0_0.clone(),
            vector0_1: self.vector0_1.clone(),
            vector0_2: self.vector0_2.clone(),
            vector0_3: self.vector0_3.clone(),
            vector1_0: self.vector1_0.clone(),
            vector1_1: self.vector1_1.clone(),
            vector1_2: self.vector1_2.clone(),
            vector1_3: self.vector1_3.clone(),
            vectorComponentCount0: self.vectorComponentCount0.clone(),
            vectorComponentCount1: self.vectorComponentCount1.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DataTemplate {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Father: Option<PPtrData<DataTemplate>>,
    pub m_IsDataTemplate: Option<bool>,
    pub m_LastMergeIdentifier: Option<GUID>,
    pub m_Name: Option<String>,
    pub m_Objects: Option<Vec<PPtrData<EditorExtension>>>,
}

impl_object!(DataTemplate);

impl Clone for DataTemplate {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Father: self.m_Father.clone(),
            m_IsDataTemplate: self.m_IsDataTemplate.clone(),
            m_LastMergeIdentifier: self.m_LastMergeIdentifier.clone(),
            m_Name: self.m_Name.clone(),
            m_Objects: self.m_Objects.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DateTime {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub ticks: Option<i64>,
}

impl_object!(DateTime);

impl Clone for DateTime {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            ticks: self.ticks.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DefaultPreset {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Disabled: Option<bool>,
    pub m_Filter: Option<String>,
    pub m_Preset: Option<PPtrData<Preset>>,
}

impl_object!(DefaultPreset);

impl Clone for DefaultPreset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Disabled: self.m_Disabled.clone(),
            m_Filter: self.m_Filter.clone(),
            m_Preset: self.m_Preset.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DefaultPresetList {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub defaultPresets: Option<Vec<DefaultPreset>>,
    pub typ: Option<PresetType>,
}

impl_object!(DefaultPresetList);

impl Clone for DefaultPresetList {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            defaultPresets: self.defaultPresets.clone(),
            typ: self.typ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DeletedItem {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub changeset: Option<i32>,
    pub digest: Option<Hash128>,
    pub fullPath: Option<String>,
    pub guid: Option<GUID>,
    pub parent: Option<GUID>,
    pub typ: Option<i32>,
}

impl_object!(DeletedItem);

impl Clone for DeletedItem {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            changeset: self.changeset.clone(),
            digest: self.digest.clone(),
            fullPath: self.fullPath.clone(),
            guid: self.guid.clone(),
            parent: self.parent.clone(),
            typ: self.typ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DenseClip {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BeginTime: Option<f32>,
    pub m_CurveCount: Option<u32>,
    pub m_FrameCount: Option<i32>,
    pub m_SampleArray: Option<Vec<f32>>,
    pub m_SampleRate: Option<f32>,
}

impl_object!(DenseClip);

impl Clone for DenseClip {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BeginTime: self.m_BeginTime.clone(),
            m_CurveCount: self.m_CurveCount.clone(),
            m_FrameCount: self.m_FrameCount.clone(),
            m_SampleArray: self.m_SampleArray.clone(),
            m_SampleRate: self.m_SampleRate.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DetailDatabase {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub WavingGrassTint: Option<Color>,
    pub m_DefaultShaders_0_: Option<PPtrData<Shader>>,
    pub m_DefaultShaders_1_: Option<PPtrData<Shader>>,
    pub m_DefaultShaders_2_: Option<PPtrData<Shader>>,
    pub m_DetailBillboardShader: Option<PPtrData<Shader>>,
    pub m_DetailMeshGrassShader: Option<PPtrData<Shader>>,
    pub m_DetailMeshLitShader: Option<PPtrData<Shader>>,
    pub m_DetailPrototypes: Option<Vec<DetailPrototype>>,
    pub m_DetailScatterMode: Option<i32>,
    pub m_PatchCount: Option<i32>,
    pub m_PatchSamples: Option<i32>,
    pub m_Patches: Option<Vec<DetailPatch>>,
    pub m_PreloadTextureAtlasData: Option<Vec<PPtrData<Texture2D>>>,
    pub m_RandomRotations: Option<Vec<Vector3>>,
    pub m_TreeInstances: Option<Vec<TreeInstance>>,
    pub m_TreePrototypes: Option<Vec<TreePrototype>>,
    pub m_WavingGrassAmount: Option<f32>,
    pub m_WavingGrassSpeed: Option<f32>,
    pub m_WavingGrassStrength: Option<f32>,
}

impl_object!(DetailDatabase);

impl Clone for DetailDatabase {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            WavingGrassTint: self.WavingGrassTint.clone(),
            m_DefaultShaders_0_: self.m_DefaultShaders_0_.clone(),
            m_DefaultShaders_1_: self.m_DefaultShaders_1_.clone(),
            m_DefaultShaders_2_: self.m_DefaultShaders_2_.clone(),
            m_DetailBillboardShader: self.m_DetailBillboardShader.clone(),
            m_DetailMeshGrassShader: self.m_DetailMeshGrassShader.clone(),
            m_DetailMeshLitShader: self.m_DetailMeshLitShader.clone(),
            m_DetailPrototypes: self.m_DetailPrototypes.clone(),
            m_DetailScatterMode: self.m_DetailScatterMode.clone(),
            m_PatchCount: self.m_PatchCount.clone(),
            m_PatchSamples: self.m_PatchSamples.clone(),
            m_Patches: self.m_Patches.clone(),
            m_PreloadTextureAtlasData: self.m_PreloadTextureAtlasData.clone(),
            m_RandomRotations: self.m_RandomRotations.clone(),
            m_TreeInstances: self.m_TreeInstances.clone(),
            m_TreePrototypes: self.m_TreePrototypes.clone(),
            m_WavingGrassAmount: self.m_WavingGrassAmount.clone(),
            m_WavingGrassSpeed: self.m_WavingGrassSpeed.clone(),
            m_WavingGrassStrength: self.m_WavingGrassStrength.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DetailPatch {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bounds: Option<AABB>,
    pub coverage: Option<Vec<u8>>,
    pub layerIndices: Option<Vec<u8>>,
    pub numberOfObjects: Option<Vec<u8>>,
}

impl_object!(DetailPatch);

impl Clone for DetailPatch {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bounds: self.bounds.clone(),
            coverage: self.coverage.clone(),
            layerIndices: self.layerIndices.clone(),
            numberOfObjects: self.numberOfObjects.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DetailPrototype {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub alignToGround: Option<f32>,
    pub bendFactor: Option<f32>,
    pub density: Option<f32>,
    pub dryColor: Option<Color>,
    pub healthyColor: Option<Color>,
    pub holeTestRadius: Option<f32>,
    pub lightmapFactor: Option<f32>,
    pub maxHeight: Option<f32>,
    pub maxWidth: Option<f32>,
    pub minHeight: Option<f32>,
    pub minWidth: Option<f32>,
    pub noiseSeed: Option<i32>,
    pub noiseSpread: Option<f32>,
    pub positionJitter: Option<f32>,
    pub positionOrderliness: Option<f32>,
    pub prototype: Option<PPtrData<GameObject>>,
    pub prototypeTexture: Option<PPtrData<Texture2D>>,
    pub renderMode: Option<i32>,
    pub targetCoverage: Option<f32>,
    pub useDensityScaling: Option<i32>,
    pub useInstancing: Option<i32>,
    pub usePrototypeMesh: Option<i32>,
}

impl_object!(DetailPrototype);

impl Clone for DetailPrototype {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            alignToGround: self.alignToGround.clone(),
            bendFactor: self.bendFactor.clone(),
            density: self.density.clone(),
            dryColor: self.dryColor.clone(),
            healthyColor: self.healthyColor.clone(),
            holeTestRadius: self.holeTestRadius.clone(),
            lightmapFactor: self.lightmapFactor.clone(),
            maxHeight: self.maxHeight.clone(),
            maxWidth: self.maxWidth.clone(),
            minHeight: self.minHeight.clone(),
            minWidth: self.minWidth.clone(),
            noiseSeed: self.noiseSeed.clone(),
            noiseSpread: self.noiseSpread.clone(),
            positionJitter: self.positionJitter.clone(),
            positionOrderliness: self.positionOrderliness.clone(),
            prototype: self.prototype.clone(),
            prototypeTexture: self.prototypeTexture.clone(),
            renderMode: self.renderMode.clone(),
            targetCoverage: self.targetCoverage.clone(),
            useDensityScaling: self.useDensityScaling.clone(),
            useInstancing: self.useInstancing.clone(),
            usePrototypeMesh: self.usePrototypeMesh.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DeviceNone {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(DeviceNone);

impl Clone for DeviceNone {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DirectorGenericBinding {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub key: Option<PPtrData<Object>>,
    pub value: Option<PPtrData<Object>>,
}

impl_object!(DirectorGenericBinding);

impl Clone for DirectorGenericBinding {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            key: self.key.clone(),
            value: self.value.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct DirectorPlayer {
    // extends Behaviour
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GameObject: Option<PPtrData<GameObject>>,
}

impl_object!(DirectorPlayer);

impl Clone for DirectorPlayer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GameObject: self.m_GameObject.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EffectConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bypass: Option<bool>,
    pub groupConstantIndex: Option<u32>,
    pub parameterIndices: Option<Vec<u32>>,
    pub prevEffectIndex: Option<u32>,
    pub sendTargetEffectIndex: Option<u32>,
    pub typ: Option<i32>,
    pub wetMixLevelIndex: Option<u32>,
}

impl_object!(EffectConstant);

impl Clone for EffectConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bypass: self.bypass.clone(),
            groupConstantIndex: self.groupConstantIndex.clone(),
            parameterIndices: self.parameterIndices.clone(),
            prevEffectIndex: self.prevEffectIndex.clone(),
            sendTargetEffectIndex: self.sendTargetEffectIndex.clone(),
            typ: self.typ.clone(),
            wetMixLevelIndex: self.wetMixLevelIndex.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EmbeddedNativeType {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_FloatArray: Option<Vec<f32>>,
    pub m_String: Option<String>,
}

impl_object!(EmbeddedNativeType);

impl Clone for EmbeddedNativeType {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_FloatArray: self.m_FloatArray.clone(),
            m_String: self.m_String.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EmissionModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub cnt0: Option<i32>,
    pub cnt1: Option<i32>,
    pub cnt2: Option<i32>,
    pub cnt3: Option<i32>,
    pub cntmax0: Option<i32>,
    pub cntmax1: Option<i32>,
    pub cntmax2: Option<i32>,
    pub cntmax3: Option<i32>,
    pub enabled: Option<bool>,
    pub m_BurstCount: Option<i32>,
    pub m_Bursts: Option<Vec<ParticleSystemEmissionBurst>>,
    pub m_Type: Option<i32>,
    pub rate: Option<MinMaxCurve>,
    pub rateOverDistance: Option<MinMaxCurve>,
    pub rateOverTime: Option<MinMaxCurve>,
    pub time0: Option<f32>,
    pub time1: Option<f32>,
    pub time2: Option<f32>,
    pub time3: Option<f32>,
}

impl_object!(EmissionModule);

impl Clone for EmissionModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            cnt0: self.cnt0.clone(),
            cnt1: self.cnt1.clone(),
            cnt2: self.cnt2.clone(),
            cnt3: self.cnt3.clone(),
            cntmax0: self.cntmax0.clone(),
            cntmax1: self.cntmax1.clone(),
            cntmax2: self.cntmax2.clone(),
            cntmax3: self.cntmax3.clone(),
            enabled: self.enabled.clone(),
            m_BurstCount: self.m_BurstCount.clone(),
            m_Bursts: self.m_Bursts.clone(),
            m_Type: self.m_Type.clone(),
            rate: self.rate.clone(),
            rateOverDistance: self.rateOverDistance.clone(),
            rateOverTime: self.rateOverTime.clone(),
            time0: self.time0.clone(),
            time1: self.time1.clone(),
            time2: self.time2.clone(),
            time3: self.time3.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EnlightenRendererInformation {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub dynamicLightmapSTInSystem: Option<Vector4>,
    pub instanceHash: Option<Hash128>,
    pub renderer: Option<PPtrData<Object>>,
    pub systemId: Option<i32>,
}

impl_object!(EnlightenRendererInformation);

impl Clone for EnlightenRendererInformation {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            dynamicLightmapSTInSystem: self.dynamicLightmapSTInSystem.clone(),
            instanceHash: self.instanceHash.clone(),
            renderer: self.renderer.clone(),
            systemId: self.systemId.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EnlightenSceneMapping {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Probesets: Option<Vec<Hash128>>,
    pub m_Renderers: Option<Vec<EnlightenRendererInformation>>,
    pub m_SystemAtlases: Option<Vec<EnlightenSystemAtlasInformation>>,
    pub m_Systems: Option<Vec<EnlightenSystemInformation>>,
    pub m_TerrainChunks: Option<Vec<EnlightenTerrainChunksInformation>>,
}

impl_object!(EnlightenSceneMapping);

impl Clone for EnlightenSceneMapping {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Probesets: self.m_Probesets.clone(),
            m_Renderers: self.m_Renderers.clone(),
            m_SystemAtlases: self.m_SystemAtlases.clone(),
            m_Systems: self.m_Systems.clone(),
            m_TerrainChunks: self.m_TerrainChunks.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EnlightenSystemAtlasInformation {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub atlasHash: Option<Hash128>,
    pub atlasSize: Option<i32>,
    pub firstSystemId: Option<i32>,
}

impl_object!(EnlightenSystemAtlasInformation);

impl Clone for EnlightenSystemAtlasInformation {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            atlasHash: self.atlasHash.clone(),
            atlasSize: self.atlasSize.clone(),
            firstSystemId: self.firstSystemId.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EnlightenSystemInformation {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub atlasIndex: Option<i32>,
    pub atlasOffsetX: Option<i32>,
    pub atlasOffsetY: Option<i32>,
    pub inputSystemHash: Option<Hash128>,
    pub radiositySystemHash: Option<Hash128>,
    pub rendererIndex: Option<u32>,
    pub rendererSize: Option<u32>,
}

impl_object!(EnlightenSystemInformation);

impl Clone for EnlightenSystemInformation {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            atlasIndex: self.atlasIndex.clone(),
            atlasOffsetX: self.atlasOffsetX.clone(),
            atlasOffsetY: self.atlasOffsetY.clone(),
            inputSystemHash: self.inputSystemHash.clone(),
            radiositySystemHash: self.radiositySystemHash.clone(),
            rendererIndex: self.rendererIndex.clone(),
            rendererSize: self.rendererSize.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct EnlightenTerrainChunksInformation {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub firstSystemId: Option<i32>,
    pub numChunksInX: Option<i32>,
    pub numChunksInY: Option<i32>,
}

impl_object!(EnlightenTerrainChunksInformation);

impl Clone for EnlightenTerrainChunksInformation {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            firstSystemId: self.firstSystemId.clone(),
            numChunksInX: self.numChunksInX.clone(),
            numChunksInY: self.numChunksInY.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ExpandedData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ClassID: Option<i32>,
    pub m_ExpandedProperties: Option<Vec<String>>,
    pub m_InspectorExpanded: Option<bool>,
    pub m_ScriptClass: Option<String>,
}

impl_object!(ExpandedData);

impl Clone for ExpandedData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ClassID: self.m_ClassID.clone(),
            m_ExpandedProperties: self.m_ExpandedProperties.clone(),
            m_InspectorExpanded: self.m_InspectorExpanded.clone(),
            m_ScriptClass: self.m_ScriptClass.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ExposedReferenceTable {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_References: Option<Vec<(String, PPtrData<Object>)>>,
}

impl_object!(ExposedReferenceTable);

impl Clone for ExposedReferenceTable {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_References: self.m_References.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Expression {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub data_0_: Option<i32>,
    pub data_1_: Option<i32>,
    pub data_2_: Option<i32>,
    pub data_3_: Option<i32>,
    pub op: Option<i32>,
    pub valueIndex: Option<i32>,
}

impl_object!(Expression);

impl Clone for Expression {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            data_0_: self.data_0_.clone(),
            data_1_: self.data_1_.clone(),
            data_2_: self.data_2_.clone(),
            data_3_: self.data_3_.clone(),
            op: self.op.clone(),
            valueIndex: self.valueIndex.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ExtensionPropertyValue {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub extensionName: Option<String>,
    pub pluginName: Option<String>,
    pub propertyName: Option<String>,
    pub propertyValue: Option<f32>,
}

impl_object!(ExtensionPropertyValue);

impl Clone for ExtensionPropertyValue {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            extensionName: self.extensionName.clone(),
            pluginName: self.pluginName.clone(),
            propertyName: self.propertyName.clone(),
            propertyValue: self.propertyValue.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ExternalForcesModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub enabled: Option<bool>,
    pub influenceFilter: Option<i32>,
    pub influenceList: Option<Vec<PPtrData<ParticleSystemForceField>>>,
    pub influenceMask: Option<BitField>,
    pub multiplier: Option<f32>,
    pub multiplierCurve: Option<MinMaxCurve>,
}

impl_object!(ExternalForcesModule);

impl Clone for ExternalForcesModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            enabled: self.enabled.clone(),
            influenceFilter: self.influenceFilter.clone(),
            influenceList: self.influenceList.clone(),
            influenceMask: self.influenceMask.clone(),
            multiplier: self.multiplier.clone(),
            multiplierCurve: self.multiplierCurve.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct FalloffTable {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Table_0_: Option<f32>,
    pub m_Table_10_: Option<f32>,
    pub m_Table_11_: Option<f32>,
    pub m_Table_12_: Option<f32>,
    pub m_Table_1_: Option<f32>,
    pub m_Table_2_: Option<f32>,
    pub m_Table_3_: Option<f32>,
    pub m_Table_4_: Option<f32>,
    pub m_Table_5_: Option<f32>,
    pub m_Table_6_: Option<f32>,
    pub m_Table_7_: Option<f32>,
    pub m_Table_8_: Option<f32>,
    pub m_Table_9_: Option<f32>,
}

impl_object!(FalloffTable);

impl Clone for FalloffTable {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Table_0_: self.m_Table_0_.clone(),
            m_Table_10_: self.m_Table_10_.clone(),
            m_Table_11_: self.m_Table_11_.clone(),
            m_Table_12_: self.m_Table_12_.clone(),
            m_Table_1_: self.m_Table_1_.clone(),
            m_Table_2_: self.m_Table_2_.clone(),
            m_Table_3_: self.m_Table_3_.clone(),
            m_Table_4_: self.m_Table_4_.clone(),
            m_Table_5_: self.m_Table_5_.clone(),
            m_Table_6_: self.m_Table_6_.clone(),
            m_Table_7_: self.m_Table_7_.clone(),
            m_Table_8_: self.m_Table_8_.clone(),
            m_Table_9_: self.m_Table_9_.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct FastPropertyName {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub name: Option<String>,
}

impl_object!(FastPropertyName);

impl Clone for FastPropertyName {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            name: self.name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct FlareElement {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Color: Option<Color>,
    pub m_Fade: Option<bool>,
    pub m_ImageIndex: Option<u32>,
    pub m_Position: Option<f32>,
    pub m_Rotate: Option<bool>,
    pub m_Size: Option<f32>,
    pub m_UseLightColor: Option<bool>,
    pub m_Zoom: Option<bool>,
}

impl_object!(FlareElement);

impl Clone for FlareElement {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Color: self.m_Color.clone(),
            m_Fade: self.m_Fade.clone(),
            m_ImageIndex: self.m_ImageIndex.clone(),
            m_Position: self.m_Position.clone(),
            m_Rotate: self.m_Rotate.clone(),
            m_Size: self.m_Size.clone(),
            m_UseLightColor: self.m_UseLightColor.clone(),
            m_Zoom: self.m_Zoom.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct FloatCurve {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub attribute: Option<String>,
    pub classID: Option<i32>,
    pub curve: Option<AnimationCurve>,
    pub flags: Option<i32>,
    pub path: Option<String>,
    pub script: Option<PPtrData<MonoScript>>,
}

impl_object!(FloatCurve);

impl Clone for FloatCurve {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            attribute: self.attribute.clone(),
            classID: self.classID.clone(),
            curve: self.curve.clone(),
            flags: self.flags.clone(),
            path: self.path.clone(),
            script: self.script.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ForceModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub enabled: Option<bool>,
    pub inWorldSpace: Option<bool>,
    pub randomizePerFrame: Option<bool>,
    pub x: Option<MinMaxCurve>,
    pub y: Option<MinMaxCurve>,
    pub z: Option<MinMaxCurve>,
}

impl_object!(ForceModule);

impl Clone for ForceModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            enabled: self.enabled.clone(),
            inWorldSpace: self.inWorldSpace.clone(),
            randomizePerFrame: self.randomizePerFrame.clone(),
            x: self.x.clone(),
            y: self.y.clone(),
            z: self.z.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GISettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AlbedoBoost: Option<f32>,
    pub m_BounceScale: Option<f32>,
    pub m_EnableBakedLightmaps: Option<bool>,
    pub m_EnableRealtimeLightmaps: Option<bool>,
    pub m_EnvironmentLightingMode: Option<u32>,
    pub m_IndirectOutputScale: Option<f32>,
    pub m_TemporalCoherenceThreshold: Option<f32>,
}

impl_object!(GISettings);

impl Clone for GISettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AlbedoBoost: self.m_AlbedoBoost.clone(),
            m_BounceScale: self.m_BounceScale.clone(),
            m_EnableBakedLightmaps: self.m_EnableBakedLightmaps.clone(),
            m_EnableRealtimeLightmaps: self.m_EnableRealtimeLightmaps.clone(),
            m_EnvironmentLightingMode: self.m_EnvironmentLightingMode.clone(),
            m_IndirectOutputScale: self.m_IndirectOutputScale.clone(),
            m_TemporalCoherenceThreshold: self.m_TemporalCoherenceThreshold.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GLTextureSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Aniso: Option<i32>,
    pub m_FilterMode: Option<i32>,
    pub m_MipBias: Option<f32>,
    pub m_WrapMode: Option<i32>,
    pub m_WrapU: Option<i32>,
    pub m_WrapV: Option<i32>,
    pub m_WrapW: Option<i32>,
}

impl_object!(GLTextureSettings);

impl Clone for GLTextureSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Aniso: self.m_Aniso.clone(),
            m_FilterMode: self.m_FilterMode.clone(),
            m_MipBias: self.m_MipBias.clone(),
            m_WrapMode: self.m_WrapMode.clone(),
            m_WrapU: self.m_WrapU.clone(),
            m_WrapV: self.m_WrapV.clone(),
            m_WrapW: self.m_WrapW.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GUID {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub data_0_: Option<u32>,
    pub data_1_: Option<u32>,
    pub data_2_: Option<u32>,
    pub data_3_: Option<u32>,
}

impl_object!(GUID);

impl Clone for GUID {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            data_0_: self.data_0_.clone(),
            data_1_: self.data_1_.clone(),
            data_2_: self.data_2_.clone(),
            data_3_: self.data_3_.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GenericBinding {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub attribute: Option<u32>,
    pub classID: Option<u16>,
    pub customType: Option<u8>,
    pub isIntCurve: Option<u8>,
    pub isPPtrCurve: Option<u8>,
    pub isSerializeReferenceCurve: Option<u8>,
    pub path: Option<u32>,
    pub script: Option<PPtrData<Object>>,
    pub typeID: Option<i32>,
}

impl_object!(GenericBinding);

impl Clone for GenericBinding {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            attribute: self.attribute.clone(),
            classID: self.classID.clone(),
            customType: self.customType.clone(),
            isIntCurve: self.isIntCurve.clone(),
            isPPtrCurve: self.isPPtrCurve.clone(),
            isSerializeReferenceCurve: self.isSerializeReferenceCurve.clone(),
            path: self.path.clone(),
            script: self.script.clone(),
            typeID: self.typeID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GfxBlendState {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub alphaToMask: Option<u8>,
    pub rt: Option<Vec<GfxRenderTargetBlendState>>,
    pub separateMRTBlend: Option<u8>,
}

impl_object!(GfxBlendState);

impl Clone for GfxBlendState {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            alphaToMask: self.alphaToMask.clone(),
            rt: self.rt.clone(),
            separateMRTBlend: self.separateMRTBlend.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GfxDepthState {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub depthFunc: Option<i8>,
    pub depthWrite: Option<u8>,
}

impl_object!(GfxDepthState);

impl Clone for GfxDepthState {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            depthFunc: self.depthFunc.clone(),
            depthWrite: self.depthWrite.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GfxRasterState {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub conservative: Option<u8>,
    pub cullMode: Option<i32>,
    pub depthBias: Option<i32>,
    pub depthClip: Option<u8>,
    pub slopeScaledDepthBias: Option<f32>,
}

impl_object!(GfxRasterState);

impl Clone for GfxRasterState {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            conservative: self.conservative.clone(),
            cullMode: self.cullMode.clone(),
            depthBias: self.depthBias.clone(),
            depthClip: self.depthClip.clone(),
            slopeScaledDepthBias: self.slopeScaledDepthBias.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GfxRenderTargetBlendState {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub blendOp: Option<u8>,
    pub blendOpAlpha: Option<u8>,
    pub dstBlend: Option<u8>,
    pub dstBlendAlpha: Option<u8>,
    pub srcBlend: Option<u8>,
    pub srcBlendAlpha: Option<u8>,
    pub writeMask: Option<u8>,
}

impl_object!(GfxRenderTargetBlendState);

impl Clone for GfxRenderTargetBlendState {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            blendOp: self.blendOp.clone(),
            blendOpAlpha: self.blendOpAlpha.clone(),
            dstBlend: self.dstBlend.clone(),
            dstBlendAlpha: self.dstBlendAlpha.clone(),
            srcBlend: self.srcBlend.clone(),
            srcBlendAlpha: self.srcBlendAlpha.clone(),
            writeMask: self.writeMask.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GfxStencilState {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub padding: Option<u8>,
    pub readMask: Option<u8>,
    pub stencilEnable: Option<u8>,
    pub stencilFailOpBack: Option<u8>,
    pub stencilFailOpFront: Option<u8>,
    pub stencilFuncBack: Option<u8>,
    pub stencilFuncFront: Option<u8>,
    pub stencilPassOpBack: Option<u8>,
    pub stencilPassOpFront: Option<u8>,
    pub stencilZFailOpBack: Option<u8>,
    pub stencilZFailOpFront: Option<u8>,
    pub writeMask: Option<u8>,
}

impl_object!(GfxStencilState);

impl Clone for GfxStencilState {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            padding: self.padding.clone(),
            readMask: self.readMask.clone(),
            stencilEnable: self.stencilEnable.clone(),
            stencilFailOpBack: self.stencilFailOpBack.clone(),
            stencilFailOpFront: self.stencilFailOpFront.clone(),
            stencilFuncBack: self.stencilFuncBack.clone(),
            stencilFuncFront: self.stencilFuncFront.clone(),
            stencilPassOpBack: self.stencilPassOpBack.clone(),
            stencilPassOpFront: self.stencilPassOpFront.clone(),
            stencilZFailOpBack: self.stencilZFailOpBack.clone(),
            stencilZFailOpFront: self.stencilZFailOpFront.clone(),
            writeMask: self.writeMask.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Google {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub depthFormat: Option<i32>,
    pub enableTransitionView: Option<bool>,
    pub enableVideoLayer: Option<bool>,
    pub maximumSupportedHeadTracking: Option<i32>,
    pub minimumSupportedHeadTracking: Option<i32>,
    pub useProtectedVideoMemory: Option<bool>,
    pub useSustainedPerformanceMode: Option<bool>,
}

impl_object!(Google);

impl Clone for Google {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            depthFormat: self.depthFormat.clone(),
            enableTransitionView: self.enableTransitionView.clone(),
            enableVideoLayer: self.enableVideoLayer.clone(),
            maximumSupportedHeadTracking: self.maximumSupportedHeadTracking.clone(),
            minimumSupportedHeadTracking: self.minimumSupportedHeadTracking.clone(),
            useProtectedVideoMemory: self.useProtectedVideoMemory.clone(),
            useSustainedPerformanceMode: self.useSustainedPerformanceMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Gradient {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub atime0: Option<u16>,
    pub atime1: Option<u16>,
    pub atime2: Option<u16>,
    pub atime3: Option<u16>,
    pub atime4: Option<u16>,
    pub atime5: Option<u16>,
    pub atime6: Option<u16>,
    pub atime7: Option<u16>,
    pub ctime0: Option<u16>,
    pub ctime1: Option<u16>,
    pub ctime2: Option<u16>,
    pub ctime3: Option<u16>,
    pub ctime4: Option<u16>,
    pub ctime5: Option<u16>,
    pub ctime6: Option<u16>,
    pub ctime7: Option<u16>,
    pub key0: Option<Color>,
    pub key1: Option<Color>,
    pub key2: Option<Color>,
    pub key3: Option<Color>,
    pub key4: Option<Color>,
    pub key5: Option<Color>,
    pub key6: Option<Color>,
    pub key7: Option<Color>,
    pub m_ColorSpace: Option<i8>,
    pub m_Color_0_: Option<Color>,
    pub m_Color_1_: Option<Color>,
    pub m_Color_2_: Option<Color>,
    pub m_Color_3_: Option<Color>,
    pub m_Color_4_: Option<Color>,
    pub m_Mode: Option<i32>,
    pub m_NumAlphaKeys: Option<u8>,
    pub m_NumColorKeys: Option<u8>,
}

impl_object!(Gradient);

impl Clone for Gradient {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            atime0: self.atime0.clone(),
            atime1: self.atime1.clone(),
            atime2: self.atime2.clone(),
            atime3: self.atime3.clone(),
            atime4: self.atime4.clone(),
            atime5: self.atime5.clone(),
            atime6: self.atime6.clone(),
            atime7: self.atime7.clone(),
            ctime0: self.ctime0.clone(),
            ctime1: self.ctime1.clone(),
            ctime2: self.ctime2.clone(),
            ctime3: self.ctime3.clone(),
            ctime4: self.ctime4.clone(),
            ctime5: self.ctime5.clone(),
            ctime6: self.ctime6.clone(),
            ctime7: self.ctime7.clone(),
            key0: self.key0.clone(),
            key1: self.key1.clone(),
            key2: self.key2.clone(),
            key3: self.key3.clone(),
            key4: self.key4.clone(),
            key5: self.key5.clone(),
            key6: self.key6.clone(),
            key7: self.key7.clone(),
            m_ColorSpace: self.m_ColorSpace.clone(),
            m_Color_0_: self.m_Color_0_.clone(),
            m_Color_1_: self.m_Color_1_.clone(),
            m_Color_2_: self.m_Color_2_.clone(),
            m_Color_3_: self.m_Color_3_.clone(),
            m_Color_4_: self.m_Color_4_.clone(),
            m_Mode: self.m_Mode.clone(),
            m_NumAlphaKeys: self.m_NumAlphaKeys.clone(),
            m_NumColorKeys: self.m_NumColorKeys.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GradientNEW {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub atime0: Option<u16>,
    pub atime1: Option<u16>,
    pub atime2: Option<u16>,
    pub atime3: Option<u16>,
    pub atime4: Option<u16>,
    pub atime5: Option<u16>,
    pub atime6: Option<u16>,
    pub atime7: Option<u16>,
    pub ctime0: Option<u16>,
    pub ctime1: Option<u16>,
    pub ctime2: Option<u16>,
    pub ctime3: Option<u16>,
    pub ctime4: Option<u16>,
    pub ctime5: Option<u16>,
    pub ctime6: Option<u16>,
    pub ctime7: Option<u16>,
    pub key0: Option<Color>,
    pub key1: Option<Color>,
    pub key2: Option<Color>,
    pub key3: Option<Color>,
    pub key4: Option<Color>,
    pub key5: Option<Color>,
    pub key6: Option<Color>,
    pub key7: Option<Color>,
    pub m_NumAlphaKeys: Option<u8>,
    pub m_NumColorKeys: Option<u8>,
}

impl_object!(GradientNEW);

impl Clone for GradientNEW {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            atime0: self.atime0.clone(),
            atime1: self.atime1.clone(),
            atime2: self.atime2.clone(),
            atime3: self.atime3.clone(),
            atime4: self.atime4.clone(),
            atime5: self.atime5.clone(),
            atime6: self.atime6.clone(),
            atime7: self.atime7.clone(),
            ctime0: self.ctime0.clone(),
            ctime1: self.ctime1.clone(),
            ctime2: self.ctime2.clone(),
            ctime3: self.ctime3.clone(),
            ctime4: self.ctime4.clone(),
            ctime5: self.ctime5.clone(),
            ctime6: self.ctime6.clone(),
            ctime7: self.ctime7.clone(),
            key0: self.key0.clone(),
            key1: self.key1.clone(),
            key2: self.key2.clone(),
            key3: self.key3.clone(),
            key4: self.key4.clone(),
            key5: self.key5.clone(),
            key6: self.key6.clone(),
            key7: self.key7.clone(),
            m_NumAlphaKeys: self.m_NumAlphaKeys.clone(),
            m_NumColorKeys: self.m_NumColorKeys.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GraphicsStateInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub appBackface: Option<bool>,
    pub depthBias: Option<f32>,
    pub forceCullMode: Option<i32>,
    pub invertProjectionMatrix: Option<bool>,
    pub renderPass: Option<u64>,
    pub renderState: Option<u64>,
    pub slopeDepthBias: Option<f32>,
    pub subPassIndex: Option<i32>,
    pub topology: Option<i32>,
    pub userBackface: Option<bool>,
    pub vertexLayout: Option<u64>,
    pub wireframe: Option<bool>,
}

impl_object!(GraphicsStateInfo);

impl Clone for GraphicsStateInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            appBackface: self.appBackface.clone(),
            depthBias: self.depthBias.clone(),
            forceCullMode: self.forceCullMode.clone(),
            invertProjectionMatrix: self.invertProjectionMatrix.clone(),
            renderPass: self.renderPass.clone(),
            renderState: self.renderState.clone(),
            slopeDepthBias: self.slopeDepthBias.clone(),
            subPassIndex: self.subPassIndex.clone(),
            topology: self.topology.clone(),
            userBackface: self.userBackface.clone(),
            vertexLayout: self.vertexLayout.clone(),
            wireframe: self.wireframe.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GroupConnection {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub sendEffectIndex: Option<u32>,
    pub sourceGroupIndex: Option<u32>,
    pub targetGroupIndex: Option<u32>,
}

impl_object!(GroupConnection);

impl Clone for GroupConnection {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            sendEffectIndex: self.sendEffectIndex.clone(),
            sourceGroupIndex: self.sourceGroupIndex.clone(),
            targetGroupIndex: self.targetGroupIndex.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct GroupConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bypassEffects: Option<bool>,
    pub mute: Option<bool>,
    pub parentConstantIndex: Option<i32>,
    pub pitchIndex: Option<u32>,
    pub sendIndex: Option<u32>,
    pub solo: Option<bool>,
    pub volumeIndex: Option<u32>,
}

impl_object!(GroupConstant);

impl Clone for GroupConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bypassEffects: self.bypassEffects.clone(),
            mute: self.mute.clone(),
            parentConstantIndex: self.parentConstantIndex.clone(),
            pitchIndex: self.pitchIndex.clone(),
            sendIndex: self.sendIndex.clone(),
            solo: self.solo.clone(),
            volumeIndex: self.volumeIndex.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Hand {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_HandBoneIndex: Option<Vec<i32>>,
}

impl_object!(Hand);

impl Clone for Hand {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_HandBoneIndex: self.m_HandBoneIndex.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HandPose {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CloseOpen: Option<f32>,
    pub m_DoFArray: Option<Vec<f32>>,
    pub m_Grab: Option<f32>,
    pub m_GrabX: Option<xform>,
    pub m_InOut: Option<f32>,
    pub m_Override: Option<f32>,
}

impl_object!(HandPose);

impl Clone for HandPose {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CloseOpen: self.m_CloseOpen.clone(),
            m_DoFArray: self.m_DoFArray.clone(),
            m_Grab: self.m_Grab.clone(),
            m_GrabX: self.m_GrabX.clone(),
            m_InOut: self.m_InOut.clone(),
            m_Override: self.m_Override.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Handle {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ID: Option<u32>,
    pub m_ParentHumanIndex: Option<u32>,
    pub m_X: Option<xform>,
}

impl_object!(Handle);

impl Clone for Handle {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ID: self.m_ID.clone(),
            m_ParentHumanIndex: self.m_ParentHumanIndex.clone(),
            m_X: self.m_X.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Hash128 {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bytes_0_: Option<u8>,
    pub bytes_10_: Option<u8>,
    pub bytes_11_: Option<u8>,
    pub bytes_12_: Option<u8>,
    pub bytes_13_: Option<u8>,
    pub bytes_14_: Option<u8>,
    pub bytes_15_: Option<u8>,
    pub bytes_1_: Option<u8>,
    pub bytes_2_: Option<u8>,
    pub bytes_3_: Option<u8>,
    pub bytes_4_: Option<u8>,
    pub bytes_5_: Option<u8>,
    pub bytes_6_: Option<u8>,
    pub bytes_7_: Option<u8>,
    pub bytes_8_: Option<u8>,
    pub bytes_9_: Option<u8>,
}

impl_object!(Hash128);

impl Clone for Hash128 {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bytes_0_: self.bytes_0_.clone(),
            bytes_10_: self.bytes_10_.clone(),
            bytes_11_: self.bytes_11_.clone(),
            bytes_12_: self.bytes_12_.clone(),
            bytes_13_: self.bytes_13_.clone(),
            bytes_14_: self.bytes_14_.clone(),
            bytes_15_: self.bytes_15_.clone(),
            bytes_1_: self.bytes_1_.clone(),
            bytes_2_: self.bytes_2_.clone(),
            bytes_3_: self.bytes_3_.clone(),
            bytes_4_: self.bytes_4_.clone(),
            bytes_5_: self.bytes_5_.clone(),
            bytes_6_: self.bytes_6_.clone(),
            bytes_7_: self.bytes_7_.clone(),
            bytes_8_: self.bytes_8_.clone(),
            bytes_9_: self.bytes_9_.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HeightMeshBVNode {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub i: Option<i32>,
    pub max: Option<Vector3>,
    pub min: Option<Vector3>,
    pub n: Option<i32>,
}

impl_object!(HeightMeshBVNode);

impl Clone for HeightMeshBVNode {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            i: self.i.clone(),
            max: self.max.clone(),
            min: self.min.clone(),
            n: self.n.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HeightMeshData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Bounds: Option<AABB>,
    pub m_Indices: Option<Vec<i32>>,
    pub m_Nodes: Option<Vec<HeightMeshBVNode>>,
    pub m_Vertices: Option<Vec<Vector3>>,
}

impl_object!(HeightMeshData);

impl Clone for HeightMeshData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Bounds: self.m_Bounds.clone(),
            m_Indices: self.m_Indices.clone(),
            m_Nodes: self.m_Nodes.clone(),
            m_Vertices: self.m_Vertices.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Heightmap {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DefaultPhysicMaterial: Option<PPtrData<PhysicMaterial>>,
    pub m_EnableHolesTextureCompression: Option<bool>,
    pub m_EnableSurfaceMaskTextureCompression: Option<bool>,
    pub m_Height: Option<i32>,
    pub m_Heights: Option<Vec<i16>>,
    pub m_Holes: Option<Vec<u8>>,
    pub m_HolesLOD: Option<Vec<u8>>,
    pub m_Levels: Option<i32>,
    pub m_MinMaxPatchHeights: Option<Vec<f32>>,
    pub m_PrecomputedError: Option<Vec<f32>>,
    pub m_Resolution: Option<i32>,
    pub m_Scale: Option<Vector3>,
    pub m_SurfaceMask: Option<Vec<u8>>,
    pub m_SurfaceMaskLOD: Option<Vec<u8>>,
    pub m_Thickness: Option<f32>,
    pub m_Width: Option<i32>,
}

impl_object!(Heightmap);

impl Clone for Heightmap {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DefaultPhysicMaterial: self.m_DefaultPhysicMaterial.clone(),
            m_EnableHolesTextureCompression: self.m_EnableHolesTextureCompression.clone(),
            m_EnableSurfaceMaskTextureCompression: self
                .m_EnableSurfaceMaskTextureCompression
                .clone(),
            m_Height: self.m_Height.clone(),
            m_Heights: self.m_Heights.clone(),
            m_Holes: self.m_Holes.clone(),
            m_HolesLOD: self.m_HolesLOD.clone(),
            m_Levels: self.m_Levels.clone(),
            m_MinMaxPatchHeights: self.m_MinMaxPatchHeights.clone(),
            m_PrecomputedError: self.m_PrecomputedError.clone(),
            m_Resolution: self.m_Resolution.clone(),
            m_Scale: self.m_Scale.clone(),
            m_SurfaceMask: self.m_SurfaceMask.clone(),
            m_SurfaceMaskLOD: self.m_SurfaceMaskLOD.clone(),
            m_Thickness: self.m_Thickness.clone(),
            m_Width: self.m_Width.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HeightmapData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub isRotated: Option<bool>,
    pub position: Option<Vector3>,
    pub surfaceToTerrain: Option<Matrix4x4>,
    pub terrainData: Option<PPtrData<Object>>,
}

impl_object!(HeightmapData);

impl Clone for HeightmapData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            isRotated: self.isRotated.clone(),
            position: self.position.clone(),
            surfaceToTerrain: self.surfaceToTerrain.clone(),
            terrainData: self.terrainData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HierarchicalSceneData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_SceneGUID: Option<GUID>,
}

impl_object!(HierarchicalSceneData);

impl Clone for HierarchicalSceneData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_SceneGUID: self.m_SceneGUID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HoloLens {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub depthBufferSharingEnabled: Option<bool>,
    pub depthFormat: Option<i32>,
}

impl_object!(HoloLens);

impl Clone for HoloLens {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            depthBufferSharingEnabled: self.depthBufferSharingEnabled.clone(),
            depthFormat: self.depthFormat.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Human {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ArmStretch: Option<f32>,
    pub m_ArmTwist: Option<f32>,
    pub m_ColliderArray: Option<Vec<Collider>>,
    pub m_ColliderIndex: Option<Vec<i32>>,
    pub m_FeetSpacing: Option<f32>,
    pub m_ForeArmTwist: Option<f32>,
    pub m_Handles: Option<Vec<Handle>>,
    pub m_HasLeftHand: Option<bool>,
    pub m_HasRightHand: Option<bool>,
    pub m_HasTDoF: Option<bool>,
    pub m_HumanBoneIndex: Option<Vec<i32>>,
    pub m_HumanBoneMass: Option<Vec<f32>>,
    pub m_LeftHand: Option<Box<Box<OffsetPtr>>>,
    pub m_LegStretch: Option<f32>,
    pub m_LegTwist: Option<f32>,
    pub m_RightHand: Option<Box<Box<OffsetPtr>>>,
    pub m_RootX: Option<xform>,
    pub m_Scale: Option<f32>,
    pub m_Skeleton: Option<Box<Box<OffsetPtr>>>,
    pub m_SkeletonPose: Option<Box<Box<OffsetPtr>>>,
    pub m_UpperLegTwist: Option<f32>,
}

impl_object!(Human);

impl Clone for Human {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ArmStretch: self.m_ArmStretch.clone(),
            m_ArmTwist: self.m_ArmTwist.clone(),
            m_ColliderArray: self.m_ColliderArray.clone(),
            m_ColliderIndex: self.m_ColliderIndex.clone(),
            m_FeetSpacing: self.m_FeetSpacing.clone(),
            m_ForeArmTwist: self.m_ForeArmTwist.clone(),
            m_Handles: self.m_Handles.clone(),
            m_HasLeftHand: self.m_HasLeftHand.clone(),
            m_HasRightHand: self.m_HasRightHand.clone(),
            m_HasTDoF: self.m_HasTDoF.clone(),
            m_HumanBoneIndex: self.m_HumanBoneIndex.clone(),
            m_HumanBoneMass: self.m_HumanBoneMass.clone(),
            m_LeftHand: self.m_LeftHand.clone(),
            m_LegStretch: self.m_LegStretch.clone(),
            m_LegTwist: self.m_LegTwist.clone(),
            m_RightHand: self.m_RightHand.clone(),
            m_RootX: self.m_RootX.clone(),
            m_Scale: self.m_Scale.clone(),
            m_Skeleton: self.m_Skeleton.clone(),
            m_SkeletonPose: self.m_SkeletonPose.clone(),
            m_UpperLegTwist: self.m_UpperLegTwist.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HumanBone {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BoneName: Option<String>,
    pub m_HumanName: Option<String>,
    pub m_Limit: Option<SkeletonBoneLimit>,
}

impl_object!(HumanBone);

impl Clone for HumanBone {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BoneName: self.m_BoneName.clone(),
            m_HumanName: self.m_HumanName.clone(),
            m_Limit: self.m_Limit.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HumanDescription {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ArmStretch: Option<f32>,
    pub m_ArmTwist: Option<f32>,
    pub m_FeetSpacing: Option<f32>,
    pub m_ForeArmTwist: Option<f32>,
    pub m_GlobalScale: Option<f32>,
    pub m_Handles: Option<Vec<HumanHandle>>,
    pub m_HasExtraRoot: Option<bool>,
    pub m_HasTranslationDoF: Option<bool>,
    pub m_Human: Option<Vec<HumanBone>>,
    pub m_LegStretch: Option<f32>,
    pub m_LegTwist: Option<f32>,
    pub m_RootMotionBoneName: Option<String>,
    pub m_RootMotionBoneRotation: Option<Quaternion>,
    pub m_Skeleton: Option<Vec<SkeletonBone>>,
    pub m_SkeletonHasParents: Option<bool>,
    pub m_UpperLegTwist: Option<f32>,
}

impl_object!(HumanDescription);

impl Clone for HumanDescription {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ArmStretch: self.m_ArmStretch.clone(),
            m_ArmTwist: self.m_ArmTwist.clone(),
            m_FeetSpacing: self.m_FeetSpacing.clone(),
            m_ForeArmTwist: self.m_ForeArmTwist.clone(),
            m_GlobalScale: self.m_GlobalScale.clone(),
            m_Handles: self.m_Handles.clone(),
            m_HasExtraRoot: self.m_HasExtraRoot.clone(),
            m_HasTranslationDoF: self.m_HasTranslationDoF.clone(),
            m_Human: self.m_Human.clone(),
            m_LegStretch: self.m_LegStretch.clone(),
            m_LegTwist: self.m_LegTwist.clone(),
            m_RootMotionBoneName: self.m_RootMotionBoneName.clone(),
            m_RootMotionBoneRotation: self.m_RootMotionBoneRotation.clone(),
            m_Skeleton: self.m_Skeleton.clone(),
            m_SkeletonHasParents: self.m_SkeletonHasParents.clone(),
            m_UpperLegTwist: self.m_UpperLegTwist.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HumanGoal {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_HintT: Option<Vector3>,
    pub m_HintWeightT: Option<f32>,
    pub m_WeightR: Option<f32>,
    pub m_WeightT: Option<f32>,
    pub m_X: Option<xform>,
}

impl_object!(HumanGoal);

impl Clone for HumanGoal {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_HintT: self.m_HintT.clone(),
            m_HintWeightT: self.m_HintWeightT.clone(),
            m_WeightR: self.m_WeightR.clone(),
            m_WeightT: self.m_WeightT.clone(),
            m_X: self.m_X.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HumanHandle {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BoneName: Option<String>,
    pub m_LookAt: Option<bool>,
    pub m_Name: Option<String>,
    pub m_Position: Option<Vector3>,
    pub m_Rotation: Option<Quaternion>,
    pub m_Scale: Option<Vector3>,
}

impl_object!(HumanHandle);

impl Clone for HumanHandle {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BoneName: self.m_BoneName.clone(),
            m_LookAt: self.m_LookAt.clone(),
            m_Name: self.m_Name.clone(),
            m_Position: self.m_Position.clone(),
            m_Rotation: self.m_Rotation.clone(),
            m_Scale: self.m_Scale.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HumanLayerConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Binding: Option<u32>,
    pub m_BodyMask: Option<HumanPoseMask>,
    pub m_DefaultWeight: Option<f32>,
    pub m_IKPass: Option<bool>,
    pub m_LayerBlendingMode: Option<i32>,
    pub m_SkeletonMask: Option<Box<Box<OffsetPtr>>>,
    pub m_StateMachineIndex: Option<u32>,
    pub m_StateMachineMotionSetIndex: Option<u32>,
    pub m_SyncedLayerAffectsTiming: Option<bool>,
}

impl_object!(HumanLayerConstant);

impl Clone for HumanLayerConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Binding: self.m_Binding.clone(),
            m_BodyMask: self.m_BodyMask.clone(),
            m_DefaultWeight: self.m_DefaultWeight.clone(),
            m_IKPass: self.m_IKPass.clone(),
            m_LayerBlendingMode: self.m_LayerBlendingMode.clone(),
            m_SkeletonMask: self.m_SkeletonMask.clone(),
            m_StateMachineIndex: self.m_StateMachineIndex.clone(),
            m_StateMachineMotionSetIndex: self.m_StateMachineMotionSetIndex.clone(),
            m_SyncedLayerAffectsTiming: self.m_SyncedLayerAffectsTiming.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HumanPose {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DoFArray: Option<Vec<f32>>,
    pub m_GoalArray: Option<Vec<HumanGoal>>,
    pub m_LeftHandPose: Option<HandPose>,
    pub m_LookAtPosition: Option<Vector3>,
    pub m_LookAtWeight: Option<Vector4>,
    pub m_RightHandPose: Option<HandPose>,
    pub m_RootX: Option<xform>,
    pub m_TDoFArray: Option<Vec<Vector3>>,
}

impl_object!(HumanPose);

impl Clone for HumanPose {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DoFArray: self.m_DoFArray.clone(),
            m_GoalArray: self.m_GoalArray.clone(),
            m_LeftHandPose: self.m_LeftHandPose.clone(),
            m_LookAtPosition: self.m_LookAtPosition.clone(),
            m_LookAtWeight: self.m_LookAtWeight.clone(),
            m_RightHandPose: self.m_RightHandPose.clone(),
            m_RootX: self.m_RootX.clone(),
            m_TDoFArray: self.m_TDoFArray.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct HumanPoseMask {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub word0: Option<u32>,
    pub word1: Option<u32>,
    pub word2: Option<u32>,
}

impl_object!(HumanPoseMask);

impl Clone for HumanPoseMask {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            word0: self.word0.clone(),
            word1: self.word1.clone(),
            word2: self.word2.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Image {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub image_data: Option<Vec<u8>>,
    pub m_Format: Option<i32>,
    pub m_Height: Option<i32>,
    pub m_RowBytes: Option<i32>,
    pub m_Width: Option<i32>,
}

impl_object!(Image);

impl Clone for Image {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            image_data: self.image_data.clone(),
            m_Format: self.m_Format.clone(),
            m_Height: self.m_Height.clone(),
            m_RowBytes: self.m_RowBytes.clone(),
            m_Width: self.m_Width.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ImportLog_ImportLogEntry {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub file: Option<String>,
    pub line: Option<i32>,
    pub message: Option<String>,
    pub mode: Option<i32>,
    pub object: Option<PPtrData<Object>>,
}

impl_object!(ImportLog_ImportLogEntry);

impl Clone for ImportLog_ImportLogEntry {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            file: self.file.clone(),
            line: self.line.clone(),
            message: self.message.clone(),
            mode: self.mode.clone(),
            object: self.object.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct InheritVelocityModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub enabled: Option<bool>,
    pub m_Curve: Option<MinMaxCurve>,
    pub m_Mode: Option<i32>,
}

impl_object!(InheritVelocityModule);

impl Clone for InheritVelocityModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            enabled: self.enabled.clone(),
            m_Curve: self.m_Curve.clone(),
            m_Mode: self.m_Mode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct InitialModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub customEmitterVelocity: Option<Vector3>,
    pub enabled: Option<bool>,
    pub gravityModifier: Option<MinMaxCurve>,
    pub gravitySource: Option<i32>,
    pub inheritVelocity: Option<f32>,
    pub maxNumParticles: Option<i32>,
    pub randomizeRotationDirection: Option<f32>,
    pub rotation3D: Option<bool>,
    pub size3D: Option<bool>,
    pub startColor: Option<MinMaxGradient>,
    pub startLifetime: Option<MinMaxCurve>,
    pub startRotation: Option<MinMaxCurve>,
    pub startRotationX: Option<MinMaxCurve>,
    pub startRotationY: Option<MinMaxCurve>,
    pub startSize: Option<MinMaxCurve>,
    pub startSizeY: Option<MinMaxCurve>,
    pub startSizeZ: Option<MinMaxCurve>,
    pub startSpeed: Option<MinMaxCurve>,
}

impl_object!(InitialModule);

impl Clone for InitialModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            customEmitterVelocity: self.customEmitterVelocity.clone(),
            enabled: self.enabled.clone(),
            gravityModifier: self.gravityModifier.clone(),
            gravitySource: self.gravitySource.clone(),
            inheritVelocity: self.inheritVelocity.clone(),
            maxNumParticles: self.maxNumParticles.clone(),
            randomizeRotationDirection: self.randomizeRotationDirection.clone(),
            rotation3D: self.rotation3D.clone(),
            size3D: self.size3D.clone(),
            startColor: self.startColor.clone(),
            startLifetime: self.startLifetime.clone(),
            startRotation: self.startRotation.clone(),
            startRotationX: self.startRotationX.clone(),
            startRotationY: self.startRotationY.clone(),
            startSize: self.startSize.clone(),
            startSizeY: self.startSizeY.clone(),
            startSizeZ: self.startSizeZ.clone(),
            startSpeed: self.startSpeed.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct InputAxis {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub altNegativeButton: Option<String>,
    pub altPositiveButton: Option<String>,
    pub axis: Option<i32>,
    pub dead: Option<f32>,
    pub descriptiveName: Option<String>,
    pub descriptiveNegativeName: Option<String>,
    pub gravity: Option<f32>,
    pub invert: Option<bool>,
    pub joyNum: Option<i32>,
    pub m_Name: Option<String>,
    pub negativeButton: Option<String>,
    pub positiveButton: Option<String>,
    pub sensitivity: Option<f32>,
    pub snap: Option<bool>,
    pub typ: Option<i32>,
}

impl_object!(InputAxis);

impl Clone for InputAxis {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            altNegativeButton: self.altNegativeButton.clone(),
            altPositiveButton: self.altPositiveButton.clone(),
            axis: self.axis.clone(),
            dead: self.dead.clone(),
            descriptiveName: self.descriptiveName.clone(),
            descriptiveNegativeName: self.descriptiveNegativeName.clone(),
            gravity: self.gravity.clone(),
            invert: self.invert.clone(),
            joyNum: self.joyNum.clone(),
            m_Name: self.m_Name.clone(),
            negativeButton: self.negativeButton.clone(),
            positiveButton: self.positiveButton.clone(),
            sensitivity: self.sensitivity.clone(),
            snap: self.snap.clone(),
            typ: self.typ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct InputImportSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub alphaSource: Option<i32>,
    pub aniso: Option<i32>,
    pub filterMode: Option<i32>,
    pub name: Option<String>,
    pub value: Option<SubstanceValue>,
    pub wrapMode: Option<i32>,
}

impl_object!(InputImportSettings);

impl Clone for InputImportSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            alphaSource: self.alphaSource.clone(),
            aniso: self.aniso.clone(),
            filterMode: self.filterMode.clone(),
            name: self.name.clone(),
            value: self.value.clone(),
            wrapMode: self.wrapMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct IntPoint {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub X: Option<i64>,
    pub Y: Option<i64>,
}

impl_object!(IntPoint);

impl Clone for IntPoint {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            X: self.X.clone(),
            Y: self.Y.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Item {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub changeFlags: Option<i32>,
    pub changeset: Option<i32>,
    pub digest: Option<Hash128>,
    pub downloadResolution: Option<i32>,
    pub guid: Option<GUID>,
    pub markedForRemoval: Option<bool>,
    pub name: Option<String>,
    pub nameConflictResolution: Option<i32>,
    pub oldVersion: Option<i32>,
    pub origin: Option<i32>,
    pub parent: Option<GUID>,
    pub parentFolderID: Option<i32>,
    pub typ: Option<i32>,
}

impl_object!(Item);

impl Clone for Item {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            changeFlags: self.changeFlags.clone(),
            changeset: self.changeset.clone(),
            digest: self.digest.clone(),
            downloadResolution: self.downloadResolution.clone(),
            guid: self.guid.clone(),
            markedForRemoval: self.markedForRemoval.clone(),
            name: self.name.clone(),
            nameConflictResolution: self.nameConflictResolution.clone(),
            oldVersion: self.oldVersion.clone(),
            origin: self.origin.clone(),
            parent: self.parent.clone(),
            parentFolderID: self.parentFolderID.clone(),
            typ: self.typ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct JointAngleLimit2D {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_LowerAngle: Option<f32>,
    pub m_UpperAngle: Option<f32>,
}

impl_object!(JointAngleLimit2D);

impl Clone for JointAngleLimit2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_LowerAngle: self.m_LowerAngle.clone(),
            m_UpperAngle: self.m_UpperAngle.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct JointAngleLimits2D {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_LowerAngle: Option<f32>,
    pub m_UpperAngle: Option<f32>,
}

impl_object!(JointAngleLimits2D);

impl Clone for JointAngleLimits2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_LowerAngle: self.m_LowerAngle.clone(),
            m_UpperAngle: self.m_UpperAngle.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct JointDrive {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub maximumForce: Option<f32>,
    pub mode: Option<i32>,
    pub positionDamper: Option<f32>,
    pub positionSpring: Option<f32>,
    pub useAcceleration: Option<i32>,
}

impl_object!(JointDrive);

impl Clone for JointDrive {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            maximumForce: self.maximumForce.clone(),
            mode: self.mode.clone(),
            positionDamper: self.positionDamper.clone(),
            positionSpring: self.positionSpring.clone(),
            useAcceleration: self.useAcceleration.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct JointLimits {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bounceMinVelocity: Option<f32>,
    pub bounciness: Option<f32>,
    pub contactDistance: Option<f32>,
    pub max: Option<f32>,
    pub maxBounce: Option<f32>,
    pub min: Option<f32>,
    pub minBounce: Option<f32>,
}

impl_object!(JointLimits);

impl Clone for JointLimits {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bounceMinVelocity: self.bounceMinVelocity.clone(),
            bounciness: self.bounciness.clone(),
            contactDistance: self.contactDistance.clone(),
            max: self.max.clone(),
            maxBounce: self.maxBounce.clone(),
            min: self.min.clone(),
            minBounce: self.minBounce.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct JointMotor {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub force: Option<f32>,
    pub freeSpin: Option<i32>,
    pub targetVelocity: Option<f32>,
}

impl_object!(JointMotor);

impl Clone for JointMotor {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            force: self.force.clone(),
            freeSpin: self.freeSpin.clone(),
            targetVelocity: self.targetVelocity.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct JointMotor2D {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_MaximumMotorForce: Option<f32>,
    pub m_MotorSpeed: Option<f32>,
}

impl_object!(JointMotor2D);

impl Clone for JointMotor2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_MaximumMotorForce: self.m_MaximumMotorForce.clone(),
            m_MotorSpeed: self.m_MotorSpeed.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct JointSpring {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub damper: Option<f32>,
    pub spring: Option<f32>,
    pub targetPosition: Option<f32>,
}

impl_object!(JointSpring);

impl Clone for JointSpring {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            damper: self.damper.clone(),
            spring: self.spring.clone(),
            targetPosition: self.targetPosition.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct JointSuspension2D {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Angle: Option<f32>,
    pub m_DampingRatio: Option<f32>,
    pub m_Frequency: Option<f32>,
}

impl_object!(JointSuspension2D);

impl Clone for JointSuspension2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Angle: self.m_Angle.clone(),
            m_DampingRatio: self.m_DampingRatio.clone(),
            m_Frequency: self.m_Frequency.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct JointTranslationLimits2D {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_LowerTranslation: Option<f32>,
    pub m_UpperTranslation: Option<f32>,
}

impl_object!(JointTranslationLimits2D);

impl Clone for JointTranslationLimits2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_LowerTranslation: self.m_LowerTranslation.clone(),
            m_UpperTranslation: self.m_UpperTranslation.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Keyframe {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub inSlope: Option<Quaternion>,
    pub inWeight: Option<Quaternion>,
    pub outSlope: Option<Quaternion>,
    pub outWeight: Option<Quaternion>,
    pub time: Option<f32>,
    pub value: Option<Quaternion>,
    pub weightedMode: Option<i32>,
}

impl_object!(Keyframe);

impl Clone for Keyframe {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            inSlope: self.inSlope.clone(),
            inWeight: self.inWeight.clone(),
            outSlope: self.outSlope.clone(),
            outWeight: self.outWeight.clone(),
            time: self.time.clone(),
            value: self.value.clone(),
            weightedMode: self.weightedMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LOD {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub fadeMode: Option<i32>,
    pub fadeTransitionWidth: Option<f32>,
    pub renderers: Option<Vec<LODRenderer>>,
    pub screenRelativeHeight: Option<f32>,
}

impl_object!(LOD);

impl Clone for LOD {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            fadeMode: self.fadeMode.clone(),
            fadeTransitionWidth: self.fadeTransitionWidth.clone(),
            renderers: self.renderers.clone(),
            screenRelativeHeight: self.screenRelativeHeight.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LODRenderer {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub renderer: Option<PPtrData<Renderer>>,
}

impl_object!(LODRenderer);

impl Clone for LODRenderer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            renderer: self.renderer.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LayerConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Binding: Option<u32>,
    pub m_BodyMask: Option<HumanPoseMask>,
    pub m_DefaultWeight: Option<f32>,
    pub m_IKPass: Option<bool>,
    pub m_LayerBlendingMode: Option<i32>,
    pub m_SkeletonMask: Option<Box<Box<OffsetPtr>>>,
    pub m_StateMachineIndex: Option<u32>,
    pub m_StateMachineMotionSetIndex: Option<u32>,
    pub m_StateMachineSynchronizedLayerIndex: Option<u32>,
    pub m_SyncedLayerAffectsTiming: Option<bool>,
}

impl_object!(LayerConstant);

impl Clone for LayerConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Binding: self.m_Binding.clone(),
            m_BodyMask: self.m_BodyMask.clone(),
            m_DefaultWeight: self.m_DefaultWeight.clone(),
            m_IKPass: self.m_IKPass.clone(),
            m_LayerBlendingMode: self.m_LayerBlendingMode.clone(),
            m_SkeletonMask: self.m_SkeletonMask.clone(),
            m_StateMachineIndex: self.m_StateMachineIndex.clone(),
            m_StateMachineMotionSetIndex: self.m_StateMachineMotionSetIndex.clone(),
            m_StateMachineSynchronizedLayerIndex: self.m_StateMachineSynchronizedLayerIndex.clone(),
            m_SyncedLayerAffectsTiming: self.m_SyncedLayerAffectsTiming.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LayoutDataOne {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_FloatArray: Option<Vec<f32>>,
}

impl_object!(LayoutDataOne);

impl Clone for LayoutDataOne {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_FloatArray: self.m_FloatArray.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LayoutDataThree {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AnotherFloatArray: Option<Vec<f32>>,
}

impl_object!(LayoutDataThree);

impl Clone for LayoutDataThree {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AnotherFloatArray: self.m_AnotherFloatArray.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LayoutDataTwo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_FloatValue: Option<f32>,
    pub m_IntegerValue: Option<i32>,
}

impl_object!(LayoutDataTwo);

impl Clone for LayoutDataTwo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_FloatValue: self.m_FloatValue.clone(),
            m_IntegerValue: self.m_IntegerValue.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LeafInfoConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_IDArray: Option<Vec<u32>>,
    pub m_IndexOffset: Option<u32>,
}

impl_object!(LeafInfoConstant);

impl Clone for LeafInfoConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_IDArray: self.m_IDArray.clone(),
            m_IndexOffset: self.m_IndexOffset.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LibraryRepresentation {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub flags: Option<u16>,
    pub guid: Option<GUID>,
    pub localIdentifier: Option<i64>,
    pub name: Option<String>,
    pub object: Option<PPtrData<EditorExtension>>,
    pub path: Option<String>,
    pub scriptClassName: Option<String>,
    pub thumbnail: Option<Image>,
    pub thumbnailClassID: Option<i16>,
}

impl_object!(LibraryRepresentation);

impl Clone for LibraryRepresentation {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            flags: self.flags.clone(),
            guid: self.guid.clone(),
            localIdentifier: self.localIdentifier.clone(),
            name: self.name.clone(),
            object: self.object.clone(),
            path: self.path.clone(),
            scriptClassName: self.scriptClassName.clone(),
            thumbnail: self.thumbnail.clone(),
            thumbnailClassID: self.thumbnailClassID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LifetimeByEmitterSpeedModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub enabled: Option<bool>,
    pub m_Curve: Option<MinMaxCurve>,
    pub m_Range: Option<Vector2>,
}

impl_object!(LifetimeByEmitterSpeedModule);

impl Clone for LifetimeByEmitterSpeedModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            enabled: self.enabled.clone(),
            m_Curve: self.m_Curve.clone(),
            m_Range: self.m_Range.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LightBakingOutput {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub isBaked: Option<bool>,
    pub lightmapBakeMode: Option<LightmapBakeMode>,
    pub lightmappingMask: Option<i32>,
    pub occlusionMaskChannel: Option<i32>,
    pub probeOcclusionLightIndex: Option<i32>,
    pub shadowMaskChannel: Option<i32>,
}

impl_object!(LightBakingOutput);

impl Clone for LightBakingOutput {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            isBaked: self.isBaked.clone(),
            lightmapBakeMode: self.lightmapBakeMode.clone(),
            lightmappingMask: self.lightmappingMask.clone(),
            occlusionMaskChannel: self.occlusionMaskChannel.clone(),
            probeOcclusionLightIndex: self.probeOcclusionLightIndex.clone(),
            shadowMaskChannel: self.shadowMaskChannel.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LightProbeData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_NonTetrahedralizedProbeSetIndexMap: Option<Vec<(Hash128, i32)>>,
    pub m_Positions: Option<Vec<Vector3>>,
    pub m_ProbeSets: Option<Vec<ProbeSetIndex>>,
    pub m_Tetrahedralization: Option<ProbeSetTetrahedralization>,
}

impl_object!(LightProbeData);

impl Clone for LightProbeData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_NonTetrahedralizedProbeSetIndexMap: self.m_NonTetrahedralizedProbeSetIndexMap.clone(),
            m_Positions: self.m_Positions.clone(),
            m_ProbeSets: self.m_ProbeSets.clone(),
            m_Tetrahedralization: self.m_Tetrahedralization.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LightProbeOcclusion {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BakedLightIndex: Option<Vec<i32>>,
    pub m_Occlusion: Option<Vec<f32>>,
    pub m_OcclusionMaskChannel: Option<Vec<i8>>,
    pub m_ProbeOcclusionLightIndex: Option<Vec<i32>>,
    pub m_ShadowMaskChannel: Option<Vec<i8>>,
}

impl_object!(LightProbeOcclusion);

impl Clone for LightProbeOcclusion {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BakedLightIndex: self.m_BakedLightIndex.clone(),
            m_Occlusion: self.m_Occlusion.clone(),
            m_OcclusionMaskChannel: self.m_OcclusionMaskChannel.clone(),
            m_ProbeOcclusionLightIndex: self.m_ProbeOcclusionLightIndex.clone(),
            m_ShadowMaskChannel: self.m_ShadowMaskChannel.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LightmapBakeMode {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub lightmapBakeType: Option<i32>,
    pub mixedLightingMode: Option<i32>,
}

impl_object!(LightmapBakeMode);

impl Clone for LightmapBakeMode {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            lightmapBakeType: self.lightmapBakeType.clone(),
            mixedLightingMode: self.mixedLightingMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LightmapData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DirLightmap: Option<PPtrData<Texture2D>>,
    pub m_IndirectLightmap: Option<PPtrData<Texture2D>>,
    pub m_Lightmap: Option<PPtrData<Texture2D>>,
    pub m_ShadowMask: Option<PPtrData<Texture2D>>,
    pub sh_0_: Option<f32>,
    pub sh_10_: Option<f32>,
    pub sh_11_: Option<f32>,
    pub sh_12_: Option<f32>,
    pub sh_13_: Option<f32>,
    pub sh_14_: Option<f32>,
    pub sh_15_: Option<f32>,
    pub sh_16_: Option<f32>,
    pub sh_17_: Option<f32>,
    pub sh_18_: Option<f32>,
    pub sh_19_: Option<f32>,
    pub sh_1_: Option<f32>,
    pub sh_20_: Option<f32>,
    pub sh_21_: Option<f32>,
    pub sh_22_: Option<f32>,
    pub sh_23_: Option<f32>,
    pub sh_24_: Option<f32>,
    pub sh_25_: Option<f32>,
    pub sh_26_: Option<f32>,
    pub sh_2_: Option<f32>,
    pub sh_3_: Option<f32>,
    pub sh_4_: Option<f32>,
    pub sh_5_: Option<f32>,
    pub sh_6_: Option<f32>,
    pub sh_7_: Option<f32>,
    pub sh_8_: Option<f32>,
    pub sh_9_: Option<f32>,
}

impl_object!(LightmapData);

impl Clone for LightmapData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DirLightmap: self.m_DirLightmap.clone(),
            m_IndirectLightmap: self.m_IndirectLightmap.clone(),
            m_Lightmap: self.m_Lightmap.clone(),
            m_ShadowMask: self.m_ShadowMask.clone(),
            sh_0_: self.sh_0_.clone(),
            sh_10_: self.sh_10_.clone(),
            sh_11_: self.sh_11_.clone(),
            sh_12_: self.sh_12_.clone(),
            sh_13_: self.sh_13_.clone(),
            sh_14_: self.sh_14_.clone(),
            sh_15_: self.sh_15_.clone(),
            sh_16_: self.sh_16_.clone(),
            sh_17_: self.sh_17_.clone(),
            sh_18_: self.sh_18_.clone(),
            sh_19_: self.sh_19_.clone(),
            sh_1_: self.sh_1_.clone(),
            sh_20_: self.sh_20_.clone(),
            sh_21_: self.sh_21_.clone(),
            sh_22_: self.sh_22_.clone(),
            sh_23_: self.sh_23_.clone(),
            sh_24_: self.sh_24_.clone(),
            sh_25_: self.sh_25_.clone(),
            sh_26_: self.sh_26_.clone(),
            sh_2_: self.sh_2_.clone(),
            sh_3_: self.sh_3_.clone(),
            sh_4_: self.sh_4_.clone(),
            sh_5_: self.sh_5_.clone(),
            sh_6_: self.sh_6_.clone(),
            sh_7_: self.sh_7_.clone(),
            sh_8_: self.sh_8_.clone(),
            sh_9_: self.sh_9_.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LightmapSnapshot {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BakedAmbientProbeInGamma: Option<SphericalHarmonicsL2>,
    pub m_BakedAmbientProbeInLinear: Option<SphericalHarmonicsL2>,
    pub m_BakedAmbientProbesInGamma: Option<Vec<SphericalHarmonicsL2>>,
    pub m_BakedAmbientProbesInLinear: Option<Vec<SphericalHarmonicsL2>>,
    pub m_BakedReflectionProbeCubemaps: Option<Vec<PPtrData<Texture>>>,
    pub m_BakedReflectionProbes: Option<Vec<SceneObjectIdentifier>>,
    pub m_BakedSkyboxProbeCubemaps: Option<Vec<PPtrData<Texture>>>,
    pub m_EnlightenData: Option<Vec<u8>>,
    pub m_EnlightenSceneMapping: Option<EnlightenSceneMapping>,
    pub m_EnlightenSceneMappingRendererIDs: Option<Vec<SceneObjectIdentifier>>,
    pub m_LightProbes: Option<PPtrData<LightProbes>>,
    pub m_LightmappedRendererData: Option<Vec<RendererData>>,
    pub m_LightmappedRendererDataIDs: Option<Vec<SceneObjectIdentifier>>,
    pub m_Lightmaps: Option<Vec<LightmapData>>,
    pub m_Lights: Option<Vec<SceneObjectIdentifier>>,
    pub m_Name: Option<String>,
    pub m_SceneGUID: Option<GUID>,
}

impl_object!(LightmapSnapshot);

impl Clone for LightmapSnapshot {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BakedAmbientProbeInGamma: self.m_BakedAmbientProbeInGamma.clone(),
            m_BakedAmbientProbeInLinear: self.m_BakedAmbientProbeInLinear.clone(),
            m_BakedAmbientProbesInGamma: self.m_BakedAmbientProbesInGamma.clone(),
            m_BakedAmbientProbesInLinear: self.m_BakedAmbientProbesInLinear.clone(),
            m_BakedReflectionProbeCubemaps: self.m_BakedReflectionProbeCubemaps.clone(),
            m_BakedReflectionProbes: self.m_BakedReflectionProbes.clone(),
            m_BakedSkyboxProbeCubemaps: self.m_BakedSkyboxProbeCubemaps.clone(),
            m_EnlightenData: self.m_EnlightenData.clone(),
            m_EnlightenSceneMapping: self.m_EnlightenSceneMapping.clone(),
            m_EnlightenSceneMappingRendererIDs: self.m_EnlightenSceneMappingRendererIDs.clone(),
            m_LightProbes: self.m_LightProbes.clone(),
            m_LightmappedRendererData: self.m_LightmappedRendererData.clone(),
            m_LightmappedRendererDataIDs: self.m_LightmappedRendererDataIDs.clone(),
            m_Lightmaps: self.m_Lightmaps.clone(),
            m_Lights: self.m_Lights.clone(),
            m_Name: self.m_Name.clone(),
            m_SceneGUID: self.m_SceneGUID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LightsModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub color: Option<bool>,
    pub enabled: Option<bool>,
    pub intensity: Option<bool>,
    pub intensityCurve: Option<MinMaxCurve>,
    pub light: Option<PPtrData<Light>>,
    pub maxLights: Option<i32>,
    pub randomDistribution: Option<bool>,
    pub range: Option<bool>,
    pub rangeCurve: Option<MinMaxCurve>,
    pub ratio: Option<f32>,
}

impl_object!(LightsModule);

impl Clone for LightsModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            color: self.color.clone(),
            enabled: self.enabled.clone(),
            intensity: self.intensity.clone(),
            intensityCurve: self.intensityCurve.clone(),
            light: self.light.clone(),
            maxLights: self.maxLights.clone(),
            randomDistribution: self.randomDistribution.clone(),
            range: self.range.clone(),
            rangeCurve: self.rangeCurve.clone(),
            ratio: self.ratio.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Limit {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Max: Option<Vector3>,
    pub m_Min: Option<Vector3>,
}

impl_object!(Limit);

impl Clone for Limit {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Max: self.m_Max.clone(),
            m_Min: self.m_Min.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct LineParameters {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub alignment: Option<i32>,
    pub colorGradient: Option<Gradient>,
    pub endWidth: Option<f32>,
    pub generateLightingData: Option<bool>,
    pub m_EndColor: Option<Color>,
    pub m_StartColor: Option<Color>,
    pub numCapVertices: Option<i32>,
    pub numCornerVertices: Option<i32>,
    pub shadowBias: Option<f32>,
    pub startWidth: Option<f32>,
    pub textureMode: Option<i32>,
    pub textureScale: Option<Vector2>,
    pub widthCurve: Option<AnimationCurve>,
    pub widthMultiplier: Option<f32>,
}

impl_object!(LineParameters);

impl Clone for LineParameters {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            alignment: self.alignment.clone(),
            colorGradient: self.colorGradient.clone(),
            endWidth: self.endWidth.clone(),
            generateLightingData: self.generateLightingData.clone(),
            m_EndColor: self.m_EndColor.clone(),
            m_StartColor: self.m_StartColor.clone(),
            numCapVertices: self.numCapVertices.clone(),
            numCornerVertices: self.numCornerVertices.clone(),
            shadowBias: self.shadowBias.clone(),
            startWidth: self.startWidth.clone(),
            textureMode: self.textureMode.clone(),
            textureScale: self.textureScale.clone(),
            widthCurve: self.widthCurve.clone(),
            widthMultiplier: self.widthMultiplier.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Lumin {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub depthFormat: Option<i32>,
    pub enableGLCache: Option<bool>,
    pub frameTiming: Option<i32>,
    pub glCacheMaxBlobSize: Option<u32>,
    pub glCacheMaxFileSize: Option<u32>,
}

impl_object!(Lumin);

impl Clone for Lumin {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            depthFormat: self.depthFormat.clone(),
            enableGLCache: self.enableGLCache.clone(),
            frameTiming: self.frameTiming.clone(),
            glCacheMaxBlobSize: self.glCacheMaxBlobSize.clone(),
            glCacheMaxFileSize: self.glCacheMaxFileSize.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MaterialImportOutput {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub baked: Option<i32>,
    pub currentSettings: Option<BuildTargetSettings>,
}

impl_object!(MaterialImportOutput);

impl Clone for MaterialImportOutput {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            baked: self.baked.clone(),
            currentSettings: self.currentSettings.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MaterialInstanceSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub buildTargetSettings: Option<Vec<BuildTargetSettings>>,
    pub inputs: Option<Vec<InputImportSettings>>,
    pub lightmapFlags: Option<u32>,
    pub materialInformation: Option<ProceduralMaterialInformation>,
    pub materialProperties: Option<UnityPropertySheet>,
    pub name: Option<String>,
    pub prototypeName: Option<String>,
    pub renderQueue: Option<i32>,
    pub shader: Option<PPtrData<Shader>>,
    pub shaderKeywords: Option<String>,
    pub shaderName: Option<String>,
    pub textureAssignments: Option<Vec<ProceduralTextureAssignment>>,
    pub textureParameters: Option<Vec<InputImportSettings>>,
}

impl_object!(MaterialInstanceSettings);

impl Clone for MaterialInstanceSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            buildTargetSettings: self.buildTargetSettings.clone(),
            inputs: self.inputs.clone(),
            lightmapFlags: self.lightmapFlags.clone(),
            materialInformation: self.materialInformation.clone(),
            materialProperties: self.materialProperties.clone(),
            name: self.name.clone(),
            prototypeName: self.prototypeName.clone(),
            renderQueue: self.renderQueue.clone(),
            shader: self.shader.clone(),
            shaderKeywords: self.shaderKeywords.clone(),
            shaderName: self.shaderName.clone(),
            textureAssignments: self.textureAssignments.clone(),
            textureParameters: self.textureParameters.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MatrixParameter {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ArraySize: Option<i32>,
    pub m_Index: Option<i32>,
    pub m_NameIndex: Option<i32>,
    pub m_RowCount: Option<i8>,
    pub m_Type: Option<i8>,
}

impl_object!(MatrixParameter);

impl Clone for MatrixParameter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ArraySize: self.m_ArraySize.clone(),
            m_Index: self.m_Index.clone(),
            m_NameIndex: self.m_NameIndex.clone(),
            m_RowCount: self.m_RowCount.clone(),
            m_Type: self.m_Type.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MdFour {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub md4_hash: Option<Vec<u8>>,
}

impl_object!(MdFour);

impl Clone for MdFour {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            md4_hash: self.md4_hash.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MeshBlendShape {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub aabbMaxDelta: Option<Vector3>,
    pub aabbMinDelta: Option<Vector3>,
    pub firstVertex: Option<u32>,
    pub hasNormals: Option<bool>,
    pub hasTangents: Option<bool>,
    pub name: Option<String>,
    pub vertexCount: Option<u32>,
}

impl_object!(MeshBlendShape);

impl Clone for MeshBlendShape {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            aabbMaxDelta: self.aabbMaxDelta.clone(),
            aabbMinDelta: self.aabbMinDelta.clone(),
            firstVertex: self.firstVertex.clone(),
            hasNormals: self.hasNormals.clone(),
            hasTangents: self.hasTangents.clone(),
            name: self.name.clone(),
            vertexCount: self.vertexCount.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MeshBlendShapeChannel {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub frameCount: Option<i32>,
    pub frameIndex: Option<i32>,
    pub name: Option<String>,
    pub nameHash: Option<u32>,
}

impl_object!(MeshBlendShapeChannel);

impl Clone for MeshBlendShapeChannel {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            frameCount: self.frameCount.clone(),
            frameIndex: self.frameIndex.clone(),
            name: self.name.clone(),
            nameHash: self.nameHash.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MeshBlendShapeVertex {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub index: Option<i32>,
    pub normal: Option<Vector3>,
    pub tangent: Option<Vector3>,
    pub vertex: Option<Vector3>,
}

impl_object!(MeshBlendShapeVertex);

impl Clone for MeshBlendShapeVertex {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            index: self.index.clone(),
            normal: self.normal.clone(),
            tangent: self.tangent.clone(),
            vertex: self.vertex.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MinMaxAABB {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Max: Option<Vector3>,
    pub m_Min: Option<Vector3>,
}

impl_object!(MinMaxAABB);

impl Clone for MinMaxAABB {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Max: self.m_Max.clone(),
            m_Min: self.m_Min.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MinMaxCurve {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub maxCurve: Option<AnimationCurve>,
    pub minCurve: Option<AnimationCurve>,
    pub minMaxState: Option<i16>,
    pub minScalar: Option<f32>,
    pub scalar: Option<f32>,
}

impl_object!(MinMaxCurve);

impl Clone for MinMaxCurve {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            maxCurve: self.maxCurve.clone(),
            minCurve: self.minCurve.clone(),
            minMaxState: self.minMaxState.clone(),
            minScalar: self.minScalar.clone(),
            scalar: self.scalar.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MinMaxGradient {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub maxColor: Option<Color>,
    pub maxGradient: Option<Gradient>,
    pub minColor: Option<Color>,
    pub minGradient: Option<Gradient>,
    pub minMaxState: Option<i16>,
}

impl_object!(MinMaxGradient);

impl Clone for MinMaxGradient {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            maxColor: self.maxColor.clone(),
            maxGradient: self.maxGradient.clone(),
            minColor: self.minColor.clone(),
            minGradient: self.minGradient.clone(),
            minMaxState: self.minMaxState.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MipmapLimitSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub limitBias: Option<i32>,
    pub limitBiasMode: Option<i32>,
}

impl_object!(MipmapLimitSettings);

impl Clone for MipmapLimitSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            limitBias: self.limitBias.clone(),
            limitBiasMode: self.limitBiasMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Module {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub controlledByBuiltinPackage: Option<bool>,
    pub dependencies: Option<Vec<String>>,
    pub name: Option<String>,
    pub strippable: Option<bool>,
}

impl_object!(Module);

impl Clone for Module {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            controlledByBuiltinPackage: self.controlledByBuiltinPackage.clone(),
            dependencies: self.dependencies.clone(),
            name: self.name.clone(),
            strippable: self.strippable.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MonoAssemblyImporter {
    // extends AssetImporter
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ExecutionOrder: Option<Vec<(String, i32)>>,
    pub m_FileIDToRecycleName: Option<Vec<(i32, String)>>,
    pub m_IconMap: Option<Vec<(String, PPtrData<Texture2D>)>>,
    pub m_Name: Option<String>,
    pub m_NewHashIdentity: Option<MdFour>,
    pub m_OldHashIdentity: Option<MdFour>,
    pub m_UserData: Option<String>,
}

impl_object!(MonoAssemblyImporter);

impl Clone for MonoAssemblyImporter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ExecutionOrder: self.m_ExecutionOrder.clone(),
            m_FileIDToRecycleName: self.m_FileIDToRecycleName.clone(),
            m_IconMap: self.m_IconMap.clone(),
            m_Name: self.m_Name.clone(),
            m_NewHashIdentity: self.m_NewHashIdentity.clone(),
            m_OldHashIdentity: self.m_OldHashIdentity.clone(),
            m_UserData: self.m_UserData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MonoObject {
    // extends
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(MonoObject);

impl Clone for MonoObject {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MotionNeighborList {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_NeighborArray: Option<Vec<u32>>,
}

impl_object!(MotionNeighborList);

impl Clone for MotionNeighborList {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_NeighborArray: self.m_NeighborArray.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct MultiModeParameter {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub mode: Option<i32>,
    pub speed: Option<MinMaxCurve>,
    pub spread: Option<f32>,
    pub value: Option<f32>,
}

impl_object!(MultiModeParameter);

impl Clone for MultiModeParameter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            mode: self.mode.clone(),
            speed: self.speed.clone(),
            spread: self.spread.clone(),
            value: self.value.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NameToObjectMap {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ObjectToName: Option<Vec<(PPtrData<Shader>, String)>>,
}

impl_object!(NameToObjectMap);

impl Clone for NameToObjectMap {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ObjectToName: self.m_ObjectToName.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NativeType {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub a: Option<i32>,
    pub b: Option<f32>,
    pub embedded: Option<EmbeddedNativeType>,
}

impl_object!(NativeType);

impl Clone for NativeType {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            a: self.a.clone(),
            b: self.b.clone(),
            embedded: self.embedded.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NavMesh {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Heightmaps: Option<Vec<HeightmapData>>,
    pub m_MeshData: Option<Vec<u8>>,
    pub m_Name: Option<String>,
}

impl_object!(NavMesh);

impl Clone for NavMesh {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Heightmaps: self.m_Heightmaps.clone(),
            m_MeshData: self.m_MeshData.clone(),
            m_Name: self.m_Name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NavMeshAreaData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub cost: Option<f32>,
    pub name: Option<String>,
}

impl_object!(NavMeshAreaData);

impl Clone for NavMeshAreaData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            cost: self.cost.clone(),
            name: self.name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NavMeshAreas {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub areas: Option<Vec<NavMeshAreaData>>,
}

impl_object!(NavMeshAreas);

impl Clone for NavMeshAreas {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            areas: self.areas.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NavMeshBuildDebugSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Flags: Option<u8>,
}

impl_object!(NavMeshBuildDebugSettings);

impl Clone for NavMeshBuildDebugSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Flags: self.m_Flags.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NavMeshBuildSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub accuratePlacement: Option<bool>,
    pub agentClimb: Option<f32>,
    pub agentHeight: Option<f32>,
    pub agentRadius: Option<f32>,
    pub agentSlope: Option<f32>,
    pub agentTypeID: Option<i32>,
    pub buildHeightMesh: Option<i32>,
    pub cellSize: Option<f32>,
    pub debug: Option<NavMeshBuildDebugSettings>,
    pub keepTiles: Option<i32>,
    pub ledgeDropHeight: Option<f32>,
    pub manualCellSize: Option<bool>,
    pub manualTileSize: Option<bool>,
    pub maxJobWorkers: Option<u32>,
    pub maxJumpAcrossDistance: Option<f32>,
    pub minRegionArea: Option<f32>,
    pub preserveTilesOutsideBounds: Option<i32>,
    pub tileSize: Option<i32>,
}

impl_object!(NavMeshBuildSettings);

impl Clone for NavMeshBuildSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            accuratePlacement: self.accuratePlacement.clone(),
            agentClimb: self.agentClimb.clone(),
            agentHeight: self.agentHeight.clone(),
            agentRadius: self.agentRadius.clone(),
            agentSlope: self.agentSlope.clone(),
            agentTypeID: self.agentTypeID.clone(),
            buildHeightMesh: self.buildHeightMesh.clone(),
            cellSize: self.cellSize.clone(),
            debug: self.debug.clone(),
            keepTiles: self.keepTiles.clone(),
            ledgeDropHeight: self.ledgeDropHeight.clone(),
            manualCellSize: self.manualCellSize.clone(),
            manualTileSize: self.manualTileSize.clone(),
            maxJobWorkers: self.maxJobWorkers.clone(),
            maxJumpAcrossDistance: self.maxJumpAcrossDistance.clone(),
            minRegionArea: self.minRegionArea.clone(),
            preserveTilesOutsideBounds: self.preserveTilesOutsideBounds.clone(),
            tileSize: self.tileSize.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NavMeshLayerData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub cost: Option<f32>,
    pub editType: Option<i32>,
    pub name: Option<String>,
}

impl_object!(NavMeshLayerData);

impl Clone for NavMeshLayerData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            cost: self.cost.clone(),
            editType: self.editType.clone(),
            name: self.name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NavMeshLayers {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub Built_in_Layer_0: Option<NavMeshLayerData>,
    pub Built_in_Layer_1: Option<NavMeshLayerData>,
    pub Built_in_Layer_2: Option<NavMeshLayerData>,
    pub User_Layer_0: Option<NavMeshLayerData>,
    pub User_Layer_1: Option<NavMeshLayerData>,
    pub User_Layer_10: Option<NavMeshLayerData>,
    pub User_Layer_11: Option<NavMeshLayerData>,
    pub User_Layer_12: Option<NavMeshLayerData>,
    pub User_Layer_13: Option<NavMeshLayerData>,
    pub User_Layer_14: Option<NavMeshLayerData>,
    pub User_Layer_15: Option<NavMeshLayerData>,
    pub User_Layer_16: Option<NavMeshLayerData>,
    pub User_Layer_17: Option<NavMeshLayerData>,
    pub User_Layer_18: Option<NavMeshLayerData>,
    pub User_Layer_19: Option<NavMeshLayerData>,
    pub User_Layer_2: Option<NavMeshLayerData>,
    pub User_Layer_20: Option<NavMeshLayerData>,
    pub User_Layer_21: Option<NavMeshLayerData>,
    pub User_Layer_22: Option<NavMeshLayerData>,
    pub User_Layer_23: Option<NavMeshLayerData>,
    pub User_Layer_24: Option<NavMeshLayerData>,
    pub User_Layer_25: Option<NavMeshLayerData>,
    pub User_Layer_26: Option<NavMeshLayerData>,
    pub User_Layer_27: Option<NavMeshLayerData>,
    pub User_Layer_28: Option<NavMeshLayerData>,
    pub User_Layer_3: Option<NavMeshLayerData>,
    pub User_Layer_4: Option<NavMeshLayerData>,
    pub User_Layer_5: Option<NavMeshLayerData>,
    pub User_Layer_6: Option<NavMeshLayerData>,
    pub User_Layer_7: Option<NavMeshLayerData>,
    pub User_Layer_8: Option<NavMeshLayerData>,
    pub User_Layer_9: Option<NavMeshLayerData>,
}

impl_object!(NavMeshLayers);

impl Clone for NavMeshLayers {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            Built_in_Layer_0: self.Built_in_Layer_0.clone(),
            Built_in_Layer_1: self.Built_in_Layer_1.clone(),
            Built_in_Layer_2: self.Built_in_Layer_2.clone(),
            User_Layer_0: self.User_Layer_0.clone(),
            User_Layer_1: self.User_Layer_1.clone(),
            User_Layer_10: self.User_Layer_10.clone(),
            User_Layer_11: self.User_Layer_11.clone(),
            User_Layer_12: self.User_Layer_12.clone(),
            User_Layer_13: self.User_Layer_13.clone(),
            User_Layer_14: self.User_Layer_14.clone(),
            User_Layer_15: self.User_Layer_15.clone(),
            User_Layer_16: self.User_Layer_16.clone(),
            User_Layer_17: self.User_Layer_17.clone(),
            User_Layer_18: self.User_Layer_18.clone(),
            User_Layer_19: self.User_Layer_19.clone(),
            User_Layer_2: self.User_Layer_2.clone(),
            User_Layer_20: self.User_Layer_20.clone(),
            User_Layer_21: self.User_Layer_21.clone(),
            User_Layer_22: self.User_Layer_22.clone(),
            User_Layer_23: self.User_Layer_23.clone(),
            User_Layer_24: self.User_Layer_24.clone(),
            User_Layer_25: self.User_Layer_25.clone(),
            User_Layer_26: self.User_Layer_26.clone(),
            User_Layer_27: self.User_Layer_27.clone(),
            User_Layer_28: self.User_Layer_28.clone(),
            User_Layer_3: self.User_Layer_3.clone(),
            User_Layer_4: self.User_Layer_4.clone(),
            User_Layer_5: self.User_Layer_5.clone(),
            User_Layer_6: self.User_Layer_6.clone(),
            User_Layer_7: self.User_Layer_7.clone(),
            User_Layer_8: self.User_Layer_8.clone(),
            User_Layer_9: self.User_Layer_9.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NavMeshParams {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub cellSize: Option<f32>,
    pub tileSize: Option<f32>,
    pub walkableClimb: Option<f32>,
    pub walkableHeight: Option<f32>,
    pub walkableRadius: Option<f32>,
}

impl_object!(NavMeshParams);

impl Clone for NavMeshParams {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            cellSize: self.cellSize.clone(),
            tileSize: self.tileSize.clone(),
            walkableClimb: self.walkableClimb.clone(),
            walkableHeight: self.walkableHeight.clone(),
            walkableRadius: self.walkableRadius.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NavMeshTileData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Hash: Option<Hash128>,
    pub m_MeshData: Option<Vec<u8>>,
}

impl_object!(NavMeshTileData);

impl Clone for NavMeshTileData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Hash: self.m_Hash.clone(),
            m_MeshData: self.m_MeshData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NetworkViewID {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ID: Option<u32>,
    pub m_Type: Option<u32>,
}

impl_object!(NetworkViewID);

impl Clone for NetworkViewID {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ID: self.m_ID.clone(),
            m_Type: self.m_Type.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Node {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AxesId: Option<i32>,
    pub m_ParentId: Option<i32>,
}

impl_object!(Node);

impl Clone for Node {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AxesId: self.m_AxesId.clone(),
            m_ParentId: self.m_ParentId.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NoiseModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub damping: Option<bool>,
    pub enabled: Option<bool>,
    pub frequency: Option<f32>,
    pub octaveMultiplier: Option<f32>,
    pub octaveScale: Option<f32>,
    pub octaves: Option<i32>,
    pub positionAmount: Option<MinMaxCurve>,
    pub quality: Option<i32>,
    pub remap: Option<MinMaxCurve>,
    pub remapEnabled: Option<bool>,
    pub remapY: Option<MinMaxCurve>,
    pub remapZ: Option<MinMaxCurve>,
    pub rotationAmount: Option<MinMaxCurve>,
    pub scrollSpeed: Option<MinMaxCurve>,
    pub separateAxes: Option<bool>,
    pub sizeAmount: Option<MinMaxCurve>,
    pub strength: Option<MinMaxCurve>,
    pub strengthY: Option<MinMaxCurve>,
    pub strengthZ: Option<MinMaxCurve>,
}

impl_object!(NoiseModule);

impl Clone for NoiseModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            damping: self.damping.clone(),
            enabled: self.enabled.clone(),
            frequency: self.frequency.clone(),
            octaveMultiplier: self.octaveMultiplier.clone(),
            octaveScale: self.octaveScale.clone(),
            octaves: self.octaves.clone(),
            positionAmount: self.positionAmount.clone(),
            quality: self.quality.clone(),
            remap: self.remap.clone(),
            remapEnabled: self.remapEnabled.clone(),
            remapY: self.remapY.clone(),
            remapZ: self.remapZ.clone(),
            rotationAmount: self.rotationAmount.clone(),
            scrollSpeed: self.scrollSpeed.clone(),
            separateAxes: self.separateAxes.clone(),
            sizeAmount: self.sizeAmount.clone(),
            strength: self.strength.clone(),
            strengthY: self.strengthY.clone(),
            strengthZ: self.strengthZ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct NonAlignedStruct {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Bool: Option<bool>,
}

impl_object!(NonAlignedStruct);

impl Clone for NonAlignedStruct {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Bool: self.m_Bool.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ObjectRolePair {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Object: Option<PPtrData<Object>>,
    pub m_RolesMask: Option<i32>,
}

impl_object!(ObjectRolePair);

impl Clone for ObjectRolePair {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Object: self.m_Object.clone(),
            m_RolesMask: self.m_RolesMask.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct OcclusionScene {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub indexPortals: Option<i32>,
    pub indexRenderers: Option<i32>,
    pub scene: Option<GUID>,
    pub sizePortals: Option<i32>,
    pub sizeRenderers: Option<i32>,
}

impl_object!(OcclusionScene);

impl Clone for OcclusionScene {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            indexPortals: self.indexPortals.clone(),
            indexRenderers: self.indexRenderers.clone(),
            scene: self.scene.clone(),
            sizePortals: self.sizePortals.clone(),
            sizeRenderers: self.sizeRenderers.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Oculus {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub dashSupport: Option<bool>,
    pub lowOverheadMode: Option<bool>,
    pub protectedContext: Option<bool>,
    pub sharedDepthBuffer: Option<bool>,
    pub v2Signing: Option<bool>,
}

impl_object!(Oculus);

impl Clone for Oculus {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            dashSupport: self.dashSupport.clone(),
            lowOverheadMode: self.lowOverheadMode.clone(),
            protectedContext: self.protectedContext.clone(),
            sharedDepthBuffer: self.sharedDepthBuffer.clone(),
            v2Signing: self.v2Signing.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct OffsetPtr {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub data: Option<Clip>,
}

impl_object!(OffsetPtr);

impl Clone for OffsetPtr {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            data: self.data.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Output {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub hasEmptyFontData: Option<bool>,
    pub importedType: Option<i32>,
    pub previewData: Option<Vec<f32>>,
}

impl_object!(Output);

impl Clone for Output {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            hasEmptyFontData: self.hasEmptyFontData.clone(),
            importedType: self.importedType.clone(),
            previewData: self.previewData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PPtrCurve {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub attribute: Option<String>,
    pub classID: Option<i32>,
    pub curve: Option<Vec<PPtrKeyframe>>,
    pub flags: Option<i32>,
    pub path: Option<String>,
    pub script: Option<PPtrData<MonoScript>>,
}

impl_object!(PPtrCurve);

impl Clone for PPtrCurve {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            attribute: self.attribute.clone(),
            classID: self.classID.clone(),
            curve: self.curve.clone(),
            flags: self.flags.clone(),
            path: self.path.clone(),
            script: self.script.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PPtrKeyframe {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub time: Option<f32>,
    pub value: Option<PPtrData<Object>>,
}

impl_object!(PPtrKeyframe);

impl Clone for PPtrKeyframe {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            time: self.time.clone(),
            value: self.value.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PackedBitVector {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BitSize: Option<u8>,
    pub m_Data: Option<Vec<u8>>,
    pub m_NumItems: Option<u32>,
    pub m_Range: Option<f32>,
    pub m_Start: Option<f32>,
}

impl_object!(PackedBitVector);

impl Clone for PackedBitVector {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BitSize: self.m_BitSize.clone(),
            m_Data: self.m_Data.clone(),
            m_NumItems: self.m_NumItems.clone(),
            m_Range: self.m_Range.clone(),
            m_Start: self.m_Start.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PackingSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub allowAlphaSplitting: Option<bool>,
    pub blockOffset: Option<i32>,
    pub enableAlphaDilation: Option<bool>,
    pub enableRotation: Option<bool>,
    pub enableTightPacking: Option<bool>,
    pub padding: Option<i32>,
}

impl_object!(PackingSettings);

impl Clone for PackingSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            allowAlphaSplitting: self.allowAlphaSplitting.clone(),
            blockOffset: self.blockOffset.clone(),
            enableAlphaDilation: self.enableAlphaDilation.clone(),
            enableRotation: self.enableRotation.clone(),
            enableTightPacking: self.enableTightPacking.clone(),
            padding: self.padding.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Parameter {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_GUID: Option<GUID>,
    pub m_ParameterName: Option<String>,
}

impl_object!(Parameter);

impl Clone for Parameter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_GUID: self.m_GUID.clone(),
            m_ParameterName: self.m_ParameterName.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ParserBindChannels {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Channels: Option<Vec<ShaderBindChannel>>,
    pub m_SourceMap: Option<i32>,
}

impl_object!(ParserBindChannels);

impl Clone for ParserBindChannels {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Channels: self.m_Channels.clone(),
            m_SourceMap: self.m_SourceMap.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ParticleSystemEmissionBurst {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub countCurve: Option<MinMaxCurve>,
    pub cycleCount: Option<i32>,
    pub maxCount: Option<u32>,
    pub minCount: Option<u32>,
    pub probability: Option<f32>,
    pub repeatInterval: Option<f32>,
    pub time: Option<f32>,
}

impl_object!(ParticleSystemEmissionBurst);

impl Clone for ParticleSystemEmissionBurst {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            countCurve: self.countCurve.clone(),
            cycleCount: self.cycleCount.clone(),
            maxCount: self.maxCount.clone(),
            minCount: self.minCount.clone(),
            probability: self.probability.clone(),
            repeatInterval: self.repeatInterval.clone(),
            time: self.time.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ParticleSystemForceFieldParameters {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DirectionCurveX: Option<MinMaxCurve>,
    pub m_DirectionCurveY: Option<MinMaxCurve>,
    pub m_DirectionCurveZ: Option<MinMaxCurve>,
    pub m_DragCurve: Option<MinMaxCurve>,
    pub m_EndRange: Option<f32>,
    pub m_GravityCurve: Option<MinMaxCurve>,
    pub m_GravityFocus: Option<f32>,
    pub m_Length: Option<f32>,
    pub m_MultiplyDragByParticleSize: Option<bool>,
    pub m_MultiplyDragByParticleVelocity: Option<bool>,
    pub m_RotationAttractionCurve: Option<MinMaxCurve>,
    pub m_RotationRandomness: Option<Vector2>,
    pub m_RotationSpeedCurve: Option<MinMaxCurve>,
    pub m_Shape: Option<i32>,
    pub m_StartRange: Option<f32>,
    pub m_VectorField: Option<PPtrData<Texture3D>>,
    pub m_VectorFieldAttractionCurve: Option<MinMaxCurve>,
    pub m_VectorFieldSpeedCurve: Option<MinMaxCurve>,
}

impl_object!(ParticleSystemForceFieldParameters);

impl Clone for ParticleSystemForceFieldParameters {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DirectionCurveX: self.m_DirectionCurveX.clone(),
            m_DirectionCurveY: self.m_DirectionCurveY.clone(),
            m_DirectionCurveZ: self.m_DirectionCurveZ.clone(),
            m_DragCurve: self.m_DragCurve.clone(),
            m_EndRange: self.m_EndRange.clone(),
            m_GravityCurve: self.m_GravityCurve.clone(),
            m_GravityFocus: self.m_GravityFocus.clone(),
            m_Length: self.m_Length.clone(),
            m_MultiplyDragByParticleSize: self.m_MultiplyDragByParticleSize.clone(),
            m_MultiplyDragByParticleVelocity: self.m_MultiplyDragByParticleVelocity.clone(),
            m_RotationAttractionCurve: self.m_RotationAttractionCurve.clone(),
            m_RotationRandomness: self.m_RotationRandomness.clone(),
            m_RotationSpeedCurve: self.m_RotationSpeedCurve.clone(),
            m_Shape: self.m_Shape.clone(),
            m_StartRange: self.m_StartRange.clone(),
            m_VectorField: self.m_VectorField.clone(),
            m_VectorFieldAttractionCurve: self.m_VectorFieldAttractionCurve.clone(),
            m_VectorFieldSpeedCurve: self.m_VectorFieldSpeedCurve.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PerLODSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub castShadows: Option<bool>,
    pub enableBump: Option<bool>,
    pub enableHue: Option<bool>,
    pub enableSettingOverride: Option<bool>,
    pub enableSubsurface: Option<bool>,
    pub height: Option<f32>,
    pub receiveShadows: Option<bool>,
    pub reflectionProbeUsage: Option<i32>,
    pub useLightProbes: Option<bool>,
    pub windQuality: Option<i32>,
}

impl_object!(PerLODSettings);

impl Clone for PerLODSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            castShadows: self.castShadows.clone(),
            enableBump: self.enableBump.clone(),
            enableHue: self.enableHue.clone(),
            enableSettingOverride: self.enableSettingOverride.clone(),
            enableSubsurface: self.enableSubsurface.clone(),
            height: self.height.clone(),
            receiveShadows: self.receiveShadows.clone(),
            reflectionProbeUsage: self.reflectionProbeUsage.clone(),
            useLightProbes: self.useLightProbes.clone(),
            windQuality: self.windQuality.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PerformanceReportingSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<bool>,
}

impl_object!(PerformanceReportingSettings);

impl Clone for PerformanceReportingSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PhysicMaterial {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bounceCombine: Option<i32>,
    pub bounciness: Option<f32>,
    pub dynamicFriction: Option<f32>,
    pub dynamicFriction2: Option<f32>,
    pub frictionCombine: Option<i32>,
    pub frictionDirection2: Option<Vector3>,
    pub m_Name: Option<String>,
    pub staticFriction: Option<f32>,
    pub staticFriction2: Option<f32>,
}

impl_object!(PhysicMaterial);

impl Clone for PhysicMaterial {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bounceCombine: self.bounceCombine.clone(),
            bounciness: self.bounciness.clone(),
            dynamicFriction: self.dynamicFriction.clone(),
            dynamicFriction2: self.dynamicFriction2.clone(),
            frictionCombine: self.frictionCombine.clone(),
            frictionDirection2: self.frictionDirection2.clone(),
            m_Name: self.m_Name.clone(),
            staticFriction: self.staticFriction.clone(),
            staticFriction2: self.staticFriction2.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PhysicsJobOptions2D {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ClearBodyForcesPerJob: Option<i32>,
    pub m_ClearFlagsPerJob: Option<i32>,
    pub m_CollideContactsPerJob: Option<i32>,
    pub m_FindNearestContactsPerJob: Option<i32>,
    pub m_InterpolationPosesPerJob: Option<i32>,
    pub m_IslandSolverBodiesPerJob: Option<i32>,
    pub m_IslandSolverBodyCostScale: Option<i32>,
    pub m_IslandSolverContactCostScale: Option<i32>,
    pub m_IslandSolverContactsPerJob: Option<i32>,
    pub m_IslandSolverCostThreshold: Option<i32>,
    pub m_IslandSolverJointCostScale: Option<i32>,
    pub m_NewContactsPerJob: Option<i32>,
    pub m_SyncContinuousFixturesPerJob: Option<i32>,
    pub m_SyncDiscreteFixturesPerJob: Option<i32>,
    pub m_UpdateTriggerContactsPerJob: Option<i32>,
    pub m_UseConsistencySorting: Option<bool>,
    pub m_UseMultithreading: Option<bool>,
    pub useConsistencySorting: Option<bool>,
    pub useMultithreading: Option<bool>,
}

impl_object!(PhysicsJobOptions2D);

impl Clone for PhysicsJobOptions2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ClearBodyForcesPerJob: self.m_ClearBodyForcesPerJob.clone(),
            m_ClearFlagsPerJob: self.m_ClearFlagsPerJob.clone(),
            m_CollideContactsPerJob: self.m_CollideContactsPerJob.clone(),
            m_FindNearestContactsPerJob: self.m_FindNearestContactsPerJob.clone(),
            m_InterpolationPosesPerJob: self.m_InterpolationPosesPerJob.clone(),
            m_IslandSolverBodiesPerJob: self.m_IslandSolverBodiesPerJob.clone(),
            m_IslandSolverBodyCostScale: self.m_IslandSolverBodyCostScale.clone(),
            m_IslandSolverContactCostScale: self.m_IslandSolverContactCostScale.clone(),
            m_IslandSolverContactsPerJob: self.m_IslandSolverContactsPerJob.clone(),
            m_IslandSolverCostThreshold: self.m_IslandSolverCostThreshold.clone(),
            m_IslandSolverJointCostScale: self.m_IslandSolverJointCostScale.clone(),
            m_NewContactsPerJob: self.m_NewContactsPerJob.clone(),
            m_SyncContinuousFixturesPerJob: self.m_SyncContinuousFixturesPerJob.clone(),
            m_SyncDiscreteFixturesPerJob: self.m_SyncDiscreteFixturesPerJob.clone(),
            m_UpdateTriggerContactsPerJob: self.m_UpdateTriggerContactsPerJob.clone(),
            m_UseConsistencySorting: self.m_UseConsistencySorting.clone(),
            m_UseMultithreading: self.m_UseMultithreading.clone(),
            useConsistencySorting: self.useConsistencySorting.clone(),
            useMultithreading: self.useMultithreading.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PhysicsShape {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AdjacentEnd: Option<Vector2>,
    pub m_AdjacentStart: Option<Vector2>,
    pub m_Radius: Option<f32>,
    pub m_ShapeType: Option<i32>,
    pub m_UseAdjacentEnd: Option<i32>,
    pub m_UseAdjacentStart: Option<i32>,
    pub m_VertexCount: Option<i32>,
    pub m_VertexStartIndex: Option<i32>,
}

impl_object!(PhysicsShape);

impl Clone for PhysicsShape {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AdjacentEnd: self.m_AdjacentEnd.clone(),
            m_AdjacentStart: self.m_AdjacentStart.clone(),
            m_Radius: self.m_Radius.clone(),
            m_ShapeType: self.m_ShapeType.clone(),
            m_UseAdjacentEnd: self.m_UseAdjacentEnd.clone(),
            m_UseAdjacentStart: self.m_UseAdjacentStart.clone(),
            m_VertexCount: self.m_VertexCount.clone(),
            m_VertexStartIndex: self.m_VertexStartIndex.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PhysicsShapeGroup2D {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Shapes: Option<Vec<PhysicsShape>>,
    pub m_Vertices: Option<Vec<Vector2>>,
}

impl_object!(PhysicsShapeGroup2D);

impl Clone for PhysicsShapeGroup2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Shapes: self.m_Shapes.clone(),
            m_Vertices: self.m_Vertices.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PlatformSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AllowsAlphaSplitting: Option<bool>,
    pub m_BuildTarget: Option<String>,
    pub m_CompressionQuality: Option<i32>,
    pub m_CrunchedCompression: Option<bool>,
    pub m_MaxTextureSize: Option<i32>,
    pub m_Overridden: Option<bool>,
    pub m_ResizeAlgorithm: Option<i32>,
    pub m_TextureCompression: Option<i32>,
    pub m_TextureFormat: Option<i32>,
}

impl_object!(PlatformSettings);

impl Clone for PlatformSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AllowsAlphaSplitting: self.m_AllowsAlphaSplitting.clone(),
            m_BuildTarget: self.m_BuildTarget.clone(),
            m_CompressionQuality: self.m_CompressionQuality.clone(),
            m_CrunchedCompression: self.m_CrunchedCompression.clone(),
            m_MaxTextureSize: self.m_MaxTextureSize.clone(),
            m_Overridden: self.m_Overridden.clone(),
            m_ResizeAlgorithm: self.m_ResizeAlgorithm.clone(),
            m_TextureCompression: self.m_TextureCompression.clone(),
            m_TextureFormat: self.m_TextureFormat.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PlatformSettingsData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub enabled: Option<bool>,
    pub settings: Option<Vec<(String, String)>>,
}

impl_object!(PlatformSettingsData);

impl Clone for PlatformSettingsData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            enabled: self.enabled.clone(),
            settings: self.settings.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PlatformShaderDefines {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub defines_Tier1: Option<Vec<u32>>,
    pub defines_Tier2: Option<Vec<u32>>,
    pub defines_Tier3: Option<Vec<u32>>,
    pub shaderPlatform: Option<i32>,
}

impl_object!(PlatformShaderDefines);

impl Clone for PlatformShaderDefines {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            defines_Tier1: self.defines_Tier1.clone(),
            defines_Tier2: self.defines_Tier2.clone(),
            defines_Tier3: self.defines_Tier3.clone(),
            shaderPlatform: self.shaderPlatform.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PlatformShaderSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub useCascadedShadowMaps: Option<bool>,
    pub useScreenSpaceShadows: Option<bool>,
}

impl_object!(PlatformShaderSettings);

impl Clone for PlatformShaderSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            useCascadedShadowMaps: self.useCascadedShadowMaps.clone(),
            useScreenSpaceShadows: self.useScreenSpaceShadows.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PluginImportOutput {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub dllType: Option<i32>,
    pub pluginType: Option<i32>,
    pub scriptingRuntimeVersion: Option<i32>,
}

impl_object!(PluginImportOutput);

impl Clone for PluginImportOutput {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            dllType: self.dllType.clone(),
            pluginType: self.pluginType.clone(),
            scriptingRuntimeVersion: self.scriptingRuntimeVersion.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Polygon2D {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Paths: Option<Vec<Vec<Vector2>>>,
}

impl_object!(Polygon2D);

impl Clone for Polygon2D {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Paths: self.m_Paths.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PrefabModification {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AddedComponents: Option<Vec<AddedComponent>>,
    pub m_AddedGameObjects: Option<Vec<AddedGameObject>>,
    pub m_Modifications: Option<Vec<PropertyModification>>,
    pub m_RemovedComponents: Option<Vec<PPtrData<Component>>>,
    pub m_RemovedGameObjects: Option<Vec<PPtrData<GameObject>>>,
    pub m_TransformParent: Option<PPtrData<Transform>>,
}

impl_object!(PrefabModification);

impl Clone for PrefabModification {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AddedComponents: self.m_AddedComponents.clone(),
            m_AddedGameObjects: self.m_AddedGameObjects.clone(),
            m_Modifications: self.m_Modifications.clone(),
            m_RemovedComponents: self.m_RemovedComponents.clone(),
            m_RemovedGameObjects: self.m_RemovedGameObjects.clone(),
            m_TransformParent: self.m_TransformParent.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PresetType {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ManagedTypeFallback: Option<String>,
    pub m_ManagedTypePPtr: Option<PPtrData<MonoScript>>,
    pub m_NativeTypeID: Option<i32>,
}

impl_object!(PresetType);

impl Clone for PresetType {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ManagedTypeFallback: self.m_ManagedTypeFallback.clone(),
            m_ManagedTypePPtr: self.m_ManagedTypePPtr.clone(),
            m_NativeTypeID: self.m_NativeTypeID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PreviewData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CompSize: Option<i32>,
    pub m_OrigSize: Option<i32>,
    pub m_PreviewData: Option<Vec<f32>>,
}

impl_object!(PreviewData);

impl Clone for PreviewData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CompSize: self.m_CompSize.clone(),
            m_OrigSize: self.m_OrigSize.clone(),
            m_PreviewData: self.m_PreviewData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ProbeSetIndex {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Hash: Option<Hash128>,
    pub m_Offset: Option<i32>,
    pub m_Size: Option<i32>,
}

impl_object!(ProbeSetIndex);

impl Clone for ProbeSetIndex {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Hash: self.m_Hash.clone(),
            m_Offset: self.m_Offset.clone(),
            m_Size: self.m_Size.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ProbeSetTetrahedralization {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_HullRays: Option<Vec<Vector3>>,
    pub m_Tetrahedra: Option<Vec<Tetrahedron>>,
}

impl_object!(ProbeSetTetrahedralization);

impl Clone for ProbeSetTetrahedralization {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_HullRays: self.m_HullRays.clone(),
            m_Tetrahedra: self.m_Tetrahedra.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ProceduralMaterialInformation {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AnimationUpdateRate: Option<i32>,
    pub m_GenerateAllOutputs: Option<i32>,
    pub m_GenerateMipmaps: Option<bool>,
    pub m_GeneratedAtLoading: Option<i32>,
    pub m_Offset: Option<Vector2>,
    pub m_Scale: Option<Vector2>,
}

impl_object!(ProceduralMaterialInformation);

impl Clone for ProceduralMaterialInformation {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AnimationUpdateRate: self.m_AnimationUpdateRate.clone(),
            m_GenerateAllOutputs: self.m_GenerateAllOutputs.clone(),
            m_GenerateMipmaps: self.m_GenerateMipmaps.clone(),
            m_GeneratedAtLoading: self.m_GeneratedAtLoading.clone(),
            m_Offset: self.m_Offset.clone(),
            m_Scale: self.m_Scale.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ProceduralTextureAssignment {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub baseUID: Option<u32>,
    pub material: Option<PPtrData<ProceduralMaterial>>,
    pub shaderProp: Option<FastPropertyName>,
}

impl_object!(ProceduralTextureAssignment);

impl Clone for ProceduralTextureAssignment {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            baseUID: self.baseUID.clone(),
            material: self.material.clone(),
            shaderProp: self.shaderProp.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PropertyModification {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub objectReference: Option<PPtrData<Object>>,
    pub propertyPath: Option<String>,
    pub target: Option<PPtrData<Object>>,
    pub value: Option<String>,
}

impl_object!(PropertyModification);

impl Clone for PropertyModification {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            objectReference: self.objectReference.clone(),
            propertyPath: self.propertyPath.clone(),
            target: self.target.clone(),
            value: self.value.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct PropertyModificationsTargetTestNativeObject {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_FloatValue: Option<f32>,
    pub m_IntegerValue: Option<i32>,
}

impl_object!(PropertyModificationsTargetTestNativeObject);

impl Clone for PropertyModificationsTargetTestNativeObject {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_FloatValue: self.m_FloatValue.clone(),
            m_IntegerValue: self.m_IntegerValue.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct QualitySetting {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub adaptiveVsync: Option<bool>,
    pub adaptiveVsyncExtraA: Option<i32>,
    pub adaptiveVsyncExtraB: Option<i32>,
    pub anisotropicTextures: Option<i32>,
    pub antiAliasing: Option<i32>,
    pub asyncUploadBufferSize: Option<i32>,
    pub asyncUploadPersistentBuffer: Option<bool>,
    pub asyncUploadTimeSlice: Option<i32>,
    pub billboardsFaceCameraPosition: Option<bool>,
    pub blendWeights: Option<i32>,
    pub customRenderPipeline: Option<PPtrData<MonoBehaviour>>,
    pub enableLODCrossFade: Option<bool>,
    pub globalTextureMipmapLimit: Option<i32>,
    pub lodBias: Option<f32>,
    pub maximumLODLevel: Option<i32>,
    pub name: Option<String>,
    pub particleRaycastBudget: Option<i32>,
    pub pixelLightCount: Option<i32>,
    pub realtimeGICPUUsage: Option<i32>,
    pub realtimeReflectionProbes: Option<bool>,
    pub resolutionScalingFixedDPIFactor: Option<f32>,
    pub shadowCascade2Split: Option<f32>,
    pub shadowCascade4Split: Option<Vector3>,
    pub shadowCascades: Option<i32>,
    pub shadowDistance: Option<f32>,
    pub shadowNearPlaneOffset: Option<f32>,
    pub shadowProjection: Option<i32>,
    pub shadowResolution: Option<i32>,
    pub shadowmaskMode: Option<i32>,
    pub shadows: Option<i32>,
    pub skinWeights: Option<i32>,
    pub softParticles: Option<bool>,
    pub softVegetation: Option<bool>,
    pub streamingMipmapsActive: Option<bool>,
    pub streamingMipmapsAddAllCameras: Option<bool>,
    pub streamingMipmapsMaxFileIORequests: Option<i32>,
    pub streamingMipmapsMaxLevelReduction: Option<i32>,
    pub streamingMipmapsMemoryBudget: Option<f32>,
    pub streamingMipmapsRenderersPerFrame: Option<i32>,
    pub terrainBasemapDistance: Option<f32>,
    pub terrainBillboardStart: Option<f32>,
    pub terrainDetailDensityScale: Option<f32>,
    pub terrainDetailDistance: Option<f32>,
    pub terrainFadeLength: Option<f32>,
    pub terrainMaxTrees: Option<i32>,
    pub terrainPixelError: Option<f32>,
    pub terrainQualityOverrides: Option<i32>,
    pub terrainTreeDistance: Option<f32>,
    pub textureMipmapLimitSettings: Option<Vec<MipmapLimitSettings>>,
    pub textureQuality: Option<i32>,
    pub useLegacyDetailDistribution: Option<bool>,
    pub vSyncCount: Option<i32>,
}

impl_object!(QualitySetting);

impl Clone for QualitySetting {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            adaptiveVsync: self.adaptiveVsync.clone(),
            adaptiveVsyncExtraA: self.adaptiveVsyncExtraA.clone(),
            adaptiveVsyncExtraB: self.adaptiveVsyncExtraB.clone(),
            anisotropicTextures: self.anisotropicTextures.clone(),
            antiAliasing: self.antiAliasing.clone(),
            asyncUploadBufferSize: self.asyncUploadBufferSize.clone(),
            asyncUploadPersistentBuffer: self.asyncUploadPersistentBuffer.clone(),
            asyncUploadTimeSlice: self.asyncUploadTimeSlice.clone(),
            billboardsFaceCameraPosition: self.billboardsFaceCameraPosition.clone(),
            blendWeights: self.blendWeights.clone(),
            customRenderPipeline: self.customRenderPipeline.clone(),
            enableLODCrossFade: self.enableLODCrossFade.clone(),
            globalTextureMipmapLimit: self.globalTextureMipmapLimit.clone(),
            lodBias: self.lodBias.clone(),
            maximumLODLevel: self.maximumLODLevel.clone(),
            name: self.name.clone(),
            particleRaycastBudget: self.particleRaycastBudget.clone(),
            pixelLightCount: self.pixelLightCount.clone(),
            realtimeGICPUUsage: self.realtimeGICPUUsage.clone(),
            realtimeReflectionProbes: self.realtimeReflectionProbes.clone(),
            resolutionScalingFixedDPIFactor: self.resolutionScalingFixedDPIFactor.clone(),
            shadowCascade2Split: self.shadowCascade2Split.clone(),
            shadowCascade4Split: self.shadowCascade4Split.clone(),
            shadowCascades: self.shadowCascades.clone(),
            shadowDistance: self.shadowDistance.clone(),
            shadowNearPlaneOffset: self.shadowNearPlaneOffset.clone(),
            shadowProjection: self.shadowProjection.clone(),
            shadowResolution: self.shadowResolution.clone(),
            shadowmaskMode: self.shadowmaskMode.clone(),
            shadows: self.shadows.clone(),
            skinWeights: self.skinWeights.clone(),
            softParticles: self.softParticles.clone(),
            softVegetation: self.softVegetation.clone(),
            streamingMipmapsActive: self.streamingMipmapsActive.clone(),
            streamingMipmapsAddAllCameras: self.streamingMipmapsAddAllCameras.clone(),
            streamingMipmapsMaxFileIORequests: self.streamingMipmapsMaxFileIORequests.clone(),
            streamingMipmapsMaxLevelReduction: self.streamingMipmapsMaxLevelReduction.clone(),
            streamingMipmapsMemoryBudget: self.streamingMipmapsMemoryBudget.clone(),
            streamingMipmapsRenderersPerFrame: self.streamingMipmapsRenderersPerFrame.clone(),
            terrainBasemapDistance: self.terrainBasemapDistance.clone(),
            terrainBillboardStart: self.terrainBillboardStart.clone(),
            terrainDetailDensityScale: self.terrainDetailDensityScale.clone(),
            terrainDetailDistance: self.terrainDetailDistance.clone(),
            terrainFadeLength: self.terrainFadeLength.clone(),
            terrainMaxTrees: self.terrainMaxTrees.clone(),
            terrainPixelError: self.terrainPixelError.clone(),
            terrainQualityOverrides: self.terrainQualityOverrides.clone(),
            terrainTreeDistance: self.terrainTreeDistance.clone(),
            textureMipmapLimitSettings: self.textureMipmapLimitSettings.clone(),
            textureQuality: self.textureQuality.clone(),
            useLegacyDetailDistribution: self.useLegacyDetailDistribution.clone(),
            vSyncCount: self.vSyncCount.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct QuaternionCurve {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub curve: Option<AnimationCurve>,
    pub path: Option<String>,
}

impl_object!(QuaternionCurve);

impl Clone for QuaternionCurve {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            curve: self.curve.clone(),
            path: self.path.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RationalTime {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Count: Option<i64>,
    pub m_Rate: Option<TicksPerSecond>,
}

impl_object!(RationalTime);

impl Clone for RationalTime {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Count: self.m_Count.clone(),
            m_Rate: self.m_Rate.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RayTracingShaderBuiltinSampler {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bindPoint: Option<i32>,
    pub sampler: Option<u32>,
}

impl_object!(RayTracingShaderBuiltinSampler);

impl Clone for RayTracingShaderBuiltinSampler {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bindPoint: self.bindPoint.clone(),
            sampler: self.sampler.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RayTracingShaderConstantBuffer {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub byteSize: Option<i32>,
    pub hash: Option<u32>,
    pub name: Option<String>,
    pub params: Option<Vec<RayTracingShaderParam>>,
}

impl_object!(RayTracingShaderConstantBuffer);

impl Clone for RayTracingShaderConstantBuffer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            byteSize: self.byteSize.clone(),
            hash: self.hash.clone(),
            name: self.name.clone(),
            params: self.params.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RayTracingShaderFunctionDesc {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub attributeSizeInBytes: Option<u32>,
    pub identifier: Option<RayTracingShaderID>,
    pub payloadSizeInBytes: Option<u32>,
}

impl_object!(RayTracingShaderFunctionDesc);

impl Clone for RayTracingShaderFunctionDesc {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            attributeSizeInBytes: self.attributeSizeInBytes.clone(),
            identifier: self.identifier.clone(),
            payloadSizeInBytes: self.payloadSizeInBytes.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RayTracingShaderID {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub name: Option<String>,
    pub typ: Option<i32>,
}

impl_object!(RayTracingShaderID);

impl Clone for RayTracingShaderID {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            name: self.name.clone(),
            typ: self.typ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RayTracingShaderParam {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub arraySize: Option<i32>,
    pub colCount: Option<i32>,
    pub dataSize: Option<u32>,
    pub dataType: Option<i32>,
    pub name: Option<String>,
    pub offset: Option<i32>,
    pub propertySheetType: Option<i32>,
    pub rowCount: Option<i32>,
    pub typ: Option<i32>,
}

impl_object!(RayTracingShaderParam);

impl Clone for RayTracingShaderParam {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            arraySize: self.arraySize.clone(),
            colCount: self.colCount.clone(),
            dataSize: self.dataSize.clone(),
            dataType: self.dataType.clone(),
            name: self.name.clone(),
            offset: self.offset.clone(),
            propertySheetType: self.propertySheetType.clone(),
            rowCount: self.rowCount.clone(),
            typ: self.typ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RayTracingShaderReflectionData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub code: Option<Vec<u8>>,
    pub functions: Option<Vec<RayTracingShaderFunctionDesc>>,
    pub globalResources: Option<RayTracingShaderResources>,
    pub hasErrors: Option<bool>,
    pub localResources: Option<RayTracingShaderResources>,
    pub precompiled: Option<Vec<u8>>,
    pub requirements: Option<i64>,
}

impl_object!(RayTracingShaderReflectionData);

impl Clone for RayTracingShaderReflectionData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            code: self.code.clone(),
            functions: self.functions.clone(),
            globalResources: self.globalResources.clone(),
            hasErrors: self.hasErrors.clone(),
            localResources: self.localResources.clone(),
            precompiled: self.precompiled.clone(),
            requirements: self.requirements.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RayTracingShaderResource {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub arraySize: Option<i32>,
    pub bindPoint: Option<i32>,
    pub multisampled: Option<bool>,
    pub name: Option<String>,
    pub rayGenMask: Option<u64>,
    pub samplerBindPoint: Option<i32>,
    pub texDimension: Option<i32>,
}

impl_object!(RayTracingShaderResource);

impl Clone for RayTracingShaderResource {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            arraySize: self.arraySize.clone(),
            bindPoint: self.bindPoint.clone(),
            multisampled: self.multisampled.clone(),
            name: self.name.clone(),
            rayGenMask: self.rayGenMask.clone(),
            samplerBindPoint: self.samplerBindPoint.clone(),
            texDimension: self.texDimension.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RayTracingShaderResources {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub builtinSamplers: Option<Vec<RayTracingShaderBuiltinSampler>>,
    pub constantBuffers: Option<Vec<RayTracingShaderResource>>,
    pub constantBuffersDesc: Option<Vec<RayTracingShaderConstantBuffer>>,
    pub inputBuffers: Option<Vec<RayTracingShaderResource>>,
    pub outputBuffers: Option<Vec<RayTracingShaderResource>>,
    pub textures: Option<Vec<RayTracingShaderResource>>,
}

impl_object!(RayTracingShaderResources);

impl Clone for RayTracingShaderResources {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            builtinSamplers: self.builtinSamplers.clone(),
            constantBuffers: self.constantBuffers.clone(),
            constantBuffersDesc: self.constantBuffersDesc.clone(),
            inputBuffers: self.inputBuffers.clone(),
            outputBuffers: self.outputBuffers.clone(),
            textures: self.textures.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RayTracingShaderVariant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub resourceReflectionData: Option<RayTracingShaderReflectionData>,
    pub targetRenderer: Option<i32>,
}

impl_object!(RayTracingShaderVariant);

impl Clone for RayTracingShaderVariant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            resourceReflectionData: self.resourceReflectionData.clone(),
            targetRenderer: self.targetRenderer.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Rectf {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub height: Option<f32>,
    pub width: Option<f32>,
    pub x: Option<f32>,
    pub y: Option<f32>,
}

impl_object!(Rectf);

impl Clone for Rectf {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            height: self.height.clone(),
            width: self.width.clone(),
            x: self.x.clone(),
            y: self.y.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RenderManager {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(RenderManager);

impl Clone for RenderManager {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RenderPassInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub attachmentCount: Option<i32>,
    pub attachments: Option<Vec<AttachmentInfo>>,
    pub depthAttachmentIndex: Option<i32>,
    pub multiviewCount: Option<i32>,
    pub sampleCount: Option<i32>,
    pub shadingRateIndex: Option<i32>,
    pub subPassCount: Option<i32>,
    pub subPasses: Option<Vec<SubPassDescriptor>>,
}

impl_object!(RenderPassInfo);

impl Clone for RenderPassInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            attachmentCount: self.attachmentCount.clone(),
            attachments: self.attachments.clone(),
            depthAttachmentIndex: self.depthAttachmentIndex.clone(),
            multiviewCount: self.multiviewCount.clone(),
            sampleCount: self.sampleCount.clone(),
            shadingRateIndex: self.shadingRateIndex.clone(),
            subPassCount: self.subPassCount.clone(),
            subPasses: self.subPasses.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RenderStateBlock {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub blendState: Option<GfxBlendState>,
    pub depthState: Option<GfxDepthState>,
    pub mask: Option<i32>,
    pub rasterState: Option<GfxRasterState>,
    pub stencilRef: Option<i32>,
    pub stencilState: Option<GfxStencilState>,
}

impl_object!(RenderStateBlock);

impl Clone for RenderStateBlock {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            blendState: self.blendState.clone(),
            depthState: self.depthState.clone(),
            mask: self.mask.clone(),
            rasterState: self.rasterState.clone(),
            stencilRef: self.stencilRef.clone(),
            stencilState: self.stencilState.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RenderStateInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub renderState: Option<RenderStateBlock>,
}

impl_object!(RenderStateInfo);

impl Clone for RenderStateInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            renderState: self.renderState.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RendererData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub explicitProbeSetHash: Option<Hash128>,
    pub lightmapIndex: Option<u16>,
    pub lightmapIndexDynamic: Option<u16>,
    pub lightmapST: Option<Vector4>,
    pub lightmapSTDynamic: Option<Vector4>,
    pub terrainChunkDynamicUVST: Option<Vector4>,
    pub terrainDynamicUVST: Option<Vector4>,
    pub uvMesh: Option<PPtrData<Mesh>>,
}

impl_object!(RendererData);

impl Clone for RendererData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            explicitProbeSetHash: self.explicitProbeSetHash.clone(),
            lightmapIndex: self.lightmapIndex.clone(),
            lightmapIndexDynamic: self.lightmapIndexDynamic.clone(),
            lightmapST: self.lightmapST.clone(),
            lightmapSTDynamic: self.lightmapSTDynamic.clone(),
            terrainChunkDynamicUVST: self.terrainChunkDynamicUVST.clone(),
            terrainDynamicUVST: self.terrainDynamicUVST.clone(),
            uvMesh: self.uvMesh.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ResourceManager_Dependency {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Dependencies: Option<Vec<PPtrData<Object>>>,
    pub m_Object: Option<PPtrData<Object>>,
}

impl_object!(ResourceManager_Dependency);

impl Clone for ResourceManager_Dependency {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Dependencies: self.m_Dependencies.clone(),
            m_Object: self.m_Object.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RippleGroup {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_afDirectional_0: Option<f32>,
    pub m_afDirectional_1: Option<f32>,
    pub m_afDirectional_10: Option<f32>,
    pub m_afDirectional_11: Option<f32>,
    pub m_afDirectional_12: Option<f32>,
    pub m_afDirectional_13: Option<f32>,
    pub m_afDirectional_14: Option<f32>,
    pub m_afDirectional_15: Option<f32>,
    pub m_afDirectional_16: Option<f32>,
    pub m_afDirectional_17: Option<f32>,
    pub m_afDirectional_18: Option<f32>,
    pub m_afDirectional_19: Option<f32>,
    pub m_afDirectional_2: Option<f32>,
    pub m_afDirectional_3: Option<f32>,
    pub m_afDirectional_4: Option<f32>,
    pub m_afDirectional_5: Option<f32>,
    pub m_afDirectional_6: Option<f32>,
    pub m_afDirectional_7: Option<f32>,
    pub m_afDirectional_8: Option<f32>,
    pub m_afDirectional_9: Option<f32>,
    pub m_afFlexibility_0: Option<f32>,
    pub m_afFlexibility_1: Option<f32>,
    pub m_afFlexibility_10: Option<f32>,
    pub m_afFlexibility_11: Option<f32>,
    pub m_afFlexibility_12: Option<f32>,
    pub m_afFlexibility_13: Option<f32>,
    pub m_afFlexibility_14: Option<f32>,
    pub m_afFlexibility_15: Option<f32>,
    pub m_afFlexibility_16: Option<f32>,
    pub m_afFlexibility_17: Option<f32>,
    pub m_afFlexibility_18: Option<f32>,
    pub m_afFlexibility_19: Option<f32>,
    pub m_afFlexibility_2: Option<f32>,
    pub m_afFlexibility_3: Option<f32>,
    pub m_afFlexibility_4: Option<f32>,
    pub m_afFlexibility_5: Option<f32>,
    pub m_afFlexibility_6: Option<f32>,
    pub m_afFlexibility_7: Option<f32>,
    pub m_afFlexibility_8: Option<f32>,
    pub m_afFlexibility_9: Option<f32>,
    pub m_afPlanar_0: Option<f32>,
    pub m_afPlanar_1: Option<f32>,
    pub m_afPlanar_10: Option<f32>,
    pub m_afPlanar_11: Option<f32>,
    pub m_afPlanar_12: Option<f32>,
    pub m_afPlanar_13: Option<f32>,
    pub m_afPlanar_14: Option<f32>,
    pub m_afPlanar_15: Option<f32>,
    pub m_afPlanar_16: Option<f32>,
    pub m_afPlanar_17: Option<f32>,
    pub m_afPlanar_18: Option<f32>,
    pub m_afPlanar_19: Option<f32>,
    pub m_afPlanar_2: Option<f32>,
    pub m_afPlanar_3: Option<f32>,
    pub m_afPlanar_4: Option<f32>,
    pub m_afPlanar_5: Option<f32>,
    pub m_afPlanar_6: Option<f32>,
    pub m_afPlanar_7: Option<f32>,
    pub m_afPlanar_8: Option<f32>,
    pub m_afPlanar_9: Option<f32>,
    pub m_afSpeed_0: Option<f32>,
    pub m_afSpeed_1: Option<f32>,
    pub m_afSpeed_10: Option<f32>,
    pub m_afSpeed_11: Option<f32>,
    pub m_afSpeed_12: Option<f32>,
    pub m_afSpeed_13: Option<f32>,
    pub m_afSpeed_14: Option<f32>,
    pub m_afSpeed_15: Option<f32>,
    pub m_afSpeed_16: Option<f32>,
    pub m_afSpeed_17: Option<f32>,
    pub m_afSpeed_18: Option<f32>,
    pub m_afSpeed_19: Option<f32>,
    pub m_afSpeed_2: Option<f32>,
    pub m_afSpeed_3: Option<f32>,
    pub m_afSpeed_4: Option<f32>,
    pub m_afSpeed_5: Option<f32>,
    pub m_afSpeed_6: Option<f32>,
    pub m_afSpeed_7: Option<f32>,
    pub m_afSpeed_8: Option<f32>,
    pub m_afSpeed_9: Option<f32>,
    pub m_fIndependence: Option<f32>,
    pub m_fShimmer: Option<f32>,
}

impl_object!(RippleGroup);

impl Clone for RippleGroup {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_afDirectional_0: self.m_afDirectional_0.clone(),
            m_afDirectional_1: self.m_afDirectional_1.clone(),
            m_afDirectional_10: self.m_afDirectional_10.clone(),
            m_afDirectional_11: self.m_afDirectional_11.clone(),
            m_afDirectional_12: self.m_afDirectional_12.clone(),
            m_afDirectional_13: self.m_afDirectional_13.clone(),
            m_afDirectional_14: self.m_afDirectional_14.clone(),
            m_afDirectional_15: self.m_afDirectional_15.clone(),
            m_afDirectional_16: self.m_afDirectional_16.clone(),
            m_afDirectional_17: self.m_afDirectional_17.clone(),
            m_afDirectional_18: self.m_afDirectional_18.clone(),
            m_afDirectional_19: self.m_afDirectional_19.clone(),
            m_afDirectional_2: self.m_afDirectional_2.clone(),
            m_afDirectional_3: self.m_afDirectional_3.clone(),
            m_afDirectional_4: self.m_afDirectional_4.clone(),
            m_afDirectional_5: self.m_afDirectional_5.clone(),
            m_afDirectional_6: self.m_afDirectional_6.clone(),
            m_afDirectional_7: self.m_afDirectional_7.clone(),
            m_afDirectional_8: self.m_afDirectional_8.clone(),
            m_afDirectional_9: self.m_afDirectional_9.clone(),
            m_afFlexibility_0: self.m_afFlexibility_0.clone(),
            m_afFlexibility_1: self.m_afFlexibility_1.clone(),
            m_afFlexibility_10: self.m_afFlexibility_10.clone(),
            m_afFlexibility_11: self.m_afFlexibility_11.clone(),
            m_afFlexibility_12: self.m_afFlexibility_12.clone(),
            m_afFlexibility_13: self.m_afFlexibility_13.clone(),
            m_afFlexibility_14: self.m_afFlexibility_14.clone(),
            m_afFlexibility_15: self.m_afFlexibility_15.clone(),
            m_afFlexibility_16: self.m_afFlexibility_16.clone(),
            m_afFlexibility_17: self.m_afFlexibility_17.clone(),
            m_afFlexibility_18: self.m_afFlexibility_18.clone(),
            m_afFlexibility_19: self.m_afFlexibility_19.clone(),
            m_afFlexibility_2: self.m_afFlexibility_2.clone(),
            m_afFlexibility_3: self.m_afFlexibility_3.clone(),
            m_afFlexibility_4: self.m_afFlexibility_4.clone(),
            m_afFlexibility_5: self.m_afFlexibility_5.clone(),
            m_afFlexibility_6: self.m_afFlexibility_6.clone(),
            m_afFlexibility_7: self.m_afFlexibility_7.clone(),
            m_afFlexibility_8: self.m_afFlexibility_8.clone(),
            m_afFlexibility_9: self.m_afFlexibility_9.clone(),
            m_afPlanar_0: self.m_afPlanar_0.clone(),
            m_afPlanar_1: self.m_afPlanar_1.clone(),
            m_afPlanar_10: self.m_afPlanar_10.clone(),
            m_afPlanar_11: self.m_afPlanar_11.clone(),
            m_afPlanar_12: self.m_afPlanar_12.clone(),
            m_afPlanar_13: self.m_afPlanar_13.clone(),
            m_afPlanar_14: self.m_afPlanar_14.clone(),
            m_afPlanar_15: self.m_afPlanar_15.clone(),
            m_afPlanar_16: self.m_afPlanar_16.clone(),
            m_afPlanar_17: self.m_afPlanar_17.clone(),
            m_afPlanar_18: self.m_afPlanar_18.clone(),
            m_afPlanar_19: self.m_afPlanar_19.clone(),
            m_afPlanar_2: self.m_afPlanar_2.clone(),
            m_afPlanar_3: self.m_afPlanar_3.clone(),
            m_afPlanar_4: self.m_afPlanar_4.clone(),
            m_afPlanar_5: self.m_afPlanar_5.clone(),
            m_afPlanar_6: self.m_afPlanar_6.clone(),
            m_afPlanar_7: self.m_afPlanar_7.clone(),
            m_afPlanar_8: self.m_afPlanar_8.clone(),
            m_afPlanar_9: self.m_afPlanar_9.clone(),
            m_afSpeed_0: self.m_afSpeed_0.clone(),
            m_afSpeed_1: self.m_afSpeed_1.clone(),
            m_afSpeed_10: self.m_afSpeed_10.clone(),
            m_afSpeed_11: self.m_afSpeed_11.clone(),
            m_afSpeed_12: self.m_afSpeed_12.clone(),
            m_afSpeed_13: self.m_afSpeed_13.clone(),
            m_afSpeed_14: self.m_afSpeed_14.clone(),
            m_afSpeed_15: self.m_afSpeed_15.clone(),
            m_afSpeed_16: self.m_afSpeed_16.clone(),
            m_afSpeed_17: self.m_afSpeed_17.clone(),
            m_afSpeed_18: self.m_afSpeed_18.clone(),
            m_afSpeed_19: self.m_afSpeed_19.clone(),
            m_afSpeed_2: self.m_afSpeed_2.clone(),
            m_afSpeed_3: self.m_afSpeed_3.clone(),
            m_afSpeed_4: self.m_afSpeed_4.clone(),
            m_afSpeed_5: self.m_afSpeed_5.clone(),
            m_afSpeed_6: self.m_afSpeed_6.clone(),
            m_afSpeed_7: self.m_afSpeed_7.clone(),
            m_afSpeed_8: self.m_afSpeed_8.clone(),
            m_afSpeed_9: self.m_afSpeed_9.clone(),
            m_fIndependence: self.m_fIndependence.clone(),
            m_fShimmer: self.m_fShimmer.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RootMotionData {
    // extends
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,
    // No additional fields
}

impl_object!(RootMotionData);

impl Clone for RootMotionData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RotationBySpeedModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub curve: Option<MinMaxCurve>,
    pub enabled: Option<bool>,
    pub range: Option<Vector2>,
    pub separateAxes: Option<bool>,
    pub x: Option<MinMaxCurve>,
    pub y: Option<MinMaxCurve>,
}

impl_object!(RotationBySpeedModule);

impl Clone for RotationBySpeedModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            curve: self.curve.clone(),
            enabled: self.enabled.clone(),
            range: self.range.clone(),
            separateAxes: self.separateAxes.clone(),
            x: self.x.clone(),
            y: self.y.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct RotationModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub curve: Option<MinMaxCurve>,
    pub enabled: Option<bool>,
    pub separateAxes: Option<bool>,
    pub x: Option<MinMaxCurve>,
    pub y: Option<MinMaxCurve>,
}

impl_object!(RotationModule);

impl Clone for RotationModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            curve: self.curve.clone(),
            enabled: self.enabled.clone(),
            separateAxes: self.separateAxes.clone(),
            x: self.x.clone(),
            y: self.y.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SBranchWindLevel {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_afDirectionAdherence_0: Option<f32>,
    pub m_afDirectionAdherence_1: Option<f32>,
    pub m_afDirectionAdherence_2: Option<f32>,
    pub m_afDirectionAdherence_3: Option<f32>,
    pub m_afDirectionAdherence_4: Option<f32>,
    pub m_afDirectionAdherence_5: Option<f32>,
    pub m_afDirectionAdherence_6: Option<f32>,
    pub m_afDirectionAdherence_7: Option<f32>,
    pub m_afDirectionAdherence_8: Option<f32>,
    pub m_afDirectionAdherence_9: Option<f32>,
    pub m_afDistance_0: Option<f32>,
    pub m_afDistance_1: Option<f32>,
    pub m_afDistance_2: Option<f32>,
    pub m_afDistance_3: Option<f32>,
    pub m_afDistance_4: Option<f32>,
    pub m_afDistance_5: Option<f32>,
    pub m_afDistance_6: Option<f32>,
    pub m_afDistance_7: Option<f32>,
    pub m_afDistance_8: Option<f32>,
    pub m_afDistance_9: Option<f32>,
    pub m_afWhip_0: Option<f32>,
    pub m_afWhip_1: Option<f32>,
    pub m_afWhip_2: Option<f32>,
    pub m_afWhip_3: Option<f32>,
    pub m_afWhip_4: Option<f32>,
    pub m_afWhip_5: Option<f32>,
    pub m_afWhip_6: Option<f32>,
    pub m_afWhip_7: Option<f32>,
    pub m_afWhip_8: Option<f32>,
    pub m_afWhip_9: Option<f32>,
    pub m_fTurbulence: Option<f32>,
    pub m_fTwitch: Option<f32>,
    pub m_fTwitchFreqScale: Option<f32>,
}

impl_object!(SBranchWindLevel);

impl Clone for SBranchWindLevel {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_afDirectionAdherence_0: self.m_afDirectionAdherence_0.clone(),
            m_afDirectionAdherence_1: self.m_afDirectionAdherence_1.clone(),
            m_afDirectionAdherence_2: self.m_afDirectionAdherence_2.clone(),
            m_afDirectionAdherence_3: self.m_afDirectionAdherence_3.clone(),
            m_afDirectionAdherence_4: self.m_afDirectionAdherence_4.clone(),
            m_afDirectionAdherence_5: self.m_afDirectionAdherence_5.clone(),
            m_afDirectionAdherence_6: self.m_afDirectionAdherence_6.clone(),
            m_afDirectionAdherence_7: self.m_afDirectionAdherence_7.clone(),
            m_afDirectionAdherence_8: self.m_afDirectionAdherence_8.clone(),
            m_afDirectionAdherence_9: self.m_afDirectionAdherence_9.clone(),
            m_afDistance_0: self.m_afDistance_0.clone(),
            m_afDistance_1: self.m_afDistance_1.clone(),
            m_afDistance_2: self.m_afDistance_2.clone(),
            m_afDistance_3: self.m_afDistance_3.clone(),
            m_afDistance_4: self.m_afDistance_4.clone(),
            m_afDistance_5: self.m_afDistance_5.clone(),
            m_afDistance_6: self.m_afDistance_6.clone(),
            m_afDistance_7: self.m_afDistance_7.clone(),
            m_afDistance_8: self.m_afDistance_8.clone(),
            m_afDistance_9: self.m_afDistance_9.clone(),
            m_afWhip_0: self.m_afWhip_0.clone(),
            m_afWhip_1: self.m_afWhip_1.clone(),
            m_afWhip_2: self.m_afWhip_2.clone(),
            m_afWhip_3: self.m_afWhip_3.clone(),
            m_afWhip_4: self.m_afWhip_4.clone(),
            m_afWhip_5: self.m_afWhip_5.clone(),
            m_afWhip_6: self.m_afWhip_6.clone(),
            m_afWhip_7: self.m_afWhip_7.clone(),
            m_afWhip_8: self.m_afWhip_8.clone(),
            m_afWhip_9: self.m_afWhip_9.clone(),
            m_fTurbulence: self.m_fTurbulence.clone(),
            m_fTwitch: self.m_fTwitch.clone(),
            m_fTwitchFreqScale: self.m_fTwitchFreqScale.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SParams {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub BranchLevel1: Option<SBranchWindLevel>,
    pub BranchLevel2: Option<SBranchWindLevel>,
    pub LeafGroup1: Option<SWindGroup>,
    pub LeafGroup2: Option<SWindGroup>,
    pub Oscillation0_0: Option<f32>,
    pub Oscillation0_1: Option<f32>,
    pub Oscillation0_2: Option<f32>,
    pub Oscillation0_3: Option<f32>,
    pub Oscillation0_4: Option<f32>,
    pub Oscillation0_5: Option<f32>,
    pub Oscillation0_6: Option<f32>,
    pub Oscillation0_7: Option<f32>,
    pub Oscillation0_8: Option<f32>,
    pub Oscillation0_9: Option<f32>,
    pub Oscillation1_0: Option<f32>,
    pub Oscillation1_1: Option<f32>,
    pub Oscillation1_2: Option<f32>,
    pub Oscillation1_3: Option<f32>,
    pub Oscillation1_4: Option<f32>,
    pub Oscillation1_5: Option<f32>,
    pub Oscillation1_6: Option<f32>,
    pub Oscillation1_7: Option<f32>,
    pub Oscillation1_8: Option<f32>,
    pub Oscillation1_9: Option<f32>,
    pub Oscillation2_0: Option<f32>,
    pub Oscillation2_1: Option<f32>,
    pub Oscillation2_2: Option<f32>,
    pub Oscillation2_3: Option<f32>,
    pub Oscillation2_4: Option<f32>,
    pub Oscillation2_5: Option<f32>,
    pub Oscillation2_6: Option<f32>,
    pub Oscillation2_7: Option<f32>,
    pub Oscillation2_8: Option<f32>,
    pub Oscillation2_9: Option<f32>,
    pub Oscillation3_0: Option<f32>,
    pub Oscillation3_1: Option<f32>,
    pub Oscillation3_2: Option<f32>,
    pub Oscillation3_3: Option<f32>,
    pub Oscillation3_4: Option<f32>,
    pub Oscillation3_5: Option<f32>,
    pub Oscillation3_6: Option<f32>,
    pub Oscillation3_7: Option<f32>,
    pub Oscillation3_8: Option<f32>,
    pub Oscillation3_9: Option<f32>,
    pub Oscillation4_0: Option<f32>,
    pub Oscillation4_1: Option<f32>,
    pub Oscillation4_2: Option<f32>,
    pub Oscillation4_3: Option<f32>,
    pub Oscillation4_4: Option<f32>,
    pub Oscillation4_5: Option<f32>,
    pub Oscillation4_6: Option<f32>,
    pub Oscillation4_7: Option<f32>,
    pub Oscillation4_8: Option<f32>,
    pub Oscillation4_9: Option<f32>,
    pub Oscillation5_0: Option<f32>,
    pub Oscillation5_1: Option<f32>,
    pub Oscillation5_2: Option<f32>,
    pub Oscillation5_3: Option<f32>,
    pub Oscillation5_4: Option<f32>,
    pub Oscillation5_5: Option<f32>,
    pub Oscillation5_6: Option<f32>,
    pub Oscillation5_7: Option<f32>,
    pub Oscillation5_8: Option<f32>,
    pub Oscillation5_9: Option<f32>,
    pub Oscillation6_0: Option<f32>,
    pub Oscillation6_1: Option<f32>,
    pub Oscillation6_2: Option<f32>,
    pub Oscillation6_3: Option<f32>,
    pub Oscillation6_4: Option<f32>,
    pub Oscillation6_5: Option<f32>,
    pub Oscillation6_6: Option<f32>,
    pub Oscillation6_7: Option<f32>,
    pub Oscillation6_8: Option<f32>,
    pub Oscillation6_9: Option<f32>,
    pub Oscillation7_0: Option<f32>,
    pub Oscillation7_1: Option<f32>,
    pub Oscillation7_2: Option<f32>,
    pub Oscillation7_3: Option<f32>,
    pub Oscillation7_4: Option<f32>,
    pub Oscillation7_5: Option<f32>,
    pub Oscillation7_6: Option<f32>,
    pub Oscillation7_7: Option<f32>,
    pub Oscillation7_8: Option<f32>,
    pub Oscillation7_9: Option<f32>,
    pub Oscillation8_0: Option<f32>,
    pub Oscillation8_1: Option<f32>,
    pub Oscillation8_2: Option<f32>,
    pub Oscillation8_3: Option<f32>,
    pub Oscillation8_4: Option<f32>,
    pub Oscillation8_5: Option<f32>,
    pub Oscillation8_6: Option<f32>,
    pub Oscillation8_7: Option<f32>,
    pub Oscillation8_8: Option<f32>,
    pub Oscillation8_9: Option<f32>,
    pub Oscillation9_0: Option<f32>,
    pub Oscillation9_1: Option<f32>,
    pub Oscillation9_2: Option<f32>,
    pub Oscillation9_3: Option<f32>,
    pub Oscillation9_4: Option<f32>,
    pub Oscillation9_5: Option<f32>,
    pub Oscillation9_6: Option<f32>,
    pub Oscillation9_7: Option<f32>,
    pub Oscillation9_8: Option<f32>,
    pub Oscillation9_9: Option<f32>,
    pub m_afFrondRippleDistance_0: Option<f32>,
    pub m_afFrondRippleDistance_1: Option<f32>,
    pub m_afFrondRippleDistance_2: Option<f32>,
    pub m_afFrondRippleDistance_3: Option<f32>,
    pub m_afFrondRippleDistance_4: Option<f32>,
    pub m_afFrondRippleDistance_5: Option<f32>,
    pub m_afFrondRippleDistance_6: Option<f32>,
    pub m_afFrondRippleDistance_7: Option<f32>,
    pub m_afFrondRippleDistance_8: Option<f32>,
    pub m_afFrondRippleDistance_9: Option<f32>,
    pub m_afGlobalDirectionAdherence_0: Option<f32>,
    pub m_afGlobalDirectionAdherence_1: Option<f32>,
    pub m_afGlobalDirectionAdherence_2: Option<f32>,
    pub m_afGlobalDirectionAdherence_3: Option<f32>,
    pub m_afGlobalDirectionAdherence_4: Option<f32>,
    pub m_afGlobalDirectionAdherence_5: Option<f32>,
    pub m_afGlobalDirectionAdherence_6: Option<f32>,
    pub m_afGlobalDirectionAdherence_7: Option<f32>,
    pub m_afGlobalDirectionAdherence_8: Option<f32>,
    pub m_afGlobalDirectionAdherence_9: Option<f32>,
    pub m_afGlobalDistance_0: Option<f32>,
    pub m_afGlobalDistance_1: Option<f32>,
    pub m_afGlobalDistance_2: Option<f32>,
    pub m_afGlobalDistance_3: Option<f32>,
    pub m_afGlobalDistance_4: Option<f32>,
    pub m_afGlobalDistance_5: Option<f32>,
    pub m_afGlobalDistance_6: Option<f32>,
    pub m_afGlobalDistance_7: Option<f32>,
    pub m_afGlobalDistance_8: Option<f32>,
    pub m_afGlobalDistance_9: Option<f32>,
    pub m_fAnchorDistanceScale: Option<f32>,
    pub m_fAnchorOffset: Option<f32>,
    pub m_fDirectionResponse: Option<f32>,
    pub m_fFrondRippleLightingScalar: Option<f32>,
    pub m_fFrondRippleTile: Option<f32>,
    pub m_fGlobalHeight: Option<f32>,
    pub m_fGlobalHeightExponent: Option<f32>,
    pub m_fGustDurationMax: Option<f32>,
    pub m_fGustDurationMin: Option<f32>,
    pub m_fGustFallScalar: Option<f32>,
    pub m_fGustFrequency: Option<f32>,
    pub m_fGustRiseScalar: Option<f32>,
    pub m_fGustStrengthMax: Option<f32>,
    pub m_fGustStrengthMin: Option<f32>,
    pub m_fRollingBranchFieldMin: Option<f32>,
    pub m_fRollingBranchLightingAdjust: Option<f32>,
    pub m_fRollingBranchVerticalOffset: Option<f32>,
    pub m_fRollingLeafRippleMin: Option<f32>,
    pub m_fRollingLeafTumbleMin: Option<f32>,
    pub m_fRollingNoisePeriod: Option<f32>,
    pub m_fRollingNoiseSize: Option<f32>,
    pub m_fRollingNoiseSpeed: Option<f32>,
    pub m_fRollingNoiseTurbulence: Option<f32>,
    pub m_fRollingNoiseTwist: Option<f32>,
    pub m_fStrengthResponse: Option<f32>,
}

impl_object!(SParams);

impl Clone for SParams {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            BranchLevel1: self.BranchLevel1.clone(),
            BranchLevel2: self.BranchLevel2.clone(),
            LeafGroup1: self.LeafGroup1.clone(),
            LeafGroup2: self.LeafGroup2.clone(),
            Oscillation0_0: self.Oscillation0_0.clone(),
            Oscillation0_1: self.Oscillation0_1.clone(),
            Oscillation0_2: self.Oscillation0_2.clone(),
            Oscillation0_3: self.Oscillation0_3.clone(),
            Oscillation0_4: self.Oscillation0_4.clone(),
            Oscillation0_5: self.Oscillation0_5.clone(),
            Oscillation0_6: self.Oscillation0_6.clone(),
            Oscillation0_7: self.Oscillation0_7.clone(),
            Oscillation0_8: self.Oscillation0_8.clone(),
            Oscillation0_9: self.Oscillation0_9.clone(),
            Oscillation1_0: self.Oscillation1_0.clone(),
            Oscillation1_1: self.Oscillation1_1.clone(),
            Oscillation1_2: self.Oscillation1_2.clone(),
            Oscillation1_3: self.Oscillation1_3.clone(),
            Oscillation1_4: self.Oscillation1_4.clone(),
            Oscillation1_5: self.Oscillation1_5.clone(),
            Oscillation1_6: self.Oscillation1_6.clone(),
            Oscillation1_7: self.Oscillation1_7.clone(),
            Oscillation1_8: self.Oscillation1_8.clone(),
            Oscillation1_9: self.Oscillation1_9.clone(),
            Oscillation2_0: self.Oscillation2_0.clone(),
            Oscillation2_1: self.Oscillation2_1.clone(),
            Oscillation2_2: self.Oscillation2_2.clone(),
            Oscillation2_3: self.Oscillation2_3.clone(),
            Oscillation2_4: self.Oscillation2_4.clone(),
            Oscillation2_5: self.Oscillation2_5.clone(),
            Oscillation2_6: self.Oscillation2_6.clone(),
            Oscillation2_7: self.Oscillation2_7.clone(),
            Oscillation2_8: self.Oscillation2_8.clone(),
            Oscillation2_9: self.Oscillation2_9.clone(),
            Oscillation3_0: self.Oscillation3_0.clone(),
            Oscillation3_1: self.Oscillation3_1.clone(),
            Oscillation3_2: self.Oscillation3_2.clone(),
            Oscillation3_3: self.Oscillation3_3.clone(),
            Oscillation3_4: self.Oscillation3_4.clone(),
            Oscillation3_5: self.Oscillation3_5.clone(),
            Oscillation3_6: self.Oscillation3_6.clone(),
            Oscillation3_7: self.Oscillation3_7.clone(),
            Oscillation3_8: self.Oscillation3_8.clone(),
            Oscillation3_9: self.Oscillation3_9.clone(),
            Oscillation4_0: self.Oscillation4_0.clone(),
            Oscillation4_1: self.Oscillation4_1.clone(),
            Oscillation4_2: self.Oscillation4_2.clone(),
            Oscillation4_3: self.Oscillation4_3.clone(),
            Oscillation4_4: self.Oscillation4_4.clone(),
            Oscillation4_5: self.Oscillation4_5.clone(),
            Oscillation4_6: self.Oscillation4_6.clone(),
            Oscillation4_7: self.Oscillation4_7.clone(),
            Oscillation4_8: self.Oscillation4_8.clone(),
            Oscillation4_9: self.Oscillation4_9.clone(),
            Oscillation5_0: self.Oscillation5_0.clone(),
            Oscillation5_1: self.Oscillation5_1.clone(),
            Oscillation5_2: self.Oscillation5_2.clone(),
            Oscillation5_3: self.Oscillation5_3.clone(),
            Oscillation5_4: self.Oscillation5_4.clone(),
            Oscillation5_5: self.Oscillation5_5.clone(),
            Oscillation5_6: self.Oscillation5_6.clone(),
            Oscillation5_7: self.Oscillation5_7.clone(),
            Oscillation5_8: self.Oscillation5_8.clone(),
            Oscillation5_9: self.Oscillation5_9.clone(),
            Oscillation6_0: self.Oscillation6_0.clone(),
            Oscillation6_1: self.Oscillation6_1.clone(),
            Oscillation6_2: self.Oscillation6_2.clone(),
            Oscillation6_3: self.Oscillation6_3.clone(),
            Oscillation6_4: self.Oscillation6_4.clone(),
            Oscillation6_5: self.Oscillation6_5.clone(),
            Oscillation6_6: self.Oscillation6_6.clone(),
            Oscillation6_7: self.Oscillation6_7.clone(),
            Oscillation6_8: self.Oscillation6_8.clone(),
            Oscillation6_9: self.Oscillation6_9.clone(),
            Oscillation7_0: self.Oscillation7_0.clone(),
            Oscillation7_1: self.Oscillation7_1.clone(),
            Oscillation7_2: self.Oscillation7_2.clone(),
            Oscillation7_3: self.Oscillation7_3.clone(),
            Oscillation7_4: self.Oscillation7_4.clone(),
            Oscillation7_5: self.Oscillation7_5.clone(),
            Oscillation7_6: self.Oscillation7_6.clone(),
            Oscillation7_7: self.Oscillation7_7.clone(),
            Oscillation7_8: self.Oscillation7_8.clone(),
            Oscillation7_9: self.Oscillation7_9.clone(),
            Oscillation8_0: self.Oscillation8_0.clone(),
            Oscillation8_1: self.Oscillation8_1.clone(),
            Oscillation8_2: self.Oscillation8_2.clone(),
            Oscillation8_3: self.Oscillation8_3.clone(),
            Oscillation8_4: self.Oscillation8_4.clone(),
            Oscillation8_5: self.Oscillation8_5.clone(),
            Oscillation8_6: self.Oscillation8_6.clone(),
            Oscillation8_7: self.Oscillation8_7.clone(),
            Oscillation8_8: self.Oscillation8_8.clone(),
            Oscillation8_9: self.Oscillation8_9.clone(),
            Oscillation9_0: self.Oscillation9_0.clone(),
            Oscillation9_1: self.Oscillation9_1.clone(),
            Oscillation9_2: self.Oscillation9_2.clone(),
            Oscillation9_3: self.Oscillation9_3.clone(),
            Oscillation9_4: self.Oscillation9_4.clone(),
            Oscillation9_5: self.Oscillation9_5.clone(),
            Oscillation9_6: self.Oscillation9_6.clone(),
            Oscillation9_7: self.Oscillation9_7.clone(),
            Oscillation9_8: self.Oscillation9_8.clone(),
            Oscillation9_9: self.Oscillation9_9.clone(),
            m_afFrondRippleDistance_0: self.m_afFrondRippleDistance_0.clone(),
            m_afFrondRippleDistance_1: self.m_afFrondRippleDistance_1.clone(),
            m_afFrondRippleDistance_2: self.m_afFrondRippleDistance_2.clone(),
            m_afFrondRippleDistance_3: self.m_afFrondRippleDistance_3.clone(),
            m_afFrondRippleDistance_4: self.m_afFrondRippleDistance_4.clone(),
            m_afFrondRippleDistance_5: self.m_afFrondRippleDistance_5.clone(),
            m_afFrondRippleDistance_6: self.m_afFrondRippleDistance_6.clone(),
            m_afFrondRippleDistance_7: self.m_afFrondRippleDistance_7.clone(),
            m_afFrondRippleDistance_8: self.m_afFrondRippleDistance_8.clone(),
            m_afFrondRippleDistance_9: self.m_afFrondRippleDistance_9.clone(),
            m_afGlobalDirectionAdherence_0: self.m_afGlobalDirectionAdherence_0.clone(),
            m_afGlobalDirectionAdherence_1: self.m_afGlobalDirectionAdherence_1.clone(),
            m_afGlobalDirectionAdherence_2: self.m_afGlobalDirectionAdherence_2.clone(),
            m_afGlobalDirectionAdherence_3: self.m_afGlobalDirectionAdherence_3.clone(),
            m_afGlobalDirectionAdherence_4: self.m_afGlobalDirectionAdherence_4.clone(),
            m_afGlobalDirectionAdherence_5: self.m_afGlobalDirectionAdherence_5.clone(),
            m_afGlobalDirectionAdherence_6: self.m_afGlobalDirectionAdherence_6.clone(),
            m_afGlobalDirectionAdherence_7: self.m_afGlobalDirectionAdherence_7.clone(),
            m_afGlobalDirectionAdherence_8: self.m_afGlobalDirectionAdherence_8.clone(),
            m_afGlobalDirectionAdherence_9: self.m_afGlobalDirectionAdherence_9.clone(),
            m_afGlobalDistance_0: self.m_afGlobalDistance_0.clone(),
            m_afGlobalDistance_1: self.m_afGlobalDistance_1.clone(),
            m_afGlobalDistance_2: self.m_afGlobalDistance_2.clone(),
            m_afGlobalDistance_3: self.m_afGlobalDistance_3.clone(),
            m_afGlobalDistance_4: self.m_afGlobalDistance_4.clone(),
            m_afGlobalDistance_5: self.m_afGlobalDistance_5.clone(),
            m_afGlobalDistance_6: self.m_afGlobalDistance_6.clone(),
            m_afGlobalDistance_7: self.m_afGlobalDistance_7.clone(),
            m_afGlobalDistance_8: self.m_afGlobalDistance_8.clone(),
            m_afGlobalDistance_9: self.m_afGlobalDistance_9.clone(),
            m_fAnchorDistanceScale: self.m_fAnchorDistanceScale.clone(),
            m_fAnchorOffset: self.m_fAnchorOffset.clone(),
            m_fDirectionResponse: self.m_fDirectionResponse.clone(),
            m_fFrondRippleLightingScalar: self.m_fFrondRippleLightingScalar.clone(),
            m_fFrondRippleTile: self.m_fFrondRippleTile.clone(),
            m_fGlobalHeight: self.m_fGlobalHeight.clone(),
            m_fGlobalHeightExponent: self.m_fGlobalHeightExponent.clone(),
            m_fGustDurationMax: self.m_fGustDurationMax.clone(),
            m_fGustDurationMin: self.m_fGustDurationMin.clone(),
            m_fGustFallScalar: self.m_fGustFallScalar.clone(),
            m_fGustFrequency: self.m_fGustFrequency.clone(),
            m_fGustRiseScalar: self.m_fGustRiseScalar.clone(),
            m_fGustStrengthMax: self.m_fGustStrengthMax.clone(),
            m_fGustStrengthMin: self.m_fGustStrengthMin.clone(),
            m_fRollingBranchFieldMin: self.m_fRollingBranchFieldMin.clone(),
            m_fRollingBranchLightingAdjust: self.m_fRollingBranchLightingAdjust.clone(),
            m_fRollingBranchVerticalOffset: self.m_fRollingBranchVerticalOffset.clone(),
            m_fRollingLeafRippleMin: self.m_fRollingLeafRippleMin.clone(),
            m_fRollingLeafTumbleMin: self.m_fRollingLeafTumbleMin.clone(),
            m_fRollingNoisePeriod: self.m_fRollingNoisePeriod.clone(),
            m_fRollingNoiseSize: self.m_fRollingNoiseSize.clone(),
            m_fRollingNoiseSpeed: self.m_fRollingNoiseSpeed.clone(),
            m_fRollingNoiseTurbulence: self.m_fRollingNoiseTurbulence.clone(),
            m_fRollingNoiseTwist: self.m_fRollingNoiseTwist.clone(),
            m_fStrengthResponse: self.m_fStrengthResponse.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SWindGroup {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_afRippleDistance_0: Option<f32>,
    pub m_afRippleDistance_1: Option<f32>,
    pub m_afRippleDistance_2: Option<f32>,
    pub m_afRippleDistance_3: Option<f32>,
    pub m_afRippleDistance_4: Option<f32>,
    pub m_afRippleDistance_5: Option<f32>,
    pub m_afRippleDistance_6: Option<f32>,
    pub m_afRippleDistance_7: Option<f32>,
    pub m_afRippleDistance_8: Option<f32>,
    pub m_afRippleDistance_9: Option<f32>,
    pub m_afTumbleDirectionAdherence_0: Option<f32>,
    pub m_afTumbleDirectionAdherence_1: Option<f32>,
    pub m_afTumbleDirectionAdherence_2: Option<f32>,
    pub m_afTumbleDirectionAdherence_3: Option<f32>,
    pub m_afTumbleDirectionAdherence_4: Option<f32>,
    pub m_afTumbleDirectionAdherence_5: Option<f32>,
    pub m_afTumbleDirectionAdherence_6: Option<f32>,
    pub m_afTumbleDirectionAdherence_7: Option<f32>,
    pub m_afTumbleDirectionAdherence_8: Option<f32>,
    pub m_afTumbleDirectionAdherence_9: Option<f32>,
    pub m_afTumbleFlip_0: Option<f32>,
    pub m_afTumbleFlip_1: Option<f32>,
    pub m_afTumbleFlip_2: Option<f32>,
    pub m_afTumbleFlip_3: Option<f32>,
    pub m_afTumbleFlip_4: Option<f32>,
    pub m_afTumbleFlip_5: Option<f32>,
    pub m_afTumbleFlip_6: Option<f32>,
    pub m_afTumbleFlip_7: Option<f32>,
    pub m_afTumbleFlip_8: Option<f32>,
    pub m_afTumbleFlip_9: Option<f32>,
    pub m_afTumbleTwist_0: Option<f32>,
    pub m_afTumbleTwist_1: Option<f32>,
    pub m_afTumbleTwist_2: Option<f32>,
    pub m_afTumbleTwist_3: Option<f32>,
    pub m_afTumbleTwist_4: Option<f32>,
    pub m_afTumbleTwist_5: Option<f32>,
    pub m_afTumbleTwist_6: Option<f32>,
    pub m_afTumbleTwist_7: Option<f32>,
    pub m_afTumbleTwist_8: Option<f32>,
    pub m_afTumbleTwist_9: Option<f32>,
    pub m_afTwitchThrow_0: Option<f32>,
    pub m_afTwitchThrow_1: Option<f32>,
    pub m_afTwitchThrow_2: Option<f32>,
    pub m_afTwitchThrow_3: Option<f32>,
    pub m_afTwitchThrow_4: Option<f32>,
    pub m_afTwitchThrow_5: Option<f32>,
    pub m_afTwitchThrow_6: Option<f32>,
    pub m_afTwitchThrow_7: Option<f32>,
    pub m_afTwitchThrow_8: Option<f32>,
    pub m_afTwitchThrow_9: Option<f32>,
    pub m_fLeewardScalar: Option<f32>,
    pub m_fRollMaxScale: Option<f32>,
    pub m_fRollMinScale: Option<f32>,
    pub m_fRollSeparation: Option<f32>,
    pub m_fRollSpeed: Option<f32>,
    pub m_fTwitchSharpness: Option<f32>,
}

impl_object!(SWindGroup);

impl Clone for SWindGroup {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_afRippleDistance_0: self.m_afRippleDistance_0.clone(),
            m_afRippleDistance_1: self.m_afRippleDistance_1.clone(),
            m_afRippleDistance_2: self.m_afRippleDistance_2.clone(),
            m_afRippleDistance_3: self.m_afRippleDistance_3.clone(),
            m_afRippleDistance_4: self.m_afRippleDistance_4.clone(),
            m_afRippleDistance_5: self.m_afRippleDistance_5.clone(),
            m_afRippleDistance_6: self.m_afRippleDistance_6.clone(),
            m_afRippleDistance_7: self.m_afRippleDistance_7.clone(),
            m_afRippleDistance_8: self.m_afRippleDistance_8.clone(),
            m_afRippleDistance_9: self.m_afRippleDistance_9.clone(),
            m_afTumbleDirectionAdherence_0: self.m_afTumbleDirectionAdherence_0.clone(),
            m_afTumbleDirectionAdherence_1: self.m_afTumbleDirectionAdherence_1.clone(),
            m_afTumbleDirectionAdherence_2: self.m_afTumbleDirectionAdherence_2.clone(),
            m_afTumbleDirectionAdherence_3: self.m_afTumbleDirectionAdherence_3.clone(),
            m_afTumbleDirectionAdherence_4: self.m_afTumbleDirectionAdherence_4.clone(),
            m_afTumbleDirectionAdherence_5: self.m_afTumbleDirectionAdherence_5.clone(),
            m_afTumbleDirectionAdherence_6: self.m_afTumbleDirectionAdherence_6.clone(),
            m_afTumbleDirectionAdherence_7: self.m_afTumbleDirectionAdherence_7.clone(),
            m_afTumbleDirectionAdherence_8: self.m_afTumbleDirectionAdherence_8.clone(),
            m_afTumbleDirectionAdherence_9: self.m_afTumbleDirectionAdherence_9.clone(),
            m_afTumbleFlip_0: self.m_afTumbleFlip_0.clone(),
            m_afTumbleFlip_1: self.m_afTumbleFlip_1.clone(),
            m_afTumbleFlip_2: self.m_afTumbleFlip_2.clone(),
            m_afTumbleFlip_3: self.m_afTumbleFlip_3.clone(),
            m_afTumbleFlip_4: self.m_afTumbleFlip_4.clone(),
            m_afTumbleFlip_5: self.m_afTumbleFlip_5.clone(),
            m_afTumbleFlip_6: self.m_afTumbleFlip_6.clone(),
            m_afTumbleFlip_7: self.m_afTumbleFlip_7.clone(),
            m_afTumbleFlip_8: self.m_afTumbleFlip_8.clone(),
            m_afTumbleFlip_9: self.m_afTumbleFlip_9.clone(),
            m_afTumbleTwist_0: self.m_afTumbleTwist_0.clone(),
            m_afTumbleTwist_1: self.m_afTumbleTwist_1.clone(),
            m_afTumbleTwist_2: self.m_afTumbleTwist_2.clone(),
            m_afTumbleTwist_3: self.m_afTumbleTwist_3.clone(),
            m_afTumbleTwist_4: self.m_afTumbleTwist_4.clone(),
            m_afTumbleTwist_5: self.m_afTumbleTwist_5.clone(),
            m_afTumbleTwist_6: self.m_afTumbleTwist_6.clone(),
            m_afTumbleTwist_7: self.m_afTumbleTwist_7.clone(),
            m_afTumbleTwist_8: self.m_afTumbleTwist_8.clone(),
            m_afTumbleTwist_9: self.m_afTumbleTwist_9.clone(),
            m_afTwitchThrow_0: self.m_afTwitchThrow_0.clone(),
            m_afTwitchThrow_1: self.m_afTwitchThrow_1.clone(),
            m_afTwitchThrow_2: self.m_afTwitchThrow_2.clone(),
            m_afTwitchThrow_3: self.m_afTwitchThrow_3.clone(),
            m_afTwitchThrow_4: self.m_afTwitchThrow_4.clone(),
            m_afTwitchThrow_5: self.m_afTwitchThrow_5.clone(),
            m_afTwitchThrow_6: self.m_afTwitchThrow_6.clone(),
            m_afTwitchThrow_7: self.m_afTwitchThrow_7.clone(),
            m_afTwitchThrow_8: self.m_afTwitchThrow_8.clone(),
            m_afTwitchThrow_9: self.m_afTwitchThrow_9.clone(),
            m_fLeewardScalar: self.m_fLeewardScalar.clone(),
            m_fRollMaxScale: self.m_fRollMaxScale.clone(),
            m_fRollMinScale: self.m_fRollMinScale.clone(),
            m_fRollSeparation: self.m_fRollSeparation.clone(),
            m_fRollSpeed: self.m_fRollSpeed.clone(),
            m_fTwitchSharpness: self.m_fTwitchSharpness.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SampleSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub compressionFormat: Option<i32>,
    pub conversionMode: Option<i32>,
    pub loadType: Option<i32>,
    pub preloadAudioData: Option<bool>,
    pub quality: Option<f32>,
    pub sampleRateOverride: Option<u32>,
    pub sampleRateSetting: Option<i32>,
}

impl_object!(SampleSettings);

impl Clone for SampleSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            compressionFormat: self.compressionFormat.clone(),
            conversionMode: self.conversionMode.clone(),
            loadType: self.loadType.clone(),
            preloadAudioData: self.preloadAudioData.clone(),
            quality: self.quality.clone(),
            sampleRateOverride: self.sampleRateOverride.clone(),
            sampleRateSetting: self.sampleRateSetting.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SamplerParameter {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bindPoint: Option<i32>,
    pub sampler: Option<u32>,
}

impl_object!(SamplerParameter);

impl Clone for SamplerParameter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bindPoint: self.bindPoint.clone(),
            sampler: self.sampler.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Scene {
    // extends LevelGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub enabled: Option<bool>,
    pub guid: Option<GUID>,
    pub m_PVSData: Option<Vec<u8>>,
    pub m_PVSObjectsArray: Option<Vec<PPtrData<Renderer>>>,
    pub m_PVSPortalsArray: Option<Vec<PPtrData<OcclusionPortal>>>,
    pub m_QueryMode: Option<u32>,
    pub path: Option<String>,
}

impl_object!(Scene);

impl Clone for Scene {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            enabled: self.enabled.clone(),
            guid: self.guid.clone(),
            m_PVSData: self.m_PVSData.clone(),
            m_PVSObjectsArray: self.m_PVSObjectsArray.clone(),
            m_PVSPortalsArray: self.m_PVSPortalsArray.clone(),
            m_QueryMode: self.m_QueryMode.clone(),
            path: self.path.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SceneDataContainer {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_SceneData: Option<Vec<(SceneIdentifier, HierarchicalSceneData)>>,
}

impl_object!(SceneDataContainer);

impl Clone for SceneDataContainer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_SceneData: self.m_SceneData.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SceneIdentifier {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub guid: Option<GUID>,
    pub handle: Option<i32>,
}

impl_object!(SceneIdentifier);

impl Clone for SceneIdentifier {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            guid: self.guid.clone(),
            handle: self.handle.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SceneObjectIdentifier {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub targetObject: Option<i64>,
    pub targetPrefab: Option<i64>,
}

impl_object!(SceneObjectIdentifier);

impl Clone for SceneObjectIdentifier {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            targetObject: self.targetObject.clone(),
            targetPrefab: self.targetPrefab.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SceneSettings {
    // extends LevelGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_PVSData: Option<Vec<u8>>,
    pub m_PVSObjectsArray: Option<Vec<PPtrData<Renderer>>>,
    pub m_PVSPortalsArray: Option<Vec<PPtrData<OcclusionPortal>>>,
    pub m_QueryMode: Option<u32>,
}

impl_object!(SceneSettings);

impl Clone for SceneSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_PVSData: self.m_PVSData.clone(),
            m_PVSObjectsArray: self.m_PVSObjectsArray.clone(),
            m_PVSPortalsArray: self.m_PVSPortalsArray.clone(),
            m_QueryMode: self.m_QueryMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SceneVisibilityData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_SceneGUID: Option<GUID>,
}

impl_object!(SceneVisibilityData);

impl Clone for SceneVisibilityData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_SceneGUID: self.m_SceneGUID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ScriptMapper {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_PreloadShaders: Option<bool>,
    pub m_Shaders: Option<NameToObjectMap>,
}

impl_object!(ScriptMapper);

impl Clone for ScriptMapper {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_PreloadShaders: self.m_PreloadShaders.clone(),
            m_Shaders: self.m_Shaders.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SecondarySpriteTexture {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub name: Option<String>,
    pub texture: Option<PPtrData<Texture2D>>,
}

impl_object!(SecondarySpriteTexture);

impl Clone for SecondarySpriteTexture {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            name: self.name.clone(),
            texture: self.texture.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SecondaryTextureSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub platformSettings: Option<Vec<TextureImporterPlatformSettings>>,
    pub sRGB: Option<bool>,
}

impl_object!(SecondaryTextureSettings);

impl Clone for SecondaryTextureSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            platformSettings: self.platformSettings.clone(),
            sRGB: self.sRGB.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SelectorStateConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_FullPathID: Option<u32>,
    pub m_IsEntry: Option<bool>,
    pub m_TransitionConstantArray: Option<Vec<Box<Box<OffsetPtr>>>>,
}

impl_object!(SelectorStateConstant);

impl Clone for SelectorStateConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_FullPathID: self.m_FullPathID.clone(),
            m_IsEntry: self.m_IsEntry.clone(),
            m_TransitionConstantArray: self.m_TransitionConstantArray.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SelectorTransitionConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ConditionConstantArray: Option<Vec<Box<Box<OffsetPtr>>>>,
    pub m_Destination: Option<u32>,
}

impl_object!(SelectorTransitionConstant);

impl Clone for SelectorTransitionConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ConditionConstantArray: self.m_ConditionConstantArray.clone(),
            m_Destination: self.m_Destination.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedCustomEditorForRenderPipeline {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub customEditorName: Option<String>,
    pub renderPipelineType: Option<String>,
}

impl_object!(SerializedCustomEditorForRenderPipeline);

impl Clone for SerializedCustomEditorForRenderPipeline {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            customEditorName: self.customEditorName.clone(),
            renderPipelineType: self.renderPipelineType.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedPass {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_EditorDataHash: Option<Vec<Hash128>>,
    pub m_GlobalKeywordMask: Option<Vec<u16>>,
    pub m_HasInstancingVariant: Option<bool>,
    pub m_HasProceduralInstancingVariant: Option<bool>,
    pub m_LocalKeywordMask: Option<Vec<u16>>,
    pub m_Name: Option<String>,
    pub m_NameIndices: Option<Vec<(String, i32)>>,
    pub m_Platforms: Option<Vec<u8>>,
    pub m_ProgramMask: Option<u32>,
    pub m_SerializedKeywordStateMask: Option<Vec<u16>>,
    pub m_State: Option<SerializedShaderState>,
    pub m_Tags: Option<SerializedTagMap>,
    pub m_TextureName: Option<String>,
    pub m_Type: Option<i32>,
    pub m_UseName: Option<String>,
    pub progDomain: Option<SerializedProgram>,
    pub progFragment: Option<SerializedProgram>,
    pub progGeometry: Option<SerializedProgram>,
    pub progHull: Option<SerializedProgram>,
    pub progRayTracing: Option<SerializedProgram>,
    pub progVertex: Option<SerializedProgram>,
}

impl_object!(SerializedPass);

impl Clone for SerializedPass {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_EditorDataHash: self.m_EditorDataHash.clone(),
            m_GlobalKeywordMask: self.m_GlobalKeywordMask.clone(),
            m_HasInstancingVariant: self.m_HasInstancingVariant.clone(),
            m_HasProceduralInstancingVariant: self.m_HasProceduralInstancingVariant.clone(),
            m_LocalKeywordMask: self.m_LocalKeywordMask.clone(),
            m_Name: self.m_Name.clone(),
            m_NameIndices: self.m_NameIndices.clone(),
            m_Platforms: self.m_Platforms.clone(),
            m_ProgramMask: self.m_ProgramMask.clone(),
            m_SerializedKeywordStateMask: self.m_SerializedKeywordStateMask.clone(),
            m_State: self.m_State.clone(),
            m_Tags: self.m_Tags.clone(),
            m_TextureName: self.m_TextureName.clone(),
            m_Type: self.m_Type.clone(),
            m_UseName: self.m_UseName.clone(),
            progDomain: self.progDomain.clone(),
            progFragment: self.progFragment.clone(),
            progGeometry: self.progGeometry.clone(),
            progHull: self.progHull.clone(),
            progRayTracing: self.progRayTracing.clone(),
            progVertex: self.progVertex.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedPlayerSubProgram {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BlobIndex: Option<u32>,
    pub m_GpuProgramType: Option<i8>,
    pub m_KeywordIndices: Option<Vec<u16>>,
    pub m_ShaderRequirements: Option<i64>,
}

impl_object!(SerializedPlayerSubProgram);

impl Clone for SerializedPlayerSubProgram {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BlobIndex: self.m_BlobIndex.clone(),
            m_GpuProgramType: self.m_GpuProgramType.clone(),
            m_KeywordIndices: self.m_KeywordIndices.clone(),
            m_ShaderRequirements: self.m_ShaderRequirements.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedProgram {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CommonParameters: Option<SerializedProgramParameters>,
    pub m_ParameterBlobIndices: Option<Vec<Vec<u32>>>,
    pub m_PlayerSubPrograms: Option<Vec<Vec<SerializedPlayerSubProgram>>>,
    pub m_SerializedKeywordStateMask: Option<Vec<u16>>,
    pub m_SubPrograms: Option<Vec<SerializedSubProgram>>,
}

impl_object!(SerializedProgram);

impl Clone for SerializedProgram {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CommonParameters: self.m_CommonParameters.clone(),
            m_ParameterBlobIndices: self.m_ParameterBlobIndices.clone(),
            m_PlayerSubPrograms: self.m_PlayerSubPrograms.clone(),
            m_SerializedKeywordStateMask: self.m_SerializedKeywordStateMask.clone(),
            m_SubPrograms: self.m_SubPrograms.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedProgramParameters {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BufferParams: Option<Vec<BufferBinding>>,
    pub m_ConstantBufferBindings: Option<Vec<BufferBinding>>,
    pub m_ConstantBuffers: Option<Vec<ConstantBuffer>>,
    pub m_MatrixParams: Option<Vec<MatrixParameter>>,
    pub m_Samplers: Option<Vec<SamplerParameter>>,
    pub m_TextureParams: Option<Vec<TextureParameter>>,
    pub m_UAVParams: Option<Vec<UAVParameter>>,
    pub m_VectorParams: Option<Vec<VectorParameter>>,
}

impl_object!(SerializedProgramParameters);

impl Clone for SerializedProgramParameters {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BufferParams: self.m_BufferParams.clone(),
            m_ConstantBufferBindings: self.m_ConstantBufferBindings.clone(),
            m_ConstantBuffers: self.m_ConstantBuffers.clone(),
            m_MatrixParams: self.m_MatrixParams.clone(),
            m_Samplers: self.m_Samplers.clone(),
            m_TextureParams: self.m_TextureParams.clone(),
            m_UAVParams: self.m_UAVParams.clone(),
            m_VectorParams: self.m_VectorParams.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedProperties {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Props: Option<Vec<SerializedProperty>>,
}

impl_object!(SerializedProperties);

impl Clone for SerializedProperties {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Props: self.m_Props.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedProperty {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Attributes: Option<Vec<String>>,
    pub m_DefTexture: Option<SerializedTextureProperty>,
    pub m_DefValue_0_: Option<f32>,
    pub m_DefValue_1_: Option<f32>,
    pub m_DefValue_2_: Option<f32>,
    pub m_DefValue_3_: Option<f32>,
    pub m_Description: Option<String>,
    pub m_Flags: Option<u32>,
    pub m_Name: Option<String>,
    pub m_Type: Option<i32>,
}

impl_object!(SerializedProperty);

impl Clone for SerializedProperty {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Attributes: self.m_Attributes.clone(),
            m_DefTexture: self.m_DefTexture.clone(),
            m_DefValue_0_: self.m_DefValue_0_.clone(),
            m_DefValue_1_: self.m_DefValue_1_.clone(),
            m_DefValue_2_: self.m_DefValue_2_.clone(),
            m_DefValue_3_: self.m_DefValue_3_.clone(),
            m_Description: self.m_Description.clone(),
            m_Flags: self.m_Flags.clone(),
            m_Name: self.m_Name.clone(),
            m_Type: self.m_Type.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedShader {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CustomEditorForRenderPipelines: Option<Vec<SerializedCustomEditorForRenderPipeline>>,
    pub m_CustomEditorName: Option<String>,
    pub m_Dependencies: Option<Vec<SerializedShaderDependency>>,
    pub m_DisableNoSubshadersMessage: Option<bool>,
    pub m_FallbackName: Option<String>,
    pub m_KeywordFlags: Option<Vec<u8>>,
    pub m_KeywordNames: Option<Vec<String>>,
    pub m_Name: Option<String>,
    pub m_PropInfo: Option<SerializedProperties>,
    pub m_SubShaders: Option<Vec<SerializedSubShader>>,
}

impl_object!(SerializedShader);

impl Clone for SerializedShader {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CustomEditorForRenderPipelines: self.m_CustomEditorForRenderPipelines.clone(),
            m_CustomEditorName: self.m_CustomEditorName.clone(),
            m_Dependencies: self.m_Dependencies.clone(),
            m_DisableNoSubshadersMessage: self.m_DisableNoSubshadersMessage.clone(),
            m_FallbackName: self.m_FallbackName.clone(),
            m_KeywordFlags: self.m_KeywordFlags.clone(),
            m_KeywordNames: self.m_KeywordNames.clone(),
            m_Name: self.m_Name.clone(),
            m_PropInfo: self.m_PropInfo.clone(),
            m_SubShaders: self.m_SubShaders.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedShaderDependency {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub from: Option<String>,
    pub to: Option<String>,
}

impl_object!(SerializedShaderDependency);

impl Clone for SerializedShaderDependency {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            from: self.from.clone(),
            to: self.to.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedShaderFloatValue {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub name: Option<FastPropertyName>,
    pub val: Option<f32>,
}

impl_object!(SerializedShaderFloatValue);

impl Clone for SerializedShaderFloatValue {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            name: self.name.clone(),
            val: self.val.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedShaderRTBlendState {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub blendOp: Option<SerializedShaderFloatValue>,
    pub blendOpAlpha: Option<SerializedShaderFloatValue>,
    pub colMask: Option<SerializedShaderFloatValue>,
    pub destBlend: Option<SerializedShaderFloatValue>,
    pub destBlendAlpha: Option<SerializedShaderFloatValue>,
    pub srcBlend: Option<SerializedShaderFloatValue>,
    pub srcBlendAlpha: Option<SerializedShaderFloatValue>,
}

impl_object!(SerializedShaderRTBlendState);

impl Clone for SerializedShaderRTBlendState {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            blendOp: self.blendOp.clone(),
            blendOpAlpha: self.blendOpAlpha.clone(),
            colMask: self.colMask.clone(),
            destBlend: self.destBlend.clone(),
            destBlendAlpha: self.destBlendAlpha.clone(),
            srcBlend: self.srcBlend.clone(),
            srcBlendAlpha: self.srcBlendAlpha.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedShaderState {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub alphaToMask: Option<SerializedShaderFloatValue>,
    pub conservative: Option<SerializedShaderFloatValue>,
    pub culling: Option<SerializedShaderFloatValue>,
    pub fogColor: Option<SerializedShaderVectorValue>,
    pub fogDensity: Option<SerializedShaderFloatValue>,
    pub fogEnd: Option<SerializedShaderFloatValue>,
    pub fogMode: Option<i32>,
    pub fogStart: Option<SerializedShaderFloatValue>,
    pub gpuProgramID: Option<i32>,
    pub lighting: Option<bool>,
    pub m_LOD: Option<i32>,
    pub m_Name: Option<String>,
    pub m_Tags: Option<SerializedTagMap>,
    pub offsetFactor: Option<SerializedShaderFloatValue>,
    pub offsetUnits: Option<SerializedShaderFloatValue>,
    pub rtBlend0: Option<SerializedShaderRTBlendState>,
    pub rtBlend1: Option<SerializedShaderRTBlendState>,
    pub rtBlend2: Option<SerializedShaderRTBlendState>,
    pub rtBlend3: Option<SerializedShaderRTBlendState>,
    pub rtBlend4: Option<SerializedShaderRTBlendState>,
    pub rtBlend5: Option<SerializedShaderRTBlendState>,
    pub rtBlend6: Option<SerializedShaderRTBlendState>,
    pub rtBlend7: Option<SerializedShaderRTBlendState>,
    pub rtSeparateBlend: Option<bool>,
    pub stencilOp: Option<SerializedStencilOp>,
    pub stencilOpBack: Option<SerializedStencilOp>,
    pub stencilOpFront: Option<SerializedStencilOp>,
    pub stencilReadMask: Option<SerializedShaderFloatValue>,
    pub stencilRef: Option<SerializedShaderFloatValue>,
    pub stencilWriteMask: Option<SerializedShaderFloatValue>,
    pub zClip: Option<SerializedShaderFloatValue>,
    pub zTest: Option<SerializedShaderFloatValue>,
    pub zWrite: Option<SerializedShaderFloatValue>,
}

impl_object!(SerializedShaderState);

impl Clone for SerializedShaderState {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            alphaToMask: self.alphaToMask.clone(),
            conservative: self.conservative.clone(),
            culling: self.culling.clone(),
            fogColor: self.fogColor.clone(),
            fogDensity: self.fogDensity.clone(),
            fogEnd: self.fogEnd.clone(),
            fogMode: self.fogMode.clone(),
            fogStart: self.fogStart.clone(),
            gpuProgramID: self.gpuProgramID.clone(),
            lighting: self.lighting.clone(),
            m_LOD: self.m_LOD.clone(),
            m_Name: self.m_Name.clone(),
            m_Tags: self.m_Tags.clone(),
            offsetFactor: self.offsetFactor.clone(),
            offsetUnits: self.offsetUnits.clone(),
            rtBlend0: self.rtBlend0.clone(),
            rtBlend1: self.rtBlend1.clone(),
            rtBlend2: self.rtBlend2.clone(),
            rtBlend3: self.rtBlend3.clone(),
            rtBlend4: self.rtBlend4.clone(),
            rtBlend5: self.rtBlend5.clone(),
            rtBlend6: self.rtBlend6.clone(),
            rtBlend7: self.rtBlend7.clone(),
            rtSeparateBlend: self.rtSeparateBlend.clone(),
            stencilOp: self.stencilOp.clone(),
            stencilOpBack: self.stencilOpBack.clone(),
            stencilOpFront: self.stencilOpFront.clone(),
            stencilReadMask: self.stencilReadMask.clone(),
            stencilRef: self.stencilRef.clone(),
            stencilWriteMask: self.stencilWriteMask.clone(),
            zClip: self.zClip.clone(),
            zTest: self.zTest.clone(),
            zWrite: self.zWrite.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedShaderVectorValue {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub name: Option<FastPropertyName>,
    pub w: Option<SerializedShaderFloatValue>,
    pub x: Option<SerializedShaderFloatValue>,
    pub y: Option<SerializedShaderFloatValue>,
    pub z: Option<SerializedShaderFloatValue>,
}

impl_object!(SerializedShaderVectorValue);

impl Clone for SerializedShaderVectorValue {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            name: self.name.clone(),
            w: self.w.clone(),
            x: self.x.clone(),
            y: self.y.clone(),
            z: self.z.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedStencilOp {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub comp: Option<SerializedShaderFloatValue>,
    pub fail: Option<SerializedShaderFloatValue>,
    pub pass: Option<SerializedShaderFloatValue>,
    pub zFail: Option<SerializedShaderFloatValue>,
}

impl_object!(SerializedStencilOp);

impl Clone for SerializedStencilOp {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            comp: self.comp.clone(),
            fail: self.fail.clone(),
            pass: self.pass.clone(),
            zFail: self.zFail.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedSubProgram {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BlobIndex: Option<u32>,
    pub m_BufferParams: Option<Vec<BufferBinding>>,
    pub m_Channels: Option<ParserBindChannels>,
    pub m_ConstantBufferBindings: Option<Vec<BufferBinding>>,
    pub m_ConstantBuffers: Option<Vec<ConstantBuffer>>,
    pub m_GlobalKeywordIndices: Option<Vec<u16>>,
    pub m_GpuProgramType: Option<i8>,
    pub m_KeywordIndices: Option<Vec<u16>>,
    pub m_LocalKeywordIndices: Option<Vec<u16>>,
    pub m_MatrixParams: Option<Vec<MatrixParameter>>,
    pub m_Parameters: Option<SerializedProgramParameters>,
    pub m_Samplers: Option<Vec<SamplerParameter>>,
    pub m_ShaderHardwareTier: Option<i8>,
    pub m_ShaderRequirements: Option<i32>,
    pub m_TextureParams: Option<Vec<TextureParameter>>,
    pub m_UAVParams: Option<Vec<UAVParameter>>,
    pub m_VectorParams: Option<Vec<VectorParameter>>,
}

impl_object!(SerializedSubProgram);

impl Clone for SerializedSubProgram {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BlobIndex: self.m_BlobIndex.clone(),
            m_BufferParams: self.m_BufferParams.clone(),
            m_Channels: self.m_Channels.clone(),
            m_ConstantBufferBindings: self.m_ConstantBufferBindings.clone(),
            m_ConstantBuffers: self.m_ConstantBuffers.clone(),
            m_GlobalKeywordIndices: self.m_GlobalKeywordIndices.clone(),
            m_GpuProgramType: self.m_GpuProgramType.clone(),
            m_KeywordIndices: self.m_KeywordIndices.clone(),
            m_LocalKeywordIndices: self.m_LocalKeywordIndices.clone(),
            m_MatrixParams: self.m_MatrixParams.clone(),
            m_Parameters: self.m_Parameters.clone(),
            m_Samplers: self.m_Samplers.clone(),
            m_ShaderHardwareTier: self.m_ShaderHardwareTier.clone(),
            m_ShaderRequirements: self.m_ShaderRequirements.clone(),
            m_TextureParams: self.m_TextureParams.clone(),
            m_UAVParams: self.m_UAVParams.clone(),
            m_VectorParams: self.m_VectorParams.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedSubShader {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_LOD: Option<i32>,
    pub m_Passes: Option<Vec<SerializedPass>>,
    pub m_Tags: Option<SerializedTagMap>,
}

impl_object!(SerializedSubShader);

impl Clone for SerializedSubShader {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_LOD: self.m_LOD.clone(),
            m_Passes: self.m_Passes.clone(),
            m_Tags: self.m_Tags.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedTagMap {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub tags: Option<Vec<(String, String)>>,
}

impl_object!(SerializedTagMap);

impl Clone for SerializedTagMap {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            tags: self.tags.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SerializedTextureProperty {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_DefaultName: Option<String>,
    pub m_TexDim: Option<i32>,
}

impl_object!(SerializedTextureProperty);

impl Clone for SerializedTextureProperty {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_DefaultName: self.m_DefaultName.clone(),
            m_TexDim: self.m_TexDim.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ShaderBindChannel {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub source: Option<i8>,
    pub target: Option<i8>,
}

impl_object!(ShaderBindChannel);

impl Clone for ShaderBindChannel {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            source: self.source.clone(),
            target: self.target.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ShaderInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub variants: Option<Vec<VariantInfo>>,
}

impl_object!(ShaderInfo);

impl Clone for ShaderInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            variants: self.variants.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ShadowSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Bias: Option<f32>,
    pub m_CullingMatrixOverride: Option<Matrix4x4>,
    pub m_CustomResolution: Option<i32>,
    pub m_NearPlane: Option<f32>,
    pub m_NormalBias: Option<f32>,
    pub m_Resolution: Option<i32>,
    pub m_Softness: Option<f32>,
    pub m_SoftnessFade: Option<f32>,
    pub m_Strength: Option<f32>,
    pub m_Type: Option<i32>,
    pub m_UseCullingMatrixOverride: Option<bool>,
}

impl_object!(ShadowSettings);

impl Clone for ShadowSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Bias: self.m_Bias.clone(),
            m_CullingMatrixOverride: self.m_CullingMatrixOverride.clone(),
            m_CustomResolution: self.m_CustomResolution.clone(),
            m_NearPlane: self.m_NearPlane.clone(),
            m_NormalBias: self.m_NormalBias.clone(),
            m_Resolution: self.m_Resolution.clone(),
            m_Softness: self.m_Softness.clone(),
            m_SoftnessFade: self.m_SoftnessFade.clone(),
            m_Strength: self.m_Strength.clone(),
            m_Type: self.m_Type.clone(),
            m_UseCullingMatrixOverride: self.m_UseCullingMatrixOverride.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ShapeModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub alignToDirection: Option<bool>,
    pub angle: Option<f32>,
    pub arc: Option<MultiModeParameter>,
    pub boxThickness: Option<Vector3>,
    pub boxX: Option<f32>,
    pub boxY: Option<f32>,
    pub boxZ: Option<f32>,
    pub donutRadius: Option<f32>,
    pub enabled: Option<bool>,
    pub length: Option<f32>,
    pub m_Mesh: Option<PPtrData<Mesh>>,
    pub m_MeshMaterialIndex: Option<i32>,
    pub m_MeshNormalOffset: Option<f32>,
    pub m_MeshRenderer: Option<PPtrData<MeshRenderer>>,
    pub m_MeshScale: Option<f32>,
    pub m_MeshSpawn: Option<MultiModeParameter>,
    pub m_Position: Option<Vector3>,
    pub m_Rotation: Option<Vector3>,
    pub m_Scale: Option<Vector3>,
    pub m_SkinnedMeshRenderer: Option<PPtrData<SkinnedMeshRenderer>>,
    pub m_Sprite: Option<PPtrData<Sprite>>,
    pub m_SpriteRenderer: Option<PPtrData<SpriteRenderer>>,
    pub m_Texture: Option<PPtrData<Texture2D>>,
    pub m_TextureAlphaAffectsParticles: Option<bool>,
    pub m_TextureBilinearFiltering: Option<bool>,
    pub m_TextureClipChannel: Option<i32>,
    pub m_TextureClipThreshold: Option<f32>,
    pub m_TextureColorAffectsParticles: Option<bool>,
    pub m_TextureUVChannel: Option<i32>,
    pub m_UseMeshColors: Option<bool>,
    pub m_UseMeshMaterialIndex: Option<bool>,
    pub placementMode: Option<i32>,
    pub radius: Option<MultiModeParameter>,
    pub radiusThickness: Option<f32>,
    pub randomDirection: Option<bool>,
    pub randomDirectionAmount: Option<f32>,
    pub randomPositionAmount: Option<f32>,
    pub sphericalDirectionAmount: Option<f32>,
    pub typ: Option<i32>,
}

impl_object!(ShapeModule);

impl Clone for ShapeModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            alignToDirection: self.alignToDirection.clone(),
            angle: self.angle.clone(),
            arc: self.arc.clone(),
            boxThickness: self.boxThickness.clone(),
            boxX: self.boxX.clone(),
            boxY: self.boxY.clone(),
            boxZ: self.boxZ.clone(),
            donutRadius: self.donutRadius.clone(),
            enabled: self.enabled.clone(),
            length: self.length.clone(),
            m_Mesh: self.m_Mesh.clone(),
            m_MeshMaterialIndex: self.m_MeshMaterialIndex.clone(),
            m_MeshNormalOffset: self.m_MeshNormalOffset.clone(),
            m_MeshRenderer: self.m_MeshRenderer.clone(),
            m_MeshScale: self.m_MeshScale.clone(),
            m_MeshSpawn: self.m_MeshSpawn.clone(),
            m_Position: self.m_Position.clone(),
            m_Rotation: self.m_Rotation.clone(),
            m_Scale: self.m_Scale.clone(),
            m_SkinnedMeshRenderer: self.m_SkinnedMeshRenderer.clone(),
            m_Sprite: self.m_Sprite.clone(),
            m_SpriteRenderer: self.m_SpriteRenderer.clone(),
            m_Texture: self.m_Texture.clone(),
            m_TextureAlphaAffectsParticles: self.m_TextureAlphaAffectsParticles.clone(),
            m_TextureBilinearFiltering: self.m_TextureBilinearFiltering.clone(),
            m_TextureClipChannel: self.m_TextureClipChannel.clone(),
            m_TextureClipThreshold: self.m_TextureClipThreshold.clone(),
            m_TextureColorAffectsParticles: self.m_TextureColorAffectsParticles.clone(),
            m_TextureUVChannel: self.m_TextureUVChannel.clone(),
            m_UseMeshColors: self.m_UseMeshColors.clone(),
            m_UseMeshMaterialIndex: self.m_UseMeshMaterialIndex.clone(),
            placementMode: self.placementMode.clone(),
            radius: self.radius.clone(),
            radiusThickness: self.radiusThickness.clone(),
            randomDirection: self.randomDirection.clone(),
            randomDirectionAmount: self.randomDirectionAmount.clone(),
            randomPositionAmount: self.randomPositionAmount.clone(),
            sphericalDirectionAmount: self.sphericalDirectionAmount.clone(),
            typ: self.typ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SizeBySpeedModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub curve: Option<MinMaxCurve>,
    pub enabled: Option<bool>,
    pub range: Option<Vector2>,
    pub separateAxes: Option<bool>,
    pub y: Option<MinMaxCurve>,
    pub z: Option<MinMaxCurve>,
}

impl_object!(SizeBySpeedModule);

impl Clone for SizeBySpeedModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            curve: self.curve.clone(),
            enabled: self.enabled.clone(),
            range: self.range.clone(),
            separateAxes: self.separateAxes.clone(),
            y: self.y.clone(),
            z: self.z.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SizeModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub curve: Option<MinMaxCurve>,
    pub enabled: Option<bool>,
    pub separateAxes: Option<bool>,
    pub y: Option<MinMaxCurve>,
    pub z: Option<MinMaxCurve>,
}

impl_object!(SizeModule);

impl Clone for SizeModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            curve: self.curve.clone(),
            enabled: self.enabled.clone(),
            separateAxes: self.separateAxes.clone(),
            y: self.y.clone(),
            z: self.z.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Skeleton {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AxesArray: Option<Vec<Axes>>,
    pub m_ID: Option<Vec<u32>>,
    pub m_Node: Option<Vec<Node>>,
}

impl_object!(Skeleton);

impl Clone for Skeleton {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AxesArray: self.m_AxesArray.clone(),
            m_ID: self.m_ID.clone(),
            m_Node: self.m_Node.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SkeletonBone {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
    pub m_ParentName: Option<String>,
    pub m_Position: Option<Vector3>,
    pub m_Rotation: Option<Quaternion>,
    pub m_Scale: Option<Vector3>,
    pub m_TransformModified: Option<bool>,
}

impl_object!(SkeletonBone);

impl Clone for SkeletonBone {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
            m_ParentName: self.m_ParentName.clone(),
            m_Position: self.m_Position.clone(),
            m_Rotation: self.m_Rotation.clone(),
            m_Scale: self.m_Scale.clone(),
            m_TransformModified: self.m_TransformModified.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SkeletonBoneLimit {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Length: Option<f32>,
    pub m_Max: Option<Vector3>,
    pub m_Min: Option<Vector3>,
    pub m_Modified: Option<bool>,
    pub m_PostQ: Option<Quaternion>,
    pub m_PreQ: Option<Quaternion>,
    pub m_Value: Option<Vector3>,
}

impl_object!(SkeletonBoneLimit);

impl Clone for SkeletonBoneLimit {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Length: self.m_Length.clone(),
            m_Max: self.m_Max.clone(),
            m_Min: self.m_Min.clone(),
            m_Modified: self.m_Modified.clone(),
            m_PostQ: self.m_PostQ.clone(),
            m_PreQ: self.m_PreQ.clone(),
            m_Value: self.m_Value.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SkeletonMask {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Data: Option<Vec<SkeletonMaskElement>>,
}

impl_object!(SkeletonMask);

impl Clone for SkeletonMask {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Data: self.m_Data.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SkeletonMaskElement {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Index: Option<u32>,
    pub m_PathHash: Option<u32>,
    pub m_Weight: Option<f32>,
}

impl_object!(SkeletonMaskElement);

impl Clone for SkeletonMaskElement {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Index: self.m_Index.clone(),
            m_PathHash: self.m_PathHash.clone(),
            m_Weight: self.m_Weight.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SkeletonPose {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_X: Option<Vec<xform>>,
}

impl_object!(SkeletonPose);

impl Clone for SkeletonPose {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_X: self.m_X.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SketchUpImportCamera {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub aspectRatio: Option<f32>,
    pub farPlane: Option<f32>,
    pub fov: Option<f32>,
    pub isPerspective: Option<i32>,
    pub lookAt: Option<Vector3>,
    pub nearPlane: Option<f32>,
    pub orthoSize: Option<f32>,
    pub position: Option<Vector3>,
    pub up: Option<Vector3>,
}

impl_object!(SketchUpImportCamera);

impl Clone for SketchUpImportCamera {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            aspectRatio: self.aspectRatio.clone(),
            farPlane: self.farPlane.clone(),
            fov: self.fov.clone(),
            isPerspective: self.isPerspective.clone(),
            lookAt: self.lookAt.clone(),
            nearPlane: self.nearPlane.clone(),
            orthoSize: self.orthoSize.clone(),
            position: self.position.clone(),
            up: self.up.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SketchUpImportData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub defaultCamera: Option<SketchUpImportCamera>,
    pub scenes: Option<Vec<SketchUpImportScene>>,
}

impl_object!(SketchUpImportData);

impl Clone for SketchUpImportData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            defaultCamera: self.defaultCamera.clone(),
            scenes: self.scenes.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SketchUpImportScene {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub camera: Option<SketchUpImportCamera>,
    pub name: Option<String>,
}

impl_object!(SketchUpImportScene);

impl Clone for SketchUpImportScene {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            camera: self.camera.clone(),
            name: self.name.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SnapshotConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub nameHash: Option<u32>,
    pub transitionIndices: Option<Vec<u32>>,
    pub transitionTypes: Option<Vec<u32>>,
    pub values: Option<Vec<f32>>,
}

impl_object!(SnapshotConstant);

impl Clone for SnapshotConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            nameHash: self.nameHash.clone(),
            transitionIndices: self.transitionIndices.clone(),
            transitionTypes: self.transitionTypes.clone(),
            values: self.values.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SoftJointLimit {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bounciness: Option<f32>,
    pub contactDistance: Option<f32>,
    pub damper: Option<f32>,
    pub limit: Option<f32>,
    pub spring: Option<f32>,
}

impl_object!(SoftJointLimit);

impl Clone for SoftJointLimit {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bounciness: self.bounciness.clone(),
            contactDistance: self.contactDistance.clone(),
            damper: self.damper.clone(),
            limit: self.limit.clone(),
            spring: self.spring.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SoftJointLimitSpring {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub damper: Option<f32>,
    pub spring: Option<f32>,
}

impl_object!(SoftJointLimitSpring);

impl Clone for SoftJointLimitSpring {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            damper: self.damper.clone(),
            spring: self.spring.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SortingLayerEntry {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub name: Option<String>,
    pub uniqueID: Option<u32>,
    pub userID: Option<u32>,
}

impl_object!(SortingLayerEntry);

impl Clone for SortingLayerEntry {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            name: self.name.clone(),
            uniqueID: self.uniqueID.clone(),
            userID: self.userID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SourceAssetIdentifier {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub assembly: Option<String>,
    pub name: Option<String>,
    pub typ: Option<String>,
}

impl_object!(SourceAssetIdentifier);

impl Clone for SourceAssetIdentifier {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            assembly: self.assembly.clone(),
            name: self.name.clone(),
            typ: self.typ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SourceTextureInformation {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub doesTextureContainAlpha: Option<bool>,
    pub doesTextureContainColor: Option<bool>,
    pub height: Option<i32>,
    pub sourceWasHDR: Option<bool>,
    pub width: Option<i32>,
}

impl_object!(SourceTextureInformation);

impl Clone for SourceTextureInformation {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            doesTextureContainAlpha: self.doesTextureContainAlpha.clone(),
            doesTextureContainColor: self.doesTextureContainColor.clone(),
            height: self.height.clone(),
            sourceWasHDR: self.sourceWasHDR.clone(),
            width: self.width.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpeedTreeWind {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub BRANCH_DIRECTIONAL_1: Option<bool>,
    pub BRANCH_DIRECTIONAL_2: Option<bool>,
    pub BRANCH_DIRECTIONAL_FROND_1: Option<bool>,
    pub BRANCH_DIRECTIONAL_FROND_2: Option<bool>,
    pub BRANCH_OSC_COMPLEX_1: Option<bool>,
    pub BRANCH_OSC_COMPLEX_2: Option<bool>,
    pub BRANCH_SIMPLE_1: Option<bool>,
    pub BRANCH_SIMPLE_2: Option<bool>,
    pub BRANCH_TURBULENCE_1: Option<bool>,
    pub BRANCH_TURBULENCE_2: Option<bool>,
    pub BRANCH_WHIP_1: Option<bool>,
    pub BRANCH_WHIP_2: Option<bool>,
    pub BranchWindAnchor0: Option<f32>,
    pub BranchWindAnchor1: Option<f32>,
    pub BranchWindAnchor2: Option<f32>,
    pub FROND_RIPPLE_ADJUST_LIGHTING: Option<bool>,
    pub FROND_RIPPLE_ONE_SIDED: Option<bool>,
    pub FROND_RIPPLE_TWO_SIDED: Option<bool>,
    pub GLOBAL_PRESERVE_SHAPE: Option<bool>,
    pub GLOBAL_WIND: Option<bool>,
    pub LEAF_OCCLUSION_1: Option<bool>,
    pub LEAF_OCCLUSION_2: Option<bool>,
    pub LEAF_RIPPLE_COMPUTED_1: Option<bool>,
    pub LEAF_RIPPLE_COMPUTED_2: Option<bool>,
    pub LEAF_RIPPLE_VERTEX_NORMAL_1: Option<bool>,
    pub LEAF_RIPPLE_VERTEX_NORMAL_2: Option<bool>,
    pub LEAF_TUMBLE_1: Option<bool>,
    pub LEAF_TUMBLE_2: Option<bool>,
    pub LEAF_TWITCH_1: Option<bool>,
    pub LEAF_TWITCH_2: Option<bool>,
    pub ROLLING: Option<bool>,
    pub m_fMaxBranchLevel1Length: Option<f32>,
    pub m_sParams: Option<SParams>,
}

impl_object!(SpeedTreeWind);

impl Clone for SpeedTreeWind {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            BRANCH_DIRECTIONAL_1: self.BRANCH_DIRECTIONAL_1.clone(),
            BRANCH_DIRECTIONAL_2: self.BRANCH_DIRECTIONAL_2.clone(),
            BRANCH_DIRECTIONAL_FROND_1: self.BRANCH_DIRECTIONAL_FROND_1.clone(),
            BRANCH_DIRECTIONAL_FROND_2: self.BRANCH_DIRECTIONAL_FROND_2.clone(),
            BRANCH_OSC_COMPLEX_1: self.BRANCH_OSC_COMPLEX_1.clone(),
            BRANCH_OSC_COMPLEX_2: self.BRANCH_OSC_COMPLEX_2.clone(),
            BRANCH_SIMPLE_1: self.BRANCH_SIMPLE_1.clone(),
            BRANCH_SIMPLE_2: self.BRANCH_SIMPLE_2.clone(),
            BRANCH_TURBULENCE_1: self.BRANCH_TURBULENCE_1.clone(),
            BRANCH_TURBULENCE_2: self.BRANCH_TURBULENCE_2.clone(),
            BRANCH_WHIP_1: self.BRANCH_WHIP_1.clone(),
            BRANCH_WHIP_2: self.BRANCH_WHIP_2.clone(),
            BranchWindAnchor0: self.BranchWindAnchor0.clone(),
            BranchWindAnchor1: self.BranchWindAnchor1.clone(),
            BranchWindAnchor2: self.BranchWindAnchor2.clone(),
            FROND_RIPPLE_ADJUST_LIGHTING: self.FROND_RIPPLE_ADJUST_LIGHTING.clone(),
            FROND_RIPPLE_ONE_SIDED: self.FROND_RIPPLE_ONE_SIDED.clone(),
            FROND_RIPPLE_TWO_SIDED: self.FROND_RIPPLE_TWO_SIDED.clone(),
            GLOBAL_PRESERVE_SHAPE: self.GLOBAL_PRESERVE_SHAPE.clone(),
            GLOBAL_WIND: self.GLOBAL_WIND.clone(),
            LEAF_OCCLUSION_1: self.LEAF_OCCLUSION_1.clone(),
            LEAF_OCCLUSION_2: self.LEAF_OCCLUSION_2.clone(),
            LEAF_RIPPLE_COMPUTED_1: self.LEAF_RIPPLE_COMPUTED_1.clone(),
            LEAF_RIPPLE_COMPUTED_2: self.LEAF_RIPPLE_COMPUTED_2.clone(),
            LEAF_RIPPLE_VERTEX_NORMAL_1: self.LEAF_RIPPLE_VERTEX_NORMAL_1.clone(),
            LEAF_RIPPLE_VERTEX_NORMAL_2: self.LEAF_RIPPLE_VERTEX_NORMAL_2.clone(),
            LEAF_TUMBLE_1: self.LEAF_TUMBLE_1.clone(),
            LEAF_TUMBLE_2: self.LEAF_TUMBLE_2.clone(),
            LEAF_TWITCH_1: self.LEAF_TWITCH_1.clone(),
            LEAF_TWITCH_2: self.LEAF_TWITCH_2.clone(),
            ROLLING: self.ROLLING.clone(),
            m_fMaxBranchLevel1Length: self.m_fMaxBranchLevel1Length.clone(),
            m_sParams: self.m_sParams.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpeedTreeWindConfig8 {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub BRANCH_DIRECTIONAL_1: Option<bool>,
    pub BRANCH_DIRECTIONAL_2: Option<bool>,
    pub BRANCH_DIRECTIONAL_FROND_1: Option<bool>,
    pub BRANCH_DIRECTIONAL_FROND_2: Option<bool>,
    pub BRANCH_OSC_COMPLEX_1: Option<bool>,
    pub BRANCH_OSC_COMPLEX_2: Option<bool>,
    pub BRANCH_SIMPLE_1: Option<bool>,
    pub BRANCH_SIMPLE_2: Option<bool>,
    pub BRANCH_TURBULENCE_1: Option<bool>,
    pub BRANCH_TURBULENCE_2: Option<bool>,
    pub BRANCH_WHIP_1: Option<bool>,
    pub BRANCH_WHIP_2: Option<bool>,
    pub BranchLevel1: Option<SBranchWindLevel>,
    pub BranchLevel2: Option<SBranchWindLevel>,
    pub BranchWindAnchor0: Option<f32>,
    pub BranchWindAnchor1: Option<f32>,
    pub BranchWindAnchor2: Option<f32>,
    pub FROND_RIPPLE_ADJUST_LIGHTING: Option<bool>,
    pub FROND_RIPPLE_ONE_SIDED: Option<bool>,
    pub FROND_RIPPLE_TWO_SIDED: Option<bool>,
    pub GLOBAL_PRESERVE_SHAPE: Option<bool>,
    pub GLOBAL_WIND: Option<bool>,
    pub LEAF_OCCLUSION_1: Option<bool>,
    pub LEAF_OCCLUSION_2: Option<bool>,
    pub LEAF_RIPPLE_COMPUTED_1: Option<bool>,
    pub LEAF_RIPPLE_COMPUTED_2: Option<bool>,
    pub LEAF_RIPPLE_VERTEX_NORMAL_1: Option<bool>,
    pub LEAF_RIPPLE_VERTEX_NORMAL_2: Option<bool>,
    pub LEAF_TUMBLE_1: Option<bool>,
    pub LEAF_TUMBLE_2: Option<bool>,
    pub LEAF_TWITCH_1: Option<bool>,
    pub LEAF_TWITCH_2: Option<bool>,
    pub LeafGroup1: Option<SWindGroup>,
    pub LeafGroup2: Option<SWindGroup>,
    pub Oscillation0_0: Option<f32>,
    pub Oscillation0_1: Option<f32>,
    pub Oscillation0_2: Option<f32>,
    pub Oscillation0_3: Option<f32>,
    pub Oscillation0_4: Option<f32>,
    pub Oscillation0_5: Option<f32>,
    pub Oscillation0_6: Option<f32>,
    pub Oscillation0_7: Option<f32>,
    pub Oscillation0_8: Option<f32>,
    pub Oscillation0_9: Option<f32>,
    pub Oscillation1_0: Option<f32>,
    pub Oscillation1_1: Option<f32>,
    pub Oscillation1_2: Option<f32>,
    pub Oscillation1_3: Option<f32>,
    pub Oscillation1_4: Option<f32>,
    pub Oscillation1_5: Option<f32>,
    pub Oscillation1_6: Option<f32>,
    pub Oscillation1_7: Option<f32>,
    pub Oscillation1_8: Option<f32>,
    pub Oscillation1_9: Option<f32>,
    pub Oscillation2_0: Option<f32>,
    pub Oscillation2_1: Option<f32>,
    pub Oscillation2_2: Option<f32>,
    pub Oscillation2_3: Option<f32>,
    pub Oscillation2_4: Option<f32>,
    pub Oscillation2_5: Option<f32>,
    pub Oscillation2_6: Option<f32>,
    pub Oscillation2_7: Option<f32>,
    pub Oscillation2_8: Option<f32>,
    pub Oscillation2_9: Option<f32>,
    pub Oscillation3_0: Option<f32>,
    pub Oscillation3_1: Option<f32>,
    pub Oscillation3_2: Option<f32>,
    pub Oscillation3_3: Option<f32>,
    pub Oscillation3_4: Option<f32>,
    pub Oscillation3_5: Option<f32>,
    pub Oscillation3_6: Option<f32>,
    pub Oscillation3_7: Option<f32>,
    pub Oscillation3_8: Option<f32>,
    pub Oscillation3_9: Option<f32>,
    pub Oscillation4_0: Option<f32>,
    pub Oscillation4_1: Option<f32>,
    pub Oscillation4_2: Option<f32>,
    pub Oscillation4_3: Option<f32>,
    pub Oscillation4_4: Option<f32>,
    pub Oscillation4_5: Option<f32>,
    pub Oscillation4_6: Option<f32>,
    pub Oscillation4_7: Option<f32>,
    pub Oscillation4_8: Option<f32>,
    pub Oscillation4_9: Option<f32>,
    pub Oscillation5_0: Option<f32>,
    pub Oscillation5_1: Option<f32>,
    pub Oscillation5_2: Option<f32>,
    pub Oscillation5_3: Option<f32>,
    pub Oscillation5_4: Option<f32>,
    pub Oscillation5_5: Option<f32>,
    pub Oscillation5_6: Option<f32>,
    pub Oscillation5_7: Option<f32>,
    pub Oscillation5_8: Option<f32>,
    pub Oscillation5_9: Option<f32>,
    pub Oscillation6_0: Option<f32>,
    pub Oscillation6_1: Option<f32>,
    pub Oscillation6_2: Option<f32>,
    pub Oscillation6_3: Option<f32>,
    pub Oscillation6_4: Option<f32>,
    pub Oscillation6_5: Option<f32>,
    pub Oscillation6_6: Option<f32>,
    pub Oscillation6_7: Option<f32>,
    pub Oscillation6_8: Option<f32>,
    pub Oscillation6_9: Option<f32>,
    pub Oscillation7_0: Option<f32>,
    pub Oscillation7_1: Option<f32>,
    pub Oscillation7_2: Option<f32>,
    pub Oscillation7_3: Option<f32>,
    pub Oscillation7_4: Option<f32>,
    pub Oscillation7_5: Option<f32>,
    pub Oscillation7_6: Option<f32>,
    pub Oscillation7_7: Option<f32>,
    pub Oscillation7_8: Option<f32>,
    pub Oscillation7_9: Option<f32>,
    pub Oscillation8_0: Option<f32>,
    pub Oscillation8_1: Option<f32>,
    pub Oscillation8_2: Option<f32>,
    pub Oscillation8_3: Option<f32>,
    pub Oscillation8_4: Option<f32>,
    pub Oscillation8_5: Option<f32>,
    pub Oscillation8_6: Option<f32>,
    pub Oscillation8_7: Option<f32>,
    pub Oscillation8_8: Option<f32>,
    pub Oscillation8_9: Option<f32>,
    pub Oscillation9_0: Option<f32>,
    pub Oscillation9_1: Option<f32>,
    pub Oscillation9_2: Option<f32>,
    pub Oscillation9_3: Option<f32>,
    pub Oscillation9_4: Option<f32>,
    pub Oscillation9_5: Option<f32>,
    pub Oscillation9_6: Option<f32>,
    pub Oscillation9_7: Option<f32>,
    pub Oscillation9_8: Option<f32>,
    pub Oscillation9_9: Option<f32>,
    pub ROLLING: Option<bool>,
    pub m_afFrondRippleDistance_0: Option<f32>,
    pub m_afFrondRippleDistance_1: Option<f32>,
    pub m_afFrondRippleDistance_2: Option<f32>,
    pub m_afFrondRippleDistance_3: Option<f32>,
    pub m_afFrondRippleDistance_4: Option<f32>,
    pub m_afFrondRippleDistance_5: Option<f32>,
    pub m_afFrondRippleDistance_6: Option<f32>,
    pub m_afFrondRippleDistance_7: Option<f32>,
    pub m_afFrondRippleDistance_8: Option<f32>,
    pub m_afFrondRippleDistance_9: Option<f32>,
    pub m_afGlobalDirectionAdherence_0: Option<f32>,
    pub m_afGlobalDirectionAdherence_1: Option<f32>,
    pub m_afGlobalDirectionAdherence_2: Option<f32>,
    pub m_afGlobalDirectionAdherence_3: Option<f32>,
    pub m_afGlobalDirectionAdherence_4: Option<f32>,
    pub m_afGlobalDirectionAdherence_5: Option<f32>,
    pub m_afGlobalDirectionAdherence_6: Option<f32>,
    pub m_afGlobalDirectionAdherence_7: Option<f32>,
    pub m_afGlobalDirectionAdherence_8: Option<f32>,
    pub m_afGlobalDirectionAdherence_9: Option<f32>,
    pub m_afGlobalDistance_0: Option<f32>,
    pub m_afGlobalDistance_1: Option<f32>,
    pub m_afGlobalDistance_2: Option<f32>,
    pub m_afGlobalDistance_3: Option<f32>,
    pub m_afGlobalDistance_4: Option<f32>,
    pub m_afGlobalDistance_5: Option<f32>,
    pub m_afGlobalDistance_6: Option<f32>,
    pub m_afGlobalDistance_7: Option<f32>,
    pub m_afGlobalDistance_8: Option<f32>,
    pub m_afGlobalDistance_9: Option<f32>,
    pub m_fAnchorDistanceScale: Option<f32>,
    pub m_fAnchorOffset: Option<f32>,
    pub m_fDirectionResponse: Option<f32>,
    pub m_fFrondRippleLightingScalar: Option<f32>,
    pub m_fFrondRippleTile: Option<f32>,
    pub m_fGlobalHeight: Option<f32>,
    pub m_fGlobalHeightExponent: Option<f32>,
    pub m_fGustDurationMax: Option<f32>,
    pub m_fGustDurationMin: Option<f32>,
    pub m_fGustFallScalar: Option<f32>,
    pub m_fGustFrequency: Option<f32>,
    pub m_fGustRiseScalar: Option<f32>,
    pub m_fGustStrengthMax: Option<f32>,
    pub m_fGustStrengthMin: Option<f32>,
    pub m_fMaxBranchLevel1Length: Option<f32>,
    pub m_fRollingBranchFieldMin: Option<f32>,
    pub m_fRollingBranchLightingAdjust: Option<f32>,
    pub m_fRollingBranchVerticalOffset: Option<f32>,
    pub m_fRollingLeafRippleMin: Option<f32>,
    pub m_fRollingLeafTumbleMin: Option<f32>,
    pub m_fRollingNoisePeriod: Option<f32>,
    pub m_fRollingNoiseSize: Option<f32>,
    pub m_fRollingNoiseSpeed: Option<f32>,
    pub m_fRollingNoiseTurbulence: Option<f32>,
    pub m_fRollingNoiseTwist: Option<f32>,
    pub m_fStrengthResponse: Option<f32>,
}

impl_object!(SpeedTreeWindConfig8);

impl Clone for SpeedTreeWindConfig8 {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            BRANCH_DIRECTIONAL_1: self.BRANCH_DIRECTIONAL_1.clone(),
            BRANCH_DIRECTIONAL_2: self.BRANCH_DIRECTIONAL_2.clone(),
            BRANCH_DIRECTIONAL_FROND_1: self.BRANCH_DIRECTIONAL_FROND_1.clone(),
            BRANCH_DIRECTIONAL_FROND_2: self.BRANCH_DIRECTIONAL_FROND_2.clone(),
            BRANCH_OSC_COMPLEX_1: self.BRANCH_OSC_COMPLEX_1.clone(),
            BRANCH_OSC_COMPLEX_2: self.BRANCH_OSC_COMPLEX_2.clone(),
            BRANCH_SIMPLE_1: self.BRANCH_SIMPLE_1.clone(),
            BRANCH_SIMPLE_2: self.BRANCH_SIMPLE_2.clone(),
            BRANCH_TURBULENCE_1: self.BRANCH_TURBULENCE_1.clone(),
            BRANCH_TURBULENCE_2: self.BRANCH_TURBULENCE_2.clone(),
            BRANCH_WHIP_1: self.BRANCH_WHIP_1.clone(),
            BRANCH_WHIP_2: self.BRANCH_WHIP_2.clone(),
            BranchLevel1: self.BranchLevel1.clone(),
            BranchLevel2: self.BranchLevel2.clone(),
            BranchWindAnchor0: self.BranchWindAnchor0.clone(),
            BranchWindAnchor1: self.BranchWindAnchor1.clone(),
            BranchWindAnchor2: self.BranchWindAnchor2.clone(),
            FROND_RIPPLE_ADJUST_LIGHTING: self.FROND_RIPPLE_ADJUST_LIGHTING.clone(),
            FROND_RIPPLE_ONE_SIDED: self.FROND_RIPPLE_ONE_SIDED.clone(),
            FROND_RIPPLE_TWO_SIDED: self.FROND_RIPPLE_TWO_SIDED.clone(),
            GLOBAL_PRESERVE_SHAPE: self.GLOBAL_PRESERVE_SHAPE.clone(),
            GLOBAL_WIND: self.GLOBAL_WIND.clone(),
            LEAF_OCCLUSION_1: self.LEAF_OCCLUSION_1.clone(),
            LEAF_OCCLUSION_2: self.LEAF_OCCLUSION_2.clone(),
            LEAF_RIPPLE_COMPUTED_1: self.LEAF_RIPPLE_COMPUTED_1.clone(),
            LEAF_RIPPLE_COMPUTED_2: self.LEAF_RIPPLE_COMPUTED_2.clone(),
            LEAF_RIPPLE_VERTEX_NORMAL_1: self.LEAF_RIPPLE_VERTEX_NORMAL_1.clone(),
            LEAF_RIPPLE_VERTEX_NORMAL_2: self.LEAF_RIPPLE_VERTEX_NORMAL_2.clone(),
            LEAF_TUMBLE_1: self.LEAF_TUMBLE_1.clone(),
            LEAF_TUMBLE_2: self.LEAF_TUMBLE_2.clone(),
            LEAF_TWITCH_1: self.LEAF_TWITCH_1.clone(),
            LEAF_TWITCH_2: self.LEAF_TWITCH_2.clone(),
            LeafGroup1: self.LeafGroup1.clone(),
            LeafGroup2: self.LeafGroup2.clone(),
            Oscillation0_0: self.Oscillation0_0.clone(),
            Oscillation0_1: self.Oscillation0_1.clone(),
            Oscillation0_2: self.Oscillation0_2.clone(),
            Oscillation0_3: self.Oscillation0_3.clone(),
            Oscillation0_4: self.Oscillation0_4.clone(),
            Oscillation0_5: self.Oscillation0_5.clone(),
            Oscillation0_6: self.Oscillation0_6.clone(),
            Oscillation0_7: self.Oscillation0_7.clone(),
            Oscillation0_8: self.Oscillation0_8.clone(),
            Oscillation0_9: self.Oscillation0_9.clone(),
            Oscillation1_0: self.Oscillation1_0.clone(),
            Oscillation1_1: self.Oscillation1_1.clone(),
            Oscillation1_2: self.Oscillation1_2.clone(),
            Oscillation1_3: self.Oscillation1_3.clone(),
            Oscillation1_4: self.Oscillation1_4.clone(),
            Oscillation1_5: self.Oscillation1_5.clone(),
            Oscillation1_6: self.Oscillation1_6.clone(),
            Oscillation1_7: self.Oscillation1_7.clone(),
            Oscillation1_8: self.Oscillation1_8.clone(),
            Oscillation1_9: self.Oscillation1_9.clone(),
            Oscillation2_0: self.Oscillation2_0.clone(),
            Oscillation2_1: self.Oscillation2_1.clone(),
            Oscillation2_2: self.Oscillation2_2.clone(),
            Oscillation2_3: self.Oscillation2_3.clone(),
            Oscillation2_4: self.Oscillation2_4.clone(),
            Oscillation2_5: self.Oscillation2_5.clone(),
            Oscillation2_6: self.Oscillation2_6.clone(),
            Oscillation2_7: self.Oscillation2_7.clone(),
            Oscillation2_8: self.Oscillation2_8.clone(),
            Oscillation2_9: self.Oscillation2_9.clone(),
            Oscillation3_0: self.Oscillation3_0.clone(),
            Oscillation3_1: self.Oscillation3_1.clone(),
            Oscillation3_2: self.Oscillation3_2.clone(),
            Oscillation3_3: self.Oscillation3_3.clone(),
            Oscillation3_4: self.Oscillation3_4.clone(),
            Oscillation3_5: self.Oscillation3_5.clone(),
            Oscillation3_6: self.Oscillation3_6.clone(),
            Oscillation3_7: self.Oscillation3_7.clone(),
            Oscillation3_8: self.Oscillation3_8.clone(),
            Oscillation3_9: self.Oscillation3_9.clone(),
            Oscillation4_0: self.Oscillation4_0.clone(),
            Oscillation4_1: self.Oscillation4_1.clone(),
            Oscillation4_2: self.Oscillation4_2.clone(),
            Oscillation4_3: self.Oscillation4_3.clone(),
            Oscillation4_4: self.Oscillation4_4.clone(),
            Oscillation4_5: self.Oscillation4_5.clone(),
            Oscillation4_6: self.Oscillation4_6.clone(),
            Oscillation4_7: self.Oscillation4_7.clone(),
            Oscillation4_8: self.Oscillation4_8.clone(),
            Oscillation4_9: self.Oscillation4_9.clone(),
            Oscillation5_0: self.Oscillation5_0.clone(),
            Oscillation5_1: self.Oscillation5_1.clone(),
            Oscillation5_2: self.Oscillation5_2.clone(),
            Oscillation5_3: self.Oscillation5_3.clone(),
            Oscillation5_4: self.Oscillation5_4.clone(),
            Oscillation5_5: self.Oscillation5_5.clone(),
            Oscillation5_6: self.Oscillation5_6.clone(),
            Oscillation5_7: self.Oscillation5_7.clone(),
            Oscillation5_8: self.Oscillation5_8.clone(),
            Oscillation5_9: self.Oscillation5_9.clone(),
            Oscillation6_0: self.Oscillation6_0.clone(),
            Oscillation6_1: self.Oscillation6_1.clone(),
            Oscillation6_2: self.Oscillation6_2.clone(),
            Oscillation6_3: self.Oscillation6_3.clone(),
            Oscillation6_4: self.Oscillation6_4.clone(),
            Oscillation6_5: self.Oscillation6_5.clone(),
            Oscillation6_6: self.Oscillation6_6.clone(),
            Oscillation6_7: self.Oscillation6_7.clone(),
            Oscillation6_8: self.Oscillation6_8.clone(),
            Oscillation6_9: self.Oscillation6_9.clone(),
            Oscillation7_0: self.Oscillation7_0.clone(),
            Oscillation7_1: self.Oscillation7_1.clone(),
            Oscillation7_2: self.Oscillation7_2.clone(),
            Oscillation7_3: self.Oscillation7_3.clone(),
            Oscillation7_4: self.Oscillation7_4.clone(),
            Oscillation7_5: self.Oscillation7_5.clone(),
            Oscillation7_6: self.Oscillation7_6.clone(),
            Oscillation7_7: self.Oscillation7_7.clone(),
            Oscillation7_8: self.Oscillation7_8.clone(),
            Oscillation7_9: self.Oscillation7_9.clone(),
            Oscillation8_0: self.Oscillation8_0.clone(),
            Oscillation8_1: self.Oscillation8_1.clone(),
            Oscillation8_2: self.Oscillation8_2.clone(),
            Oscillation8_3: self.Oscillation8_3.clone(),
            Oscillation8_4: self.Oscillation8_4.clone(),
            Oscillation8_5: self.Oscillation8_5.clone(),
            Oscillation8_6: self.Oscillation8_6.clone(),
            Oscillation8_7: self.Oscillation8_7.clone(),
            Oscillation8_8: self.Oscillation8_8.clone(),
            Oscillation8_9: self.Oscillation8_9.clone(),
            Oscillation9_0: self.Oscillation9_0.clone(),
            Oscillation9_1: self.Oscillation9_1.clone(),
            Oscillation9_2: self.Oscillation9_2.clone(),
            Oscillation9_3: self.Oscillation9_3.clone(),
            Oscillation9_4: self.Oscillation9_4.clone(),
            Oscillation9_5: self.Oscillation9_5.clone(),
            Oscillation9_6: self.Oscillation9_6.clone(),
            Oscillation9_7: self.Oscillation9_7.clone(),
            Oscillation9_8: self.Oscillation9_8.clone(),
            Oscillation9_9: self.Oscillation9_9.clone(),
            ROLLING: self.ROLLING.clone(),
            m_afFrondRippleDistance_0: self.m_afFrondRippleDistance_0.clone(),
            m_afFrondRippleDistance_1: self.m_afFrondRippleDistance_1.clone(),
            m_afFrondRippleDistance_2: self.m_afFrondRippleDistance_2.clone(),
            m_afFrondRippleDistance_3: self.m_afFrondRippleDistance_3.clone(),
            m_afFrondRippleDistance_4: self.m_afFrondRippleDistance_4.clone(),
            m_afFrondRippleDistance_5: self.m_afFrondRippleDistance_5.clone(),
            m_afFrondRippleDistance_6: self.m_afFrondRippleDistance_6.clone(),
            m_afFrondRippleDistance_7: self.m_afFrondRippleDistance_7.clone(),
            m_afFrondRippleDistance_8: self.m_afFrondRippleDistance_8.clone(),
            m_afFrondRippleDistance_9: self.m_afFrondRippleDistance_9.clone(),
            m_afGlobalDirectionAdherence_0: self.m_afGlobalDirectionAdherence_0.clone(),
            m_afGlobalDirectionAdherence_1: self.m_afGlobalDirectionAdherence_1.clone(),
            m_afGlobalDirectionAdherence_2: self.m_afGlobalDirectionAdherence_2.clone(),
            m_afGlobalDirectionAdherence_3: self.m_afGlobalDirectionAdherence_3.clone(),
            m_afGlobalDirectionAdherence_4: self.m_afGlobalDirectionAdherence_4.clone(),
            m_afGlobalDirectionAdherence_5: self.m_afGlobalDirectionAdherence_5.clone(),
            m_afGlobalDirectionAdherence_6: self.m_afGlobalDirectionAdherence_6.clone(),
            m_afGlobalDirectionAdherence_7: self.m_afGlobalDirectionAdherence_7.clone(),
            m_afGlobalDirectionAdherence_8: self.m_afGlobalDirectionAdherence_8.clone(),
            m_afGlobalDirectionAdherence_9: self.m_afGlobalDirectionAdherence_9.clone(),
            m_afGlobalDistance_0: self.m_afGlobalDistance_0.clone(),
            m_afGlobalDistance_1: self.m_afGlobalDistance_1.clone(),
            m_afGlobalDistance_2: self.m_afGlobalDistance_2.clone(),
            m_afGlobalDistance_3: self.m_afGlobalDistance_3.clone(),
            m_afGlobalDistance_4: self.m_afGlobalDistance_4.clone(),
            m_afGlobalDistance_5: self.m_afGlobalDistance_5.clone(),
            m_afGlobalDistance_6: self.m_afGlobalDistance_6.clone(),
            m_afGlobalDistance_7: self.m_afGlobalDistance_7.clone(),
            m_afGlobalDistance_8: self.m_afGlobalDistance_8.clone(),
            m_afGlobalDistance_9: self.m_afGlobalDistance_9.clone(),
            m_fAnchorDistanceScale: self.m_fAnchorDistanceScale.clone(),
            m_fAnchorOffset: self.m_fAnchorOffset.clone(),
            m_fDirectionResponse: self.m_fDirectionResponse.clone(),
            m_fFrondRippleLightingScalar: self.m_fFrondRippleLightingScalar.clone(),
            m_fFrondRippleTile: self.m_fFrondRippleTile.clone(),
            m_fGlobalHeight: self.m_fGlobalHeight.clone(),
            m_fGlobalHeightExponent: self.m_fGlobalHeightExponent.clone(),
            m_fGustDurationMax: self.m_fGustDurationMax.clone(),
            m_fGustDurationMin: self.m_fGustDurationMin.clone(),
            m_fGustFallScalar: self.m_fGustFallScalar.clone(),
            m_fGustFrequency: self.m_fGustFrequency.clone(),
            m_fGustRiseScalar: self.m_fGustRiseScalar.clone(),
            m_fGustStrengthMax: self.m_fGustStrengthMax.clone(),
            m_fGustStrengthMin: self.m_fGustStrengthMin.clone(),
            m_fMaxBranchLevel1Length: self.m_fMaxBranchLevel1Length.clone(),
            m_fRollingBranchFieldMin: self.m_fRollingBranchFieldMin.clone(),
            m_fRollingBranchLightingAdjust: self.m_fRollingBranchLightingAdjust.clone(),
            m_fRollingBranchVerticalOffset: self.m_fRollingBranchVerticalOffset.clone(),
            m_fRollingLeafRippleMin: self.m_fRollingLeafRippleMin.clone(),
            m_fRollingLeafTumbleMin: self.m_fRollingLeafTumbleMin.clone(),
            m_fRollingNoisePeriod: self.m_fRollingNoisePeriod.clone(),
            m_fRollingNoiseSize: self.m_fRollingNoiseSize.clone(),
            m_fRollingNoiseSpeed: self.m_fRollingNoiseSpeed.clone(),
            m_fRollingNoiseTurbulence: self.m_fRollingNoiseTurbulence.clone(),
            m_fRollingNoiseTwist: self.m_fRollingNoiseTwist.clone(),
            m_fStrengthResponse: self.m_fStrengthResponse.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpeedTreeWindConfig9 {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_bDoBranch1: Option<i32>,
    pub m_bDoBranch2: Option<i32>,
    pub m_bDoRipple: Option<i32>,
    pub m_bDoShared: Option<i32>,
    pub m_bDoShimmer: Option<i32>,
    pub m_bLodFade: Option<i32>,
    pub m_fBranch1StretchLimit: Option<f32>,
    pub m_fBranch2StretchLimit: Option<f32>,
    pub m_fDirectionResponse: Option<f32>,
    pub m_fGustDurationMax: Option<f32>,
    pub m_fGustDurationMin: Option<f32>,
    pub m_fGustFallScalar: Option<f32>,
    pub m_fGustFrequency: Option<f32>,
    pub m_fGustRiseScalar: Option<f32>,
    pub m_fGustStrengthMax: Option<f32>,
    pub m_fGustStrengthMin: Option<f32>,
    pub m_fImportScaling: Option<f32>,
    pub m_fSharedHeightStart: Option<f32>,
    pub m_fStrengthResponse: Option<f32>,
    pub m_fWindIndependence: Option<f32>,
    pub m_sBranch1: Option<BranchWindLevel>,
    pub m_sBranch2: Option<BranchWindLevel>,
    pub m_sRipple: Option<RippleGroup>,
    pub m_sShared: Option<BranchWindLevel>,
    pub m_vTreeExtents: Option<Vector3>,
    pub pad: Option<i32>,
}

impl_object!(SpeedTreeWindConfig9);

impl Clone for SpeedTreeWindConfig9 {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_bDoBranch1: self.m_bDoBranch1.clone(),
            m_bDoBranch2: self.m_bDoBranch2.clone(),
            m_bDoRipple: self.m_bDoRipple.clone(),
            m_bDoShared: self.m_bDoShared.clone(),
            m_bDoShimmer: self.m_bDoShimmer.clone(),
            m_bLodFade: self.m_bLodFade.clone(),
            m_fBranch1StretchLimit: self.m_fBranch1StretchLimit.clone(),
            m_fBranch2StretchLimit: self.m_fBranch2StretchLimit.clone(),
            m_fDirectionResponse: self.m_fDirectionResponse.clone(),
            m_fGustDurationMax: self.m_fGustDurationMax.clone(),
            m_fGustDurationMin: self.m_fGustDurationMin.clone(),
            m_fGustFallScalar: self.m_fGustFallScalar.clone(),
            m_fGustFrequency: self.m_fGustFrequency.clone(),
            m_fGustRiseScalar: self.m_fGustRiseScalar.clone(),
            m_fGustStrengthMax: self.m_fGustStrengthMax.clone(),
            m_fGustStrengthMin: self.m_fGustStrengthMin.clone(),
            m_fImportScaling: self.m_fImportScaling.clone(),
            m_fSharedHeightStart: self.m_fSharedHeightStart.clone(),
            m_fStrengthResponse: self.m_fStrengthResponse.clone(),
            m_fWindIndependence: self.m_fWindIndependence.clone(),
            m_sBranch1: self.m_sBranch1.clone(),
            m_sBranch2: self.m_sBranch2.clone(),
            m_sRipple: self.m_sRipple.clone(),
            m_sShared: self.m_sShared.clone(),
            m_vTreeExtents: self.m_vTreeExtents.clone(),
            pad: self.pad.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SphericalHarmonicsL2 {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub sh_10_: Option<f32>,
    pub sh_11_: Option<f32>,
    pub sh_12_: Option<f32>,
    pub sh_13_: Option<f32>,
    pub sh_14_: Option<f32>,
    pub sh_15_: Option<f32>,
    pub sh_16_: Option<f32>,
    pub sh_17_: Option<f32>,
    pub sh_18_: Option<f32>,
    pub sh_19_: Option<f32>,
    pub sh_20_: Option<f32>,
    pub sh_21_: Option<f32>,
    pub sh_22_: Option<f32>,
    pub sh_23_: Option<f32>,
    pub sh_24_: Option<f32>,
    pub sh_25_: Option<f32>,
    pub sh_26_: Option<f32>,
    pub sh__0_: Option<f32>,
    pub sh__1_: Option<f32>,
    pub sh__2_: Option<f32>,
    pub sh__3_: Option<f32>,
    pub sh__4_: Option<f32>,
    pub sh__5_: Option<f32>,
    pub sh__6_: Option<f32>,
    pub sh__7_: Option<f32>,
    pub sh__8_: Option<f32>,
    pub sh__9_: Option<f32>,
}

impl_object!(SphericalHarmonicsL2);

impl Clone for SphericalHarmonicsL2 {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            sh_10_: self.sh_10_.clone(),
            sh_11_: self.sh_11_.clone(),
            sh_12_: self.sh_12_.clone(),
            sh_13_: self.sh_13_.clone(),
            sh_14_: self.sh_14_.clone(),
            sh_15_: self.sh_15_.clone(),
            sh_16_: self.sh_16_.clone(),
            sh_17_: self.sh_17_.clone(),
            sh_18_: self.sh_18_.clone(),
            sh_19_: self.sh_19_.clone(),
            sh_20_: self.sh_20_.clone(),
            sh_21_: self.sh_21_.clone(),
            sh_22_: self.sh_22_.clone(),
            sh_23_: self.sh_23_.clone(),
            sh_24_: self.sh_24_.clone(),
            sh_25_: self.sh_25_.clone(),
            sh_26_: self.sh_26_.clone(),
            sh__0_: self.sh__0_.clone(),
            sh__1_: self.sh__1_.clone(),
            sh__2_: self.sh__2_.clone(),
            sh__3_: self.sh__3_.clone(),
            sh__4_: self.sh__4_.clone(),
            sh__5_: self.sh__5_.clone(),
            sh__6_: self.sh__6_.clone(),
            sh__7_: self.sh__7_.clone(),
            sh__8_: self.sh__8_.clone(),
            sh__9_: self.sh__9_.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SplashScreenLogo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub duration: Option<f32>,
    pub logo: Option<PPtrData<Sprite>>,
}

impl_object!(SplashScreenLogo);

impl Clone for SplashScreenLogo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            duration: self.duration.clone(),
            logo: self.logo.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SplatDatabase {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AlphaTextures: Option<Vec<PPtrData<Texture2D>>>,
    pub m_AlphamapResolution: Option<i32>,
    pub m_BaseMapResolution: Option<i32>,
    pub m_ColorSpace: Option<i32>,
    pub m_MaterialRequiresMetallic: Option<bool>,
    pub m_MaterialRequiresSmoothness: Option<bool>,
    pub m_Splats: Option<Vec<SplatPrototype>>,
    pub m_TerrainLayers: Option<Vec<PPtrData<TerrainLayer>>>,
}

impl_object!(SplatDatabase);

impl Clone for SplatDatabase {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AlphaTextures: self.m_AlphaTextures.clone(),
            m_AlphamapResolution: self.m_AlphamapResolution.clone(),
            m_BaseMapResolution: self.m_BaseMapResolution.clone(),
            m_ColorSpace: self.m_ColorSpace.clone(),
            m_MaterialRequiresMetallic: self.m_MaterialRequiresMetallic.clone(),
            m_MaterialRequiresSmoothness: self.m_MaterialRequiresSmoothness.clone(),
            m_Splats: self.m_Splats.clone(),
            m_TerrainLayers: self.m_TerrainLayers.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SplatPrototype {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub normalMap: Option<PPtrData<Texture2D>>,
    pub smoothness: Option<f32>,
    pub specularMetallic: Option<Vector4>,
    pub texture: Option<PPtrData<Texture2D>>,
    pub tileOffset: Option<Vector2>,
    pub tileSize: Option<Vector2>,
}

impl_object!(SplatPrototype);

impl Clone for SplatPrototype {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            normalMap: self.normalMap.clone(),
            smoothness: self.smoothness.clone(),
            specularMetallic: self.specularMetallic.clone(),
            texture: self.texture.clone(),
            tileOffset: self.tileOffset.clone(),
            tileSize: self.tileSize.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteAtlasAssetData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub packables: Option<Vec<PPtrData<Object>>>,
}

impl_object!(SpriteAtlasAssetData);

impl Clone for SpriteAtlasAssetData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            packables: self.packables.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteAtlasData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub alphaTexture: Option<PPtrData<Texture2D>>,
    pub atlasRectOffset: Option<Vector2>,
    pub downscaleMultiplier: Option<f32>,
    pub secondaryTextures: Option<Vec<SecondarySpriteTexture>>,
    pub settingsRaw: Option<u32>,
    pub texture: Option<PPtrData<Texture2D>>,
    pub textureRect: Option<Rectf>,
    pub textureRectOffset: Option<Vector2>,
    pub uvTransform: Option<Vector4>,
}

impl_object!(SpriteAtlasData);

impl Clone for SpriteAtlasData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            alphaTexture: self.alphaTexture.clone(),
            atlasRectOffset: self.atlasRectOffset.clone(),
            downscaleMultiplier: self.downscaleMultiplier.clone(),
            secondaryTextures: self.secondaryTextures.clone(),
            settingsRaw: self.settingsRaw.clone(),
            texture: self.texture.clone(),
            textureRect: self.textureRect.clone(),
            textureRectOffset: self.textureRectOffset.clone(),
            uvTransform: self.uvTransform.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteAtlasEditorData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bindAsDefault: Option<bool>,
    pub cachedData: Option<PPtrData<CachedSpriteAtlasRuntimeData>>,
    pub isAtlasV2: Option<bool>,
    pub packables: Option<Vec<PPtrData<Object>>>,
    pub packingSettings: Option<PackingSettings>,
    pub platformSettings: Option<Vec<TextureImporterPlatformSettings>>,
    pub secondaryTextureSettings: Option<Vec<(String, SecondaryTextureSettings)>>,
    pub storedHash: Option<Hash128>,
    pub textureSettings: Option<TextureSettings>,
    pub totalSpriteSurfaceArea: Option<u32>,
    pub variantMultiplier: Option<f32>,
}

impl_object!(SpriteAtlasEditorData);

impl Clone for SpriteAtlasEditorData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bindAsDefault: self.bindAsDefault.clone(),
            cachedData: self.cachedData.clone(),
            isAtlasV2: self.isAtlasV2.clone(),
            packables: self.packables.clone(),
            packingSettings: self.packingSettings.clone(),
            platformSettings: self.platformSettings.clone(),
            secondaryTextureSettings: self.secondaryTextureSettings.clone(),
            storedHash: self.storedHash.clone(),
            textureSettings: self.textureSettings.clone(),
            totalSpriteSurfaceArea: self.totalSpriteSurfaceArea.clone(),
            variantMultiplier: self.variantMultiplier.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteBone {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub color: Option<Color>,
    pub guid: Option<String>,
    pub length: Option<f32>,
    pub name: Option<String>,
    pub parentId: Option<i32>,
    pub position: Option<Vector3>,
    pub rotation: Option<Quaternion>,
}

impl_object!(SpriteBone);

impl Clone for SpriteBone {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            color: self.color.clone(),
            guid: self.guid.clone(),
            length: self.length.clone(),
            name: self.name.clone(),
            parentId: self.parentId.clone(),
            position: self.position.clone(),
            rotation: self.rotation.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteCustomDataEntry {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Key: Option<String>,
    pub m_Value: Option<String>,
}

impl_object!(SpriteCustomDataEntry);

impl Clone for SpriteCustomDataEntry {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Key: self.m_Key.clone(),
            m_Value: self.m_Value.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteCustomMetadata {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Entries: Option<Vec<SpriteCustomDataEntry>>,
}

impl_object!(SpriteCustomMetadata);

impl Clone for SpriteCustomMetadata {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Entries: self.m_Entries.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub sprite: Option<PPtrData<Object>>,
}

impl_object!(SpriteData);

impl Clone for SpriteData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            sprite: self.sprite.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteMetaData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Alignment: Option<i32>,
    pub m_Bones: Option<Vec<SpriteBone>>,
    pub m_Border: Option<Vector4>,
    pub m_CustomData: Option<String>,
    pub m_Edges: Option<Vec<int2_storage>>,
    pub m_Indices: Option<Vec<i32>>,
    pub m_InternalID: Option<i64>,
    pub m_Name: Option<String>,
    pub m_Outline: Option<Vec<Vec<Vector2>>>,
    pub m_PhysicsShape: Option<Vec<Vec<Vector2>>>,
    pub m_Pivot: Option<Vector2>,
    pub m_Rect: Option<Rectf>,
    pub m_SpriteID: Option<String>,
    pub m_TessellationDetail: Option<f32>,
    pub m_Vertices: Option<Vec<Vector2>>,
    pub m_Weights: Option<Vec<BoneWeights4>>,
}

impl_object!(SpriteMetaData);

impl Clone for SpriteMetaData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Alignment: self.m_Alignment.clone(),
            m_Bones: self.m_Bones.clone(),
            m_Border: self.m_Border.clone(),
            m_CustomData: self.m_CustomData.clone(),
            m_Edges: self.m_Edges.clone(),
            m_Indices: self.m_Indices.clone(),
            m_InternalID: self.m_InternalID.clone(),
            m_Name: self.m_Name.clone(),
            m_Outline: self.m_Outline.clone(),
            m_PhysicsShape: self.m_PhysicsShape.clone(),
            m_Pivot: self.m_Pivot.clone(),
            m_Rect: self.m_Rect.clone(),
            m_SpriteID: self.m_SpriteID.clone(),
            m_TessellationDetail: self.m_TessellationDetail.clone(),
            m_Vertices: self.m_Vertices.clone(),
            m_Weights: self.m_Weights.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteRenderData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub alphaTexture: Option<PPtrData<Texture2D>>,
    pub atlasRectOffset: Option<Vector2>,
    pub downscaleMultiplier: Option<f32>,
    pub indices: Option<Vec<u16>>,
    pub m_Bindpose: Option<Vec<Matrix4x4>>,
    pub m_IndexBuffer: Option<Vec<u8>>,
    pub m_SourceSkin: Option<Vec<BoneWeights4>>,
    pub m_SubMeshes: Option<Vec<SubMesh>>,
    pub m_VertexData: Option<VertexData>,
    pub secondaryTextures: Option<Vec<SecondarySpriteTexture>>,
    pub settingsRaw: Option<u32>,
    pub texture: Option<PPtrData<Texture2D>>,
    pub textureRect: Option<Rectf>,
    pub textureRectOffset: Option<Vector2>,
    pub uvTransform: Option<Vector4>,
    pub vertices: Option<Vec<SpriteVertex>>,
}

impl_object!(SpriteRenderData);

impl Clone for SpriteRenderData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            alphaTexture: self.alphaTexture.clone(),
            atlasRectOffset: self.atlasRectOffset.clone(),
            downscaleMultiplier: self.downscaleMultiplier.clone(),
            indices: self.indices.clone(),
            m_Bindpose: self.m_Bindpose.clone(),
            m_IndexBuffer: self.m_IndexBuffer.clone(),
            m_SourceSkin: self.m_SourceSkin.clone(),
            m_SubMeshes: self.m_SubMeshes.clone(),
            m_VertexData: self.m_VertexData.clone(),
            secondaryTextures: self.secondaryTextures.clone(),
            settingsRaw: self.settingsRaw.clone(),
            texture: self.texture.clone(),
            textureRect: self.textureRect.clone(),
            textureRectOffset: self.textureRectOffset.clone(),
            uvTransform: self.uvTransform.clone(),
            vertices: self.vertices.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteSheetMetaData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Bones: Option<Vec<SpriteBone>>,
    pub m_CustomData: Option<String>,
    pub m_Edges: Option<Vec<int2_storage>>,
    pub m_Indices: Option<Vec<i32>>,
    pub m_InternalID: Option<i64>,
    pub m_NameFileIdTable: Option<Vec<(String, i64)>>,
    pub m_Outline: Option<Vec<Vec<Vector2>>>,
    pub m_PhysicsShape: Option<Vec<Vec<Vector2>>>,
    pub m_SecondaryTextures: Option<Vec<SecondarySpriteTexture>>,
    pub m_SpriteCustomMetadata: Option<SpriteCustomMetadata>,
    pub m_SpriteID: Option<String>,
    pub m_Sprites: Option<Vec<SpriteMetaData>>,
    pub m_Vertices: Option<Vec<Vector2>>,
    pub m_Weights: Option<Vec<BoneWeights4>>,
}

impl_object!(SpriteSheetMetaData);

impl Clone for SpriteSheetMetaData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Bones: self.m_Bones.clone(),
            m_CustomData: self.m_CustomData.clone(),
            m_Edges: self.m_Edges.clone(),
            m_Indices: self.m_Indices.clone(),
            m_InternalID: self.m_InternalID.clone(),
            m_NameFileIdTable: self.m_NameFileIdTable.clone(),
            m_Outline: self.m_Outline.clone(),
            m_PhysicsShape: self.m_PhysicsShape.clone(),
            m_SecondaryTextures: self.m_SecondaryTextures.clone(),
            m_SpriteCustomMetadata: self.m_SpriteCustomMetadata.clone(),
            m_SpriteID: self.m_SpriteID.clone(),
            m_Sprites: self.m_Sprites.clone(),
            m_Vertices: self.m_Vertices.clone(),
            m_Weights: self.m_Weights.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteTilingProperty {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub adaptiveTiling: Option<bool>,
    pub adaptiveTilingThreshold: Option<f32>,
    pub border: Option<Vector4>,
    pub drawMode: Option<i32>,
    pub newSize: Option<Vector2>,
    pub oldSize: Option<Vector2>,
    pub pivot: Option<Vector2>,
}

impl_object!(SpriteTilingProperty);

impl Clone for SpriteTilingProperty {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            adaptiveTiling: self.adaptiveTiling.clone(),
            adaptiveTilingThreshold: self.adaptiveTilingThreshold.clone(),
            border: self.border.clone(),
            drawMode: self.drawMode.clone(),
            newSize: self.newSize.clone(),
            oldSize: self.oldSize.clone(),
            pivot: self.pivot.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SpriteVertex {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub pos: Option<Vector3>,
    pub uv: Option<Vector2>,
}

impl_object!(SpriteVertex);

impl Clone for SpriteVertex {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            pos: self.pos.clone(),
            uv: self.uv.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct State {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CycleOffset: Option<f32>,
    pub m_IKOnFeet: Option<bool>,
    pub m_Mirror: Option<bool>,
    pub m_Motions: Option<Vec<PPtrData<Motion>>>,
    pub m_Name: Option<String>,
    pub m_ParentStateMachine: Option<PPtrData<StateMachine>>,
    pub m_Position: Option<Vector3>,
    pub m_Speed: Option<f32>,
    pub m_Tag: Option<String>,
}

impl_object!(State);

impl Clone for State {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CycleOffset: self.m_CycleOffset.clone(),
            m_IKOnFeet: self.m_IKOnFeet.clone(),
            m_Mirror: self.m_Mirror.clone(),
            m_Motions: self.m_Motions.clone(),
            m_Name: self.m_Name.clone(),
            m_ParentStateMachine: self.m_ParentStateMachine.clone(),
            m_Position: self.m_Position.clone(),
            m_Speed: self.m_Speed.clone(),
            m_Tag: self.m_Tag.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct StateConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BlendTreeConstantArray: Option<Vec<Box<Box<OffsetPtr>>>>,
    pub m_BlendTreeConstantIndexArray: Option<Vec<i32>>,
    pub m_CycleOffset: Option<f32>,
    pub m_CycleOffsetParamID: Option<u32>,
    pub m_FullPathID: Option<u32>,
    pub m_ID: Option<u32>,
    pub m_IKOnFeet: Option<bool>,
    pub m_LeafInfoArray: Option<Vec<LeafInfoConstant>>,
    pub m_Loop: Option<bool>,
    pub m_Mirror: Option<bool>,
    pub m_MirrorParamID: Option<u32>,
    pub m_NameID: Option<u32>,
    pub m_PathID: Option<u32>,
    pub m_Speed: Option<f32>,
    pub m_SpeedParamID: Option<u32>,
    pub m_TagID: Option<u32>,
    pub m_TimeParamID: Option<u32>,
    pub m_TransitionConstantArray: Option<Vec<Box<Box<OffsetPtr>>>>,
    pub m_WriteDefaultValues: Option<bool>,
}

impl_object!(StateConstant);

impl Clone for StateConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BlendTreeConstantArray: self.m_BlendTreeConstantArray.clone(),
            m_BlendTreeConstantIndexArray: self.m_BlendTreeConstantIndexArray.clone(),
            m_CycleOffset: self.m_CycleOffset.clone(),
            m_CycleOffsetParamID: self.m_CycleOffsetParamID.clone(),
            m_FullPathID: self.m_FullPathID.clone(),
            m_ID: self.m_ID.clone(),
            m_IKOnFeet: self.m_IKOnFeet.clone(),
            m_LeafInfoArray: self.m_LeafInfoArray.clone(),
            m_Loop: self.m_Loop.clone(),
            m_Mirror: self.m_Mirror.clone(),
            m_MirrorParamID: self.m_MirrorParamID.clone(),
            m_NameID: self.m_NameID.clone(),
            m_PathID: self.m_PathID.clone(),
            m_Speed: self.m_Speed.clone(),
            m_SpeedParamID: self.m_SpeedParamID.clone(),
            m_TagID: self.m_TagID.clone(),
            m_TimeParamID: self.m_TimeParamID.clone(),
            m_TransitionConstantArray: self.m_TransitionConstantArray.clone(),
            m_WriteDefaultValues: self.m_WriteDefaultValues.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct StateKey {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_LayerIndex: Option<i32>,
    pub m_StateID: Option<u32>,
}

impl_object!(StateKey);

impl Clone for StateKey {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_LayerIndex: self.m_LayerIndex.clone(),
            m_StateID: self.m_StateID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct StateMachine {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AnyStatePosition: Option<Vector3>,
    pub m_ChildStateMachine: Option<Vec<PPtrData<StateMachine>>>,
    pub m_ChildStateMachinePosition: Option<Vec<Vector3>>,
    pub m_DefaultState: Option<PPtrData<State>>,
    pub m_LocalTransitions: Option<Vec<(PPtrData<State>, Vec<PPtrData<Transition>>)>>,
    pub m_MotionSetCount: Option<i32>,
    pub m_Name: Option<String>,
    pub m_OrderedTransitions: Option<Vec<(PPtrData<State>, Vec<PPtrData<Transition>>)>>,
    pub m_ParentStateMachinePosition: Option<Vector3>,
    pub m_States: Option<Vec<PPtrData<State>>>,
}

impl_object!(StateMachine);

impl Clone for StateMachine {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AnyStatePosition: self.m_AnyStatePosition.clone(),
            m_ChildStateMachine: self.m_ChildStateMachine.clone(),
            m_ChildStateMachinePosition: self.m_ChildStateMachinePosition.clone(),
            m_DefaultState: self.m_DefaultState.clone(),
            m_LocalTransitions: self.m_LocalTransitions.clone(),
            m_MotionSetCount: self.m_MotionSetCount.clone(),
            m_Name: self.m_Name.clone(),
            m_OrderedTransitions: self.m_OrderedTransitions.clone(),
            m_ParentStateMachinePosition: self.m_ParentStateMachinePosition.clone(),
            m_States: self.m_States.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct StateMachineBehaviourVectorDescription {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_StateMachineBehaviourIndices: Option<Vec<u32>>,
    pub m_StateMachineBehaviourRanges: Option<Vec<(StateKey, StateRange)>>,
}

impl_object!(StateMachineBehaviourVectorDescription);

impl Clone for StateMachineBehaviourVectorDescription {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_StateMachineBehaviourIndices: self.m_StateMachineBehaviourIndices.clone(),
            m_StateMachineBehaviourRanges: self.m_StateMachineBehaviourRanges.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct StateMachineConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AnyStateTransitionConstantArray: Option<Vec<Box<Box<OffsetPtr>>>>,
    pub m_DefaultState: Option<u32>,
    pub m_MotionSetCount: Option<u32>,
    pub m_SelectorStateConstantArray: Option<Vec<Box<Box<OffsetPtr>>>>,
    pub m_StateConstantArray: Option<Vec<Box<Box<OffsetPtr>>>>,
    pub m_SynchronizedLayerCount: Option<u32>,
}

impl_object!(StateMachineConstant);

impl Clone for StateMachineConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AnyStateTransitionConstantArray: self.m_AnyStateTransitionConstantArray.clone(),
            m_DefaultState: self.m_DefaultState.clone(),
            m_MotionSetCount: self.m_MotionSetCount.clone(),
            m_SelectorStateConstantArray: self.m_SelectorStateConstantArray.clone(),
            m_StateConstantArray: self.m_StateConstantArray.clone(),
            m_SynchronizedLayerCount: self.m_SynchronizedLayerCount.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct StateRange {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Count: Option<u32>,
    pub m_StartIndex: Option<u32>,
}

impl_object!(StateRange);

impl Clone for StateRange {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Count: self.m_Count.clone(),
            m_StartIndex: self.m_StartIndex.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct StaticBatchInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub firstSubMesh: Option<u16>,
    pub subMeshCount: Option<u16>,
}

impl_object!(StaticBatchInfo);

impl Clone for StaticBatchInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            firstSubMesh: self.firstSubMesh.clone(),
            subMeshCount: self.subMeshCount.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct StreamInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub align: Option<u32>,
    pub channelMask: Option<u32>,
    pub dividerOp: Option<u8>,
    pub frequency: Option<u16>,
    pub offset: Option<u32>,
    pub stride: Option<u32>,
}

impl_object!(StreamInfo);

impl Clone for StreamInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            align: self.align.clone(),
            channelMask: self.channelMask.clone(),
            dividerOp: self.dividerOp.clone(),
            frequency: self.frequency.clone(),
            offset: self.offset.clone(),
            stride: self.stride.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct StreamedClip {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub curveCount: Option<u16>,
    pub data: Option<Vec<u32>>,
    pub discreteCurveCount: Option<u16>,
}

impl_object!(StreamedClip);

impl Clone for StreamedClip {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            curveCount: self.curveCount.clone(),
            data: self.data.clone(),
            discreteCurveCount: self.discreteCurveCount.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct StreamedResource {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Offset: Option<u64>,
    pub m_Size: Option<u64>,
    pub m_Source: Option<String>,
}

impl_object!(StreamedResource);

impl Clone for StreamedResource {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Offset: self.m_Offset.clone(),
            m_Size: self.m_Size.clone(),
            m_Source: self.m_Source.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct StreamingInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub offset: Option<u32>,
    pub path: Option<String>,
    pub size: Option<u32>,
}

impl_object!(StreamingInfo);

impl Clone for StreamingInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            offset: self.offset.clone(),
            path: self.path.clone(),
            size: self.size.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct StructParameter {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ArraySize: Option<i32>,
    pub m_Index: Option<i32>,
    pub m_MatrixMembers: Option<Vec<MatrixParameter>>,
    pub m_NameIndex: Option<i32>,
    pub m_StructSize: Option<i32>,
    pub m_VectorMembers: Option<Vec<VectorParameter>>,
}

impl_object!(StructParameter);

impl Clone for StructParameter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ArraySize: self.m_ArraySize.clone(),
            m_Index: self.m_Index.clone(),
            m_MatrixMembers: self.m_MatrixMembers.clone(),
            m_NameIndex: self.m_NameIndex.clone(),
            m_StructSize: self.m_StructSize.clone(),
            m_VectorMembers: self.m_VectorMembers.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SubCollider {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Collider: Option<PPtrData<Collider2D>>,
    pub m_ColliderPaths: Option<Vec<Vec<IntPoint>>>,
}

impl_object!(SubCollider);

impl Clone for SubCollider {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Collider: self.m_Collider.clone(),
            m_ColliderPaths: self.m_ColliderPaths.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SubEmitterData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub emitProbability: Option<f32>,
    pub emitter: Option<PPtrData<ParticleSystem>>,
    pub properties: Option<i32>,
    pub typ: Option<i32>,
}

impl_object!(SubEmitterData);

impl Clone for SubEmitterData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            emitProbability: self.emitProbability.clone(),
            emitter: self.emitter.clone(),
            properties: self.properties.clone(),
            typ: self.typ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SubMesh {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub baseVertex: Option<u32>,
    pub firstByte: Option<u32>,
    pub firstVertex: Option<u32>,
    pub indexCount: Option<u32>,
    pub isTriStrip: Option<u32>,
    pub localAABB: Option<AABB>,
    pub topology: Option<i32>,
    pub triangleCount: Option<u32>,
    pub vertexCount: Option<u32>,
}

impl_object!(SubMesh);

impl Clone for SubMesh {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            baseVertex: self.baseVertex.clone(),
            firstByte: self.firstByte.clone(),
            firstVertex: self.firstVertex.clone(),
            indexCount: self.indexCount.clone(),
            isTriStrip: self.isTriStrip.clone(),
            localAABB: self.localAABB.clone(),
            topology: self.topology.clone(),
            triangleCount: self.triangleCount.clone(),
            vertexCount: self.vertexCount.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SubModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub enabled: Option<bool>,
    pub subEmitterBirth: Option<PPtrData<ParticleSystem>>,
    pub subEmitterBirth1: Option<PPtrData<ParticleSystem>>,
    pub subEmitterCollision: Option<PPtrData<ParticleSystem>>,
    pub subEmitterCollision1: Option<PPtrData<ParticleSystem>>,
    pub subEmitterDeath: Option<PPtrData<ParticleSystem>>,
    pub subEmitterDeath1: Option<PPtrData<ParticleSystem>>,
    pub subEmitters: Option<Vec<SubEmitterData>>,
}

impl_object!(SubModule);

impl Clone for SubModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            enabled: self.enabled.clone(),
            subEmitterBirth: self.subEmitterBirth.clone(),
            subEmitterBirth1: self.subEmitterBirth1.clone(),
            subEmitterCollision: self.subEmitterCollision.clone(),
            subEmitterCollision1: self.subEmitterCollision1.clone(),
            subEmitterDeath: self.subEmitterDeath.clone(),
            subEmitterDeath1: self.subEmitterDeath1.clone(),
            subEmitters: self.subEmitters.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SubPassDescriptor {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub colorOutputs: Option<AttachmentIndexArray>,
    pub flags: Option<i32>,
    pub inputs: Option<AttachmentIndexArray>,
}

impl_object!(SubPassDescriptor);

impl Clone for SubPassDescriptor {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            colorOutputs: self.colorOutputs.clone(),
            flags: self.flags.clone(),
            inputs: self.inputs.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SubstanceEnumItem {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub text: Option<String>,
    pub value: Option<i32>,
}

impl_object!(SubstanceEnumItem);

impl Clone for SubstanceEnumItem {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            text: self.text.clone(),
            value: self.value.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SubstanceInput {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub alteredTexturesUID: Option<Vec<u32>>,
    pub componentLabels: Option<Vec<String>>,
    pub enumValues: Option<Vec<SubstanceEnumItem>>,
    pub flags: Option<u32>,
    pub group: Option<String>,
    pub internalIdentifier: Option<u32>,
    pub internalIndex: Option<u32>,
    pub internalType: Option<i32>,
    pub label: Option<String>,
    pub maximum: Option<f32>,
    pub minimum: Option<f32>,
    pub name: Option<String>,
    pub step: Option<f32>,
    pub typ: Option<i32>,
    pub value: Option<SubstanceValue>,
    pub visibleIf: Option<String>,
}

impl_object!(SubstanceInput);

impl Clone for SubstanceInput {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            alteredTexturesUID: self.alteredTexturesUID.clone(),
            componentLabels: self.componentLabels.clone(),
            enumValues: self.enumValues.clone(),
            flags: self.flags.clone(),
            group: self.group.clone(),
            internalIdentifier: self.internalIdentifier.clone(),
            internalIndex: self.internalIndex.clone(),
            internalType: self.internalType.clone(),
            label: self.label.clone(),
            maximum: self.maximum.clone(),
            minimum: self.minimum.clone(),
            name: self.name.clone(),
            step: self.step.clone(),
            typ: self.typ.clone(),
            value: self.value.clone(),
            visibleIf: self.visibleIf.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct SubstanceValue {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub scalar_0_: Option<f32>,
    pub scalar_1_: Option<f32>,
    pub scalar_2_: Option<f32>,
    pub scalar_3_: Option<f32>,
    pub stringvalue: Option<String>,
    pub texture: Option<PPtrData<Texture2D>>,
}

impl_object!(SubstanceValue);

impl Clone for SubstanceValue {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            scalar_0_: self.scalar_0_.clone(),
            scalar_1_: self.scalar_1_.clone(),
            scalar_2_: self.scalar_2_.clone(),
            scalar_3_: self.scalar_3_.clone(),
            stringvalue: self.stringvalue.clone(),
            texture: self.texture.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TakeInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bakeStartTime: Option<f32>,
    pub bakeStopTime: Option<f32>,
    pub clip: Option<PPtrData<AnimationClip>>,
    pub defaultClipName: Option<String>,
    pub internalID: Option<i64>,
    pub name: Option<String>,
    pub sampleRate: Option<f32>,
    pub startTime: Option<f32>,
    pub stopTime: Option<f32>,
}

impl_object!(TakeInfo);

impl Clone for TakeInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bakeStartTime: self.bakeStartTime.clone(),
            bakeStopTime: self.bakeStopTime.clone(),
            clip: self.clip.clone(),
            defaultClipName: self.defaultClipName.clone(),
            internalID: self.internalID.clone(),
            name: self.name.clone(),
            sampleRate: self.sampleRate.clone(),
            startTime: self.startTime.clone(),
            stopTime: self.stopTime.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Tetrahedron {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub indices_0_: Option<i32>,
    pub indices_1_: Option<i32>,
    pub indices_2_: Option<i32>,
    pub indices_3_: Option<i32>,
    pub matrix: Option<Matrix3x4>,
    pub neighbors_0_: Option<i32>,
    pub neighbors_1_: Option<i32>,
    pub neighbors_2_: Option<i32>,
    pub neighbors_3_: Option<i32>,
}

impl_object!(Tetrahedron);

impl Clone for Tetrahedron {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            indices_0_: self.indices_0_.clone(),
            indices_1_: self.indices_1_.clone(),
            indices_2_: self.indices_2_.clone(),
            indices_3_: self.indices_3_.clone(),
            matrix: self.matrix.clone(),
            neighbors_0_: self.neighbors_0_.clone(),
            neighbors_1_: self.neighbors_1_.clone(),
            neighbors_2_: self.neighbors_2_.clone(),
            neighbors_3_: self.neighbors_3_.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TextureImportInstructions {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub androidETC2FallbackDownscale: Option<bool>,
    pub androidETC2FallbackFormat: Option<i32>,
    pub colorSpace: Option<i32>,
    pub compressedFormat: Option<i32>,
    pub compressionQuality: Option<i32>,
    pub cubeIntermediateSize: Option<i32>,
    pub cubeLayout: Option<i32>,
    pub cubeMode: Option<i32>,
    pub depth: Option<i32>,
    pub desiredFormat: Option<i32>,
    pub height: Option<i32>,
    pub recommendedFormat: Option<i32>,
    pub uncompressedFormat: Option<i32>,
    pub usageMode: Option<i32>,
    pub vtOnly: Option<bool>,
    pub width: Option<i32>,
}

impl_object!(TextureImportInstructions);

impl Clone for TextureImportInstructions {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            androidETC2FallbackDownscale: self.androidETC2FallbackDownscale.clone(),
            androidETC2FallbackFormat: self.androidETC2FallbackFormat.clone(),
            colorSpace: self.colorSpace.clone(),
            compressedFormat: self.compressedFormat.clone(),
            compressionQuality: self.compressionQuality.clone(),
            cubeIntermediateSize: self.cubeIntermediateSize.clone(),
            cubeLayout: self.cubeLayout.clone(),
            cubeMode: self.cubeMode.clone(),
            depth: self.depth.clone(),
            desiredFormat: self.desiredFormat.clone(),
            height: self.height.clone(),
            recommendedFormat: self.recommendedFormat.clone(),
            uncompressedFormat: self.uncompressedFormat.clone(),
            usageMode: self.usageMode.clone(),
            vtOnly: self.vtOnly.clone(),
            width: self.width.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TextureImportOutput {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub importInspectorWarnings: Option<String>,
    pub sourceTextureInformation: Option<SourceTextureInformation>,
    pub textureImportInstructions: Option<TextureImportInstructions>,
}

impl_object!(TextureImportOutput);

impl Clone for TextureImportOutput {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            importInspectorWarnings: self.importInspectorWarnings.clone(),
            sourceTextureInformation: self.sourceTextureInformation.clone(),
            textureImportInstructions: self.textureImportInstructions.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TextureImporterPlatformSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AllowsAlphaSplitting: Option<bool>,
    pub m_AndroidETC2FallbackOverride: Option<i32>,
    pub m_BuildTarget: Option<String>,
    pub m_CompressionQuality: Option<i32>,
    pub m_CrunchedCompression: Option<bool>,
    pub m_ForceMaximumCompressionQuality_BC6H_BC7: Option<bool>,
    pub m_IgnorePlatformSupport: Option<bool>,
    pub m_MaxTextureSize: Option<i32>,
    pub m_Overridden: Option<bool>,
    pub m_ResizeAlgorithm: Option<i32>,
    pub m_TextureCompression: Option<i32>,
    pub m_TextureFormat: Option<i32>,
}

impl_object!(TextureImporterPlatformSettings);

impl Clone for TextureImporterPlatformSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AllowsAlphaSplitting: self.m_AllowsAlphaSplitting.clone(),
            m_AndroidETC2FallbackOverride: self.m_AndroidETC2FallbackOverride.clone(),
            m_BuildTarget: self.m_BuildTarget.clone(),
            m_CompressionQuality: self.m_CompressionQuality.clone(),
            m_CrunchedCompression: self.m_CrunchedCompression.clone(),
            m_ForceMaximumCompressionQuality_BC6H_BC7: self
                .m_ForceMaximumCompressionQuality_BC6H_BC7
                .clone(),
            m_IgnorePlatformSupport: self.m_IgnorePlatformSupport.clone(),
            m_MaxTextureSize: self.m_MaxTextureSize.clone(),
            m_Overridden: self.m_Overridden.clone(),
            m_ResizeAlgorithm: self.m_ResizeAlgorithm.clone(),
            m_TextureCompression: self.m_TextureCompression.clone(),
            m_TextureFormat: self.m_TextureFormat.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TextureParameter {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Dim: Option<i8>,
    pub m_Index: Option<i32>,
    pub m_MultiSampled: Option<bool>,
    pub m_NameIndex: Option<i32>,
    pub m_SamplerIndex: Option<i32>,
}

impl_object!(TextureParameter);

impl Clone for TextureParameter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Dim: self.m_Dim.clone(),
            m_Index: self.m_Index.clone(),
            m_MultiSampled: self.m_MultiSampled.clone(),
            m_NameIndex: self.m_NameIndex.clone(),
            m_SamplerIndex: self.m_SamplerIndex.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TextureParameters {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub height: Option<i32>,
    pub mipLevels: Option<i32>,
    pub textureFormat: Option<i32>,
    pub width: Option<i32>,
}

impl_object!(TextureParameters);

impl Clone for TextureParameters {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            height: self.height.clone(),
            mipLevels: self.mipLevels.clone(),
            textureFormat: self.textureFormat.clone(),
            width: self.width.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TextureSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub anisoLevel: Option<i32>,
    pub compressionQuality: Option<i32>,
    pub crunchedCompression: Option<bool>,
    pub filterMode: Option<i32>,
    pub generateMipMaps: Option<bool>,
    pub maxTextureSize: Option<i32>,
    pub readable: Option<bool>,
    pub sRGB: Option<bool>,
    pub textureCompression: Option<i32>,
}

impl_object!(TextureSettings);

impl Clone for TextureSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            anisoLevel: self.anisoLevel.clone(),
            compressionQuality: self.compressionQuality.clone(),
            crunchedCompression: self.crunchedCompression.clone(),
            filterMode: self.filterMode.clone(),
            generateMipMaps: self.generateMipMaps.clone(),
            maxTextureSize: self.maxTextureSize.clone(),
            readable: self.readable.clone(),
            sRGB: self.sRGB.clone(),
            textureCompression: self.textureCompression.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TicksPerSecond {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Denominator: Option<u32>,
    pub m_Numerator: Option<u32>,
}

impl_object!(TicksPerSecond);

impl Clone for TicksPerSecond {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Denominator: self.m_Denominator.clone(),
            m_Numerator: self.m_Numerator.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TierGraphicsSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub enableLPPV: Option<bool>,
    pub hdrMode: Option<i32>,
    pub prefer32BitShadowMaps: Option<bool>,
    pub realtimeGICPUUsage: Option<i32>,
    pub renderingPath: Option<i32>,
    pub useCascadedShadowMaps: Option<bool>,
    pub useHDR: Option<bool>,
}

impl_object!(TierGraphicsSettings);

impl Clone for TierGraphicsSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            enableLPPV: self.enableLPPV.clone(),
            hdrMode: self.hdrMode.clone(),
            prefer32BitShadowMaps: self.prefer32BitShadowMaps.clone(),
            realtimeGICPUUsage: self.realtimeGICPUUsage.clone(),
            renderingPath: self.renderingPath.clone(),
            useCascadedShadowMaps: self.useCascadedShadowMaps.clone(),
            useHDR: self.useHDR.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Tile {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub dummyAlignment: Option<u16>,
    pub m_AllTileFlags: Option<u32>,
    pub m_ColliderType: Option<i32>,
    pub m_ObjectToInstantiate: Option<PPtrData<GameObject>>,
    pub m_TileColorIndex: Option<u16>,
    pub m_TileFlags: Option<i32>,
    pub m_TileIndex: Option<u32>,
    pub m_TileMatrixIndex: Option<u16>,
    pub m_TileObjectToInstantiateIndex: Option<u16>,
    pub m_TileSpriteIndex: Option<u32>,
}

impl_object!(Tile);

impl Clone for Tile {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            dummyAlignment: self.dummyAlignment.clone(),
            m_AllTileFlags: self.m_AllTileFlags.clone(),
            m_ColliderType: self.m_ColliderType.clone(),
            m_ObjectToInstantiate: self.m_ObjectToInstantiate.clone(),
            m_TileColorIndex: self.m_TileColorIndex.clone(),
            m_TileFlags: self.m_TileFlags.clone(),
            m_TileIndex: self.m_TileIndex.clone(),
            m_TileMatrixIndex: self.m_TileMatrixIndex.clone(),
            m_TileObjectToInstantiateIndex: self.m_TileObjectToInstantiateIndex.clone(),
            m_TileSpriteIndex: self.m_TileSpriteIndex.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TileAnimationData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AnimatedSprites: Option<Vec<PPtrData<Sprite>>>,
    pub m_AnimationSpeed: Option<f32>,
    pub m_AnimationTimeOffset: Option<f32>,
    pub m_Flags: Option<u32>,
    pub m_IsLooping: Option<bool>,
}

impl_object!(TileAnimationData);

impl Clone for TileAnimationData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AnimatedSprites: self.m_AnimatedSprites.clone(),
            m_AnimationSpeed: self.m_AnimationSpeed.clone(),
            m_AnimationTimeOffset: self.m_AnimationTimeOffset.clone(),
            m_Flags: self.m_Flags.clone(),
            m_IsLooping: self.m_IsLooping.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TilemapRefCountedData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Data: Option<Color>,
    pub m_RefCount: Option<u32>,
}

impl_object!(TilemapRefCountedData);

impl Clone for TilemapRefCountedData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Data: self.m_Data.clone(),
            m_RefCount: self.m_RefCount.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TrailModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub attachRibbonsToTransform: Option<bool>,
    pub colorOverLifetime: Option<MinMaxGradient>,
    pub colorOverTrail: Option<MinMaxGradient>,
    pub dieWithParticles: Option<bool>,
    pub enabled: Option<bool>,
    pub generateLightingData: Option<bool>,
    pub inheritParticleColor: Option<bool>,
    pub lifetime: Option<MinMaxCurve>,
    pub minVertexDistance: Option<f32>,
    pub mode: Option<i32>,
    pub ratio: Option<f32>,
    pub ribbonCount: Option<i32>,
    pub shadowBias: Option<f32>,
    pub sizeAffectsLifetime: Option<bool>,
    pub sizeAffectsWidth: Option<bool>,
    pub splitSubEmitterRibbons: Option<bool>,
    pub textureMode: Option<i32>,
    pub textureScale: Option<Vector2>,
    pub widthOverTrail: Option<MinMaxCurve>,
    pub worldSpace: Option<bool>,
}

impl_object!(TrailModule);

impl Clone for TrailModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            attachRibbonsToTransform: self.attachRibbonsToTransform.clone(),
            colorOverLifetime: self.colorOverLifetime.clone(),
            colorOverTrail: self.colorOverTrail.clone(),
            dieWithParticles: self.dieWithParticles.clone(),
            enabled: self.enabled.clone(),
            generateLightingData: self.generateLightingData.clone(),
            inheritParticleColor: self.inheritParticleColor.clone(),
            lifetime: self.lifetime.clone(),
            minVertexDistance: self.minVertexDistance.clone(),
            mode: self.mode.clone(),
            ratio: self.ratio.clone(),
            ribbonCount: self.ribbonCount.clone(),
            shadowBias: self.shadowBias.clone(),
            sizeAffectsLifetime: self.sizeAffectsLifetime.clone(),
            sizeAffectsWidth: self.sizeAffectsWidth.clone(),
            splitSubEmitterRibbons: self.splitSubEmitterRibbons.clone(),
            textureMode: self.textureMode.clone(),
            textureScale: self.textureScale.clone(),
            widthOverTrail: self.widthOverTrail.clone(),
            worldSpace: self.worldSpace.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TransformMaskElement {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Path: Option<String>,
    pub m_Weight: Option<f32>,
}

impl_object!(TransformMaskElement);

impl Clone for TransformMaskElement {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Path: self.m_Path.clone(),
            m_Weight: self.m_Weight.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Transition {
    // extends NamedObject
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Atomic: Option<bool>,
    pub m_CanTransitionToSelf: Option<bool>,
    pub m_Conditions: Option<Vec<Condition>>,
    pub m_DstState: Option<PPtrData<State>>,
    pub m_Mute: Option<bool>,
    pub m_Name: Option<String>,
    pub m_Solo: Option<bool>,
    pub m_SrcState: Option<PPtrData<State>>,
    pub m_TransitionDuration: Option<f32>,
    pub m_TransitionOffset: Option<f32>,
}

impl_object!(Transition);

impl Clone for Transition {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Atomic: self.m_Atomic.clone(),
            m_CanTransitionToSelf: self.m_CanTransitionToSelf.clone(),
            m_Conditions: self.m_Conditions.clone(),
            m_DstState: self.m_DstState.clone(),
            m_Mute: self.m_Mute.clone(),
            m_Name: self.m_Name.clone(),
            m_Solo: self.m_Solo.clone(),
            m_SrcState: self.m_SrcState.clone(),
            m_TransitionDuration: self.m_TransitionDuration.clone(),
            m_TransitionOffset: self.m_TransitionOffset.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TransitionConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Atomic: Option<bool>,
    pub m_CanTransitionToSelf: Option<bool>,
    pub m_ConditionConstantArray: Option<Vec<Box<Box<OffsetPtr>>>>,
    pub m_DestinationState: Option<u32>,
    pub m_ExitTime: Option<f32>,
    pub m_FullPathID: Option<u32>,
    pub m_HasExitTime: Option<bool>,
    pub m_HasFixedDuration: Option<bool>,
    pub m_ID: Option<u32>,
    pub m_InterruptionSource: Option<i32>,
    pub m_OrderedInterruption: Option<bool>,
    pub m_TransitionDuration: Option<f32>,
    pub m_TransitionOffset: Option<f32>,
    pub m_UserID: Option<u32>,
}

impl_object!(TransitionConstant);

impl Clone for TransitionConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Atomic: self.m_Atomic.clone(),
            m_CanTransitionToSelf: self.m_CanTransitionToSelf.clone(),
            m_ConditionConstantArray: self.m_ConditionConstantArray.clone(),
            m_DestinationState: self.m_DestinationState.clone(),
            m_ExitTime: self.m_ExitTime.clone(),
            m_FullPathID: self.m_FullPathID.clone(),
            m_HasExitTime: self.m_HasExitTime.clone(),
            m_HasFixedDuration: self.m_HasFixedDuration.clone(),
            m_ID: self.m_ID.clone(),
            m_InterruptionSource: self.m_InterruptionSource.clone(),
            m_OrderedInterruption: self.m_OrderedInterruption.clone(),
            m_TransitionDuration: self.m_TransitionDuration.clone(),
            m_TransitionOffset: self.m_TransitionOffset.clone(),
            m_UserID: self.m_UserID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TreeInstance {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub color: Option<Color>,
    pub heightScale: Option<f32>,
    pub index: Option<i32>,
    pub lightmapColor: Option<Color>,
    pub position: Option<Vector3>,
    pub rotation: Option<f32>,
    pub widthScale: Option<f32>,
}

impl_object!(TreeInstance);

impl Clone for TreeInstance {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            color: self.color.clone(),
            heightScale: self.heightScale.clone(),
            index: self.index.clone(),
            lightmapColor: self.lightmapColor.clone(),
            position: self.position.clone(),
            rotation: self.rotation.clone(),
            widthScale: self.widthScale.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TreePrototype {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bendFactor: Option<f32>,
    pub navMeshLod: Option<i32>,
    pub prefab: Option<PPtrData<GameObject>>,
}

impl_object!(TreePrototype);

impl Clone for TreePrototype {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bendFactor: self.bendFactor.clone(),
            navMeshLod: self.navMeshLod.clone(),
            prefab: self.prefab.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct TriggerModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub colliderQueryMode: Option<i32>,
    pub collisionShape0: Option<PPtrData<Component>>,
    pub collisionShape1: Option<PPtrData<Component>>,
    pub collisionShape2: Option<PPtrData<Component>>,
    pub collisionShape3: Option<PPtrData<Component>>,
    pub collisionShape4: Option<PPtrData<Component>>,
    pub collisionShape5: Option<PPtrData<Component>>,
    pub enabled: Option<bool>,
    pub enter: Option<i32>,
    pub exit: Option<i32>,
    pub inside: Option<i32>,
    pub outside: Option<i32>,
    pub primitives: Option<Vec<PPtrData<Component>>>,
    pub radiusScale: Option<f32>,
}

impl_object!(TriggerModule);

impl Clone for TriggerModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            colliderQueryMode: self.colliderQueryMode.clone(),
            collisionShape0: self.collisionShape0.clone(),
            collisionShape1: self.collisionShape1.clone(),
            collisionShape2: self.collisionShape2.clone(),
            collisionShape3: self.collisionShape3.clone(),
            collisionShape4: self.collisionShape4.clone(),
            collisionShape5: self.collisionShape5.clone(),
            enabled: self.enabled.clone(),
            enter: self.enter.clone(),
            exit: self.exit.clone(),
            inside: self.inside.clone(),
            outside: self.outside.clone(),
            primitives: self.primitives.clone(),
            radiusScale: self.radiusScale.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct UAVParameter {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Index: Option<i32>,
    pub m_NameIndex: Option<i32>,
    pub m_OriginalIndex: Option<i32>,
}

impl_object!(UAVParameter);

impl Clone for UAVParameter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Index: self.m_Index.clone(),
            m_NameIndex: self.m_NameIndex.clone(),
            m_OriginalIndex: self.m_OriginalIndex.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct UVAnimation {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub cycles: Option<f32>,
    pub x_Tile: Option<i32>,
    pub y_Tile: Option<i32>,
}

impl_object!(UVAnimation);

impl Clone for UVAnimation {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            cycles: self.cycles.clone(),
            x_Tile: self.x_Tile.clone(),
            y_Tile: self.y_Tile.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct UVModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub animationType: Option<i32>,
    pub cycles: Option<f32>,
    pub enabled: Option<bool>,
    pub flipU: Option<f32>,
    pub flipV: Option<f32>,
    pub fps: Option<f32>,
    pub frameOverTime: Option<MinMaxCurve>,
    pub mode: Option<i32>,
    pub randomRow: Option<bool>,
    pub rowIndex: Option<i32>,
    pub rowMode: Option<i32>,
    pub speedRange: Option<Vector2>,
    pub sprites: Option<Vec<SpriteData>>,
    pub startFrame: Option<MinMaxCurve>,
    pub tilesX: Option<i32>,
    pub tilesY: Option<i32>,
    pub timeMode: Option<i32>,
    pub uvChannelMask: Option<i32>,
}

impl_object!(UVModule);

impl Clone for UVModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            animationType: self.animationType.clone(),
            cycles: self.cycles.clone(),
            enabled: self.enabled.clone(),
            flipU: self.flipU.clone(),
            flipV: self.flipV.clone(),
            fps: self.fps.clone(),
            frameOverTime: self.frameOverTime.clone(),
            mode: self.mode.clone(),
            randomRow: self.randomRow.clone(),
            rowIndex: self.rowIndex.clone(),
            rowMode: self.rowMode.clone(),
            speedRange: self.speedRange.clone(),
            sprites: self.sprites.clone(),
            startFrame: self.startFrame.clone(),
            tilesX: self.tilesX.clone(),
            tilesY: self.tilesY.clone(),
            timeMode: self.timeMode.clone(),
            uvChannelMask: self.uvChannelMask.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct UnityAdsSettings {
    // extends GlobalGameManager
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AndroidGameId: Option<String>,
    pub m_Enabled: Option<bool>,
    pub m_EnabledPlatforms: Option<u32>,
    pub m_GameId: Option<String>,
    pub m_InitializeOnStartup: Option<bool>,
    pub m_IosGameId: Option<String>,
    pub m_TestMode: Option<bool>,
}

impl_object!(UnityAdsSettings);

impl Clone for UnityAdsSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AndroidGameId: self.m_AndroidGameId.clone(),
            m_Enabled: self.m_Enabled.clone(),
            m_EnabledPlatforms: self.m_EnabledPlatforms.clone(),
            m_GameId: self.m_GameId.clone(),
            m_InitializeOnStartup: self.m_InitializeOnStartup.clone(),
            m_IosGameId: self.m_IosGameId.clone(),
            m_TestMode: self.m_TestMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct UnityAnalyticsSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<bool>,
    pub m_InitializeOnStartup: Option<bool>,
    pub m_PackageRequiringCoreStatsPresent: Option<bool>,
    pub m_TestConfigUrl: Option<String>,
    pub m_TestEventUrl: Option<String>,
    pub m_TestMode: Option<bool>,
}

impl_object!(UnityAnalyticsSettings);

impl Clone for UnityAnalyticsSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_InitializeOnStartup: self.m_InitializeOnStartup.clone(),
            m_PackageRequiringCoreStatsPresent: self.m_PackageRequiringCoreStatsPresent.clone(),
            m_TestConfigUrl: self.m_TestConfigUrl.clone(),
            m_TestEventUrl: self.m_TestEventUrl.clone(),
            m_TestMode: self.m_TestMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct UnityPropertySheet {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Colors: Option<Vec<(FastPropertyName, Color)>>,
    pub m_Floats: Option<Vec<(FastPropertyName, f32)>>,
    pub m_Ints: Option<Vec<(String, i32)>>,
    pub m_TexEnvs: Option<Vec<(FastPropertyName, UnityTexEnv)>>,
}

impl_object!(UnityPropertySheet);

impl Clone for UnityPropertySheet {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Colors: self.m_Colors.clone(),
            m_Floats: self.m_Floats.clone(),
            m_Ints: self.m_Ints.clone(),
            m_TexEnvs: self.m_TexEnvs.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct UnityPurchasingSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Enabled: Option<bool>,
    pub m_TestMode: Option<bool>,
}

impl_object!(UnityPurchasingSettings);

impl Clone for UnityPurchasingSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Enabled: self.m_Enabled.clone(),
            m_TestMode: self.m_TestMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct UnityTexEnv {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Offset: Option<Vector2>,
    pub m_Scale: Option<Vector2>,
    pub m_Texture: Option<PPtrData<Texture>>,
}

impl_object!(UnityTexEnv);

impl Clone for UnityTexEnv {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Offset: self.m_Offset.clone(),
            m_Scale: self.m_Scale.clone(),
            m_Texture: self.m_Texture.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct UpdateZoneInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub needSwap: Option<bool>,
    pub passIndex: Option<i32>,
    pub rotation: Option<f32>,
    pub updateZoneCenter: Option<Vector3>,
    pub updateZoneSize: Option<Vector3>,
}

impl_object!(UpdateZoneInfo);

impl Clone for UpdateZoneInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            needSwap: self.needSwap.clone(),
            passIndex: self.passIndex.clone(),
            rotation: self.rotation.clone(),
            updateZoneCenter: self.updateZoneCenter.clone(),
            updateZoneSize: self.updateZoneSize.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXCPUBufferData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub data: Option<Vec<u32>>,
}

impl_object!(VFXCPUBufferData);

impl Clone for VFXCPUBufferData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            data: self.data.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXCPUBufferDesc {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub capacity: Option<u32>,
    pub initialData: Option<VFXCPUBufferData>,
    pub layout: Option<Vec<VFXLayoutElementDesc>>,
    pub stride: Option<u32>,
}

impl_object!(VFXCPUBufferDesc);

impl Clone for VFXCPUBufferDesc {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            capacity: self.capacity.clone(),
            initialData: self.initialData.clone(),
            layout: self.layout.clone(),
            stride: self.stride.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXEditorSystemDesc {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub buffers: Option<Vec<VFXMapping>>,
    pub capacity: Option<u32>,
    pub flags: Option<i32>,
    pub layer: Option<u32>,
    pub name: Option<String>,
    pub tasks: Option<Vec<VFXEditorTaskDesc>>,
    pub typ: Option<i32>,
    pub values: Option<Vec<VFXMapping>>,
}

impl_object!(VFXEditorSystemDesc);

impl Clone for VFXEditorSystemDesc {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            buffers: self.buffers.clone(),
            capacity: self.capacity.clone(),
            flags: self.flags.clone(),
            layer: self.layer.clone(),
            name: self.name.clone(),
            tasks: self.tasks.clone(),
            typ: self.typ.clone(),
            values: self.values.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXEditorTaskDesc {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub buffers: Option<Vec<VFXMapping>>,
    pub params: Option<Vec<VFXMapping>>,
    pub processor: Option<PPtrData<NamedObject>>,
    pub shaderSourceIndex: Option<i32>,
    pub temporaryBuffers: Option<Vec<VFXMappingTemporary>>,
    pub typ: Option<i32>,
    pub values: Option<Vec<VFXMapping>>,
}

impl_object!(VFXEditorTaskDesc);

impl Clone for VFXEditorTaskDesc {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            buffers: self.buffers.clone(),
            params: self.params.clone(),
            processor: self.processor.clone(),
            shaderSourceIndex: self.shaderSourceIndex.clone(),
            temporaryBuffers: self.temporaryBuffers.clone(),
            typ: self.typ.clone(),
            values: self.values.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXEntryExposed {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Name: Option<String>,
    pub m_Overridden: Option<bool>,
    pub m_Value: Option<AnimationCurve>,
}

impl_object!(VFXEntryExposed);

impl Clone for VFXEntryExposed {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Name: self.m_Name.clone(),
            m_Overridden: self.m_Overridden.clone(),
            m_Value: self.m_Value.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXEntryExpressionValue {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ExpressionIndex: Option<u32>,
    pub m_Value: Option<AnimationCurve>,
}

impl_object!(VFXEntryExpressionValue);

impl Clone for VFXEntryExpressionValue {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ExpressionIndex: self.m_ExpressionIndex.clone(),
            m_Value: self.m_Value.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXEventDesc {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub initSystems: Option<Vec<u32>>,
    pub name: Option<String>,
    pub playSystems: Option<Vec<u32>>,
    pub stopSystems: Option<Vec<u32>>,
}

impl_object!(VFXEventDesc);

impl Clone for VFXEventDesc {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            initSystems: self.initSystems.clone(),
            name: self.name.clone(),
            playSystems: self.playSystems.clone(),
            stopSystems: self.stopSystems.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXExposedMapping {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub mapping: Option<VFXMapping>,
    pub space: Option<i32>,
}

impl_object!(VFXExposedMapping);

impl Clone for VFXExposedMapping {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            mapping: self.mapping.clone(),
            space: self.space.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXExpressionContainer {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ConstantBakeCurveCount: Option<u32>,
    pub m_ConstantBakeGradientCount: Option<u32>,
    pub m_DynamicBakeCurveCount: Option<u32>,
    pub m_DynamicBakeGradientCount: Option<u32>,
    pub m_Expressions: Option<Vec<Expression>>,
    pub m_MaxCommonExpressionsIndex: Option<u32>,
    pub m_NeededMainCameraBuffers: Option<i32>,
    pub m_NeedsLocalToWorld: Option<bool>,
    pub m_NeedsMainCamera: Option<bool>,
    pub m_NeedsWorldToLocal: Option<bool>,
}

impl_object!(VFXExpressionContainer);

impl Clone for VFXExpressionContainer {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ConstantBakeCurveCount: self.m_ConstantBakeCurveCount.clone(),
            m_ConstantBakeGradientCount: self.m_ConstantBakeGradientCount.clone(),
            m_DynamicBakeCurveCount: self.m_DynamicBakeCurveCount.clone(),
            m_DynamicBakeGradientCount: self.m_DynamicBakeGradientCount.clone(),
            m_Expressions: self.m_Expressions.clone(),
            m_MaxCommonExpressionsIndex: self.m_MaxCommonExpressionsIndex.clone(),
            m_NeededMainCameraBuffers: self.m_NeededMainCameraBuffers.clone(),
            m_NeedsLocalToWorld: self.m_NeedsLocalToWorld.clone(),
            m_NeedsMainCamera: self.m_NeedsMainCamera.clone(),
            m_NeedsWorldToLocal: self.m_NeedsWorldToLocal.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXField {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Array: Option<Vec<VFXEntryExposed>>,
}

impl_object!(VFXField);

impl Clone for VFXField {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Array: self.m_Array.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXGPUBufferDesc {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub capacity: Option<u32>,
    pub layout: Option<Vec<VFXLayoutElementDesc>>,
    pub mode: Option<i32>,
    pub size: Option<u32>,
    pub stride: Option<u32>,
    pub target: Option<i32>,
    pub typ: Option<i32>,
}

impl_object!(VFXGPUBufferDesc);

impl Clone for VFXGPUBufferDesc {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            capacity: self.capacity.clone(),
            layout: self.layout.clone(),
            mode: self.mode.clone(),
            size: self.size.clone(),
            stride: self.stride.clone(),
            target: self.target.clone(),
            typ: self.typ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXInstanceSplitDesc {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub values: Option<Vec<u32>>,
}

impl_object!(VFXInstanceSplitDesc);

impl Clone for VFXInstanceSplitDesc {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            values: self.values.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXLayoutElementDesc {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub name: Option<String>,
    pub offset: Option<VFXLayoutOffset>,
    pub typ: Option<i32>,
}

impl_object!(VFXLayoutElementDesc);

impl Clone for VFXLayoutElementDesc {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            name: self.name.clone(),
            offset: self.offset.clone(),
            typ: self.typ.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXLayoutOffset {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bucket: Option<u32>,
    pub element: Option<u32>,
    pub structure: Option<u32>,
}

impl_object!(VFXLayoutOffset);

impl Clone for VFXLayoutOffset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bucket: self.bucket.clone(),
            element: self.element.clone(),
            structure: self.structure.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXMapping {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub index: Option<i32>,
    pub nameId: Option<String>,
}

impl_object!(VFXMapping);

impl Clone for VFXMapping {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            index: self.index.clone(),
            nameId: self.nameId.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXMappingTemporary {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub mapping: Option<VFXMapping>,
    pub pastFrameIndex: Option<u32>,
    pub perCameraBuffer: Option<bool>,
}

impl_object!(VFXMappingTemporary);

impl Clone for VFXMappingTemporary {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            mapping: self.mapping.clone(),
            pastFrameIndex: self.pastFrameIndex.clone(),
            perCameraBuffer: self.perCameraBuffer.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXPropertySheetSerializedBase {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_AnimationCurve: Option<VFXField>,
    pub m_Bool: Option<VFXField>,
    pub m_Float: Option<VFXField>,
    pub m_Gradient: Option<VFXField>,
    pub m_Int: Option<VFXField>,
    pub m_Matrix4x4f: Option<VFXField>,
    pub m_NamedObject: Option<VFXField>,
    pub m_Uint: Option<VFXField>,
    pub m_Vector2f: Option<VFXField>,
    pub m_Vector3f: Option<VFXField>,
    pub m_Vector4f: Option<VFXField>,
}

impl_object!(VFXPropertySheetSerializedBase);

impl Clone for VFXPropertySheetSerializedBase {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_AnimationCurve: self.m_AnimationCurve.clone(),
            m_Bool: self.m_Bool.clone(),
            m_Float: self.m_Float.clone(),
            m_Gradient: self.m_Gradient.clone(),
            m_Int: self.m_Int.clone(),
            m_Matrix4x4f: self.m_Matrix4x4f.clone(),
            m_NamedObject: self.m_NamedObject.clone(),
            m_Uint: self.m_Uint.clone(),
            m_Vector2f: self.m_Vector2f.clone(),
            m_Vector3f: self.m_Vector3f.clone(),
            m_Vector4f: self.m_Vector4f.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXRendererSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub lightProbeUsage: Option<i32>,
    pub motionVectorGenerationMode: Option<i32>,
    pub rayTracingMode: Option<i32>,
    pub receiveShadows: Option<bool>,
    pub reflectionProbeUsage: Option<i32>,
    pub shadowCastingMode: Option<i32>,
}

impl_object!(VFXRendererSettings);

impl Clone for VFXRendererSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            lightProbeUsage: self.lightProbeUsage.clone(),
            motionVectorGenerationMode: self.motionVectorGenerationMode.clone(),
            rayTracingMode: self.rayTracingMode.clone(),
            receiveShadows: self.receiveShadows.clone(),
            reflectionProbeUsage: self.reflectionProbeUsage.clone(),
            shadowCastingMode: self.shadowCastingMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXShaderSourceDesc {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub compute: Option<bool>,
    pub name: Option<String>,
    pub source: Option<String>,
}

impl_object!(VFXShaderSourceDesc);

impl Clone for VFXShaderSourceDesc {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            compute: self.compute.clone(),
            name: self.name.clone(),
            source: self.source.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXSystemDesc {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub buffers: Option<Vec<VFXMapping>>,
    pub capacity: Option<u32>,
    pub flags: Option<i32>,
    pub instanceSplitDescs: Option<Vec<VFXInstanceSplitDesc>>,
    pub layer: Option<u32>,
    pub name: Option<String>,
    pub tasks: Option<Vec<VFXTaskDesc>>,
    pub typ: Option<i32>,
    pub values: Option<Vec<VFXMapping>>,
}

impl_object!(VFXSystemDesc);

impl Clone for VFXSystemDesc {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            buffers: self.buffers.clone(),
            capacity: self.capacity.clone(),
            flags: self.flags.clone(),
            instanceSplitDescs: self.instanceSplitDescs.clone(),
            layer: self.layer.clone(),
            name: self.name.clone(),
            tasks: self.tasks.clone(),
            typ: self.typ.clone(),
            values: self.values.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXTaskDesc {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub buffers: Option<Vec<VFXMapping>>,
    pub instanceSplitIndex: Option<u32>,
    pub params: Option<Vec<VFXMapping>>,
    pub processor: Option<PPtrData<NamedObject>>,
    pub temporaryBuffers: Option<Vec<VFXMappingTemporary>>,
    pub typ: Option<i32>,
    pub values: Option<Vec<VFXMapping>>,
}

impl_object!(VFXTaskDesc);

impl Clone for VFXTaskDesc {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            buffers: self.buffers.clone(),
            instanceSplitIndex: self.instanceSplitIndex.clone(),
            params: self.params.clone(),
            processor: self.processor.clone(),
            temporaryBuffers: self.temporaryBuffers.clone(),
            typ: self.typ.clone(),
            values: self.values.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXTemplate {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub category: Option<String>,
    pub description: Option<String>,
    pub icon: Option<PPtrData<Texture2D>>,
    pub name: Option<String>,
    pub thumbnail: Option<PPtrData<Texture2D>>,
}

impl_object!(VFXTemplate);

impl Clone for VFXTemplate {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            category: self.category.clone(),
            description: self.description.clone(),
            icon: self.icon.clone(),
            name: self.name.clone(),
            thumbnail: self.thumbnail.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VFXTemporaryGPUBufferDesc {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub desc: Option<VFXGPUBufferDesc>,
    pub frameCount: Option<u32>,
}

impl_object!(VFXTemporaryGPUBufferDesc);

impl Clone for VFXTemporaryGPUBufferDesc {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            desc: self.desc.clone(),
            frameCount: self.frameCount.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VRSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub cardboard: Option<Google>,
    pub daydream: Option<Google>,
    pub enable360StereoCapture: Option<bool>,
    pub hololens: Option<HoloLens>,
    pub lumin: Option<Lumin>,
    pub none: Option<DeviceNone>,
    pub oculus: Option<Oculus>,
}

impl_object!(VRSettings);

impl Clone for VRSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            cardboard: self.cardboard.clone(),
            daydream: self.daydream.clone(),
            enable360StereoCapture: self.enable360StereoCapture.clone(),
            hololens: self.hololens.clone(),
            lumin: self.lumin.clone(),
            none: self.none.clone(),
            oculus: self.oculus.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ValueArray {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_BoolValues: Option<Vec<bool>>,
    pub m_FloatValues: Option<Vec<f32>>,
    pub m_IntValues: Option<Vec<i32>>,
    pub m_PositionValues: Option<Vec<Vector3>>,
    pub m_QuaternionValues: Option<Vec<Vector4>>,
    pub m_ScaleValues: Option<Vec<Vector3>>,
    pub m_VectorValues: Option<Vec<Vector4>>,
}

impl_object!(ValueArray);

impl Clone for ValueArray {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_BoolValues: self.m_BoolValues.clone(),
            m_FloatValues: self.m_FloatValues.clone(),
            m_IntValues: self.m_IntValues.clone(),
            m_PositionValues: self.m_PositionValues.clone(),
            m_QuaternionValues: self.m_QuaternionValues.clone(),
            m_ScaleValues: self.m_ScaleValues.clone(),
            m_VectorValues: self.m_VectorValues.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ValueArrayConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ValueArray: Option<Vec<ValueConstant>>,
}

impl_object!(ValueArrayConstant);

impl Clone for ValueArrayConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ValueArray: self.m_ValueArray.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ValueConstant {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ID: Option<u32>,
    pub m_Index: Option<u32>,
    pub m_Type: Option<u32>,
    pub m_TypeID: Option<u32>,
}

impl_object!(ValueConstant);

impl Clone for ValueConstant {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ID: self.m_ID.clone(),
            m_Index: self.m_Index.clone(),
            m_Type: self.m_Type.clone(),
            m_TypeID: self.m_TypeID.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct ValueDelta {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Start: Option<f32>,
    pub m_Stop: Option<f32>,
}

impl_object!(ValueDelta);

impl Clone for ValueDelta {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Start: self.m_Start.clone(),
            m_Stop: self.m_Stop.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VariableBoneCountWeights {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Data: Option<Vec<u32>>,
}

impl_object!(VariableBoneCountWeights);

impl Clone for VariableBoneCountWeights {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Data: self.m_Data.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VariantInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub graphicsStateInfoSet: Option<Vec<GraphicsStateInfo>>,
    pub keywordNames: Option<String>,
    pub keywords: Option<String>,
    pub passIndex: Option<i32>,
    pub passType: Option<i32>,
    pub shader: Option<PPtrData<Shader>>,
    pub shaderAssetGUID: Option<String>,
    pub shaderName: Option<String>,
    pub subShaderIndex: Option<i32>,
}

impl_object!(VariantInfo);

impl Clone for VariantInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            graphicsStateInfoSet: self.graphicsStateInfoSet.clone(),
            keywordNames: self.keywordNames.clone(),
            keywords: self.keywords.clone(),
            passIndex: self.passIndex.clone(),
            passType: self.passType.clone(),
            shader: self.shader.clone(),
            shaderAssetGUID: self.shaderAssetGUID.clone(),
            shaderName: self.shaderName.clone(),
            subShaderIndex: self.subShaderIndex.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct Vector3Curve {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub curve: Option<AnimationCurve>,
    pub path: Option<String>,
}

impl_object!(Vector3Curve);

impl Clone for Vector3Curve {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            curve: self.curve.clone(),
            path: self.path.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VectorParameter {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_ArraySize: Option<i32>,
    pub m_Dim: Option<i8>,
    pub m_Index: Option<i32>,
    pub m_NameIndex: Option<i32>,
    pub m_Type: Option<i8>,
}

impl_object!(VectorParameter);

impl Clone for VectorParameter {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_ArraySize: self.m_ArraySize.clone(),
            m_Dim: self.m_Dim.clone(),
            m_Index: self.m_Index.clone(),
            m_NameIndex: self.m_NameIndex.clone(),
            m_Type: self.m_Type.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VelocityModule {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub enabled: Option<bool>,
    pub inWorldSpace: Option<bool>,
    pub orbitalOffsetX: Option<MinMaxCurve>,
    pub orbitalOffsetY: Option<MinMaxCurve>,
    pub orbitalOffsetZ: Option<MinMaxCurve>,
    pub orbitalX: Option<MinMaxCurve>,
    pub orbitalY: Option<MinMaxCurve>,
    pub orbitalZ: Option<MinMaxCurve>,
    pub radial: Option<MinMaxCurve>,
    pub speedModifier: Option<MinMaxCurve>,
    pub x: Option<MinMaxCurve>,
    pub y: Option<MinMaxCurve>,
    pub z: Option<MinMaxCurve>,
}

impl_object!(VelocityModule);

impl Clone for VelocityModule {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            enabled: self.enabled.clone(),
            inWorldSpace: self.inWorldSpace.clone(),
            orbitalOffsetX: self.orbitalOffsetX.clone(),
            orbitalOffsetY: self.orbitalOffsetY.clone(),
            orbitalOffsetZ: self.orbitalOffsetZ.clone(),
            orbitalX: self.orbitalX.clone(),
            orbitalY: self.orbitalY.clone(),
            orbitalZ: self.orbitalZ.clone(),
            radial: self.radial.clone(),
            speedModifier: self.speedModifier.clone(),
            x: self.x.clone(),
            y: self.y.clone(),
            z: self.z.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VertexData {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Channels: Option<Vec<ChannelInfo>>,
    pub m_CurrentChannels: Option<i32>,
    pub m_DataSize: Option<Vec<u8>>,
    pub m_Streams: Option<Vec<StreamInfo>>,
    pub m_Streams_0_: Option<StreamInfo>,
    pub m_Streams_1_: Option<StreamInfo>,
    pub m_Streams_2_: Option<StreamInfo>,
    pub m_Streams_3_: Option<StreamInfo>,
    pub m_VertexCount: Option<u32>,
}

impl_object!(VertexData);

impl Clone for VertexData {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Channels: self.m_Channels.clone(),
            m_CurrentChannels: self.m_CurrentChannels.clone(),
            m_DataSize: self.m_DataSize.clone(),
            m_Streams: self.m_Streams.clone(),
            m_Streams_0_: self.m_Streams_0_.clone(),
            m_Streams_1_: self.m_Streams_1_.clone(),
            m_Streams_2_: self.m_Streams_2_.clone(),
            m_Streams_3_: self.m_Streams_3_.clone(),
            m_VertexCount: self.m_VertexCount.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VertexLayoutInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub vertexChannelsInfo: Option<Vec<ChannelInfo>>,
    pub vertexStreamCount: Option<i32>,
    pub vertexStrides: Option<Vec<u8>>,
}

impl_object!(VertexLayoutInfo);

impl Clone for VertexLayoutInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            vertexChannelsInfo: self.vertexChannelsInfo.clone(),
            vertexStreamCount: self.vertexStreamCount.clone(),
            vertexStrides: self.vertexStrides.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VideoClipImporterOutput {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub encodedEndFrame: Option<i32>,
    pub encodedHeight: Option<i32>,
    pub encodedSettings: Option<VideoClipImporterTargetSettings>,
    pub encodedStartFrame: Option<i32>,
    pub encodedWidth: Option<i32>,
    pub format: Option<i32>,
    pub originalFrameCount: Option<i32>,
    pub originalHeight: Option<i32>,
    pub originalWidth: Option<i32>,
    pub settings: Option<VideoClipImporterTargetSettings>,
    pub sourceAudioChannelCount: Option<Vec<u16>>,
    pub sourceAudioSampleRate: Option<Vec<u32>>,
    pub sourceFileSize: Option<u64>,
    pub sourceFrameRate: Option<f64>,
    pub sourceHasAlpha: Option<bool>,
    pub sourcePixelAspectRatioDenominator: Option<u32>,
    pub sourcePixelAspectRatioNumerator: Option<u32>,
    pub streamedResource: Option<StreamedResource>,
    pub transcodeSkipped: Option<bool>,
}

impl_object!(VideoClipImporterOutput);

impl Clone for VideoClipImporterOutput {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            encodedEndFrame: self.encodedEndFrame.clone(),
            encodedHeight: self.encodedHeight.clone(),
            encodedSettings: self.encodedSettings.clone(),
            encodedStartFrame: self.encodedStartFrame.clone(),
            encodedWidth: self.encodedWidth.clone(),
            format: self.format.clone(),
            originalFrameCount: self.originalFrameCount.clone(),
            originalHeight: self.originalHeight.clone(),
            originalWidth: self.originalWidth.clone(),
            settings: self.settings.clone(),
            sourceAudioChannelCount: self.sourceAudioChannelCount.clone(),
            sourceAudioSampleRate: self.sourceAudioSampleRate.clone(),
            sourceFileSize: self.sourceFileSize.clone(),
            sourceFrameRate: self.sourceFrameRate.clone(),
            sourceHasAlpha: self.sourceHasAlpha.clone(),
            sourcePixelAspectRatioDenominator: self.sourcePixelAspectRatioDenominator.clone(),
            sourcePixelAspectRatioNumerator: self.sourcePixelAspectRatioNumerator.clone(),
            streamedResource: self.streamedResource.clone(),
            transcodeSkipped: self.transcodeSkipped.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VideoClipImporterTargetSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub aspectRatio: Option<i32>,
    pub bitrateMode: Option<i32>,
    pub codec: Option<i32>,
    pub customHeight: Option<i32>,
    pub customWidth: Option<i32>,
    pub enableTranscoding: Option<bool>,
    pub resizeFormat: Option<i32>,
    pub spatialQuality: Option<i32>,
}

impl_object!(VideoClipImporterTargetSettings);

impl Clone for VideoClipImporterTargetSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            aspectRatio: self.aspectRatio.clone(),
            bitrateMode: self.bitrateMode.clone(),
            codec: self.codec.clone(),
            customHeight: self.customHeight.clone(),
            customWidth: self.customWidth.clone(),
            enableTranscoding: self.enableTranscoding.clone(),
            resizeFormat: self.resizeFormat.clone(),
            spatialQuality: self.spatialQuality.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VisualEffectInfo {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_Buffers: Option<Vec<VFXGPUBufferDesc>>,
    pub m_CPUBuffers: Option<Vec<VFXCPUBufferDesc>>,
    pub m_CompilationVersion: Option<u32>,
    pub m_CullingFlags: Option<i32>,
    pub m_Events: Option<Vec<VFXEventDesc>>,
    pub m_ExposedExpressions: Option<Vec<VFXExposedMapping>>,
    pub m_Expressions: Option<VFXExpressionContainer>,
    pub m_InitialEventName: Option<String>,
    pub m_InstancingCapacity: Option<u32>,
    pub m_InstancingDisabledReason: Option<i32>,
    pub m_InstancingMode: Option<i32>,
    pub m_PreWarmDeltaTime: Option<f32>,
    pub m_PreWarmStepCount: Option<u32>,
    pub m_PropertySheet: Option<VFXPropertySheetSerializedBase>,
    pub m_RendererSettings: Option<VFXRendererSettings>,
    pub m_RuntimeVersion: Option<u32>,
    pub m_TemporaryBuffers: Option<Vec<VFXTemporaryGPUBufferDesc>>,
    pub m_UpdateMode: Option<i32>,
}

impl_object!(VisualEffectInfo);

impl Clone for VisualEffectInfo {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_Buffers: self.m_Buffers.clone(),
            m_CPUBuffers: self.m_CPUBuffers.clone(),
            m_CompilationVersion: self.m_CompilationVersion.clone(),
            m_CullingFlags: self.m_CullingFlags.clone(),
            m_Events: self.m_Events.clone(),
            m_ExposedExpressions: self.m_ExposedExpressions.clone(),
            m_Expressions: self.m_Expressions.clone(),
            m_InitialEventName: self.m_InitialEventName.clone(),
            m_InstancingCapacity: self.m_InstancingCapacity.clone(),
            m_InstancingDisabledReason: self.m_InstancingDisabledReason.clone(),
            m_InstancingMode: self.m_InstancingMode.clone(),
            m_PreWarmDeltaTime: self.m_PreWarmDeltaTime.clone(),
            m_PreWarmStepCount: self.m_PreWarmStepCount.clone(),
            m_PropertySheet: self.m_PropertySheet.clone(),
            m_RendererSettings: self.m_RendererSettings.clone(),
            m_RuntimeVersion: self.m_RuntimeVersion.clone(),
            m_TemporaryBuffers: self.m_TemporaryBuffers.clone(),
            m_UpdateMode: self.m_UpdateMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct VisualEffectSettings {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub m_CullingFlags: Option<i32>,
    pub m_InitialEventName: Option<String>,
    pub m_InstancingCapacity: Option<u32>,
    pub m_InstancingDisabledReason: Option<i32>,
    pub m_InstancingMode: Option<i32>,
    pub m_PreWarmDeltaTime: Option<f32>,
    pub m_PreWarmStepCount: Option<u32>,
    pub m_RendererSettings: Option<VFXRendererSettings>,
    pub m_UpdateMode: Option<i32>,
}

impl_object!(VisualEffectSettings);

impl Clone for VisualEffectSettings {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            m_CullingFlags: self.m_CullingFlags.clone(),
            m_InitialEventName: self.m_InitialEventName.clone(),
            m_InstancingCapacity: self.m_InstancingCapacity.clone(),
            m_InstancingDisabledReason: self.m_InstancingDisabledReason.clone(),
            m_InstancingMode: self.m_InstancingMode.clone(),
            m_PreWarmDeltaTime: self.m_PreWarmDeltaTime.clone(),
            m_PreWarmStepCount: self.m_PreWarmStepCount.clone(),
            m_RendererSettings: self.m_RendererSettings.clone(),
            m_UpdateMode: self.m_UpdateMode.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct WheelFrictionCurve {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub asymptoteSlip: Option<f32>,
    pub asymptoteValue: Option<f32>,
    pub extremumSlip: Option<f32>,
    pub extremumValue: Option<f32>,
    pub m_AsymptoteSlip: Option<f32>,
    pub m_AsymptoteValue: Option<f32>,
    pub m_ExtremumSlip: Option<f32>,
    pub m_ExtremumValue: Option<f32>,
    pub m_Stiffness: Option<f32>,
    pub stiffnessFactor: Option<f32>,
}

impl_object!(WheelFrictionCurve);

impl Clone for WheelFrictionCurve {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            asymptoteSlip: self.asymptoteSlip.clone(),
            asymptoteValue: self.asymptoteValue.clone(),
            extremumSlip: self.extremumSlip.clone(),
            extremumValue: self.extremumValue.clone(),
            m_AsymptoteSlip: self.m_AsymptoteSlip.clone(),
            m_AsymptoteValue: self.m_AsymptoteValue.clone(),
            m_ExtremumSlip: self.m_ExtremumSlip.clone(),
            m_ExtremumValue: self.m_ExtremumValue.clone(),
            m_Stiffness: self.m_Stiffness.clone(),
            stiffnessFactor: self.stiffnessFactor.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct bitset {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub bitCount: Option<i32>,
    pub bitblocks: Option<Vec<u8>>,
}

impl_object!(bitset);

impl Clone for bitset {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            bitCount: self.bitCount.clone(),
            bitblocks: self.bitblocks.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct int2_storage {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub x: Option<i32>,
    pub y: Option<i32>,
}

impl_object!(int2_storage);

impl Clone for int2_storage {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            x: self.x.clone(),
            y: self.y.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct int3_storage {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub x: Option<i32>,
    pub y: Option<i32>,
    pub z: Option<i32>,
}

impl_object!(int3_storage);

impl Clone for int3_storage {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            x: self.x.clone(),
            y: self.y.clone(),
            z: self.z.clone(),
        }
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]
#[serde(default)]
pub struct xform {
    #[serde(skip)]
    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,

    pub q: Option<Vector4>,
    pub s: Option<Vector3>,
    pub t: Option<Vector3>,
}

impl_object!(xform);

impl Clone for xform {
    fn clone(&self) -> Self {
        Self {
            object_reader: None,
            q: self.q.clone(),
            s: self.s.clone(),
            t: self.t.clone(),
        }
    }
}
