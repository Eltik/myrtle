//! ClassesGenerator - Generates Rust structs for Unity classes from TPK data
//!
//! This is a build-time code generator that:
//! 1. Reads the TPK (Type Package) database containing Unity's type information
//! 2. Extracts class definitions for all Unity types (Texture2D, Mesh, MonoBehaviour, etc.)
//! 3. Generates Rust struct definitions with proper types and derives
//! 4. Handles inheritance hierarchies (Object ‚Üí NamedObject ‚Üí Texture ‚Üí Texture2D)
//! 5. Manages optional fields across different Unity versions
//!
//! Usage: cargo run --bin classes_generator

use once_cell::sync::Lazy;
use std::cell::RefCell;
use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::io::Write;
use std::sync::Mutex;
use unity_rs::helpers::tpk::{get_tpk_typetree, TpkUnityNode};

thread_local! {
    /// Tracks types currently being generated to detect recursion
    static GENERATION_STACK: RefCell<Vec<String>> = RefCell::new(Vec::new());
}

/// Global caches for class and type information
/// Python equivalent: CLASS_CACHE_ID, CLASS_CACHE_NAME, TYPE_CACHE (lines 126-128)
static CLASS_CACHE_ID: Lazy<Mutex<HashMap<(usize, String), NodeClass>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));
static CLASS_CACHE_NAME: Lazy<Mutex<HashMap<String, NodeClass>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));
static TYPE_CACHE: Lazy<Mutex<HashMap<usize, String>>> = Lazy::new(|| Mutex::new(HashMap::new()));

// We need to import the TPK infrastructure from the main crate
// This will be added to Cargo.toml in the [[bin]] section

/// Maps Unity's primitive types to Rust types
/// Python equivalent: BASE_TYPE_MAP (lines 18-41)
fn get_base_type_map() -> HashMap<&'static str, &'static str> {
    let mut map = HashMap::new();

    // Integer types ‚Üí i32 or u32
    map.insert("char", "i8");
    map.insert("short", "i16");
    map.insert("int", "i32");
    map.insert("long long", "i64");
    map.insert("unsigned short", "u16");
    map.insert("unsigned int", "u32");
    map.insert("unsigned long long", "u64");
    map.insert("UInt8", "u8");
    map.insert("UInt16", "u16");
    map.insert("UInt32", "u32");
    map.insert("UInt64", "u64");
    map.insert("SInt8", "i8");
    map.insert("SInt16", "i16");
    map.insert("SInt32", "i32");
    map.insert("SInt64", "i64");
    map.insert("Type*", "u32");
    map.insert("FileSize", "u64");

    // Floating point types ‚Üí f32 or f64
    map.insert("float", "f32");
    map.insert("double", "f64");

    // Boolean ‚Üí bool
    map.insert("bool", "bool");

    // String ‚Üí String
    map.insert("string", "String");

    // Binary data ‚Üí Vec<u8>
    map.insert("TypelessData", "Vec<u8>");

    map
}

/// Classes that are defined in math.rs and shouldn't be regenerated
/// Python equivalent: MATH_CLASSES (lines 112-122)
fn get_math_classes() -> HashSet<&'static str> {
    let mut set = HashSet::new();
    set.insert("ColorRGBA");
    set.insert("Matrix3x4f");
    set.insert("Matrix4x4f");
    set.insert("Quaternionf");
    set.insert("Vector2f");
    set.insert("Vector3f");
    set.insert("Vector4f");
    set.insert("float3");
    set.insert("float4");
    set
}

fn map_math_type(typename: &str) -> &str {
    match typename {
        "Vector2f" => "Vector2",
        "Vector3f" => "Vector3",
        "Vector4f" => "Vector4",
        "ColorRGBA" => "Color",
        "Quaternionf" => "Quaternion",
        "Matrix4x4f" => "Matrix4x4",
        "Matrix3x4f" => "Matrix3x4",
        "float3" => "Vector3",
        "float4" => "Vector4",
        _ => typename,
    }
}

/// Classes that should not be generated (primitives, math types, etc.)
/// Python equivalent: FORBIDDEN_CLASSES (line 124)
fn get_forbidden_classes() -> HashSet<&'static str> {
    let mut set = get_math_classes();
    set.insert("bool");
    set.insert("float");
    set.insert("int");
    set.insert("void");
    set
}

/// Header template for the generated file
/// Python equivalent: GENERATED_HEADER (lines 43-88)
const GENERATED_HEADER: &str = r#"//! Generated Unity class definitions
//!
//! This file is auto-generated by ClassesGenerator.
//! Do not edit manually - changes will be overwritten.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use crate::classes::object::{ObjectInfo, ObjectReaderTrait};
use crate::classes::pptr::PPtrData;
use crate::math::*;

// Type alias: In Python, Object is used in PPtr[Object]
// In Rust, we alias ObjectInfo as Object for the same usage
pub type Object = ObjectInfo;

/// Macro to implement the Object trait for generated structs
/// This provides the same functionality as Python's Object inheritance
macro_rules! impl_object {
    ($struct_name:ident) => {
        impl crate::classes::object::Object for $struct_name {
            fn object_reader(&self) -> Option<&dyn ObjectReaderTrait> {
                self.object_reader.as_ref().map(|b| &**b as &dyn ObjectReaderTrait)
            }

            fn set_object_reader(&mut self, reader: Box<dyn ObjectReaderTrait>) {
                self.object_reader = Some(reader);
            }

            fn type_name(&self) -> &str {
                stringify!($struct_name)
            }

            fn as_any(&self) -> &dyn std::any::Any {
                self
            }

            fn to_json_value(&self) -> serde_json::Value {
                serde_json::to_value(self).unwrap_or_else(|_| serde_json::json!({}))
            }
        }
    };
}

"#;

/// Represents a field in a Unity class
/// Python equivalent: NodeClassField (lines 132-151)
#[derive(Debug, Clone)]
struct NodeClassField {
    /// Set of node IDs that define this field (for tracking versions)
    ids: HashSet<usize>,

    /// Field name (e.g., "m_Width", "m_Height")
    name: String,

    /// Set of possible types (usually just one, but can vary across versions)
    types: HashSet<String>,

    /// Whether this field is optional (not present in all Unity versions)
    optional: bool,
}

impl NodeClassField {
    fn new(id: usize, name: String) -> Self {
        NodeClassField {
            ids: {
                let mut set = HashSet::new();
                set.insert(id);
                set
            },
            name,
            types: HashSet::new(),
            optional: true,
        }
    }

    /// Generates the Rust field definition
    /// Python equivalent: generate_str() lines 138-147
    fn generate_str(&self) -> String {
        // Determine the type string
        let type_str = if self.types.len() == 1 {
            self.types.iter().next().unwrap().clone()
        } else {
            // Multiple types - use an enum or pick the most common one
            // For now, we'll just pick the first one alphabetically
            let mut types_vec: Vec<_> = self.types.iter().collect();
            types_vec.sort();
            types_vec[0].clone()
        };

        // Generate field with optional wrapper if needed
        if self.optional {
            format!("    pub {}: Option<{}>,", self.clean_name(), type_str)
        } else {
            format!("    pub {}: {},", self.clean_name(), type_str)
        }
    }

    /// Cleans the field name (handles reserved keywords, invalid chars, etc.)
    /// Python equivalent: clean_name property (lines 149-151) + TypeTreeHelper.clean_name
    fn clean_name(&self) -> String {
        let mut name = self.name.clone();

        // Remove "(int&)" prefix if present
        if name.starts_with("(int&)") {
            name = name[6..].to_string();
        }

        // Remove "?" suffix if present
        if name.ends_with('?') {
            name = name[..name.len() - 1].to_string();
        }

        // Replace invalid Rust identifier characters with underscores
        // Replaces: spaces, dots, colons, hyphens, brackets
        name = name
            .chars()
            .map(|c| match c {
                ' ' | '.' | ':' | '-' | '[' | ']' => '_',
                _ => c,
            })
            .collect();

        // Handle Rust reserved keywords
        let name = match name.as_str() {
            "type" => "typ".to_string(),
            "ref" => "reference".to_string(),
            "mod" => "modifier".to_string(),
            "match" => "match_value".to_string(),
            "loop" => "loop_value".to_string(),
            "in" => "in_value".to_string(),
            "as" => "as_value".to_string(),
            "use" => "use_value".to_string(),
            _ => name,
        };

        // If starts with a digit, prefix with 'x'
        if name
            .chars()
            .next()
            .map(|c| c.is_ascii_digit())
            .unwrap_or(false)
        {
            format!("x{}", name)
        } else {
            name
        }
    }
}

/// Represents a Unity class (Texture2D, Mesh, MonoBehaviour, etc.)
/// Python equivalent: NodeClass (lines 154-194)
#[derive(Debug, Clone)]
struct NodeClass {
    /// Set of node IDs that define this class
    ids: HashSet<usize>,

    /// Class name (e.g., "Texture2D", "MonoBehaviour")
    name: String,

    /// Alternative names/aliases for this class
    aliases: HashSet<String>,

    /// Fields in this class (name ‚Üí field)
    fields: HashMap<String, NodeClassField>,

    /// Set of field node IDs we've already processed
    field_ids: HashSet<usize>,

    /// Fields that are present in the first version (key fields)
    key_fields: HashSet<String>,

    /// Whether this is an abstract class (no concrete instances)
    abstract_class: bool,

    /// Base class name (e.g., Texture2D extends Texture)
    base: Option<String>,
}

impl NodeClass {
    fn new(id: usize, name: String) -> Self {
        NodeClass {
            ids: {
                let mut set = HashSet::new();
                set.insert(id);
                set
            },
            name,
            aliases: HashSet::new(),
            fields: HashMap::new(),
            field_ids: HashSet::new(),
            key_fields: HashSet::new(),
            abstract_class: false,
            base: None,
        }
    }

    /// Generates the Rust struct definition
    /// Python equivalent: generate_str() lines 169-194
    fn generate_str(&self) -> String {
        let mut lines = Vec::new();

        // Generate struct header with derives (no Clone - we'll implement manually)
        // Default is needed for ClassIDTypeToClassMap
        // Note: We do NOT use serde(rename_all) because Unity's TypeTree field names
        // are already in the correct format (m_Name, m_BitsPerSample, etc.)
        // Use #[serde(default)] to gracefully handle missing/null fields across Unity versions
        lines.push("#[derive(Debug, serde::Deserialize, serde::Serialize, Default)]".to_string());
        lines.push("#[serde(default)]".to_string());

        // Struct definition with optional base class
        let struct_def = if let Some(ref base) = self.base {
            format!("pub struct {} {{  // extends {}", self.name, base)
        } else {
            format!("pub struct {} {{", self.name)
        };
        lines.push(struct_def);

        // Add object_reader field (for Object trait implementation)
        lines.push("    #[serde(skip)]".to_string());
        lines.push("    pub object_reader: Option<Box<dyn ObjectReaderTrait>>,".to_string());
        lines.push("".to_string()); // Blank line

        // Generate fields (sorted: non-optional first, then by name)
        let fields_vec: Vec<_> = if self.fields.is_empty() {
            lines.push("    // No additional fields".to_string());
            Vec::new()
        } else {
            let mut fields_vec: Vec<_> = self.fields.values().collect();
            fields_vec.sort_by(|a, b| {
                // Sort by: 1. non-optional before optional, 2. name
                match (a.optional, b.optional) {
                    (false, true) => std::cmp::Ordering::Less,
                    (true, false) => std::cmp::Ordering::Greater,
                    _ => a.clean_name().cmp(&b.clean_name()),
                }
            });

            for field in &fields_vec {
                lines.push(field.generate_str());
            }

            fields_vec
        };

        lines.push("}".to_string());
        lines.push("".to_string()); // Blank line

        // Generate Object trait implementation via macro
        lines.push(format!("impl_object!({});", self.name));
        lines.push("".to_string());

        // Generate Clone implementation (object_reader is always None after clone)
        lines.push(format!("impl Clone for {} {{", self.name));
        lines.push("    fn clone(&self) -> Self {".to_string());
        lines.push("        Self {".to_string());
        lines.push("            object_reader: None,".to_string());

        for field in fields_vec {
            let field_name = field.clean_name();
            lines.push(format!(
                "            {}: self.{}.clone(),",
                field_name, field_name
            ));
        }

        lines.push("        }".to_string());
        lines.push("    }".to_string());
        lines.push("}".to_string());

        lines.join("\n")
    }
}

/// Generates the Rust type string for a TPK node
/// Python equivalent: generate_field_type() lines 260-305
///
/// # Arguments
/// * `node_id` - Index into the node buffer
/// * `node` - The TpkUnityNode (or None to fetch from buffer)
/// * `nodes` - Reference to the node buffer
/// * `strings` - Reference to the string buffer
fn generate_field_type(
    node_id: usize,
    node: Option<&TpkUnityNode>,
    nodes: &[TpkUnityNode],
    strings: &[String],
    parent_class: Option<&str>,
) -> String {
    let node_ref = if let Some(n) = node {
        n
    } else {
        &nodes[node_id]
    };

    let typename = strings[node_ref.type_name as usize].clone();
    // Check if this type is in the generation stack (recursive reference)
    // Must check BEFORE cache to handle cycles properly
    let needs_box = GENERATION_STACK.with(|stack| stack.borrow().contains(&typename));

    // Check cache (but account for boxing)
    {
        let cache = TYPE_CACHE.lock().unwrap();
        if let Some(cached) = cache.get(&node_id) {
            if needs_box {
                return format!("Box<{}>", cached);
            } else {
                return cached.clone();
            }
        }
    }
    let base_type_map = get_base_type_map();

    let result = if let Some(&py_typ) = base_type_map.get(typename.as_str()) {
        // Base type mapping
        py_typ.to_string()
    } else if typename == "pair" {
        // Pair type ‚Üí Tuple[T1, T2]
        let typ1 = generate_field_type(
            node_ref.sub_nodes[0] as usize,
            None,
            nodes,
            strings,
            parent_class,
        );
        let typ2 = generate_field_type(
            node_ref.sub_nodes[1] as usize,
            None,
            nodes,
            strings,
            parent_class,
        );
        format!("({}, {})", typ1, typ2)
    } else if typename.starts_with("PPtr<") {
        // PPtr<T> ‚Üí PPtrData<T>, and map the inner type
        // Extract inner type: "PPtr<Vector3f>" -> "Vector3f"
        let inner_type = &typename[5..typename.len() - 1]; // Skip "PPtr<" and ">"
        let mapped_inner = map_math_type(inner_type);
        format!("PPtrData<{}>", mapped_inner)
    } else {
        // Check if it's a vector/array or custom class
        if !node_ref.sub_nodes.is_empty() {
            let subnode0 = &nodes[node_ref.sub_nodes[0] as usize];
            let subnode0_typename = strings[subnode0.type_name as usize].clone();

            if subnode0_typename == "Array" {
                // Vector type ‚Üí Vec<T>
                // Array structure: Array { size, data }
                if subnode0.sub_nodes.len() >= 2 {
                    let data_node_id = subnode0.sub_nodes[1] as usize;
                    let data_node = &nodes[data_node_id];
                    let data_typename = strings[data_node.type_name as usize].clone();

                    if let Some(&base_type) = base_type_map.get(data_typename.as_str()) {
                        format!("Vec<{}>", base_type)
                    } else {
                        let subtype = generate_field_type(
                            data_node_id,
                            Some(data_node),
                            nodes,
                            strings,
                            parent_class,
                        );
                        format!("Vec<{}>", subtype)
                    }
                } else {
                    // Fallback
                    map_math_type(&typename).to_string()
                }
            } else {
                // Custom class - process it
                implement_node_class(node_id, Some(node_ref), None, nodes, strings);
                let mapped_typename = map_math_type(&typename);

                // Check if this type is in the generation stack (recursive reference)
                let needs_box = GENERATION_STACK
                    .with(|stack| stack.borrow().contains(&mapped_typename.to_string()));

                if needs_box {
                    format!("Box<{}>", mapped_typename)
                } else {
                    mapped_typename.to_string()
                }
            }
        } else {
            // Custom class with no subnodes
            implement_node_class(node_id, Some(node_ref), None, nodes, strings);
            map_math_type(&typename).to_string()
        }
    };

    // Cache the result
    {
        let mut cache = TYPE_CACHE.lock().unwrap();
        cache.insert(node_id, result.clone());
    }

    // Apply Box wrapper if needed
    if needs_box {
        format!("Box<{}>", result)
    } else {
        result
    }
}

/// Processes a TPK node and builds a NodeClass with fields
/// Python equivalent: implement_node_class() lines 197-257
///
/// # Arguments
/// * `node_id` - Index into the node buffer
/// * `node` - The TpkUnityNode (or None to fetch from buffer)
/// * `override_name` - Optional name override for the class
/// * `nodes` - Reference to the node buffer
/// * `strings` - Reference to the string buffer
fn implement_node_class(
    node_id: usize,
    node: Option<&TpkUnityNode>,
    override_name: Option<&str>,
    nodes: &[TpkUnityNode],
    strings: &[String],
) -> NodeClass {
    // Get the node (from parameter or fetch from buffer)
    let node_ref = if let Some(n) = node {
        n
    } else {
        &nodes[node_id]
    };

    // Get class name (override or from node)
    let cls_name = if let Some(name) = override_name {
        name.to_string()
    } else {
        strings[node_ref.type_name as usize].clone()
    };

    // Check CLASS_CACHE_ID first
    {
        let cache = CLASS_CACHE_ID.lock().unwrap();
        if let Some(cls) = cache.get(&(node_id, cls_name.clone())) {
            return cls.clone();
        }
    }

    // Check CLASS_CACHE_NAME or create new
    let mut class_cache_name = CLASS_CACHE_NAME.lock().unwrap();
    let first_impl = !class_cache_name.contains_key(&cls_name);

    let mut cls = if first_impl {
        let new_cls = NodeClass::new(node_id, cls_name.clone());
        class_cache_name.insert(cls_name.clone(), new_cls.clone());
        new_cls
    } else {
        let mut existing = class_cache_name.get_mut(&cls_name).unwrap().clone();
        existing.ids.insert(node_id);
        existing
    };

    drop(class_cache_name); // Release lock

    // Push class name onto generation stack to detect cycles
    GENERATION_STACK.with(|stack| {
        stack.borrow_mut().push(cls_name.clone());
    });

    // Add alias if override_name differs from original
    if let Some(override_val) = override_name {
        let original_name = strings[node_ref.type_name as usize].clone();
        if override_val != original_name {
            cls.aliases.insert(original_name);
        }
    }

    // Process subnode fields
    let mut field_names = HashSet::new();
    for &subnode_id in &node_ref.sub_nodes {
        let subnode = &nodes[subnode_id as usize];
        let subname = strings[subnode.name as usize].clone();

        // Create a temporary field to get cleaned name
        let temp_field = NodeClassField::new(subnode_id as usize, subname.clone());
        let cleaned_name = temp_field.clean_name();

        field_names.insert(cleaned_name.clone());

        // Skip if we've already processed this field node
        if cls.field_ids.contains(&(subnode_id as usize)) {
            continue;
        }

        // Get or create field
        let field = cls
            .fields
            .entry(cleaned_name.clone())
            .or_insert_with(|| NodeClassField::new(subnode_id as usize, subname));

        field.ids.insert(subnode_id as usize);

        // Generate field type
        let field_type = generate_field_type(
            subnode_id as usize,
            Some(subnode),
            nodes,
            strings,
            Some(&cls_name),
        );
        field.types.insert(field_type);
    }

    // Add all subnodes to field_ids
    for &subnode_id in &node_ref.sub_nodes {
        cls.field_ids.insert(subnode_id as usize);
    }

    // Handle first implementation vs subsequent versions
    if first_impl {
        // First time seeing this class - make all fields Optional
        // Note: Unity's TypeTree format doesn't guarantee field presence across versions/platforms.
        // Fields can have null values in JSON even when marked as "required" in one version.
        // Making all fields Optional matches Python's runtime behavior and prevents deserialization errors.
        cls.key_fields = cls.fields.keys().cloned().collect();
        for field in cls.fields.values_mut() {
            field.optional = true; // Changed from false to true
        }
    } else {
        // Subsequent version - mark deprecated fields as optional
        let deprecated_fields: HashSet<_> =
            cls.key_fields.difference(&field_names).cloned().collect();
        cls.key_fields = cls
            .key_fields
            .difference(&deprecated_fields)
            .cloned()
            .collect();

        for deprecated_name in deprecated_fields {
            if let Some(field) = cls.fields.get_mut(&deprecated_name) {
                field.optional = true;
            }
        }
    }

    // Cache the result
    {
        let mut cache = CLASS_CACHE_ID.lock().unwrap();
        cache.insert((node_id, cls_name.clone()), cls.clone());
    }
    {
        let mut cache = CLASS_CACHE_NAME.lock().unwrap();
        cache.insert(cls_name, cls.clone());
    }

    // Pop from generation stack
    GENERATION_STACK.with(|stack| {
        stack.borrow_mut().pop();
    });

    cls
}

fn main() {
    println!("üîß UnityRs ClassesGenerator");
    println!("================================\n");

    // Step 1: Load TPK data from embedded resource
    println!("üì¶ Loading TPK database...");

    // Embed the TPK file at compile time (1.2MB)
    const TPK_BYTES: &[u8] = include_bytes!("../resources/uncompressed.tpk");

    // Initialize the global TPK_TYPE_TREE
    unity_rs::helpers::tpk::init_from_bytes(TPK_BYTES)
        .expect("Failed to initialize TPK from embedded data");

    // Now get the initialized TPK data
    let tpk = match get_tpk_typetree() {
        Ok(tree) => tree,
        Err(e) => {
            eprintln!("‚ùå Failed to load TPK: {}", e);
            std::process::exit(1);
        }
    };

    let nodes = &tpk.node_buffer.nodes;
    let strings = &tpk.string_buffer.strings;
    println!(
        "   ‚úì Loaded {} nodes, {} strings",
        nodes.len(),
        strings.len()
    );

    // Step 2: Process all Unity classes
    println!("\nüî® Processing Unity classes...");
    let mut main_classes: HashSet<String> = HashSet::new();
    let mut deps: HashMap<String, Vec<String>> = HashMap::new();

    for (&class_id, class_info) in &tpk.class_information {
        let mut abstract_class = true;
        let mut base: Option<String> = None;
        let mut cls_name: Option<String> = None;

        for (version, unity_class_opt) in &class_info.classes {
            if let Some(unity_class) = unity_class_opt {
                cls_name = Some(strings[unity_class.name as usize].clone());
                base = Some(strings[unity_class.base as usize].clone());

                // If release_root_node exists, it's not abstract
                if let Some(release_root_node) = unity_class.release_root_node {
                    abstract_class = false;
                    let cls = implement_node_class(
                        release_root_node as usize,
                        None,
                        cls_name.as_deref(),
                        nodes,
                        strings,
                    );

                    // Update base
                    let mut cache = CLASS_CACHE_NAME.lock().unwrap();
                    if let Some(cached_cls) = cache.get_mut(cls_name.as_ref().unwrap()) {
                        cached_cls.base = base.clone();
                    }
                }
            }
        }

        // Register class and dependencies
        if let Some(ref name) = cls_name {
            if abstract_class {
                // Create abstract class entry
                let mut cache = CLASS_CACHE_NAME.lock().unwrap();
                if !cache.contains_key(name) {
                    let mut cls = NodeClass::new(0, name.clone());
                    cls.abstract_class = true;
                    cls.base = base.clone();
                    cache.insert(name.clone(), cls);
                }
            }

            main_classes.insert(name.clone());

            // Track inheritance dependencies
            if let Some(ref base_name) = base {
                deps.entry(base_name.clone())
                    .or_insert_with(Vec::new)
                    .push(name.clone());
            }
        }
    }

    println!("   ‚úì Processed {} Unity classes", main_classes.len());

    // Step 3: Sort classes by inheritance (topological sort)
    println!("\nüìã Sorting by inheritance...");
    let mut cache = CLASS_CACHE_NAME.lock().unwrap();
    cache.remove("Object");
    let forbidden = get_forbidden_classes();

    // Remove "Object" from deps and use it as root
    let mut sorted_classes: Vec<String> = Vec::new();
    let mut stack: Vec<String> = if let Some(mut object_children) = deps.remove("Object") {
        object_children.sort();
        object_children
    } else {
        Vec::new()
    };

    // Topological sort using FIFO queue (Python uses pop(0))
    while !stack.is_empty() {
        let cls_name = stack.remove(0); // Pop from FRONT (FIFO) - matches Python pop(0)
        sorted_classes.push(cls_name.clone());
        if let Some(mut children) = deps.remove(&cls_name) {
            children.sort();
            // Prepend children to front (matches Python: sorted(...) + stack)
            children.extend(stack);
            stack = children;
        }
    }

    // Add remaining classes not in hierarchy
    let mut remaining: Vec<_> = cache
        .keys()
        .filter(|k| !sorted_classes.contains(k) && !forbidden.contains(k.as_str()))
        .cloned()
        .collect();
    remaining.sort();
    sorted_classes.extend(remaining);

    // Remove duplicates
    let mut seen = HashSet::new();
    sorted_classes.retain(|name| seen.insert(name.clone()));

    println!("   ‚úì Sorted {} classes", sorted_classes.len());

    // Step 4: Generate output file
    println!("\nüìù Writing generated.rs...");
    let output_path = "src/classes/generated.rs";
    let mut file = File::create(output_path).expect("Failed to create output file");

    // Write header
    file.write_all(GENERATED_HEADER.as_bytes())
        .expect("Failed to write header");

    // Write classes
    for cls_name in sorted_classes {
        if let Some(cls) = cache.get(&cls_name) {
            let class_str = cls.generate_str();
            file.write_all(class_str.as_bytes())
                .expect("Failed to write class");
            file.write_all(b"\n\n").expect("Failed to write newline");
        }
    }

    println!("   ‚úì Wrote to {}", output_path);
    println!("\n‚úÖ Code generation complete!");
}
