//! ClassIDMapGenerator - Generates mapping from ClassIDType to class structs
//!
//! This generator:
//! 1. Reads ClassIDType enum variants from class_id_type.rs
//! 2. Verifies each variant has a corresponding struct in generated.rs
//! 3. Generates a match statement mapping enum variants to struct instances
//! 4. Outputs class_id_type_to_class_map.rs
//!
//! Usage: cargo run --bin class_id_map_generator

use regex::Regex;
use std::fs::{self, File};
use std::io::Write;

fn main() -> std::io::Result<()> {
    println!("üîß Generating ClassIDType to Class map...");

    // Step 1: Extract enum variants from class_id_type.rs
    let variants = extract_enum_variants("src/enums/class_id_type.rs")?;
    println!("‚úÖ Found {} ClassIDType variants", variants.len());

    // Step 2: Verify structs exist in generated.rs
    let (valid, missing) = verify_structs(&variants)?;
    println!("‚úÖ Verified {} struct mappings", valid.len());
    if !missing.is_empty() {
        println!("‚ö†Ô∏è  Warning: {} variants have no struct:", missing.len());
        for name in &missing {
            println!("    - {}", name);
        }
    }

    // Step 3: Generate the output file
    generate_map_file(&valid)?;
    println!(
        "‚úÖ Generated src/classes/class_id_type_to_class_map.rs ({} mappings)",
        valid.len()
    );

    // Step 4: Update mod.rs to export the new module
    update_mod_rs()?;
    println!("‚úÖ Updated src/classes/mod.rs");

    println!("\nüéâ Generation complete!");
    println!("üìù Next step: Run 'cargo build --lib' to verify compilation");

    Ok(())
}

/// Extracts enum variant names from class_id_type.rs
///
/// Parses lines like: "    GameObject = 1,"
/// Extracts: "GameObject"
fn extract_enum_variants(path: &str) -> std::io::Result<Vec<String>> {
    let content = fs::read_to_string(path)?;

    // Regex to match enum variants: "    VariantName = number,"
    let re = Regex::new(r"^\s+([A-Za-z0-9_]+)\s*=\s*[-0-9]+").unwrap();

    let variants: Vec<String> = content
        .lines()
        .filter_map(|line| {
            re.captures(line)
                .and_then(|cap| cap.get(1))
                .map(|m| m.as_str().to_string())
        })
        .filter(|name| name != "UnknownType") // Skip special case
        .collect();

    Ok(variants)
}

/// Verifies that each enum variant has a corresponding struct in generated.rs
///
/// Returns (valid_variants, missing_variants)
fn verify_structs(variants: &[String]) -> std::io::Result<(Vec<String>, Vec<String>)> {
    let generated = fs::read_to_string("src/classes/generated.rs")?;

    let mut valid = Vec::new();
    let mut missing = Vec::new();

    for variant in variants {
        // Check if "pub struct VariantName {" exists (word boundary check)
        // This prevents "Object" from matching "ObjectRolePair"
        if generated.contains(&format!("pub struct {} {{", variant)) {
            valid.push(variant.clone());
        } else {
            missing.push(variant.clone());
        }
    }

    Ok((valid, missing))
}

/// Generates the class_id_type_to_class_map.rs file
fn generate_map_file(variants: &[String]) -> std::io::Result<()> {
    let output_path = "src/classes/class_id_type_to_class_map.rs";
    let mut file = File::create(output_path)?;

    // Write file header
    writeln!(file, "// AUTO-GENERATED by class_id_map_generator.rs")?;
    writeln!(file, "// DO NOT EDIT MANUALLY")?;
    writeln!(file, "//")?;
    writeln!(
        file,
        "// This file maps Unity's ClassIDType enum to the corresponding"
    )?;
    writeln!(
        file,
        "// generated struct types. Each ClassIDType variant maps to a"
    )?;
    writeln!(file, "// struct instance that implements the Object trait.")?;
    writeln!(file, "//")?;
    writeln!(file, "// Total mappings: {}", variants.len())?;
    writeln!(file)?;

    // Write imports
    writeln!(file, "use crate::classes::generated::*;")?;
    writeln!(file, "use crate::classes::object::Object;")?;
    writeln!(file, "use crate::classes::unknown_object::UnknownObject;")?;
    writeln!(file, "use crate::enums::class_id_type::ClassIDType;")?;
    writeln!(file)?;

    // Write function documentation
    writeln!(
        file,
        "/// Maps ClassIDType enum variants to concrete struct instances"
    )?;
    writeln!(file, "///")?;
    writeln!(
        file,
        "/// This function creates a new instance of the appropriate Unity class"
    )?;
    writeln!(
        file,
        "/// based on the ClassIDType. All classes implement the Object trait,"
    )?;
    writeln!(file, "/// allowing for polymorphic handling.")?;
    writeln!(file, "///")?;
    writeln!(file, "/// # Arguments")?;
    writeln!(file, "///")?;
    writeln!(file, "/// * `class_id` - The Unity ClassIDType to map")?;
    writeln!(file, "///")?;
    writeln!(file, "/// # Returns")?;
    writeln!(file, "///")?;
    writeln!(
        file,
        "/// A `Box<dyn Object>` containing the corresponding struct instance."
    )?;
    writeln!(
        file,
        "/// If the ClassIDType is not mapped, returns an UnknownObject."
    )?;
    writeln!(file, "///")?;
    writeln!(file, "/// # Examples")?;
    writeln!(file, "///")?;
    writeln!(file, "/// ```ignore")?;
    writeln!(file, "/// use crate::enums::class_id_type::ClassIDType;")?;
    writeln!(
        file,
        "/// use crate::classes::class_id_type_to_class_map::get_class_for_type;"
    )?;
    writeln!(file, "///")?;
    writeln!(
        file,
        "/// let obj = get_class_for_type(ClassIDType::GameObject);"
    )?;
    writeln!(file, "/// assert_eq!(obj.type_name(), \"GameObject\");")?;
    writeln!(file, "/// ```")?;
    writeln!(file, "///")?;
    writeln!(file, "/// # Python equivalent")?;
    writeln!(file, "///")?;
    writeln!(
        file,
        "/// `ClassIDTypeToClassMap.py` - Dictionary mapping (lines 720-1088)"
    )?;
    writeln!(
        file,
        "pub fn get_class_for_type(class_id: ClassIDType) -> Box<dyn Object> {{"
    )?;
    writeln!(file, "    match class_id {{")?;

    // Write match arms (sorted alphabetically for readability)
    let mut sorted_variants = variants.to_vec();
    sorted_variants.sort();

    for variant in &sorted_variants {
        writeln!(
            file,
            "        ClassIDType::{} => Box::new({}::default()),",
            variant, variant
        )?;
    }

    // Write fallback case
    writeln!(file)?;
    writeln!(file, "        // Fallback for unknown/unmapped types")?;
    writeln!(
        file,
        "        // This includes UnknownType (-1) and any future ClassIDType variants"
    )?;
    writeln!(file, "        _ => {{")?;
    writeln!(file, "            eprintln!(\"Warning: No mapping for ClassIDType::{{:?}}, using UnknownObject\", class_id);")?;
    writeln!(file, "            Box::new(UnknownObject::default())")?;
    writeln!(file, "        }}")?;
    writeln!(file, "    }}")?;
    writeln!(file, "}}")?;
    writeln!(file)?;

    // Add helper function for checking if a type is mapped
    writeln!(
        file,
        "/// Checks if a ClassIDType has a corresponding struct mapping"
    )?;
    writeln!(file, "///")?;
    writeln!(file, "/// # Arguments")?;
    writeln!(file, "///")?;
    writeln!(file, "/// * `class_id` - The ClassIDType to check")?;
    writeln!(file, "///")?;
    writeln!(file, "/// # Returns")?;
    writeln!(file, "///")?;
    writeln!(
        file,
        "/// `true` if the ClassIDType has a direct struct mapping, `false` otherwise"
    )?;
    writeln!(file, "pub fn has_mapping(class_id: ClassIDType) -> bool {{")?;
    writeln!(file, "    matches!(")?;
    writeln!(file, "        class_id,")?;

    // Write all valid variants
    for (i, variant) in sorted_variants.iter().enumerate() {
        if i == sorted_variants.len() - 1 {
            writeln!(file, "        ClassIDType::{}", variant)?;
        } else {
            writeln!(file, "        ClassIDType::{} |", variant)?;
        }
    }

    writeln!(file, "    )")?;
    writeln!(file, "}}")?;

    // Add blank line
    writeln!(file)?;

    // ===== FUNCTION 1: get_class_id_from_name =====
    writeln!(file, "/// Converts a type name string to ClassIDType enum")?;
    writeln!(file, "///")?;
    writeln!(
        file,
        "/// Used by TypeTreeHelper to map node.m_Type strings to ClassIDType enums"
    )?;
    writeln!(file, "///")?;
    writeln!(file, "/// # Arguments")?;
    writeln!(file, "///")?;
    writeln!(
        file,
        "/// * `name` - The type name string (e.g., \\\"GameObject\\\", \\\"Mesh\\\")"
    )?;
    writeln!(file, "///")?;
    writeln!(file, "/// # Returns")?;
    writeln!(file, "///")?;
    writeln!(
        file,
        "/// `Some(ClassIDType)` if the name has a mapping, `None` otherwise"
    )?;
    writeln!(
        file,
        "pub fn get_class_id_from_name(name: &str) -> Option<ClassIDType> {{"
    )?;
    writeln!(file, "    match name {{")?;

    // Generate match arms for each variant
    for variant in &sorted_variants {
        writeln!(
            file,
            "        \"{}\" => Some(ClassIDType::{}),",
            variant, variant
        )?;
    }

    writeln!(file, "        _ => None,")?;
    writeln!(file, "    }}")?;
    writeln!(file, "}}")?;
    writeln!(file)?;

    // ===== FUNCTION 2: deserialize_typed_object =====
    writeln!(
        file,
        "/// Deserializes a JSON value into a typed Unity object"
    )?;
    writeln!(file, "///")?;
    writeln!(
        file,
        "/// Used by TypeTreeHelper to create typed objects (GameObject, Mesh, etc.)"
    )?;
    writeln!(file, "/// instead of generic UnknownObject instances.")?;
    writeln!(file, "///")?;
    writeln!(file, "/// # Arguments")?;
    writeln!(file, "///")?;
    writeln!(file, "/// * `class_id` - The ClassIDType enum variant")?;
    writeln!(
        file,
        "/// * `json_value` - The serde_json::Value to deserialize from"
    )?;
    writeln!(file, "///")?;
    writeln!(file, "/// # Returns")?;
    writeln!(file, "///")?;
    writeln!(file, "/// `Ok(Box<dyn Object>)` with the typed object, or `Err(String)` if deserialization fails")?;
    writeln!(file, "///")?;
    writeln!(file, "/// # Python equivalent")?;
    writeln!(file, "///")?;
    writeln!(
        file,
        "/// `TypeTreeHelper.py` line 241: `value = clz(**value)`"
    )?;
    writeln!(file, "pub fn deserialize_typed_object(")?;
    writeln!(file, "    class_id: ClassIDType,")?;
    writeln!(file, "    json_value: serde_json::Value,")?;
    writeln!(file, ") -> Result<Box<dyn Object>, String> {{")?;
    writeln!(file, "    use serde_json::from_value;")?;
    writeln!(file)?;
    writeln!(file, "    match class_id {{")?;

    // Generate match arms for each variant
    for variant in &sorted_variants {
        writeln!(file, "        ClassIDType::{} => {{", variant)?;
        writeln!(file, "            from_value::<{}>(json_value)", variant)?;
        writeln!(
            file,
            "                .map(|obj| Box::new(obj) as Box<dyn Object>)"
        )?;
        writeln!(
            file,
            "                .map_err(|e| format!(\"Failed to deserialize {}: {{}}\", e))",
            variant
        )?;
        writeln!(file, "        }}")?;
    }

    writeln!(file)?;
    writeln!(file, "        // Fallback for unmapped types")?;
    writeln!(
        file,
        "        _ => Err(format!(\"No struct mapping for ClassIDType::{{:?}}\", class_id)),"
    )?;
    writeln!(file, "    }}")?;
    writeln!(file, "}}")?;

    Ok(())
}

/// Updates src/classes/mod.rs to export the new module
fn update_mod_rs() -> std::io::Result<()> {
    let mod_path = "src/classes/mod.rs";
    let content = fs::read_to_string(mod_path)?;

    // Check if already exported
    if content.contains("pub mod class_id_type_to_class_map;") {
        println!("‚ÑπÔ∏è  mod.rs already exports class_id_type_to_class_map");
        return Ok(());
    }

    // Add the export
    let mut lines: Vec<&str> = content.lines().collect();

    // Find the right place to insert (after other pub mod declarations)
    let insert_pos = lines
        .iter()
        .rposition(|line| line.starts_with("pub mod"))
        .map(|pos| pos + 1)
        .unwrap_or(lines.len());

    lines.insert(insert_pos, "pub mod class_id_type_to_class_map;");

    // Write back
    let mut file = File::create(mod_path)?;
    for line in lines {
        writeln!(file, "{}", line)?;
    }

    Ok(())
}
